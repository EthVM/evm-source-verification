{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"bat.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract IERC20 {\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns\r\n    (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) public constant returns\r\n    (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256\r\n    _value);\r\n    event TransferFrom(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    function mintInvest(address from, address to, uint256 value) public;\r\n\r\n    function burnInvest(address from, uint256 value) public;\r\n\r\n}\r\n\r\n\r\ncontract IUNIGame {\r\n    function transferTokenV(uint256 _v) public;\r\n}\r\n\r\ncontract bat {\r\n    using SafeMath for uint256;\r\n    event Created(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    struct Order {\r\n        address addr;\r\n        uint256 amount;\r\n        uint256 startTime;\r\n        uint256 bonusAmount;\r\n        bool isEnd;\r\n        uint256 withdrawn;\r\n\r\n    }\r\n\r\n\r\n    struct User {\r\n        address upAddr;\r\n        uint256 checkPoint;\r\n        uint256 investAmount;\r\n        uint256 poolBonus;\r\n        uint256 dyBonus;\r\n        uint256 smBonus;\r\n        bool used;\r\n        uint256[] orderIndexArr;\r\n        address[] playerArr;\r\n        mapping(uint256 => uint256) teamInvestMap;\r\n\r\n        uint256 smRewardsAmount;\r\n        uint256 smInvestAmount;\r\n    }\r\n\r\n    struct SortBean {\r\n        address addr;\r\n        uint256 value;\r\n    }\r\n\r\n    uint256 ONE_DAY = 1 days;\r\n\r\n    //TODO \r\n    address tokenAddr = 0x5A947A3e5B62Cb571C056eC28293b32126E4d743;//\r\n    uint256 ONE_TOKEN = 1 * 10 ** 18;//\r\n    address foundationAddr = 0x4FE86109DB7B0fA397bF15E3d667A7B440725EaF;//\r\n    address devAddr = 0x0000000000000000000000000000000000000000;//\r\n    address lpGameAddr = 0xF4a7f38aF76041e4C75a5eCFf590d502A5B5AEa1;//\r\n    address ethRecAddr = 0xDeDac392ff406836Aa945d8C8d3420F0357cdBC7;//\r\n    //TODO \r\n\r\n\r\n    address owner;//\r\n\r\n    Order[] orderArr;\r\n    mapping(address => User) userMap;\r\n    address[]userArr;\r\n\r\n    uint256 smTotal;\r\n    uint256 investTotal;\r\n    uint256 bonusPoolAmount;\r\n\r\n\r\n    uint256 gameStartTime;\r\n\r\n    uint256 settlementTime;\r\n\r\n\r\n\r\n    constructor(uint256 beginTime)public{\r\n        owner = msg.sender;\r\n        emit Created(msg.sender, address(this), now);\r\n        if (beginTime == 0) {\r\n            gameStartTime = now;\r\n            settlementTime = now;\r\n        } else {\r\n            gameStartTime = beginTime;\r\n            settlementTime = beginTime;\r\n        }\r\n        User storage user = userMap[owner];\r\n        user.used = true;\r\n        userArr.push(owner);\r\n\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    function showTimes() public view returns (uint256, uint256, uint256){\r\n        return (gameStartTime, 0, 0);\r\n    }\r\n\r\n\r\n    function checkUpAddr(address _upAddr) internal {\r\n        if (userMap[msg.sender].upAddr == address(0)) {\r\n            if (userMap[_upAddr].used) {\r\n                userMap[msg.sender].upAddr = _upAddr;\r\n            } else {\r\n                userMap[msg.sender].upAddr = owner;\r\n            }\r\n\r\n            userMap[userMap[msg.sender].upAddr].playerArr.push(msg.sender);\r\n            userArr.push(msg.sender);\r\n            userMap[msg.sender].used = true;\r\n        }\r\n    }\r\n\r\n    function testInvestEvent(uint256 _value) internal {\r\n        IERC20 token = IERC20(tokenAddr);\r\n        token.mintInvest(address(this), foundationAddr, _value * 15 / 1000);\r\n        token.mintInvest(address(this), devAddr, _value * 15 / 1000);\r\n        token.mintInvest(address(this), lpGameAddr, _value * 51 / 100);\r\n        IUNIGame uni = IUNIGame(lpGameAddr);\r\n        uni.transferTokenV(_value * 51 / 100);\r\n    }\r\n\r\n\r\n    function testsm(address _addr) public payable {\r\n        (uint256 curRound,,) = getRound();\r\n        require(curRound != 0, \"time not\");\r\n        require(curRound < 4, \" time end \");\r\n        uint256 tempValue = 1 ether / 10;\r\n        require(msg.value >= tempValue, \"more 0.1\");\r\n        require(msg.value % tempValue == 0, \"0.1 multiples\");\r\n\r\n\r\n        {\r\n            uint256 smRe;\r\n            uint256 smInv;\r\n            (smRe, smInv) = getSmRealTokenAmount333(curRound, msg.value);\r\n            User storage user = userMap[msg.sender];\r\n            user.smRewardsAmount += smRe;\r\n            user.smInvestAmount += smInv;\r\n        }\r\n        //\r\n        checkUpAddr(_addr);\r\n        smTotal += msg.value;\r\n        ethRecAddr.transfer(msg.value);\r\n    }\r\n\r\n    function withdrawsmInvest() public {\r\n        require(canSmWithdraw(), \"time not w\");\r\n        User storage user = userMap[msg.sender];\r\n        require(user.smInvestAmount > 0, \"not enough\");\r\n        IERC20 token = IERC20(tokenAddr);\r\n        token.mintInvest(address(this), msg.sender, user.smRewardsAmount);\r\n\r\n        uint256 _value = user.smInvestAmount;\r\n\r\n\r\n        user.smRewardsAmount = 0;\r\n        user.smInvestAmount = 0;\r\n\r\n        {\r\n\r\n            uint256 len = orderArr.length;\r\n            if (len > 0) {\r\n\r\n                uint256 keyBaseValue = _value * 26 / 100;\r\n                (uint256 totalKey, uint256 lastIndex) = getTotalKey();\r\n\r\n                for (uint256 i = lastIndex; i < len; i++) {\r\n                    Order storage order = orderArr[i];\r\n\r\n                    order.bonusAmount = order.bonusAmount + (order.amount * keyBaseValue / totalKey);\r\n                }\r\n            }\r\n        }\r\n\r\n        userMap[userMap[msg.sender].upAddr].teamInvestMap[settlementTime] += _value;\r\n\r\n        {\r\n            address lineAddr = user.upAddr;\r\n            for (uint256 k = 0; k < 2; k++) {\r\n\r\n                if (k == 0) {\r\n                    userMap[lineAddr].dyBonus = userMap[lineAddr].dyBonus + _value * 5 / 100;\r\n                } else {\r\n                    userMap[lineAddr].dyBonus = userMap[lineAddr].dyBonus + _value * 3 / 100;\r\n                }\r\n                lineAddr = userMap[lineAddr].upAddr;\r\n                if (lineAddr == address(0)) {\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        {\r\n\r\n            bonusPoolAmount += _value * 20 / 100;\r\n\r\n            testInvestEvent(_value);\r\n\r\n            user.orderIndexArr.push(orderArr.length);\r\n            Order memory newOrder = Order(msg.sender, _value, now, 0, false, 0);\r\n            orderArr.push(newOrder);\r\n        }\r\n    }\r\n\r\n\r\n    function testInvest(address _addr, uint256 _value) public {\r\n        require(canTokenInvest(), \"time not\");\r\n        IERC20 token = IERC20(tokenAddr);\r\n        require(token.balanceOf(msg.sender) > _value, \" not enough\");\r\n        require(_value >= ONE_TOKEN, \" min one\");\r\n        require(_value % ONE_TOKEN == 0, \"No decimals allowed\");\r\n        User storage user = userMap[msg.sender];\r\n\r\n        token.burnInvest(msg.sender, _value);\r\n        investTotal += _value;\r\n\r\n        {\r\n\r\n            uint256 len = orderArr.length;\r\n            if (len > 0) {\r\n\r\n                uint256 keyBaseValue = _value * 26 / 100;\r\n                (uint256 totalKey, uint256 lastIndex) = getTotalKey();\r\n\r\n                for (uint256 i = lastIndex; i < len; i++) {\r\n                    Order storage order = orderArr[i];\r\n\r\n                    order.bonusAmount = order.bonusAmount + (order.amount * keyBaseValue / totalKey);\r\n                }\r\n            }\r\n        }\r\n\r\n        checkUpAddr(_addr);\r\n\r\n        userMap[userMap[msg.sender].upAddr].teamInvestMap[settlementTime] += _value;\r\n\r\n        {\r\n            address lineAddr = user.upAddr;\r\n            for (uint256 k = 0; k < 2; k++) {\r\n\r\n                if (k == 0) {\r\n                    userMap[lineAddr].dyBonus = userMap[lineAddr].dyBonus + _value * 5 / 100;\r\n                } else {\r\n                    userMap[lineAddr].dyBonus = userMap[lineAddr].dyBonus + _value * 3 / 100;\r\n                }\r\n                lineAddr = userMap[lineAddr].upAddr;\r\n                if (lineAddr == address(0)) {\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        {\r\n\r\n            bonusPoolAmount += _value * 20 / 100;\r\n\r\n            testInvestEvent(_value);\r\n\r\n            user.orderIndexArr.push(orderArr.length);\r\n            Order memory newOrder = Order(msg.sender, _value, now, 0, false, 0);\r\n            orderArr.push(newOrder);\r\n        }\r\n    }\r\n\r\n\r\n    function settlementGame() public onlyOwner {\r\n        uint256 len = userArr.length;\r\n        if (len > 1) {\r\n            uint256 rankIndex = 1;\r\n            SortBean[] memory tempArr = new SortBean[](len);\r\n            for (uint256 i = 0; i < len; i++) {\r\n                address itemAddr = userArr[i];\r\n                uint256 itemAmount = getTeamInvest(itemAddr);\r\n                tempArr[i] = SortBean(itemAddr, itemAmount);\r\n            }\r\n\r\n            quickSortBean(tempArr, 0, int(len - 1));\r\n            //\r\n            uint end = len - 1;\r\n            uint start = 0;\r\n            if (len > 10) {\r\n                start = len - 10;\r\n            }\r\n\r\n\r\n            uint256 tempTotalBonus;\r\n            for (uint256 k = end; k >= start;) {\r\n\r\n                if (getTeamInvest(tempArr[k].addr) == 0) {\r\n                    break;\r\n                }\r\n\r\n                uint256 itemBonus = 0;\r\n                if (rankIndex == 1) {\r\n                    itemBonus = bonusPoolAmount * 20 / 100;\r\n                } else if (rankIndex == 2) {\r\n                    itemBonus = bonusPoolAmount * 10 / 100;\r\n                } else if (rankIndex == 3) {\r\n                    itemBonus = bonusPoolAmount * 5 / 100;\r\n                } else if (rankIndex >= 4 && rankIndex <= 10) {\r\n                    itemBonus = bonusPoolAmount * 30 / 7 / 100;\r\n                }\r\n\r\n                userMap[tempArr[k].addr].poolBonus += itemBonus;\r\n                tempTotalBonus += itemBonus;\r\n                rankIndex++;\r\n\r\n                if (k == 0) {\r\n                    break;\r\n                } else {\r\n                    k--;\r\n                }\r\n            }\r\n            bonusPoolAmount -= tempTotalBonus;\r\n            settlementTime = now;\r\n        }\r\n    }\r\n\r\n\r\n    function withdrawBonus() public {\r\n        require(canSmWithdraw(), \"time not\");\r\n        User  storage user = userMap[msg.sender];\r\n        IERC20 token = IERC20(tokenAddr);\r\n        uint256 total = getStaticBonusWithdraw(msg.sender);\r\n        total += user.poolBonus + user.dyBonus;\r\n        require(total > 0, \"no bonus\");\r\n        token.mintInvest(address(this), msg.sender, total);\r\n        user.checkPoint = now;\r\n        user.poolBonus = 0;\r\n        user.dyBonus = 0;\r\n    }\r\n\r\n\r\n    function withdrawEth(address _addr, uint256 _value) public onlyOwner {\r\n        _addr.transfer(_value);\r\n    }\r\n\r\n    function withdrawToken(address _token, address _to, uint256 _value) public onlyOwner {\r\n        safeTransfer(_token, _to, _value);\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        bytes4 id = bytes4(keccak256(\"transfer(address,uint256)\"));\r\n        bool success = token.call(id, to, value);\r\n        require(success, 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n    //\r\n    //\r\n    function showSysInfo() public view returns (uint256, uint256, uint256, uint256){\r\n        (uint256 totalKey,) = getTotalKey();\r\n        return (smTotal, totalKey, bonusPoolAmount, investTotal);\r\n    }\r\n    //\r\n    //\r\n    function showUserInfo(address _addr) public view returns (uint256, uint256){\r\n        User  memory user = userMap[_addr];\r\n        return (user.smRewardsAmount, user.smInvestAmount);\r\n    }\r\n    //\r\n    function showUserInfoNew(address _addr) public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256){\r\n        uint256 staticAmount = getStaticBonus(_addr);\r\n        uint256 teamInvestTotalAmount = getTeamInvest(_addr);\r\n        uint256 selfTotalAmount = getInvestAmount(_addr);\r\n        User  memory user = userMap[_addr];\r\n        (uint256 t1,uint256 t2) = getTeamPlayerCount(_addr);\r\n        return (user.dyBonus, user.poolBonus, staticAmount, teamInvestTotalAmount, selfTotalAmount, t1, t2);\r\n    }\r\n\r\n    function showSmInfo(address _addr) public view returns (uint256, uint256){\r\n        User  memory user = userMap[_addr];\r\n        return (user.smRewardsAmount, user.smInvestAmount);\r\n    }\r\n\r\n    function showRankInfo() public view returns (address[], uint256[], uint256){\r\n        uint256 len = userArr.length;\r\n        if (len > 1) {\r\n\r\n            SortBean[] memory tempArr = new SortBean[](len);\r\n            for (uint256 i = 0; i < len; i++) {\r\n                address itemAddr = userArr[i];\r\n                uint256 itemAmount = getTeamInvest(itemAddr);\r\n                tempArr[i] = SortBean(itemAddr, itemAmount);\r\n            }\r\n            quickSortBean(tempArr, 0, int(len - 1));\r\n            //\r\n            uint end = len - 1;\r\n            uint start = 0;\r\n            if (len > 10) {\r\n                start = len - 10;\r\n            }\r\n\r\n            address[] memory addrArr = new address[](10);\r\n            uint256[] memory valArr = new uint256[](10);\r\n\r\n            uint256 rankIndex = 0;\r\n            for (uint256 k = end; k >= start;) {\r\n                if (tempArr[k].value == 0) {\r\n                    break;\r\n                }\r\n                addrArr[rankIndex] = tempArr[k].addr;\r\n                valArr[rankIndex] = tempArr[k].value;\r\n\r\n                rankIndex++;\r\n\r\n                if (k == 0) {\r\n                    break;\r\n                } else {\r\n                    k--;\r\n                }\r\n            }\r\n            return (addrArr, valArr, rankIndex);\r\n\r\n        } else {\r\n            uint256[] memory v1r = new uint256[](1);\r\n            v1r[0] = getTeamInvest(userArr[0]);\r\n            return (userArr, v1r, 1);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function getTeamInvest(address _addr) public view returns (uint256){\r\n        User storage user = userMap[_addr];\r\n        return user.teamInvestMap[settlementTime];\r\n    }\r\n\r\n    function getTeamPlayerCount(address _addr) public view returns (uint256, uint256){\r\n        User memory user = userMap[_addr];\r\n        uint256 countV1 = 0;\r\n        uint256 countV2 = 0;\r\n        if (user.playerArr.length > 0) {\r\n            uint oneLen = user.playerArr.length;\r\n            countV1 = oneLen;\r\n            for (uint256 i = 0; i < oneLen; i++) {\r\n                countV2 += userMap[user.playerArr[i]].playerArr.length;\r\n            }\r\n        }\r\n        return (countV1, countV2);\r\n    }\r\n\r\n    function getTeamAddr(address _addr) public view returns (address[]){\r\n        return userMap[_addr].playerArr;\r\n    }\r\n\r\n    function getUpAddr(address _addr) public view returns (address){\r\n        return userMap[_addr].upAddr;\r\n    }\r\n\r\n    function getInvestAmount(address _addr) public view returns (uint256){\r\n        User memory user = userMap[_addr];\r\n        uint256 orderLen = user.orderIndexArr.length;\r\n        uint256 total = 0;\r\n        if (orderLen > 0) {\r\n            for (uint256 i = orderLen - 1; i >= 0;) {\r\n                Order memory od = orderArr[user.orderIndexArr[i]];\r\n                if (od.isEnd) {\r\n                    break;\r\n                }\r\n                uint256 out = od.amount * 150 / 100;\r\n                uint256 iday = (now - od.startTime) / ONE_DAY;\r\n                uint256 iamount = iday * od.amount * 5 / 100;\r\n                if (iamount + od.bonusAmount < out) {\r\n                    total += od.amount;\r\n                }\r\n\r\n                if (i == 0) {\r\n                    break;\r\n                } else {\r\n                    i--;\r\n                }\r\n\r\n            }\r\n        }\r\n        return total;\r\n    }\r\n\r\n    function getStaticBonus(address _addr) public view returns (uint256){\r\n        User memory user = userMap[_addr];\r\n        uint256 orderLen = user.orderIndexArr.length;\r\n        uint256 total = 0;\r\n        if (orderLen > 0) {\r\n            for (uint256 i = orderLen - 1; i >= 0;) {\r\n                Order memory od = orderArr[user.orderIndexArr[i]];\r\n                if (od.isEnd) {\r\n                    break;\r\n                }\r\n                uint256 out = od.amount * 150 / 100;\r\n                if (od.startTime > user.checkPoint) {\r\n                    uint256 iday = (now - od.startTime) / ONE_DAY;\r\n                    uint256 iamount = iday * od.amount * 5 / 100;\r\n                    if (iamount + od.bonusAmount > out) {\r\n                        total += out;\r\n                    } else {\r\n                        total += iamount + od.bonusAmount;\r\n                    }\r\n                } else {\r\n                    uint256 iday2 = (now - od.startTime) / ONE_DAY;\r\n                    uint256 iamount2 = iday2 * od.amount * 5 / 100;\r\n                    uint256 tempTotal = 0;\r\n                    if (iamount2 + od.bonusAmount > out) {\r\n                        tempTotal += out;\r\n                    } else {\r\n                        tempTotal += iamount + od.bonusAmount;\r\n                    }\r\n                    total += tempTotal - od.withdrawn;\r\n                }\r\n\r\n                if (i == 0) {\r\n                    break;\r\n                } else {\r\n                    i--;\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n\r\n        return total;\r\n\r\n\r\n    }\r\n\r\n    function getStaticBonusWithdraw(address _addr) public returns (uint256){\r\n        User memory user = userMap[_addr];\r\n        uint256 orderLen = user.orderIndexArr.length;\r\n        uint256 total = 0;\r\n        if (orderLen > 0) {\r\n            for (uint256 i = orderLen - 1; i >= 0;) {\r\n                Order storage od = orderArr[user.orderIndexArr[i]];\r\n                if (od.isEnd) {\r\n                    break;\r\n                }\r\n                uint256 out = od.amount * 150 / 100;\r\n                uint256 newWithdrawAmount;\r\n                bool endAfter = false;\r\n                uint256 iday = (now - od.startTime) / ONE_DAY;\r\n                uint256 iamount = iday * od.amount * 5 / 100;\r\n                if (od.startTime > user.checkPoint) {\r\n                    if (iamount + od.bonusAmount >= out) {\r\n                        total += out;\r\n                        newWithdrawAmount = out;\r\n                        endAfter = true;\r\n                    } else {\r\n                        total += iamount + od.bonusAmount;\r\n                        newWithdrawAmount = iamount + od.bonusAmount;\r\n                    }\r\n                } else {\r\n                    uint256 tempTotal = 0;\r\n                    if (iamount + od.bonusAmount >= out) {\r\n                        tempTotal += out;\r\n                        endAfter = true;\r\n                    } else {\r\n                        tempTotal += iamount + od.bonusAmount;\r\n                    }\r\n                    total += tempTotal - od.withdrawn;\r\n                    newWithdrawAmount = tempTotal - od.withdrawn;\r\n                }\r\n                od.withdrawn += newWithdrawAmount;\r\n                if (endAfter) {\r\n                    od.isEnd = true;\r\n                }\r\n\r\n                if (i == 0) {\r\n                    break;\r\n                } else {\r\n                    i--;\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n\r\n        return total;\r\n\r\n\r\n    }\r\n\r\n\r\n    function getIntervalDay(uint256 startTime) public view returns (uint256){\r\n        if (startTime > now) {\r\n            return 0;\r\n        }\r\n        return (now - startTime) / ONE_DAY;\r\n    }\r\n\r\n    function getTotalKey() public view returns (uint256, uint256){\r\n        uint256 len = orderArr.length;\r\n        if (len == 0) {\r\n            return (0, 0);\r\n        }\r\n        uint256 totalKey = 0;\r\n        uint256 lastIndex = 0;\r\n        for (uint256 i = len - 1; i >= 0;) {\r\n            Order memory order = orderArr[i];\r\n            uint256 total = order.amount * 150 / 100;\r\n            uint256 daysAmount = order.amount * 5 / 100 * getIntervalDay(order.startTime);\r\n            uint256 temp = daysAmount + order.bonusAmount;\r\n\r\n            if (temp >= total || order.isEnd) {\r\n                lastIndex = i + 1;\r\n                break;\r\n            }\r\n\r\n            totalKey += order.amount;\r\n            if (i == 0) {\r\n                break;\r\n            } else {\r\n                i--;\r\n            }\r\n        }\r\n        return (totalKey, lastIndex);\r\n    }\r\n\r\n\r\n    function getOrderBonus(uint256 index) public view returns (uint256){\r\n        if (index > orderArr.length) {\r\n            return 0;\r\n        }\r\n\r\n        Order memory order = orderArr[index];\r\n        if (order.isEnd) {\r\n            return 0;\r\n        }\r\n        uint256 total = order.amount * 150 / 100;\r\n        uint256 daysAmount = order.amount * 5 / 100 * getIntervalDay(order.startTime);\r\n        uint256 temp = daysAmount + order.bonusAmount;\r\n        if (temp > total) {\r\n            return total;\r\n        }\r\n        return temp;\r\n    }\r\n\r\n\r\n    function getSmRealTokenAmount333(uint256 curRound, uint256 inputAmount) internal pure returns (uint256, uint256){\r\n        (uint256 rate1,uint256 rate2) = getEthRate(curRound);\r\n        return (inputAmount * rate1, inputAmount * rate2);\r\n    }\r\n\r\n    function getEthRate(uint256 round) public pure returns (uint256, uint256){\r\n        if (round < 1 || round > 3) {\r\n            return (0, 0);\r\n        }\r\n        if (round == 1) {\r\n            return (10, 10);\r\n        }\r\n        if (round == 2) {\r\n            return (7, 10);\r\n        }\r\n        if (round == 3) {\r\n            return (5, 10);\r\n        }\r\n        return (0, 0);\r\n    }\r\n\r\n\r\n    function quickSortBean(SortBean[] memory arr, int left, int right) internal {\r\n        int i = left;\r\n        int j = right;\r\n        if (i == j) return;\r\n        uint pivot = arr[uint(left + (right - left) / 2)].value;\r\n        while (i <= j) {\r\n            while (arr[uint(i)].value < pivot) i++;\r\n            while (pivot < arr[uint(j)].value) j--;\r\n            if (i <= j) {\r\n                (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n        if (left < j)\r\n            quickSortBean(arr, left, j);\r\n        if (i < right)\r\n            quickSortBean(arr, i, right);\r\n    }\r\n\r\n\r\n    function getRound() public view returns (uint256, uint256, uint256){\r\n        if (now < gameStartTime) {\r\n            return (0, gameStartTime, now);\r\n        }\r\n        uint256 diff = now - gameStartTime;\r\n        if (diff <= 2 * ONE_DAY) {\r\n            return (1, gameStartTime, now);\r\n        }\r\n        if (diff <= 4 * ONE_DAY) {\r\n            return (2, gameStartTime, now);\r\n        }\r\n        if (diff <= 11 * ONE_DAY) {\r\n            return (3, gameStartTime, now);\r\n        }\r\n        return (4, gameStartTime, now);\r\n    }\r\n\r\n    function canSmWithdraw() public view returns (bool){\r\n        if (now < gameStartTime) {\r\n            return false;\r\n        }\r\n        if (now - gameStartTime <= 4 * ONE_DAY) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    function canTokenInvest() public view returns (bool){\r\n        if (now < gameStartTime) {\r\n            return false;\r\n        }\r\n        if (now - gameStartTime <= 10 * ONE_DAY) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n}"}}}