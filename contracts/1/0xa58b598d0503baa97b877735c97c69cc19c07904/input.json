{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "./contracts/lib/Adminable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { Storage } from \"./Storage.sol\";\n\n/**\n * @title Adminable\n * @author dYdX\n *\n * @dev EIP-1967 Proxy Admin contract.\n */\ncontract Adminable {\n    /**\n     * @dev Storage slot with the admin of the contract.\n     *  This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    bytes32 internal constant ADMIN_SLOT =\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n    * @dev Modifier to check whether the `msg.sender` is the admin.\n    *  If it is, it will run the function. Otherwise, it will revert.\n    */\n    modifier onlyAdmin() {\n        require(\n            msg.sender == getAdmin(),\n            \"Adminable: caller is not admin\"\n        );\n        _;\n    }\n\n    /**\n     * @return The EIP-1967 proxy admin\n     */\n    function getAdmin()\n        public\n        view\n        returns (address)\n    {\n        return address(uint160(uint256(Storage.load(ADMIN_SLOT))));\n    }\n}"
    },
    "./contracts/lib/Amount.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {Math} from \"../lib/Math.sol\";\n\nlibrary Amount {\n\n    using Math for uint256;\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    uint256 constant BASE = 10**18;\n\n    // A Principal Amount is an amount that's been adjusted by an index\n\n    struct Principal {\n        bool sign; // true if positive\n        uint256 value;\n    }\n\n    function zero()\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return Principal({\n            sign: false,\n            value: 0\n        });\n    }\n\n    function sub(\n        Principal memory a,\n        Principal memory b\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return add(a, negative(b));\n    }\n\n    function add(\n        Principal memory a,\n        Principal memory b\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        Principal memory result;\n\n        if (a.sign == b.sign) {\n            result.sign = a.sign;\n            result.value = SafeMath.add(a.value, b.value);\n        } else {\n            if (a.value >= b.value) {\n                result.sign = a.sign;\n                result.value = SafeMath.sub(a.value, b.value);\n            } else {\n                result.sign = b.sign;\n                result.value = SafeMath.sub(b.value, a.value);\n            }\n        }\n        return result;\n    }\n\n    function equals(\n        Principal memory a,\n        Principal memory b\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        if (a.value == b.value) {\n            if (a.value == 0) {\n                return true;\n            }\n            return a.sign == b.sign;\n        }\n        return false;\n    }\n\n    function negative(\n        Principal memory a\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return Principal({\n            sign: !a.sign,\n            value: a.value\n        });\n    }\n\n    function calculateAdjusted(\n        Principal memory a,\n        uint256 index\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(a.value, index, BASE);\n    }\n\n    function calculatePrincipal(\n        uint256 value,\n        uint256 index,\n        bool sign\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return Principal({\n            sign: sign,\n            value: Math.getPartial(value, BASE, index)\n        });\n    }\n\n}\n"
    },
    "./contracts/lib/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"./SafeMath.sol\";\n\n/**\n * @title Math\n *\n * Library for non-standard Math functions\n */\nlibrary Math {\n    using SafeMath for uint256;\n\n    // ============ Library Functions ============\n\n    /*\n     * Return target * (numerator / denominator).\n     */\n    function getPartial(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return target.mul(numerator).div(denominator);\n    }\n\n    function to128(\n        uint256 number\n    )\n        internal\n        pure\n        returns (uint128)\n    {\n        uint128 result = uint128(number);\n        require(\n            result == number,\n            \"Math: Unsafe cast to uint128\"\n        );\n        return result;\n    }\n\n    function min(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function max(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a > b ? a : b;\n    }\n}\n"
    },
    "./contracts/lib/SafeMath.sol": {
      "content": "\npragma solidity ^0.5.16;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "./contracts/lib/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nlibrary Storage {\n\n    /**\n     * @dev Performs an SLOAD and returns the data in the slot.\n     */\n    function load(\n        bytes32 slot\n    )\n        internal\n        view\n        returns (bytes32)\n    {\n        bytes32 result;\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            result := sload(slot)\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs an SSTORE to save the value to the slot.\n     */\n    function store(\n        bytes32 slot,\n        bytes32 value\n    )\n        internal\n    {\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            sstore(slot, value)\n        }\n    }\n}"
    },
    "./contracts/synthetic/SyntheticStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {Amount} from \"../lib/Amount.sol\";\n\ncontract SyntheticStorageV1 {\n\n    /* solium-disable-next-line */\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /**\n     * @dev ERC20 Properties\n     */\n    string  internal _name;\n    string  internal _symbol;\n    uint256 internal _totalSupply;\n    string  internal _version;\n\n    mapping (address => uint256)                      internal _balances;\n    mapping (address => mapping (address => uint256)) internal _allowances;\n\n    /**\n     * @dev Permittable Properties\n     */\n    bytes32                      public DOMAIN_SEPARATOR;\n    mapping (address => uint256) public permitNonces;\n\n    /**\n     * @dev Minter Properties\n     */\n    address[]                            internal _mintersArray;\n    mapping(address => bool)             internal _minters;\n    mapping(address => uint256)          internal _minterLimits;\n    mapping(address => Amount.Principal) internal _minterIssued;\n}\n\ncontract SyntheticStorage is SyntheticStorageV1 { /* solium-disable-line no-empty-blocks */ }\n"
    },
    "./contracts/synthetic/SyntheticTokenV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"../token/IERC20.sol\";\n\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {Amount} from \"../lib/Amount.sol\";\n\nimport {SyntheticStorage} from \"./SyntheticStorage.sol\";\n\nimport {Adminable} from \"../lib/Adminable.sol\";\n\ncontract SyntheticTokenV1 is Adminable, SyntheticStorage, IERC20 {\n\n    using SafeMath for uint256;\n    using Amount for Amount.Principal;\n\n    /* ========== Events ========== */\n\n    event MinterAdded(address _minter, uint256 _limit);\n\n    event MinterRemoved(address _minter);\n\n    event MinterLimitUpdated(address _minter, uint256 _limit);\n\n    event InitCalled();\n\n    /* ========== Modifiers ========== */\n\n    modifier onlyMinter() {\n        require(\n            _minters[msg.sender] == true,\n            \"SyntheticToken: only callable by minter\"\n        );\n        _;\n    }\n\n    /* ========== Init Function ========== */\n\n    /**\n     * @dev Initialise the synthetic token\n     *\n     * @param name The name of the token\n     * @param symbol The symbol of the token\n     * @param version The version number of this token\n     */\n    function init(\n        string memory name,\n        string memory symbol,\n        string memory version\n    )\n        public\n        onlyAdmin\n    {\n        _name = name;\n        _symbol = symbol;\n        _version = version;\n\n        DOMAIN_SEPARATOR = initDomainSeparator(name, version);\n\n        emit InitCalled();\n    }\n\n    /* ========== View Functions ========== */\n\n    function name()\n        external\n        view\n        returns (string memory)\n    {\n        return _name;\n    }\n\n    function symbol()\n        external\n        view\n        returns (string memory)\n    {\n        return _symbol;\n    }\n\n    function decimals()\n        external\n        pure\n        returns (uint8)\n    {\n        return 18;\n    }\n\n    function version()\n        external\n        view\n        returns (string memory)\n    {\n        return _version;\n    }\n\n    function totalSupply()\n        public\n        view\n        returns (uint256)\n    {\n        return _totalSupply;\n    }\n\n    function balanceOf(\n        address account\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function getAllMinters()\n        external\n        view\n        returns (address[] memory)\n    {\n        return _mintersArray;\n    }\n\n    function isValidMinter(\n        address _minter\n    )\n        external\n        view\n        returns (bool)\n    {\n        return _minters[_minter];\n    }\n\n    function getMinterIssued(\n        address _minter\n    )\n        external\n        view\n        returns (Amount.Principal memory)\n    {\n        return _minterIssued[_minter];\n    }\n\n    function getMinterLimit(\n        address _minter\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _minterLimits[_minter];\n    }\n\n    /* ========== Admin Functions ========== */\n\n    /**\n     * @dev Add a new minter to the synthetic token.\n     *\n     * @param _minter The address of the minter to add\n     * @param _limit The starting limit for how much this synth can mint\n     */\n    function addMinter(\n        address _minter,\n        uint256 _limit\n    )\n        external\n        onlyAdmin\n    {\n        require(\n            _minters[_minter] != true,\n            \"SyntheticToken: Minter already exists\"\n        );\n\n        _mintersArray.push(_minter);\n        _minters[_minter] = true;\n        _minterLimits[_minter] = _limit;\n\n        emit MinterAdded(_minter, _limit);\n    }\n\n    /**\n     * @dev Remove a minter from the synthetic token\n     *\n     * @param _minter Address to remove the minter\n     */\n    function removeMinter(\n        address _minter\n    )\n        external\n        onlyAdmin\n    {\n        require(\n            _minters[_minter] == true,\n            \"SyntheticToken: minter does not exist\"\n        );\n\n        for (uint i = 0; i < _mintersArray.length; i++) {\n            if (address(_mintersArray[i]) == _minter) {\n                delete _mintersArray[i];\n                _mintersArray[i] = _mintersArray[_mintersArray.length - 1];\n                _mintersArray.length--;\n\n                break;\n            }\n        }\n\n        delete _minters[_minter];\n        delete _minterLimits[_minter];\n\n        emit MinterRemoved(_minter);\n    }\n\n    /**\n     * @dev Update the limit of the minter\n     *\n     * @param _minter The address of the minter to set\n     * @param _limit The new limit to set for this address\n     */\n    function updateMinterLimit(\n        address _minter,\n        uint256 _limit\n    )\n        public\n        onlyAdmin\n    {\n        require(\n            _minters[_minter] == true,\n            \"SyntheticToken: minter does not exist\"\n        );\n\n        _minterLimits[_minter] = _limit;\n\n        emit MinterLimitUpdated(_minter, _limit);\n    }\n\n    /* ========== Minter Functions ========== */\n\n    /**\n     * @dev Mint synthetic tokens\n     *\n     * @notice Can only be called by a valid minter.\n     *\n     * @param to The destination to mint the synth to\n     * @param value The amount of synths to mint\n     */\n    function mint(\n        address to,\n        uint256 value\n    )\n        external\n        onlyMinter\n    {\n        Amount.Principal memory issuedAmount = _minterIssued[msg.sender].add(\n            Amount.Principal({ sign: true, value: value })\n        );\n\n        require(\n            issuedAmount.value <= _minterLimits[msg.sender] || issuedAmount.sign == false,\n            \"SyntheticToken: minter limit reached\"\n        );\n\n        _minterIssued[msg.sender] = issuedAmount;\n        _mint(to, value);\n    }\n\n    /**\n     * @dev Burn synthetic tokens\n     *\n     * @notice Can only be called by a valid minter.\n     *\n     * @param from The destination to burn the synth from\n     * @param value The amount of the synth to burn\n     */\n    function burn(\n        address from,\n        uint256 value\n    )\n        external\n        onlyMinter\n    {\n        _minterIssued[msg.sender] = _minterIssued[msg.sender].sub(\n            Amount.Principal({ sign: true, value: value })\n        );\n\n        _burn(from, value);\n    }\n\n    /**\n     * @dev Transfer any collateral held to another address\n     *\n     * @param token The address of the token to transfer\n     * @param to The destination to send the collateral to\n     * @param value The amount of the tokens to transfer\n     */\n    function transferCollateral(\n        address token,\n        address to,\n        uint256 value\n    )\n        external\n        onlyMinter\n        returns (bool)\n    {\n        return IERC20(token).transfer(\n            to,\n            value\n        );\n    }\n\n    /* ========== ERC20 Functions ========== */\n\n    function transfer(\n        address recipient,\n        uint256 amount\n    )\n        public\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(\n        address spender,\n        uint256 amount\n    )\n        public\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        public\n        returns (bool)\n    {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            _allowances[sender][msg.sender].sub(amount)\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * assuming the latter's signed approval.\n     *\n     * IMPORTANT: The same issues Erc20 `approve` has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the Eip712-formatted function arguments.\n     * - The signature must use `owner`'s current nonce.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8   v,\n        bytes32 r,\n        bytes32 s\n    )\n        public\n    {\n\n        require(\n            deadline == 0 || deadline >= block.timestamp,\n            \"SyntheticToken: Permit expired\"\n        );\n\n        require(\n            spender != address(0),\n            \"SyntheticToken: spender cannot be 0x0\"\n        );\n\n        require(\n            value > 0,\n            \"SyntheticToken: approval value must be greater than 0\"\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                    PERMIT_TYPEHASH,\n                    owner,\n                    spender,\n                    value,\n                    permitNonces[owner]++,\n                    deadline\n                )\n            )\n        ));\n\n        address recoveredAddress = ecrecover(\n            digest,\n            v,\n            r,\n            s\n        );\n\n        require(\n            recoveredAddress != address(0) && owner == recoveredAddress,\n            \"SyntheticToken: Signature invalid\"\n        );\n\n    }\n\n    /* ========== Internal Functions ========== */\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        internal\n    {\n        require(\n            sender != address(0),\n            \"SyntheticToken: transfer from the zero address\"\n        );\n\n        require(\n            recipient != address(0),\n            \"SyntheticToken: transfer to the zero address\"\n        );\n\n        _balances[sender] = _balances[sender].sub(amount);\n\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(\n        address account,\n        uint256 amount\n    )\n        internal\n    {\n        require(\n            account != address(0),\n            \"SyntheticToken: mint to the zero address\"\n        );\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(\n        address account,\n        uint256 amount\n    )\n        internal\n    {\n        require(\n            account != address(0),\n            \"SyntheticToken: burn from the zero address\"\n        );\n\n        _balances[account] = _balances[account].sub(amount);\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    )\n        internal\n    {\n        require(\n            owner != address(0),\n            \"SyntheticToken: approve from the zero address\"\n        );\n\n        require(\n            spender != address(0),\n            \"SyntheticToken: approve to the zero address\"\n        );\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /* ========== Private Functions ========== */\n\n    /**\n     * @dev Initializes EIP712 DOMAIN_SEPARATOR based on the current contract and chain ID.\n     */\n    function initDomainSeparator(\n        string memory name,\n        string memory version\n    )\n        private\n        returns (bytes32)\n    {\n        uint256 chainID;\n        /* solium-disable-next-line */\n        assembly {\n            chainID := chainid()\n        }\n\n        return keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                chainID,\n                address(this)\n            )\n        );\n    }\n}\n"
    },
    "./contracts/token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    )\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(\n        address spender,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    }
  }
}