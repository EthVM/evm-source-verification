{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/interfaces/IACOPool.sol":{"content":"pragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './IERC20.sol';\r\n\r\ninterface IACOPool is IERC20 {\r\n    struct InitData {\r\n        uint256 poolStart;\r\n        address acoFlashExercise;\r\n        address acoFactory;\r\n        address chiToken;\r\n        uint256 fee;\r\n        address feeDestination;\r\n        address underlying;\r\n        address strikeAsset;\r\n        uint256 minStrikePrice; \r\n        uint256 maxStrikePrice;\r\n        uint256 minExpiration;\r\n        uint256 maxExpiration;\r\n        bool isCall; \r\n        bool canBuy;\r\n        address strategy;\r\n        uint256 baseVolatility;    \r\n    }\r\n    \r\n\tfunction init(InitData calldata initData) external;\r\n    function numberOfACOTokensCurrentlyNegotiated() external view returns(uint256);\r\n    function collateral() external view returns(address);\r\n    function setStrategy(address strategy) external;\r\n    function setBaseVolatility(uint256 baseVolatility) external;\r\n    function quote(bool isBuying, address acoToken, uint256 tokenAmount) external view returns(uint256 swapPrice, uint256 fee, uint256 underlyingPrice);\r\n    function swap(bool isBuying, address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external returns(uint256);\r\n    function swapWithGasToken(bool isBuying, address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external returns(uint256);\r\n    function exerciseACOToken(address acoToken) external;\r\n    function redeemACOTokens() external;\r\n\tfunction redeemACOToken(address acoToken) external;\r\n    function deposit(uint256 collateralAmount, address to) external payable returns(uint256 acoPoolTokenAmount);\r\n    function redeem() external returns(uint256 underlyingReceived, uint256 strikeAssetReceived);\r\n    function redeemFrom(address account) external returns(uint256 underlyingReceived, uint256 strikeAssetReceived);\r\n    function restoreCollateral() external;\r\n}"},"localhost/interfaces/IERC20.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"},"localhost/libs/Address.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n"},"localhost/periphery/pool/ACOPoolFactory.sol":{"content":"pragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../../libs/Address.sol\";\r\nimport \"../../interfaces/IACOPool.sol\";\r\n\r\n/**\r\n * @title ACOPoolFactory\r\n * @dev The contract is the implementation for the ACOProxy.\r\n */\r\ncontract ACOPoolFactory {\r\n    \r\n    /**\r\n     * @dev Struct to store the ACO pool basic data.\r\n     */\r\n    struct ACOPoolData {\r\n        /**\r\n         * @dev The UNIX time that the ACO pool can start negotiated ACO tokens.\r\n         */\r\n        uint256 poolStart;\r\n        \r\n        /**\r\n         * @dev Address of the underlying asset (0x0 for Ethereum).\r\n         */\r\n        address underlying;\r\n        \r\n        /**\r\n         * @dev Address of the strike asset (0x0 for Ethereum).\r\n         */\r\n        address strikeAsset;\r\n        \r\n        /**\r\n         * @dev True if the type is CALL, false for PUT.\r\n         */\r\n        bool isCall;\r\n        \r\n        /**\r\n         * @dev The minimum strike price allowed with the strike asset precision.\r\n         */\r\n        uint256 minStrikePrice;\r\n        \r\n        /**\r\n         * @dev The maximum strike price allowed with the strike asset precision.\r\n         */\r\n        uint256 maxStrikePrice;\r\n        \r\n        /**\r\n         * @dev The minimum UNIX time for the ACO token expiration.\r\n         */\r\n        uint256 minExpiration;\r\n        \r\n        /**\r\n         * @dev The maximum UNIX time for the ACO token expiration.\r\n         */\r\n        uint256 maxExpiration;\r\n        \r\n        /**\r\n         * @dev Whether the pool buys ACO tokens otherwise, it only sells.\r\n         */\r\n        bool canBuy;\r\n    }\r\n    \r\n    /**\r\n     * @dev Emitted when the factory admin address has been changed.\r\n     * @param previousFactoryAdmin Address of the previous factory admin.\r\n     * @param newFactoryAdmin Address of the new factory admin.\r\n     */\r\n    event SetFactoryAdmin(address indexed previousFactoryAdmin, address indexed newFactoryAdmin);\r\n    \r\n    /**\r\n     * @dev Emitted when the ACO pool implementation has been changed.\r\n     * @param previousAcoPoolImplementation Address of the previous ACO pool implementation.\r\n     * @param previousAcoPoolImplementation Address of the new ACO pool implementation.\r\n     */\r\n    event SetAcoPoolImplementation(address indexed previousAcoPoolImplementation, address indexed newAcoPoolImplementation);\r\n    \r\n    /**\r\n     * @dev Emitted when the ACO factory has been changed.\r\n     * @param previousAcoFactory Address of the previous ACO factory.\r\n     * @param newAcoFactory Address of the new ACO factory.\r\n     */\r\n    event SetAcoFactory(address indexed previousAcoFactory, address indexed newAcoFactory);\r\n    \r\n    /**\r\n     * @dev Emitted when the Chi Token has been changed.\r\n     * @param previousChiToken Address of the previous Chi Token.\r\n     * @param newChiToken Address of the new Chi Token.\r\n     */\r\n    event SetChiToken(address indexed previousChiToken, address indexed newChiToken);\r\n    \r\n    /**\r\n     * @dev Emitted when the ACO fee has been changed.\r\n     * @param previousAcoFlashExercise Address of the previous ACO flash exercise.\r\n     * @param newAcoFlashExercise Address of the new ACO flash exercise.\r\n     */\r\n    event SetAcoFlashExercise(address indexed previousAcoFlashExercise, address indexed newAcoFlashExercise);\r\n    \r\n    /**\r\n     * @dev Emitted when the ACO Pool fee has been changed.\r\n     * @param previousAcoFee Value of the previous ACO Pool fee.\r\n     * @param newAcoFee Value of the new ACO Pool fee.\r\n     */\r\n    event SetAcoPoolFee(uint256 indexed previousAcoFee, uint256 indexed newAcoFee);\r\n    \r\n    /**\r\n     * @dev Emitted when the ACO Pool fee destination address has been changed.\r\n     * @param previousAcoPoolFeeDestination Address of the previous ACO Pool fee destination.\r\n     * @param newAcoPoolFeeDestination Address of the new ACO Pool fee destination.\r\n     */\r\n    event SetAcoPoolFeeDestination(address indexed previousAcoPoolFeeDestination, address indexed newAcoPoolFeeDestination);\r\n    \r\n    /**\r\n     * @dev Emitted when permission for an ACO pool admin has been changed.\r\n     * @param poolAdmin Address of the ACO pool admin.\r\n     * @param previousPermission The previous permission situation.\r\n     * @param newPermission The new permission situation.\r\n     */\r\n    event SetAcoPoolPermission(address indexed poolAdmin, bool indexed previousPermission, bool indexed newPermission);\r\n    \r\n    /**\r\n     * @dev Emitted when a strategy permission has been changed.\r\n     * @param strategy Address of the strategy.\r\n     * @param previousPermission The previous strategy permission.\r\n     * @param newPermission The new strategy permission.\r\n     */\r\n    event SetStrategyPermission(address indexed strategy, bool indexed previousPermission, bool newPermission);\r\n\r\n    /**\r\n     * @dev Emitted when a new ACO pool has been created.\r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall True if the type is CALL, false for PUT.\r\n     * @param poolStart The UNIX time that the ACO pool can start negotiated ACO tokens.\r\n     * @param minStrikePrice The minimum strike price for ACO tokens with the strike asset precision.\r\n     * @param maxStrikePrice The maximum strike price for ACO tokens with the strike asset precision.\r\n     * @param minExpiration The minimum expiration time for ACO tokens.\r\n     * @param maxExpiration The maximum expiration time for ACO tokens.\r\n     * @param canBuy Whether the pool buys ACO tokens otherwise, it only sells.\r\n     * @param acoPool Address of the new ACO pool created.\r\n     * @param acoPoolImplementation Address of the ACO pool implementation used on creation.\r\n     */\r\n    event NewAcoPool(address indexed underlying, address indexed strikeAsset, bool indexed isCall, uint256 poolStart, uint256 minStrikePrice, uint256 maxStrikePrice, uint256 minExpiration, uint256 maxExpiration, bool canBuy, address acoPool, address acoPoolImplementation);\r\n    \r\n    /**\r\n     * @dev The factory admin address.\r\n     */\r\n    address public factoryAdmin;\r\n    \r\n    /**\r\n     * @dev The ACO pool implementation address.\r\n     */\r\n    address public acoPoolImplementation;\r\n    \r\n    /**\r\n     * @dev The ACO factory address.\r\n     */\r\n    address public acoFactory;\r\n    \r\n    /**\r\n     * @dev The ACO flash exercise address.\r\n     */\r\n    address public acoFlashExercise;\r\n    \r\n    /**\r\n     * @dev The Chi Token address.\r\n     */\r\n    address public chiToken;\r\n    \r\n    /**\r\n     * @dev The ACO Pool fee value. \r\n     * It is a percentage value (100000 is 100%).\r\n     */\r\n    uint256 public acoPoolFee;\r\n    \r\n    /**\r\n     * @dev The ACO Pool fee destination address.\r\n     */\r\n    address public acoPoolFeeDestination;\r\n    \r\n    /**\r\n     * @dev The ACO pool admin permissions.\r\n     */\r\n    mapping(address => bool) public poolAdminPermission;\r\n    \r\n    /**\r\n     * @dev The strategies permitted.\r\n     */\r\n    mapping(address => bool) public strategyPermitted;\r\n    \r\n    /**\r\n     * @dev The ACO pool basic data.\r\n     */\r\n    mapping(address => ACOPoolData) public acoPoolData;\r\n    \r\n    /**\r\n     * @dev Modifier to check if the `msg.sender` is the factory admin.\r\n     * Only factory admin address can execute.\r\n     */\r\n    modifier onlyFactoryAdmin() {\r\n        require(msg.sender == factoryAdmin, \"ACOPoolFactory::onlyFactoryAdmin\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Modifier to check if the `msg.sender` is a pool admin.\r\n     * Only a pool admin address can execute.\r\n     */\r\n    modifier onlyPoolAdmin() {\r\n        require(poolAdminPermission[msg.sender], \"ACOPoolFactory::onlyPoolAdmin\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to initialize the contract.\r\n     * It should be called through the `data` argument when creating the proxy.\r\n     * It must be called only once. The first `require` is to guarantee that behavior.\r\n     * @param _factoryAdmin Address of the factory admin.\r\n     * @param _acoPoolImplementation Address of the ACO pool implementation.\r\n     * @param _acoFactory Address of the ACO token factory.\r\n     * @param _acoFlashExercise Address of the ACO flash exercise.\r\n     */\r\n    function init(\r\n        address _factoryAdmin, \r\n        address _acoPoolImplementation, \r\n        address _acoFactory, \r\n        address _acoFlashExercise,\r\n        address _chiToken,\r\n        uint256 _acoPoolFee,\r\n        address _acoPoolFeeDestination\r\n    ) public {\r\n        require(factoryAdmin == address(0) && acoPoolImplementation == address(0), \"ACOPoolFactory::init: Contract already initialized.\");\r\n        \r\n        _setFactoryAdmin(_factoryAdmin);\r\n        _setAcoPoolImplementation(_acoPoolImplementation);\r\n        _setAcoFactory(_acoFactory);\r\n        _setAcoFlashExercise(_acoFlashExercise);\r\n        _setChiToken(_chiToken);\r\n        _setAcoPoolFee(_acoPoolFee);\r\n        _setAcoPoolFeeDestination(_acoPoolFeeDestination);\r\n        _setAcoPoolPermission(_factoryAdmin, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to guarantee that the contract will not receive ether.\r\n     */\r\n    receive() external payable virtual {\r\n        revert();\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to create a new ACO pool.\r\n     * It deploys a minimal proxy for the ACO pool implementation address. \r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall True if the type is CALL, false for PUT.\r\n     * @param poolStart The UNIX time that the ACO pool can start negotiated ACO tokens.\r\n     * @param minStrikePrice The minimum strike price for ACO tokens with the strike asset precision.\r\n     * @param maxStrikePrice The maximum strike price for ACO tokens with the strike asset precision.\r\n     * @param minExpiration The minimum expiration time for ACO tokens.\r\n     * @param maxExpiration The maximum expiration time for ACO tokens.\r\n     * @param canBuy Whether the pool buys ACO tokens otherwise, it only sells.\r\n     * @param strategy Address of the pool strategy to be used.\r\n     * @param baseVolatility The base volatility for the pool starts. It is a percentage value (100000 is 100%).\r\n     * @return The created ACO pool address.\r\n     */\r\n    function createAcoPool(\r\n        address underlying, \r\n        address strikeAsset, \r\n        bool isCall,\r\n        uint256 poolStart,\r\n        uint256 minStrikePrice,\r\n        uint256 maxStrikePrice,\r\n        uint256 minExpiration,\r\n        uint256 maxExpiration,\r\n        bool canBuy,\r\n        address strategy,\r\n        uint256 baseVolatility\r\n    ) onlyFactoryAdmin external virtual returns(address) {\r\n        _validateStrategy(strategy);\r\n        return _createAcoPool(IACOPool.InitData(\r\n            poolStart,\r\n            acoFlashExercise,\r\n            acoFactory,\r\n            chiToken,\r\n            acoPoolFee,\r\n            acoPoolFeeDestination,\r\n            underlying, \r\n            strikeAsset,\r\n            minStrikePrice,\r\n            maxStrikePrice,\r\n            minExpiration,\r\n            maxExpiration,\r\n            isCall,\r\n            canBuy,\r\n            strategy,\r\n            baseVolatility\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * @dev Function to set the factory admin address.\r\n     * Only can be called by the factory admin.\r\n     * @param newFactoryAdmin Address of the new factory admin.\r\n     */\r\n    function setFactoryAdmin(address newFactoryAdmin) onlyFactoryAdmin external virtual {\r\n        _setFactoryAdmin(newFactoryAdmin);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the ACO pool implementation address.\r\n     * Only can be called by the factory admin.\r\n     * @param newAcoPoolImplementation Address of the new ACO pool implementation.\r\n     */\r\n    function setAcoPoolImplementation(address newAcoPoolImplementation) onlyFactoryAdmin external virtual {\r\n        _setAcoPoolImplementation(newAcoPoolImplementation);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the ACO factory address.\r\n     * Only can be called by the factory admin.\r\n     * @param newAcoFactory Address of the ACO token factory.\r\n     */\r\n    function setAcoFactory(address newAcoFactory) onlyFactoryAdmin external virtual {\r\n        _setAcoFactory(newAcoFactory);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the ACO flash exercise address.\r\n     * Only can be called by the factory admin.\r\n     * @param newAcoFlashExercise Address of the new ACO flash exercise.\r\n     */\r\n    function setAcoFlashExercise(address newAcoFlashExercise) onlyFactoryAdmin external virtual {\r\n        _setAcoFlashExercise(newAcoFlashExercise);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the Chi Token address.\r\n     * Only can be called by the factory admin.\r\n     * @param newChiToken Address of the new Chi Token.\r\n     */\r\n    function setChiToken(address newChiToken) onlyFactoryAdmin external virtual {\r\n        _setChiToken(newChiToken);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the ACO Pool fee.\r\n     * Only can be called by the factory admin.\r\n     * @param newAcoPoolFee Value of the new ACO Pool fee. It is a percentage value (100000 is 100%).\r\n     */\r\n    function setAcoPoolFee(uint256 newAcoPoolFee) onlyFactoryAdmin external virtual {\r\n        _setAcoPoolFee(newAcoPoolFee);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the ACO Pool destination address.\r\n     * Only can be called by the factory admin.\r\n     * @param newAcoPoolFeeDestination Address of the new ACO Pool destination.\r\n     */\r\n    function setAcoPoolFeeDestination(address newAcoPoolFeeDestination) onlyFactoryAdmin external virtual {\r\n        _setAcoPoolFeeDestination(newAcoPoolFeeDestination);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the ACO pool permission.\r\n     * Only can be called by the factory admin.\r\n     * @param poolAdmin Address of the pool admin.\r\n     * @param newPermission The permission to be set.\r\n     */\r\n    function setAcoPoolPermission(address poolAdmin, bool newPermission) onlyFactoryAdmin external virtual {\r\n        _setAcoPoolPermission(poolAdmin, newPermission);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the ACO pool strategies permitted.\r\n     * Only can be called by the factory admin.\r\n     * @param strategy Address of the strategy.\r\n     * @param newPermission The permission to be set.\r\n     */\r\n    function setAcoPoolStrategyPermission(address strategy, bool newPermission) onlyFactoryAdmin external virtual {\r\n        _setAcoPoolStrategyPermission(strategy, newPermission);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to change the ACO pools strategy.\r\n     * Only can be called by a pool admin.\r\n     * @param strategy Address of the strategy to be set.\r\n     * @param acoPools Array of ACO pools addresses.\r\n     */\r\n    function setAcoPoolStrategy(address strategy, address[] calldata acoPools) onlyPoolAdmin external virtual {\r\n        _setAcoPoolStrategy(strategy, acoPools);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to change the ACO pools base volatilities.\r\n     * Only can be called by a pool admin.\r\n     * @param baseVolatilities Array of the base volatilities to be set.\r\n     * @param acoPools Array of ACO pools addresses.\r\n     */\r\n    function setAcoPoolBaseVolatility(uint256[] calldata baseVolatilities, address[] calldata acoPools) onlyPoolAdmin external virtual {\r\n        _setAcoPoolBaseVolatility(baseVolatilities, acoPools);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the factory admin address.\r\n     * @param newFactoryAdmin Address of the new factory admin.\r\n     */\r\n    function _setFactoryAdmin(address newFactoryAdmin) internal virtual {\r\n        require(newFactoryAdmin != address(0), \"ACOPoolFactory::_setFactoryAdmin: Invalid factory admin\");\r\n        emit SetFactoryAdmin(factoryAdmin, newFactoryAdmin);\r\n        factoryAdmin = newFactoryAdmin;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the ACO pool implementation address.\r\n     * @param newAcoPoolImplementation Address of the new ACO pool implementation.\r\n     */\r\n    function _setAcoPoolImplementation(address newAcoPoolImplementation) internal virtual {\r\n        require(Address.isContract(newAcoPoolImplementation), \"ACOPoolFactory::_setAcoPoolImplementation: Invalid ACO pool implementation\");\r\n        emit SetAcoPoolImplementation(acoPoolImplementation, newAcoPoolImplementation);\r\n        acoPoolImplementation = newAcoPoolImplementation;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the ACO factory address.\r\n     * @param newAcoFactory Address of the new ACO token factory.\r\n     */\r\n    function _setAcoFactory(address newAcoFactory) internal virtual {\r\n        require(Address.isContract(newAcoFactory), \"ACOPoolFactory::_setAcoFactory: Invalid ACO factory\");\r\n        emit SetAcoFactory(acoFactory, newAcoFactory);\r\n        acoFactory = newAcoFactory;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the ACO flash exercise address.\r\n     * @param newAcoFlashExercise Address of the new ACO flash exercise.\r\n     */\r\n    function _setAcoFlashExercise(address newAcoFlashExercise) internal virtual {\r\n        require(Address.isContract(newAcoFlashExercise), \"ACOPoolFactory::_setAcoFlashExercise: Invalid ACO flash exercise\");\r\n        emit SetAcoFlashExercise(acoFlashExercise, newAcoFlashExercise);\r\n        acoFlashExercise = newAcoFlashExercise;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the Chi Token address.\r\n     * @param newChiToken Address of the new Chi Token.\r\n     */\r\n    function _setChiToken(address newChiToken) internal virtual {\r\n        require(Address.isContract(newChiToken), \"ACOPoolFactory::_setChiToken: Invalid Chi Token\");\r\n        emit SetAcoFlashExercise(chiToken, newChiToken);\r\n        chiToken = newChiToken;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the ACO Pool fee.\r\n     * @param newAcoPoolFee Value of the new ACO Pool fee. It is a percentage value (100000 is 100%).\r\n     */\r\n    function _setAcoPoolFee(uint256 newAcoPoolFee) internal virtual {\r\n        emit SetAcoPoolFee(acoPoolFee, newAcoPoolFee);\r\n        acoPoolFee = newAcoPoolFee;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the ACO Pool destination address.\r\n     * @param newAcoPoolFeeDestination Address of the new ACO Pool destination.\r\n     */\r\n    function _setAcoPoolFeeDestination(address newAcoPoolFeeDestination) internal virtual {\r\n        require(newAcoPoolFeeDestination != address(0), \"ACOFactory::_setAcoPoolFeeDestination: Invalid ACO Pool fee destination\");\r\n        emit SetAcoPoolFeeDestination(acoPoolFeeDestination, newAcoPoolFeeDestination);\r\n        acoPoolFeeDestination = newAcoPoolFeeDestination;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the ACO pool permission.\r\n     * @param poolAdmin Address of the pool admin.\r\n     * @param newPermission The permission to be set.\r\n     */\r\n    function _setAcoPoolPermission(address poolAdmin, bool newPermission) internal virtual {\r\n        emit SetAcoPoolPermission(poolAdmin, poolAdminPermission[poolAdmin], newPermission);\r\n        poolAdminPermission[poolAdmin] = newPermission;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the ACO pool strategies permitted.\r\n     * @param strategy Address of the strategy.\r\n     * @param newPermission The permission to be set.\r\n     */\r\n    function _setAcoPoolStrategyPermission(address strategy, bool newPermission) internal virtual {\r\n        require(Address.isContract(strategy), \"ACOPoolFactory::_setAcoPoolStrategy: Invalid strategy\");\r\n        emit SetStrategyPermission(strategy, strategyPermitted[strategy], newPermission);\r\n        strategyPermitted[strategy] = newPermission;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to validate strategy.\r\n     * @param strategy Address of the strategy.\r\n     */\r\n    function _validateStrategy(address strategy) view internal virtual {\r\n        require(strategyPermitted[strategy], \"ACOPoolFactory::_validateStrategy: Invalid strategy\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to change the ACO pools strategy.\r\n     * @param strategy Address of the strategy to be set.\r\n     * @param acoPools Array of ACO pools addresses.\r\n     */\r\n    function _setAcoPoolStrategy(address strategy, address[] memory acoPools) internal virtual {\r\n        _validateStrategy(strategy);\r\n        for (uint256 i = 0; i < acoPools.length; ++i) {\r\n            IACOPool(acoPools[i]).setStrategy(strategy);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to change the ACO pools base volatilities.\r\n     * @param baseVolatilities Array of the base volatilities to be set.\r\n     * @param acoPools Array of ACO pools addresses.\r\n     */\r\n    function _setAcoPoolBaseVolatility(uint256[] memory baseVolatilities, address[] memory acoPools) internal virtual {\r\n        require(baseVolatilities.length == acoPools.length, \"ACOPoolFactory::_setAcoPoolBaseVolatility: Invalid arguments\");\r\n        for (uint256 i = 0; i < acoPools.length; ++i) {\r\n            IACOPool(acoPools[i]).setBaseVolatility(baseVolatilities[i]);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to create a new ACO pool.\r\n     * @param initData Data to initialize o ACO Pool.\r\n     * @return Address of the new minimal proxy deployed for the ACO pool.\r\n     */\r\n    function _createAcoPool(IACOPool.InitData memory initData) internal virtual returns(address) {\r\n        address acoPool  = _deployAcoPool(initData);\r\n        acoPoolData[acoPool] = ACOPoolData(\r\n            initData.poolStart, \r\n            initData.underlying, \r\n            initData.strikeAsset, \r\n            initData.isCall, \r\n            initData.minStrikePrice, \r\n            initData.maxStrikePrice, \r\n            initData.minExpiration, \r\n            initData.maxExpiration, \r\n            initData.canBuy\r\n        );\r\n        emit NewAcoPool(\r\n            initData.underlying, \r\n            initData.strikeAsset, \r\n            initData.isCall, \r\n            initData.poolStart, \r\n            initData.minStrikePrice, \r\n            initData.maxStrikePrice, \r\n            initData.minExpiration, \r\n            initData.maxExpiration, \r\n            initData.canBuy, \r\n            acoPool, \r\n            acoPoolImplementation\r\n        );\r\n        return acoPool;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to deploy a minimal proxy using ACO pool implementation.\r\n     * @param initData Data to initialize o ACO Pool.\r\n     * @return Address of the new minimal proxy deployed for the ACO pool.\r\n     */\r\n    function _deployAcoPool(IACOPool.InitData memory initData) internal virtual returns(address) {\r\n        bytes20 implentationBytes = bytes20(acoPoolImplementation);\r\n        address proxy;\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), implentationBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            proxy := create(0, clone, 0x37)\r\n        }\r\n        IACOPool(proxy).init(initData);\r\n        return proxy;\r\n    }\r\n}"}}}