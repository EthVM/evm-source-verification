{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CUPIETHPOOL.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2020-11-27\r\n */\r\n\r\n// File: contracts/Interfaces.sol\r\n\r\n// SPDX-License-Identifier: --ðŸ¦‰--\r\npragma solidity =0.6.12;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function mint(address account, uint256 amount) external;\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\npragma solidity =0.6.12;\r\n\r\nlibrary SafeMathLT {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\npragma solidity =0.6.12;\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n\r\n\r\n            bytes32 accountHash\r\n         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account)\r\n        internal\r\n        pure\r\n        returns (address payable)\r\n    {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        // (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n}\r\n\r\npragma solidity =0.6.12;\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMathLT for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(\r\n            value\r\n        );\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value,\r\n            \"SafeERC20: decreased allowance below zero\"\r\n        );\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity =0.6.12;\r\n// pragma solidity =0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract CUPIETHPOOL {\r\n    using SafeMathLT for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 public mintedToken = IERC20(\r\n        0xe7D2914136E63f209f0e9De3100eD60ce18A3e8E\r\n    );\r\n\r\n    struct Difficulty {\r\n        uint256 EndedAt;\r\n        bool Exists;\r\n    }\r\n\r\n    struct Deposit {\r\n        uint256 Difficulty;\r\n        uint256 Amount;\r\n        uint256 DepositedAt;\r\n        bool Closed;\r\n        uint256 ClosedAt;\r\n    }\r\n\r\n    struct User {\r\n        bool Exists;\r\n        uint256 Balances;\r\n        Deposit[] Deposits;\r\n        address Referrer;\r\n        address[] Invited1st;\r\n        address[] Invited2nd;\r\n    }\r\n\r\n    struct Reward {\r\n        uint256 ClosedRewardTotal;\r\n        uint256 ClosedRewardUsed;\r\n        bool Stoped;\r\n        uint256 CurrentRewardUsed;\r\n        uint256 MintRewardTotal;\r\n        uint256 LastRewardAt;\r\n    }\r\n\r\n    uint256 public CONTRACT_STARTED_AT;\r\n    uint256 public CONTRACT_DEPOSIT_PERCENT = 20;\r\n    uint256 public CONTRACT_WITHDRAWN_PERCENT = 0;\r\n    uint256 public TOKEN_MINT_TOTAL = 15000000 * 1e18;\r\n    uint256 public TOKEN_MINT_USED = 0;\r\n    uint256 private TOTAL_BALANCE_SUPPLY = 0;\r\n    uint256 public CONTRACT_DIFFICULTY = 5 * 1e8;\r\n\r\n    mapping(uint256 => Difficulty) public DIFFICULTIES;\r\n    mapping(address => User) public USERS;\r\n    mapping(address => Reward) public REWARDS;\r\n    mapping(address => uint256) public BONUS;\r\n\r\n    address payable public CONTRACT_DEVELOPER;\r\n    address payable public CONTRACT_FOUNDATION;\r\n    address public CONTRACT_DEFAULT_REFERRER;\r\n    bool public CONTRACT_INITED = false;\r\n\r\n    uint256[] public REFERRAL_PERCENTS = [10, 5];\r\n    uint256[] public ALLDIFFICULTIES = [CONTRACT_DIFFICULTY];\r\n\r\n    event onStake(address indexed account, address referrer, uint256 amount);\r\n    event onReward(address indexed account, uint256 reward);\r\n    event onBouns(address indexed account, uint256 bouns);\r\n    event onWithdraw(address indexed account, uint256 amount);\r\n\r\n    modifier afterDeveloper() {\r\n        require(msg.sender == CONTRACT_DEVELOPER);\r\n        _;\r\n    }\r\n\r\n    modifier afterStarted() {\r\n        require(block.timestamp > CONTRACT_STARTED_AT, \"not start\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        CONTRACT_DEVELOPER = msg.sender;\r\n        CONTRACT_STARTED_AT = block.timestamp + 1 minutes;\r\n    }\r\n\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n\r\n    function _(\r\n        address account,\r\n        uint256 amount,\r\n        address referrer\r\n    ) internal {\r\n        if (referrer == account) {\r\n            referrer = CONTRACT_DEFAULT_REFERRER;\r\n        }\r\n\r\n        if (USERS[account].Exists == false) {\r\n            USERS[account].Referrer = referrer;\r\n\r\n            USERS[referrer].Invited1st.push(account);\r\n            USERS[USERS[referrer].Referrer].Invited2nd.push(account);\r\n        }\r\n\r\n        USERS[account].Deposits.push(\r\n            Deposit(CONTRACT_DIFFICULTY, amount, block.timestamp, false, 0)\r\n        );\r\n        USERS[account].Balances = USERS[account].Balances.add(amount);\r\n        TOTAL_BALANCE_SUPPLY = TOTAL_BALANCE_SUPPLY.add(amount);\r\n        USERS[account].Exists = true;\r\n\r\n        if (REWARDS[msg.sender].Stoped) {\r\n            getReward();\r\n        }\r\n\r\n        emit onStake(account, referrer, amount);\r\n    }\r\n\r\n    function stake(address referrer) external payable afterStarted {\r\n        require(referrer != address(0), \"referrer = address(0)\");\r\n        require(msg.value > 0, \"msg.value = 0\");\r\n\r\n        uint256 burnAmount = msg.value.mul(CONTRACT_DEPOSIT_PERCENT).div(100);\r\n        CONTRACT_FOUNDATION.transfer(burnAmount);\r\n\r\n        _(msg.sender, msg.value.sub(burnAmount), referrer);\r\n    }\r\n\r\n    function computeDifficulties(Deposit memory d)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 earnedAmount;\r\n        uint256 nextEndedAt = d.DepositedAt;\r\n\r\n        if (ALLDIFFICULTIES.length > 1) {\r\n            uint256 difficultyIndex = 0;\r\n            for (uint256 i = 0; i < ALLDIFFICULTIES.length; i++) {\r\n                if (ALLDIFFICULTIES[i] == d.Difficulty) {\r\n                    difficultyIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            for (uint256 i = difficultyIndex; i < ALLDIFFICULTIES.length; i++) {\r\n                if (DIFFICULTIES[ALLDIFFICULTIES[i]].Exists) {\r\n                    earnedAmount = earnedAmount.add(\r\n                        d.Amount.mul(\r\n                            DIFFICULTIES[ALLDIFFICULTIES[i]]\r\n                                .EndedAt\r\n                                .sub(nextEndedAt)\r\n                                .div(1 seconds)\r\n                                .mul(ALLDIFFICULTIES[i])\r\n                                .div(1e8)\r\n                        )\r\n                    );\r\n\r\n                    nextEndedAt = DIFFICULTIES[ALLDIFFICULTIES[i]].EndedAt;\r\n                }\r\n            }\r\n        }\r\n\r\n        earnedAmount = earnedAmount.add(\r\n            d\r\n                .Amount\r\n                .mul(block.timestamp.sub(nextEndedAt).div(1 seconds))\r\n                .mul(CONTRACT_DIFFICULTY)\r\n                .div(1e8)\r\n        );\r\n\r\n        return earnedAmount;\r\n    }\r\n\r\n    function _earned(address account) internal view returns (uint256) {\r\n        require(account != address(0), \"account = address(0)\");\r\n        require(\r\n            TOKEN_MINT_USED < TOKEN_MINT_TOTAL,\r\n            \"TOKEN_MINT_USED >= TOKEN_MINT_TOTAL\"\r\n        );\r\n\r\n        User memory u = USERS[account];\r\n\r\n        uint256 earnedAmount;\r\n\r\n        for (uint256 i = 0; i < u.Deposits.length; i++) {\r\n            Deposit memory d = u.Deposits[i];\r\n\r\n            if (d.Closed) {\r\n                continue;\r\n            }\r\n\r\n            earnedAmount = earnedAmount.add(computeDifficulties(d));\r\n        }\r\n\r\n        earnedAmount = earnedAmount.div(1 days);\r\n        earnedAmount = earnedAmount.add(\r\n            REWARDS[account].ClosedRewardTotal.sub(\r\n                REWARDS[account].ClosedRewardUsed\r\n            )\r\n        );\r\n\r\n        earnedAmount = earnedAmount.sub(REWARDS[account].CurrentRewardUsed);\r\n\r\n        if (TOKEN_MINT_USED.add(earnedAmount) > TOKEN_MINT_TOTAL) {\r\n            earnedAmount = earnedAmount.sub(\r\n                TOKEN_MINT_USED.add(earnedAmount).sub(TOKEN_MINT_TOTAL)\r\n            );\r\n        }\r\n\r\n        return earnedAmount;\r\n    }\r\n\r\n    function getMyEarnd(address account)\r\n        public\r\n        view\r\n        afterStarted\r\n        returns (uint256)\r\n    {\r\n        return _earned(account);\r\n    }\r\n\r\n    function getMyInvitedLength(address account)\r\n        external\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        User memory user = USERS[account];\r\n\r\n        return (user.Invited1st.length, user.Invited2nd.length);\r\n    }\r\n\r\n    function getMyInvitedBonus(address account)\r\n        public\r\n        view\r\n        afterStarted\r\n        returns (uint256)\r\n    {\r\n        require(account != address(0), \"account = address(0)\");\r\n\r\n        uint256 bonusBonus1st;\r\n        uint256 bonusBonus2nd;\r\n\r\n        User memory user = USERS[account];\r\n\r\n        for (uint256 i = 0; i < user.Invited1st.length; i++) {\r\n            uint256 earnedAmount;\r\n            uint256 rewardAmount = REWARDS[user.Invited1st[i]].MintRewardTotal;\r\n\r\n            earnedAmount = _earned(user.Invited1st[i]).add(rewardAmount);\r\n            bonusBonus1st = bonusBonus1st.add(\r\n                earnedAmount.mul(REFERRAL_PERCENTS[0]).div(100)\r\n            );\r\n        }\r\n\r\n        for (uint256 i = 0; i < user.Invited2nd.length; i++) {\r\n            uint256 earnedAmount;\r\n            uint256 rewardAmount = REWARDS[user.Invited2nd[i]].MintRewardTotal;\r\n\r\n            earnedAmount = _earned(user.Invited2nd[i]).add(rewardAmount);\r\n            bonusBonus2nd = bonusBonus2nd.add(\r\n                earnedAmount.mul(REFERRAL_PERCENTS[1]).div(100)\r\n            );\r\n        }\r\n\r\n        return bonusBonus1st.add(bonusBonus2nd).sub(BONUS[account]);\r\n    }\r\n\r\n    function getBonus() public afterStarted {\r\n        uint256 bonusAmount;\r\n\r\n        bonusAmount = getMyInvitedBonus(msg.sender);\r\n\r\n        if (bonusAmount > 0) {\r\n            BONUS[msg.sender] = BONUS[msg.sender].add(bonusAmount);\r\n            TOKEN_MINT_USED = TOKEN_MINT_USED.add(bonusAmount);\r\n\r\n            mintedToken.safeTransfer(msg.sender, bonusAmount);\r\n            emit onBouns(msg.sender, bonusAmount);\r\n        }\r\n    }\r\n\r\n    function getReward() public afterStarted {\r\n        uint256 earnedAmount;\r\n        uint256 totalAmount;\r\n\r\n        earnedAmount = _earned(msg.sender);\r\n\r\n        if (REWARDS[msg.sender].Stoped) {\r\n            REWARDS[msg.sender].Stoped = false;\r\n            REWARDS[msg.sender].CurrentRewardUsed = 0;\r\n        } else {\r\n            REWARDS[msg.sender].CurrentRewardUsed = REWARDS[msg.sender]\r\n                .CurrentRewardUsed\r\n                .add(earnedAmount);\r\n        }\r\n\r\n        totalAmount = earnedAmount;\r\n\r\n        if (totalAmount > 0) {\r\n            REWARDS[msg.sender].ClosedRewardUsed = REWARDS[msg.sender]\r\n                .ClosedRewardTotal;\r\n            TOKEN_MINT_USED = TOKEN_MINT_USED.add(totalAmount);\r\n\r\n            REWARDS[msg.sender].MintRewardTotal = REWARDS[msg.sender]\r\n                .MintRewardTotal\r\n                .add(totalAmount);\r\n\r\n            mintedToken.safeTransfer(msg.sender, totalAmount);\r\n            emit onReward(msg.sender, totalAmount);\r\n        }\r\n    }\r\n\r\n    function withdraw() public afterStarted {\r\n        User storage u = USERS[msg.sender];\r\n\r\n        TOTAL_BALANCE_SUPPLY = TOTAL_BALANCE_SUPPLY.sub(u.Balances);\r\n\r\n        REWARDS[msg.sender].ClosedRewardTotal = REWARDS[msg.sender]\r\n            .ClosedRewardTotal\r\n            .add(_earned(msg.sender));\r\n\r\n        REWARDS[msg.sender].CurrentRewardUsed = 0;\r\n        REWARDS[msg.sender].Stoped = true;\r\n\r\n        for (uint256 i = 0; i < u.Deposits.length; i++) {\r\n            u.Deposits[i].Closed = true;\r\n            u.Deposits[i].ClosedAt = block.timestamp;\r\n        }\r\n\r\n        uint256 burnAmount = u.Balances.mul(CONTRACT_WITHDRAWN_PERCENT).div(\r\n            100\r\n        );\r\n        uint256 amount = u.Balances.sub(burnAmount);\r\n\r\n        msg.sender.transfer(amount);\r\n        CONTRACT_FOUNDATION.transfer(burnAmount);\r\n\r\n        emit onWithdraw(msg.sender, amount);\r\n\r\n        u.Balances = 0;\r\n    }\r\n\r\n    function exit() external afterStarted {\r\n        withdraw();\r\n        getBonus();\r\n        getReward();\r\n    }\r\n\r\n    function getDeposit(address account)\r\n        external\r\n        view\r\n        afterStarted\r\n        returns (Deposit[] memory)\r\n    {\r\n        require(account != address(0), \"account = address(0)\");\r\n\r\n        User memory u = USERS[account];\r\n\r\n        return u.Deposits;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return TOTAL_BALANCE_SUPPLY;\r\n    }\r\n\r\n    function balanceOf(address account)\r\n        public\r\n        view\r\n        afterStarted\r\n        returns (uint256)\r\n    {\r\n        require(account != address(0), \"account = address(0)\");\r\n\r\n        return USERS[account].Balances;\r\n    }\r\n\r\n    function setDifficulty(uint256 v)\r\n        external\r\n        afterDeveloper\r\n        returns (uint256)\r\n    {\r\n        require(DIFFICULTIES[v].Exists == false, \"difficulty = true\");\r\n\r\n        ALLDIFFICULTIES.push(v);\r\n        DIFFICULTIES[CONTRACT_DIFFICULTY] = Difficulty(block.timestamp, true);\r\n        CONTRACT_DIFFICULTY = v;\r\n\r\n        return ALLDIFFICULTIES.length;\r\n    }\r\n\r\n    function setDepositPercent(uint256 percent) external afterDeveloper {\r\n        CONTRACT_DEPOSIT_PERCENT = percent;\r\n\r\n        require(\r\n            CONTRACT_DEPOSIT_PERCENT.add(CONTRACT_WITHDRAWN_PERCENT) <= 100\r\n        );\r\n    }\r\n\r\n    function setWithdrawnPercent(uint256 percent) external afterDeveloper {\r\n        CONTRACT_WITHDRAWN_PERCENT = percent;\r\n\r\n        require(\r\n            CONTRACT_DEPOSIT_PERCENT.add(CONTRACT_WITHDRAWN_PERCENT) <= 100\r\n        );\r\n    }\r\n\r\n    function setDefaultReferrer(address account) external afterDeveloper {\r\n        require(account != address(0), \"account = address(0)\");\r\n\r\n        CONTRACT_DEFAULT_REFERRER = account;\r\n    }\r\n\r\n    function setDeveloper(address payable account) external afterDeveloper {\r\n        require(account != address(0), \"account = address(0)\");\r\n\r\n        CONTRACT_DEVELOPER = account;\r\n    }\r\n\r\n    function setFoundation(address payable account) external afterDeveloper {\r\n        require(account != address(0), \"account = address(0)\");\r\n\r\n        CONTRACT_FOUNDATION = account;\r\n    }\r\n\r\n    function init() external afterDeveloper {\r\n        require(CONTRACT_INITED == false, \"CONTRACT_INITED = true\");\r\n\r\n        mintedToken.mint(address(this), TOKEN_MINT_TOTAL);\r\n\r\n        CONTRACT_INITED = true;\r\n    }\r\n}"}}}