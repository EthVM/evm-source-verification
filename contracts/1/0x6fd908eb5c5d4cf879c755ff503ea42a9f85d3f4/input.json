{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/DefiPortfolio.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\r\npragma abicoder v2;\r\npragma solidity ^0.8.7;\r\n\r\ncontract DefiPortfolio {\r\n  struct ProtocolInfo {\r\n    string name;\r\n    string websiteURL;\r\n    string iconURL;\r\n    address chefAddress;\r\n    string poolLengthSignature;\r\n    string poolInfoSignature;\r\n    string userInfoSignature;\r\n  }\r\n  \r\n  struct StakedPoolInfo {\r\n    uint256 index;\r\n    address token;\r\n    uint256 amount;\r\n  }\r\n\r\n  struct StakedInfo {\r\n    string name;\r\n    StakedPoolInfo[] pools;\r\n  }\r\n\r\n  ProtocolInfo[] public protocols;\r\n  mapping(string => uint256) public protocolIndex;\r\n  mapping(string => bool) public protocolSupport;\r\n  \r\n  address public manager;\r\n  \r\n  modifier onlyManager() {\r\n    require (msg.sender == manager);\r\n    _;\r\n  }\r\n  \r\n  constructor() {\r\n    manager = msg.sender;\r\n  }\r\n  \r\n  function getPoolLengthOf(\r\n    uint256 index\r\n  ) public view returns (uint256 length) {\r\n    ProtocolInfo storage protocol = protocols[index];\r\n    if (bytes(protocol.poolLengthSignature).length == 0) {\r\n      return 0;\r\n    }\r\n\r\n    bytes memory callData;\r\n    callData = abi.encodeWithSignature(protocol.poolLengthSignature);\r\n\r\n    (\r\n      bool success,\r\n      bytes memory returnData\r\n    ) = address(protocol.chefAddress).staticcall(callData);\r\n\r\n    if (success) {\r\n      (length) = abi.decode(returnData, (uint256));\r\n    }\r\n  }\r\n  \r\n  function getPoolInfoOf(\r\n    uint256 index,\r\n    uint256 id\r\n  ) public view returns (address token) {\r\n    ProtocolInfo storage protocol = protocols[index];\r\n    bytes memory callData;\r\n    callData = abi.encodeWithSignature(protocol.poolInfoSignature, id);\r\n\r\n    (\r\n      bool success,\r\n      bytes memory returnData\r\n    ) = address(protocol.chefAddress).staticcall(callData);\r\n\r\n    if (success) {\r\n      (token) = abi.decode(returnData, (address));\r\n    }\r\n  }\r\n  \r\n  function getUserInfoOf(\r\n    uint256 index,\r\n    uint256 id,\r\n    address user\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 amount)\r\n  {\r\n    ProtocolInfo storage protocol = protocols[index];\r\n    bytes memory callData;\r\n    callData = abi.encodeWithSignature(\r\n      protocol.userInfoSignature,\r\n      id,\r\n      user\r\n    );\r\n\r\n    (\r\n      bool success,\r\n      bytes memory returnData\r\n    ) = address(protocol.chefAddress).staticcall(callData);\r\n\r\n    if (success) {\r\n      (amount) = abi.decode(returnData, (uint256));\r\n    }\r\n  }\r\n  \r\n  function getStakedInfoOf(\r\n    uint256 index,\r\n    address user\r\n  )\r\n    public\r\n    view\r\n    returns (StakedPoolInfo[] memory stakedPoolInfo)\r\n  {\r\n    uint256 length = getPoolLengthOf(index);\r\n    uint256[] memory userPools = new uint256[](length);\r\n    uint256[] memory amounts = new uint256[](length);\r\n    uint256 counter = 0;\r\n\r\n    if (bytes(protocols[index].poolLengthSignature).length == 0) {\r\n      for (uint256 i = 0; i < length; i++) {\r\n        try this.getUserInfoOf(\r\n          index,\r\n          i,\r\n          user\r\n        ) returns (uint256 amount) {\r\n          if (amount > 0) {\r\n            userPools[counter] = i;\r\n            amounts[counter] = amount;\r\n            counter++;\r\n          }\r\n        } catch (bytes memory) {\r\n          break;\r\n        }\r\n      }\r\n    } else {\r\n      for (uint256 i = 0; i < length; i++) {\r\n        uint256 amount = getUserInfoOf(index, i, user);\r\n        if (amount > 0) {\r\n          userPools[counter] = i;\r\n          amounts[counter] = amount;\r\n          counter++;\r\n        }\r\n      }\r\n    }\r\n    \r\n    stakedPoolInfo = new StakedPoolInfo[](counter);\r\n    for (uint256 i = 0; i < counter; i++) {\r\n      stakedPoolInfo[i].index = userPools[i];\r\n      stakedPoolInfo[i].token = getPoolInfoOf(index, userPools[i]);\r\n      stakedPoolInfo[i].amount = amounts[i];\r\n    }\r\n  }\r\n  \r\n  function getPoolLength(\r\n    string calldata name\r\n  ) public view returns (uint256 length) {\r\n    length = getPoolLengthOf(protocolIndex[name]);\r\n  }\r\n  \r\n  function getPoolInfo(\r\n    string calldata name,\r\n    uint256 id\r\n  ) public view returns (address token) {\r\n    token = getPoolInfoOf(protocolIndex[name], id);\r\n  }\r\n  \r\n  function getUserInfo(\r\n    string calldata name,\r\n    uint256 id,\r\n    address user\r\n  ) public view returns (uint256 amount) {\r\n    amount = getUserInfoOf(protocolIndex[name], id, user);\r\n  }\r\n \r\n  function getStakedInfo(\r\n    string calldata name,\r\n    address user\r\n  )\r\n    public\r\n    view\r\n    returns (StakedPoolInfo[] memory stakedPoolInfo)\r\n  {\r\n    stakedPoolInfo = getStakedInfoOf(protocolIndex[name], user);\r\n  }\r\n  \r\n  function getStakedInfos(\r\n    address user\r\n  )\r\n    public\r\n    view\r\n    returns (StakedInfo[]memory stakedInfos)\r\n  {\r\n    stakedInfos = new StakedInfo[](protocols.length);\r\n    uint256 protocolLength = protocols.length;\r\n    for (uint256 i = 0; i < protocolLength; i++) {\r\n        stakedInfos[i].name = protocols[i].name;\r\n        stakedInfos[i].pools = getStakedInfoOf(i, user);\r\n    }\r\n  }\r\n  \r\n  function getAllProtocols()\r\n    public\r\n    view\r\n    returns (ProtocolInfo[] memory protocolInfos)\r\n  {\r\n    uint256 protocolLength = protocols.length;\r\n    protocolInfos = new ProtocolInfo[](protocolLength);\r\n    for (uint256 i = 0; i < protocolLength; i++) {\r\n        protocolInfos[i] = protocols[i];\r\n    }\r\n  }\r\n\r\n  function addProtocol(ProtocolInfo calldata info) public onlyManager {\r\n    require(!protocolSupport[info.name]);\r\n    require(info.chefAddress != address(0));\r\n    protocolIndex[info.name] = protocols.length;\r\n    protocols.push(info);\r\n    protocolSupport[info.name] = true;\r\n  }\r\n\r\n  function addProtocols(\r\n    ProtocolInfo[] calldata info\r\n  ) external onlyManager {\r\n    uint256 infoLength = info.length;\r\n    for (uint256 i = 0; i < infoLength; i++) {\r\n      addProtocol(info[i]);\r\n    }\r\n  }\r\n  \r\n  function updateProtocol(\r\n    uint256 index,\r\n    ProtocolInfo calldata info\r\n  ) external onlyManager {\r\n    require(info.chefAddress != address(0));\r\n    protocolSupport[protocols[index].name] = false;\r\n    protocolIndex[protocols[index].name] = 0;\r\n    protocols[index] = info;\r\n    protocolSupport[info.name] = true;\r\n    protocolIndex[info.name] = index;\r\n  }\r\n  \r\n  function changeManager(address newManager) external onlyManager {\r\n    require(newManager != address(0));\r\n    manager = newManager;\r\n  }\r\n}"
    }
  }
}