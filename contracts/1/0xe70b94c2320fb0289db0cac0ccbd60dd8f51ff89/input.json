{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/rezerve.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a / b + (a % b == 0 ? 0 : 1);\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\n\r\n// pragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\ninterface RezerveExchange {\r\n     function exchangeReserve ( uint256 _amount ) external;\r\n     function flush() external;\r\n    \r\n}\r\n\r\n\r\n\r\n\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable( msg.sender );\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    address private _previousOwner;\r\n    uint256 private _lockTime;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor ()  {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n     /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function geUnlockTime() public view returns (uint256) {\r\n        return _lockTime;\r\n    }\r\n\r\n    //Locks the contract for owner for the amount of time provided\r\n    function lock(uint256 time) public virtual onlyOwner {\r\n        _previousOwner = _owner;\r\n        _owner = address(0);\r\n        _lockTime = block.timestamp + time;\r\n        emit OwnershipTransferred(_owner, address(0));\r\n    }\r\n    \r\n    //Unlocks the contract for owner when _lockTime is exceeds\r\n    function unlock() public virtual {\r\n        require(_previousOwner == msg.sender, \"You don't have permission to unlock\");\r\n        require( block.timestamp > _lockTime , \"Contract is locked until 7 days\");\r\n        emit OwnershipTransferred(_owner, _previousOwner);\r\n        _owner = _previousOwner;\r\n        _previousOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract Rezerve is Context, IERC20, Ownable {\r\n\tusing Address for address;\r\n\r\n\tmapping (address => mapping (address => uint256)) private _allowances;\r\n\tmapping (address => uint256) private balances;\r\n\tmapping (address => bool) private _isExcludedFromFee;\r\n\r\n\tuint256 private _totalSupply = 21000000 * 10**9;\r\n\tuint256 private _tFeeTotal;\r\n\r\n\tstring private constant _name = \"Rezerve\";\r\n\tstring private constant _symbol = \"RZRV\";\r\n\tuint8 private constant _decimals = 9;\r\n\r\n\tuint256 public _taxFeeOnSale = 0;\r\n\tuint256 private _previousSellFee = _taxFeeOnSale;\r\n\r\n\tuint256 public _taxFeeOnBuy = 10;\r\n\tuint256 private _previousBuyFee = _taxFeeOnBuy;\r\n\r\n    uint256 public _burnFee = 2;\r\n\tuint256 private _previousBurnFee = _burnFee;\r\n\t\r\n\tuint256 public stakingSlice = 20;\r\n\r\n\r\n\tbool public saleTax = true;\r\n\r\n\tmapping (address => uint256) public lastTrade;\r\n\tmapping (address => uint256) public lastBlock;\r\n\tmapping (address => bool)    public blacklist;\r\n\tmapping (address => bool)    public whitelist;\r\n\tmapping (address => bool)    public rezerveEcosystem;\r\n\taddress public reserveStaking;\r\n\taddress payable public reserveVault;\r\n\taddress public reserveExchange;\r\n\taddress public ReserveStakingReceiver;\r\n\taddress public DAI;\r\n\r\n\tIUniswapV2Router02 public immutable uniswapV2Router;\r\n\taddress public uniswapV2RouterAddress;\r\n\taddress public immutable uniswapV2Pair;\r\n\r\n\tuint8 public action;\r\n\tbool public daiShield;\r\n\tbool public AutoSwap = false;\r\n\r\n\tuint8 public lpPullPercentage = 70;\r\n\tbool public pauseContract = true;\r\n\tbool public stakingTax = true;\r\n\r\n\taddress public burnAddress = 0x000000000000000000000000000000000000dEaD;  \r\n\r\n\tbool inSwapAndLiquify;\r\n\tbool public swapAndLiquifyEnabled = true;\r\n\r\n\tuint256 public _maxTxAmount = 21000000  * 10**9;\r\n\tuint256 public numTokensSellToAddToLiquidity = 21000 * 10**9;\r\n\r\n\tevent MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\r\n\tevent SwapAndLiquifyEnabledUpdated(bool enabled);\r\n\tevent SwapAndLiquify(\r\n\t\tuint256 tokensSwapped,\r\n\t\tuint256 ethReceived,\r\n\t\tuint256 tokensIntoLiqudity\r\n\t);\r\n\r\n\t// ========== Modifiers ========== //\r\n\tmodifier lockTheSwap {\r\n\t\tinSwapAndLiquify = true;\r\n\t\t_;\r\n\t\tinSwapAndLiquify = false;\r\n\t}\r\n\r\n\tconstructor () {\r\n\t\t//DAI = 0x9A702Da2aCeA529dE15f75b69d69e0E94bEFB73B;\r\n\t\t// DAI = 0x6980FF5a3BF5E429F520746EFA697525e8EaFB5C; // @audit - make sure this address is correct\r\n\t\t//uniswapV2RouterAddress = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;\r\n                balances[msg.sender] = _totalSupply;\r\n\t\tDAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // testnet DAI\r\n\t\tuniswapV2RouterAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // @audit - make sure this address is correct\r\n\t\tIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapV2RouterAddress);\r\n\t\t // Create a uniswap pair for this new token\r\n\t\taddress pairAddress = IUniswapV2Factory(_uniswapV2Router.factory())\r\n\t\t\t.createPair(address(this), DAI );\r\n\t\tuniswapV2Pair = pairAddress;\r\n\t\t// UNCOMMENT THESE FOR ETHEREUM MAINNET\r\n\t\t//DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n\r\n\t\t// set the rest of the contract variables\r\n\t\tuniswapV2Router = _uniswapV2Router;\r\n\r\n\t\taddRezerveEcosystemAddress(owner());\r\n\t\taddRezerveEcosystemAddress(address(this));\r\n\r\n\t\taddToWhitelist(pairAddress);\r\n\r\n\t\t//exclude owner and this contract from fee\r\n\t\t_isExcludedFromFee[owner()] = true;\r\n\t\t_isExcludedFromFee[address(this)] = true;\r\n\t\t_isExcludedFromFee[0x397c2dBe7af135eA95561acdd9E558E630410a84] = true; // @audit - make sure this address is correct\r\n\t\tdaiShield = true;\r\n\t\temit Transfer(address(0), _msgSender(), _totalSupply);\r\n\t}\r\n\r\n\t// ========== View Functions ========== //\r\n\r\n\tfunction thresholdMet () public view returns (bool) {\r\n\t\treturn reserveBalance() > numTokensSellToAddToLiquidity ;\r\n\t}\r\n\t\r\n\tfunction reserveBalance () public view returns (uint256) {\r\n\t\treturn balanceOf( address(this) );\r\n\t}\r\n\r\n\tfunction name() public pure returns (string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\tfunction symbol() public pure returns (string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\tfunction decimals() public pure returns (uint8) {\r\n\t\treturn _decimals;\r\n\t}\r\n\r\n\tfunction totalSupply() public view override returns (uint256) {\r\n\t\treturn _totalSupply;\r\n\t}\r\n\r\n\tfunction balanceOf(address account) public view override returns (uint256) {\r\n\t\treturn balances[account];\r\n\t}\r\n\r\n\tfunction allowance(address owner, address spender) public view override returns (uint256) {\r\n\t\treturn _allowances[owner][spender];\r\n\t}\r\n\r\n\tfunction totalFees() public view returns (uint256) {\r\n\t\treturn _tFeeTotal;\r\n\t}\r\n\r\n\tfunction getLPBalance() public view returns(uint256){\r\n\t\tIERC20 _lp = IERC20 ( uniswapV2Pair);\r\n\t\treturn _lp.balanceOf(address(this));\r\n\t}\r\n\r\n\tfunction isExcludedFromFee(address account) public view returns(bool) {\r\n\t\treturn _isExcludedFromFee[account];\r\n\t}\r\n\r\n\tfunction checkDaiOwnership( address _address ) public view returns(bool){\r\n\t\tIERC20 _dai = IERC20(DAI);\r\n\t\tuint256 _daibalance = _dai.balanceOf(_address );\r\n\t\treturn ( _daibalance > 0 );\r\n\t}\r\n\r\n\t// ========== Mutative / Owner Functions ========== //\r\n\r\n\tfunction transfer(address recipient, uint256 amount) public override returns (bool) {\r\n\t\t_transfer(_msgSender(), recipient, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction approve(address spender, uint256 amount) public override returns (bool) {\r\n\t\t_approve(_msgSender(), spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n\t\t_approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount );\r\n\t\t_transfer(sender, recipient, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//to receive ETH from uniswapV2Router when swaping\r\n\treceive() external payable {}\r\n\r\n\tfunction setReserveExchange( address _address ) public onlyOwner {\r\n\t\trequire(_address != address(0), \"reserveExchange is zero address\");\r\n\t\treserveExchange = _address;\r\n\t\texcludeFromFee( _address );\r\n\t\taddRezerveEcosystemAddress(_address);\r\n\t}\r\n\r\n\tfunction contractPauser() public onlyOwner {\r\n\t\tpauseContract = !pauseContract;\r\n\t\tAutoSwap = !AutoSwap;\r\n\t\t_approve(address(this), reserveExchange, ~uint256(0));\r\n\t\t_approve(address(this), uniswapV2Pair ,  ~uint256(0));\r\n\t\t_approve(address(this), uniswapV2RouterAddress, ~uint256(0));\r\n\t\t \r\n\t\tIERC20 _dai = IERC20 ( DAI );\r\n\t\t_dai.approve( uniswapV2Pair, ~uint256(0) );\r\n\t\t_dai.approve( uniswapV2RouterAddress ,  ~uint256(0) );\r\n\t\t_dai.approve( reserveExchange ,  ~uint256(0) );\r\n\t}\r\n\r\n\tfunction excludeFromFee(address account) public onlyOwner {\r\n\t\t_isExcludedFromFee[account] = true;\r\n\t}\r\n\r\n\tfunction includeInFee(address account) public onlyOwner {\r\n\t\t_isExcludedFromFee[account] = false;\r\n\t}\r\n\r\n\tfunction setSellFeePercent(uint256 sellFee) external onlyOwner() {\r\n\t\trequire ( sellFee < 30 , \"Tax too high\" );\r\n\t\t_taxFeeOnSale = sellFee;\r\n\t}\r\n\r\n\tfunction setBuyFeePercent(uint256 buyFee) external onlyOwner() {\r\n\t\trequire ( buyFee < 11 , \"Tax too high\" );\r\n\t\t_taxFeeOnBuy = buyFee;\r\n\t}\r\n\t\r\n\tfunction setBurnFeePercent(uint256 burnFee) external onlyOwner() {\r\n\t\trequire ( burnFee < 11 , \"Burn too high\" );\r\n\t\t_burnFee = burnFee;\r\n\t}\r\n\r\n\tfunction setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\r\n\t\t_maxTxAmount = (_totalSupply * maxTxPercent) / 10**6;\r\n\t}\r\n\r\n\tfunction setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\r\n\t\tswapAndLiquifyEnabled = _enabled;\r\n\t\temit SwapAndLiquifyEnabledUpdated(_enabled);\r\n\t}\r\n\r\n\tfunction setReserveStakingReceiver(address _address) public onlyOwner {\r\n\t\trequire(_address != address(0), \"ReserveStakingReceiver is zero address\");\r\n\t\tReserveStakingReceiver = _address;\r\n\t\texcludeFromFee( _address );\r\n\t\taddRezerveEcosystemAddress(_address);\r\n\t}\r\n\t\r\n\tfunction setReserveStaking ( address _address ) public onlyOwner {\r\n\t\trequire(_address != address(0), \"ReserveStaking is zero address\");\r\n\t\treserveStaking = _address;\r\n\t\texcludeFromFee( _address );\r\n\t\taddRezerveEcosystemAddress(_address);\r\n\t}\r\n\r\n\tfunction setMinimumNumber (uint256 _min) public onlyOwner {\r\n\t\tnumTokensSellToAddToLiquidity = _min * 10** 9;\r\n\t}\r\n\r\n\tfunction daiShieldToggle () public onlyOwner {\r\n\t\tdaiShield = !daiShield;\r\n\t}\r\n\t\r\n\tfunction AutoSwapToggle () public onlyOwner {\r\n\t\tAutoSwap = !AutoSwap;\r\n\t}\r\n\r\n\tfunction addToBlacklist(address account) public onlyOwner {\r\n\t\twhitelist[account] = false;\r\n\t\tblacklist[account] = true;\r\n\t}\r\n\r\n\tfunction removeFromBlacklist(address account) public onlyOwner {\r\n\t\tblacklist[account] = false;\r\n\t}\r\n\t\r\n\t// To be used for contracts that should never be blacklisted, but aren't part of the Rezerve ecosystem, such as the Uniswap pair\r\n\tfunction addToWhitelist(address account) public onlyOwner {\r\n\t\tblacklist[account] = false;\r\n\t\twhitelist[account] = true;\r\n\t}\r\n\r\n\tfunction removeFromWhitelist(address account) public onlyOwner {\r\n\t\twhitelist[account] = false;\r\n\t}\r\n\r\n\t// To be used if new contracts are added to the Rezerve ecosystem\r\n\tfunction addRezerveEcosystemAddress(address account) public onlyOwner {\r\n\t\trezerveEcosystem[account] = true;\r\n\t\taddToWhitelist(account);\r\n\t}\r\n\r\n\tfunction removeRezerveEcosystemAddress(address account) public onlyOwner {\r\n\t\trezerveEcosystem[account] = false;\r\n\t}\r\n\r\n\tfunction toggleStakingTax() public onlyOwner {\r\n\t\tstakingTax = !stakingTax;\r\n\t}\r\n\r\n\tfunction withdrawLPTokens () public onlyOwner {\r\n\t\tIERC20 _uniswapV2Pair = IERC20 ( uniswapV2Pair );\r\n\t\tuint256 _lpbalance = _uniswapV2Pair.balanceOf(address(this));\r\n\t\t_uniswapV2Pair.transfer( msg.sender, _lpbalance );\r\n\t}\r\n\t\r\n\tfunction setLPPullPercentage ( uint8 _perc ) public onlyOwner {\r\n\t\trequire ( _perc >9 && _perc <71);\r\n\t\tlpPullPercentage = _perc;\r\n\t}\r\n\r\n\tfunction addToLP(uint256 tokenAmount, uint256 daiAmount) public onlyOwner {\r\n\t\t// approve token transfer to cover all possible scenarios\r\n\t\t_transfer ( msg.sender, address(this) , tokenAmount );\r\n\t\t_approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\t\t\r\n\t\tIERC20 _dai = IERC20 ( DAI );\r\n\t\t_dai.approve(  address(uniswapV2Router), daiAmount);\r\n\t\t_dai.transferFrom ( msg.sender, address(this) , daiAmount );\r\n\t\t\r\n\t\t// add the liquidity\r\n\t\tuniswapV2Router.addLiquidity(\r\n\t\t\taddress(this),\r\n\t\t\tDAI,\r\n\t\t\ttokenAmount,\r\n\t\t\tdaiAmount,\r\n\t\t\t0, // slippage is unavoidable\r\n\t\t\t0, // slippage is unavoidable\r\n\t\t\taddress(this),\r\n\t\t\tblock.timestamp\r\n\t\t);\r\n\t\tcontractPauser();\r\n\t}\r\n\r\n\tfunction removeLP () public onlyOwner {\r\n\t\tsaleTax = false;  \r\n\t\tIERC20 _uniswapV2Pair = IERC20 ( uniswapV2Pair );\r\n\t\tuint256 _lpbalance = _uniswapV2Pair.balanceOf(address(this));\r\n\t\tuint256 _perc = (_lpbalance * lpPullPercentage ) / 100;\r\n\t\t\r\n\t\t_uniswapV2Pair.approve( address(uniswapV2Router), _perc );\r\n\t\tuniswapV2Router.removeLiquidity(\r\n\t\t\taddress(this),\r\n\t\t\tDAI,\r\n\t\t\t_perc,\r\n\t\t\t0,\r\n\t\t\t0,\r\n\t\t\treserveExchange,\r\n\t\t\tblock.timestamp + 3 minutes\r\n\t\t); \r\n\t\tRezerveExchange _reserveexchange = RezerveExchange ( reserveExchange );\r\n\t\t_reserveexchange.flush();\r\n\t}\r\n\r\n\tfunction _approve(address owner, address spender, uint256 amount) private {\r\n\t\trequire(owner != address(0), \"ERC20: approve from the zero address\");\r\n\t\trequire(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n\t\t_allowances[owner][spender] = amount;\r\n\t\temit Approval(owner, spender, amount);\r\n\t}\r\n\r\n\t// ========== Private / Internal Functions ========== //\r\n\r\n\tfunction _transfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 amount\r\n\t) private {\r\n\t\trequire(from != address(0), \"ERC20: transfer from the zero address\");\r\n\t\trequire(to != address(0), \"ERC20: transfer to the zero address\");\r\n\t\trequire(amount > 0, \"Transfer amount must be greater than zero\");\r\n\t\trequire(!blacklist[from]);\r\n\t\tif (pauseContract) require (from == address(this) || from == owner());\r\n\r\n\t\tif (!rezerveEcosystem[from]) {\r\n\t\t\tif(to == uniswapV2Pair && daiShield) require ( !checkDaiOwnership(from) );\r\n\t\t\tif(from == uniswapV2Pair) saleTax = false;\r\n\t\t\tif(to != owner())\r\n\t\t\t\trequire(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\r\n\r\n\t\t\tif (!whitelist[from]) {\r\n\t\t\t\tif (lastBlock[from] == block.number) blacklist[from] = true;\r\n\t\t\t\tif (lastTrade[from] + 20 seconds > block.timestamp && !blacklist[from]) revert(\"Slowdown\");\r\n\t\t\t\tlastBlock[from] = block.number;\r\n\t\t\t\tlastTrade[from] = block.timestamp;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\taction = 0;\r\n\r\n\t\tif(from == uniswapV2Pair) action = 1;\r\n\t\tif(to == uniswapV2Pair) action = 2;\r\n\t\t// is the token balance of this contract address over the min number of\r\n\t\t// tokens that we need to initiate a swap + liquidity lock?\r\n\t\t// also, don't get caught in a circular liquidity event.\r\n\t\t// also, don't swap & liquify if sender is uniswap pair.\r\n\t\t\r\n\t\tuint256 contractTokenBalance = balanceOf(address(this));\r\n\t\tcontractTokenBalance = Math.min(contractTokenBalance, numTokensSellToAddToLiquidity);\r\n\t\tbool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\r\n\t\tif (\r\n\t\t\toverMinTokenBalance &&\r\n\t\t\t!inSwapAndLiquify &&\r\n\t\t\tfrom != uniswapV2Pair &&\r\n\t\t\tswapAndLiquifyEnabled &&\r\n\t\t\tAutoSwap\r\n\t\t) {\r\n\t\t\tswapIt(contractTokenBalance);\r\n\t\t}\r\n\t\t\r\n\t\t//indicates if fee should be deducted from transfer\r\n\t\tbool takeFee = true;\r\n\t\t\r\n\t\t//if any account belongs to _isExcludedFromFee account then remove the fee\r\n\t\tif(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\r\n\t\t\ttakeFee = false;\r\n\t\t}\r\n\t\t\r\n\t\t//transfer amount, it will take tax, burn, liquidity fee\r\n\t\tif (!blacklist[from])\r\n\t\t\t_tokenTransfer(from, to, amount, takeFee);\r\n\t\telse\r\n\t\t\t_tokenTransfer(from, to, 1, false);\r\n\t}\r\n\r\n\tfunction swapIt(uint256 contractTokenBalance) internal lockTheSwap {\r\n\t\tuint256 _exchangeshare = contractTokenBalance;\r\n\t\tif (stakingTax) {\r\n\t\t\t_exchangeshare = ( _exchangeshare * 4 ) / 5;\r\n\t\t\tuint256 _stakingshare = contractTokenBalance - _exchangeshare;\r\n\t\t\t_tokenTransfer(address(this), ReserveStakingReceiver, _stakingshare, false);\r\n\t\t}\r\n\t\tswapTokensForDai(_exchangeshare);\r\n\t}\r\n\r\n\tfunction swapTokensForDai(uint256 tokenAmount) internal {\r\n\t\t// generate the uniswap pair path of token -> DAI\r\n\t\taddress[] memory path = new address[](2);\r\n\r\n\t\tpath[0] = address(this);\r\n\t\tpath[1] = DAI;\r\n\t\tuniswapV2Router.swapExactTokensForTokens(\r\n\t\t\ttokenAmount,\r\n\t\t\t0, // accept any amount of DAI\r\n\t\t\tpath,\r\n\t\t\treserveExchange,\r\n\t\t\tblock.timestamp + 3 minutes\r\n\t\t);\r\n\t}\r\n\t\r\n\tfunction setStakingSlice ( uint256 _slice ) public onlyOwner {\r\n\t    stakingSlice = _slice;\r\n\t}\r\n\t\r\n\t//this method is responsible for taking all fee, if takeFee is true\r\n\tfunction _tokenTransfer(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount,\r\n\t\tbool takeFee\r\n\t) private {\r\n\t\tif(!takeFee)\r\n\t\t\tremoveAllFee();\r\n\r\n\t\t( uint256 transferAmount, uint256 sellFee, uint256 buyFee, uint256 burnFee ) = _getTxValues(amount);\r\n\t\t_tFeeTotal = _tFeeTotal + sellFee + buyFee + burnFee;\r\n\t\tuint256 stakingFee;\r\n\t\tif (stakingTax) {\r\n\t\t        uint256 stakingFeeB = (buyFee * stakingSlice )/100; \r\n\t\t        uint256 stakingFeeS = (sellFee * stakingSlice )/100;\r\n\t\t        buyFee = buyFee - stakingFeeB; \r\n\t\t        sellFee = sellFee - stakingFeeS;\r\n\t\t        stakingFee = stakingFeeB + stakingFeeS;\r\n\t\t\r\n\t\t}\r\n\t\tbalances[sender] = balances[sender] - amount;\r\n\t\tbalances[recipient] = balances[recipient] + transferAmount;\r\n\t\tbalances[address(this)] = balances[address(this)] + sellFee + buyFee;\r\n\t\tbalances[burnAddress] = balances[burnAddress] + burnFee;\r\n\t\tbalances[ReserveStakingReceiver] = balances[ReserveStakingReceiver] + stakingFee;\r\n\r\n\t\temit Transfer(sender, recipient, transferAmount);\r\n\t\t\r\n\t\tif(!takeFee)\r\n\t\t\trestoreAllFee();\r\n\t}\r\n\r\n\tfunction _getTxValues(uint256 tAmount) private returns (uint256, uint256, uint256, uint256) {\r\n\t\tuint256 sellFee = calculateSellFee(tAmount);\r\n\t\tuint256 buyFee = calculateBuyFee(tAmount);\r\n\t\tuint256 burnFee = calculateBurnFee(tAmount);\r\n\t\tuint256 tTransferAmount = tAmount - sellFee - buyFee - burnFee;\r\n\t\treturn (tTransferAmount, sellFee, buyFee, burnFee);\r\n\t}\r\n\r\n\tfunction calculateSellFee(uint256 _amount) private returns (uint256) {\r\n\t\tif (!saleTax) {\r\n\t\t\tsaleTax = true;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn( _amount * _taxFeeOnSale) / 10**2;\r\n\t}\r\n\r\n\tfunction calculateBuyFee(uint256 _amount) private view returns (uint256) {\r\n\t\tif(action == 1)\r\n\t\t\treturn (_amount * _taxFeeOnBuy) / 10**2;\r\n\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\tfunction calculateBurnFee(uint256 _amount) private view returns (uint256) {\r\n\t\tif ( _burnFee > 0 )\r\n\t\treturn (_amount * _burnFee) / 10**2;\r\n        return 0;\r\n\t\t\r\n\t}\r\n\r\n\tfunction removeAllFee() private {\r\n\t\tif(_taxFeeOnSale == 0 && _taxFeeOnBuy == 0  && _burnFee == 0 ) return;\r\n\t\t\r\n\t\t_previousSellFee = _taxFeeOnSale;\r\n\t\t_previousBuyFee = _taxFeeOnBuy;\r\n\t\t_previousBurnFee = _burnFee;\r\n\t\t\r\n\t\t_taxFeeOnSale = 0;\r\n\t\t_taxFeeOnBuy = 0;\r\n\t\t_burnFee = 0;\r\n\t}\r\n\r\n\tfunction restoreAllFee() private {\r\n\t\t_taxFeeOnSale = _previousSellFee;\r\n\t\t_taxFeeOnBuy = _previousBuyFee;\r\n\t\t_burnFee = _previousBurnFee;\r\n\t}\r\n}"}}}