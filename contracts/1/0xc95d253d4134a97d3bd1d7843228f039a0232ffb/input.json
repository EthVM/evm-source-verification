{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/MLM 2.3.sol": {
      "content": "pragma solidity ^0.6.10;\r\n// SPDX-License-Identifier: MIT\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"overflow error\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(b <= a, \"overflow error\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    \r\n    function inc(uint a) internal pure returns(uint) {\r\n        return(add(a, 1));\r\n    }\r\n\r\n    function dec(uint a) internal pure returns(uint) {\r\n        return(sub(a, 1));\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract MLM {\r\n    using SafeMath for uint;\r\n//****************************************************************************    \r\n//* Data\r\n//****************************************************************************    \r\n    struct Tx {\r\n        uint fr;\r\n        uint to;\r\n        uint value;\r\n    }\r\n    struct User {\r\n        address payable parent;\r\n        address payable ldirect;\r\n        address payable mdirect;\r\n        address payable rdirect;\r\n        uint level;\r\n        mapping(uint => Tx) txs;\r\n        uint txCount;\r\n        uint uid;\r\n        uint poolShare;\r\n    }\r\n    address payable[] directUsers;\r\n    mapping(address => User) users;\r\n    mapping(uint => address) uids;\r\n    address payable[] usersArray;\r\n    uint[] portions;\r\n    uint share;\r\n    uint directShare;\r\n    address owner;\r\n    address payable beneficiary; //wallet owner\r\n    bool maintainance;\r\n    uint maxDirectRegister;\r\n    uint directRegisterCount;\r\n    uint uidPrecision = 1e4;\r\n    uint maxLevel = 0;\r\n    uint pool = 0;\r\n    uint autoPoolShare;\r\n//****************************************************************************    \r\n//* Events\r\n//****************************************************************************    \r\n    event UserRegistered(address payable parent, address payable child, uint level);\r\n    event PoolDischarged(uint poolValue, uint usersCount, uint time);\r\n//****************************************************************************    \r\n//* Modifiers\r\n//****************************************************************************    \r\n    modifier isOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    modifier maintainanceOn {\r\n        require(maintainance);\r\n        _;\r\n    }\r\n    \r\n    modifier maintainanceOff {\r\n        require(! maintainance);\r\n        _;\r\n    }\r\n    \r\n    modifier notRegistered {\r\n        require(users[msg.sender].uid == 0);\r\n        _;\r\n    }\r\n    \r\n    modifier registered(address payable _member) {\r\n        require(users[_member].uid > 0);\r\n        _;\r\n    }\r\n    \r\n    modifier shareSet {\r\n        require(share > 0 && directShare > 0);\r\n        _;\r\n    }\r\n    \r\n    modifier isNode(address node) {\r\n        require(users[node].uid > 0); \r\n        _;\r\n    }\r\n\r\n//****************************************************************************    \r\n//* Functions\r\n//****************************************************************************    \r\n    constructor() public {\r\n        maintainance = true;\r\n        owner = msg.sender;\r\n        beneficiary = msg.sender;\r\n        portions.push(0);\r\n        maxDirectRegister = 1;\r\n    }\r\n    \r\n    function withdrawMyPoolShare() public {\r\n        require(users[msg.sender].poolShare > 0);\r\n        msg.sender.transfer(users[msg.sender].poolShare);\r\n        users[msg.sender].poolShare = 0;\r\n    }\r\n    \r\n    function dischargePool() public isOwner {\r\n        require(pool > 0);\r\n        uint poolShare = pool/usersArray.length;\r\n        for (uint i = 0; i < usersArray.length; i = i.inc()) {\r\n            users[usersArray[i]].txs[users[usersArray[i]].txCount] = Tx({\r\n                fr: 0,\r\n                to: users[usersArray[i]].uid,\r\n                value: poolShare\r\n            });\r\n            pool = pool.sub(poolShare);\r\n            users[usersArray[i]].txCount = users[usersArray[i]].txCount.inc();\r\n            users[usersArray[i]].poolShare = users[usersArray[i]].poolShare.add(poolShare);\r\n        }\r\n        emit PoolDischarged(pool, usersArray.length, now);\r\n    }\r\n    \r\n    function getUsersCount() public view returns(uint) {\r\n        return(usersArray.length);    \r\n    }\r\n    \r\n    function getPoolValue() public view returns(uint) {\r\n        return(pool);\r\n    }\r\n    \r\n    function getMyPoolShare() public view returns(uint) {\r\n        require(users[msg.sender].uid > 0);\r\n        return(users[msg.sender].poolShare);\r\n    }\r\n    \r\n    function changeMaxDirectRegister(uint _maxDirectRegister) public isOwner {\r\n        require(_maxDirectRegister != maxDirectRegister);\r\n        require(_maxDirectRegister >= getDirectRegisterCount());\r\n        maxDirectRegister = _maxDirectRegister;\r\n    }\r\n    \r\n    function getMaxDirectRegister() public view isOwner returns(uint) {\r\n        return(maxDirectRegister);\r\n    }\r\n    \r\n    function getDirectRegisterCount() public view isOwner returns(uint) {\r\n        return(directRegisterCount);\r\n    }\r\n    \r\n    function getDirectRegister(uint _index) public view returns(address payable) {\r\n        require((msg.sender == owner) || (msg.sender == beneficiary));\r\n        return(directUsers[_index.dec()]);\r\n    }\r\n    \r\n    function getRemainedDirectRegister() public view returns(uint) {\r\n        return(maxDirectRegister.sub(directRegisterCount));\r\n    }\r\n    \r\n    function changeOwner(address _owner) public isOwner {\r\n        require(owner != _owner);\r\n        owner = _owner;\r\n    }\r\n    \r\n    function setPoolShare(uint _poolShare) public isOwner maintainanceOn {\r\n        require(autoPoolShare != _poolShare);\r\n        autoPoolShare = _poolShare;\r\n    }\r\n    \r\n    function getPoolShare() public view returns(uint) {\r\n        return(autoPoolShare);\r\n    }\r\n    \r\n    function setActive() public isOwner maintainanceOn shareSet {\r\n        uint portionsSum = autoPoolShare;\r\n        for (uint l = 1; l < portions.length; l = l.inc()) {\r\n            portionsSum = portionsSum.add(portions[l]);\r\n        }\r\n        require(portionsSum < share);\r\n        maintainance = false;\r\n    }\r\n    \r\n    function setInactive() public isOwner maintainanceOff {\r\n        maintainance = true;\r\n    }\r\n    \r\n    function setShare(uint _share) public isOwner maintainanceOn {\r\n        require(_share > 0);\r\n        require(share != _share);\r\n        share = _share;\r\n    }\r\n\r\n    function getShare() public view returns(uint) {\r\n        return(share);\r\n    }\r\n    \r\n    function setDirectShare(uint _share) public isOwner maintainanceOn {\r\n        require(_share > 0);\r\n        require(directShare != _share);\r\n        directShare = _share;\r\n    }\r\n\r\n    function getDirectShare() public view returns(uint) {\r\n        return(directShare);\r\n    }\r\n\r\n    function setBeneficiary(address payable _beneficiary) public isOwner {\r\n        require(_beneficiary != beneficiary);\r\n        beneficiary = _beneficiary;\r\n    }\r\n    \r\n    function setPortion(uint _level, uint _portion) public isOwner maintainanceOn {\r\n        require(_level > 0);\r\n        uint currentLevel = portions.length.dec();\r\n        if (_level > currentLevel) {\r\n            for (uint l = currentLevel.inc(); l < _level; l = l.inc()) {\r\n                portions.push(0);\r\n            }\r\n            portions.push(_portion);\r\n        }\r\n        else {\r\n            portions[_level] = _portion;\r\n        }\r\n    }\r\n    \r\n    function getPortion(uint _level) public view returns(uint) {\r\n        require(_level < portions.length);\r\n        return(portions[_level]);\r\n    }\r\n\r\n    function getPortionCount() public view returns(uint) {\r\n        return(portions.length);\r\n    }\r\n\r\n    function getDirectChildsCount(address _node) public view isNode(_node) returns(uint) {\r\n        uint childs = 0;\r\n        if (users[_node].ldirect != address(0))\r\n            childs = childs.inc();\r\n        if (users[_node].mdirect != address(0))\r\n            childs = childs.inc();\r\n        if (users[_node].rdirect != address(0))\r\n            childs = childs.inc();\r\n        return(childs);\r\n    }\r\n    \r\n    function getDirectChilds(address _node) public view isNode(_node) returns(address, address, address) {\r\n        return(users[_node].ldirect, users[_node].mdirect, users[_node].rdirect);\r\n    }\r\n    \r\n    function getDirectChildsUid(uint _uid) public view returns(uint, uint, uint) {\r\n        require(uids[_uid] != address(0));\r\n        return(\r\n            users[users[uids[_uid]].ldirect].uid, \r\n            users[users[uids[_uid]].mdirect].uid, \r\n            users[users[uids[_uid]].rdirect].uid\r\n            );\r\n    }\r\n    \r\n    function getChildsCount(address _node) public view isNode(_node) returns(uint) {\r\n        if (_node == address(0))\r\n            return(0);\r\n        uint childs = getDirectChildsCount(_node);\r\n        if (users[_node].ldirect != address(0))\r\n            childs = childs.add(getChildsCount(users[_node].ldirect));\r\n        if (users[_node].mdirect != address(0))\r\n            childs = childs.add(getChildsCount(users[_node].mdirect));\r\n        if (users[_node].rdirect != address(0))\r\n            childs = childs.add(getChildsCount(users[_node].rdirect));\r\n        return(childs);\r\n    }\r\n    \r\n    function withdraw(uint value) public isOwner {\r\n        beneficiary.transfer(value);\r\n    }\r\n    \r\n    function getParent(address node) public view isNode(node) returns(address) {\r\n        return(users[node].parent);\r\n    }\r\n    \r\n    function findParentInLevel(address payable _referral, uint _level) private view returns(address payable) {\r\n        if (_level == 1) {\r\n            if (getDirectChildsCount(_referral) < 3)\r\n                return(_referral);\r\n            else\r\n                return(address(0));\r\n        }\r\n        else {\r\n            address payable ldirect = findParentInLevel(users[_referral].ldirect, _level.dec());\r\n            if (ldirect == address(0)) {\r\n                address payable mdirect = findParentInLevel(users[_referral].mdirect, _level.dec());\r\n                if (mdirect == address(0)) {\r\n                    address payable rdirect = findParentInLevel(users[_referral].rdirect, _level.dec());\r\n                    return(rdirect);\r\n                }\r\n                else\r\n                    return(mdirect);\r\n            }\r\n            else\r\n                return(ldirect);\r\n        }\r\n    }\r\n    \r\n    function getNearestParent(address payable _referral) private view returns(address payable) {\r\n        if (_referral == address(0))\r\n            return(address(0));\r\n        uint _level = 1;\r\n        bool _found = false;\r\n        address payable _parent;\r\n        while (! _found) {\r\n            _parent = findParentInLevel(_referral, _level);\r\n            if (_parent == address(0))\r\n                _level = _level.inc();\r\n            else\r\n                _found = true;\r\n        }\r\n        return(_parent);\r\n    }\r\n    \r\n    function generateUid() private returns(uint) {\r\n        if (getUsersCount() >= (uidPrecision / 10))\r\n            uidPrecision *= 10;\r\n        int time = - int(now);\r\n        uint uid = uint(msg.sender) ^ uint(address(this)) ^ uint(time) ^ uint(blockhash(block.number-1));\r\n        if (uid == 0)\r\n            uid = 1;\r\n        while (uid > uidPrecision)\r\n            uid = uid / 10;\r\n        while (users[uids[uid]].uid >0) {\r\n            if (uid == (uidPrecision.dec()))\r\n                uid = 1;\r\n            else\r\n                uid = uid.inc();\r\n        }\r\n        return(uid);\r\n    }\r\n    \r\n    function registerDirect() public payable maintainanceOff notRegistered {\r\n        require(maxDirectRegister > directRegisterCount);\r\n        address payable _referral = address(0);\r\n        directRegisterCount = directRegisterCount.inc();\r\n        directUsers.push(msg.sender);\r\n        doRegister(_referral, directShare);\r\n    }\r\n    \r\n    function registerNoReferral() public payable maintainanceOff notRegistered {\r\n        address payable minLevelParent = getNearestParent(directUsers[0]);\r\n        uint minLevel = users[minLevelParent].level;\r\n        for(uint i = 1; i < directUsers.length; i = i.inc()) {\r\n            address payable parent = getNearestParent(directUsers[i]);\r\n            uint level = users[parent].level;\r\n            if (level < minLevel) {\r\n                minLevel = level;\r\n                minLevelParent = parent;\r\n            }\r\n        }\r\n        doRegister(minLevelParent, share);\r\n    }\r\n    \r\n    function registerReferral(address payable _referral) public payable maintainanceOff notRegistered {\r\n        require(_referral != address(0));\r\n        _referral = getNearestParent(_referral);\r\n        doRegister(_referral, share);\r\n    }\r\n    \r\n    function doRegister(address payable _referral, uint _share) private {\r\n        require(users[msg.sender].uid == 0);\r\n        doRegisterData(_referral, msg.sender, _share);\r\n        doRegisterPayment(msg.sender, _share);\r\n    }\r\n    \r\n    function doRegisterData(address payable _referral, address payable _child, uint _share) private {\r\n        uint _level;\r\n        uint _uid = generateUid();\r\n        if (_referral == address(0))\r\n            _level = 1;\r\n        else\r\n            _level = users[_referral].level.inc();\r\n        if (_level > maxLevel)\r\n            maxLevel = _level;\r\n        users[_child] = User({\r\n            parent: _referral,\r\n            level: _level,\r\n            txCount: 1,\r\n            ldirect: address(0),\r\n            mdirect: address(0),\r\n            rdirect: address(0),\r\n            uid: _uid,\r\n            poolShare: 0\r\n        });\r\n        users[_child].txs[0] = Tx({\r\n            fr: users[_child].uid,\r\n            to: 0,\r\n            value: _share\r\n        });\r\n        uids[_uid] = _child;\r\n        usersArray.push(_child);\r\n        if (_referral != address(0)) {\r\n            if (users[_referral].ldirect == address(0))\r\n                users[_referral].ldirect = _child;\r\n            else if (users[_referral].mdirect == address(0))\r\n                users[_referral].mdirect = _child;\r\n            else if (users[_referral].rdirect == address(0))\r\n                users[_referral].rdirect = _child;\r\n            else\r\n                revert();\r\n        }\r\n        emit UserRegistered(_referral, _child, _level);\r\n    }\r\n    \r\n    function doRegisterPayment(address payable _child, uint _share) private {\r\n        address payable node = _child;\r\n        uint value = msg.value;\r\n        require(value >= _share);\r\n        uint portionsSum = 0;\r\n        for (uint l = 1; l < portions.length; l = l.inc()) {\r\n            node = users[node].parent;\r\n            if (portions[l] > 0) {\r\n                if (node != address(0)) {\r\n                    portionsSum = portionsSum.add(portions[l]);\r\n                    node.transfer(portions[l]);\r\n                    users[node].txs[users[node].txCount] = Tx({\r\n                        fr: users[_child].uid,\r\n                        to: users[node].uid,\r\n                        value: portions[l]\r\n                    });\r\n                    users[node].txCount = users[node].txCount.inc();\r\n                }\r\n            }\r\n        }\r\n        pool = pool.add(autoPoolShare);\r\n        uint beneficiaryShare = _share.sub(portionsSum).sub(autoPoolShare);\r\n        beneficiary.transfer(beneficiaryShare);\r\n        uint remainedValue = value.sub(_share);\r\n        if (remainedValue > 0)\r\n            _child.transfer(remainedValue);\r\n    }\r\n    \r\n    function doRegisterTx(address payable _child) private {\r\n        address payable node = _child;\r\n        for (uint l = 1; l < portions.length; l = l.inc()) {\r\n            node = users[node].parent;\r\n            if (portions[l] > 0) {\r\n                if (node != address(0)) {\r\n                    users[node].txs[users[node].txCount] = Tx({\r\n                        fr: users[_child].uid,\r\n                        to: users[node].uid,\r\n                        value: portions[l]\r\n                    });\r\n                    users[node].txCount = users[node].txCount.inc();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getOwner() public view returns(address) {\r\n        return(owner);\r\n    }\r\n    \r\n    function getBeneficiary() public view returns(address) {\r\n        return(beneficiary);\r\n    }\r\n    \r\n    function getBalance() public view isOwner returns(uint) {\r\n        return(address(this).balance);\r\n    }\r\n    \r\n    function getMaintainance() public view returns(bool) {\r\n        return(maintainance);\r\n    }\r\n    \r\n    function getAddress(uint _uid) public view returns(address payable) {\r\n        require(uids[_uid] != address(0));\r\n        return(payable(uids[_uid]));\r\n    }\r\n    \r\n    function getUid(address payable _address) public view returns(uint) {\r\n        require(users[_address].uid > 0);\r\n        return(users[_address].uid);\r\n    }\r\n    \r\n    function getMyUid() public view returns(uint) {\r\n        return(getUid(msg.sender));\r\n    }\r\n    \r\n    function isMember(address payable _address) public view returns(bool) {\r\n        return(users[_address].uid > 0);\r\n    }\r\n    \r\n    function isMemberByUid(uint _uid) public view returns(bool) {\r\n        return(uids[_uid] != address(0));\r\n    }\r\n    \r\n    function getTxCount(address payable _address) public view registered(_address) returns(uint) {\r\n        return(users[_address].txCount);\r\n    }\r\n    \r\n    function getTx(address payable _address, uint _index) public view registered(_address) returns(uint, uint, uint, uint, uint) {\r\n        require(_index < users[_address].txCount);\r\n        uint uid = getUid(_address);\r\n        return(_index, uid, users[_address].txs[_index].fr, users[_address].txs[_index].to, users[_address].txs[_index].value);\r\n    }\r\n    \r\n    function getPaid(address payable _address) public view registered(_address) returns(uint) {\r\n        return(users[_address].txs[0].value);\r\n    }\r\n\r\n    function getEarned(address payable _address) public view registered(_address) returns(uint) {\r\n        uint sum;\r\n        for (uint i = 1; i < users[_address].txCount; i= i.inc())\r\n            sum = sum.add(users[_address].txs[i].value);\r\n        return(sum);\r\n    }\r\n    \r\n    function getLevel(address payable _address) public view registered(_address) returns(uint) {\r\n        return(users[_address].level);\r\n    }\r\n    \r\n    function initialize(address payable _parent, address payable _child) public maintainanceOn {\r\n        require((msg.sender == owner) || (msg.sender == beneficiary));\r\n        require(_parent != address(0));\r\n        require(_child != address(0));\r\n        require(users[_parent].uid > 0);\r\n        require(users[_child].uid == 0);\r\n        doRegisterData(_parent, _child, share);\r\n        doRegisterTx(_child);\r\n    }\r\n    \r\n    function initializeDirect(address payable _direct) public maintainanceOn {\r\n        require((msg.sender == owner) || (msg.sender == beneficiary));\r\n        require(maxDirectRegister > directRegisterCount);\r\n        require(_direct != address(0));\r\n        require(users[_direct].uid == 0);\r\n        directRegisterCount = directRegisterCount.inc();\r\n        directUsers.push(msg.sender);\r\n        doRegisterData(address(0), _direct, directShare);\r\n    }\r\n    \r\n    function getMaxLevel() public view isOwner returns(uint) {\r\n        return(maxLevel);\r\n    }\r\n    \r\n    function getAddressById(uint _id) public view returns(address payable) {\r\n        require((msg.sender == owner) || (msg.sender == beneficiary));\r\n        return(usersArray[_id]);\r\n    }\r\n    \r\n    function getUidById(uint _id) public view returns(uint) {\r\n        require((msg.sender == owner) || (msg.sender == beneficiary));\r\n        return(users[usersArray[_id]].uid);\r\n    }\r\n}"
    }
  }
}