{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "localhost/contracts/BNBETH/Ownable.sol": {
      "content": "// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.6.9;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n *\r\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\r\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\r\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\r\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(),\"Not Owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0),\"Zero address not allowed\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"
    },
    "localhost/contracts/BNBETH/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.6.9;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n"
    },
    "localhost/contracts/BNBETH/SwapFactory.sol": {
      "content": "// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.6.9;\r\n\r\n//import \"./SafeMath.sol\";\r\n//import \"./Ownable.sol\";\r\nimport \"./SwapPair.sol\";\r\n\r\ninterface IERC20 {\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IValidator {\r\n    // returns: user balance, native (foreign for us) encoded balance, foreign (native for us) encoded balance\r\n    function checkBalances(address pair, address foreignSwapPair, address user) external returns(uint256);\r\n    // returns: user balance\r\n    function checkBalance(address pair, address foreignSwapPair, address user) external returns(uint256);\r\n    // returns: oracle fee\r\n    function getOracleFee(uint256 req) external returns(uint256);  //req: 1 - cancel, 2 - claim, returns: value\r\n}\r\n\r\ninterface ISmart {\r\n    function requestCompensation(address user, uint256 feeAmount) external returns(bool);\r\n}\r\n\r\ninterface IAuction {\r\n    function contributeFromSmartSwap(address payable _whom) external payable returns (bool);\r\n}\r\n\r\ncontract SwapFactory is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address constant NATIVE_COINS = 0x0000000000000000000000000000000000000009; // 1 - BNB, 2 - ETH, 3 - BTC\r\n    uint256 constant INVESTMENT_FLAG = 2**224;\r\n\r\n    mapping(address => mapping(address => address payable)) public getPair;\r\n    mapping(address => address) public foreignPair;\r\n    address[] public allPairs;\r\n    address public foreignFactory;\r\n\r\n    mapping(address => mapping(address => uint256)) public cancelAmount;    // pair => user => cancelAmount\r\n    mapping(address => mapping(address => uint256)) public swapAmount;    // pair => user => swapAmount\r\n\r\n    mapping(address => bool) public isExchange;         // is Exchange address\r\n    mapping(address => bool) public isExcludedSender;   // address excluded from receiving SMART token as fee compensation\r\n\r\n    \r\n    uint256 public fee;\r\n    address payable public validator;\r\n    address public system;  // system address mey change fee amount\r\n    address public auction; // auction address\r\n    address public contractSmart;  // the contract address to request Smart token in exchange of fee\r\n    address public feeReceiver; // address which receive the fee (by default is validator)\r\n    \r\n\r\n    address public newFactory;            // new factory address to upgrade\r\n    event PairCreated(address indexed tokenA, address indexed tokenB, address pair, uint);\r\n    event SwapRequest(address indexed tokenA, address indexed tokenB, address indexed user, uint256 amountA, bool isInvestment);\r\n    event CancelRequest(address indexed tokenA, address indexed tokenB, address indexed user, uint256 amountA, bool isInvestment);\r\n    event CancelApprove(address indexed tokenA, address indexed tokenB, address indexed user, uint256 amountA, bool isInvestment);\r\n    event ClaimRequest(address indexed tokenA, address indexed tokenB, address indexed user, uint256 amountB, bool isInvestment);\r\n    event ClaimApprove(address indexed tokenA, address indexed tokenB, address indexed user, uint256 amountB, uint256 amountA, bool isInvestment);\r\n    event ExchangeInvestETH(address indexed exchange, address indexed whom, uint256 value);\r\n    \r\n    /**\r\n    * @dev Throws if called by any account other than the system.\r\n    */\r\n    modifier onlySystem() {\r\n        require(msg.sender == system || isOwner(), \"Caller is not the system\");\r\n        _;\r\n    }\r\n\r\n    constructor (address _system) public {\r\n        system = _system;\r\n        newFactory = address(this);\r\n    }\r\n    \r\n    //invest into auction\r\n    function investAuction(address payable _whom) external payable returns (bool)\r\n    {\r\n        require(foreignPair[msg.sender] != address(0), \"Investing allowed from pair only\");\r\n        IAuction(auction).contributeFromSmartSwap{value: msg.value}(_whom);\r\n    }\r\n    \r\n    function setFee(uint256 _fee) external onlySystem returns(bool) {\r\n        fee = _fee;\r\n        return true;\r\n    }\r\n\r\n    function setSystem(address _system) external onlyOwner returns(bool) {\r\n        system = _system;\r\n        return true;\r\n    }\r\n\r\n    function setValidator(address payable _validator) external onlyOwner returns(bool) {\r\n        validator = _validator;\r\n        if(feeReceiver == address(0)) feeReceiver = _validator;\r\n        return true;\r\n    }\r\n\r\n    function setForeignFactory(address _addr) external onlyOwner returns(bool) {\r\n        foreignFactory = _addr;\r\n        return true;\r\n    }\r\n\r\n    function setFeeReceiver(address _addr) external onlyOwner returns(bool) {\r\n        feeReceiver = _addr;\r\n        return true;\r\n    }\r\n\r\n    function setMSSContract(address _addr) external onlyOwner returns(bool) {\r\n        contractSmart = _addr;\r\n        return true;\r\n    }\r\n\r\n    function setNewFactory(address _addr) external onlyOwner returns(bool) {\r\n        newFactory = _addr;\r\n        return true;\r\n    }\r\n\r\n    function setAuction(address _addr) external onlyOwner returns(bool) {\r\n        auction = _addr;\r\n        return true;\r\n    }\r\n    \r\n    // for ETH side only\r\n    function changeExchangeAddress(address _which,bool _bool) external onlyOwner returns(bool){\r\n        isExchange[_which] = _bool;\r\n        return true;\r\n    }\r\n    \r\n    function changeExcludedAddress(address _which,bool _bool) external onlyOwner returns(bool){\r\n        isExcludedSender[_which] = _bool;\r\n        return true;\r\n    }\r\n    \r\n    function createPair(address tokenA, uint8 decimalsA, address tokenB, uint8 decimalsB) public onlyOwner returns (address payable pair) {\r\n        require(getPair[tokenA][tokenB] == address(0), 'PAIR_EXISTS'); // single check is sufficient\r\n        bytes memory bytecode = type(SwapPair).creationCode;\r\n        bytes32 salt = keccak256(abi.encodePacked(tokenA, tokenB));\r\n        assembly {\r\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        foreignPair[pair] = getForeignPair(tokenB, tokenA);\r\n        SwapPair(pair).initialize(foreignPair[pair], tokenA, decimalsA, tokenB, decimalsB);\r\n        getPair[tokenA][tokenB] = pair;\r\n\r\n        allPairs.push(pair);\r\n        emit PairCreated(tokenA, tokenB, pair, allPairs.length);\r\n    }\r\n\r\n    function getForeignPair(address tokenA, address tokenB) internal view returns(address pair) {\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                foreignFactory,\r\n                keccak256(abi.encodePacked(tokenA, tokenB)),\r\n                hex'05a14d15386c927ac1a2b1e515003107665e36f549246b88b3d136d36426eded' // init code hash\r\n            ))));\r\n    }\r\n\r\n    // set already existed pairs in case of contract upgrade\r\n    function setPairs(address[] memory tokenA, address[] memory tokenB, address payable[] memory pair) external onlyOwner returns(bool) {\r\n        uint256 len = tokenA.length;\r\n        while (len > 0) {\r\n            len--;\r\n            getPair[tokenA[len]][tokenB[len]] = pair[len];\r\n            foreignPair[pair[len]] = SwapPair(pair[len]).foreignSwapPair();\r\n            allPairs.push(pair[len]);\r\n            emit PairCreated(tokenA[len], tokenB[len], pair[len], allPairs.length);            \r\n        }\r\n        return true;\r\n    }\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairAddressFor(address tokenA, address tokenB) external view returns (address pair, bytes32 bytecodeHash) {\r\n        bytes memory bytecode = type(SwapPair).creationCode;\r\n        bytecodeHash = keccak256(bytecode);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                address(this),\r\n                keccak256(abi.encodePacked(tokenA, tokenB)),\r\n                bytecodeHash    // hex'05a14d15386c927ac1a2b1e515003107665e36f549246b88b3d136d36426eded' // init code hash\r\n            ))));\r\n    }\r\n\r\n    // ================== on Ethereum network only =========================================================================\r\n\r\n    //user should approve tokens transfer before calling this function.\r\n    function swapInvestment(address tokenA, uint256 amount) external payable returns (bool) {\r\n        address tokenB = address(1);    // BNB (foreign coin)\r\n        return _swap(tokenA, tokenB, msg.sender, amount, true);\r\n    }\r\n\r\n    function cancelInvestment(address tokenA, uint256 amount) external payable returns (bool) {\r\n        address tokenB = address(1);    // BNB (foreign coin)\r\n        return _cancel(tokenA, tokenB, msg.sender, amount, true);\r\n    }\r\n\r\n\r\n    // function for invest ETH from from exchange on user behalf\r\n    function contributeWithEtherBehalf(address payable _whom) external payable returns (bool) {\r\n        require(isExchange[msg.sender], \"Not an Exchange address\");\r\n        address tokenA = address(2);    // ETH (native coin)\r\n        address tokenB = address(1);    // BNB (foreign coin)\r\n        uint256 amount = msg.value - fee;\r\n        emit ExchangeInvestETH(msg.sender, _whom, msg.value);\r\n        return _swap(tokenA, tokenB, _whom, amount, true);\r\n    }\r\n    // ================= end Ethereum part =================================================================================\r\n\r\n    // ====================== on BSC side only =============================================================================\r\n\r\n    // tokenB - foreign token address or address(1) for ETH\r\n    // amountB - amount of foreign tokens or ETH\r\n    function claimInvestmentBehalf(address tokenB, address user, uint256 amountB) external onlySystem returns (bool) {\r\n        address tokenA = address(1);    // BNB (native coin)\r\n        return _claimTokenBehalf(tokenA, tokenB, user, amountB, true);\r\n    }\r\n    // ====================== end BSC part =================================================================================\r\n\r\n    \r\n    //user should approve tokens transfer before calling this function.\r\n    function swap(address tokenA, address tokenB, uint256 amount) external payable returns (bool) {\r\n        return _swap(tokenA, tokenB, msg.sender, amount, false);\r\n    }\r\n\r\n    function cancel(address tokenA, address tokenB, uint256 amount) external payable returns (bool) {\r\n        return _cancel(tokenA, tokenB, msg.sender, amount, false);\r\n    }\r\n    function claimTokenBehalf(address tokenA, address tokenB, address user, uint256 amountB) external onlySystem returns (bool) {\r\n        return _claimTokenBehalf(tokenA, tokenB, user, amountB, false);\r\n    }\r\n\r\n    // transfer fee to receiver and request MASS token as compensation.\r\n    function transferFee(uint256 feeAmount, address user) internal {\r\n        TransferHelper.safeTransferETH(feeReceiver, feeAmount);\r\n        if(contractSmart != address(0) && !isExcludedSender[msg.sender]) {\r\n            ISmart(contractSmart).requestCompensation(user, feeAmount);\r\n        }\r\n    }\r\n\r\n    //user should approve tokens transfer before calling this function.\r\n    function _swap(address tokenA, address tokenB, address user, uint256 amount, bool isInvestment) internal returns (bool) {\r\n        uint256 feeAmount = msg.value;\r\n        if (tokenA < NATIVE_COINS) feeAmount = feeAmount.sub(amount,\"Insuficiant value\");   // if native coin, then feeAmount = msg.value - swap amount\r\n        require(feeAmount >= fee,\"Insufficient fee\");\r\n        require(amount != 0, \"Zero amount\");\r\n        address payable pair = getPair[tokenA][tokenB];\r\n        require(pair != address(0), 'PAIR_NOT_EXISTS');\r\n        \r\n        // transfer fee to validator. May be changed to request tokens for compensation\r\n        transferFee(feeAmount, user);\r\n\r\n        if (tokenA < NATIVE_COINS)\r\n            TransferHelper.safeTransferETH(pair, amount);\r\n        else \r\n            TransferHelper.safeTransferFrom(tokenA, user, pair, amount);\r\n        SwapPair(pair).deposit(user, amount, isInvestment);\r\n        emit SwapRequest(tokenA, tokenB, user, amount, isInvestment);\r\n        return true;\r\n    }\r\n\r\n    function _cancel(address tokenA, address tokenB, address user, uint256 amount, bool isInvestment) internal returns (bool) {\r\n        require(msg.value >= IValidator(validator).getOracleFee(1), \"Insufficient fee\");    // check oracle fee for Cancel request\r\n        require(amount != 0, \"Zero amount\");\r\n        address payable pair = getPair[tokenA][tokenB];\r\n        require(pair != address(0), 'PAIR_NOT_EXISTS');\r\n        if (cancelAmount[pair][user] == 0) {  // new cancel request\r\n            cancelAmount[pair][user] = amount;\r\n            SwapPair(pair).cancel(user, amount, isInvestment);\r\n        }\r\n        else { // repeat cancel request in case oracle issues.\r\n            amount = cancelAmount[pair][user];\r\n        }\r\n\r\n        // transfer fee to validator. May be changed to request tokens for compensation\r\n        transferFee(msg.value, user);\r\n\r\n        if (isInvestment)\r\n            IValidator(validator).checkBalance(pair, foreignPair[pair], _investAddress(user));    // on Ethereum network only\r\n        else\r\n            IValidator(validator).checkBalance(pair, foreignPair[pair], _swapAddress(user));\r\n        emit CancelRequest(tokenA, tokenB, user, amount, isInvestment);\r\n        return true;\r\n    }\r\n\r\n\r\n    // amountB - amount of foreign token to swap\r\n    function _claimTokenBehalf(address tokenA, address tokenB, address user, uint256 amountB, bool isInvestment) internal returns (bool) {\r\n        address payable pair = getPair[tokenA][tokenB];\r\n        require(pair != address(0), 'PAIR_NOT_EXISTS');\r\n        require(amountB != 0, \"Zero amount\");\r\n        if (swapAmount[pair][user] == 0) {  // new claim request\r\n            swapAmount[pair][user] = amountB;\r\n            SwapPair(pair).claim(user, amountB, isInvestment);\r\n        }\r\n        else { // repeat claim request in case oracle issues.\r\n            amountB = swapAmount[pair][user];\r\n        }\r\n        if (isInvestment)\r\n            IValidator(validator).checkBalances(pair, foreignPair[pair], _investAddress(user));    // on BSC network only\r\n        else\r\n            IValidator(validator).checkBalances(pair, foreignPair[pair], user);\r\n        emit ClaimRequest(tokenA, tokenB, user, amountB, isInvestment);\r\n        return true;\r\n    }\r\n\r\n    // On both side (BEP and ERC) we accumulate user's deposits (balance).\r\n    // If balance on one side it greater then on other, the difference means user deposit.\r\n    function balanceCallback(address payable pair, address user, uint256 balanceForeign) external returns(bool) {\r\n        require (validator == msg.sender, \"Not validator\");\r\n        (uint256 balance, bool isInvestment) = _getBalance(SwapPair(pair).balanceOf(user));\r\n        if (isInvestment) user = _swapAddress(user);    // real user address = investAddress + 1\r\n        uint256 amount = cancelAmount[pair][user];\r\n        require (amount != 0, \"No active cancel request\");\r\n        cancelAmount[pair][user] = 0;\r\n        address tokenA;\r\n        address tokenB;\r\n        bool isApproved = (balanceForeign <= balance);\r\n        (tokenA, tokenB) = SwapPair(pair).cancelApprove(user, amount, isApproved, isInvestment);\r\n        if(!isApproved) amount = 0;\r\n\r\n        emit CancelApprove(tokenA, tokenB, user, amount, isInvestment);\r\n        return true;\r\n    }\r\n\r\n    function balancesCallback(\r\n            address payable pair,\r\n            address user,\r\n            uint256 balanceForeign,\r\n            uint256 nativeEncoded,\r\n            uint256 foreignSpent,\r\n            uint256 rate    // rate = foreignPrice.mul(NOMINATOR) / nativePrice;   // current rate\r\n        ) external returns(bool) {\r\n        require (validator == msg.sender, \"Not validator\");\r\n        (uint256 balance, bool isInvestment) = _getBalance(balanceForeign);\r\n        address userSwap;\r\n        if (isInvestment) {\r\n            userSwap = user;    // investAddress\r\n            user = _swapAddress(user);    // real user address = investAddress + 1\r\n        }\r\n        else {\r\n            userSwap = _swapAddress(user);\r\n        }\r\n\r\n        uint256 amountB = swapAmount[pair][user];\r\n        require (amountB != 0, \"No active swap request\");\r\n        swapAmount[pair][user] = 0;\r\n        address tokenA;\r\n        address tokenB;\r\n        uint256 nativeAmount;\r\n        uint256 rest;\r\n        if (balance >= SwapPair(pair).balanceOf(userSwap)) { // is approve claim\r\n            (tokenA, tokenB, nativeAmount, rest) = SwapPair(pair).claimApprove(user, amountB, nativeEncoded, foreignSpent, rate, true, isInvestment);\r\n            amountB = amountB.sub(rest);\r\n        }\r\n        else {\r\n            (tokenA, tokenB, nativeAmount, rest) = SwapPair(pair).claimApprove(user, amountB, nativeEncoded, foreignSpent, rate, false, isInvestment);\r\n            amountB = 0;\r\n        }\r\n\r\n        emit ClaimApprove(tokenA, tokenB, user, amountB, nativeAmount, isInvestment);\r\n        return true;\r\n    }\r\n\r\n    // swapAddress = user address + 1.\r\n    // balanceOf contain two types of balance:\r\n    // 1. balanceOf[user] - balance of tokens on native chain\r\n    // 2. balanceOf[user+1] - swapped balance of foreign tokens. I.e. on BSC chain it contain amount of ETH that was swapped.\r\n    function _swapAddress(address user) internal pure returns(address swapAddress) {\r\n        swapAddress = address(uint160(user)+1);\r\n    }\r\n    // 3. balanceOf[user-1] - investment to auction total balance.\r\n    function _investAddress(address user) internal pure returns(address investAddress) {\r\n        investAddress = address(uint160(user)-1);\r\n    }\r\n    // return balance and investment flag\r\n    function _getBalance(uint256 balanceWithFlag) internal pure returns(uint256 balance, bool isInvestment) {\r\n        if(INVESTMENT_FLAG & balanceWithFlag != 0) {\r\n            balance = uint192(balanceWithFlag);\r\n            isInvestment = true;\r\n        }\r\n        else {\r\n            balance = balanceWithFlag;\r\n            isInvestment = false;\r\n        }\r\n    }\r\n}"
    },
    "localhost/contracts/BNBETH/SwapPair.sol": {
      "content": "// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.6.9;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./TransferHelper.sol\";\r\n\r\n// TODO: balance + 1, to avoid Zero balance\r\n\r\ninterface ISwapFactory {\r\n    function newFactory() external view returns(address);\r\n    function auction() external view returns(address);\r\n    function validator() external view returns(address);\r\n    function investAuction(address payable _whom) external payable returns (bool);\r\n}\r\n\r\ncontract SwapPair {\r\n    using SafeMath for uint256;\r\n\r\n    //uint256 constant chain = 97;  // ETH mainnet = 1, Ropsten = 2, BSC_TESTNET = 97, BSC_MAINNET = 56\r\n    uint256 constant MAX_AMOUNT = 2**192;\r\n    uint256 constant INVESTMENT_FLAG = 2**224;\r\n    uint256 constant NOMINATOR = 10**18;\r\n    uint256 constant PRICE_NOMINATOR = 10**9;     // rate nominator\r\n    address constant NATIVE = address(-1);  // address which holds native token ballance that was spent\r\n    address constant FOREIGN = address(-2); // address which holds foreign token encoded ballance that was spent\r\n    address constant NATIVE_COINS = 0x0000000000000000000000000000000000000009; // 0 - BNB, 1 - ETH, 2 - BTC\r\n\r\n    address public token;               // token address\r\n    address public tokenForeign;        // Foreign token address\r\n    address public foreignSwapPair;     // foreign SwapPair contract address (on other blockchain)\r\n    address public factory;             // factory address\r\n    uint256 public decimalsNative;\r\n    uint256 public decimalsForeign;\r\n    uint256 public totalSupply;\r\n\r\n    // balanceOf contain two types of balance:\r\n    // 1. balanceOf[user] - balance of tokens on native chain\r\n    // 2. balanceOf[user+1] - swapped balance of foreign tokens. I.e. on BSC chain it contain amount of ETH that was swapped.\r\n    // 3. balanceOf[user-1] - swapped balance of foreign tokens for investment. I.e. on BSC chain it contain amount of ETH that was swapped.\r\n    mapping (address => uint256) public balanceOf;\r\n    //mapping (address => uint256) public cancelAmount;\r\n    //mapping (address => uint256) public swapAmount;\r\n\r\n    event CancelRequest(address indexed user, address token, uint256 amount);\r\n    event CancelApprove(address indexed user, address token, uint256 amount);\r\n    event ClaimRequest(address indexed user, address foreignToken, uint256 foreignAmount);\r\n    event ClaimApprove(address indexed user, address foreignToken, uint256 foreignAmount, address token, uint256 amount);\r\n\r\n    modifier onlyFactory() {\r\n        require(msg.sender == factory, \"Caller is not the factory\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    function initialize(address _foreignPair, address tokenA, uint8 decimalsA, address tokenB, uint8 decimalsB) public onlyFactory {\r\n        foreignSwapPair = _foreignPair;\r\n        token = tokenA;\r\n        tokenForeign = tokenB;\r\n        decimalsNative = 10**uint256(decimalsA);\r\n        decimalsForeign = 10**uint256(decimalsB);\r\n    }\r\n\r\n    function update() public returns(bool) {\r\n        factory = ISwapFactory(factory).newFactory();\r\n        return true;\r\n    }\r\n\r\n    function getTokens() external view returns(address tokenA, address tokenB) {\r\n        tokenA = token;\r\n        tokenB = tokenForeign;\r\n    }\r\n    \r\n    // encode 64 bits of rate (decimal = 9). and 192 bits of amount \r\n    // into uint256 where high 64 bits is rate and low 192 bit is amount\r\n    // rate = foreign token price / native token price\r\n    function _encode(uint256 rate, uint256 amount) internal pure returns(uint256 encodedBalance) {\r\n        require(amount < MAX_AMOUNT, \"Amount overflow\");\r\n        require(rate < 2**64, \"Rate overflow\");\r\n        encodedBalance = rate * MAX_AMOUNT + amount;\r\n    }\r\n\r\n    // decode from uint256 where high 64 bits is rate and low 192 bit is amount\r\n    // rate = foreign token price / native token price\r\n    function _decode(uint256 encodedBalance) internal pure returns(uint256 rate, uint256 amount) {\r\n        rate = encodedBalance / MAX_AMOUNT;\r\n        amount = uint192(encodedBalance);\r\n    }\r\n\r\n    // swapAddress = user address + 1.\r\n    // balanceOf contain two types of balance:\r\n    // 1. balanceOf[user] - balance of tokens on native chain\r\n    // 2. balanceOf[user+1] - swapped balance of foreign tokens. I.e. on BSC chain it contain amount of ETH that was swapped.\r\n    function _swapAddress(address user) internal pure returns(address swapAddress) {\r\n        swapAddress = address(uint160(user)+1);\r\n    }\r\n    // 3. balanceOf[user-1] - investment to auction total balance.\r\n    function _investAddress(address user) internal pure returns(address investAddress) {\r\n        investAddress = address(uint160(user)-1);\r\n    }\r\n\r\n    // call appropriate transfer function\r\n    function _transfer(address to, uint value) internal {\r\n        if (token < NATIVE_COINS) \r\n            TransferHelper.safeTransferETH(to, value);\r\n        else\r\n            TransferHelper.safeTransfer(token, to, value);\r\n    }\r\n\r\n    // user's deposit to the pool, waiting for swap\r\n    function deposit(address user, uint256 amount, bool isInvestment) external onlyFactory returns(bool) {\r\n        if (isInvestment) {\r\n            address investAddress = _investAddress(user);   // on Ethereum side only\r\n            balanceOf[investAddress] = (balanceOf[investAddress].add(amount)) | INVESTMENT_FLAG;\r\n        }\r\n        else {\r\n            balanceOf[user] = balanceOf[user].add(amount);\r\n        }\r\n        totalSupply = totalSupply.add(amount);\r\n        return true;\r\n    }\r\n\r\n    // cancel swap order request\r\n    function cancel(address user, uint256 amount, bool isInvestment) external onlyFactory returns(bool) {\r\n        if (isInvestment) {\r\n            address investAddress = _investAddress(user);   // on Ethereum side only\r\n            uint256 balance = uint192(balanceOf[investAddress]);\r\n            balance = balance.sub(amount,\"Not enough tokens on the balance\");\r\n            balanceOf[investAddress] = balance | INVESTMENT_FLAG;\r\n        }\r\n        else {\r\n            balanceOf[user] = balanceOf[user].sub(amount,\"Not enough tokens on the balance\");\r\n        }\r\n        totalSupply = totalSupply.sub(amount,\"Not enough Total Supply\");\r\n        return true;\r\n    }\r\n    // approve cancel swap order and withdraw token from pool or discard cancel request\r\n    // if isInvestment then user = investAddress (user - 1)\r\n    function cancelApprove(address user, uint256 amount, bool approve, bool isInvestment) external onlyFactory returns(address, address) {\r\n        if (approve) {    //approve cancel\r\n            _transfer(user, amount);\r\n        }\r\n        else {  // discard cancel request.\r\n            if (isInvestment)\r\n                user = _investAddress(user);   // on Ethereum side only\r\n            balanceOf[user] = balanceOf[user].add(amount);\r\n            totalSupply = totalSupply.add(amount);\r\n        }\r\n        return (token, tokenForeign);\r\n    }\r\n\r\n    // request to claim token after swap\r\n    function claim(address user, uint256 amount, bool isInvestment) external onlyFactory returns(bool) {\r\n        address userBalance;\r\n        if (isInvestment)\r\n            userBalance = _investAddress(user); // on BSC side only\r\n        else\r\n            userBalance = _swapAddress(user);\r\n        balanceOf[userBalance] = balanceOf[userBalance].add(amount);\r\n        return true;\r\n    }\r\n\r\n    // approve / discard claim request\r\n    function claimApprove(\r\n            address user,\r\n            uint256 amount, // foreign token amount to swap\r\n            uint256 nativeEncoded,\r\n            uint256 foreignSpent,\r\n            uint256 rate,\r\n            bool approve,\r\n            bool isInvestment\r\n        ) external onlyFactory returns(address, address, uint256 nativeAmount, uint256 rest) {\r\n        address userSwap;\r\n        if (isInvestment) {   //claim investment only on BSC side\r\n            userSwap = _investAddress(user);    // invest address (real user address - 1)\r\n        }\r\n        else {\r\n            userSwap = _swapAddress(user);  // swap address = real user address + 1\r\n        }\r\n\r\n        if(approve) { // approve claim\r\n            (nativeAmount, rest) = calculateAmount(amount,nativeEncoded,foreignSpent,rate);\r\n            if (rest != 0) {\r\n                balanceOf[userSwap] = balanceOf[userSwap].sub(rest);    // not all amount swapped\r\n            }\r\n            totalSupply = totalSupply.sub(nativeAmount,\"Not enough Total Supply\");\r\n            if (isInvestment)\r\n                ISwapFactory(factory).investAuction{value: nativeAmount}(payable(user));\r\n            else\r\n                _transfer(user, nativeAmount);\r\n        }\r\n        else {  // discard claim\r\n            balanceOf[userSwap] = balanceOf[userSwap].sub(amount);\r\n        }\r\n        return (token, tokenForeign, nativeAmount, rest);\r\n    }\r\n\r\n    function calculateAmount(\r\n        uint256 foreignAmount,\r\n        uint256 nativeEncoded,\r\n        uint256 foreignSpent,\r\n        uint256 rate    // Foreign token price / Native token price = (Native amount / Foreign amount)\r\n    ) internal returns(uint256 nativeAmount, uint256 rest) {\r\n        uint256 nativeDecimals = decimalsNative;\r\n        uint256 foreignDecimals = decimalsForeign;\r\n        \r\n        // step 1. Check is it enough unspent native tokens\r\n        {\r\n            (uint256 rate1, uint256 amount1) = _decode(nativeEncoded);  // rate1 = Native token price / Foreign token price\r\n            rate1 = rate1*NOMINATOR*foreignDecimals/nativeDecimals;\r\n            amount1 = amount1.sub(balanceOf[NATIVE], \"NativeSpent balance higher then remote\");\r\n            // rate1, amount1 - rate and amount ready to spend native tokens\r\n            if (amount1 != 0) {\r\n                uint256 requireAmount = foreignAmount.mul(PRICE_NOMINATOR*NOMINATOR).div(rate1);\r\n                if (requireAmount <= amount1) {\r\n                    nativeAmount = requireAmount;\r\n                    foreignAmount = 0;\r\n                }\r\n                else {\r\n                    nativeAmount = amount1;\r\n                    foreignAmount = (requireAmount - amount1).mul(rate1) / (PRICE_NOMINATOR*NOMINATOR);\r\n                }\r\n                balanceOf[NATIVE] = balanceOf[NATIVE].add(nativeAmount);\r\n            }\r\n        }\r\n        require(totalSupply >= nativeAmount,\"ERR: Not enough Total Supply\");\r\n        // step 2. recalculate rate for swapped tokens\r\n        if (foreignAmount != 0) {\r\n            uint256 rate2 = rate.mul(NOMINATOR).mul(nativeDecimals).div(foreignDecimals);\r\n            uint256 requireAmount = foreignAmount.mul(rate2) / (PRICE_NOMINATOR*NOMINATOR);\r\n            if (totalSupply < nativeAmount.add(requireAmount)) {\r\n                requireAmount = totalSupply.sub(nativeAmount);\r\n                rest = foreignAmount.sub(requireAmount.mul(PRICE_NOMINATOR*NOMINATOR).div(rate2));\r\n                foreignAmount = foreignAmount.sub(rest);\r\n            }\r\n            nativeAmount = nativeAmount.add(requireAmount);\r\n            uint256 amount;\r\n            (rate2, amount) = _decode(balanceOf[FOREIGN]);\r\n            rate2 = rate2.mul(NOMINATOR).mul(nativeDecimals).div(foreignDecimals);\r\n            uint256 amount2 = amount.sub(foreignSpent, \"ForeignSpent balance higher then local\");\r\n            // rate2, amount2 - rate and amount swapped foreign tokens\r\n\r\n            if (amount2 != 0) { // recalculate avarage rate (native amount / foreign amount)\r\n                rate =  ((amount2.mul(rate2)/(PRICE_NOMINATOR*NOMINATOR)).add(requireAmount)).mul(PRICE_NOMINATOR*foreignDecimals).div((amount2.add(foreignAmount)).mul(nativeDecimals));\r\n            }\r\n            balanceOf[FOREIGN] = _encode(rate, amount.add(foreignAmount));\r\n        }\r\n    }\r\n\r\n    receive() external payable {\r\n        require(msg.sender == factory, \"Not a factory\");\r\n    }\r\n}\r\n"
    },
    "localhost/contracts/BNBETH/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n"
    }
  }
}