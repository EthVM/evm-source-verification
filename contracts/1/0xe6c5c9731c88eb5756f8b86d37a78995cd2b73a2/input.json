{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"push2ENS.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\n//  ____  _  _  ____  _  _    ____    ____  __ _  ____\n// (  _ \\/ )( \\/ ___)/ )( \\  (___ \\  (  __)(  ( \\/ ___)\n//  ) __/) \\/ (\\___ \\) __ (   / __/   ) _) /    /\\___ \\\n// (__)  \\____/(____/\\_)(_/  (____)  (____)\\_)__)(____/\n//\n// By Alex Van de Sande\n//\n// A little contract that adds push & pull money transfer to ENS ensAddresses.\n// Will work with any ENS, existing or future, including DNS names!\n// Ether, tokens and NFTs remain locked by contract until ENS is set up properly.\n// Once ENS points to a non-zero address, anyone can pull it there.\n//\n// Want to donate USDC to wikipedia.org but they don't have an eth address yet?\n// Want to send an NFT to xkcd.org but you're not sure how to trust the address?\n// Want to make an Ether bounty for the Ethiopian government to be aware of ENS?\n// Now you can do all that and more!\n// But wait, there's more! You can also use it to push to a normal address.\n// Just because.\n//\n// ATTENTION: use at your own risk! I've barely tested it. And by barely I mean I tried a couple different things\n// on rinkeby and once they worked I deployed to mainnet. NFTs don't use _safeTransfer\n// because I was too lazy to build my own onerc721Received. Be careful out there.\n\npragma solidity ^0.8.0;\n/// @title Push to ENS\n/// @author Alex Van de Sande\n/// @notice Allows tokens and ether to be deposited to ENS names\n/// @dev Supports ether, erc20 tokens and erc721 NFTs.\n\nimport \"./supportsENS.sol\";\n\n// works for both Tokens and NFTs\nabstract contract Transferable {\n    function transferFrom(address from, address to, uint tokens) virtual public;\n}\n\ncontract PushToENS is SupportsENS {\n\n  /// @notice Internal balance function\n  /// @dev Balances are a hash based on token and account information\n  mapping(bytes32 => Balance) public balances;\n\n  struct Balance {\n      uint256 withdrawable;\n      uint256 lastBlockPulled;\n      mapping(address => uint256) pusher;\n      mapping(address => uint256) lastPushed;\n  }\n\n  event Pushed(bytes32 nameHash, address assetAddress, uint8 sendType, uint256 amount);\n  event Pulled(bytes32 nameHash, address assetAddress, uint8 sendType, uint256 amount);\n  event Cancel(bytes32 nameHash, address assetAddress, uint8 sendType, uint256 amount);\n\n  // PUSH FUNCTIONS\n\n   /**\n    * @dev Generic internal push functions\n    */\n  function _push (bytes32 hash, uint256 amount, address assetAddress, uint8 sendType) internal {\n    Balance storage balance = balances[hash];\n\n    // If there was a pull since you last pushed, then you can't withdraw that amount anymore\n    if (balance.lastPushed[msg.sender] < balance.lastBlockPulled) balance.pusher[msg.sender]=0;\n\n    // Weird things can happen in the same block\n    require(balance.lastPushed[msg.sender] != balance.lastBlockPulled || balance.lastBlockPulled == 0, \"You can't push the same block on a pull\");\n\n    // Prevent Overflows\n    require(balance.pusher[msg.sender] + amount > balance.pusher[msg.sender] , \"Overflow detected!\");\n    require(balance.withdrawable + amount > balance.withdrawable , \"Overflow detected!\");\n\n    // Increase the balances\n    balance.withdrawable  += amount;\n    balance.pusher[msg.sender]+= amount;\n    balance.lastPushed[msg.sender] = block.number;\n\n    // tell everyone about it\n    emit Pushed(hash, assetAddress, sendType, amount);\n  }\n\n   /**\n    * @notice Pushes ether sent in transaction for an ENS name represented by `nameHash`\n    * @param nameHash a 256-bit hash that represents an ENS name. See: https://docs.ens.domains/contract-api-reference/name-processing\n    */\n  function pushEther2ENS (bytes32 nameHash) public payable {\n    _push(nameHash, msg.value, 0x0000000000000000000000000000000000000000, 0);\n  }\n\n   /**\n    * @notice Pushes ether sent in transaction for `ethAddress`\n    * @param ethAddress a standard ethereum compatible address\n    */\n  function pushEther2Ethadd (address ethAddress) public payable {\n    _push(keccak256(abi.encode(ethAddress)), msg.value, 0x0000000000000000000000000000000000000000, 1);\n  }\n\n   /**\n    * @notice Pushes `amount` standard units of the `assetAddress` token for an ENS address represented by `nameHash`.\n    * @notice If `nftId` is set, then it assumes it's a ERC721 NFT and sends the one with `nftId`.\n    * @dev If it's a token, leave nftId as 0. Can't send any NFT with id 0.\n    * @param nameHash a 256-bit hash that represents an ENS name. See: https://docs.ens.domains/contract-api-reference/name-processing\n    * @param assetAddress The address of either the token or NFT\n    * @param amount Token amount. If it's an NFT, leave 0.\n    * @param nftId the id of the NFT being sent. If it's a token, leave 0.\n    */\n  function pushAsset2ENS (bytes32 nameHash, address assetAddress, uint256 amount, uint256 nftId) public {\n     // instantiate token\n     Transferable asset = Transferable(assetAddress);\n     uint256 wat;\n\n     if (nftId==0) {\n        // If fungible, then add all balances\n        wat = amount;\n        _push(keccak256(abi.encode(nameHash,assetAddress)), amount, assetAddress, 2);\n     } else {\n       // If not, then use amount as the nft ID\n       wat = nftId;\n        _push(keccak256(abi.encode(nameHash,assetAddress,nftId)), nftId, assetAddress, 3);\n    }\n\n    // transfer assets. Doesn't add a require, assumes token will revert if fails\n    asset.transferFrom(msg.sender, address(this), wat);\n  }\n\n  // PULL FUNCTIONS\n\n   /**\n    * @dev Generic internal pull function\n    */\n  function _pull (bytes32 hash, address assetAddress, uint8 sendType) internal returns (uint256 amount){\n    Balance storage balance = balances[hash];\n\n    amount = balance.withdrawable;\n\n    //Pull full amount always\n    balance.withdrawable=0;\n    balance.lastBlockPulled = block.number;\n\n    // Interaction\n    emit Pulled(hash, assetAddress, sendType, amount );\n\n    return amount;\n  }\n\n   /**\n    * @notice Pulls ether for any valid ENS name.\n    * @dev Function can be called by anyone. Will revert if ENS name is not set, or set to 0x.\n    * @param nameHash a 256-bit hash that represents an ENS name. See: https://docs.ens.domains/contract-api-reference/name-processing\n    */\n  function pullEther2ENS (bytes32 nameHash) public {\n      // Zeroes out full balance\n      uint256 amount = _pull(nameHash, 0x0000000000000000000000000000000000000000, 0);\n\n      //Interaction\n      // getSafeENSAddress prevents returning empty address\n      sendValue(payable(getSafeENSAddress(nameHash)), amount);\n  }\n\n   /**\n    * @notice Pulls all ether pushed for your address.\n    * @dev Can only be called by the address receiving the token.\n    */\n  function pullEther2Ethadd () public {\n      // Zeroes out full balance\n      uint256 amount = _pull(keccak256(abi.encode(msg.sender)), 0x0000000000000000000000000000000000000000, 1);\n\n      //Interaction\n      sendValue(payable(msg.sender), amount);\n  }\n\n   /**\n    * @notice Pulls all of the balance from token `assetAddress` for the ENS address represented by `nameHash`.\n    * @notice If `nftId` is set, then it assumes it's a NFT and pulls the one with `nftId`.\n    * @dev Can be called by anyone. If it's a token, leave nftId as 0. Can only pull full amounts.\n    * @dev Function will revert if ENS is not set or set to 0x0.\n    * @param nameHash a 256-bit hash that represents an ENS name. See: https://docs.ens.domains/contract-api-reference/name-processing\n    * @param assetAddress The address of either the token or NFT\n    * @param nftId the id of the NFT being sent. If it's a token, leave 0.\n     */\n  function pullAsset2ENS (bytes32 nameHash, address assetAddress, uint nftId) public {\n       // instantiate token\n     Transferable asset = Transferable(assetAddress);\n    uint256 wat;\n    // If it's a token then use nftId as 0\n    if (nftId==0){\n      //if ID is 0 then it's a token\n      wat = _pull(keccak256(abi.encode(nameHash,assetAddress)), assetAddress, 2);\n    } else {\n      //if ID is set then it's an NFT\n      wat = nftId;\n      _pull(keccak256(abi.encode(nameHash, assetAddress, nftId)), assetAddress, 3);\n    }\n\n    // getSafeENSAddress prevents returning empty address\n      asset.transferFrom(address(this), getSafeENSAddress(nameHash), wat);\n  }\n\n    // CANCEL FUNCTIONS\n\n   /**\n    * @dev Generic internal cancel function\n    */\n  function _cancel (bytes32 hash, uint256 amount, address assetAddress, uint8 sendType) internal {\n     Balance storage balance = balances[hash];\n\n    // Can only cancel if there wasn't a push yet\n    require(balance.lastPushed[msg.sender] > balance.lastBlockPulled || balance.lastBlockPulled == 0, \"Recipient already withdrew\");\n\n    // Check if enough balance\n    require(amount <= balance.pusher[msg.sender] , \"Not enough balance\");\n    require(amount <= balance.withdrawable , \"Not enough balance\");\n\n    // Decrease both balances\n    balance.pusher[msg.sender]-= amount;\n    balance.withdrawable -= amount;\n\n    // Interaction\n    emit Cancel(hash, assetAddress, sendType, amount );\n  }\n\n  /**\n    * @dev Get back `amount/1000000000000000000` ether you had pushed to an ENS name but it hasn't pulled yet.\n    * @param nameHash a 256-bit hash that represents an ENS name. See: https://docs.ens.domains/contract-api-reference/name-processing\n    * @param amount Ether amount you want to get back.\n    */\n  function cancelEther2ENS (bytes32 nameHash, uint256 amount) public {\n      // Generic cancel function\n      _cancel(nameHash, amount, 0x0000000000000000000000000000000000000000, 0);\n\n      //Interaction\n      // getSafeENSAddress prevents returning empty address\n      sendValue(payable(msg.sender), amount);\n  }\n\n\n   /**\n    * @dev Get back `amount/1000000000000000000` ether you had pushed to an Eth address name but it hasn't pulled yet.\n    * @param ethAddress The address which you had pushed to.\n    * @param amount Ether amount you want to get back.\n    */\n  function cancelEther2Ethadd (address ethAddress, uint256 amount) public {\n      // Generic cancel function\n       _cancel(keccak256(abi.encode(ethAddress)), amount, 0x0000000000000000000000000000000000000000, 1);\n\n      //Interaction\n      sendValue(payable(msg.sender), amount);\n  }\n\n   /**\n    * @notice Get back tokens or NFT you had pushed to an ENS name but hasn't been claimed yet.\n    * @param nameHash a 256-bit hash that represents an ENS name. See: https://docs.ens.domains/contract-api-reference/name-processing\n    * @param assetAddress The address of either the token or NFT\n    * @param amount Amount you want to pull back\n    * @param nftId the id of the NFT being sent. If it's a token, leave 0.\n    */\n  function cancelAsset2ENS (bytes32 nameHash,  address assetAddress, uint256 amount, uint256 nftId) public {\n       // instantiate token\n     Transferable asset = Transferable(assetAddress);\n     uint256 wat;\n     //generic cancel\n     // getSafeENSAddress prevents returning empty address\n     if (nftId==0) {\n       // If it's a token then pull all of them\n       wat= amount;\n       _cancel(keccak256(abi.encode(nameHash,assetAddress)), amount, assetAddress, 2);\n     } else {\n       // if it's an NFT use amount as tokenId\n       wat=nftId;\n       _cancel(keccak256(abi.encode(nameHash, assetAddress, amount)), amount, assetAddress, 3);\n     }\n\n    // transfer tokens\n    asset.transferFrom(address(this), msg.sender, wat);\n\n  }\n\n\n     /**\n     * Open Zeppellin's Send Value\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"},"supportsENS.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n// This is a quick and small library for allowing any contract to\n// use ENS names like they would use a standard address.\n// So a DAO can have bob.eth as the member, instead of 0x123,\n// and therefore Bob can change that address to whatever they prefer\n// or give out a tip that can be only received by the rightful owner of example.com\n// even if example.com owner never heard about ethereum!\n//\n// To use it, just use a store the NameHash as a string and then call\n// updateAddress(NameHash) to save the latest ethereum address it points to\n// Once that has been saved, use ensAddresses(NameHash) to obtain a valid eth address.\n// Optionally, you can check lastUpdatedENSAt(NameHash) to check the last time\n// it was updated. If it was never updated then both functions should return 0:\n// IMPORTANT: check if address is not address(0) before sending ether.\n\n// Learn more about NameHash: https://docs.ens.domains/contract-api-reference/name-processing\n// Learn more about full DNS support in ENS: https://medium.com/the-ethereum-name-service/full-dns-namespace-integration-to-ens-now-on-mainnet-9d37270807d3\n// Learn more about ENS: ens.domains\n\n// Author: Alex Van de Sande\n// License: Public Domain\n\npragma solidity ^0.8.0;\n\nabstract contract  ENS {\n    function resolver(bytes32 node) public virtual view  returns (Resolver);\n}\n\nabstract contract Resolver {\n    function addr(bytes32 node) public virtual view returns (address);\n}\n\ncontract SupportsENS {\n    // Same address for Mainet, Ropsten, Rinkerby, Gorli and other networks;\n    ENS ens = ENS(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\n\n    // Optional modifier to only allow calls from a specific ENS owner\n    modifier onlyENSOwner(bytes32 nameHash) {\n        require(\n            msg.sender == getENSAddress(nameHash),\n            \"Only ENS owner can call this contract\"\n            );\n            _;\n    }\n\n    // Main function to get an address\n    // ATTENTION: if an ENS is not set or claimed, it will return 0x0.\n    // Make sure to check this before sending ether.\n    function getENSAddress(bytes32 nameHash) public view returns (address){\n        Resolver resolver = ens.resolver(nameHash);\n        return resolver.addr(nameHash);\n    }\n\n    // Similar to the function above but will\n    // revert if the address returns 0x00..\n    function getSafeENSAddress(bytes32 nameHash) public view returns (address){\n        Resolver resolver = ens.resolver(nameHash);\n        address res = resolver.addr(nameHash);\n        require(res != address(0), \"address not set or set to burn\");\n        return res;\n    }\n\n}\n"}}}