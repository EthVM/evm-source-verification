{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CouponPresale.sol":{"content":"pragma solidity ^0.5.17;\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n//the dao interface\r\ninterface IAdvance{\r\n    function advance() external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n    \r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n}\r\n\r\ncontract CouponPresale{\r\n    using SafeMath for uint256;\r\n    \r\n    uint256 public totalSale;\r\n    \r\n    address public ssdTokenAddr;\r\n    \r\n    address public ssdDaoAddr;\r\n    \r\n    address public _owner;\r\n    \r\n    address constant usdcAddr=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n    \r\n    mapping(address=>uint256)  public couponSale;\r\n    \r\n    mapping(address=>uint256)  public usdcBuy;\r\n    \r\n    constructor() public{\r\n        _owner=msg.sender;\r\n        \r\n        //old contract data\r\n        couponSale[0x5d4F95ceB7A6d57e742f7018aDa8Ac7705f7a9EA].add(206774676*10/8);\r\n        couponSale[0xfd8a63085804DCB95417fe33f9E49253522c68DD].add(2007615528*10/8);\r\n        couponSale[0x7Aa9d09A6d283F5b5ec724D7dd8fa70673553183].add(821041200*10/8);\r\n        couponSale[0x67443683D43bdE8274acC78b3e8CE6EC6F72A1A6].add(731311560*10/8);\r\n        couponSale[0xcFe4D656F5855D82f61786E7577ae37A192C633e].add(200000000*10/8);\r\n        couponSale[0x75c8E2dd57927eB0373E8e201ebF582406aDcf45].add(2000000000*10/8);\r\n    }\r\n    \r\n    function setRealAddrs(address dao,address ssd) public{\r\n        require(msg.sender==_owner,'not owner');\r\n        ssdDaoAddr=dao;\r\n        ssdTokenAddr=ssd;\r\n    }\r\n    \r\n    function buyCoupons(uint256 amount) public {\r\n        require(block.timestamp>1608998399,'wait for start');\r\n        require(block.timestamp<1609171199,'end');\r\n        require(amount>=200000000,'revert');\r\n        require(usdcBuy[msg.sender].add(amount)<=2000000000,'buy limit');\r\n        bool ret = IERC20(usdcAddr).transferFrom(msg.sender,address(this),amount);\r\n        require(ret,'revert');\r\n        usdcBuy[msg.sender]=usdcBuy[msg.sender].add(amount);\r\n        amount=amount.mul(10).div(8);\r\n        totalSale=totalSale.add(amount);\r\n        require(totalSale<=250000000000,'hard cap');\r\n        couponSale[msg.sender]=couponSale[msg.sender].add(amount);\r\n    }\r\n    \r\n    function withdrawUSDC() public{\r\n        IERC20(usdcAddr).transfer(_owner,IERC20(usdcAddr).balanceOf(address(this)));\r\n    }\r\n    \r\n    \r\n    //when almost user withdrawSSD\r\n    function withdrawLeft(uint256 amount) public{\r\n        require(msg.sender==_owner);\r\n        require(totalSale>200000000,'team limit');\r\n        IERC20(ssdTokenAddr).transfer(_owner,amount);\r\n    }\r\n    \r\n    function withdrawSSD(uint256 amount) public{\r\n        require(couponSale[msg.sender]>=amount,'no coupon!');\r\n        //calc to ssd token amount\r\n        uint256 needSSD=amount*1e12;\r\n        require(IERC20(ssdTokenAddr).balanceOf(address(this))>=needSSD,'not enough ssd,please wait epoch');\r\n        couponSale[msg.sender]=couponSale[msg.sender].sub(amount);\r\n        totalSale=totalSale.sub(amount);\r\n        IERC20(ssdTokenAddr).transfer(msg.sender,needSSD);\r\n    }\r\n    \r\n    //only trigger by team\r\n    function advance() external {\r\n        IAdvance(ssdDaoAddr).advance();\r\n    }\r\n}"}}}