{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/STYK1.sol": {
      "content": "\n// File: contracts\\SafeMath.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity  ^0.6.0;\n\ncontract SafeMath {\n   /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return safeSub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function safeSub(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\n        require(b <= a, error);\n        uint256 c = a - b;\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return safeDiv(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function safeDiv(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\n        require(b > 0, error);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function safeExponent(uint256 a,uint256 b) internal pure returns (uint256) {\n        uint256 result;\n        assembly {\n            result:=exp(a, b)\n        }\n        return result;\n    }\n}\n\n// File: contracts\\DateTime.sol\n\npragma solidity ^0.6;\n\ncontract DateTime {\n        /*\n         *  Date and Time utilities for ethereum contracts\n         *\n         */\n        struct _DateTime {\n                uint16 year;\n                uint8 month;\n                uint8 day;\n                uint8 hour;\n                uint8 minute;\n                uint8 second;\n                uint8 weekday;\n        }\n\n        uint constant DAY_IN_SECONDS = 86400;\n        uint constant YEAR_IN_SECONDS = 31536000;\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n\n        uint constant HOUR_IN_SECONDS = 3600;\n        uint constant MINUTE_IN_SECONDS = 60;\n\n        uint16 constant ORIGIN_YEAR = 1970;\n\n        function isLeapYear(uint16 year) public pure returns (bool) {\n                if (year % 4 != 0) {\n                        return false;\n                }\n                if (year % 100 != 0) {\n                        return true;\n                }\n                if (year % 400 != 0) {\n                        return false;\n                }\n                return true;\n        }\n\n        function leapYearsBefore(uint year) public pure returns (uint) {\n                year -= 1;\n                return year / 4 - year / 100 + year / 400;\n        }\n\n        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n                        return 31;\n                }\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\n                        return 30;\n                }\n                else if (isLeapYear(year)) {\n                        return 29;\n                }\n                else {\n                        return 28;\n                }\n        }\n\n        function parseTimestamp(uint timestamp) internal pure returns (_DateTime memory dt) {\n                uint secondsAccountedFor = 0;\n                uint buf;\n                uint8 i;\n\n                // Year\n                dt.year = getYear(timestamp);\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n\n                // Month\n                uint secondsInMonth;\n                for (i = 1; i <= 12; i++) {\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\n                                dt.month = i;\n                                break;\n                        }\n                        secondsAccountedFor += secondsInMonth;\n                }\n\n                // Day\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n                                dt.day = i;\n                                break;\n                        }\n                        secondsAccountedFor += DAY_IN_SECONDS;\n                }\n\n                // Hour\n                dt.hour = getHour(timestamp);\n\n                // Minute\n                dt.minute = getMinute(timestamp);\n\n                // Second\n                dt.second = getSecond(timestamp);\n\n                // Day of week.\n                dt.weekday = getWeekday(timestamp);\n        }\n\n        function getYear(uint timestamp) public pure returns (uint16) {\n                uint secondsAccountedFor = 0;\n                uint16 year;\n                uint numLeapYears;\n\n                // Year\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n\n                while (secondsAccountedFor > timestamp) {\n                        if (isLeapYear(uint16(year - 1))) {\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n                        }\n                        else {\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\n                        }\n                        year -= 1;\n                }\n                return year;\n        }\n\n        function getMonth(uint timestamp) public pure returns (uint8) {\n                return parseTimestamp(timestamp).month;\n        }\n\n        function getDay(uint timestamp) public pure returns (uint8) {\n                return parseTimestamp(timestamp).day;\n        }\n\n        function getHour(uint timestamp) public pure returns (uint8) {\n                return uint8((timestamp / 60 / 60) % 24);\n        }\n\n        function getMinute(uint timestamp) public pure returns (uint8) {\n                return uint8((timestamp / 60) % 60);\n        }\n\n        function getSecond(uint timestamp) public pure returns (uint8) {\n                return uint8(timestamp % 60);\n        }\n\n        function getWeekday(uint timestamp) public pure returns (uint8) {\n                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n        }\n\n        function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\n                return toTimestamp(year, month, day, 0, 0, 0);\n        }\n\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\n                return toTimestamp(year, month, day, hour, 0, 0);\n        }\n\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\n                return toTimestamp(year, month, day, hour, minute, 0);\n        }\n\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\n                uint16 i;\n\n                // Year\n                for (i = ORIGIN_YEAR; i < year; i++) {\n                        if (isLeapYear(i)) {\n                                timestamp += LEAP_YEAR_IN_SECONDS;\n                        }\n                        else {\n                                timestamp += YEAR_IN_SECONDS;\n                        }\n                }\n\n                // Month\n                uint8[12] memory monthDayCounts;\n                monthDayCounts[0] = 31;\n                if (isLeapYear(year)) {\n                        monthDayCounts[1] = 29;\n                }\n                else {\n                        monthDayCounts[1] = 28;\n                }\n                monthDayCounts[2] = 31;\n                monthDayCounts[3] = 30;\n                monthDayCounts[4] = 31;\n                monthDayCounts[5] = 30;\n                monthDayCounts[6] = 31;\n                monthDayCounts[7] = 31;\n                monthDayCounts[8] = 30;\n                monthDayCounts[9] = 31;\n                monthDayCounts[10] = 30;\n                monthDayCounts[11] = 31;\n\n                for (i = 1; i < month; i++) {\n                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n                }\n\n                // Day\n                timestamp += DAY_IN_SECONDS * (day - 1);\n\n                // Hour\n                timestamp += HOUR_IN_SECONDS * (hour);\n\n                // Minute\n                timestamp += MINUTE_IN_SECONDS * (minute);\n\n                // Second\n                timestamp += second;\n\n                return timestamp;\n        }\n}\n\n// File: contracts\\STYK_I.sol\n\npragma solidity ^0.6.0;\n\n\n\ncontract STYK_I is SafeMath, DateTime {\n    constructor(\n        uint256 _lockTime,\n        uint256 _auctionExpiryTime,\n        uint256 _auctionLimit,\n        uint256 _stakeAmount\n    ) public {\n        STYK_REWARD_TOKENS = safeMul(200000, 1e18);\n        MONTHLY_REWARD_TOKENS = safeMul(100000, 1e18);\n\n        tokenBalanceLedger_[address(this)] = safeAdd(\n            STYK_REWARD_TOKENS,\n            MONTHLY_REWARD_TOKENS\n        );\n        // time lock for 100 years\n        lockTime = _lockTime;\n        auctionExpiryTime = _auctionExpiryTime;\n        auctionEthLimit = _auctionLimit;\n        stakingRequirement = _stakeAmount;\n        inflationPayOutDays = safeAdd(now, 500 days);\n    }\n\n    /*=================================\n    =            MODIFIERS            =\n    =================================*/\n    // only people with tokens\n    modifier onlybelievers() {\n        require(myTokens() > 0);\n        _;\n    }\n\n    // only people with profits\n    modifier onlyhodler() {\n        require(myDividends(true) > 0);\n        _;\n    }\n\n    /*==============================\n    =            EVENTS            =\n    ==============================*/\n    event onTokenPurchase(\n        address indexed customerAddress,\n        uint256 incomingEthereum,\n        uint256 tokensMinted,\n        address indexed referredBy\n    );\n\n    event onTokenSell(\n        address indexed customerAddress,\n        uint256 tokensBurned,\n        uint256 ethereumEarned\n    );\n\n    event onReinvestment(\n        address indexed customerAddress,\n        uint256 ethereumReinvested,\n        uint256 tokensMinted\n    );\n\n    event onWithdraw(\n        address indexed customerAddress,\n        uint256 ethereumWithdrawn\n    );\n\n    // ERC20\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n\n    /*=====================================\n    =            CONFIGURABLES            =\n    =====================================*/\n    string public name = \"STYK I\";\n    string public symbol = \"STYK\";\n    uint256 public constant decimals = 18;\n    uint8 internal constant dividendFee_ = 10;\n    uint256 internal constant tokenPriceInitial_ = 0.0000001 ether;\n    uint256 internal constant tokenPriceIncremental_ = 0.00000001 ether;\n    uint256 internal constant magnitude = 2**64;\n    uint256 STYK_REWARD_TOKENS;\n\n    uint256 MONTHLY_REWARD_TOKENS;\n\n    uint256 internal inflationTime;\n\n    uint256 internal lockTime;\n    uint256 internal inflationPayOutDays;\n    uint56 internal userCount = 0;\n    uint256 public inflationCounter = 0;\n\n    // proof of stake (defaults at 1 token)\n    uint256 internal stakingRequirement;\n\n    /*================================\n    =            DATASETS            =\n    ================================*/\n\n    mapping(address => uint256) internal tokenBalanceLedger_;\n    mapping(address => uint256) internal referralBalance_;\n    mapping(address => bool) public rewardQualifier;\n    mapping(address => uint256) internal stykRewards;\n    mapping(address => address[]) internal referralUsers;\n    mapping(address => mapping(address => bool)) internal userExists;\n    mapping(address => bool) internal earlyadopters;\n    mapping(address => bool) internal userAdded;\n    mapping(address => uint256) internal userIndex;\n    mapping(address => int256) internal payoutsTo_;\n    mapping(address => uint256) internal totalMonthRewards;\n    mapping(address => uint256) internal earlyadopterBonus;\n    mapping(address => uint256) internal userDeposit;\n    mapping(address => bool) internal auctionAddressTracker;\n    mapping(address => mapping(uint256 => mapping (uint256 => bool)))public monthlyRewardsClaimed;\n    mapping(address =>mapping(uint256 => bool))public stykclaimMap;\n\n    address[] internal userAddress;\n    uint256 internal tokenSupply_ = 0;\n    uint256 public auctionEthLimit;\n    uint256 public auctionExpiryTime;\n    uint256 internal profitPerShare_;\n    uint256 internal auctionProfitPerShare_;\n\n    /**\n     * Converts all incoming Ethereum to tokens for the caller, and passes down the referral address (if any)\n     */\n    function buy(address _referredBy) public payable returns (uint256) {\n        purchaseTokens(msg.value, _referredBy);\n    }\n\n    //Cannot directly deposit ethers\n    fallback() external payable {\n        revert(\"ERR_CANNOT_FORCE_ETHERS\");\n    }\n\n    //Cannot directly deposit ethers\n    receive() external payable {\n        revert(\"ERR_CANNOT_FORCE_ETHERS\");\n    }\n\n    /**\n     * Converts all of caller's dividends to tokens.\n     */\n    function reinvest() public onlyhodler() {\n        // pay out the dividends virtually\n        address _customerAddress = msg.sender;\n        // fetch dividends\n        uint256 _dividends = totalDividends(_customerAddress);\n        userDeposit[_customerAddress] = 0;\n        payoutsTo_[_customerAddress] += (int256)(\n            _dividendsOf(_customerAddress) * magnitude\n        );\n        referralBalance_[_customerAddress] = 0;\n\n        //determine whether user qualify for early adopter bonus or not\n        if (\n            earlyadopters[_customerAddress] &&\n            (now > safeAdd(auctionExpiryTime, 24 hours))\n        ) {\n            if (tokenBalanceLedger_[_customerAddress] == 0) {\n                earlyadopterBonus[_customerAddress] = 0;\n            }\n            earlyadopters[_customerAddress] = false;\n        }\n\n        //determine whether user qualify for styk bonus or not\n        if (\n            rewardQualifier[_customerAddress] &&\n            _calculateInflationMinutes() > 4320\n        ) {\n            stykRewards[_customerAddress] = 0;\n            rewardQualifier[_customerAddress] = false;\n        }\n        if (totalMonthRewards[_customerAddress] != 0) {\n            totalMonthRewards[_customerAddress] = 0;\n        }\n\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\n        uint256 _tokens = purchaseTokens(_dividends, address(0));\n\n        // fire event\n        emit onReinvestment(_customerAddress, _dividends, _tokens);\n    }\n\n    /**\n     * Alias of sell() and withdraw().\n     */\n    function exit() public {\n        // get token count for caller & sell them all\n        address _customerAddress = msg.sender;\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n\n        if (_tokens > 0) sell(_tokens);\n\n        withdraw();\n        userAdded[_customerAddress] = false;\n\n        uint256 index = getUserAddressIndex(_customerAddress);\n        address _lastAddress = userAddress[userAddress.length - 1];\n        uint256 _lastindex = getUserAddressIndex(_lastAddress);\n        userAddress[index] = _lastAddress;\n        userAddress[userAddress.length - 1] = _customerAddress;\n\n        userIndex[_lastAddress] = index;\n        userIndex[_customerAddress] = _lastindex;\n        delete userIndex[_customerAddress];\n        userAddress.pop();\n        userCount--;\n    }\n\n    /**\n     * Withdraws all of the callers earnings.\n     */\n    function withdraw() public onlyhodler() {\n        // setup data\n        address payable _customerAddress = msg.sender;\n        uint256 _dividends = totalDividends(_customerAddress);\n\n        userDeposit[_customerAddress] = 0;\n        // update dividend tracker\n        payoutsTo_[_customerAddress] += (int256)(\n            _dividendsOf(_customerAddress) * magnitude\n        );\n        referralBalance_[_customerAddress] = 0;\n\n        //determine whether user qualify for early adopter bonus or not\n        if (\n            earlyadopters[_customerAddress] &&\n            (now > safeAdd(auctionExpiryTime, 24 hours))\n        ) {\n            if (tokenBalanceLedger_[_customerAddress] == 0) {\n                earlyadopterBonus[_customerAddress] = 0;\n            }\n            earlyadopters[_customerAddress] = false;\n        }\n\n        //determine whether user qualify for styk bonus or not\n        if (\n            rewardQualifier[_customerAddress] &&\n            _calculateInflationMinutes() > 4320\n        ) {\n            stykRewards[_customerAddress] = 0;\n            rewardQualifier[_customerAddress] = false;\n        }\n        if (totalMonthRewards[_customerAddress] != 0) {\n            totalMonthRewards[_customerAddress] = 0;\n        }\n        // delivery service\n        _customerAddress.transfer(_dividends);\n\n        // fire event\n        emit onWithdraw(_customerAddress, _dividends);\n    }\n\n    /**\n     * Liquifies tokens to ethereum.\n     */\n    function sell(uint256 _amountOfTokens) public onlybelievers() {\n        address _customerAddress = msg.sender;\n\n        require(\n            now > auctionExpiryTime,\n            \"ERR_CANNOT_SELL_TOKENS_BEFORE_AUCTION\"\n        );\n\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n\n        uint256 _tokens = _amountOfTokens;\n        uint256 _ethereum = tokensToEthereum_(_tokens);\n        uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n        uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\n\n        if (tokenBalanceLedger_[_customerAddress] == _amountOfTokens) {\n            if (earlyadopters[_customerAddress]) {\n                earlyadopterBonus[_customerAddress] = earlyAdopterBonus(\n                    _customerAddress\n                );\n            }\n            if (rewardQualifier[_customerAddress]) {\n                stykRewards[_customerAddress] = STYKRewards(_customerAddress);\n            }\n        }\n\n        // burn the sold tokens\n        tokenSupply_ = safeSub(tokenSupply_, _tokens);\n        tokenBalanceLedger_[_customerAddress] = safeSub(\n            tokenBalanceLedger_[_customerAddress],\n            _tokens\n        );\n\n        if (auctionAddressTracker[_customerAddress]) {\n            int256 _updatedPayouts = (int256)(auctionProfitPerShare_ * _tokens);\n            payoutsTo_[_customerAddress] -= _updatedPayouts;\n        } else {\n            int256 _updatedPayouts = (int256)(profitPerShare_ * _tokens);\n            payoutsTo_[_customerAddress] -= _updatedPayouts;\n        }\n\n        // dividing by zero is a bad idea\n        if (tokenSupply_ > 0) {\n            // update the amount of dividends per token\n            auctionProfitPerShare_ = safeAdd(\n                auctionProfitPerShare_,\n                (_dividends * magnitude) /\n                    safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)])\n            );\n\n            profitPerShare_ = safeAdd(\n                profitPerShare_,\n                (_dividends * magnitude) /\n                    safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)])\n            );\n        }\n\n        userDeposit[_customerAddress] = safeAdd(\n            userDeposit[_customerAddress],\n            _taxedEthereum\n        );\n\n        // fire events\n        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);\n        emit Transfer(_customerAddress, address(0), _amountOfTokens);\n    }\n\n    /*----------  HELPERS AND CALCULATORS  ----------*/\n    /**\n     * Method to view the current Ethereum stored in the contract\n     * Example: totalEthereumBalance()\n     */\n    function totalEthereumBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * Retrieve the total token supply.\n     */\n    function totalSupply() public view returns (uint256) {\n        return tokenSupply_;\n    }\n\n    /**\n     * Retrieve the tokens owned by the caller.\n     */\n    function myTokens() public view returns (uint256) {\n        address _customerAddress = msg.sender;\n        return balanceOf(_customerAddress);\n    }\n\n    /**\n     * Retrieve the dividends owned by the caller.\n     */\n    function myDividends(bool _includeReferralBonus)\n        public\n        view\n        returns (uint256)\n    {\n        address _customerAddress = msg.sender;\n        return\n            _includeReferralBonus\n                ? _dividendsOf(_customerAddress) +\n                    referralBalance_[_customerAddress]\n                : _dividendsOf(_customerAddress);\n    }\n\n    /**\n     * Retrieve the token balance of any single address.\n     */\n    function balanceOf(address _customerAddress) public view returns (uint256) {\n        return tokenBalanceLedger_[_customerAddress];\n    }\n\n    /**\n     * Retrieve the dividend balance of any single address.\n     */\n    function _dividendsOf(address _customerAddress)\n        public\n        view\n        returns (uint256)\n    {\n        if (auctionAddressTracker[_customerAddress]) {\n            return\n                safeAdd(\n                    (uint256)(\n                        (int256)(\n                            auctionProfitPerShare_ *\n                                (tokenBalanceLedger_[_customerAddress])\n                        ) - payoutsTo_[_customerAddress]\n                    ) / magnitude,\n                    userDeposit[_customerAddress]\n                );\n        } else {\n            return\n                safeAdd(\n                    (uint256)(\n                        (int256)(\n                            profitPerShare_ *\n                                (tokenBalanceLedger_[_customerAddress])\n                        ) - payoutsTo_[_customerAddress]\n                    ) / magnitude,\n                    userDeposit[_customerAddress]\n                );\n        }\n    }\n\n    /**\n     * Return the buy price of 1 individual token.\n     */\n    function sellPrice() external view returns (uint256) {\n        if (tokenSupply_ == 0) {\n            return tokenPriceInitial_ - tokenPriceIncremental_;\n        } else {\n            uint256 _ethereum = tokensToEthereum_(1e18);\n            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n            uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\n            return _taxedEthereum;\n        }\n    }\n\n    /**\n     * Return the sell price of 1 individual token.\n     */\n    function buyPrice() public view returns (uint256) {\n        if (tokenSupply_ == 0) {\n            return tokenPriceInitial_ + tokenPriceIncremental_;\n        } else {\n            uint256 _ethereum = tokensToEthereum_(1e18);\n            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n            uint256 _taxedEthereum = safeAdd(_ethereum, _dividends);\n            return _taxedEthereum;\n        }\n    }\n\n    function calculateTokensReceived(uint256 _ethereumToSpend)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 _dividends = safeDiv(_ethereumToSpend, dividendFee_);\n        uint256 _taxedEthereum = safeSub(_ethereumToSpend, _dividends);\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n        return _amountOfTokens;\n    }\n\n    function calculateEthereumReceived(uint256 _tokensToSell)\n        external\n        view\n        returns (uint256)\n    {\n        require(_tokensToSell <= tokenSupply_);\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\n        uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n        uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\n        return _taxedEthereum;\n    }\n\n    /*==========================================\n    =            Methods Developed By Minddeft    =\n    ==========================================*/\n\n    function _inflation() internal view returns (uint256) {\n        uint256 buyPrice_ = buyPrice();\n        uint256 inflation_factor = safeDiv(buyPrice_, 1e12);\n        return inflation_factor;\n    }\n\n    // chainlink already give data as 10**8 so convert to 18 decimal\n    function checkInflation() external view returns (uint256) {\n        return _inflation();\n    }\n\n    //To set inflationTime when inflation factor reaches 2% of ethereum\n    function setInflationTime() internal {\n        if (_inflation() >= 20000 || now > inflationPayOutDays) {\n            inflationTime = now;\n            inflationPayOutDays = safeAdd(inflationTime, 500 days);\n             ++inflationCounter;\n        }\n    }\n\n    //To calculate Inflation minutes (72 hours converted into minutes)\n    function _calculateInflationMinutes() internal view returns (uint256) {\n        if (inflationTime == 0) {\n            return 0;\n        }\n        return safeDiv(safeSub(now, inflationTime), 60);\n    }\n\n    function calculateInflationMinutes() external view returns (uint256) {\n        return _calculateInflationMinutes();\n    }\n\n    //To calculate Token Percentage\n    function _calculateTokenPercentage(address _customerAddress)\n        internal\n        view\n        returns (uint256)\n    {\n        if (tokenBalanceLedger_[_customerAddress] > 0) {\n            uint256 token_percent =\n                safeDiv(\n                    safeMul(tokenBalanceLedger_[_customerAddress], 1000000),\n                    totalSupply()\n                );\n            return token_percent;\n        }\n        return 0;\n    }\n\n    //To calculate Token Percentage\n    function calculateTokenPercentage(address _customerAddress)\n        external\n        view\n        returns (uint256)\n    {\n        return _calculateTokenPercentage(_customerAddress);\n    }\n\n    //To calculate user's STYK rewards\n    function _calculateSTYKReward(address _customerAddress)\n        internal\n        view\n        returns (uint256)\n    {\n        if (now > auctionExpiryTime) {\n            uint256 token_percent = _calculateTokenPercentage(_customerAddress);\n            if (token_percent > 0) {\n                uint256 rewards =\n                    safeDiv(\n                        safeMul(\n                            _dividendsOfPremintedTokens(STYK_REWARD_TOKENS),\n                            token_percent\n                        ),\n                        1000000\n                    );\n                return rewards;\n            }\n            return 0;\n        }\n        return 0;\n    }\n\n    function calculateSTYKReward(address _customerAddress)\n        external\n        view\n        returns (uint256)\n    {\n        return _calculateSTYKReward(_customerAddress);\n    }\n\n    //To activate deflation\n    function deflationSell() external {\n        uint256 inflationMinutes = _calculateInflationMinutes();\n        require(\n            inflationMinutes <= 4320,\n            \"ERR_INFLATION_MINUTES_SHOULD_BE_LESS_THAN_4320\"\n        );\n\n        require(!stykclaimMap[msg.sender][inflationCounter], \"ERR_REWARD_ALREADY_CLAIMED\");\n\n        if (_calculateSTYKReward(msg.sender) > 0) {\n            rewardQualifier[msg.sender] = true;\n            stykclaimMap[msg.sender][inflationCounter] = true;\n            uint256 rewards = _calculateSTYKReward(msg.sender);\n\n            stykRewards[msg.sender] = safeAdd(stykRewards[msg.sender], rewards);\n\n            uint256 userToken =\n                safeDiv(safeMul(tokenBalanceLedger_[msg.sender], 25), 100);\n\n            sell(userToken);\n        }\n    }\n\n    //To accumulate rewards of non qualifying after deflation sell\n    function _deflationAccumulatedRewards() internal view returns (uint256) {\n        uint256 stykRewardPoolBalance = 0;\n\n        for (uint256 i = 0; i < userAddress.length; i++) {\n            if (userAddress[i] != address(0)) {\n                address _user = userAddress[i];\n                if (!rewardQualifier[_user]) {\n                    stykRewardPoolBalance = safeAdd(\n                        _calculateSTYKReward(_user),\n                        stykRewardPoolBalance\n                    );\n                }\n            }\n        }\n        return stykRewardPoolBalance;\n    }\n\n    //To pay STYK Rewards\n    function STYKRewards(address _to) internal view returns (uint256) {\n        if (_calculateTokenPercentage(_to) > 0) {\n            uint256 _rewards = stykRewards[_to];\n            uint256 accumulatedRewards =\n                safeDiv(\n                    safeMul(\n                        _deflationAccumulatedRewards(),\n                        _calculateTokenPercentage(_to)\n                    ),\n                    1000000\n                );\n            uint256 finalRewards = safeAdd(_rewards, accumulatedRewards);\n            return finalRewards;\n        }\n        return 0;\n    }\n\n    //To calculate team token holder percent\n    function _teamTokenHolder(address _to) internal view returns (uint256) {\n        uint256 useractivecount = 0;\n        uint256 usertotaltokens = 0;\n        if (profitPerShare_ > 0) {\n            for (uint256 i = 0; i < referralUsers[_to].length; i++) {\n                address _userAddress = referralUsers[_to][i];\n                if (_checkUserActiveStatus(_userAddress)) {\n                    ++useractivecount;\n                }\n            }\n\n            if (useractivecount >= 3) {\n                for (uint256 i = 0; i < referralUsers[_to].length; i++) {\n                    address _addr = referralUsers[_to][i];\n                    usertotaltokens = safeAdd(\n                        tokenBalanceLedger_[_addr],\n                        usertotaltokens\n                    );\n                }\n                return\n                    safeDiv(safeMul(usertotaltokens, 1000000), totalSupply());\n            } else {\n                return 0;\n            }\n        } else return 0;\n    }\n\n    function teamTokenHolder(address _to) external view returns (uint256) {\n        return _teamTokenHolder(_to);\n    }\n\n    // To calculate monthly  rewards\n    function _calculateMonthlyRewards(address _to)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 token_percent = _teamTokenHolder(_to);\n        if (token_percent != 0) {\n            uint256 rewards =\n                safeDiv(\n                    safeMul(\n                        _dividendsOfPremintedTokens(MONTHLY_REWARD_TOKENS),\n                        token_percent\n                    ),\n                    1000000\n                );\n\n            return rewards;\n        }\n        return 0;\n    }\n\n    function calculateMonthlyRewards(address _to)\n        external\n        view\n        returns (uint256)\n    {\n        return _calculateMonthlyRewards(_to);\n    }\n\n    // To check the user's  status\n    function _checkUserActiveStatus(address _user)\n        internal\n        view\n        returns (bool)\n    {\n        if (tokenBalanceLedger_[_user] > safeMul(10, 1e18)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    //To distribute rewards to early adopters\n    function earlyAdopterBonus(address _user) public view returns (uint256) {\n        if (tokenBalanceLedger_[_user] > 0 && earlyadopters[_user]) {\n            uint256 token_percent = _calculateTokenPercentage(_user);\n            uint256 _earlyadopterDividends =\n                (uint256)(\n                    (int256)(\n                        auctionProfitPerShare_ *\n                            tokenBalanceLedger_[address(this)]\n                    )\n                ) / magnitude;\n            uint256 rewards =\n                safeDiv(\n                    safeMul(_earlyadopterDividends, token_percent),\n                    1000000\n                );\n            return rewards;\n        }\n        return 0;\n    }\n\n    //To get user affiliate rewards\n    function getUserAffiliateBalance(address _user)\n        external\n        view\n        returns (uint256)\n    {\n        return referralBalance_[_user];\n    }\n\n    //To retrieve the index of user's address\n    function getUserAddressIndex(address _customerAddress)\n        internal\n        view\n        returns (uint256)\n    {\n        return userIndex[_customerAddress];\n    }\n\n    /**\n     * Retrieve the dividends from pre-minted tokens.\n     */\n    function _dividendsOfPremintedTokens(uint256 _tokens)\n        internal\n        view\n        returns (uint256)\n    {\n        return (uint256)((int256)(profitPerShare_ * _tokens)) / magnitude;\n    }\n\n    //To calculate total dividends of user\n    function totalDividends(address _customerAddress)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 _dividends = _dividendsOf(_customerAddress);\n\n        uint256 qualifying_rewards;\n        if (\n            earlyadopters[_customerAddress] &&\n            (now > safeAdd(auctionExpiryTime, 24 hours))\n        ) {\n            if (tokenBalanceLedger_[_customerAddress] > 0) {\n                qualifying_rewards = safeAdd(\n                    qualifying_rewards,\n                    earlyAdopterBonus(_customerAddress)\n                );\n            } else {\n                qualifying_rewards = safeAdd(\n                    qualifying_rewards,\n                    earlyadopterBonus[_customerAddress]\n                );\n            }\n        }\n        if (\n            rewardQualifier[_customerAddress] &&\n            _calculateInflationMinutes() > 4320\n        ) {\n            if (tokenBalanceLedger_[_customerAddress] > 0) {\n                qualifying_rewards = safeAdd(\n                    qualifying_rewards,\n                    STYKRewards(_customerAddress)\n                );\n            } else {\n                qualifying_rewards = safeAdd(\n                    qualifying_rewards,\n                    stykRewards[_customerAddress]\n                );\n            }\n        }\n\n        if (totalMonthRewards[_customerAddress] != 0) {\n            qualifying_rewards = safeAdd(\n                qualifying_rewards,\n                totalMonthRewards[_customerAddress]\n            );\n        }\n\n        return (\n            safeAdd(\n                safeAdd(_dividends, qualifying_rewards),\n                referralBalance_[_customerAddress]\n            )\n        );\n    }\n\n    //To Claim Monthly Rewards\n    function claimMonthlyRewards() external {\n        address _customerAddress = msg.sender;\n        \n        require(_calculateMonthlyRewards(_customerAddress) > 0 ,\"ERR_YOU_DONT_QUALIFY\");\n        \n        uint256 daysPayout = safeSub(getDaysInMonth(getMonth(now), getYear(now)),1);\n\n        require(\n            (getDay(now) == daysPayout || getDay(now) == getDaysInMonth(getMonth(now), getYear(now))),\n            \"ERR_CANNOT_CLAIM_BEFORE_PAYOUT\"\n        );\n        \n        require(!monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)],\"ERR_REWARD_ALREADY_CLAIMED\");\n        \n        if (_calculateTokenPercentage(_customerAddress) != 0) {\n            totalMonthRewards[_customerAddress] = safeAdd(\n                totalMonthRewards[_customerAddress],\n                _calculateMonthlyRewards(_customerAddress)\n            );\n            monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)] = true;\n        \n        }\n    }\n\n    //To release the pre-minted tokens after the lock time\n    function release() external {\n        require(now > lockTime, \"ERR_CANNOT_RELEASE_TOKENS_BEFORE_LOCK_TIME\");\n\n        uint256 amount = tokenBalanceLedger_[address(this)];\n        tokenSupply_ = safeAdd(tokenSupply_, amount);\n    }\n\n    /*==========================================\n    =            INTERNAL FUNCTIONS            =\n    ==========================================*/\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy)\n        internal\n        returns (uint256)\n    {\n        // data setup\n        address _customerAddress = msg.sender;\n        uint256 _undividedDividends = safeDiv(_incomingEthereum, dividendFee_);\n        uint256 _referralBonus = safeDiv(_undividedDividends, 2);\n        uint256 _dividends = safeSub(_undividedDividends, _referralBonus);\n        uint256 _taxedEthereum =\n            safeSub(_incomingEthereum, _undividedDividends);\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n        uint256 _fee = _dividends * magnitude;\n\n        require(\n            _amountOfTokens > 0 &&\n                (safeAdd(_amountOfTokens, tokenSupply_) > tokenSupply_)\n        );\n\n        // is the user referred by a karmalink?\n        if (\n            _referredBy != address(0) &&\n            // no cheating!\n            _referredBy != _customerAddress &&\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n        ) {\n            // wealth redistribution\n            referralBalance_[_referredBy] = safeAdd(\n                referralBalance_[_referredBy],\n                _referralBonus\n            );\n        } else {\n            // no ref purchase\n            // add the referral bonus back to the global dividends cake\n            _dividends = safeAdd(_dividends, _referralBonus);\n            _fee = _dividends * magnitude;\n        }\n\n        // add tokens to the pool\n        tokenSupply_ = safeAdd(tokenSupply_, _amountOfTokens);\n\n        // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n        if (now > auctionExpiryTime) {\n            profitPerShare_ += ((_dividends * magnitude) /\n                safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)]));\n        }\n        auctionProfitPerShare_ += ((_dividends * magnitude) /\n            safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)]));\n\n        // calculate the amount of tokens the customer receives over his purchase\n        _fee =\n            _fee -\n            (_fee -\n                (_amountOfTokens *\n                    ((_dividends * magnitude) /\n                        safeAdd(\n                            tokenSupply_,\n                            tokenBalanceLedger_[address(this)]\n                        ))));\n\n        // update circulating supply & the ledger address for the customer\n        tokenBalanceLedger_[_customerAddress] = safeAdd(\n            tokenBalanceLedger_[_customerAddress],\n            _amountOfTokens\n        );\n\n        if (\n            !userExists[_referredBy][_customerAddress] &&\n            _referredBy != address(0) &&\n            _referredBy != _customerAddress\n        ) {\n            userExists[_referredBy][_customerAddress] = true;\n            referralUsers[_referredBy].push(_customerAddress);\n        }\n\n        if (now <= auctionExpiryTime) {\n            if (\n                totalEthereumBalance() <= auctionEthLimit &&\n                safeAdd(totalEthereumBalance(), _incomingEthereum) <=\n                auctionEthLimit\n            ) {\n                if (!earlyadopters[_customerAddress]) {\n                    earlyadopters[_customerAddress] = true;\n                }\n                if (!auctionAddressTracker[_customerAddress]) {\n                    auctionAddressTracker[_customerAddress] = true;\n                }\n            }\n        }\n\n        if (auctionAddressTracker[_customerAddress]) {\n            int256 _updatedPayouts =\n                (int256)((auctionProfitPerShare_ * _amountOfTokens) - _fee);\n            payoutsTo_[_customerAddress] += _updatedPayouts;\n        } else {\n            int256 _updatedPayouts =\n                (int256)((profitPerShare_ * _amountOfTokens) - _fee);\n            payoutsTo_[_customerAddress] += _updatedPayouts;\n        }\n\n        if (!userAdded[_customerAddress]) {\n            userAddress.push(_customerAddress);\n            userAdded[_customerAddress] = true;\n            userIndex[_customerAddress] = userCount;\n            userCount++;\n        }\n\n        // fire event\n        emit onTokenPurchase(\n            _customerAddress,\n            _incomingEthereum,\n            _amountOfTokens,\n            _referredBy\n        );\n        if (now > auctionExpiryTime) {\n            if (inflationTime == 0 || _calculateInflationMinutes() > 4320)\n                setInflationTime();\n        }\n        emit Transfer(address(this), _customerAddress, _amountOfTokens);\n\n        return _amountOfTokens;\n    }\n\n    /**\n     * Calculate Token price based on an amount of incoming ethereum\n     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n     */\n    function ethereumToTokens_(uint256 _ethereum)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n        uint256 _tokensReceived =\n            ((\n                // underflow attempts BTFO\n                safeSub(\n                    (\n                        sqrt(\n                            (_tokenPriceInitial**2) +\n                                (2 *\n                                    (tokenPriceIncremental_ * 1e18) *\n                                    (_ethereum * 1e18)) +\n                                (((tokenPriceIncremental_)**2) *\n                                    (tokenSupply_**2)) +\n                                (2 *\n                                    (tokenPriceIncremental_) *\n                                    _tokenPriceInitial *\n                                    tokenSupply_)\n                        )\n                    ),\n                    _tokenPriceInitial\n                )\n            ) / (tokenPriceIncremental_)) - (tokenSupply_);\n\n        return _tokensReceived;\n    }\n\n    /**\n     * Calculate token sell value.\n     */\n    function tokensToEthereum_(uint256 _tokens)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 tokens_ = (_tokens + 1e18);\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\n        uint256 _etherReceived =\n            (// underflow attempts BTFO\n            safeSub(\n                (((tokenPriceInitial_ +\n                    (tokenPriceIncremental_ * (_tokenSupply / 1e18))) -\n                    tokenPriceIncremental_) * (tokens_ - 1e18)),\n                (tokenPriceIncremental_ * ((tokens_**2 - tokens_) / 1e18)) / 2\n            ) / 1e18);\n        return _etherReceived;\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n}\n\n/*================================================================================================================================\n                                      \n                                       CREDITS        \n    \n   credit goes to POWH, GANDHIJI, HEX, WISE & ECLIPSE CITY smart contracts\" All charity work is inspired by BI Phakathi (Youtuber)\n  \n     \n================================================================================================================================*/\n"
    }
  }
}