{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "bozy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\n// ----------------------------------------------------------------------------\r\n/// @author Gradi Kayamba\r\n/// @title Bozindo Currency - BOZY\r\n// ----------------------------------------------------------------------------\r\n\r\n// ----------------------------------------------------------------------------\r\n/// @title Interface : Token Standard #20. https://github.com/ethereum/EIPs/issues/20\r\n// ----------------------------------------------------------------------------\r\ninterface ERC20Interface {\r\n    \r\n    /// @dev Triggers on any successful call to transfer() and transferFrom().\r\n    /// @param _from : The address sending the tokens.\r\n    /// @param _to : The address receiving the tokens.\r\n    /// @param _amount : The quantity of tokens to be sent.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    \r\n    /// @dev Triggers on any successful call to approve() and allowance().\r\n    /// @param _owner : The address allowing token to be spent.\r\n    /// @param _spender : The address allowed to spend tokens.\r\n    /// @param _amount : The quantity allowed to be spent.\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\r\n    \r\n    /// @notice Transfers `_amount` tokens to `_to`.\r\n    /// @param _to : The address receiving tokens.\r\n    /// @param _amount : The quantity of tokens to send.\r\n    function transfer(address _to, uint256 _amount) external returns (bool success);\r\n    \r\n    /// @notice Transfers `_amount` tokens from `_from` to `_to`.\r\n    /// @param _from : The address sending tokens.\r\n    /// @param _to : The address receiving tokens.\r\n    /// @param _amount : The quantity of tokens to be sent.\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);\r\n    \r\n    /// @notice Sets `_amount` to be spent by `_spender` on your behalf.\r\n    /// @param _spender : The address allowed to spend tokens.\r\n    /// @param _amount : The quantity allowed to be spent.\r\n    function approve(address _spender, uint256 _amount) external returns (bool success);\r\n    \r\n    /// @notice Returns the amount which `_spender` is still allowed to withdraw from `_owner`.\r\n    /// @param _owner : The address allowing token to be spent.\r\n    /// @param _spender : The address allowed to spend tokens.\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    \r\n    /// @notice Returns the amount of tokens owned by account `_owner`.\r\n    /// @param _owner : The address from which the balance will be retrieved.\r\n    /// @return holdings 000\r\n    function balanceOf(address _owner) external view returns (uint256 holdings);\r\n    \r\n    /// @notice Returns the amount of tokens in existence.\r\n    /// @return remaining 000\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n/// @title Context : Information about sender, value, and data of the transaction.\r\n// ----------------------------------------------------------------------------\r\nabstract contract Context {\r\n    /// @dev Returns information about the sender of the transaction.\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    /// @dev Returns information about the value of the transaction.\r\n    function _msgValue() internal view virtual returns (uint256) {\r\n        return msg.value;\r\n    }\r\n    \r\n    /// @dev Returns information about the data of the transaction.\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n/// @title Ownable : Information about the founder of the contract and none-zero address modifier.\r\n// ----------------------------------------------------------------------------\r\nabstract contract Ownable is Context {\r\n    // Define public constant variables.\r\n    address payable public founder;\r\n    mapping(address => uint256) balances;\r\n\r\n    // Set values on construction.\r\n    constructor() {\r\n        founder = payable(_msgSender());\r\n    }\r\n    \r\n    /// @dev Triggers on any successful call to transferOwnership().\r\n    /// @param _oldOwner : The address tranfering the ownership.\r\n    /// @param _newOwner : The address gaining ownership.\r\n    event TransferOwnership(address _oldOwner, address _newOwner);\r\n    \r\n    /// @dev Makes a function callable only by the founder.\r\n    modifier onlyFounder() {\r\n        require(_msgSender() == founder, \"Your are not the Founder.\");\r\n        _;\r\n    }\r\n    \r\n    /// @dev Makes a function callable only when the _owner is not a zero-address.\r\n    modifier noneZero(address _owner){\r\n        require(_owner != address(0), \"Zero address not allowed.\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Transfers ownership of the contract to `_newOwner`.\r\n    /// @notice Callable by the founder only.\r\n    /// @notice Callable only by a none-zero address.\r\n    function transferOwnership(address payable _newOwner) \r\n    onlyFounder \r\n    noneZero(_newOwner) \r\n    public \r\n    returns (bool success) \r\n    {\r\n        // Check founder's balance.\r\n        uint256 founderBalance = balances[founder];\r\n        // Check new owner's balance.\r\n        uint256 newOwnerBalance = balances[_newOwner];\r\n        \r\n        // Set founder balance to 0.\r\n        balances[founder] = 0;\r\n        \r\n        // Add founder's old balance to the new owner's balance.\r\n        balances[_newOwner] = newOwnerBalance + founderBalance;\r\n        \r\n        // Transfer ownership from `founder` to the `_newOwner`.\r\n        founder = _newOwner;\r\n        \r\n        // Emit event\r\n        emit TransferOwnership(founder, _newOwner);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n/// @title Whitelisted : The ability to block evil users' transactions and to burn their tokens.\r\n// ----------------------------------------------------------------------------\r\nabstract contract Whitelisted is Ownable {\r\n    // Define public constant variables.\r\n    mapping (address => bool) public isWhitelisted;\r\n    \r\n    /// @dev Triggers on any successful call to burnWhiteTokens().\r\n    /// @param _evilOwner : The address to burn tokens from.\r\n    /// @param _dirtyTokens : The quantity of tokens burned.\r\n    event BurnWhiteTokens(address _evilOwner, uint256 _dirtyTokens);\r\n    \r\n    /// @dev Triggers on any successful call to addToWhitelist().\r\n    /// @param _evilOwner : The address to add to whitelist.\r\n    event AddToWhitelist(address _evilOwner);\r\n    \r\n    /// @dev Triggers on any successful call to removedFromWhitelist().\r\n    /// @param _owner : The address to remove from whitelist.\r\n    event RemovedFromWhitelist(address _owner);\r\n    \r\n    /// @dev Makes a function callable only when `_owner` is not whitelisted.\r\n    modifier whenNotWhitelisted(address _owner) {\r\n        require(isWhitelisted[_owner] == false, \"Whitelisted status detected; please check whitelisted status.\");\r\n        _;\r\n    }\r\n    \r\n    /// @dev Makes a function callable only when `_owner` is whitelisted.\r\n    modifier whenWhitelisted(address _owner) {\r\n        require(isWhitelisted[_owner] == true, \"Whitelisted status not detected; please check whitelisted status.\");\r\n        _;\r\n    }\r\n    \r\n    /// @notice Adds `_evilOwner` to whitelist.\r\n    /// @notice Callable only by the founder.\r\n    /// @notice Callable only when `_evilOwner` is not whitelisted.\r\n    /// @param _evilOwner : The address to whitelist.\r\n    /// @return success\r\n    function addToWhitelist(address _evilOwner) \r\n    onlyFounder \r\n    whenNotWhitelisted(_evilOwner)\r\n    public \r\n    returns (bool success) \r\n    {\r\n        // Set whitelisted status\r\n        isWhitelisted[_evilOwner] = true;\r\n        \r\n        // Emit event\r\n        emit AddToWhitelist(_evilOwner);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n\r\n    /// @notice Removes `_owner` from whitelist.\r\n    /// @notice Callable only by the founder.\r\n    /// @notice Callable only when `_owner` is whitelisted.\r\n    /// @param _owner : The address to remove from whitelist.\r\n    /// @return success\r\n    function removedFromWhitelist(address _owner) \r\n    onlyFounder \r\n    whenWhitelisted(_owner) \r\n    public \r\n    returns (bool success) \r\n    {\r\n        // Unset whitelisted status\r\n        isWhitelisted[_owner] = false;\r\n        \r\n        // Emit event\r\n        emit RemovedFromWhitelist(_owner);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n\r\n    /// @notice Burns tokens of `_evilOwner`. \r\n    /// @notice Callable only by the founder.\r\n    /// @notice Callable only when `_evilOwner` is whitelisted.\r\n    /// @param _evilOwner : The address to burn funds from.\r\n    /// @return success\r\n    function burnWhiteTokens(address _evilOwner) \r\n    onlyFounder\r\n    whenWhitelisted(_evilOwner)\r\n    public\r\n    returns (bool success) {\r\n        // Check evil owner's balance - NOTE - Always check the balance first.\r\n        uint256 _dirtyTokens = balances[_evilOwner];\r\n        \r\n        // Set the evil owner balance to 0.\r\n        balances[_evilOwner] = 0;\r\n        // Send the dirty tokens to the founder for purification!\r\n        balances[founder] += _dirtyTokens;\r\n        \r\n        // Emit event\r\n        emit BurnWhiteTokens(_evilOwner, _dirtyTokens);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n/// @title Freezable : The ability to freeze or unfreeze addresses' tokens.\r\n// ----------------------------------------------------------------------------\r\nabstract contract Freezable is Ownable {\r\n    // Define public constant variables.\r\n    mapping(address => mapping(address => uint256)) freezed;\r\n        \r\n    /// @dev Triggers on any successful call to freeze().\r\n    /// @param _spender : The address freezed.\r\n    /// @param _amount : The quantity freezed.\r\n    event Freeze(address indexed _spender, uint256 _amount);\r\n    \r\n    /// @dev Triggers on any successful call to unfreeze().\r\n    /// @param _spender : The address unfreezed.\r\n    /// @param _amount : The quantity unfreezed.\r\n    event Unfreeze(address indexed _spender, uint256 _amount);\r\n    \r\n    /// @notice Freeses `_amount` tokens from `_spender`.\r\n    /// @dev MUST trigger a Freeze event.\r\n    /// @param _spender : The address to freeze.\r\n    /// @param _amount : The quantity to freeze.\r\n    /// @return success\r\n    function freeze(address _spender, uint256 _amount) public virtual returns (bool success) {\r\n        // NOTE - Always check balances before transaction.\r\n        // Check spender freezed balance.\r\n        uint256 _freezedBalance = freezed[_msgSender()][_spender]; \r\n        // Check spender balance.\r\n        uint256 _spenderBalance = balances[_spender]; \r\n        \r\n        // Inherit from {_freeze}\r\n        _freeze(_spender, _amount, _spenderBalance - _amount, _freezedBalance + _amount, _spenderBalance);\r\n        \r\n        // See {event Freeze}\r\n        emit Freeze(_spender, _amount);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    /// @notice Unfreeses `_amount` tokens of `_spender`.\r\n    /// @dev MUST trigger an Unfreeze event.\r\n    /// @param _spender : The address to unfreeze. \r\n    /// @param _amount : The quantity to unfreeze. \r\n    /// @return success\r\n    function unfreeze(address _spender, uint256 _amount) public virtual returns (bool success) {\r\n        // NOTE - Always check balances before transaction.\r\n        // Check spender freezed balance.\r\n        uint256 _freezedBalance = freezed[_msgSender()][_spender]; \r\n        // Check spender balance.\r\n        uint256 _spenderBalance = balances[_spender]; \r\n        \r\n        // Inherit from {_freeze}\r\n        _freeze(_spender, _amount, _spenderBalance  + _amount, _freezedBalance - _amount, _freezedBalance);\r\n        \r\n        // See {event Unfreeze}\r\n        emit Unfreeze(_spender, _amount);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    /// @notice Callable only by the founder.\r\n    /// @notice Callable only by a none-zero address.\r\n    /// @param _spender : The address freezable.\r\n    /// @param _amount : The quantity freezable.\r\n    /// @param _newBalance : The new spender's balance.\r\n    /// @param _newFreezedBalance : The new spender's freezed balance. \r\n    /// @param _initialBalance : The initial balance before freezing or unfreezing. \r\n    function _freeze(\r\n        address _spender, \r\n        uint256 _amount, \r\n        uint256 _newBalance, \r\n        uint256 _newFreezedBalance, \r\n        uint256 _initialBalance\r\n    ) \r\n    onlyFounder\r\n    noneZero(_spender)\r\n    internal \r\n    virtual \r\n    {\r\n        /// @dev Requires the spender initial balance `_initialBalance` be at least `_amount`.\r\n        require(_initialBalance >= _amount, \"Balance too low!\");\r\n        \r\n        /// @dev Requires `_amount` be greater than 0 (zero).\r\n        require(_amount > 0, \"The value is less than zero!\");\r\n        \r\n        // Decrease spender balance by the freezed amount.\r\n        balances[_spender] = _newBalance;\r\n        \r\n        // Increase spender freezed balance.\r\n        freezed[_msgSender()][_spender] = _newFreezedBalance;\r\n    }\r\n    \r\n    /// @dev Returns the `_spender` amount freezed / locked.\r\n    /// @param _spender : The address from which the balance has been freezed.\r\n    /// @return locked 000\r\n    function freezedBalanceOf(address _spender) public view returns (uint256 locked) {\r\n        // Returns spender's amount of tokens freezed.\r\n        return freezed[_msgSender()][_spender];\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n/// @title Pausable: The ability to pause or unpause trasactions of all tokens.\r\n// ----------------------------------------------------------------------------\r\nabstract contract Pausable is Ownable {\r\n    // Define public constant variables.\r\n    bool public paused = false;\r\n    \r\n    /// @dev Triggers on any successful call to pause().    \r\n    event Pause();\r\n    \r\n    /// @dev Triggers on any successful call to unpause(). \r\n    event Unpause();\r\n\r\n    /// @dev Makes a function callable only when the contract is not paused.\r\n    modifier whenNotPaused() {\r\n        require(paused == false, \"All transactions have been paused.\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Makes a function callable only when the contract is paused.\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n    \r\n    /// @notice Pauses transactions.\r\n    /// @notice Callable only by the founder.\r\n    /// @notice Callable only when the contract is not paused.\r\n    /// @return success\r\n    function pause() public onlyFounder whenNotPaused returns (bool success) {\r\n        // Set pause\r\n        paused = true;\r\n        \r\n        // See {event Pause}\r\n        emit Pause();\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    /// @dev Unpauses transactions.\r\n    /// @notice Callable only by the founder.\r\n    /// @notice Callable only when the contract is paused.\r\n    /// @return success\r\n    function unpause() public  onlyFounder whenPaused returns (bool success) {\r\n        // Unset pause\r\n        paused = false;\r\n        \r\n        // See {event Unpause}\r\n        emit Unpause();\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n/// @title Bozy : ERC Token.\r\n// ----------------------------------------------------------------------------\r\ncontract Bozy is  ERC20Interface, Context, Ownable, Whitelisted, Freezable, Pausable {\r\n    // Define public constant variables.\r\n    uint8 public decimals; // Number of decimals\r\n    string public name;    // Token name\r\n    string public symbol;  // Token symbol\r\n    uint256 public tokenPrice;\r\n    uint256 public override totalSupply;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    \r\n    // Set immutable values.\r\n    constructor() {\r\n        name              = \"Bozindo.com Currency\";\r\n        decimals          = 18;\r\n        symbol            = \"BOZY\";\r\n        totalSupply       = 30000000000; // 30 Billion\r\n        balances[founder] = totalSupply * (10 ** decimals); // 30000000000E18\r\n        tokenPrice        = 0.00001 ether; \r\n    }\r\n    \r\n    /// @dev Triggers on any successful call to mint().\r\n    /// @param _from : The address minting tokens.\r\n    /// @param _to : The address tokens will be minted to.\r\n    /// @param _amount : The quantity of tokes to be minted.\r\n    event Mint(address indexed _from, address indexed _to, uint256 _amount);\r\n    \r\n    /// @dev Triggers on any successful call to burn().\r\n    /// @param _from : The address burning tokens.\r\n    /// @param _to : The address tokens will be burned from.\r\n    /// @param _amount : The quantity of tokes to be burned.\r\n    event Burn(address indexed _from, address indexed _to, uint256 _amount);\r\n    \r\n    /// @notice Changes token name to `_newName`.\r\n    /// @notice Callable by the founder only.\r\n    /// @notice Callable only by a none-zero address.\r\n    function changeTokenName(string memory _newName) \r\n    onlyFounder \r\n    noneZero(_msgSender()) \r\n    public \r\n    returns (bool success) \r\n    {\r\n        \r\n        // Change token name from `name` to the `_newName`.\r\n        name = _newName;\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    /// @notice Changes token symbol to `_newSymbol`.\r\n    /// @notice Callable by the founder only.\r\n    /// @notice Callable only by a none-zero address.\r\n    function changeTokenSymbol(string memory _newSymbol) \r\n    onlyFounder \r\n    noneZero(_msgSender()) \r\n    public \r\n    returns (bool success) \r\n    {\r\n        \r\n        // Change token symbol from `symbol` to the `_newSymbol`.\r\n        symbol = _newSymbol;\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    /// @notice Changes token price to `_newPrice` in wei.\r\n    /// @notice Callable by the founder only.\r\n    /// @notice Callable only by a none-zero address.\r\n    function changeTokenPrice(uint256 _newPrice) \r\n    onlyFounder \r\n    noneZero(_msgSender()) \r\n    public \r\n    returns (bool success) \r\n    {\r\n        \r\n        // Change token price from `tokenPrice` to the `_newPrice` in wei.\r\n        tokenPrice = _newPrice;\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    // See {_transfer} and {ERC20Interface - transfer}\r\n    function transfer(address _to, uint256 _amount) public virtual override returns (bool success) {\r\n        // Inherit from {_transfer}.\r\n        _transfer(_msgSender(), _to, _amount);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    // See {_transfer}, {_approve} and {ERC20Interface - transferFrom}\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _amount\r\n    ) public virtual override returns (bool success) {\r\n        // Inherits from _transfer.\r\n        _transfer(_from, _to, _amount);\r\n        \r\n        // Check sender's allowance.\r\n        // NOTE - Always check balances before transaction.\r\n        uint256 currentAllowance = allowed[_from][_msgSender()];\r\n        \r\n        // Inherits from _approve.\r\n        _approve(_from, _msgSender(), currentAllowance - _amount, currentAllowance); \r\n\r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n\r\n    // See also {_approve} and {ERC20Interface - approve}\r\n    function approve(address _spender, uint256 _amount) public virtual override returns (bool success) {\r\n        // Inherits from _approve.\r\n        _approve(_msgSender(), _spender, _amount, balances[_msgSender()]);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    // Sets total allowance to 0. \r\n    // See also {_approve} and {ERC20Interface - approve}\r\n    function disapprove(address _spender) public virtual returns (bool success) {\r\n        // Inherits from _approve.\r\n        _approve(_msgSender(), _spender, 0, 0);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    // Increases total allowance to `_amount`.\r\n    // See also {_approve} and {ERC20Interface - approve}\r\n    function increaseAllowance(address _spender, uint256 _amount) public virtual returns (bool success) {\r\n        // Check spender's allowance.\r\n        // NOTE - Always check balances before transaction.\r\n        uint256 currentAllowance = allowed[_msgSender()][_spender];\r\n        \r\n        // Inherits from _approve.\r\n        _approve(_msgSender(), _spender, currentAllowance + _amount, balances[_msgSender()]);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    // Decreases total allowance by `_amount`.\r\n    // See also {_approve} and {ERC20Interface - approve}\r\n    function decreaseAllowance(address _spender, uint256 _amount) public virtual returns (bool success) {\r\n        // Check sender's allowance balance.\r\n        // NOTE - Always check balances before transaction.\r\n        uint256 currentAllowance = allowed[_msgSender()][_spender];\r\n        \r\n        // Inherits from _approve.\r\n        _approve(_msgSender(), _spender, currentAllowance - _amount, currentAllowance);\r\n\r\n        // Returns true on success.\r\n        return true;\r\n    }  \r\n    \r\n    /// @notice See {ERC20Interface - transfer}. \r\n    /// @notice MUST trigger Transfer event.\r\n    function _transfer( address _from, address _to, uint256 _amount)\r\n    noneZero(_from)\r\n    noneZero(_to)\r\n    whenNotWhitelisted(_from)\r\n    whenNotWhitelisted(_to)\r\n    whenNotPaused\r\n    internal \r\n    virtual \r\n    {\r\n        // Check sender's balance.\r\n        // NOTE - Always check balances before transaction.\r\n        uint256 senderBalance = balances[_from];\r\n        \r\n        /// @dev Requires the sender `senderBalance` balance be at least the `_amount`.\r\n        require(senderBalance >= _amount, \"The transfer amount exceeds balance.\");\r\n        \r\n        // Increase recipient balance.\r\n        balances[_to] += _amount;\r\n        // Decrease sender balance.\r\n        balances[_from] -= _amount;\r\n        \r\n        // See {event ERC20Interface-Transfer}\r\n        emit Transfer(_from, _to, _amount);\r\n    }\r\n    \r\n    /// @notice See {ERC20Interface - approve}\r\n    /// @notice MUST trigger a Approval event.\r\n    function _approve( address _owner, address _spender, uint256 _amount, uint256 _initialBalance)\r\n    noneZero(_spender)\r\n    noneZero(_owner)\r\n    internal \r\n    virtual \r\n    {\r\n        /// @dev Requires the owner `_initialBalance` balance be at least the `_amount`.\r\n        require(_initialBalance >= _amount, \"Not enough balance.\");\r\n        \r\n        /// @dev Requires the `_amount` be at least 0 (zero).\r\n        require(_amount >= 0, \"The value is less than or zero!\");\r\n        \r\n        // Set spender allowance to the `_amount`.\r\n        allowed[_owner][_spender] = _amount;\r\n        \r\n        // See {event ERC20Interface-Approval}\r\n        emit Approval(_owner, _spender, _amount);\r\n    }\r\n    /// @notice Increases an address balance and add to the total supply.\r\n    /// @notice Callable only by the founder.\r\n    /// @notice Callable only by a none-zero address.\r\n    /// @param _owner : The address to mint or add tokens to.\r\n    /// @param _amount : The quantity of tokens to mint or create.\r\n    /// @notice MUST trigger Mint event.\r\n    /// @return success\r\n    function mint(address _owner, uint256 _amount) \r\n    onlyFounder\r\n    noneZero(_owner)\r\n    public \r\n    virtual \r\n    returns (bool success) \r\n    {\r\n        // Increase total supply.\r\n        totalSupply += _amount;\r\n        // Increase owner's balance.\r\n        balances[_owner] += ( _amount * (10 ** decimals) );\r\n        \r\n        // See {event Mint}\r\n        emit Mint(address(0), _owner, _amount);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    /// @notice Decreases an address balance, and add to the total supply.\r\n    /// @notice Callable only by the founder.\r\n    /// @notice Callable only by a none-zero address.\r\n    /// @param _owner : The address to burn or substract tokens from.\r\n    /// @param _amount : The quantity of tokens to burn or destroy.\r\n    /// @notice MUST trigger Burn event.\r\n    function burn(address _owner, uint256 _amount) \r\n    onlyFounder\r\n    noneZero(_owner)\r\n    public\r\n    virtual\r\n    returns (bool success)\r\n    {\r\n        // Check owner's balance.\r\n        // NOTE - Always check balance first before transaction.\r\n        uint256 accountBalance = balances[_owner];\r\n        \r\n        /// @dev Requires the owner's balance `accountBalance` be at least `_amount`.\r\n        require(accountBalance >= _amount, \"Burn amount exceeds balance\");\r\n        \r\n        // Decrease owner total supply.\r\n        balances[_owner] -= ( _amount * (10 ** decimals) );\r\n        // Decrease `totalSupply` by `_amount`.\r\n        totalSupply -= _amount;\r\n\r\n        // See {event Burn}\r\n        emit Burn(address(0), _owner, _amount);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n        \r\n    // See {ERC20Interface - balanceOf}\r\n    function balanceOf(address _owner) public view override returns (uint256 holdings) {\r\n        // Returns owner's token balance.\r\n        return balances[_owner];\r\n    }\r\n\r\n    // See {ERC20Interface - allowance}\r\n    function allowance(address _owner, address _spender) public view virtual override returns (uint256 remaining) {\r\n        // Returns spender's allowance balance.\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n/// @title BozyICO : ERC Token ICO - 0.00001 ETH/BOZY with max-cap of 60,000 ETH\r\n// ----------------------------------------------------------------------------\r\ncontract BozyICO is Bozy {\r\n    // Define public constant variables\r\n    mapping(address => uint256) public contributions;\r\n    address payable public deposit;\r\n    address public admin;\r\n    uint256 public raisedAmount;\r\n    uint256 public icoTokenSold;\r\n    uint256 public hardCap         = 6000 ether;\r\n    uint256 public goal            = 2000 ether;\r\n    uint256 public saleStart       = block.timestamp + 30 days;\r\n    uint256 public saleEnd         = saleStart + 100 days;\r\n    uint256 public TokenTransferStart = saleEnd + 10 days;\r\n    uint256 public maxContribution = 10 ether;\r\n    uint256 public minContribution = 0.001 ether;\r\n    bool public emergencyMode      = false;\r\n    //uint256 public goal            = 300 ether; // test\r\n    //uint256 public saleStart       = block.timestamp + 30 seconds; // test\r\n    //uint256 public saleEnd         = saleStart + 3 minutes; // test\r\n    //uint256 public TokenTransferStart   = saleEnd + 1 minutes; // test\r\n\r\n    /// @param beforeStart : Returns 0 before ICO starts.\r\n    /// @param running     : Returns 1 when ICO is running.\r\n    /// @param afterEnd    : Returns 2 when ICO has ended.\r\n    /// @param halted      : Returns 3 when ICO is paused.\r\n    enum State {beforeStart, running, afterEnd, halted}\r\n    State icoState;\r\n    \r\n    /// @dev Triggers on any successful call to contribute().\r\n    /// @param _contributor : The address donating to the ICO.\r\n    /// @param _amount: The quantity in ETH of the contribution.\r\n    /// @param _tokens : The quantity of tokens sent to the contributor.\r\n    event Contribute(address _contributor, uint256 _amount, uint256 _tokens);\r\n    \r\n    /// @dev All three of these values are immutable: set on construction.\r\n    constructor(address payable _deposit) {\r\n        deposit  = _deposit;\r\n        admin    = _msgSender();\r\n        icoState = State.beforeStart;\r\n    }\r\n    \r\n    /// @dev Sends ETH. \r\n    receive() payable external {\r\n        contribute();\r\n    }\r\n    \r\n    /// @notice Pauses ICO contribution.\r\n    function haltICO() public onlyFounder {\r\n        // Set the state to halt.\r\n        icoState = State.halted;\r\n    }\r\n    \r\n    /// @notice Resumes ICO contribution.\r\n    function resumeICO() public onlyFounder {\r\n        // Set the state to running.\r\n        icoState = State.running;\r\n    }\r\n    \r\n    /// @notice Changes the deposit address.\r\n    function changeDepositAddress(address payable _newDeposit) public onlyFounder {\r\n        // Change deposit address to a new one.\r\n        deposit = _newDeposit;\r\n    }\r\n    \r\n    /// @notice Contributes to the ICO.  \r\n    /// @notice MUST trigger Contribute event.\r\n    function contribute() payable public noneZero(_msgSender()) returns (bool success) {\r\n        // Set ICO state to the current state.\r\n        icoState = getICOState();   \r\n         \r\n        /// @dev Requires the ICO to be running.\r\n        require(icoState == State.running, \"ICO is not running. Check ICO state.\");\r\n        /// @dev Requires the value be greater than min. contribution and less than max. contribution.\r\n        require(_msgValue() >= minContribution && _msgValue() <= maxContribution, \"Contribution out of range.\");\r\n        /// @dev Requires the raised amount `raisedAmount` is at least less than the `hardCap`.\r\n        require(raisedAmount <= hardCap, \"HardCap has been reached.\");\r\n        \r\n        // Increase raised amount of ETH. 0000.0009 - 90000\r\n        raisedAmount += _msgValue();\r\n        \r\n        // Set token amount.\r\n        uint256 _tokens = (_msgValue() / tokenPrice) * (10 ** decimals);\r\n        // Check deposit balance.\r\n        uint256 _depositBalance = contributions[deposit];\r\n        \r\n        // Increase ICO token sold amount.\r\n        icoTokenSold += _tokens;\r\n        \r\n        // Increase Contributor ETH contribution.\r\n        contributions[_msgSender()] += _msgValue();\r\n        // Increase Deposit ETH balances.\r\n        contributions[deposit] = _depositBalance + _msgValue();\r\n        // Increase Contributor token holdings. \r\n        balances[_msgSender()] += _tokens;\r\n        // Decrease founder token holdings.\r\n        balances[founder] -= _tokens;\r\n        \r\n        // Transfer ETH to deposit account.\r\n        payable(deposit).transfer(_msgValue());\r\n        \r\n        // See {event Contribute}\r\n        emit Contribute(_msgSender(), _msgValue(), _tokens);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    /// @dev See {Bozy - transfer}\r\n    function transfer(address _to, uint256 _tokens) public override returns (bool success) {\r\n        /// @dev Requires the ICO has started.\r\n        require(block.timestamp > saleStart, \"ICO is not running.\");\r\n        /// @dev Requires the raisedAmount amount is greater than the goal.\r\n        require(block.timestamp > TokenTransferStart, \"Transfer starts after ICO has ended.\");\r\n        \r\n        // Get the contract from ERC20.\r\n        Bozy.transfer(_to, _tokens);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    /// @dev See {Bozy - transferFrom}\r\n    function transferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _tokens\r\n    ) public override returns (bool success) {\r\n        /// @dev Requires the ICO has started.\r\n        require(block.timestamp > saleStart, \"ICO is not running.\");\r\n        /// @dev Requires the raisedAmount amount is greater than the goal.\r\n        require(block.timestamp > TokenTransferStart, \"Transfer starts after ICO has ended.\");\r\n        \r\n        // Get the contract one level higher in the inheritance hierarchy.\r\n        Bozy.transferFrom(_from, _to, _tokens);\r\n        \r\n        // Returns true on success.\r\n        return true;\r\n    }\r\n    \r\n    /// @notice Returns current ico states. Check {enum State}\r\n    function getICOState() public view returns(State) {\r\n        if(icoState == State.halted) {\r\n            return State.halted;      // returns 3\r\n        } else \r\n        if(block.timestamp < saleStart) {\r\n            return State.beforeStart; // returns 0\r\n        } else if(block.timestamp >= saleStart && block.timestamp <= saleEnd) {\r\n            return State.running;     // returns 1\r\n        } else {\r\n            return State.afterEnd;    // returns 2\r\n        }\r\n    }\r\n}\r\n\r\n\r\n"
    }
  }
}