{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/StakingPoolNew.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\n\npragma solidity ^0.6.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IERC1155 {\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) external;\n}\n\ncontract StakingPool is ReentrancyGuard, Pausable, Ownable {\n    using SafeMath for uint256;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC1155 public apeToken;\n    address private apeOwner;\n    mapping(address => uint256[]) public staked;\n    mapping(address => uint256) public stakedFemales;\n    mapping(address => uint256) public stakedMales;\n    mapping(address => uint256) public stakedBabies;\n    mapping(uint256 => bool) private femaleId;\n    mapping(uint256 => bool) private maleId;\n    mapping(uint256 => bool) private babyId;\n    mapping(uint256 => uint256[]) private babyOf;\n    mapping(uint256 => uint256) private birth;\n    mapping(address => uint256) public breedingEnd;\n    mapping(uint256 => uint256) private maxBabies;\n    mapping(uint256 => uint256) private multiplier;\n    mapping(address => uint256) public userMultiplier;\n    uint256[] private certificates;\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 30 days;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _apeToken, address _apeOwner) public {\n        apeToken = IERC1155(_apeToken);\n        apeOwner = _apeOwner;\n    }\n\n    /* ========== STAKING FUNCTIONS ========== */\n\n    function deposit() external payable {\n        // todo remove this function before deployment\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .div(_totalSupply)\n                    .mul(userMultiplier[msg.sender]) // multipliers = 2, 3, 4\n                    .mul(2)\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            msg.sender.transfer(reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward) external onlyOwner updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = address(this).balance;\n        require(\n            rewardRate <= balance.div(rewardsDuration),\n            \"Provided reward too high\"\n        );\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(rewardsDuration);\n        emit RewardAdded(reward);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    /* ========== INITIATE FUNCTIONS ========== */\n\n    function initiateBaby(uint256[] memory id) external onlyOwner {\n        uint256 i;\n        for (i=0; i < id.length; i++) {\n            babyId[id[i]] = true;\n            emit BabyInitiated(id[i]);\n        }\n    }\n\n    function initiateBabies(uint256[] memory female, uint256[] memory baby) external onlyOwner {\n        require(female.length == baby.length, \"!length\");\n        uint256 i;\n        for (i=0; i < female.length; i++) {\n            babyOf[female[i]].push(baby[i]);\n            emit BabyMatched(female[i], baby[i]);\n        }\n    }\n\n    function initiateCertificates(uint256[] memory certificate) external onlyOwner {\n        uint256 i;\n        for (i=0; i < certificate.length; i++) {\n                certificates.push(certificate[i]);\n        }\n    }\n\n    function initiateFemale(uint256[] memory female, uint256[] memory _maxBabies) external onlyOwner {\n        require(female.length == _maxBabies.length, \"!length\");\n        uint256 i;\n        for (i=0; i < female.length; i++) {\n            femaleId[female[i]] = true;\n            maxBabies[female[i]] = _maxBabies[i];\n            emit FemaleInitiated(female[i], _maxBabies[i]);\n        }\n    }\n\n    function initiateMale(uint256[] memory male, uint256[] memory _multiplier) external onlyOwner {\n        require(male.length == _multiplier.length, \"!length\");\n        uint256 i;\n        for (i=0; i < male.length; i++) {\n            maleId[male[i]] = true;\n            multiplier[male[i]] = _multiplier[i];\n            emit MaleInitiated(male[i], _multiplier[i]);\n        }\n    }\n\n    function initiateMaxBabies(uint256[] memory female, uint256[] memory _maxBabies) external onlyOwner {\n        require(female.length == _maxBabies.length, \"!length\");\n        uint256 i;\n        for (i=0; i < female.length; i++) {\n                maxBabies[female[i]] = _maxBabies[i];\n        }\n    }\n\n    function initiateMultipliers(uint256[] memory male, uint256[] memory _multiplier) external onlyOwner {\n        require(male.length == _multiplier.length, \"!length\");\n        uint256 i;\n        for (i=0; i < male.length; i++) {\n                multiplier[male[i]] = _multiplier[i];\n        }\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function _stake(uint256 tokenId) internal whenNotPaused updateReward(msg.sender) {\n        if (femaleId[tokenId] == true) {\n            require(stakedFemales[msg.sender]+1 <= 1, \"1 adult female max\");\n            stakedFemales[msg.sender]++;\n            // start breeding\n            _breeding();\n        } else if (maleId[tokenId] == true) {\n            require(stakedMales[msg.sender]+1 <= 2, \"2 adult male max\");\n            stakedMales[msg.sender]++;\n            // update current multiplier\n            if (userMultiplier[msg.sender] == 0) {\n                userMultiplier[msg.sender] = multiplier[tokenId];\n            } else {\n                if (userMultiplier[msg.sender] < multiplier[tokenId]) {\n                    userMultiplier[msg.sender] = multiplier[tokenId];\n                }\n            }\n            // start breeding\n            _breeding();\n        } else if (babyId[tokenId] == true) {\n            require(stakedBabies[msg.sender]+1 <= 2, \"2 babies max\");\n            stakedBabies[msg.sender]++;\n        } else {\n            revert(\"wrong ape\");\n        }\n        // start pay rewards\n        if (_eligibleForRewards()) {\n            _balances[msg.sender] = 1e18;\n        }\n        _totalSupply++;\n        staked[msg.sender].push(tokenId);\n        apeToken.safeTransferFrom(msg.sender, address(this), tokenId, 1, \"0x0\");\n        emit Staked(msg.sender, tokenId);\n    }\n\n    function stakeBatch(uint256[] memory tokenId) external {\n        uint i;\n        uint256 length = tokenId.length;\n        for (i=0; i < length; i++) {\n            _stake(tokenId[i]);\n        }\n    }\n\n    function withdrawAll() external {\n        uint i;\n        uint256 length = staked[msg.sender].length;\n        for (i=0; i < length; i++) {\n            _withdraw(staked[msg.sender][0]);\n        }\n    }\n\n    function exit() external {\n        uint i;\n        uint256 length = staked[msg.sender].length;\n        for (i=0; i < length; i++) {\n            _withdraw(staked[msg.sender][0]);\n        }\n        getReward();\n    }\n\n    function claimBaby() external nonReentrant whenNotPaused returns(uint256) {\n        require(stakedFemales[msg.sender] >= 1, \"female not staked\");\n        uint256 female;\n        for (uint256 i=0; i < staked[msg.sender].length; i++) {\n            // if the female staked\n            if (femaleId[staked[msg.sender][i]] == true) {\n                female = staked[msg.sender][i];\n            }\n        }\n        uint256 _maxBabies = maxBabies[female];\n        require(birth[female]+1 <= _maxBabies,\"You can not claim more\");\n        require(_breedingTime(), \"!breeding\");\n        _breeding();\n        apeToken.safeTransferFrom(apeOwner, msg.sender, babyOf[female][birth[female]], 1, \"0x0\");\n        emit Claimed(msg.sender, babyOf[female][birth[female]]);\n        birth[female]++;\n    }\n\n    function _withdraw(uint256 tokenId) internal whenNotPaused updateReward(msg.sender) {\n      require(_isStaked(tokenId),\"not staked\");\n        if (femaleId[tokenId] == true) {\n            stakedFemales[msg.sender]--;\n            breedingEnd[msg.sender] = 0; // start breeding again\n        } else if (maleId[tokenId] == true) {\n            stakedMales[msg.sender]--;\n            breedingEnd[msg.sender] = 0;\n            // update current multiplier\n            userMultiplier[msg.sender] = 0;\n        } else {\n            stakedBabies[msg.sender]--;\n        }\n        if (_eligibleForRewards()) {\n            _balances[msg.sender] = 1e18;\n        } else {\n            _balances[msg.sender] = 0;\n        }\n        _totalSupply--;\n        _remove(tokenId);\n        apeToken.safeTransferFrom(address(this), msg.sender, tokenId, 1, \"0x0\");\n        emit Withdrawn(msg.sender, tokenId);\n    }\n\n    function _eligibleForRewards() internal view returns(bool) {\n        if (stakedBabies[msg.sender] == 2 && stakedFemales[msg.sender] == 1 && stakedMales[msg.sender] == 1) {\n            return true;\n        }\n        if (stakedBabies[msg.sender] == 2 && stakedMales[msg.sender] == 2) {\n            if (_haveCertificate(msg.sender)) {\n                return true;\n            }\n        }\n    }\n\n    function _haveCertificate(address owner) internal view returns(bool) {\n        for (uint256 index = 0; index < certificates.length; index++) {\n            if (apeToken.balanceOf(owner, certificates[index]) >= 1) {\n                return true;\n            }\n        }\n    }\n\n    function _breeding() internal {\n        if (stakedFemales[msg.sender] == 1 && stakedMales[msg.sender] == 1) {\n            breedingEnd[msg.sender] = now + 10 days;\n        }\n    }\n\n    function _breedingTime() internal view returns(bool) {\n        if (breedingEnd[msg.sender] == 0) {\n            return false;\n        }\n        if (now > breedingEnd[msg.sender]) {\n            return true;\n        }\n    }\n\n    function _isStaked(uint256 tokenId) internal view returns(bool) {\n        for (uint256 index = 0; index < staked[msg.sender].length; index++) {\n            if (staked[msg.sender][index] == tokenId) {\n                return true;\n            }\n        }\n    }\n\n    function _remove(uint256 tokenId) internal {\n        uint256[] memory id = staked[msg.sender];\n        for (uint256 index = 0; index < id.length; index++) {\n            if (id[index] == tokenId) {\n                staked[msg.sender][index] = staked[msg.sender][id.length-1];\n                staked[msg.sender].pop();\n                return;\n            }\n        }\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    receive() payable external {}\n\n    function pause() external onlyOwner whenNotPaused {\n        _pause();\n        emit Paused(msg.sender);\n    }\n\n    function unpause() external onlyOwner whenPaused {\n        _unpause();\n        emit Unpaused(msg.sender);\n    }\n\n    function withdrawEther() external onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        IERC20(tokenAddress).transfer(this.owner(), tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public pure virtual returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function getStaked(address owner) external view returns (uint256[] memory) {\n        return staked[owner];\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event Staked(address indexed user, uint256 tokenId);\n    event Withdrawn(address indexed user, uint256 tokenId);\n    event Claimed(address indexed user, uint256 tokenId);\n    event Recovered(address token, uint256 amount);\n    event RewardAdded(uint256 reward);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event BabyInitiated(uint256 babyId);\n    event FemaleInitiated(uint256 femaleId, uint256 maxBabies);\n    event MaleInitiated(uint256 maleId, uint256 multiplier);\n    event BabyMatched(uint256 femaleId, uint256 babyId);\n}\n"}}}