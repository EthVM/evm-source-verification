{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":30000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"/home/bugman/Projects/idle-governance/contracts/ERC20Permit.sol":{"content":"// Permit pattern copied from BAL https://etherscan.io/address/0xba100000625a3754423978a60c9317c58a424e3d#code\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Permit is ERC20 {\n  string public constant version = \"1\";\n  bytes32 public immutable DOMAIN_SEPARATOR;\n  // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  bytes32 public immutable PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n  mapping(address => uint256) public permitNonces;\n\n  constructor(string memory name, string memory symbol)\n    public ERC20(name, symbol) {\n    uint256 chainId = getChainId();\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n        keccak256(bytes(name)),\n        keccak256(bytes(version)),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  function getChainId() internal pure returns (uint256) {\n    uint256 chainID;\n    assembly {\n      chainID := chainid()\n    }\n    return chainID;\n  }\n\n  function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n    require(block.timestamp <= deadline, \"ERR_EXPIRED_SIG\");\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        uint16(0x1901),\n        DOMAIN_SEPARATOR,\n        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, permitNonces[owner]++, deadline))\n      )\n    );\n    require(owner == _recover(digest, v, r, s), \"ERR_INVALID_SIG\");\n    _approve(owner, spender, value);\n  }\n\n  function _recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) private pure returns (address) {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n        revert(\"ECDSA: invalid signature 's' value\");\n    }\n\n    if (v != 27 && v != 28) {\n        revert(\"ECDSA: invalid signature 'v' value\");\n    }\n\n    // If the signature is valid (and not malleable), return the signer address\n    address signer = ecrecover(hash, v, r, s);\n    require(signer != address(0), \"ECDSA: invalid signature\");\n\n    return signer;\n  }\n}\n"},"/home/bugman/Projects/idle-governance/contracts/Idle.sol":{"content":"pragma solidity 0.6.12;\n\nimport \"./ERC20Permit.sol\";\n\ncontract Idle is ERC20Permit {\n    constructor() public ERC20Permit(\"Idle\", \"IDLE\") {\n      _mint(msg.sender, 13000000 * 10**18); // 13M\n    }\n\n    // Copied and modified from YAM code:\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\n    // Which is copied and modified from COMPOUND:\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) internal _delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n      /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegator The address to get delegatee for\n     */\n    function delegates(address delegator)\n        external\n        view\n        returns (address)\n    {\n        return _delegates[delegator];\n    }\n\n   /**\n    * @notice Delegate votes from `msg.sender` to `delegatee`\n    * @param delegatee The address to delegate votes to\n    */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"IDLE::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"IDLE::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"IDLE::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * ERC20 modified transferFrom that also update the avgPrice paid for the recipient and\n     * updates user gov idx\n     *\n     * @param sender : sender account\n     * @param recipient : recipient account\n     * @param amount : value to transfer\n     * @return : flag whether transfer was successful or not\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n      _transfer(sender, recipient, amount);\n      _approve(sender, msg.sender, allowance(sender, msg.sender).sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n      _moveDelegates(_delegates[sender], _delegates[recipient], amount);\n      return true;\n    }\n\n    /**\n     * ERC20 modified transfer that also update the delegates\n     *\n     * @param recipient : recipient account\n     * @param amount : value to transfer\n     * @return : flag whether transfer was successful or not\n     */\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n      _transfer(msg.sender, recipient, amount);\n      _moveDelegates(_delegates[msg.sender], _delegates[recipient], amount);\n      return true;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        require(blockNumber < block.number, \"IDLE::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee)\n        internal\n    {\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying IDLEs (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    )\n        internal\n    {\n        uint32 blockNumber = safe32(block.number, \"IDLE::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n}\n"},"/home/bugman/Projects/idle-governance/contracts/IdleController.sol":{"content":"pragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./interfaces/IdleToken.sol\";\nimport \"./lib/Exponential.sol\";\n\nimport \"./PriceOracle.sol\";\nimport \"./Idle.sol\";\nimport \"./IdleControllerStorage.sol\";\n\n/**\n * @title Idle Controller Contract\n * @author Original author Compound, modified by Idle\n */\ncontract IdleController is IdleControllerStorage, Exponential {\n  /// @notice Emitted when an admin supports a market\n  event MarketListed(address idleToken);\n\n  /// @notice Emitted when market idled status is changed\n  event MarketIdled(address idleToken, bool isIdled);\n\n  /// @notice Emitted when IDLE rate is changed\n  event NewIdleRate(uint256 oldIdleRate, uint256 newIdleRate);\n\n  /// @notice Emitted when oracle is changed\n  event NewIdleOracle(address oldIdleOracle, address newIdleOracle);\n\n  /// @notice Emitted when a new IDLE speed is calculated for a market\n  event IdleSpeedUpdated(address indexed idleToken, uint256 newSpeed);\n\n  /// @notice Emitted when IDLE is distributed to a supplier\n  event DistributedIdle(address indexed idleToken, address indexed supplier, uint256 idleDelta, uint256 idleSupplyIndex);\n\n  /// @notice The threshold above which the flywheel transfers IDLE, in wei\n  uint256 public constant idleClaimThreshold = 0.001e18;\n\n  /// @notice The initial IDLE index for a market\n  uint256 public constant idleInitialIndex = 1e36;\n\n  constructor() public {\n    admin = msg.sender;\n  }\n\n  /**\n   * @notice Checks caller is admin, or this contract is becoming the new implementation\n   */\n  function adminOrInitializing() internal view returns (bool) {\n      return msg.sender == admin || msg.sender == comptrollerImplementation;\n  }\n\n  function refreshIdleSpeeds() public {\n      require(msg.sender == tx.origin, \"only externally owned accounts may refresh speeds\");\n      refreshIdleSpeedsInternal();\n  }\n\n  function refreshIdleSpeedsInternal() internal {\n      IdleToken[] memory allMarkets_ = allMarkets;\n\n      for (uint256 i = 0; i < allMarkets_.length; i++) {\n          IdleToken idleToken = allMarkets_[i];\n          updateIdleSupplyIndex(address(idleToken));\n      }\n\n      Exp memory totalUtility = Exp({mantissa: 0});\n      Exp[] memory utilities = new Exp[](allMarkets_.length);\n      for (uint256 i = 0; i < allMarkets_.length; i++) {\n          IdleToken idleToken = allMarkets_[i];\n          if (markets[address(idleToken)].isIdled) {\n              uint256 tokenDecimals = ERC20(idleToken.token()).decimals();\n              Exp memory tokenPriceNorm = mul_(Exp({mantissa: idleToken.tokenPrice()}), 10**(sub256(18, tokenDecimals))); // norm to 1e18 always\n              Exp memory tokenSupply = Exp({mantissa: idleToken.totalSupply()}); // 1e18 always\n              Exp memory tvl = mul_(tokenPriceNorm, tokenSupply); // 1e18\n              Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(address(idleToken))}); // Must return a normalized price to 1e18\n              Exp memory tvlUnderlying = mul_(tvl, assetPrice); // 1e18\n              Exp memory utility = mul_(tvlUnderlying, Exp({mantissa: idleToken.getAvgAPR()})); // avgAPR 1e18 always\n\n              utilities[i] = utility;\n              totalUtility = add_(totalUtility, utility);\n          }\n      }\n\n      for (uint256 i = 0; i < allMarkets_.length; i++) {\n          IdleToken idleToken = allMarkets[i];\n          uint256 idleRate_ = block.timestamp < bonusEnd ? mul_(idleRate, bonusMultiplier) : idleRate;\n          uint256 newSpeed = totalUtility.mantissa > 0 ? mul_(idleRate_, div_(utilities[i], totalUtility)) : 0;\n          idleSpeeds[address(idleToken)] = newSpeed;\n          emit IdleSpeedUpdated(address(idleToken), newSpeed);\n      }\n  }\n\n  /**\n   * @notice Accrue IDLE to the market by updating the supply index\n   * @param idleToken The market whose supply index to update\n   */\n  function updateIdleSupplyIndex(address idleToken) internal {\n      IdleMarketState storage supplyState = idleSupplyState[idleToken];\n      uint256 supplySpeed = idleSpeeds[idleToken];\n      uint256 blockNumber = block.number;\n      uint256 deltaBlocks = sub_(blockNumber, supplyState.block);\n      if (deltaBlocks > 0 && supplySpeed > 0) {\n          uint256 supplyTokens = IdleToken(idleToken).totalSupply();\n          uint256 idleAccrued = mul_(deltaBlocks, supplySpeed);\n          Double memory ratio = supplyTokens > 0 ? fraction(idleAccrued, supplyTokens) : Double({mantissa: 0});\n          Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n          idleSupplyState[idleToken] = IdleMarketState({\n              index: index.mantissa,\n              block: blockNumber\n          });\n      } else if (deltaBlocks > 0) {\n          supplyState.block = blockNumber;\n      }\n  }\n\n  /**\n   * @notice Calculate IDLE accrued by a supplier and possibly transfer it to them\n   * @param idleToken The market in which the supplier is interacting\n   */\n  function distributeIdle(address idleToken, bool distributeAll) internal {\n      address supplier = idleToken;\n      IdleMarketState storage supplyState = idleSupplyState[idleToken];\n      Double memory supplyIndex = Double({mantissa: supplyState.index});\n      Double memory supplierIndex = Double({mantissa: idleSupplierIndex[idleToken][supplier]});\n      idleSupplierIndex[idleToken][supplier] = supplyIndex.mantissa;\n\n      if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n          supplierIndex.mantissa = idleInitialIndex;\n      }\n\n      Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n      uint256 supplierTokens = IdleToken(idleToken).totalSupply();\n      uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\n      uint256 supplierAccrued = add_(idleAccrued[supplier], supplierDelta);\n      idleAccrued[supplier] = transferIdle(supplier, supplierAccrued, distributeAll ? 0 : idleClaimThreshold);\n      emit DistributedIdle(idleToken, supplier, supplierDelta, supplyIndex.mantissa);\n  }\n\n  /**\n   * @notice Transfer IDLE to the user, if they are above the threshold\n   * @dev Note: If there is not enough IDLE, we do not perform the transfer all.\n   * @param user The address of the user to transfer IDLE to\n   * @param userAccrued The amount of IDLE to (possibly) transfer\n   * @return The amount of IDLE which was NOT transferred to the user\n   */\n  function transferIdle(address user, uint256 userAccrued, uint256 threshold) internal returns (uint256) {\n      if (userAccrued >= threshold && userAccrued > 0) {\n          Idle idle = Idle(idleAddress);\n          uint256 idleRemaining = idle.balanceOf(address(this));\n          if (userAccrued <= idleRemaining) {\n              idle.transfer(user, userAccrued);\n              return 0;\n          }\n      }\n      return userAccrued;\n  }\n\n  /**\n   * @notice Claim all idle accrued by the holders\n   * @param idleTokens The list of markets to claim IDLE in\n   */\n  function claimIdle(address[] memory, IdleToken[] memory idleTokens) public {\n      for (uint256 i = 0; i < idleTokens.length; i++) {\n          IdleToken idleToken = idleTokens[i];\n          require(markets[address(idleToken)].isListed, \"market must be listed\");\n          updateIdleSupplyIndex(address(idleToken));\n          distributeIdle(address(idleToken), true);\n      }\n  }\n\n  /*** Idle Distribution Admin ***/\n  /**\n   * @notice Set the amount of IDLE distributed per block\n   * @param idleRate_ The amount of IDLE wei per block to distribute\n   */\n  function _setIdleRate(uint256 idleRate_) public {\n      require(adminOrInitializing(), \"only admin can change idle rate\");\n      uint256 oldRate = idleRate;\n      idleRate = idleRate_;\n      emit NewIdleRate(oldRate, idleRate_);\n\n      refreshIdleSpeedsInternal();\n  }\n\n  function _setPriceOracle(address priceOracle_) public {\n      require(msg.sender == admin, \"only admin can change price oracle\");\n      require(priceOracle_ != address(0), \"address is 0\");\n      address oldOracle = address(oracle);\n      oracle = PriceOracle(priceOracle_);\n      emit NewIdleOracle(oldOracle, priceOracle_);\n\n      refreshIdleSpeedsInternal();\n  }\n\n  /**\n   * @notice Add markets to idleMarkets, allowing them to earn IDLE in the flywheel\n   * @param idleTokens The addresses of the markets to add\n   */\n  function _addIdleMarkets(address[] memory idleTokens) public {\n      require(adminOrInitializing(), \"only admin can change idle rate\");\n      for (uint256 i = 0; i < idleTokens.length; i++) {\n          _addIdleMarketInternal(idleTokens[i]);\n      }\n\n      refreshIdleSpeedsInternal();\n  }\n\n  function _addIdleMarketInternal(address idleToken) internal {\n      Market storage market = markets[idleToken];\n      require(market.isListed == true, \"idle market is not listed\");\n      require(market.isIdled == false, \"idle market already added\");\n\n      market.isIdled = true;\n      emit MarketIdled(idleToken, true);\n\n      if (idleSupplyState[idleToken].index == 0 && idleSupplyState[idleToken].block == 0) {\n          idleSupplyState[idleToken] = IdleMarketState({\n              index: idleInitialIndex,\n              block: block.number\n          });\n      }\n  }\n\n  /**\n   * @notice Remove a market from idleMarkets, preventing it from earning IDLE in the flywheel\n   * @param idleToken The address of the market to drop\n   */\n  function _dropIdleMarket(address idleToken) public {\n      require(msg.sender == admin, \"only admin can drop idle market\");\n\n      Market storage market = markets[idleToken];\n      require(market.isIdled == true, \"market is not a idle market\");\n\n      market.isIdled = false;\n      emit MarketIdled(idleToken, false);\n\n      refreshIdleSpeedsInternal();\n  }\n\n  /**\n    * @notice Add the market to the markets mapping and set it as listed\n    * @dev Admin function to set isListed and add support for the market\n    * @param idleTokens The array of addresses of the markets (token) to list\n    * @return uint 0=success, otherwise a failure. (See enum Error for details)\n    */\n  function _supportMarkets(address[] memory idleTokens) public returns (uint256) {\n      require(msg.sender == admin, \"only admin can change idle markets\");\n      address idleToken;\n      for (uint256 j = 0; j < idleTokens.length; j++) {\n          idleToken = idleTokens[j];\n          if (markets[address(idleToken)].isListed) {\n              /* return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS); */\n              // see https://github.com/compound-finance/compound-protocol/blob/master/contracts/ErrorReporter.sol#L15\n              return 10;\n          }\n\n          markets[idleToken] = Market({isListed: true, isIdled: false});\n\n          _addMarketInternal(idleToken);\n\n          emit MarketListed(idleToken);\n      }\n\n      return 0;\n  }\n\n  function _addMarketInternal(address idleToken) internal {\n      for (uint i = 0; i < allMarkets.length; i ++) {\n          require(allMarkets[i] != IdleToken(idleToken), \"market already added\");\n      }\n      allMarkets.push(IdleToken(idleToken));\n  }\n\n  function _become(address _unitroller) public {\n      IUnitroller unitroller = IUnitroller(_unitroller);\n      require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n      require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n  }\n\n  function _setIdleAddress(address _idleAddress) external {\n    require(msg.sender == admin, \"Not authorized\");\n    require(idleAddress == address(0), \"already initialized\");\n    require(_idleAddress != address(0), \"address is 0\");\n\n    idleAddress = _idleAddress;\n  }\n\n  function _setBonusDistribution(uint256 _bonusMultiplier) external {\n    require(msg.sender == admin, \"Not authorized\");\n    require(bonusEnd == 0, \"already initialized\");\n    bonusEnd = now + 30 days;\n    bonusMultiplier = _bonusMultiplier;\n  }\n\n  /**\n   * @notice Remove all markets from idleMarkets. This should only be called in case of emergency\n   */\n  function _resetMarkets() public returns (uint256) {\n      require(msg.sender == admin, \"only admin can change idle markets\");\n      address idleToken;\n      for (uint256 j = 0; j < allMarkets.length; j++) {\n          idleToken = address(allMarkets[j]);\n          markets[idleToken] = Market({isListed: false, isIdled: false});\n          idleSupplyState[idleToken] = IdleMarketState({index: 0, block: 0});\n          idleSupplierIndex[idleToken][idleToken] = 0;\n          idleAccrued[idleToken] = 0;\n      }\n\n      delete allMarkets;\n\n      return 0;\n  }\n\n  /**\n   * @notice Return all of the markets\n   * @dev The automatic getter may be used to access an individual market.\n   * @return The list of market addresses\n   */\n  function getAllMarkets() public view returns (IdleToken[] memory) {\n      return allMarkets;\n  }\n\n  function sub256(uint256 a, uint256 b) internal pure returns (uint) {\n      require(b <= a, \"subtraction underflow\");\n      return a - b;\n  }\n}\n\ninterface IUnitroller {\n  function admin() external returns (address);\n  function _acceptImplementation() external returns (uint256);\n}\n"},"/home/bugman/Projects/idle-governance/contracts/IdleControllerStorage.sol":{"content":"pragma solidity 0.6.12;\n\nimport \"./interfaces/IdleToken.sol\";\nimport \"./PriceOracle.sol\";\n\ncontract UnitrollerAdminStorage {\n    /**\n    * @notice Administrator for this contract\n    */\n    address public admin;\n\n    /**\n    * @notice Pending administrator for this contract\n    */\n    address public pendingAdmin;\n\n    /**\n    * @notice Active brains of Unitroller\n    */\n    address public comptrollerImplementation;\n\n    /**\n    * @notice Pending brains of Unitroller\n    */\n    address public pendingComptrollerImplementation;\n}\n\ncontract IdleControllerStorage is UnitrollerAdminStorage {\n  struct Market {\n    /// @notice Whether or not this market is listed\n    bool isListed;\n    /// @notice Whether or not this market receives IDLE\n    bool isIdled;\n  }\n\n  struct IdleMarketState {\n    /// @notice The market's last updated idleSupplyIndex\n    uint256 index;\n    /// @notice The block number the index was last updated at\n    uint256 block;\n  }\n\n  /// @notice Official mapping of idleTokens -> Market metadata\n  /// @dev Used e.g. to determine if a market is supported\n  mapping(address => Market) public markets;\n\n  /// @notice A list of all markets\n  IdleToken[] public allMarkets;\n   /// @notice The rate at which the flywheel distributes IDLE, per block\n  uint256 public idleRate;\n\n  /// @notice The portion of compRate that each market currently receives\n  mapping(address => uint256) public idleSpeeds;\n\n  /// @notice The IDLE market supply state for each market\n  mapping(address => IdleMarketState) public idleSupplyState;\n  /// @notice The IDLE supply index for each market for each supplier as of the last time they accrued IDLE\n  mapping(address => mapping(address => uint256)) public idleSupplierIndex;\n\n  /// @notice The IDLE accrued but not yet transferred to each user\n  mapping(address => uint256) public idleAccrued;\n\n  /// @notice Oracle which gives the price of any given asset\n  PriceOracle public oracle;\n\n  /// @notice IDLE governance token address\n  address public idleAddress;\n\n  /// @notice Itimestamp to limit bonus distribution on the first month\n  uint256 public bonusEnd;\n\n  /// @notice timestamp for bonus end\n  uint256 public bonusMultiplier;\n}\n"},"/home/bugman/Projects/idle-governance/contracts/PriceOracle.sol":{"content":"pragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./interfaces/IdleToken.sol\";\nimport \"./interfaces/CERC20.sol\";\nimport \"./interfaces/Comptroller.sol\";\nimport \"./interfaces/ChainLinkOracle.sol\";\n\ncontract PriceOracle is Ownable {\n  using SafeMath for uint256;\n\n  uint256 constant private ONE_18 = 10**18;\n  address constant public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n  address constant public COMP = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n  address constant public WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n  address constant public DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n  address constant public SUSD = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\n  address constant public TUSD = 0x0000000000085d4780B73119b644AE5ecd22b376;\n  address constant public USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n  address constant public USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n  uint256 public blocksPerYear = 2371428; // -> blocks per year with ~13.3s block time\n  // underlying -> chainlink feed see https://docs.chain.link/docs/reference-contracts\n  mapping (address => address) public priceFeedsUSD;\n  mapping (address => address) public priceFeedsETH;\n\n  constructor() public {\n    // USD feeds\n    priceFeedsUSD[WETH] = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419; // WETH\n    priceFeedsUSD[COMP] = 0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5; // COMP\n    priceFeedsUSD[WBTC] = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c; // wBTC\n    priceFeedsUSD[DAI] = 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9; // DAI\n\n    // ETH feeds\n    priceFeedsETH[WBTC] = 0xdeb288F737066589598e9214E782fa5A8eD689e8; // wBTC\n    priceFeedsETH[DAI] = 0x773616E4d11A78F511299002da57A0a94577F1f4; // DAI\n    priceFeedsETH[SUSD] = 0x8e0b7e6062272B5eF4524250bFFF8e5Bd3497757; // SUSD\n    priceFeedsETH[TUSD] = 0x3886BA987236181D98F2401c507Fb8BeA7871dF2; // TUSD\n    priceFeedsETH[USDC] = 0x986b5E1e1755e3C2440e960477f25201B0a8bbD4; // USDC\n    priceFeedsETH[USDT] = 0xEe9F2375b4bdF6387aa8265dD4FB8F16512A1d46; // USDT\n  }\n\n  /// @notice get price in USD for an asset\n  function getPriceUSD(address _asset) public view returns (uint256) {\n    return _getPriceUSD(_asset); // 1e18\n  }\n  /// @notice get price in ETH for an asset\n  function getPriceETH(address _asset) public view returns (uint256) {\n    return _getPriceETH(_asset); // 1e18\n  }\n  /// @notice get price in a specific token for an asset\n  function getPriceToken(address _asset, address _token) public view returns (uint256) {\n    return _getPriceToken(_asset, _token); // 1e(_token.decimals())\n  }\n  /// @notice get price for the underlying token of an idleToken\n  function getUnderlyingPrice(address _idleToken) external view returns (uint256) {\n    return getPriceUSD(IdleToken(_idleToken).token()); // 1e18\n  }\n  /// @notice get COMP additional apr for a specific cToken market\n  function getCompApr(address _cToken, address _token) external view returns (uint256) {\n    CERC20 _ctoken = CERC20(_cToken);\n    uint256 compSpeeds = Comptroller(_ctoken.comptroller()).compSpeeds(_cToken);\n    uint256 cTokenNAV = _ctoken.exchangeRateStored().mul(IERC20(_cToken).totalSupply()).div(ONE_18);\n    // how much costs 1COMP in token (1e(_token.decimals()))\n    uint256 compUnderlyingPrice = getPriceToken(COMP, _token);\n    // mul(100) needed to have a result in the format 4.4e18\n    return compSpeeds.mul(compUnderlyingPrice).mul(blocksPerYear).mul(100).div(cTokenNAV);\n  }\n\n  // #### internal\n  function _getPriceUSD(address _asset) internal view returns (uint256 price) {\n    if (priceFeedsUSD[_asset] != address(0)) {\n      price = ChainLinkOracle(priceFeedsUSD[_asset]).latestAnswer().mul(10**10); // scale it to 1e18\n    } else if (priceFeedsETH[_asset] != address(0)) {\n      price = ChainLinkOracle(priceFeedsETH[_asset]).latestAnswer();\n      price = price.mul(ChainLinkOracle(priceFeedsUSD[WETH]).latestAnswer().mul(10**10)).div(ONE_18);\n    }\n  }\n  function _getPriceETH(address _asset) internal view returns (uint256 price) {\n    if (priceFeedsETH[_asset] != address(0)) {\n      price = ChainLinkOracle(priceFeedsETH[_asset]).latestAnswer();\n    }\n  }\n  function _getPriceToken(address _asset, address _token) internal view returns (uint256 price) {\n    uint256 assetUSD = getPriceUSD(_asset);\n    uint256 tokenUSD = getPriceUSD(_token);\n    if (tokenUSD == 0) {\n      return price;\n    }\n    return assetUSD.mul(10**(uint256(ERC20(_token).decimals()))).div(tokenUSD); // 1e(tokenDecimals)\n  }\n\n  // #### onlyOwner\n  function setBlocksPerYear(uint256 _blocksPerYear) external onlyOwner {\n    blocksPerYear = _blocksPerYear;\n  }\n  // _feed can be address(0) which means disabled\n  function updateFeedETH(address _asset, address _feed) external onlyOwner {\n    priceFeedsETH[_asset] = _feed;\n  }\n  function updateFeedUSD(address _asset, address _feed) external onlyOwner {\n    priceFeedsUSD[_asset] = _feed;\n  }\n}\n"},"/home/bugman/Projects/idle-governance/contracts/interfaces/CERC20.sol":{"content":"pragma solidity 0.6.12;\n\ninterface CERC20 {\n  function comptroller() external view returns (address);\n  function exchangeRateStored() external view returns (uint256);\n}\n"},"/home/bugman/Projects/idle-governance/contracts/interfaces/ChainLinkOracle.sol":{"content":"pragma solidity 0.6.12;\n\ninterface ChainLinkOracle {\n  function latestAnswer() external view returns (uint256);\n}\n"},"/home/bugman/Projects/idle-governance/contracts/interfaces/Comptroller.sol":{"content":"pragma solidity 0.6.12;\n\ninterface Comptroller {\n  function claimComp(address) external;\n  function compSpeeds(address _cToken) external view returns (uint256);\n  function claimComp(address[] calldata holders, address[] calldata cTokens, bool borrowers, bool suppliers) external;\n}\n"},"/home/bugman/Projects/idle-governance/contracts/interfaces/IdleToken.sol":{"content":"pragma solidity 0.6.12;\n\ninterface IdleToken {\n  function totalSupply() external view returns (uint256);\n  function tokenPrice() external view returns (uint256 price);\n  function token() external view returns (address);\n  function getAvgAPR() external view returns (uint256 apr);\n  function balanceOf(address) external view returns (uint256 apr);\n  function getAPRs() external view returns (address[] memory addresses, uint256[] memory aprs);\n  function mintIdleToken(uint256 _amount, bool _skipRebalance, address _referral) external returns (uint256 mintedTokens);\n  function redeemIdleToken(uint256 _amount) external returns (uint256 redeemedTokens);\n  function redeemInterestBearingTokens(uint256 _amount) external;\n  function rebalance() external returns (bool);\n}\n"},"/home/bugman/Projects/idle-governance/contracts/lib/CarefulMath.sol":{"content":"pragma solidity 0.6.12;\n\n/**\n  * @title Careful Math\n  * @author Compound\n  * @notice Derived from OpenZeppelin's SafeMath library\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n  */\ncontract CarefulMath {\n\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n    * @dev Multiplies two numbers, returns an error on overflow.\n    */\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b <= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev Adds two numbers, returns an error on overflow.\n    */\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        uint c = a + b;\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev add a and b and then subtract c\n    */\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n        (MathError err0, uint sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n"},"/home/bugman/Projects/idle-governance/contracts/lib/Exponential.sol":{"content":"pragma solidity 0.6.12;\n\nimport \"./CarefulMath.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath {\n    uint constant expScale = 1e18;\n    uint constant doubleScale = 1e36;\n    uint constant halfExpScale = expScale/2;\n    uint constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct Double {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) pure internal returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\n        require(n < 2**224, errorMessage);\n        return uint224(n);\n    }\n\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(uint a, uint b) pure internal returns (uint) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        uint c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(uint a, uint b) pure internal returns (uint) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n    }\n\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n    }\n\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint a, uint b) pure internal returns (uint) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n    }\n\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n    }\n\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Double memory b) pure internal returns (uint) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint a, uint b) pure internal returns (uint) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\n    }\n}\n"},"@openzeppelin/contracts/GSN/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"@openzeppelin/contracts/math/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"@openzeppelin/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"}}}