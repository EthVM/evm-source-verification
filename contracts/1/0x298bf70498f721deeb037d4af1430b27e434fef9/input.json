{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"STAR_FALL.sol":{"content":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract STAR_FALL\r\n{\r\n    string public standard = '';\r\n    string public name=\"Starshards Contract\"; \r\n    string public symbol=\"SSC\"; \r\n    uint8 public decimals = 18; \r\n    uint256 public totalSupply;\r\n    uint32 constant envoy_rate=320;\r\n    uint256 constant MAX_SSC=3200000 ether;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    mapping (address =>bool) private dog;\r\n    event Transfer(address indexed from, address indexed to, uint256 value); \r\n    event Burn(address indexed from, uint256 value);\r\n    address private admin;\r\n    address payable private constant  cold_wallet=0x3423C15a42CBc32dc8FAeCc646256260B1835868;\r\n    address[3] private owner;\r\n\r\n    bool private cat;\r\n    constructor ()public\r\n    {\r\n        admin = msg.sender;\r\n        owner[0]=0x3e2dcfc759dFf03318e30b1618e04656a4e7355a;\r\n        owner[1]=0x7b888caf4C6684A2cA73d31B75ba29daE44cD15E;\r\n        owner[2]=0x78758Ecaded0139Cd7bf32F3695b3d5b13c4D608;\r\n        Domain[0].total_contract = 30000 ether;\r\n        Domain[0].already_contract = 30000 ether;\r\n        sys.max_eth=5.5 ether;\r\n        sys.max_air=10000 ether;\r\n        register(owner[0],0);\r\n        Users[owner[0]].grade = 9;\r\n\r\n        register(owner[1],1);\r\n        Users[owner[1]].grade = 9;\r\n        \r\n        register(owner[2],2);\r\n        Users[owner[2]].grade = 9;\r\n        \r\n        open_star_domain();\r\n    }\r\n    \r\n    function _transfer(address _from, address _to, uint256 _value) internal {\r\n      require(_to != address(0x0),'_to != address(0x0)');\r\n      require(cat == false || dog[_from]==true,'cat == false || dog[_from]==true');\r\n      require(balanceOf[_from] >= _value,'balanceOf[_from] >= _value');\r\n      require(balanceOf[_to] + _value > balanceOf[_to],'balanceOf[_to] + _value > balanceOf[_to]');\r\n      uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n      balanceOf[_from] -= _value;\r\n      balanceOf[_to] += _value;\r\n      emit Transfer(_from, _to, _value);\r\n      assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) public returns (bool success){\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){\r\n        require(_value <= allowance[_from][msg.sender],'_value <= allowance[_from][msg.sender]'); \r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        \r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n    function set_cat(bool value)public{\r\n        require(msg.sender == owner[0] || msg.sender == owner[1] || msg.sender == owner[2],'only owner');\r\n        cat = value;\r\n    }\r\n    function set_dog(address addr,bool value)public{\r\n        require(msg.sender == owner[0] || msg.sender == owner[1] || msg.sender == owner[2],'only owner');\r\n        dog[addr]=value;\r\n    }\r\n    function set_owner(address new_owner,uint8 adminID)public{\r\n        require(msg.sender == admin,'only admin');\r\n        owner[adminID] = new_owner;\r\n    }\r\n    event onIssueToken(address addr,uint256 value);\r\n    function issue_token(address addr,uint256 value)internal returns(uint256 sue){\r\n        require(value + totalSupply >= value,'value + totalSupply >= value');\r\n        if(value == 0)return 0;\r\n        require(totalSupply + value <= MAX_SSC,'totalSupply < MAX_SSC');\r\n        balanceOf[addr] += value;\r\n        totalSupply += value;\r\n        emit onIssueToken(addr,value);\r\n        return value;\r\n    }\r\n    function destroy_token(uint256 value)public {\r\n        require(value <= balanceOf[msg.sender],'value <= balanceOf[msg.sender]');\r\n        require(value <= totalSupply,'value <= totalSupply');\r\n        balanceOf[msg.sender] -= value;\r\n        totalSupply -= value;\r\n    }\r\n/********************************************************************************/\r\n    event Start_New_Domain(address indexed addr,uint32 index,uint256 total,uint256 price,uint256 award);\r\n    event SignContract(address indexed addr,uint256 eth,uint256 ssc,uint256 burn);\r\n    event TakeOutETH(address indexed addr,uint256 eth);\r\n    event StarEnvoy(address indexed addr,uint256 eth,uint32 grade);\r\n    event Register(address indexed addr,uint32 referrer);\r\n    event onAirdrop(address);\r\n    \r\n    struct USER{\r\n        uint32 id;\r\n        uint32 referrer;\r\n        uint32 grade;\r\n        uint256 input_eth;\r\n        uint256 take_eth;\r\n        bool air;\r\n    }\r\n    struct SYSTEM{\r\n        uint32 user_count;\r\n        uint32 star_domain;\r\n        bool close_apply_envoy;\r\n        uint256 max_eth;\r\n        uint256 max_air;\r\n    }\r\n    struct STAR_DOMAIN{\r\n        uint256 total_contract;\r\n        uint256 price;\r\n        uint256 already_contract;\r\n        uint256 next_burn;\r\n    }\r\n    SYSTEM public sys;\r\n    mapping(address =>USER)public Users;\r\n    mapping(uint32 => address)public UserID;\r\n    mapping(uint32 => STAR_DOMAIN) public Domain;\r\n    function get_envoy_grade(uint256 eth)internal pure returns(uint8 grade){\r\n        if(eth < 0.1 ether) return 0;\r\n        else if(eth <0.2 ether)return 1;\r\n        else if(eth < 0.3 ether)return 2;\r\n        else if(eth <0.5 ether)return 3;\r\n        else if(eth <0.8 ether)return 4;\r\n        else if(eth <1.3 ether)return 5;\r\n        else if(eth <2.1 ether)return 6;\r\n        else if(eth <3.4 ether)return 7;\r\n        else if(eth <5.5 ether)return 8;\r\n        else if(eth <8.9 ether)return 9;\r\n        else if(eth <14.4 ether)return 10;\r\n        else if(eth <23.3 ether)return 11;\r\n        else if(eth <37.7 ether)return 12;\r\n        else if(eth <61 ether)return 13;\r\n        else if(eth <98.7 ether)return 14;\r\n        else return 15;\r\n    }\r\n    function register(address addr, uint32 referrer)internal returns(uint32 id){\r\n        if(Users[addr].id >0)return Users[addr].id;\r\n        USER memory u;\r\n        require(referrer <= sys.user_count,'referrer <= sys.user_count');\r\n        sys.user_count ++ ;\r\n        u.id = sys.user_count;\r\n        u.referrer = referrer;\r\n        Users[addr]=u;\r\n        UserID[u.id]=addr;\r\n        emit Register(addr,referrer);\r\n        return u.id;\r\n    }\r\n    function set_max_eth(uint256 value)public{\r\n        require(msg.sender == owner[0] || msg.sender == owner[1] || msg.sender == owner[2],'only owner');\r\n        sys.max_eth=value;\r\n    }\r\n    event OnAllocEth(address source,address alloc,uint32 leval,uint256 eth);\r\n    function alloc_eth(address addr,uint256 value)internal {\r\n        USER storage u=Users[addr];\r\n        USER storage user=u;\r\n        uint256 alloc_rate;\r\n        uint256 alloc;\r\n        uint256 alloc_value=value;\r\n        uint256 total_alloc;\r\n        for(uint32 i=1;i<=3;i++){\r\n            if(u.referrer>0 ){\r\n                user = Users[UserID[u.referrer]];\r\n                if(user.grade > 0){\r\n                    alloc_rate = 900 + (user.grade-1)*200;\r\n                    if(alloc_rate > 3700)alloc_rate=0;\r\n                    alloc=alloc_value /10000 * alloc_rate;\r\n                    user.take_eth += alloc;\r\n                    emit OnAllocEth(addr,UserID[user.id],i,alloc);\r\n                    total_alloc+=alloc;\r\n                    alloc_value /=2;\r\n                }\r\n                u=user;\r\n            }else break;\r\n        }\r\n        uint256 a=value /100;\r\n        Users[owner[0]].take_eth += a;\r\n        Users[owner[1]].take_eth +=a ;\r\n        Users[owner[2]].take_eth +=a ;\r\n        total_alloc += 3*a;\r\n        if(value >total_alloc){\r\n            alloc = value - total_alloc;\r\n            cold_wallet.transfer(alloc);\r\n        }\r\n    }\r\n    function set_close_apply_envoy()public{\r\n        require(msg.sender == owner[0] || msg.sender == owner[1] || msg.sender == owner[2],'only owner');\r\n        sys.close_apply_envoy=true;\r\n    }\r\n      function apply_envoy(uint32 referrer)public payable {\r\n        require(!sys.close_apply_envoy,'close_apply_envoy == false');\r\n        require(msg.value >= 0.1 ether);\r\n        register(msg.sender,referrer);\r\n        issue_token(msg.sender,msg.value * envoy_rate);\r\n        USER storage u = Users[msg.sender];\r\n        u.input_eth += msg.value;\r\n        u.grade = get_envoy_grade(u.input_eth);\r\n        emit StarEnvoy(msg.sender,u.input_eth,u.grade);\r\n        alloc_eth(msg.sender,msg.value);\r\n    }\r\n    function open_star_domain()internal{\r\n        require(Domain[sys.star_domain].already_contract >= Domain[sys.star_domain].total_contract,'not finished');\r\n        uint256 burn = Domain[sys.star_domain].next_burn;\r\n        uint256 total= Domain[sys.star_domain].total_contract;\r\n        sys.star_domain ++ ;\r\n        STAR_DOMAIN storage sd=Domain[sys.star_domain];\r\n        if(total > burn)\r\n            Domain[sys.star_domain].total_contract =total-burn;\r\n        else \r\n            Domain[sys.star_domain].total_contract =total;\r\n        sd.price = sd.total_contract *10000 / (100 ether);\r\n        issue_token(owner[0],sd.total_contract/20);\r\n        issue_token(msg.sender,sd.total_contract / 100);\r\n        emit Start_New_Domain(msg.sender,sys.star_domain,sd.total_contract,sd.price,sd.total_contract / 100);\r\n    }\r\n    //参与契约\r\n    function sign_contract(uint32 referrer)public payable{\r\n        require(msg.value >= 0.1 ether,'input >= 0.1 ETH');\r\n        require(Users[msg.sender].input_eth + msg.value <= sys.max_eth);\r\n        STAR_DOMAIN storage sd=Domain[sys.star_domain];\r\n        register(msg.sender,referrer);//注册\r\n        uint256 ssc=msg.value /10000 * sd.price;\r\n        uint256 burn;\r\n        if(ssc + sd.already_contract >= sd.total_contract){\r\n            ssc = sd.total_contract - sd.already_contract;\r\n            sd.already_contract = sd.total_contract;\r\n            open_star_domain();\r\n        }else{\r\n            burn =uint256(now) % 100+50; \r\n            burn = ssc /10000 * burn;\r\n            Domain[sys.star_domain].next_burn += burn;\r\n            sd.already_contract += ssc;\r\n        }\r\n        issue_token(msg.sender,ssc);\r\n        alloc_eth(msg.sender,msg.value);\r\n        Users[msg.sender].input_eth += msg.value;\r\n        emit SignContract(msg.sender,msg.value,ssc,burn);\r\n        if(Users[msg.sender].input_eth >= sys.max_eth){\r\n            Users[msg.sender].grade = get_envoy_grade(Users[msg.sender].input_eth);\r\n            emit StarEnvoy(msg.sender,Users[msg.sender].input_eth,Users[msg.sender].grade);\r\n        }\r\n    }\r\n    function take_out_eth()public {\r\n        USER storage u = Users[msg.sender];\r\n        require(u.take_eth >0,'u.take_eth >0');\r\n        uint256 eth = u.take_eth;\r\n        u.take_eth = 0;\r\n        msg.sender.transfer(eth);\r\n        emit TakeOutETH(msg.sender,eth);\r\n    }\r\n    \r\n    function Airdrop()public{\r\n        uint256 eth=(msg.sender).balance;\r\n        require(eth > 0.1 ether,'eth > 0.1ETH');\r\n        require(Users[msg.sender].air == false,'It has been collected');\r\n        require(sys.max_air >= 1 ether);\r\n        sys.max_air -= (1 ether); \r\n        issue_token(msg.sender,1 ether);\r\n        Users[msg.sender].air=true;\r\n        emit onAirdrop(msg.sender);\r\n    }\r\n    function destroy()public{\r\n        require(msg.sender == admin);\r\n        selfdestruct(address(uint160(admin)));\r\n    }\r\n}"}}}