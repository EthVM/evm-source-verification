{
  "language": "Solidity",
  "settings": {
    "evmVersion": "petersburg",
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "SCHUTZ.sol": {
      "content": "pragma solidity 0.5.11;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface ICustomersFundable {\r\n    function fundCustomer(address customerAddress, uint256 value, uint8 subconto) external payable;\r\n}\r\n\r\ninterface IRemoteWallet {\r\n    function invest(address customerAddress, address target, uint256 value, uint8 subconto) external returns (bool);\r\n}\r\n\r\ninterface IUSDT {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external;\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external;\r\n    function transferFrom(address sender, address recipient, uint256 amount) external;\r\n    function decimals() external view returns(uint8);\r\n}\r\n\r\ncontract SCHUTZ {\r\n    using SafeMath for uint256;\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBoss3 {\r\n        require(msg.sender == boss3);\r\n        _;\r\n    }\r\n\r\n    string public name = \"Zinsdepot unter Schutz\";\r\n    string public symbol = \"SCHUTZ\";\r\n    uint8 constant public decimals = 6;\r\n\r\n    address public admin;\r\n    address constant internal boss1 = 0xC5f6A5EDAedeCE6A221db4ec6103edf3B407Da8E;\r\n    address constant internal boss2 = 0xA52FAE9D447C8379761C86a112c134f8d7816C33;\r\n    address public boss3 = 0x47b1E65E0f6D2350c90b4AdE98Dbf9e8E9aa28D7;\r\n    address public boss4 = address(0); ///\r\n    address public boss5 = address(0); ///\r\n\r\n    uint256 public refLevel1_ = 9;\r\n    uint256 public refLevel2_ = 3;\r\n    uint256 public refLevel3_ = 2;\r\n\r\n    uint256 internal tokenPrice = 1;\r\n    uint256 public minimalInvestment = 500e6;\r\n    uint256 public stakingRequirement = 0;\r\n    uint256 public feePercent = 0; ///\r\n    uint256 public percentDivider = 10000;\r\n\r\n    mapping(address => uint256) internal tokenBalanceLedger_;\r\n    mapping(address => uint256) public interestBalance_;\r\n    mapping(address => uint256) public depositBalance_;\r\n    mapping(address => uint256) public mayPayouts_;\r\n\r\n    uint256 internal tokenSupply_;\r\n    bool public depositAvailable = true;\r\n\r\n    IUSDT public token;\r\n\r\n    constructor(address tokenAddr, address recipient, uint256 initialSupply) public {\r\n        token = IUSDT(tokenAddr);\r\n\r\n        admin = msg.sender;\r\n        mayPayouts_[boss1] = 1e60;\r\n        mayPayouts_[boss2] = 1e60;\r\n        mayPayouts_[boss3] = 1e60;\r\n\r\n        tokenBalanceLedger_[recipient] = initialSupply;\r\n        tokenSupply_ = initialSupply;\r\n        emit Transfer(address(0), recipient, initialSupply);\r\n    }\r\n\r\n    function deposit(uint256 value, address _ref1, address _ref2, address _ref3) public returns (uint256) {\r\n        require(value >= minimalInvestment, \"Value is below minimal investment.\");\r\n        require(token.allowance(msg.sender, address(this)) >= value, \"Token allowance error: approve this amount first\");\r\n        require(depositAvailable, \"Sales stopped for the moment.\");\r\n        token.transferFrom(msg.sender, address(this), value);\r\n        return purchaseTokens(value, _ref1, _ref2, _ref3);\r\n    }\r\n\r\n    function reinvest(uint256 value) public {\r\n        require(value > 0);\r\n        address _customerAddress = msg.sender;\r\n        interestBalance_[_customerAddress] = interestBalance_[_customerAddress].sub(value);\r\n        uint256 _tokens = purchaseTokens(value, address(0x0), address(0x0), address(0x0));\r\n        emit OnReinvestment(_customerAddress, value, _tokens, false, now);\r\n    }\r\n\r\n    function exit() public {\r\n        address _customerAddress = msg.sender;\r\n        uint256 balance = depositBalance_[_customerAddress];\r\n        if (balance > 0) closeDeposit(balance);\r\n        withdraw(interestBalance_[_customerAddress]);\r\n    }\r\n\r\n    function withdraw(uint256 value) public {\r\n        require(value > 0);\r\n        address _customerAddress = msg.sender;\r\n        interestBalance_[_customerAddress] = interestBalance_[_customerAddress].sub(value);\r\n        token.transfer(_customerAddress, value);\r\n        emit OnWithdraw(_customerAddress, value, now);\r\n    }\r\n\r\n    function closeDeposit(uint256 value) public {\r\n        require(value > 0);\r\n        address _customerAddress = msg.sender;\r\n        depositBalance_[_customerAddress] = depositBalance_[_customerAddress].sub(value);\r\n\r\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress].sub(value);\r\n        tokenSupply_ = tokenSupply_.sub(value);\r\n\r\n        token.transfer(_customerAddress, value);\r\n        emit OnGotRepay(_customerAddress, value, now);\r\n        emit Transfer(_customerAddress, address(0), value);\r\n    }\r\n\r\n    function purchaseTokens(uint256 _incomingValue, address _ref1, address _ref2, address _ref3) internal returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        uint256 welcomeFee_ = refLevel1_.add(refLevel2_).add(refLevel3_);\r\n        require(welcomeFee_ <= 99);\r\n        require(_customerAddress != _ref1 && _customerAddress != _ref2 && _customerAddress != _ref3);\r\n\r\n        uint256[7] memory uIntValues = [\r\n            _incomingValue.mul(welcomeFee_).div(100),\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            0\r\n        ];\r\n\r\n        uIntValues[1] = uIntValues[0].mul(refLevel1_).div(welcomeFee_);\r\n        uIntValues[2] = uIntValues[0].mul(refLevel2_).div(welcomeFee_);\r\n        uIntValues[3] = uIntValues[0].mul(refLevel3_).div(welcomeFee_);\r\n\r\n        uint256 fee = _incomingValue.mul(feePercent).div(percentDivider);\r\n        uint256 _taxedValue = _incomingValue.sub(uIntValues[0]).sub(fee);\r\n\r\n        uint256 _amountOfTokens = valueToTokens_(_incomingValue);\r\n\r\n        require(_amountOfTokens > 0);\r\n\r\n        if (\r\n            _ref1 != 0x0000000000000000000000000000000000000000 &&\r\n            tokensToValue_(tokenBalanceLedger_[_ref1]) >= stakingRequirement\r\n        ) {\r\n            interestBalance_[_ref1] = interestBalance_[_ref1].add(uIntValues[1]);\r\n        } else {\r\n            interestBalance_[boss1] = interestBalance_[boss1].add(uIntValues[1]);\r\n            _ref1 = 0x0000000000000000000000000000000000000000;\r\n        }\r\n\r\n        if (\r\n            _ref2 != 0x0000000000000000000000000000000000000000 &&\r\n            tokensToValue_(tokenBalanceLedger_[_ref2]) >= stakingRequirement\r\n        ) {\r\n            interestBalance_[_ref2] = interestBalance_[_ref2].add(uIntValues[2]);\r\n        } else {\r\n            interestBalance_[boss1] = interestBalance_[boss1].add(uIntValues[2]);\r\n            _ref2 = 0x0000000000000000000000000000000000000000;\r\n        }\r\n\r\n        if (\r\n            _ref3 != 0x0000000000000000000000000000000000000000 &&\r\n            tokensToValue_(tokenBalanceLedger_[_ref3]) >= stakingRequirement\r\n        ) {\r\n            interestBalance_[_ref3] = interestBalance_[_ref3].add(uIntValues[3]);\r\n        } else {\r\n            interestBalance_[boss1] = interestBalance_[boss1].add(uIntValues[3]);\r\n            _ref3 = 0x0000000000000000000000000000000000000000;\r\n        }\r\n\r\n\r\n        interestBalance_[boss2] = interestBalance_[boss2].add(_taxedValue);\r\n        interestBalance_[boss5] = interestBalance_[boss5].add(fee);\r\n\r\n        tokenSupply_ = tokenSupply_.add(_amountOfTokens);\r\n\r\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress].add(_amountOfTokens);\r\n\r\n        emit OnTokenPurchase(_customerAddress, _incomingValue, _amountOfTokens, _ref1, _ref2, _ref3, uIntValues[4], uIntValues[5], uIntValues[6], now);\r\n        emit Transfer(address(0), _customerAddress, _amountOfTokens);\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    function investCharity(uint256 value) public {\r\n        require(boss4 != address(0));\r\n        require(value > 0);\r\n        address _customerAddress = msg.sender;\r\n        interestBalance_[_customerAddress] = interestBalance_[_customerAddress].sub(value);\r\n        interestBalance_[boss4] = interestBalance_[boss4].add(value);\r\n\r\n        emit OnInvestCharity(_customerAddress, value, now);\r\n    }\r\n\r\n    /* Admin methods */\r\n    function issue(uint256 startIndex, address[] memory customerAddresses, uint256[] memory values) public onlyBoss3 {\r\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\r\n            tokenSupply_ = tokenSupply_.add(values[i]);\r\n            tokenBalanceLedger_[customerAddresses[i]] = tokenBalanceLedger_[customerAddresses[i]].add(values[i]);\r\n            emit OnMint(customerAddresses[i], values[i], now);\r\n            emit Transfer(address(0), customerAddresses[i], values[i]);\r\n        }\r\n    }\r\n\r\n    function setParameters(uint8 level1, uint8 level2, uint8 level3, uint256 minInvest, uint256 staking, uint256 newFeePercent) public {\r\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2 || msg.sender == boss5, \"No access\");\r\n        require(newFeePercent <= percentDivider); /// заменить \"percentDivider\" на ограничение, допустим если не больше 10% то 1000;\r\n        refLevel1_ = level1;\r\n        refLevel2_ = level2;\r\n        refLevel3_ = level3;\r\n\r\n        minimalInvestment = minInvest;\r\n        stakingRequirement = staking;\r\n        feePercent = newFeePercent;\r\n\r\n        emit OnRefBonusSet(level1, level2, level3, minInvest, staking, newFeePercent, now);\r\n    }\r\n\r\n    function accrualDeposit(uint256 startIndex, uint256[] memory values, address[] memory customerAddresses, string memory comment) public {\r\n        require(mayPayouts_[msg.sender] > 0, \"Not allowed to pass interest from your address\");\r\n        uint256 totalValue;\r\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\r\n            require(values[i] > 0);\r\n            totalValue = totalValue.add(values[i]);\r\n            depositBalance_[customerAddresses[i]] = depositBalance_[customerAddresses[i]].add(values[i]);\r\n            emit OnRepayPassed(customerAddresses[i], msg.sender, values[i], comment, now);\r\n        }\r\n        require(totalValue <= token.allowance(msg.sender, address(this)), \"Token allowance error: approve this amount first\");\r\n        token.transferFrom(msg.sender, address(this), totalValue);\r\n        mayPayouts_[msg.sender] = mayPayouts_[msg.sender].sub(totalValue);\r\n    }\r\n\r\n    function allowPayouts(address payer, uint256 value, string memory comment) public onlyAdmin {\r\n        mayPayouts_[payer] = value;\r\n        emit OnRepayAddressAdded(payer, value, comment, now);\r\n    }\r\n\r\n    function accrualInterest(uint256 startIndex, uint256[] memory values, address[] memory customerAddresses, string memory comment) public {\r\n        require(mayPayouts_[msg.sender] > 0, \"Not allowed to pass interest from your address\");\r\n        uint256 totalValue;\r\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\r\n            require(values[i] > 0);\r\n            totalValue = totalValue.add(values[i]);\r\n            interestBalance_[customerAddresses[i]] = interestBalance_[customerAddresses[i]].add(values[i]);\r\n            emit OnInterestPassed(customerAddresses[i], values[i], comment, now);\r\n        }\r\n        require(totalValue <= token.allowance(msg.sender, address(this)), \"Token allowance error: approve this amount first\");\r\n        token.transferFrom(msg.sender, address(this), totalValue);\r\n    }\r\n\r\n    function switchState() public onlyAdmin {\r\n        if (depositAvailable) {\r\n            depositAvailable = false;\r\n            emit OnSaleStop(now);\r\n        } else {\r\n            depositAvailable = true;\r\n            emit OnSaleStart(now);\r\n        }\r\n    }\r\n\r\n    function setName(string memory newName, string memory newSymbol) public {\r\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2);\r\n\r\n        emit OnNameSet(name, symbol, newName, newSymbol, now);\r\n        name = newName;\r\n        symbol = newSymbol;\r\n    }\r\n\r\n    function seize(address customerAddress, address receiver) public {\r\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2);\r\n\r\n        uint256 tokens = tokenBalanceLedger_[customerAddress];\r\n        if (tokens > 0) {\r\n            tokenBalanceLedger_[customerAddress] = 0;\r\n            tokenBalanceLedger_[receiver] = tokenBalanceLedger_[receiver].add(tokens);\r\n            emit Transfer(customerAddress, receiver, tokens);\r\n        }\r\n\r\n        uint256 value = interestBalance_[customerAddress];\r\n        if (value > 0) {\r\n            interestBalance_[customerAddress] = 0;\r\n            interestBalance_[receiver] = interestBalance_[receiver].add(value);\r\n        }\r\n\r\n        uint256 repay = depositBalance_[customerAddress];\r\n        if (repay > 0) {\r\n            depositBalance_[customerAddress] = 0;\r\n            depositBalance_[receiver] = depositBalance_[receiver].add(repay);\r\n        }\r\n\r\n        emit OnSeize(customerAddress, receiver, tokens, value, repay, now);\r\n    }\r\n\r\n    function shift(uint256 startIndex, address[] memory holders, address[] memory recipients, uint256[] memory values) public {\r\n        require(msg.sender == boss1 || msg.sender == boss2 || msg.sender == boss3);\r\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\r\n            require(values[i] > 0);\r\n\r\n            tokenBalanceLedger_[holders[i]] = tokenBalanceLedger_[holders[i]].sub(values[i]);\r\n            tokenBalanceLedger_[recipients[i]] = tokenBalanceLedger_[recipients[i]].add(values[i]);\r\n\r\n            emit OnShift(holders[i], recipients[i], values[i], now);\r\n            emit Transfer(holders[i], recipients[i], values[i]);\r\n        }\r\n    }\r\n\r\n    function burn(uint256 startIndex, address[] memory holders, uint256[] memory values) public {\r\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2 || msg.sender == boss3);\r\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\r\n            require(values[i] > 0);\r\n\r\n            tokenSupply_ = tokenSupply_.sub(values[i]);\r\n            tokenBalanceLedger_[holders[i]] = tokenBalanceLedger_[holders[i]].sub(values[i]);\r\n\r\n            emit OnBurn(holders[i], values[i], now);\r\n            emit Transfer(holders[i], address(0), values[i]);\r\n        }\r\n    }\r\n\r\n    function withdrawERC20(address ERC20Token, address recipient, uint256 value) public {\r\n        require(msg.sender == boss1 || msg.sender == boss2);\r\n\r\n        require(value > 0);\r\n\r\n        IUSDT(ERC20Token).transfer(recipient, value);\r\n    }\r\n\r\n    function deputeBoss3(address x) public {\r\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2 || msg.sender == boss3, \"No access\");\r\n        emit OnBoss3Deposed(boss3, x, now);\r\n        boss3 = x;\r\n    }\r\n\r\n    function deputeBoss4(address x) public {\r\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2, \"No access\");\r\n        emit OnBoss4Deposed(boss4, x, now);\r\n        boss4 = x;\r\n    }\r\n\r\n    function deputeBoss5(address x) public {\r\n        require(msg.sender == boss1 || msg.sender == boss2 || msg.sender == boss5, \"No access\");\r\n        emit OnBoss5Deposed(boss5, x, now);\r\n        boss5 = x;\r\n    }\r\n\r\n    /* View methods */\r\n    function totalSupply() external view returns (uint256) {\r\n        return tokenSupply_;\r\n    }\r\n\r\n    function balanceOf(address _customerAddress) public view returns (uint256) {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n\r\n    function valueToTokens_(uint256 _value) public view returns (uint256) {\r\n        uint256 _tokensReceived = _value.mul(tokenPrice).mul(1e12);\r\n\r\n        return _tokensReceived;\r\n    }\r\n\r\n    function tokensToValue_(uint256 _tokens) public view returns (uint256) {\r\n        uint256 _valueReceived = _tokens.div(tokenPrice).div(1e12);\r\n\r\n        return _valueReceived;\r\n    }\r\n\r\n    event OnTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingValue,\r\n        uint256 tokensMinted,\r\n        address ref1,\r\n        address ref2,\r\n        address ref3,\r\n        uint256 ref1value,\r\n        uint256 ref2value,\r\n        uint256 ref3value,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 valueReinvested,\r\n        uint256 tokensMinted,\r\n        bool isRemote,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 value,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnGotRepay(\r\n        address indexed customerAddress,\r\n        uint256 value,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnRepayPassed(\r\n        address indexed customerAddress,\r\n        address indexed payer,\r\n        uint256 value,\r\n        string comment,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnInterestPassed(\r\n        address indexed customerAddress,\r\n        uint256 value,\r\n        string comment,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnSaleStop(\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnSaleStart(\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnRepayAddressAdded(\r\n        address indexed payer,\r\n        uint256 value,\r\n        string comment,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnRepayAddressRemoved(\r\n        address indexed payer,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnMint(\r\n        address indexed customerAddress,\r\n        uint256 value,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnBoss3Deposed(\r\n        address indexed former,\r\n        address indexed current,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnBoss4Deposed(\r\n        address indexed former,\r\n        address indexed current,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnBoss5Deposed(\r\n        address indexed former,\r\n        address indexed current,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnRefBonusSet(\r\n        uint8 level1,\r\n        uint8 level2,\r\n        uint8 level3,\r\n        uint256 minimalInvestment,\r\n        uint256 stakingRequirement,\r\n        uint256 newFeePercent,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnFund(\r\n        address indexed source,\r\n        uint256 value,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnBurn (\r\n        address holder,\r\n        uint256 value,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnSeize(\r\n        address indexed customerAddress,\r\n        address indexed receiver,\r\n        uint256 tokens,\r\n        uint256 value,\r\n        uint256 repayValue,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnShift (\r\n        address holder,\r\n        address recipient,\r\n        uint256 value,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnNameSet (\r\n        string oldName,\r\n        string oldSymbol,\r\n        string newName,\r\n        string newSymbol,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnTokenSet (\r\n        address oldToken,\r\n        address newToken,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event OnInvestCharity (\r\n        address indexed customerAddress,\r\n        uint256 value,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event Transfer (\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n}"
    }
  }
}