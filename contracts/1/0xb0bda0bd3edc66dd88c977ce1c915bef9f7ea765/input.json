{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"WOWDCFO.sol":{"content":"/*\r\n __      __            .__       .___         _____                                     \r\n/  \\    /  \\___________|  |    __| _/   _____/ ____\\                                    \r\n\\   \\/\\/   /  _ \\_  __ \\  |   / __ |   /  _ \\   __\\                                     \r\n \\        (  <_> )  | \\/  |__/ /_/ |  (  <_> )  |                                       \r\n  \\__/\\  / \\____/|__|  |____/\\____ |   \\____/|__|                                       \r\n       \\/                         \\/                                                    \r\n      __      __.__    .__  __           ________            .___             \r\n      /  \\    /  \\  |__ |__|/  |_  ____   \\______ \\  __ __  __| _/____   ______\r\n      \\   \\/\\/   /  |  \\|  \\   __\\/ __ \\   |    |  \\|  |  \\/ __ |/ __ \\ /  ___/\r\n      \\        /|   Y  \\  ||  | \\  ___/   |    `   \\  |  / /_/ \\  ___/ \\___ \\ \r\n        \\__/\\  / |___|  /__||__|  \\___  > /_______  /____/\\____ |\\___  >____  >\r\n            \\/       \\/              \\/          \\/           \\/    \\/     \\/ \r\n\r\n            More like World of White DAOudes imho\r\n\r\n*/\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nlibrary SafeCast {\r\n    function toUint224(uint256 value) internal pure returns (uint224) {\r\n        require(\r\n            value <= type(uint224).max,\r\n            \"SafeCast: value doesn't fit in 224 bits\"\r\n        );\r\n        return uint224(value);\r\n    }\r\n\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(\r\n            value <= type(uint128).max,\r\n            \"SafeCast: value doesn't fit in 128 bits\"\r\n        );\r\n        return uint128(value);\r\n    }\r\n\r\n    function toUint96(uint256 value) internal pure returns (uint96) {\r\n        require(\r\n            value <= type(uint96).max,\r\n            \"SafeCast: value doesn't fit in 96 bits\"\r\n        );\r\n        return uint96(value);\r\n    }\r\n\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(\r\n            value <= type(uint64).max,\r\n            \"SafeCast: value doesn't fit in 64 bits\"\r\n        );\r\n        return uint64(value);\r\n    }\r\n\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(\r\n            value <= type(uint32).max,\r\n            \"SafeCast: value doesn't fit in 32 bits\"\r\n        );\r\n        return uint32(value);\r\n    }\r\n\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(\r\n            value <= type(uint16).max,\r\n            \"SafeCast: value doesn't fit in 16 bits\"\r\n        );\r\n        return uint16(value);\r\n    }\r\n\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(\r\n            value <= type(uint8).max,\r\n            \"SafeCast: value doesn't fit in 8 bits\"\r\n        );\r\n        return uint8(value);\r\n    }\r\n\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(\r\n            value >= type(int128).min && value <= type(int128).max,\r\n            \"SafeCast: value doesn't fit in 128 bits\"\r\n        );\r\n        return int128(value);\r\n    }\r\n\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(\r\n            value >= type(int64).min && value <= type(int64).max,\r\n            \"SafeCast: value doesn't fit in 64 bits\"\r\n        );\r\n        return int64(value);\r\n    }\r\n\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(\r\n            value >= type(int32).min && value <= type(int32).max,\r\n            \"SafeCast: value doesn't fit in 32 bits\"\r\n        );\r\n        return int32(value);\r\n    }\r\n\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(\r\n            value >= type(int16).min && value <= type(int16).max,\r\n            \"SafeCast: value doesn't fit in 16 bits\"\r\n        );\r\n        return int16(value);\r\n    }\r\n\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(\r\n            value >= type(int8).min && value <= type(int8).max,\r\n            \"SafeCast: value doesn't fit in 8 bits\"\r\n        );\r\n        return int8(value);\r\n    }\r\n\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\r\n        require(\r\n            value <= uint256(type(int256).max),\r\n            \"SafeCast: value doesn't fit in an int256\"\r\n        );\r\n        return int256(value);\r\n    }\r\n}\r\n\r\nlibrary ECDSA {\r\n    enum RecoverError {\r\n        NoError,\r\n        InvalidSignature,\r\n        InvalidSignatureLength,\r\n        InvalidSignatureS,\r\n        InvalidSignatureV\r\n    }\r\n\r\n    function _throwError(RecoverError error) private pure {\r\n        if (error == RecoverError.NoError) {\r\n            return; // no error: do nothing\r\n        } else if (error == RecoverError.InvalidSignature) {\r\n            revert(\"ECDSA: invalid signature\");\r\n        } else if (error == RecoverError.InvalidSignatureLength) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        } else if (error == RecoverError.InvalidSignatureS) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        } else if (error == RecoverError.InvalidSignatureV) {\r\n            revert(\"ECDSA: invalid signature 'v' value\");\r\n        }\r\n    }\r\n\r\n    function tryRecover(bytes32 hash, bytes memory signature)\r\n        internal\r\n        pure\r\n        returns (address, RecoverError)\r\n    {\r\n        // Check the signature length\r\n        // - case 65: r,s,v signature (standard)\r\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\r\n        if (signature.length == 65) {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n            return tryRecover(hash, v, r, s);\r\n        } else if (signature.length == 64) {\r\n            bytes32 r;\r\n            bytes32 vs;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                vs := mload(add(signature, 0x40))\r\n            }\r\n            return tryRecover(hash, r, vs);\r\n        } else {\r\n            return (address(0), RecoverError.InvalidSignatureLength);\r\n        }\r\n    }\r\n\r\n    function recover(bytes32 hash, bytes memory signature)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address, RecoverError) {\r\n        bytes32 s;\r\n        uint8 v;\r\n        assembly {\r\n            s := and(\r\n                vs,\r\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n            )\r\n            v := add(shr(255, vs), 27)\r\n        }\r\n        return tryRecover(hash, v, r, s);\r\n    }\r\n\r\n    function recover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address, RecoverError) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (\r\n            uint256(s) >\r\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\r\n        ) {\r\n            return (address(0), RecoverError.InvalidSignatureS);\r\n        }\r\n        if (v != 27 && v != 28) {\r\n            return (address(0), RecoverError.InvalidSignatureV);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return (address(0), RecoverError.InvalidSignature);\r\n        }\r\n\r\n        return (signer, RecoverError.NoError);\r\n    }\r\n\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    function toEthSignedMessageHash(bytes32 hash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n            );\r\n    }\r\n\r\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\r\n            );\r\n    }\r\n}\r\n\r\nabstract contract EIP712 {\r\n    /* solhint-disable var-name-mixedcase */\r\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\r\n    // invalidate the cached domain separator if the chain id changes.\r\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\r\n    uint256 private immutable _CACHED_CHAIN_ID;\r\n\r\n    bytes32 private immutable _HASHED_NAME;\r\n    bytes32 private immutable _HASHED_VERSION;\r\n    bytes32 private immutable _TYPE_HASH;\r\n\r\n    /* solhint-enable var-name-mixedcase */\r\n\r\n    constructor(string memory name, string memory version) {\r\n        bytes32 hashedName = keccak256(bytes(name));\r\n        bytes32 hashedVersion = keccak256(bytes(version));\r\n        bytes32 typeHash = keccak256(\r\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n        );\r\n        _HASHED_NAME = hashedName;\r\n        _HASHED_VERSION = hashedVersion;\r\n        _CACHED_CHAIN_ID = block.chainid;\r\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(\r\n            typeHash,\r\n            hashedName,\r\n            hashedVersion\r\n        );\r\n        _TYPE_HASH = typeHash;\r\n    }\r\n\r\n    function _domainSeparatorV4() internal view returns (bytes32) {\r\n        if (block.chainid == _CACHED_CHAIN_ID) {\r\n            return _CACHED_DOMAIN_SEPARATOR;\r\n        } else {\r\n            return\r\n                _buildDomainSeparator(\r\n                    _TYPE_HASH,\r\n                    _HASHED_NAME,\r\n                    _HASHED_VERSION\r\n                );\r\n        }\r\n    }\r\n\r\n    function _buildDomainSeparator(\r\n        bytes32 typeHash,\r\n        bytes32 nameHash,\r\n        bytes32 versionHash\r\n    ) private view returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    typeHash,\r\n                    nameHash,\r\n                    versionHash,\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    function _hashTypedDataV4(bytes32 structHash)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bytes32)\r\n    {\r\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionDelegateCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level delegate call failed\"\r\n            );\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\nlibrary Timers {\r\n    struct Timestamp {\r\n        uint64 _deadline;\r\n    }\r\n\r\n    function getDeadline(Timestamp memory timer)\r\n        internal\r\n        pure\r\n        returns (uint64)\r\n    {\r\n        return timer._deadline;\r\n    }\r\n\r\n    function setDeadline(Timestamp storage timer, uint64 timestamp) internal {\r\n        timer._deadline = timestamp;\r\n    }\r\n\r\n    function reset(Timestamp storage timer) internal {\r\n        timer._deadline = 0;\r\n    }\r\n\r\n    function isUnset(Timestamp memory timer) internal pure returns (bool) {\r\n        return timer._deadline == 0;\r\n    }\r\n\r\n    function isStarted(Timestamp memory timer) internal pure returns (bool) {\r\n        return timer._deadline > 0;\r\n    }\r\n\r\n    function isPending(Timestamp memory timer) internal view returns (bool) {\r\n        return timer._deadline > block.timestamp;\r\n    }\r\n\r\n    function isExpired(Timestamp memory timer) internal view returns (bool) {\r\n        return isStarted(timer) && timer._deadline <= block.timestamp;\r\n    }\r\n\r\n    struct BlockNumber {\r\n        uint64 _deadline;\r\n    }\r\n\r\n    function getDeadline(BlockNumber memory timer)\r\n        internal\r\n        pure\r\n        returns (uint64)\r\n    {\r\n        return timer._deadline;\r\n    }\r\n\r\n    function setDeadline(BlockNumber storage timer, uint64 timestamp) internal {\r\n        timer._deadline = timestamp;\r\n    }\r\n\r\n    function reset(BlockNumber storage timer) internal {\r\n        timer._deadline = 0;\r\n    }\r\n\r\n    function isUnset(BlockNumber memory timer) internal pure returns (bool) {\r\n        return timer._deadline == 0;\r\n    }\r\n\r\n    function isStarted(BlockNumber memory timer) internal pure returns (bool) {\r\n        return timer._deadline > 0;\r\n    }\r\n\r\n    function isPending(BlockNumber memory timer) internal view returns (bool) {\r\n        return timer._deadline > block.number;\r\n    }\r\n\r\n    function isExpired(BlockNumber memory timer) internal view returns (bool) {\r\n        return isStarted(timer) && timer._deadline <= block.number;\r\n    }\r\n}\r\n\r\nabstract contract IGovernor is IERC165 {\r\n    enum ProposalState {\r\n        Pending,\r\n        Active,\r\n        Canceled,\r\n        Defeated,\r\n        Succeeded,\r\n        Queued,\r\n        Expired,\r\n        Executed\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when a proposal is created.\r\n     */\r\n    event ProposalCreated(\r\n        uint256 proposalId,\r\n        address proposer,\r\n        address[] targets,\r\n        uint256[] values,\r\n        string[] signatures,\r\n        bytes[] calldatas,\r\n        uint256 startBlock,\r\n        uint256 endBlock,\r\n        string description\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when a proposal is canceled.\r\n     */\r\n    event ProposalCanceled(uint256 proposalId);\r\n\r\n    /**\r\n     * @dev Emitted when a proposal is executed.\r\n     */\r\n    event ProposalExecuted(uint256 proposalId);\r\n\r\n    /**\r\n     * @dev Emitted when a vote is cast.\r\n     *\r\n     * Note: `support` values should be seen as buckets. There interpretation depends on the voting module used.\r\n     */\r\n    event VoteCast(\r\n        address indexed voter,\r\n        uint256 proposalId,\r\n        uint8 support,\r\n        uint256 weight,\r\n        string reason\r\n    );\r\n\r\n    event Shout(string mouthVomit);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\r\n     */\r\n    function name() public view virtual returns (string memory);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\"\r\n     */\r\n    function version() public view virtual returns (string memory);\r\n\r\n    /**\r\n     * @notice module:voting\r\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\r\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\r\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\r\n     *\r\n     * There are 2 standard keys: `support` and `quorum`.\r\n     *\r\n     * - `support=bravo` refers to the vote options 0 = For, 1 = Against, 2 = Abstain, as in `GovernorBravo`.\r\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\r\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\r\n     *\r\n     * NOTE: The string can be decoded by the standard\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\r\n     * JavaScript class.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function COUNTING_MODE() public pure virtual returns (string memory);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\r\n     */\r\n    function hashProposal(\r\n        address[] calldata targets,\r\n        uint256[] calldata values,\r\n        bytes[] calldata calldatas,\r\n        bytes32 descriptionHash\r\n    ) public pure virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev Current state of a proposal, following Compound's convention\r\n     */\r\n    function state(uint256 proposalId)\r\n        public\r\n        view\r\n        virtual\r\n        returns (ProposalState);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev block number used to retrieve user's votes and quorum.\r\n     */\r\n    function proposalSnapshot(uint256 proposalId)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev timestamp at which votes close.\r\n     */\r\n    function proposalDeadline(uint256 proposalId)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice module:user-config\r\n     * @dev delay, in number of block, between the proposal is created and the vote starts. This can be increassed to\r\n     * leave time for users to buy voting power, of delegate it, before the voting of a proposal starts.\r\n     */\r\n    function votingDelay() public view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice module:user-config\r\n     * @dev delay, in number of blocks, between the vote start and vote ends.\r\n     *\r\n     * Note: the {votingDelay} can delay the start of the vote. This must be considered when setting the voting\r\n     * duration compared to the voting delay.\r\n     */\r\n    function votingPeriod() public view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice module:user-config\r\n     * @dev Minimum number of cast voted required for a proposal to be successful.\r\n     *\r\n     * Note: The `blockNumber` parameter corresponds to the snaphot used for counting vote. This allows to scale the\r\n     * quroum depending on values such as the totalSupply of a token at this block (see {ERC20Votes}).\r\n     */\r\n    function quorum(uint256 blockNumber) public view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice module:reputation\r\n     * @dev Voting power of an `account` at a specific `blockNumber`.\r\n     *\r\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\r\n     * multiple), {ERC20Votes} tokens.\r\n     */\r\n    function getVotes(address account, uint256 blockNumber)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice module:voting\r\n     * @dev Returns weither `account` has cast a vote on `proposalId`.\r\n     */\r\n    function hasVoted(uint256 proposalId, address account)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Create a new proposal. Vote start {IGovernor-votingDelay} blocks after the proposal is created and ends\r\n     * {IGovernor-votingPeriod} blocks after the voting starts.\r\n     *\r\n     * Emits a {ProposalCreated} event.\r\n     */\r\n    function propose(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        string memory description\r\n    ) public virtual returns (uint256 proposalId);\r\n\r\n    /**\r\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\r\n     * deadline to be reached.\r\n     *\r\n     * Emits a {ProposalExecuted} event.\r\n     *\r\n     * Note: some module can modify the requirements for execution, for example by adding an additional timelock.\r\n     */\r\n    function execute(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        bytes32 descriptionHash\r\n    ) public payable virtual returns (uint256 proposalId);\r\n\r\n    /**\r\n     * @dev Cast a vote\r\n     *\r\n     * Emits a {VoteCast} event.\r\n     */\r\n    function castVote(uint256 proposalId, uint8 support)\r\n        public\r\n        virtual\r\n        returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Cast a with a reason\r\n     *\r\n     * Emits a {VoteCast} event.\r\n     */\r\n    function castVoteWithReason(\r\n        uint256 proposalId,\r\n        uint8 support,\r\n        string calldata reason\r\n    ) public virtual returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Cast a vote using the user cryptographic signature.\r\n     *\r\n     * Emits a {VoteCast} event.\r\n     */\r\n    function castVoteBySig(\r\n        uint256 proposalId,\r\n        uint8 support,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual returns (uint256 balance);\r\n}\r\n\r\ninterface IWorldOfWhiteDudes {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function maxSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index)\r\n        external\r\n        view\r\n        returns (uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n\r\n    function walletOfOwner(address owner)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n}\r\n\r\nabstract contract BoolPacker {\r\n    function getBoolean(uint256 _packedBools, uint256 _boolNumber)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint256 flag = (_packedBools >> _boolNumber) & uint256(1);\r\n        return (flag == 1 ? true : false);\r\n    }\r\n\r\n    function setBoolean(\r\n        uint256 _packedBools,\r\n        uint256 _boolNumber,\r\n        bool _value\r\n    ) internal pure returns (uint256) {\r\n        if (_value) return _packedBools | (uint256(1) << _boolNumber);\r\n        else return _packedBools & ~(uint256(1) << _boolNumber);\r\n    }\r\n}\r\n\r\nabstract contract Governor is Ownable, ERC165, EIP712, IGovernor, BoolPacker {\r\n    using SafeCast for uint256;\r\n    using Timers for Timers.BlockNumber;\r\n\r\n    IWorldOfWhiteDudes public immutable token =\r\n        IWorldOfWhiteDudes(0xD00D1e06a2680E02919f4F5c5EC5dC45d67bB0b5);\r\n    bytes32 public constant BALLOT_TYPEHASH =\r\n        keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\r\n\r\n    struct ProposalVote {\r\n        Timers.BlockNumber voteStart;\r\n        Timers.BlockNumber voteEnd;\r\n        bool executed;\r\n        bool canceled;\r\n        uint16 againstVotes;\r\n        uint16 forVotes;\r\n        uint16 abstainVotes;\r\n        uint16 maxVotes;\r\n        //mapping(address => uint16) voteCount;\r\n        //mapping(uint256 => bool) tokenHasVoted;\r\n        //uint8[10000] tokenHasVoted;\r\n        uint256[40] tokenHasVoted;\r\n    }\r\n\r\n    function getTokenHasVoted(uint256 proposalId, uint256 tokenId)\r\n        public\r\n        view\r\n        returns (bool hasTokenVoted)\r\n    {\r\n        ProposalVote storage proposalvote = _proposals[proposalId];\r\n        return\r\n            getBoolean(proposalvote.tokenHasVoted[tokenId / 40], tokenId % 256);\r\n    }\r\n\r\n    string private _name;\r\n\r\n    uint256 public totalProposals;\r\n    mapping(uint256 => uint256) public proposalIndexes;\r\n\r\n    mapping(uint256 => string) public proposalTitles;\r\n    mapping(uint256 => ProposalVote) internal _proposals;\r\n\r\n    /**\r\n     * @dev Restrict access to governor executing address. Some module might override the _executor function to make\r\n     * sure this modifier is consistant with the execution model.\r\n     */\r\n    modifier onlyGovernance() {\r\n        require(_msgSender() == _executor(), \"Governor: onlyGovernance\");\r\n        _;\r\n    }\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status = _NOT_ENTERED;\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the value for {name} and {version}\r\n     */\r\n    constructor(string memory name_) EIP712(name_, version()) {\r\n        _name = name_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(IERC165, ERC165)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IGovernor).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-version}.\r\n     */\r\n    function version() public view virtual override returns (string memory) {\r\n        return \"1\";\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-hashProposal}.\r\n     *\r\n     * The proposal id is produced by hashing the RLC encoded `targets` array, the `values` array, the `calldatas` array\r\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\r\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\r\n     * advance, before the proposal is submitted.\r\n     *\r\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\r\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\r\n     * accross multiple networks. This also means that in order to execute the same operation twice (on the same\r\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\r\n     */\r\n    function hashProposal(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        bytes32 descriptionHash\r\n    ) public pure virtual override returns (uint256) {\r\n        return\r\n            uint256(\r\n                keccak256(\r\n                    abi.encode(targets, values, calldatas, descriptionHash)\r\n                )\r\n            );\r\n    }\r\n\r\n    function state(uint256 proposalId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (ProposalState)\r\n    {\r\n        ProposalVote storage proposal = _proposals[proposalId];\r\n\r\n        if (proposal.executed) {\r\n            return ProposalState.Executed;\r\n        } else if (proposal.canceled) {\r\n            return ProposalState.Canceled;\r\n        } else if (proposal.voteStart.isPending()) {\r\n            return ProposalState.Pending;\r\n        } else if (proposal.voteEnd.isPending()) {\r\n            return ProposalState.Active;\r\n        } else if (proposal.voteEnd.isExpired()) {\r\n            return\r\n                _quorumReached(proposalId) && _voteSucceeded(proposalId)\r\n                    ? ProposalState.Succeeded\r\n                    : ProposalState.Defeated;\r\n        } else {\r\n            revert(\"Governor: unknown proposal id\");\r\n        }\r\n    }\r\n\r\n    function proposalSnapshot(uint256 proposalId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _proposals[proposalId].voteStart.getDeadline();\r\n    }\r\n\r\n    function proposalDeadline(uint256 proposalId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _proposals[proposalId].voteEnd.getDeadline();\r\n    }\r\n\r\n    /**\r\n     * @dev Amount of votes already cast passes the threshold limit.\r\n     */\r\n    function _quorumReached(uint256 proposalId)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Is the proposal successful or not.\r\n     */\r\n    function _voteSucceeded(uint256 proposalId)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool);\r\n\r\n    function _countVote(\r\n        uint256 proposalId,\r\n        address account,\r\n        uint8 support\r\n    ) internal virtual returns (uint16);\r\n\r\n    function propose(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        string memory description\r\n    ) public virtual override returns (uint256) {\r\n        string memory blank;\r\n        return NewPropose(targets, values, calldatas, blank, description);\r\n    }\r\n\r\n    function NewPropose(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        string memory title,\r\n        string memory description\r\n    ) public virtual returns (uint256) {\r\n        uint256 proposalId = hashProposal(\r\n            targets,\r\n            values,\r\n            calldatas,\r\n            keccak256(bytes(description))\r\n        );\r\n        require(\r\n            targets.length == values.length,\r\n            \"Governor: invalid proposal length\"\r\n        );\r\n        require(\r\n            targets.length == calldatas.length,\r\n            \"Governor: invalid proposal length\"\r\n        );\r\n        require(targets.length > 0, \"Governor: empty proposal\");\r\n        ProposalVote storage proposal = _proposals[proposalId];\r\n        require(\r\n            proposal.voteStart.isUnset(),\r\n            \"Governor: proposal already exists\"\r\n        );\r\n\r\n        uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();\r\n        uint64 deadline = snapshot + votingPeriod().toUint64();\r\n\r\n        proposal.voteStart.setDeadline(snapshot);\r\n        proposal.voteEnd.setDeadline(deadline);\r\n        proposal.maxVotes = uint16(token.totalSupply());\r\n        proposalIndexes[totalProposals] = proposalId;\r\n        proposalTitles[proposalId] = title;\r\n        totalProposals += 1;\r\n\r\n        emit ProposalCreated(\r\n            proposalId,\r\n            _msgSender(),\r\n            targets,\r\n            values,\r\n            new string[](targets.length),\r\n            calldatas,\r\n            snapshot,\r\n            deadline,\r\n            description\r\n        );\r\n\r\n        return proposalId;\r\n    }\r\n\r\n    function execute(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        bytes32 descriptionHash\r\n    ) public payable virtual override nonReentrant returns (uint256) {\r\n        uint256 proposalId = hashProposal(\r\n            targets,\r\n            values,\r\n            calldatas,\r\n            descriptionHash\r\n        );\r\n        ProposalState status = state(proposalId);\r\n        require(\r\n            status == ProposalState.Succeeded || status == ProposalState.Queued,\r\n            \"Governor: proposal not successful\"\r\n        );\r\n        _proposals[proposalId].executed = true;\r\n        emit ProposalExecuted(proposalId);\r\n        _execute(proposalId, targets, values, calldatas, descriptionHash);\r\n        return proposalId;\r\n    }\r\n\r\n    function _execute(\r\n        uint256, /* proposalId */\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        bytes32 /*descriptionHash*/\r\n    ) internal virtual {\r\n        string memory errorMessage = \"Governor: call reverted without message\";\r\n        for (uint256 i = 0; i < targets.length; ++i) {\r\n            (bool success, bytes memory returndata) = targets[i].call{\r\n                value: values[i]\r\n            }(calldatas[i]);\r\n            Address._verifyCallResult(success, returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal cancel mechanism: locks up the proposal timer, preventing it from being re-submitted. Marks it as\r\n     * canceled to allow distinguishing it from executed proposals.\r\n     *\r\n     * Emits a {IGovernor-ProposalCanceled} event.\r\n     */\r\n    function _cancel(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        bytes32 descriptionHash\r\n    ) internal virtual returns (uint256) {\r\n        uint256 proposalId = hashProposal(\r\n            targets,\r\n            values,\r\n            calldatas,\r\n            descriptionHash\r\n        );\r\n        ProposalState status = state(proposalId);\r\n\r\n        require(\r\n            status != ProposalState.Canceled &&\r\n                status != ProposalState.Expired &&\r\n                status != ProposalState.Executed,\r\n            \"Governor: proposal not active\"\r\n        );\r\n        _proposals[proposalId].canceled = true;\r\n\r\n        emit ProposalCanceled(proposalId);\r\n\r\n        return proposalId;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-castVote}.\r\n     */\r\n    function castVote(uint256 proposalId, uint8 support)\r\n        public\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        address voter = _msgSender();\r\n        return _castVote(proposalId, voter, support, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-castVoteWithReason}.\r\n     */\r\n    function castVoteWithReason(\r\n        uint256 proposalId,\r\n        uint8 support,\r\n        string calldata reason\r\n    ) public virtual override returns (uint256) {\r\n        address voter = _msgSender();\r\n        return _castVote(proposalId, voter, support, reason);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-castVoteBySig}.\r\n     */\r\n    function castVoteBySig(\r\n        uint256 proposalId,\r\n        uint8 support,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual override returns (uint256) {\r\n        address voter = ECDSA.recover(\r\n            _hashTypedDataV4(\r\n                keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))\r\n            ),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n        return _castVote(proposalId, voter, support, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\r\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\r\n     *\r\n     * Emits a {IGovernor-VoteCast} event.\r\n     */\r\n    function _castVote(\r\n        uint256 proposalId,\r\n        address account,\r\n        uint8 support,\r\n        string memory reason\r\n    ) internal virtual returns (uint256) {\r\n        require(\r\n            state(proposalId) == ProposalState.Active,\r\n            \"Governor: vote not currently active\"\r\n        );\r\n\r\n        uint256 weight = _countVote(proposalId, account, support);\r\n\r\n        emit VoteCast(account, proposalId, support, weight, reason);\r\n\r\n        return weight;\r\n    }\r\n\r\n    /**\r\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\r\n     * through another contract such as a timelock.\r\n     */\r\n    function _executor() internal view virtual returns (address) {\r\n        return address(this);\r\n    }\r\n}\r\n\r\nabstract contract GovernorProposalThreshold is Governor {\r\n    /**\r\n     * @dev See {IGovernor-propose}.\r\n     */\r\n    function propose(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        string memory description\r\n    ) public virtual override returns (uint256) {\r\n        require(\r\n            getVotes(msg.sender, block.number - 1) >= proposalThreshold(),\r\n            \"GovernorCompatibilityBravo: proposer votes below proposal threshold\"\r\n        );\r\n\r\n        return super.propose(targets, values, calldatas, description);\r\n    }\r\n\r\n    /**\r\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\r\n     */\r\n    function proposalThreshold() public view virtual returns (uint256);\r\n}\r\n\r\nabstract contract GovernorCountingSimple is Governor {\r\n    /**\r\n     * @dev Supported vote types. Matches Governor Bravo ordering.\r\n     */\r\n    enum VoteType {\r\n        Against,\r\n        For,\r\n        Abstain\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-COUNTING_MODE}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function COUNTING_MODE()\r\n        public\r\n        pure\r\n        virtual\r\n        override\r\n        returns (string memory)\r\n    {\r\n        return \"support=bravo&quorum=for,abstain\";\r\n    }\r\n\r\n    function getVotes(address account, uint256)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return token.balanceOf(account);\r\n    }\r\n\r\n    function votesLeft(uint256 proposalId, address account)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 voteAmount)\r\n    {\r\n        uint256 tokenCount = token.balanceOf(account);\r\n        uint256 tokenId;\r\n        ProposalVote storage proposalvote = _proposals[proposalId];\r\n        for (uint256 i = 0; i < tokenCount; i++) {\r\n            tokenId = token.tokenOfOwnerByIndex(account, i);\r\n            if (\r\n                !getTokenHasVoted(proposalId, tokenId) &&\r\n                //proposalvote.tokenHasVoted[tokenId] == 0 &&\r\n                tokenId < proposalvote.maxVotes\r\n            ) {\r\n                voteAmount += 1;\r\n            }\r\n        }\r\n        return voteAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-hasVoted}.\r\n     */\r\n    function hasVoted(uint256, address)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        require(false, \"Don't use this method\");\r\n        return false;\r\n        //return _proposals[proposalId].voteCount[account] > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Accessor to the internal vote counts.\r\n     */\r\n    function proposalVotes(uint256 proposalId)\r\n        public\r\n        view\r\n        virtual\r\n        returns (\r\n            uint256 againstVotes,\r\n            uint256 forVotes,\r\n            uint256 abstainVotes\r\n        )\r\n    {\r\n        ProposalVote storage proposalvote = _proposals[proposalId];\r\n        return (\r\n            proposalvote.againstVotes,\r\n            proposalvote.forVotes,\r\n            proposalvote.abstainVotes\r\n        );\r\n    }\r\n\r\n    function getProposal(uint256 proposalId)\r\n        public\r\n        view\r\n        virtual\r\n        returns (\r\n            string memory title,\r\n            string memory currentState,\r\n            uint256 againstVotes,\r\n            uint256 forVotes,\r\n            uint256 abstainVotes,\r\n            uint256 totalVotes,\r\n            uint256 currentQuorum,\r\n            uint256 minQuorum,\r\n            uint256 maxVotes\r\n        )\r\n    {\r\n        string[8] memory proposalStates;\r\n        proposalStates = [\r\n            \"Pending\",\r\n            \"Active\",\r\n            \"Canceled\",\r\n            \"Defeated\",\r\n            \"Succeeded\",\r\n            \"Queued\",\r\n            \"Expired\",\r\n            \"Executed\"\r\n        ];\r\n\r\n        ProposalVote storage proposalvote = _proposals[proposalId];\r\n        return (\r\n            proposalTitles[proposalId],\r\n            proposalStates[uint256(state(proposalId))],\r\n            proposalvote.againstVotes,\r\n            proposalvote.forVotes,\r\n            proposalvote.abstainVotes,\r\n            proposalvote.againstVotes +\r\n                proposalvote.forVotes +\r\n                proposalvote.abstainVotes,\r\n            proposalvote.forVotes + proposalvote.abstainVotes,\r\n            quorum(proposalvote.maxVotes),\r\n            proposalvote.maxVotes\r\n        );\r\n    }\r\n\r\n    /*\r\n    function getProposalAccountVotes(uint256 proposalId, address owner)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 ownerVoteCount)\r\n    {\r\n        ProposalVote storage proposalvote = _proposals[proposalId];\r\n        return (proposalvote.voteCount[owner]);\r\n    }\r\n*/\r\n    function hasTokenVoted(uint256 proposalId, uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bool tokenVoted)\r\n    {\r\n        //ProposalVote storage proposalvote = _proposals[proposalId];\r\n        //return (proposalvote.tokenHasVoted[tokenId] == 1);\r\n        return getTokenHasVoted(proposalId, tokenId);\r\n    }\r\n\r\n    function _quorumReached(uint256 proposalId)\r\n        internal\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        ProposalVote storage proposalvote = _proposals[proposalId];\r\n\r\n        return\r\n            quorum(_proposals[proposalId].maxVotes) <=\r\n            proposalvote.forVotes + proposalvote.abstainVotes;\r\n    }\r\n\r\n    function _voteSucceeded(uint256 proposalId)\r\n        internal\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        ProposalVote storage proposalvote = _proposals[proposalId];\r\n\r\n        return proposalvote.forVotes > proposalvote.againstVotes;\r\n    }\r\n\r\n    function _countVote(\r\n        uint256 proposalId,\r\n        address account,\r\n        uint8 support\r\n    ) internal virtual override returns (uint16 voteAmount) {\r\n        ProposalVote storage proposalvote = _proposals[proposalId];\r\n        uint256[40] storage vState = proposalvote.tokenHasVoted;\r\n        uint256[] memory tokens = token.walletOfOwner(account);\r\n        uint256 tokenId;\r\n        uint256 idxInt;\r\n        uint256 idxBool;\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            tokenId = tokens[i];\r\n            idxInt = tokenId / 40;\r\n            idxBool = tokenId % 256;\r\n            if (\r\n                ((vState[idxInt] >> idxBool) & uint256(1)) != 1 &&\r\n                tokenId < proposalvote.maxVotes\r\n            ) {\r\n                vState[idxInt] = vState[idxInt] | (uint256(1) << idxBool);\r\n                voteAmount += 1;\r\n            }\r\n        }\r\n        require(voteAmount > 0, \"GovernorVotingSimple: No votes left\");\r\n        if (support == uint8(VoteType.Against)) {\r\n            proposalvote.againstVotes += voteAmount;\r\n        } else if (support == uint8(VoteType.For)) {\r\n            proposalvote.forVotes += voteAmount;\r\n        } else if (support == uint8(VoteType.Abstain)) {\r\n            proposalvote.abstainVotes += voteAmount;\r\n        } else {\r\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract GovernorVotesQuorumFraction is Governor {\r\n    uint256 private _quorumNumerator;\r\n\r\n    event QuorumNumeratorUpdated(\r\n        uint256 oldQuorumNumerator,\r\n        uint256 newQuorumNumerator\r\n    );\r\n\r\n    constructor(uint256 quorumNumeratorValue) {\r\n        _updateQuorumNumerator(quorumNumeratorValue);\r\n    }\r\n\r\n    function quorumNumerator() public view virtual returns (uint256) {\r\n        return _quorumNumerator;\r\n    }\r\n\r\n    function quorumDenominator() public view virtual returns (uint256) {\r\n        return 100;\r\n    }\r\n\r\n    function quorum(uint256 totalVotes)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return (totalVotes * quorumNumerator()) / quorumDenominator();\r\n    }\r\n\r\n    function updateQuorumNumerator(uint256 newQuorumNumerator)\r\n        external\r\n        virtual\r\n        onlyGovernance\r\n    {\r\n        _updateQuorumNumerator(newQuorumNumerator);\r\n    }\r\n\r\n    function _updateQuorumNumerator(uint256 newQuorumNumerator)\r\n        internal\r\n        virtual\r\n    {\r\n        require(\r\n            newQuorumNumerator <= quorumDenominator(),\r\n            \"GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator\"\r\n        );\r\n\r\n        uint256 oldQuorumNumerator = _quorumNumerator;\r\n        _quorumNumerator = newQuorumNumerator;\r\n\r\n        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);\r\n    }\r\n}\r\n\r\ncontract WOWDGovernor is\r\n    Governor,\r\n    GovernorProposalThreshold,\r\n    GovernorCountingSimple,\r\n    GovernorVotesQuorumFraction\r\n{\r\n    uint256 private _votingPeriod = 90000; // Mainnet 90000 15 days, Testnet 1.5 9000\r\n    uint256 private _proposalThreshold = 11;\r\n\r\n    constructor() Governor(\"WOWDGovernor\") GovernorVotesQuorumFraction(18) {}\r\n\r\n    function votingDelay() public pure override returns (uint256) {\r\n        return 1; // 1 block\r\n    }\r\n\r\n    function votingPeriod() public view override returns (uint256) {\r\n        return _votingPeriod;\r\n    }\r\n\r\n    function setVotingPeriod(uint256 newPeriod) external onlyGovernance {\r\n        _votingPeriod = newPeriod;\r\n    }\r\n\r\n    function proposalThreshold() public view override returns (uint256) {\r\n        return _proposalThreshold;\r\n    }\r\n\r\n    function setProposalThreshold(uint256 newThreshhold)\r\n        external\r\n        onlyGovernance\r\n    {\r\n        _proposalThreshold = newThreshhold;\r\n    }\r\n\r\n    // The following functions are overrides required by Solidity.\r\n\r\n    function quorum(uint256 totalVotes)\r\n        public\r\n        view\r\n        override(IGovernor, GovernorVotesQuorumFraction)\r\n        returns (uint256)\r\n    {\r\n        return super.quorum(totalVotes);\r\n    }\r\n\r\n    function getVotes(address account, uint256 blockNumber)\r\n        public\r\n        view\r\n        override(IGovernor, GovernorCountingSimple)\r\n        returns (uint256)\r\n    {\r\n        return super.getVotes(account, blockNumber);\r\n    }\r\n\r\n    function shoutOut(string memory mouthVomit) external onlyGovernance {\r\n        emit Shout(mouthVomit);\r\n    }\r\n\r\n    function propose(\r\n        address[] memory targets,\r\n        uint256[] memory values,\r\n        bytes[] memory calldatas,\r\n        string memory description\r\n    ) public override(Governor, GovernorProposalThreshold) returns (uint256) {\r\n        return super.propose(targets, values, calldatas, description);\r\n    }\r\n\r\n    function proposeShout(string memory title, string memory description)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return _proShout(title, description, 0);\r\n    }\r\n\r\n    function executeShout(string memory title, string memory description)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return _proShout(title, description, 1);\r\n    }\r\n\r\n    function _proShout(\r\n        string memory title,\r\n        string memory description,\r\n        uint256 exec\r\n    ) internal returns (uint256) {\r\n        bytes[] memory payload = new bytes[](1);\r\n        payload[0] = abi.encodeWithSignature(\"shoutOut(string)\", description);\r\n        address[] memory targets = new address[](1);\r\n        targets[0] = address(this);\r\n        uint256[] memory values = new uint256[](1);\r\n        values[0] = 0;\r\n        if (exec == 1) {\r\n            return\r\n                execute(\r\n                    targets,\r\n                    values,\r\n                    payload,\r\n                    keccak256(bytes(description))\r\n                );\r\n        }\r\n        return NewPropose(targets, values, payload, title, description);\r\n    }\r\n\r\n    function proposeNominate(\r\n        string memory title,\r\n        address recipient,\r\n        uint256 amountWei,\r\n        string memory description\r\n    ) public returns (uint256) {\r\n        return _proNominate(title, recipient, amountWei, description, 0);\r\n    }\r\n\r\n    function executeNominate(\r\n        string memory title,\r\n        address recipient,\r\n        uint256 amountWei,\r\n        string memory description\r\n    ) public returns (uint256) {\r\n        return _proNominate(title, recipient, amountWei, description, 1);\r\n    }\r\n\r\n    function _proNominate(\r\n        string memory title,\r\n        address recipient,\r\n        uint256 amountWei,\r\n        string memory description,\r\n        uint256 exec\r\n    ) private returns (uint256) {\r\n        bytes[] memory payload = new bytes[](1);\r\n        address[] memory targets = new address[](1);\r\n        targets[0] = payable(recipient);\r\n        uint256[] memory values = new uint256[](1);\r\n        values[0] = amountWei;\r\n        if (exec == 1) {\r\n            return\r\n                execute(\r\n                    targets,\r\n                    values,\r\n                    payload,\r\n                    keccak256(bytes(description))\r\n                );\r\n        }\r\n        return NewPropose(targets, values, payload, title, description);\r\n    }\r\n\r\n    function deposit() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    receive() external payable {}\r\n}\r\n"}}}