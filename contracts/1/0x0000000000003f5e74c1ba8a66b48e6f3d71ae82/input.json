{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/myswap_combo.sol":{"content":"pragma solidity =0.6.6;\r\n\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\ncontract MyRouter {\r\n    uint256 private constant CHISTART_MASK =  0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00;\r\n    uint256 private constant ISUNISWAP_MASK = 0x000000000000000000000000000000000000000000000000000000000000000f;\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    modifier onlyTrader {\r\n        require((msg.sender == 0x19aBe4496214Df53bd60BF05385c2bc28e87A090) || (msg.sender == 0x1Afa018d9Be65B0Eac856340d919c4526C168FF8) || (msg.sender == 0xd05aE1dA4f202d82F165F6b0291E6bE4668B39B8) || (msg.sender == 0x44A5d8240174F7164FF963D9062CdF1148410459), \"not trader\");\r\n        _;\r\n    }\r\n    \r\n\r\n    constructor() public{\r\n    }\r\n    \r\n    function withdrawETH() public onlyTrader{\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n    \r\n    function withdrawToken(address tokenAddress, uint amount) public onlyTrader{\r\n        TransferHelper.safeTransfer(tokenAddress, msg.sender, amount);\r\n    }\r\n    \r\n    function withdrawTokens(address[] memory path) public onlyTrader{\r\n        for (uint i; i < path.length; i++) {\r\n            IERC20 token = IERC20(path[i]);\r\n            uint256 currentTokenBalance = token.balanceOf(address(this));\r\n            TransferHelper.safeTransfer(path[i], msg.sender, currentTokenBalance);\r\n        }\r\n    }\r\n\r\n    function swap25927504(\r\n        uint amount,\r\n        uint tokenMax,\r\n        uint amountMin,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint data\r\n    ) public onlyTrader {\r\n        uint256 gasStart = gasleft();\r\n        uint256 chiStart = (data & CHISTART_MASK) >> 8;\r\n        uint256 isUniswap = data & ISUNISWAP_MASK;\r\n        address pairOwner;\r\n        if (isUniswap==1) {\r\n            pairOwner = pairFor_sushi(tokenA, tokenB);\r\n        } else {\r\n            pairOwner = pairFor_uni(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, pairOwner);\r\n        if (tokenMax > amountMin + reserveA) {\r\n            if (tokenMax - reserveA>amount) {\r\n                swapExactTokensForTokens(\r\n                    amount,\r\n                    tokenA,\r\n                    tokenB,\r\n                    reserveA,\r\n                    reserveB,\r\n                    pairOwner\r\n                );\r\n            } else {\r\n                swapExactTokensForTokens(\r\n                    tokenMax - reserveA,\r\n                    tokenA,\r\n                    tokenB,\r\n                    reserveA,\r\n                    reserveB,\r\n                    pairOwner\r\n                );\r\n            }\r\n        }\r\n        if (chiStart>0) {\r\n            uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\r\n            free( (gasSpent + 14154) / 41130, chiStart);\r\n        }\r\n        \r\n    }\r\n    \r\n    function swap26309536(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountIn,\r\n        uint amountOut,\r\n        uint data\r\n    ) public onlyTrader{\r\n        uint256 gasStart = gasleft();\r\n        uint256 chiStart = (data & CHISTART_MASK) >> 8;\r\n        uint256 isUniswap = data & ISUNISWAP_MASK;\r\n        address pairOwner;\r\n        if (isUniswap==1) {\r\n            pairOwner = pairFor_sushi(tokenA, tokenB);\r\n        } else {\r\n            pairOwner = pairFor_uni(tokenA, tokenB);\r\n        }\r\n        TransferHelper.safeTransfer(\r\n            tokenA, pairOwner, amountIn\r\n            );\r\n        _swap(amountOut, tokenA, tokenB, pairOwner);\r\n        if (chiStart>0) {\r\n            uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\r\n            free( (gasSpent + 14154) / 41130, chiStart);\r\n        }\r\n    }\r\n    \r\n    function swapBackAll23252139(\r\n        uint token0Max,\r\n        address tokenA,\r\n        address tokenB,\r\n        bool isUniswap\r\n    ) public onlyTrader {\r\n        IERC20 tokenERC20 = IERC20(tokenA);\r\n        uint myToken = tokenERC20.balanceOf(address(this));\r\n        require(myToken>0);\r\n        address pairOwner;\r\n        if (isUniswap) {\r\n            pairOwner = pairFor_sushi(tokenA, tokenB);\r\n        } else {\r\n            pairOwner = pairFor_uni(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, pairOwner);\r\n        require(reserveA<=token0Max);\r\n        swapExactTokensForTokens(\r\n                myToken-1,\r\n                tokenA,\r\n                tokenB,\r\n                reserveA,\r\n                reserveB,\r\n                pairOwner\r\n            );\r\n    }\r\n    \r\n    function swapBackAllFee19870645(\r\n        uint token0Max,\r\n        address tokenA,\r\n        address tokenB,\r\n        bool isUniswap\r\n    ) public onlyTrader {\r\n        IERC20 tokenERC20 = IERC20(tokenA);\r\n        uint myToken = tokenERC20.balanceOf(address(this));\r\n        require(myToken>0);\r\n        address pairOwner;\r\n        if (isUniswap) {\r\n            pairOwner = pairFor_sushi(tokenA, tokenB);\r\n        } else {\r\n            pairOwner = pairFor_uni(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, pairOwner);\r\n        require(reserveA<=token0Max);\r\n        TransferHelper.safeTransfer(\r\n            tokenA, pairOwner, myToken-1\r\n            );\r\n        myToken = tokenERC20.balanceOf(pairOwner) - reserveA;\r\n        uint amountOut = getAmountOut(myToken, reserveA, reserveB);\r\n        _swap(amountOut, tokenA, tokenB, pairOwner);\r\n        \r\n        \r\n    }\r\n    \r\n    \r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n    \r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint amountOut, address tokenA, address tokenB, address pairOwner) internal virtual {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint amount0Out, uint amount1Out) = tokenA == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n        IUniswapV2Pair(pairOwner).swap(\r\n            amount0Out, amount1Out, address(this), new bytes(0)\r\n        );\r\n    }\r\n    \r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint reserveA,\r\n        uint reserveB,\r\n        address pairOwner\r\n    ) internal virtual returns (uint amountOut) {\r\n        amountOut = getAmountOut(amountIn, reserveA, reserveB);\r\n        TransferHelper.safeTransfer(\r\n            tokenA, pairOwner, amountIn\r\n            );\r\n        _swap(amountOut, tokenA, tokenB, pairOwner);\r\n    }\r\n    \r\n\r\n    function getReserves(address tokenA, address tokenB, address pairOwner) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairOwner).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n    \r\n    function pairFor_uni(address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\r\n            ))));\r\n    }\r\n    \r\n    function pairFor_sushi(address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\r\n            ))));\r\n    }\r\n    \r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n    \r\n    function checkFees(\r\n                address tokenA,\r\n                address tokenB,\r\n                uint mytokenIn,\r\n                uint saveAmount,\r\n                bool isUniswap\r\n                ) public onlyTrader returns (uint amountOut, uint amountOut_) {\r\n        IERC20 tokenOutERC20 = IERC20(tokenB);\r\n        uint myTokenOut = tokenOutERC20.balanceOf(address(this));\r\n        address pairOwner;\r\n        if (isUniswap) {\r\n            pairOwner = pairFor_sushi(tokenA, tokenB);\r\n        } else {\r\n            pairOwner = pairFor_uni(tokenA, tokenB);\r\n        }\r\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, pairOwner);\r\n        amountOut = getAmountOut(mytokenIn, reserveA, reserveB);\r\n        TransferHelper.safeTransfer(\r\n            tokenA, pairOwner, mytokenIn\r\n            );\r\n        _swap(amountOut, tokenA, tokenB, pairOwner); \r\n        uint mytokenOut_ = tokenOutERC20.balanceOf(address(this));\r\n        amountOut = mytokenOut_.sub(myTokenOut);\r\n        reserveB = tokenOutERC20.balanceOf(pairOwner);\r\n        TransferHelper.safeTransfer(\r\n            tokenB, pairOwner, mytokenOut_ - saveAmount\r\n            );\r\n        amountOut_ = tokenOutERC20.balanceOf(pairOwner).sub(reserveB);\r\n    }\r\n    \r\n    \r\n     function mint(uint256 value, uint256 offset) public {\r\n        assembly {\r\n            mstore(0, 0x746d3f5e74c1ba8a66b48e6f3d71ae823318585733ff6000526015600bf30000)\r\n\r\n            for {let i := div(value, 32)} i {i := sub(i, 1)} {\r\n                pop(create2(0, 0, 30, add(offset, 0))) pop(create2(0, 0, 30, add(offset, 1)))\r\n                pop(create2(0, 0, 30, add(offset, 2))) pop(create2(0, 0, 30, add(offset, 3)))\r\n                pop(create2(0, 0, 30, add(offset, 4))) pop(create2(0, 0, 30, add(offset, 5)))\r\n                pop(create2(0, 0, 30, add(offset, 6))) pop(create2(0, 0, 30, add(offset, 7)))\r\n                pop(create2(0, 0, 30, add(offset, 8))) pop(create2(0, 0, 30, add(offset, 9)))\r\n                pop(create2(0, 0, 30, add(offset, 10))) pop(create2(0, 0, 30, add(offset, 11)))\r\n                pop(create2(0, 0, 30, add(offset, 12))) pop(create2(0, 0, 30, add(offset, 13)))\r\n                pop(create2(0, 0, 30, add(offset, 14))) pop(create2(0, 0, 30, add(offset, 15)))\r\n                pop(create2(0, 0, 30, add(offset, 16))) pop(create2(0, 0, 30, add(offset, 17)))\r\n                pop(create2(0, 0, 30, add(offset, 18))) pop(create2(0, 0, 30, add(offset, 19)))\r\n                pop(create2(0, 0, 30, add(offset, 20))) pop(create2(0, 0, 30, add(offset, 21)))\r\n                pop(create2(0, 0, 30, add(offset, 22))) pop(create2(0, 0, 30, add(offset, 23)))\r\n                pop(create2(0, 0, 30, add(offset, 24))) pop(create2(0, 0, 30, add(offset, 25)))\r\n                pop(create2(0, 0, 30, add(offset, 26))) pop(create2(0, 0, 30, add(offset, 27)))\r\n                pop(create2(0, 0, 30, add(offset, 28))) pop(create2(0, 0, 30, add(offset, 29)))\r\n                pop(create2(0, 0, 30, add(offset, 30))) pop(create2(0, 0, 30, add(offset, 31)))\r\n                offset := add(offset, 32)\r\n            }\r\n\r\n            for {let i := and(value, 0x1F)} i {i := sub(i, 1)} {\r\n                pop(create2(0, 0, 30, offset))\r\n                offset := add(offset, 1)\r\n            }\r\n        }\r\n    }\r\n    \r\n    function computeAddress2(uint256 salt) public view returns (address) {\r\n        bytes32 _data = keccak256(\r\n            abi.encodePacked(bytes1(0xff), address(this), salt, bytes32(0x5b4bb3ff53a436ef8d04ab52b47429cdf7ee781c13d128731a063e7571294ce0))\r\n        );\r\n        return address(uint256(_data));\r\n    }\r\n\r\n    function free(uint256 value, uint256 chiStart) internal {\r\n        for (uint256 i = 0; i < value; i++) {\r\n            computeAddress2(chiStart + i).call(\"\");\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function contractExists(address contr) public view returns (bool) {\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(contr)\r\n        }\r\n        return size > 0;\r\n    }\r\n    \r\n    function selfd() public onlyTrader {\r\n        selfdestruct(msg.sender);\r\n    }\r\n        \r\n}\r\n\r\n\r\n"}}}