{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ERC20Interface.sol":{"content":"  pragma solidity ^0.4.18;\r\n\r\n// ----------------------------------------------------------------------------------------------\r\n// Sample fixed supply token contract\r\n// Enjoy. (c) BokkyPooBah 2017. The MIT Licence.\r\n// ----------------------------------------------------------------------------------------------\r\n\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20Interface {\r\n    // Get the total token supply\r\n    function totalSupply() public constant returns (uint256);\r\n\r\n    // Get the account balance of another account with address _owner\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    // Send _value amount of tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    // this function is required for some DEX functionality\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    // Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    // Triggered when tokens are transferred.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.4.18;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"},"keeper.sol":{"content":"pragma solidity ^0.4.18;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './ERC20Interface.sol';\r\nimport './SafeMath.sol';\r\n\r\ninterface keeperv1 {\r\n    function worked(address _job_contarct) external;\r\n    function isValid(address _job_contarct , address _keeper) view external returns(bool);\r\n}\r\n\r\ninterface JobContract {\r\n    function work() external;\r\n}\r\n\r\ncontract Keeper is keeperv1 {\r\n    \r\n    uint256 job_count = 0;\r\n    \r\n    uint256 max_token = 10000000000000000000;\r\n    \r\n    address manager;\r\n    \r\n    ERC20Interface token = ERC20Interface(0x02d7b659389d537912B313611cBC5a7F7Ed615A9);\r\n    \r\n    mapping(address => uint256) owner_job_count;\r\n    \r\n    mapping (uint256 => Job) jobs;\r\n\r\n    mapping (address => uint256) balance;\r\n    \r\n    //first address is job address and second one is keeper address\r\n    mapping (address => mapping(uint256 => address)) keeper;\r\n    //first address is job address and second one is last index\r\n    mapping (address => uint256) keeper_index;\r\n    \r\n    //first address is keeper address and second one is job address\r\n    mapping (address =>  mapping(address => uint256)) jobs_bonde;\r\n    \r\n    mapping (address => uint256) completed_work_count;\r\n\r\n    ////////////////\r\n    ///improvment///\r\n    ///////////////\r\n    \r\n    mapping (address => uint256) job2index;\r\n    \r\n    struct Job {\r\n        address job_contarct;\r\n        address owner;\r\n        string job_name;\r\n        string document_link;\r\n        uint256 liquidity;\r\n        uint256 reward;\r\n        uint256 limit_call;\r\n        uint256 last_call;\r\n        uint256 min_xp;\r\n        uint256 keeper_count;\r\n        uint256 max_keeper_count;\r\n    }\r\n\r\n    constructor() public{\r\n        manager = msg.sender;\r\n    }\r\n    \r\n    //////////////////////////////////\r\n    ///////// Main Functions /////////\r\n    //////////////////////////////////\r\n    \r\n    //create new job\r\n    function createJob(address _job_contarct, string _job_name , string _document_link , uint256 _liquidity , uint256 _reward , uint256 _max_keeper_count , uint256 _limit_call , uint _min_xp) public payable{\r\n        \r\n        //check for contract unique\r\n        require(!hasJob(_job_contarct) , 'Job Is Already Added');\r\n        \r\n        //transfer token to contract\r\n        require(token.transferFrom(msg.sender, address(this), _liquidity) == true , 'transfer failed');\r\n\r\n        require(_min_xp <= 5 , 'max xp is 5');\r\n        \r\n        job_count++;\r\n        \r\n        jobs[job_count].job_contarct = _job_contarct;\r\n        jobs[job_count].job_name = _job_name;\r\n        jobs[job_count].document_link = _document_link;\r\n        jobs[job_count].liquidity = _liquidity;\r\n        jobs[job_count].max_keeper_count = _max_keeper_count;\r\n        jobs[job_count].reward = _reward;\r\n        jobs[job_count].limit_call = _limit_call;\r\n        jobs[job_count].min_xp = _min_xp;\r\n        jobs[job_count].last_call = now;\r\n        jobs[job_count].keeper_count = 0;\r\n        jobs[job_count].owner = msg.sender;\r\n        \r\n        job2index[_job_contarct] = job_count;\r\n        \r\n        owner_job_count[msg.sender]++;\r\n    }\r\n    \r\n    function editJob(address _job_contarct , uint256 _liquidity , uint256 _reward , uint256 _limit_call , uint256 _min_xp , uint256 _max_keeper_count) public{\r\n        Job storage _selected_job = getJob(_job_contarct);\r\n        require(_selected_job.owner == msg.sender , 'You are not Job Owner');\r\n        require(_min_xp <= 5 , 'max xp is 5');\r\n        \r\n        if(_liquidity > 0){\r\n            //transfer token to contract\r\n            require(token.transferFrom(msg.sender, address(this), _liquidity) == true , 'transfer failed');\r\n        }\r\n        \r\n        _selected_job.liquidity = SafeMath.add(_liquidity , _selected_job.liquidity);\r\n        _selected_job.reward = _reward;\r\n        _selected_job.limit_call = _limit_call;\r\n        _selected_job.max_keeper_count = _max_keeper_count;\r\n        _selected_job.min_xp = _min_xp;\r\n    }\r\n    \r\n    //bonde to a job\r\n    function bonde(address _job_contarct , uint256 _amount) public{\r\n        \r\n        Job storage _selected_job = getJob(_job_contarct);\r\n        \r\n        require(balance[msg.sender] >= _amount , 'Insufficient token balance');\r\n        require(minMax(_amount) >= _selected_job.min_xp , 'Insufficient token xp');\r\n        require(!isKeeper(_job_contarct , msg.sender) , 'You are a job keeper');\r\n        require((_selected_job.keeper_count < _selected_job.max_keeper_count) || (_selected_job.max_keeper_count == 0) , 'job user count limit is over');\r\n                \r\n        //subtract token balance\r\n        balance[msg.sender] = SafeMath.sub(balance[msg.sender] , _amount);\r\n        \r\n        //bonde token to job\r\n        jobs_bonde[msg.sender][_job_contarct] = _amount;\r\n        \r\n        // //add keeper to job\r\n        keeper[_job_contarct][keeper_index[_job_contarct]] = msg.sender;\r\n        keeper_index[_job_contarct]++;\r\n        _selected_job.keeper_count++;\r\n    }\r\n\r\n    function unbonde(address _job_contarct) public{\r\n        \r\n        Job storage _selected_job = getJob(_job_contarct);\r\n\r\n        \r\n        require(isKeeper(_job_contarct , msg.sender) , 'You are not a job keeper');\r\n    \r\n        //get user bonde for this job\r\n        uint256 _bonde_balance = jobs_bonde[msg.sender][_job_contarct] ;\r\n    \r\n        //add token balance to user\r\n        balance[msg.sender] = SafeMath.add(balance[msg.sender] , _bonde_balance);\r\n        \r\n        //sub user balance from job\r\n        jobs_bonde[msg.sender][_job_contarct] = 0;\r\n    \r\n        \r\n        // //remove keeper from job\r\n        uint256 _keeper_index = findJobKeeperIndex(_job_contarct);\r\n        delete keeper[_job_contarct][_keeper_index];\r\n        keeper_index[_job_contarct]--;\r\n        _selected_job.keeper_count--;\r\n    }\r\n    \r\n    function worked(address _job_contarct) external{\r\n\r\n        uint256 _job_index = getJobIndexByAddressOrThrow(_job_contarct);\r\n        Job storage _selected_job =  jobs[_job_index];   \r\n        require(isKeeper(_job_contarct , msg.sender) && checkBalance(_selected_job) , \"Transaction is Invalid\");\r\n        \r\n        ///// Start do work \r\n        \r\n        JobContract job2do = JobContract(_job_contarct);\r\n        job2do.work();\r\n        \r\n        //// End do work\r\n        \r\n        //sub reward credit\r\n        _selected_job.liquidity = SafeMath.sub(_selected_job.liquidity , _selected_job.reward);\r\n        \r\n        //add reward\r\n        jobs_bonde[msg.sender][_job_contarct] = SafeMath.add(jobs_bonde[msg.sender][_job_contarct] , _selected_job.reward);\r\n        completed_work_count[msg.sender]++;\r\n        \r\n        _selected_job.last_call = now;\r\n    }\r\n    \r\n    function withdraw(uint256 _amount) public{\r\n        \r\n        require(_amount <= balance[msg.sender] , 'Insufficient Token Amount Balance');\r\n    \r\n        balance[msg.sender] = SafeMath.sub(balance[msg.sender] , _amount);\r\n    \r\n        token.approve(address(this) , _amount);\r\n\r\n        require(token.transferFrom(address(this) , msg.sender , _amount) == true , 'Insufficient Token Amount In Repo');\r\n        \r\n    }\r\n    \r\n    //////////////////////////////////\r\n    ///////// Show Functions /////////\r\n    //////////////////////////////////\r\n    \r\n    function showKeeperJobBonde(address _job_contarct , address _keeper) public view returns(uint256){\r\n        return jobs_bonde[_keeper][_job_contarct];\r\n    }\r\n    \r\n    function showJobLiquidity(address _job_contarct) public view returns(uint256){\r\n        return getJob(_job_contarct).liquidity;\r\n    }\r\n    \r\n    function showAllJobs() public view returns(address[] , string[] , uint256[] , address[]){\r\n        address[] memory _jobs_address = new address[](job_count);\r\n        string[] memory _jobs_name = new string[](job_count);\r\n        uint256[] memory _jobs_liquidity = new uint256[](job_count);\r\n        address[] memory _jobs_owner = new address[](job_count);\r\n\r\n        for(uint256 i = 1 ; i <= job_count ; i++){\r\n            _jobs_address[i-1] = (jobs[i].job_contarct);\r\n            _jobs_name[i-1] = (jobs[i].job_name);\r\n            _jobs_liquidity[i-1] = (jobs[i].liquidity);\r\n            _jobs_owner[i-1] = (jobs[i].owner);\r\n        }\r\n        \r\n        return(_jobs_address , _jobs_name , _jobs_liquidity , _jobs_owner);\r\n    }\r\n    \r\n    function showJobDetail(address _job_contarct) public view returns(address , address , string , string , uint256 , uint256 , uint256 , uint256 ,uint256 , uint256 ){\r\n        \r\n        Job storage _selected_job = getJob(_job_contarct);\r\n        \r\n        return(\r\n            _selected_job.job_contarct ,\r\n            _selected_job.owner ,\r\n            _selected_job.job_name ,\r\n            _selected_job.document_link ,\r\n            _selected_job.liquidity ,\r\n            _selected_job.reward ,\r\n            _selected_job.keeper_count ,\r\n            _selected_job.max_keeper_count ,\r\n            _selected_job.limit_call ,\r\n            _selected_job.min_xp\r\n        );\r\n    }\r\n    \r\n    function showFreeBalance(address _keeper) public view returns(uint256){\r\n        return balance[_keeper];\r\n    }\r\n    \r\n    function showCompletedWorkCount(address _keeper) public view returns(uint256){\r\n        return completed_work_count[_keeper];\r\n    }\r\n    \r\n    function showOwnedJob() public view returns(address[] , string[]){\r\n        \r\n        uint256 _job_count = owner_job_count[msg.sender];\r\n        \r\n        address[] memory _jobs_address = new address[](_job_count);\r\n        string[] memory _jobs_name = new string[](_job_count);\r\n        \r\n        uint256 _index = 0;\r\n        for(uint256 i = 1 ; i <= job_count ; i++){\r\n            if(jobs[i].owner == msg.sender){\r\n                _jobs_address[_index] = (jobs[i].job_contarct);\r\n                _jobs_name[_index] = (jobs[i].job_name);\r\n                _index++;\r\n            }\r\n        }\r\n        \r\n        return(_jobs_address , _jobs_name);\r\n    }\r\n    \r\n    function showJobOwnedCount() public view returns(uint256){\r\n        return owner_job_count[msg.sender];\r\n    }\r\n    \r\n    function showXp(address _keeper) public view returns(uint256){\r\n        return minMax(balance[_keeper]);\r\n    }\r\n\r\n    function showMaxToken() public view returns(uint256){\r\n        \r\n        return max_token;\r\n    }\r\n    \r\n    function nextAvailabeCall(address _job_contarct) public view returns(uint256){\r\n        Job storage _selected_job = getJob(_job_contarct);\r\n        return _selected_job.limit_call + _selected_job.last_call;\r\n    }\r\n    \r\n    ///////////////////////////////////\r\n    ///////// Manger Functions/////////\r\n    ///////////////////////////////////\r\n    \r\n    function changeMaxToken(uint256 _max_token) public{\r\n        require(msg.sender == manager , \"You Are NOT manger\");\r\n        max_token = _max_token;\r\n    }\r\n    \r\n    ///////////////////////////////////////\r\n    ///////// Helper Functions ////////////\r\n    ///////////////////////////////////////\r\n    \r\n    function findJobKeeperIndex(address _job_contarct) internal view returns(uint256){\r\n        uint256 _index = keeper_index[_job_contarct];\r\n        bool _has_result = false;\r\n        uint256 _result = 0;\r\n        for(uint256 i = 0 ; i <= _index ; i++){\r\n            if(keeper[_job_contarct][i] == msg.sender){\r\n                _has_result = true;\r\n                _result = i;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        require(_has_result , 'Keeper Not Found');\r\n        \r\n        return _result;\r\n    }\r\n    \r\n    function hasJob(address _job_contarct) private constant returns (bool _result) {\r\n        _result = false;\r\n        \r\n        uint256 index = job2index[_job_contarct];\r\n        if(index != 0){\r\n            _result = true;\r\n        }\r\n    }\r\n    \r\n    function minMax(uint256 _value) private view returns(uint256){\r\n        if(_value > max_token){\r\n            _value = max_token;\r\n        }\r\n        return SafeMath.div(SafeMath.mul(_value , 5) , max_token);\r\n    }\r\n    \r\n    function isKeeper(address _job_contarct , address _keeper)public view returns (bool){\r\n        bool _result = false;\r\n        for(uint256 i = 0 ; i < keeper_index[_job_contarct] ; i++){\r\n            if(keeper[_job_contarct][i] == _keeper){\r\n                _result = true;\r\n                break;\r\n            }\r\n        }\r\n        return _result;\r\n    }\r\n    \r\n    function getJobIndexByAddressOrThrow(address _job_contarct) internal view returns (uint256) {\r\n        uint256 index = job2index[_job_contarct];\r\n        require(index > 0 , 'Job not found');\r\n        return index;\r\n    }\r\n    \r\n    function checkBalance(Job storage _selected_job) internal view returns(bool){\r\n        return _selected_job.liquidity >= _selected_job.reward;\r\n    }\r\n    \r\n    function checkLastCall(Job storage _selected_job) internal view returns(bool _result){\r\n        _result = false;\r\n        if(_selected_job.last_call + _selected_job.limit_call <= now){\r\n            _result = true;\r\n        }\r\n    }\r\n    \r\n    function isValid(address _job_contarct , address _keeper) external view returns (bool _result){\r\n        \r\n        uint256 _job_index = getJobIndexByAddressOrThrow(_job_contarct);\r\n        Job storage _selected_job =  jobs[_job_index];        \r\n        \r\n        _result = true;\r\n        if(!isKeeper(_job_contarct , _keeper)){\r\n            _result = false;\r\n        }\r\n        if(!checkBalance(_selected_job)){\r\n            _result = false;\r\n        }\r\n        if(!checkLastCall(_selected_job)){\r\n            _result = false;\r\n        }\r\n    }\r\n    \r\n    function getJob(address _job_contarct) private view returns(Job storage){\r\n        uint256 _job_index = getJobIndexByAddressOrThrow(_job_contarct);\r\n        return jobs[_job_index];\r\n    }\r\n}"}}}