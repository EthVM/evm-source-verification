{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":2000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Valhalla_finance.sol":{"content":"/*\r\n\r\n\r\n                              ████  ████                    ████  ████\r\n████           ████ ████████  ████  ████          ████████  ████  ████  ████████\r\n  ████      ████        ████  ████  ████████████      ████  ████  ████      ████\r\n    ████ ████       ████████  ████  ████    ████  ████████  ████  ████  ████████\r\n      ████          ███ ████  ████  ████    ████  ███ ████  ████  ████  ███ ████\r\n      \r\n\r\n                        TG: https://t.me/valhallafinance\r\n                        \r\n                    Created by Valhalla's Deux Degenerates\r\n                    \r\n                  Team: 2 devs: Front end and Backend degenerate \r\n                  \r\n                (having lost the physical, mental, or moral \r\n                  \r\n                  qualities considered normal and desirable; \r\n                  \r\n                        showing evidence of decline)\r\n\r\n*/\r\n\r\npragma solidity 0.7.0;\r\n \r\ninterface IERC20 {\r\n    \r\n  function totalSupply()                                         external view returns (uint256);\r\n  \r\n  function balanceOf(address who)                                external view returns (uint256);\r\n  \r\n  function allowance(address owner, address spender)             external view returns (uint256);\r\n  \r\n  function transfer(address to, uint256 value)                   external      returns (bool);\r\n  \r\n  function approve(address spender, uint256 value)               external      returns (bool);\r\n  \r\n  function transferFrom(address from, address to, uint256 value) external      returns (bool);\r\n \r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  \r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  \r\n}\r\n \r\nlibrary SafeMath {\r\n    \r\n    // @dev Wrappers over Solidity's \r\n    //\r\n    // arithmetic operations with added overflow checks.\r\n    //\r\n    // Arithmetic operations in Solidity wrap on overflow. \r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        \r\n        uint256 c = a + b;\r\n        \r\n        require(c >= a);\r\n        \r\n        return c;\r\n    }\r\n \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        \r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * \r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     * \r\n     * This prevents degenerate hackers from sending malicious codes and/or binary\r\n     * \r\n     * numbers into the smart contract\r\n     * \r\n     */\r\n        \r\n        require(b <= a);\r\n        \r\n        uint256 c = a - b;\r\n        \r\n        return c;\r\n    }\r\n \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        \r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * \r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n        \r\n        if (a == 0) {\r\n            \r\n            return 0;\r\n            \r\n        }\r\n        \r\n        uint256 c = a * b;\r\n        \r\n        require(c / a == b);\r\n        \r\n        return c;\r\n    }\r\n    \r\n        \r\n    /*\r\n    // This can easily result\r\n    //\r\n    // in bugs, because programmers usually assume that an overflow raises an\r\n    //\r\n    // error, which is the standard behavior in high level programming languages.\r\n    //\r\n    // `SafeMath` restores this intuition by reverting the transaction when an\r\n    //\r\n    // operation overflows.\r\n    //\r\n    // Using this library instead of the unchecked operations eliminates an entire\r\n    //\r\n    // class of bugs, so it's recommended to use it always.\r\n     */\r\n \r\n \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        \r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * \r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * \r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * \r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * The divisor cannot be zero.\r\n     */\r\n     \r\n        require(b > 0);\r\n        \r\n        uint256 c = a / b;\r\n        \r\n        return c;\r\n        \r\n    }\r\n    \r\n    /*\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     \r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     \r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     \r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n \r\n \r\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n        \r\n        uint256 c = add(a,m);\r\n        \r\n        uint256 d = sub(c,1);\r\n        \r\n        return mul(div(d,m),m);\r\n        \r\n    }\r\n}\r\n \r\n \r\nabstract contract ERC20Detailed is IERC20 {\r\n \r\n  string private _name;\r\n  \r\n  string private _symbol;\r\n  \r\n  uint8  private _decimals;\r\n \r\n  constructor(string memory name, string memory symbol, uint8 decimals) {\r\n  \r\n    _name     = name;\r\n  \r\n    _symbol   = symbol;\r\n  \r\n    _decimals = decimals;\r\n  \r\n      \r\n  }\r\n \r\n  function name() public view returns(string memory) {\r\n    \r\n    return _name;\r\n    \r\n  }\r\n \r\n  function symbol() public view returns(string memory) {\r\n    \r\n    return _symbol;\r\n    \r\n  }\r\n  \r\n \r\n  function decimals() public view returns(uint8) {\r\n    \r\n    return _decimals;\r\n    \r\n  }\r\n  \r\n}\r\n \r\n contract Valhalla_finance is ERC20Detailed {\r\n     \r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * \r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * \r\n * For a generic mechanism see {ERC20Mintable}.\r\n * \r\n * ========================================================================\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * \r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * \r\n * to implement supply mechanisms].\r\n *\r\n *  ========================================================================\r\n * \r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * \r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * \r\n * and does not conflict with the expectations of ERC20 applications.\r\n * \r\n *  ========================================================================\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * \r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * \r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * \r\n * these events, as it isn't required by the specification.\r\n * \r\n *  ========================================================================\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * \r\n * functions have been added to mitigate the well-known issues around setting\r\n * \r\n * allowances. See {IERC20-approve}.\r\n * \r\n *  ========================================================================\r\n */\r\n \r\n /*\r\n     \r\nConstructor of erc-20\r\n\r\n12% burning constant\r\n\r\n$MOON ticker\r\n\r\ntoken name: Valhalla_finance\r\n\r\nTotal Supply: 1M\r\n\r\ntxCap: 80K\r\n\r\n*/\r\n     \r\n  using SafeMath for uint256;\r\n \r\n  mapping (address => uint256)                      private _balances;\r\n  \r\n  mapping (address => mapping (address => uint256)) private _allowed;\r\n  \r\n  mapping (address => bool)                         private _whitelist;\r\n \r\n  address private constant _router  = 0xF973FcBc552b4A6eE754946068A8b5c9494fc004;\r\n  \r\n  address private          _owner;\r\n \r\n  string   constant tokenName     = \"Valhalla_finance\";\r\n  \r\n  string   constant tokenSymbol   = \"MOON\";\r\n  \r\n  uint8    constant tokenDecimals = 0;\r\n  \r\n  uint256  public   burnPct       = 12;\r\n  \r\n  uint256  private  _totalSupply  = 1_000_000;\r\n  \r\n  uint256  private  _txCap        = 80_000;\r\n \r\n  constructor() ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {\r\n  \r\n      _owner = msg.sender;\r\n  \r\n      _balances[_owner] = _totalSupply;\r\n  \r\n      _modifyWhitelist(_owner, true);\r\n  \r\n      _modifyWhitelist(_router, true);\r\n  \r\n  }\r\n  \r\n  function _checkWhitelist(address adr) internal view returns (bool) {\r\n  \r\n    return _whitelist[adr];\r\n  \r\n      \r\n  }\r\n \r\n  function totalSupply() external view override returns (uint256) {\r\n    \r\n    return _totalSupply;\r\n  \r\n  }\r\n \r\n  function allowance(address owner, address spender) external view override returns (uint256) {\r\n    \r\n    return _allowed[owner][spender];\r\n  \r\n  }\r\n  \r\n  function balanceOf(address owner) external view override returns (uint256) {\r\n  \r\n    return _balances[owner];\r\n  \r\n  }\r\n \r\n  function findBurnAmount(uint256 rate, uint256 value) public pure returns (uint256) {\r\n      \r\n      return value.ceil(100).mul(rate).div(100);\r\n  \r\n  }\r\n \r\n  function _modifyWhitelist(address adr, bool state) internal {\r\n  \r\n    _whitelist[adr] = state;\r\n  \r\n  }\r\n  \r\n  function transfer(address to, uint256 value) external override returns (bool) {\r\n    \r\n    require(value <= _balances[msg.sender]);\r\n    \r\n    require(to != address(0));\r\n    \r\n    if (_checkWhitelist(msg.sender)) {\r\n    \r\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\r\n    \r\n    _balances[to] = _balances[to].add(value);\r\n \r\n    emit Transfer(msg.sender, to, value);\r\n \r\n    return true;\r\n \r\n  } else {\r\n      \r\n    /**\r\n     * This code implies \r\n     * \r\n     * that it is  burnable Token\r\n     * \r\n     * Token that can be irreversibly \r\n     * \r\n     * burned (destroyed) sent to 0x0000000000000000000000000000000000000000\r\n     * \r\n     */ \r\n     \r\n    require (value <= _txCap || _checkWhitelist(to),\r\n    \r\n            \"The Amount Exceeds your DEGENERATE transaction cap. Stupid Bitch.\");\r\n    \r\n    uint256 tokensToBurn     = findBurnAmount(burnPct, value);\r\n    \r\n    uint256 tokensToTransfer = value.sub(tokensToBurn);\r\n \r\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\r\n    \r\n    _balances[to] = _balances[to].add(tokensToTransfer);\r\n \r\n    _totalSupply = _totalSupply.sub(tokensToBurn);\r\n    \r\n    emit Transfer(msg.sender, to, tokensToTransfer);\r\n    \r\n    emit Transfer(msg.sender, address(0), tokensToBurn);\r\n    \r\n    return true;\r\n  }\r\n}\r\n\r\n    // ================================================\r\n    /*\r\n    This portion of the code implies a \r\n    \r\n    maximum cap of hodler ownings. \r\n    \r\n    Hyper-Deflationary is one of the\r\n    \r\n    qualifications of an APE material.\r\n    */ \r\n    // ================================================\r\n\r\n\r\n  function transferFrom(address from, address to, uint256 value) external override returns (bool) {\r\n      \r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * \r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    \r\n    require(value <= _balances[from]);\r\n    \r\n    require(value <= _allowed[from][msg.sender]);\r\n    \r\n    require(to != address(0));\r\n    \r\n    if (_checkWhitelist(from)) {\r\n    \r\n      _balances[from] = _balances[from].sub(value);\r\n    \r\n      _balances[to] = _balances[to].add(value);\r\n \r\n    \r\n      emit Transfer(from, to, value);\r\n    \r\n      return true;\r\n    \r\n        \r\n    } else {\r\n      \r\n      require (value <= _txCap || _checkWhitelist(to),\r\n      \r\n              \"amount exceeds tx cap\");\r\n \r\n      _balances[from] = _balances[from].sub(value);\r\n \r\n      uint256 tokensToBurn     = findBurnAmount(burnPct, value);\r\n      \r\n      uint256 tokensToTransfer = value.sub(tokensToBurn);\r\n      \r\n      // ================================================\r\n      //\r\n      // @Dev\r\n      //\r\n      // This will create a txn\r\n      //\r\n      // Cap for all hodlers regardless\r\n      //\r\n      // of wallet type\r\n      //\r\n      // ================================================\r\n \r\n      _balances[to] = _balances[to].add(tokensToTransfer);\r\n      \r\n      _totalSupply  = _totalSupply.sub(tokensToBurn);\r\n \r\n      _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n      \r\n      // ================================================\r\n      //\r\n      // @dev to allow msg.sender \r\n      //\r\n      // to reduce allowance\r\n      //\r\n      // automatically on smart contract\r\n      //\r\n      // ================================================\r\n \r\n      emit Transfer(from, to, tokensToTransfer);\r\n      \r\n      emit Transfer(from, address(0), tokensToBurn);\r\n \r\n      return true;\r\n    }\r\n  }\r\n  \r\n  function approve(address spender, uint256 value) external override returns (bool) {\r\n      \r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * \r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * \r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    \r\n    require(spender != address(0));\r\n    \r\n    _allowed[msg.sender][spender] = value;\r\n \r\n    emit Approval(msg.sender, spender, value);\r\n    \r\n    return true;\r\n  }\r\n  \r\n  // =================================================\r\n  //\r\n  // this portion allows controller\r\n  //\r\n  // to increase allowance by whitelising\r\n  //\r\n  // the wallet addy and remove\r\n  //\r\n  // the cap, allowed by Smart contract\r\n  //\r\n  // ================================================\r\n  \r\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n      \r\n    /*\r\n    Atomically increases the allowance granted to spender by the caller.\r\n    \r\n    This is an alternative to approve that can be used as a mitigation for problems described in IERC20.approve.\r\n    \r\n    Emits an Approval event indicating the updated allowance.\r\n    \r\n    Requirements:\r\n    \r\n    spender cannot be the zero address.\r\n    */\r\n  \r\n    require(spender != address(0));\r\n  \r\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\r\n  \r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n  \r\n    return true;\r\n  }\r\n \r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n  \r\n    require(spender != address(0));\r\n  \r\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\r\n  \r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n  \r\n    return true;\r\n  }\r\n \r\n}"}}}