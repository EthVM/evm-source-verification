{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"SigmoidThreshold.sol":{"content":"// File: @openzeppelin/contracts/math/Math.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, 'SafeMath: addition overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, 'SafeMath: subtraction overflow');\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, 'SafeMath: division by zero');\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, 'SafeMath: modulo by zero');\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            'Ownable: new owner is the zero address'\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/owner/Operator.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ncontract Operator is Context, Ownable {\r\n    address private _operator;\r\n\r\n    event OperatorTransferred(\r\n        address indexed previousOperator,\r\n        address indexed newOperator\r\n    );\r\n\r\n    constructor() internal {\r\n        _operator = _msgSender();\r\n        emit OperatorTransferred(address(0), _operator);\r\n    }\r\n\r\n    function operator() public view returns (address) {\r\n        return _operator;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(\r\n            _operator == msg.sender,\r\n            'operator: caller is not the operator'\r\n        );\r\n        _;\r\n    }\r\n\r\n    function isOperator() public view returns (bool) {\r\n        return _msgSender() == _operator;\r\n    }\r\n\r\n    function transferOperator(address newOperator_) public onlyOwner {\r\n        _transferOperator(newOperator_);\r\n    }\r\n\r\n    function _transferOperator(address newOperator_) internal {\r\n        require(\r\n            newOperator_ != address(0),\r\n            'operator: zero address given for new operator'\r\n        );\r\n        emit OperatorTransferred(address(0), newOperator_);\r\n        _operator = newOperator_;\r\n    }\r\n}\r\n\r\n// File: contracts/curve/Curve.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface ICurve {\r\n    function minSupply() external view returns (uint256);\r\n\r\n    function maxSupply() external view returns (uint256);\r\n\r\n    function minCeiling() external view returns (uint256);\r\n\r\n    function maxCeiling() external view returns (uint256);\r\n\r\n    function calcCeiling(uint256 _supply) external view returns (uint256);\r\n}\r\n\r\nabstract contract Curve is ICurve {\r\n    /* ========== EVENTS ========== */\r\n\r\n    event MinSupplyChanged(\r\n        address indexed operator,\r\n        uint256 _old,\r\n        uint256 _new\r\n    );\r\n\r\n    event MaxSupplyChanged(\r\n        address indexed operator,\r\n        uint256 _old,\r\n        uint256 _new\r\n    );\r\n\r\n    event MinCeilingChanged(\r\n        address indexed operator,\r\n        uint256 _old,\r\n        uint256 _new\r\n    );\r\n\r\n    event MaxCeilingChanged(\r\n        address indexed operator,\r\n        uint256 _old,\r\n        uint256 _new\r\n    );\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    uint256 public override minSupply;\r\n    uint256 public override maxSupply;\r\n\r\n    uint256 public override minCeiling;\r\n    uint256 public override maxCeiling;\r\n\r\n    /* ========== GOVERNANCE ========== */\r\n\r\n    function setMinSupply(uint256 _newMinSupply) public virtual {\r\n        uint256 oldMinSupply = minSupply;\r\n        minSupply = _newMinSupply;\r\n        emit MinSupplyChanged(msg.sender, oldMinSupply, _newMinSupply);\r\n    }\r\n\r\n    function setMaxSupply(uint256 _newMaxSupply) public virtual {\r\n        uint256 oldMaxSupply = maxSupply;\r\n        maxSupply = _newMaxSupply;\r\n        emit MaxSupplyChanged(msg.sender, oldMaxSupply, _newMaxSupply);\r\n    }\r\n\r\n    function setMinCeiling(uint256 _newMinCeiling) public virtual {\r\n        uint256 oldMinCeiling = _newMinCeiling;\r\n        minCeiling = _newMinCeiling;\r\n        emit MinCeilingChanged(msg.sender, oldMinCeiling, _newMinCeiling);\r\n    }\r\n\r\n    function setMaxCeiling(uint256 _newMaxCeiling) public virtual {\r\n        uint256 oldMaxCeiling = _newMaxCeiling;\r\n        maxCeiling = _newMaxCeiling;\r\n        emit MaxCeilingChanged(msg.sender, oldMaxCeiling, _newMaxCeiling);\r\n    }\r\n\r\n    function calcCeiling(uint256 _supply)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/curve/Sigmoid.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ncontract SigmoidThreshold is Operator, Curve {\r\n    using SafeMath for uint256;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    uint256[23] private slots;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(\r\n        uint256 _minSupply,\r\n        uint256 _maxSupply,\r\n        uint256 _minCeiling,\r\n        uint256 _maxCeiling\r\n    ) public {\r\n        minSupply = _minSupply;\r\n        maxSupply = _maxSupply;\r\n        minCeiling = _minCeiling;\r\n        maxCeiling = _maxCeiling;\r\n\r\n        slots[0] = 1000000000000000000;\r\n        slots[1] = 994907149075715143;\r\n        slots[2] = 988513057369406817;\r\n        slots[3] = 982013790037908452;\r\n        slots[4] = 970687769248643639;\r\n        slots[5] = 952574126822433143;\r\n        slots[6] = 924141819978756551;\r\n        slots[7] = 880797077977882314;\r\n        slots[8] = 817574476193643651;\r\n        slots[9] = 731058578630004896;\r\n        slots[10] = 622459331201854593;\r\n        slots[11] = 500000000000000000;\r\n        slots[12] = 377540668798145407;\r\n        slots[13] = 268941421369995104;\r\n        slots[14] = 182425523806356349;\r\n        slots[15] = 119202922022117574;\r\n        slots[16] = 75858180021243560;\r\n        slots[17] = 47425873177566788;\r\n        slots[18] = 29312230751356326;\r\n        slots[19] = 17986209962091562;\r\n        slots[20] = 11486942630593183;\r\n        slots[21] = 5092850924284857;\r\n        slots[22] = 0;\r\n    }\r\n\r\n    /* ========== GOVERNANCE ========== */\r\n\r\n    function setMinSupply(uint256 _newMinSupply) public override onlyOperator {\r\n        super.setMinSupply(_newMinSupply);\r\n    }\r\n\r\n    function setMaxSupply(uint256 _newMaxSupply) public override onlyOperator {\r\n        super.setMaxSupply(_newMaxSupply);\r\n    }\r\n\r\n    function setMinCeiling(uint256 _newMinCeiling)\r\n        public\r\n        override\r\n        onlyOperator\r\n    {\r\n        super.setMinCeiling(_newMinCeiling);\r\n    }\r\n\r\n    function setMaxCeiling(uint256 _newMaxCeiling)\r\n        public\r\n        override\r\n        onlyOperator\r\n    {\r\n        super.setMaxCeiling(_newMaxCeiling);\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    function calcCeiling(uint256 _supply)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        if (_supply <= minSupply) {\r\n            return maxCeiling;\r\n        }\r\n        if (_supply >= maxSupply) {\r\n            return minCeiling;\r\n        }\r\n\r\n        uint256 slotWidth = maxSupply.sub(minSupply).div(slots.length);\r\n        uint256 xa = _supply.sub(minSupply).div(slotWidth);\r\n        uint256 xb = Math.min(xa.add(1), slots.length.sub(1));\r\n\r\n        uint256 slope = slots[xa].sub(slots[xb]).mul(1e18).div(slotWidth);\r\n        uint256 wy = slots[xa].add(slope.mul(slotWidth.mul(xa)).div(1e18));\r\n\r\n        uint256 percentage = 0;\r\n        if (wy > slope.mul(_supply).div(1e18)) {\r\n            percentage = wy.sub(slope.mul(_supply).div(1e18));\r\n        } else {\r\n            percentage = slope.mul(_supply).div(1e18).sub(wy);\r\n        }\r\n\r\n        return\r\n            minCeiling.add(\r\n                maxCeiling.sub(minCeiling).mul(percentage).div(1e18)\r\n            );\r\n    }\r\n}"}}}