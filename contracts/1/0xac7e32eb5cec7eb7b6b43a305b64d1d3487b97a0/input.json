{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"AtomicBlue.sol":{"content":"pragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract AtomicTypes{\r\n    struct SwapParams{\r\n        Token sellToken; \r\n        uint256 input;\r\n        Token buyToken;\r\n        uint minOutput;\r\n    }\r\n    \r\n    struct DistributionParams{\r\n        IAtomicExchange[] exchangeModules;\r\n        bytes[] exchangeData;\r\n        uint256[] chunks;\r\n    }\r\n    \r\n    event Trade(\r\n        address indexed sellToken,\r\n        uint256 sellAmount,\r\n        address indexed buyToken,\r\n        uint256 buyAmount,\r\n        address indexed trader,\r\n        address receiver\r\n    );\r\n}\r\n\r\ncontract AtomicUtils{    \r\n    // ETH and its wrappers\r\n    address constant WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    IWETH constant WETH = IWETH(WETHAddress);\r\n    Token constant ETH = Token(address(0));\r\n    address constant EEEAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    Token constant EEE = Token(EEEAddress);\r\n    \r\n    // Universal function to query this contracts balance, supporting  and Token\r\n    function balanceOf(Token token) internal view returns(uint balance){\r\n        if(isETH(token)){\r\n            return address(this).balance;\r\n        }else{\r\n            return token.balanceOf(address(this));\r\n        }\r\n    }\r\n    \r\n    // Universal send function, supporting ETH and Token\r\n    function send(Token token, address payable recipient, uint amount) internal {\r\n        if(isETH(token)){\r\n            require(\r\n                recipient.send(amount),\r\n                \"Sending of ETH failed.\"\r\n            );\r\n        }else{\r\n            Token(token).transfer(recipient, amount);\r\n            require(\r\n                validateOptionalERC20Return(),\r\n                \"ERC20 token transfer failed.\"\r\n            );\r\n        }\r\n    }\r\n    \r\n    // Universal function to claim tokens from msg.sender\r\n    function claimTokenFromSenderTo(Token _token, uint _amount, address _receiver) internal {\r\n        if (isETH(_token)) {\r\n            require(msg.value == _amount);\r\n            // dont forward ETH\r\n        }else{\r\n            require(msg.value  == 0);\r\n            _token.transferFrom(msg.sender, _receiver, _amount);\r\n        }\r\n    }\r\n    \r\n    // Token approval function supporting non-compliant tokens\r\n    function approve(Token _token, address _spender, uint _amount) internal {\r\n        if (!isETH(_token)) {\r\n            _token.approve(_spender, _amount);\r\n            require(\r\n                validateOptionalERC20Return(),\r\n                \"ERC20 approval failed.\"\r\n            );\r\n        }\r\n    }\r\n    \r\n    // Validate return data of non-compliant erc20s\r\n    function validateOptionalERC20Return() pure internal returns (bool){\r\n        uint256 success = 0;\r\n\r\n        assembly {\r\n            switch returndatasize()             // Check the number of bytes the token contract returned\r\n            case 0 {                            // Nothing returned, but contract did not throw > assume our transfer succeeded\r\n                success := 1\r\n            }\r\n            case 32 {                           // 32 bytes returned, result is the returned bool\r\n                returndatacopy(0, 0, 32)\r\n                success := mload(0)\r\n            }\r\n        }\r\n\r\n        return success != 0;\r\n    }\r\n\r\n    function isETH(Token token) pure internal  returns (bool){\r\n        if(\r\n            address(token) == address(0)\r\n            || address(token) == EEEAddress\r\n        ){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function isWETH(Token token) pure internal  returns (bool){\r\n        if(address(token) == WETHAddress){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    // Source: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\r\n    function sliceBytes(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    )\r\n    internal\r\n    pure\r\n    returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length), \"Read out of bounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n            // The first word of the slice result is potentially a partial\r\n            // word read from the original array. To read it, we calculate\r\n            // the length of that partial word and start copying that many\r\n            // bytes into the array. The first word we copy will start with\r\n            // data we don't care about, but the last `lengthmod` bytes will\r\n            // land at the beginning of the contents of the new array. When\r\n            // we're done copying, we overwrite the full first word with\r\n            // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n            // The multiplication in the next line is necessary\r\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n            // the following copy loop was copying the origin's length\r\n            // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                // The multiplication in the next line has the same exact purpose\r\n                // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n            //update free-memory pointer\r\n            //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n}\r\n\r\ncontract AtomicModuleRegistry {\r\n    address moduleRegistrar;\r\n    mapping(address => bool) public isModule;\r\n    \r\n    constructor () public {\r\n        moduleRegistrar = msg.sender;\r\n    }\r\n\r\n    modifier onlyRegistrar() {\r\n        require(moduleRegistrar == msg.sender, \"caller is not moduleRegistrar\");\r\n        _;\r\n    }\r\n    \r\n    function setNewRegistrar(address newRegistrar) public virtual onlyRegistrar {\r\n        moduleRegistrar = newRegistrar;\r\n    }\r\n    \r\n    function registerModule(address module, bool status) public virtual onlyRegistrar {\r\n        isModule[module] = status;\r\n    }\r\n}\r\n\r\nabstract contract IAtomicExchange is AtomicTypes{\r\n    function swap(\r\n        SwapParams memory _swap,\r\n        bytes memory data\r\n    )  external payable virtual returns(\r\n        uint output\r\n    );\r\n}\r\n\r\ncontract AtomicBlue is AtomicUtils, AtomicTypes, AtomicModuleRegistry{\r\n    // IMPORTANT NOTICE:\r\n    // NEVER set a token allowance to this contract, as everybody can do arbitrary calls from it.\r\n    // When swapping tokens always go through AtomicTokenProxy.\r\n    // This contract assumes token to swap has already been transfered to it when being called. Ether can be sent directly with the call.\r\n\r\n    // perform a distributed swap and transfer outcome to _receipient\r\n    function swapAndSend(\r\n        SwapParams memory _swap,\r\n        \r\n        DistributionParams memory _distribution,\r\n        \r\n        address payable _receipient\r\n    ) public payable returns (uint _output){\r\n        // execute swaps on behalf of trader\r\n        _output = doDistributedSwap(_swap, _distribution);\r\n\r\n        // check if output of swap is sufficient        \r\n        require(_output >= _swap.minOutput, \"Slippage limit exceeded.\");\r\n        \r\n        // send swap output to receipient\r\n        send(_swap.buyToken, _receipient, _output);\r\n        \r\n        emit Trade(\r\n            address(_swap.sellToken),\r\n            _swap.input,\r\n            address(_swap.buyToken),\r\n            _output,\r\n            msg.sender,\r\n            _receipient\r\n        );\r\n    }\r\n    \r\n    function multiPathSwapAndSend(\r\n        SwapParams memory _swap,\r\n        \r\n        Token[] calldata _path,\r\n        \r\n        DistributionParams[] memory _distribution,\r\n        \r\n        address payable _receipient\r\n    ) public payable returns (uint _output){\r\n        // verify path\r\n        require(\r\n            _path[0] == _swap.sellToken\r\n            && _path[_path.length - 1] == _swap.buyToken\r\n            && _path.length >= 2\r\n        );\r\n        \r\n        // execute swaps on behalf of trader\r\n        _output = _swap.input;\r\n        for(uint i = 1; i < _path.length; i++){\r\n            _output = doDistributedSwap(SwapParams({\r\n                sellToken : _path[i - 1],\r\n                input     : _output,      // output of last swap is input for this one\r\n                buyToken  : _path[i],\r\n                minOutput : 0            // we check the total outcome in the end\r\n            }), _distribution[i - 1]);\r\n        }\r\n\r\n        // check if output of swap is sufficient        \r\n        require(_output >= _swap.minOutput, \"Slippage limit exceeded.\");\r\n        \r\n        // send swap output to sender\r\n        send(_swap.buyToken, _receipient, _output);\r\n        \r\n        emit Trade(\r\n            address(_swap.sellToken),\r\n            _swap.input,\r\n            address(_swap.buyToken),\r\n            _output,\r\n            msg.sender,\r\n            _receipient\r\n        );\r\n    }\r\n    \r\n    \r\n    // internal function to perform a distributed swap\r\n    function doDistributedSwap(\r\n        SwapParams memory _swap,\r\n        \r\n        DistributionParams memory _distribution\r\n    ) internal returns(uint){\r\n        \r\n        // count totalChunks\r\n        uint totalChunks = 0;\r\n        for(uint i = 0; i < _distribution.chunks.length; i++){\r\n            totalChunks += _distribution.chunks[i];   \r\n        }\r\n        \r\n        // route trades to the different exchanges\r\n        for(uint i = 0; i < _distribution.exchangeModules.length; i++){\r\n            IAtomicExchange exchange = _distribution.exchangeModules[i];\r\n            \r\n            uint thisInput = _swap.input * _distribution.chunks[i] / totalChunks;\r\n            \r\n            if(address(exchange) == address(0)){\r\n                // trade is not using an exchange module but a direct call\r\n                (address target, uint value, bytes memory callData) = abi.decode(_distribution.exchangeData[i], (address, uint, bytes));\r\n                \r\n                (bool success, bytes memory data) = address(target).call.value(value)(callData);\r\n            \r\n                require(success, \"Exchange call reverted.\");\r\n            }else{\r\n                // delegate call to the exchange module\r\n                require(isModule[address(exchange)], \"unknown exchangeModule\");\r\n                (bool success, bytes memory data) = address(exchange).delegatecall(\r\n                    abi.encodePacked(// This encodes the function to call and the parameters we are passing to the settlement function\r\n                        exchange.swap.selector, \r\n                        abi.encode(\r\n                            SwapParams({\r\n                                sellToken : _swap.sellToken,\r\n                                input     : thisInput,\r\n                                buyToken  : _swap.buyToken,\r\n                                minOutput : 1 // we are checking the combined output in the end\r\n                            }),\r\n                            _distribution.exchangeData[i]\r\n                        )\r\n                    )\r\n                );\r\n            \r\n                require(success, \"Exchange module reverted.\");\r\n            }\r\n        }\r\n        \r\n        return balanceOf(_swap.buyToken);\r\n    }\r\n    \r\n    // perform a distributed swap\r\n    function swap(\r\n        SwapParams memory _swap,\r\n        DistributionParams memory _distribution\r\n    ) public payable returns (uint _output){\r\n        return swapAndSend(_swap, _distribution, msg.sender);\r\n    }\r\n    \r\n    // perform a multi-path distributed swap\r\n    function multiPathSwap(\r\n        SwapParams memory _swap,\r\n        Token[] calldata _path,\r\n        DistributionParams[] memory _distribution\r\n    ) public payable returns (uint _output){\r\n        return multiPathSwapAndSend(_swap, _path, _distribution, msg.sender);\r\n    }\r\n\r\n    // allow ETH receivals\r\n    receive() external payable {}\r\n}\r\n\r\ncontract AtomicTokenProxy is AtomicUtils, AtomicTypes{\r\n    AtomicBlue constant atomic = AtomicBlue(0x0);\r\n\r\n    // perform a distributed swap and transfer outcome to _receipient\r\n    function swapAndSend(\r\n        SwapParams calldata _swap,\r\n        \r\n        DistributionParams calldata _distribution,\r\n        \r\n        address payable _receipient\r\n    ) public payable returns (uint _output){\r\n        // deposit tokens to executor\r\n        claimTokenFromSenderTo(_swap.sellToken, _swap.input, address(atomic));\r\n        \r\n        // execute swaps on behalf of sender\r\n        _output = atomic.swapAndSend.value(msg.value)(_swap, _distribution, _receipient);\r\n    }\r\n    \r\n    // perform a multi-path distributed swap and transfer outcome to _receipient\r\n    function multiPathSwapAndSend(\r\n        SwapParams calldata _swap,\r\n        \r\n        Token[] calldata _path,\r\n        \r\n        DistributionParams[] calldata _distribution,\r\n        \r\n        address payable _receipient\r\n    ) public payable returns (uint _output){\r\n        // deposit tokens to executor\r\n        claimTokenFromSenderTo(_swap.sellToken, _swap.input, address(atomic));\r\n        \r\n        // execute swaps on behalf of sender\r\n        _output = atomic.multiPathSwapAndSend.value(msg.value)(\r\n            _swap,\r\n            _path,\r\n            _distribution,\r\n            _receipient\r\n        );\r\n    }\r\n    \r\n    // perform a distributed swap\r\n    function swap(\r\n        SwapParams calldata _swap,\r\n        DistributionParams calldata _distribution\r\n    ) public payable returns (uint _output){\r\n        return swapAndSend(_swap, _distribution, msg.sender);\r\n    }\r\n    \r\n    // perform a distributed swap and burn optimal gastoken amount afterwards\r\n    function swapWithGasTokens(\r\n        SwapParams calldata _swap,\r\n        DistributionParams calldata _distribution,\r\n        IGasToken _gasToken,\r\n        uint _gasQtyPerToken\r\n    ) public payable returns (uint _output){\r\n        uint startGas = gasleft();\r\n        _output = swapAndSend(_swap, _distribution, msg.sender);\r\n        _gasToken.freeFromUpTo(msg.sender, (startGas - gasleft() + 25000) / _gasQtyPerToken);\r\n    }\r\n    \r\n    // perform a multi-path distributed swap\r\n    function multiPathSwap(\r\n        SwapParams calldata _swap,\r\n        Token[] calldata _path,\r\n        DistributionParams[] calldata _distribution\r\n    ) public payable returns (uint _output){\r\n        return multiPathSwapAndSend(_swap, _path, _distribution, msg.sender);\r\n    }\r\n    \r\n    // perform a multi-path distributed swap and burn optimal gastoken amount afterwards\r\n    function multiPathSwapWithGasTokens(\r\n        SwapParams calldata _swap,\r\n        Token[] calldata _path,\r\n        DistributionParams[] calldata _distribution,\r\n        IGasToken _gasToken,\r\n        uint _gasQtyPerToken\r\n    ) public payable returns (uint _output){\r\n        uint startGas = gasleft();\r\n        _output = multiPathSwapAndSend(_swap, _path, _distribution, msg.sender);\r\n        _gasToken.freeFromUpTo(msg.sender, (startGas - gasleft() + 25000) / _gasQtyPerToken);\r\n    }\r\n    \r\n    // perform a distributed swap, send outcome to _receipient and burn optimal gastoken amount afterwards\r\n    function swapAndSendWithGasTokens(\r\n        SwapParams calldata _swap,\r\n        DistributionParams calldata _distribution,\r\n        address payable _receipient,\r\n        IGasToken _gasToken,\r\n        uint _gasQtyPerToken\r\n    ) public payable returns (uint _output){\r\n        uint startGas = gasleft();\r\n        _output = swapAndSend(_swap, _distribution, _receipient);\r\n        _gasToken.freeFromUpTo(msg.sender, (startGas - gasleft() + 25000) / _gasQtyPerToken);\r\n    }\r\n    \r\n    // perform a multi-path distributed swap, send outcome to _receipient and burn optimal gastoken amount afterwards\r\n    function multiPathSwapAndSendWithGasTokens(\r\n        SwapParams calldata _swap,\r\n        Token[] calldata _path,\r\n        DistributionParams[] calldata _distribution,\r\n        address payable _receipient,\r\n        IGasToken _gasToken,\r\n        uint _gasQtyPerToken\r\n    ) public payable returns (uint _output){\r\n        uint startGas = gasleft();\r\n        _output = multiPathSwapAndSend(_swap, _path, _distribution, _receipient);\r\n        _gasToken.freeFromUpTo(msg.sender, (startGas - gasleft() + 25000) / _gasQtyPerToken);\r\n    }\r\n}\r\n\r\n// Interfaces\r\n\r\ncontract Token {\r\n    function totalSupply() view public returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) view public returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) public {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)  public {}\r\n\r\n    function approve(address _spender, uint256 _value) public {}\r\n\r\n    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    uint256 public decimals;\r\n    string public name;\r\n}\r\n\r\ncontract IWETH is Token {\r\n    function deposit() public payable {}\r\n\r\n    function withdraw(uint256 amount) public {}\r\n}\r\n\r\ncontract IGasToken {\r\n    function freeUpTo(uint256 value) public returns (uint256) {\r\n    }\r\n\r\n    function free(uint256 value) public returns (uint256) {\r\n    }\r\n    \r\n    function freeFrom(address from, uint256 value) public returns (uint256) {\r\n    }\r\n\r\n    function freeFromUpTo(address from, uint256 value) public returns (uint256) {\r\n    }\r\n}"}}}