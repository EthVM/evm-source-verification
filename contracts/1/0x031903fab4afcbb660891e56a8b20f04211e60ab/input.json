{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "KyberRateQueryReserves.sol": {
      "content": "// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @kyber.network/utils-sc/contracts/IERC20Ext.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n/**\r\n * @dev Interface extending ERC20 standard to include decimals() as\r\n *      it is optional in the OpenZeppelin IERC20 interface.\r\n */\r\ninterface IERC20Ext is IERC20 {\r\n    /**\r\n     * @dev This function is required as Kyber requires to interact\r\n     *      with token.decimals() with many of its operations.\r\n     */\r\n    function decimals() external view returns (uint8 digits);\r\n}\r\n\r\n// File: @kyber.network/utils-sc/contracts/Utils.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n/**\r\n * @title Kyber utility file\r\n * mostly shared constants and rate calculation helpers\r\n * inherited by most of kyber contracts.\r\n * previous utils implementations are for previous solidity versions.\r\n */\r\ncontract Utils {\r\n    /// Declared constants below to be used in tandem with\r\n    /// getDecimalsConstant(), for gas optimization purposes\r\n    /// which return decimals from a constant list of popular\r\n    /// tokens.\r\n    IERC20Ext internal constant ETH_TOKEN_ADDRESS = IERC20Ext(\r\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n    );\r\n    IERC20Ext internal constant USDT_TOKEN_ADDRESS = IERC20Ext(\r\n        0xdAC17F958D2ee523a2206206994597C13D831ec7\r\n    );\r\n    IERC20Ext internal constant DAI_TOKEN_ADDRESS = IERC20Ext(\r\n        0x6B175474E89094C44Da98b954EedeAC495271d0F\r\n    );\r\n    IERC20Ext internal constant USDC_TOKEN_ADDRESS = IERC20Ext(\r\n        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\r\n    );\r\n    IERC20Ext internal constant WBTC_TOKEN_ADDRESS = IERC20Ext(\r\n        0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\r\n    );\r\n    IERC20Ext internal constant KNC_TOKEN_ADDRESS = IERC20Ext(\r\n        0xdd974D5C2e2928deA5F71b9825b8b646686BD200\r\n    );\r\n    uint256 public constant BPS = 10000; // Basic Price Steps. 1 step = 0.01%\r\n    uint256 internal constant PRECISION = (10**18);\r\n    uint256 internal constant MAX_QTY = (10**28); // 10B tokens\r\n    uint256 internal constant MAX_RATE = (PRECISION * 10**7); // up to 10M tokens per eth\r\n    uint256 internal constant MAX_DECIMALS = 18;\r\n    uint256 internal constant ETH_DECIMALS = 18;\r\n    uint256 internal constant MAX_ALLOWANCE = uint256(-1); // token.approve inifinite\r\n\r\n    mapping(IERC20Ext => uint256) internal decimals;\r\n\r\n    /// @dev Sets the decimals of a token to storage if not already set, and returns\r\n    ///      the decimals value of the token. Prefer using this function over\r\n    ///      getDecimals(), to avoid forgetting to set decimals in local storage.\r\n    /// @param token The token type\r\n    /// @return tokenDecimals The decimals of the token\r\n    function getSetDecimals(IERC20Ext token) internal returns (uint256 tokenDecimals) {\r\n        tokenDecimals = getDecimalsConstant(token);\r\n        if (tokenDecimals > 0) return tokenDecimals;\r\n\r\n        tokenDecimals = decimals[token];\r\n        if (tokenDecimals == 0) {\r\n            tokenDecimals = token.decimals();\r\n            decimals[token] = tokenDecimals;\r\n        }\r\n    }\r\n\r\n    /// @dev Get the balance of a user\r\n    /// @param token The token type\r\n    /// @param user The user's address\r\n    /// @return The balance\r\n    function getBalance(IERC20Ext token, address user) internal view returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            return user.balance;\r\n        } else {\r\n            return token.balanceOf(user);\r\n        }\r\n    }\r\n\r\n    /// @dev Get the decimals of a token, read from the constant list, storage,\r\n    ///      or from token.decimals(). Prefer using getSetDecimals when possible.\r\n    /// @param token The token type\r\n    /// @return tokenDecimals The decimals of the token\r\n    function getDecimals(IERC20Ext token) internal view returns (uint256 tokenDecimals) {\r\n        // return token decimals if has constant value\r\n        tokenDecimals = getDecimalsConstant(token);\r\n        if (tokenDecimals > 0) return tokenDecimals;\r\n\r\n        // handle case where token decimals is not a declared decimal constant\r\n        tokenDecimals = decimals[token];\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        return (tokenDecimals > 0) ? tokenDecimals : token.decimals();\r\n    }\r\n\r\n    function calcDestAmount(\r\n        IERC20Ext src,\r\n        IERC20Ext dest,\r\n        uint256 srcAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(\r\n        IERC20Ext src,\r\n        IERC20Ext dest,\r\n        uint256 destAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcDstQty(\r\n        uint256 srcQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(srcQty <= MAX_QTY, \"srcQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(\r\n        uint256 dstQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(dstQty <= MAX_QTY, \"dstQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint256 numerator;\r\n        uint256 denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n\r\n    function calcRateFromQty(\r\n        uint256 srcAmount,\r\n        uint256 destAmount,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals\r\n    ) internal pure returns (uint256) {\r\n        require(srcAmount <= MAX_QTY, \"srcAmount > MAX_QTY\");\r\n        require(destAmount <= MAX_QTY, \"destAmount > MAX_QTY\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION) / ((10**(dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION * (10**(srcDecimals - dstDecimals))) / srcAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev save storage access by declaring token decimal constants\r\n    /// @param token The token type\r\n    /// @return token decimals\r\n    function getDecimalsConstant(IERC20Ext token) internal pure returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            return ETH_DECIMALS;\r\n        } else if (token == USDT_TOKEN_ADDRESS) {\r\n            return 6;\r\n        } else if (token == DAI_TOKEN_ADDRESS) {\r\n            return 18;\r\n        } else if (token == USDC_TOKEN_ADDRESS) {\r\n            return 6;\r\n        } else if (token == WBTC_TOKEN_ADDRESS) {\r\n            return 8;\r\n        } else if (token == KNC_TOKEN_ADDRESS) {\r\n            return 18;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function minOf(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n}\r\n\r\n// File: contracts/sol6/IConversionRates.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IConversionRates {\r\n\r\n    function recordImbalance(\r\n        IERC20Ext token,\r\n        int buyAmount,\r\n        uint256 rateUpdateBlock,\r\n        uint256 currentBlock\r\n    ) external;\r\n\r\n    function getRate(\r\n        IERC20Ext token,\r\n        uint256 currentBlockNumber,\r\n        bool buy,\r\n        uint256 qty\r\n    ) external view returns(uint256);\r\n}\r\n\r\n// File: contracts/sol6/IKyberSanity.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\ninterface IKyberSanity {\r\n    function getSanityRate(IERC20Ext src, IERC20Ext dest) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/IKyberReserve.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\ninterface IKyberReserve {\r\n    function trade(\r\n        IERC20Ext srcToken,\r\n        uint256 srcAmount,\r\n        IERC20Ext destToken,\r\n        address payable destAddress,\r\n        uint256 conversionRate,\r\n        bool validate\r\n    ) external payable returns (bool);\r\n\r\n    function getConversionRate(\r\n        IERC20Ext src,\r\n        IERC20Ext dest,\r\n        uint256 srcQty,\r\n        uint256 blockNumber\r\n    ) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/sol6/helpers/KyberRateQueryReserves.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IKyberReserveExt is IKyberReserve {\r\n    function conversionRatesContract() external view returns (IConversionRates);\r\n    function sanityRatesContract() external view returns (IKyberSanity);\r\n}\r\n\r\ncontract KyberRateQueryReserves is Utils {\r\n\r\n    function getRatesWithEth(\r\n        IKyberReserveExt reserve,\r\n        IERC20Ext[] calldata tokens,\r\n        uint256 weiAmount\r\n    )\r\n        external view returns(uint256[] memory sellRates, uint256[] memory buyRates)\r\n    {\r\n        uint256 numTokens = tokens.length;\r\n\r\n        buyRates = new uint256[](numTokens);\r\n        sellRates = new uint256[](numTokens);\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            (buyRates[i], sellRates[i], , , ) = getRateWithEth(reserve, tokens[i], weiAmount);\r\n        }\r\n    }\r\n\r\n    function getRatesWithToken(\r\n        IKyberReserveExt reserve,\r\n        IERC20Ext[] calldata tokens,\r\n        uint256 tweiAmount\r\n    )\r\n        external view \r\n        returns(uint256[] memory sellRates, uint256[] memory buyRates)\r\n    {\r\n        uint256 numTokens = tokens.length;\r\n\r\n        buyRates = new uint256[](numTokens);\r\n        sellRates = new uint256[](numTokens);\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            (buyRates[i], sellRates[i], ,  , ) = getRateWithToken(reserve, tokens[i], tweiAmount);\r\n        }\r\n    }\r\n\r\n    function getReserveRates(\r\n        IKyberReserveExt reserve,\r\n        IERC20Ext[] calldata srcs,\r\n        IERC20Ext[] calldata dests\r\n    )\r\n        external view returns(uint256[] memory pricingRates, uint256[] memory sanityRates)\r\n    {\r\n        require(srcs.length == dests.length, \"srcs length != dests\");\r\n\r\n        pricingRates = new uint256[](srcs.length);\r\n        sanityRates = new uint256[](srcs.length);\r\n        IKyberSanity sanityRateContract;\r\n        IConversionRates conversionRateContract;\r\n\r\n        try reserve.sanityRatesContract() returns (IKyberSanity sanityContract) {\r\n            sanityRateContract = sanityContract;\r\n        } catch {\r\n            revert(\"no sanityRate contract\");\r\n        }\r\n\r\n        try reserve.conversionRatesContract() returns (IConversionRates ratesContract) {\r\n            conversionRateContract = ratesContract;\r\n        } catch {\r\n            revert(\"no conversionRate contract\");\r\n        }\r\n\r\n        for (uint256 i = 0 ; i < srcs.length ; i++) {\r\n\r\n            if (reserve.sanityRatesContract() != IKyberSanity(0x0)) {\r\n                sanityRates[i] = reserve.sanityRatesContract().getSanityRate(srcs[i], dests[i]);\r\n            }\r\n\r\n            pricingRates[i] = reserve.conversionRatesContract().getRate(\r\n                srcs[i] == ETH_TOKEN_ADDRESS ? dests[i] : srcs[i],\r\n                block.number,\r\n                srcs[i] == ETH_TOKEN_ADDRESS ? true : false,\r\n                0);\r\n        }\r\n    }\r\n\r\n    function getRateWithEth(IKyberReserveExt reserve, IERC20Ext token, uint256 weiAmount)\r\n        public view \r\n        returns(\r\n            uint256 reserveSellRate,\r\n            uint256 reserveBuyRate,\r\n            uint256 pricingSellRate,\r\n            uint256 pricingBuyRate,\r\n            uint256 tweiAmount\r\n        )\r\n    {\r\n        IConversionRates conversionRate = reserve.conversionRatesContract();\r\n\r\n        reserveBuyRate = IKyberReserveExt(reserve).getConversionRate(\r\n                    ETH_TOKEN_ADDRESS,\r\n                    token,\r\n                    weiAmount,\r\n                    block.number\r\n                );\r\n\r\n        pricingBuyRate = conversionRate.getRate(token, block.number, true, weiAmount);\r\n\r\n        tweiAmount = calcDestAmount(\r\n            ETH_TOKEN_ADDRESS, \r\n            token, \r\n            weiAmount, \r\n            reserveBuyRate == 0 ? pricingBuyRate : reserveBuyRate);\r\n\r\n        reserveSellRate = reserve.getConversionRate(\r\n                    token,\r\n                    ETH_TOKEN_ADDRESS,\r\n                    tweiAmount,\r\n                    block.number\r\n                );\r\n                \r\n        pricingSellRate = conversionRate.getRate(token, block.number, false, tweiAmount);\r\n    }\r\n\r\n    function getRateWithToken(IKyberReserveExt reserve, IERC20Ext token, uint256 tweiAmount)\r\n        public view \r\n        returns(\r\n            uint256 reserveBuyRate, \r\n            uint256 reserveSellRate, \r\n            uint256 pricingBuyRate,\r\n            uint256 pricingSellRate,\r\n            uint256 weiAmount\r\n        ) \r\n    {\r\n        IConversionRates conversionRate = reserve.conversionRatesContract();\r\n\r\n        reserveSellRate = IKyberReserveExt(reserve).getConversionRate(\r\n                token,\r\n                ETH_TOKEN_ADDRESS,\r\n                tweiAmount,\r\n                block.number\r\n            );\r\n\r\n        pricingSellRate = conversionRate.getRate(token, block.number, false, tweiAmount);\r\n\r\n        weiAmount = calcDestAmount(\r\n                token, \r\n                ETH_TOKEN_ADDRESS, \r\n                tweiAmount,\r\n                reserveSellRate == 0 ? pricingSellRate : reserveSellRate\r\n            );\r\n\r\n        reserveBuyRate = IKyberReserveExt(reserve).getConversionRate(\r\n                ETH_TOKEN_ADDRESS,\r\n                token,\r\n                weiAmount,\r\n                block.number\r\n            );\r\n\r\n        pricingBuyRate = conversionRate.getRate(token, block.number, true, weiAmount);\r\n    }\r\n}"
    }
  }
}