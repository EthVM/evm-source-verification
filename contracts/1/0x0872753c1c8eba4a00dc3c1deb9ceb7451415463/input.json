{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/aston.sol":{"content":"pragma solidity ^0.6.1;\r\n//Library for safe math\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n    \r\n    //Mian Business contract is drived from owner contract\r\n        contract Aston{\r\n                address payable public owner;// owner address\r\n                // for partners to share commission\r\n                address payable creator1;\r\n                address payable creator2;\r\n                address payable creator3;\r\n                address payable creator4;\r\n        \r\n        // owner contract modifier\r\n                using SafeMath for uint256;\r\n                uint256 commission;\r\n                string public session;\r\n        //struct for user    \r\n        struct user\r\n        {\r\n        bool isExist;         //for user existance\r\n        bool isRecomended;    //for checking is Recommended or not\r\n        uint256 earning;      //earnings from investments\r\n        uint256 id;           // user id\r\n        uint256 recomendation; //for recomendation counter\r\n        uint256 creationTime;  //creationTime counter\r\n        uint256 total_Days;    //total_Days counter\r\n        uint256 total_Amount;  //total_Amount counter earnings\r\n        uint256 level;         //level counter  // ref_Income earn by levels \r\n        uint256 referBy;       //refferer address\r\n        bool expirePeriod;    //session expired\r\n        uint256 visit;         //number of customer invested in this program\r\n        uint256 ref_Income; \r\n        address[] reffrals;    //number of reffrals by You\r\n        uint256 total_Withdraw;\r\n        }\r\n        user[] userList;      \r\n        uint256 cuurUserID=0;//List of all users\r\n        //mappings\r\n        mapping(address=>user)public users; //enter address to get user\r\n        mapping(address=>address payable)public recomendators;//number of people come through one person\r\n        mapping(address=>uint256)public invested;           //how much user invested\r\n        mapping(address=>bool)public isInvested;            //check user invested or not\r\n        mapping(uint256=>address payable)public userAddress;  //enter use id and get address\r\n       //Events\r\n       // for registration\r\n       //for Recommend event\r\n       event Recommend(address _user,address _refference,uint256 referBy);\r\n        // For WithDrawl event\r\n       event    WithDrawl(address user,uint256 earning);\r\n    \r\n       //constructor\r\n       constructor() payable public{\r\n            owner=msg.sender;\r\n            creator1=0xF161abA3a2cc544133C41d28D35c6d20B7f5754B;\r\n            creator2=0x77dC753d9c15Fae33eC91422342130D79ff3F84b;\r\n            creator3=0xf242aA1C641591DDe68c598A3C9eAa285794ae80;\r\n            creator4=0xa5a625D3CC186Fa68aa4EeCa7D29b1b6154f4201;\r\n            cuurUserID++;\r\n            user memory obj =user({isExist:true,earning:0,recomendation:0,creationTime:0,total_Days:0,isRecomended:false,id:cuurUserID,\r\n            total_Amount:0,level:0,referBy:0,expirePeriod:false,visit:1,ref_Income:0,total_Withdraw:0,reffrals:new address[](0)});\r\n            userList.push(obj);\r\n            users[msg.sender]= obj;\r\n            userAddress[cuurUserID]=msg.sender;\r\n            isInvested[msg.sender]=true;\r\n            }\r\n\r\n    //modifier\r\n       modifier onlyOwner(){\r\n        require(msg.sender==owner,\"only owner can run this\");\r\n        _;\r\n    }\r\n    modifier onlyFirst(uint256 _refference){ //for Recommend functions\r\n    address a=userAddress[_refference];\r\n        require(users[a].isExist==true); //to check reference should exist before \r\n        require(a!=msg.sender);   //to check investor should not be refferer\r\n        require(users[msg.sender].isExist==false); \r\n        _;\r\n    }\r\n    modifier reinvest(){\r\n            user memory obj=users[msg.sender];\r\n        require(obj.visit>0,\"visit should be above 0\");\r\n        require(obj.earning==0,\"You have to withdraw all your money\");\r\n        bool u=false;\r\n        if(msg.value==0.25 ether || msg.value==0.50 ether && users[msg.sender].visit==1){\r\n            u=true;\r\n        }\r\n        if(msg.value==0.25 ether || msg.value==0.50 ether||msg.value==0.75 ether&& users[msg.sender].visit>1){\r\n            u=true;\r\n        }\r\n    require(u==true,\"you have to enter right amount\");\r\n        _;\r\n    }\r\n    \r\n    function Reinvest()public  payable reinvest  returns(bool){\r\n                require(users[msg.sender].expirePeriod==true,\"your session should be new\");\r\n     require(isInvested[msg.sender]==false);    //investor should not invested before\r\n    invested[msg.sender]= msg.value;\r\n     isInvested[msg.sender]=true;\r\n     users[msg.sender].creationTime=now;\r\n     users[msg.sender].expirePeriod=false;\r\n     users[msg.sender].visit+=1;\r\n     users[msg.sender].total_Withdraw=0;\r\n            return true;\r\n        \r\n    }\r\n    //recommend function\r\n    function reffer(uint256 _refference)public payable  onlyFirst(_refference)    returns(bool){\r\n            require(msg.value==0.25 ether,\"you are new one ans start with 0.25 ether\");\r\n            require(users[msg.sender].visit==0,\"you are already investor\");\r\n            cuurUserID++;\r\n            userAddress[cuurUserID]=msg.sender;\r\n            isInvested[msg.sender]=true;\r\n            invested[msg.sender]= msg.value;\r\n            user memory obj =user({isExist:true,earning:0,recomendation:0,creationTime:now,total_Days:0,isRecomended:true,id:cuurUserID,\r\n            total_Amount:0,level:0,referBy:_refference,expirePeriod:false,visit:1,ref_Income:0,total_Withdraw:0,reffrals:new address[](0)});\r\n            userList.push(obj);\r\n            users[msg.sender]= obj;\r\n            commission=(msg.value.mul(10)).div(100);\r\n            Creators(commission); \r\n            address payable a=userAddress[_refference];\r\n            recomendators[msg.sender]=a;\r\n            users[a].reffrals.push(msg.sender);\r\n            users[a].recomendation+=1;\r\n            if(users[a].level<1){\r\n               users[a].level=1;\r\n            }\r\n            emit Recommend(msg.sender,a,_refference);\r\n            return true;\r\n    }\r\n    // Add_daily_Income function\r\n    function daily_Income()public   returns(bool){\r\n        uint256 d;\r\n        \r\n        user memory obj=users[msg.sender];\r\n      uint256  t=obj.total_Days;\r\n      uint256  p=obj.total_Amount;\r\n        require(obj.expirePeriod==false,\"your seesion has expired\");\r\n        uint256 time=now - obj.creationTime;\r\n      uint256 daysCount=time.div(86400);\r\n      users[msg.sender].total_Days+=daysCount;\r\n      t+=daysCount;\r\n      \r\n          require(isInvested[msg.sender]==true);\r\n          \r\n        uint256  c=(invested[msg.sender].mul(1)).div(100);\r\n       d=c.mul(daysCount);\r\n        users[msg.sender].total_Amount+=d;\r\n        p+=d;\r\n        if(t>=401 || p>=invested[msg.sender].mul(4)){\r\n            // users[msg.sender].expirePeriod=true;\r\n           session = session_Expire();\r\n            return true;\r\n        }\r\n        else{\r\n        users[msg.sender].earning+=d;\r\n        // assert(obj.total_Amount<=invested[msg.sender].mul(4));\r\n         if(obj.isRecomended==true){\r\n             user memory obj1;\r\n            address payable m=recomendators[msg.sender];\r\n            obj1= users[m];\r\n            \r\n        \r\n            if(obj1.expirePeriod==false){\r\n            users[m].earning+=d;\r\n            users[m].total_Amount+=d;\r\n            users[m].ref_Income+=d;}\r\n            if(obj1.isRecomended==true){\r\n                    uint256 f=(d.mul(10)).div(100);\r\n                uint256 depth=1;\r\n             down_Income(m,depth,f);\r\n            }\r\n        }\r\n        if(daysCount>0){\r\n        users[msg.sender].creationTime=now;\r\n        }\r\n        }\r\n        return true;\r\n    }\r\n    //distribute function\r\n    function down_Income(address payable add,uint256 _depth,uint256 _f)private  returns (bool){\r\n        _depth++;\r\n        if(_depth>10){\r\n            return true;\r\n        }\r\n         user memory obj1=users[add];\r\n         if(obj1.isRecomended==true){\r\n             address payable add1=recomendators[add];\r\n             user memory obj2=users[add1];\r\n             if(obj2.recomendation>=_depth){\r\n                 if(obj2.expirePeriod==false){\r\n                 users[add1].earning+=_f;\r\n                 users[add1].total_Amount+=_f;\r\n                 users[add1].ref_Income+=_f;}\r\n                 if(obj2.level<_depth){\r\n                 users[add1].level=_depth;\r\n                 }\r\n             }\r\n                 down_Income(add1,_depth,_f);\r\n             }\r\n             \r\n         \r\n        return true;\r\n    }\r\n    //withDrawl function\r\n    function withDraw(uint256 _value)public payable returns(string memory){\r\n        address payable r=msg.sender;\r\n        user memory obj=users[r];\r\n        require(obj.earning>=_value,\"you are trying to withdraw amount higher than your earnings\");\r\n        require(obj.earning>0,\"your earning is 0\");\r\n        require(address(this).balance>_value,\"contract has less amount\");\r\n        require(obj.total_Withdraw<invested[msg.sender].mul(4) ,\"you are already withdraw all amount\");\r\n         \r\n                  if(obj.earning.add(obj.total_Withdraw)>invested[msg.sender].mul(4)){\r\n                      uint256 h=obj.earning;\r\n                     uint256 x=(invested[msg.sender].mul(4)).sub(obj.total_Withdraw);\r\n                     uint256 a=obj.earning.sub(x);\r\n                     \r\n                     h=h.sub(a);\r\n                      r.transfer(h);\r\n                  users[msg.sender].earning=0;\r\n                  users[msg.sender].total_Withdraw=obj.total_Withdraw.add(h);\r\n                //   users[msg.sender].expirePeriod=true;\r\n                session=session_Expire();\r\n                  return \"you have WithDraw all your profit\";\r\n                  }\r\n                  else{\r\n                        users[msg.sender].total_Withdraw=obj.total_Withdraw.add(_value);\r\n                        users[msg.sender].earning=obj.earning.sub(_value);\r\n                        r.transfer(_value);   \r\n                        return \"you have succesfully WithDrawl your money\";\r\n                  }\r\n               \r\n                      }\r\n        receive () external payable{\r\n        }\r\n        \r\n    // private functions\r\n    // expire function\r\n    function session_Expire()private  returns(string memory){ //to invest again you have to expire first\r\n     users[msg.sender].total_Days=0;\r\n     users[msg.sender].total_Amount=0; \r\n     users[msg.sender].expirePeriod=true;\r\n     users[msg.sender].ref_Income=0;\r\n     isInvested[msg.sender]=false;\r\n        return \"your session has expired\";\r\n    }\r\n    // forCreators function\r\n    function Creators(uint256 _value)private returns(bool ){\r\n        uint256 p=_value.div(4);\r\n        creator1.transfer(p);\r\n        creator2.transfer(p);\r\n        creator3.transfer(p);\r\n        creator4.transfer(p);\r\n        return true;\r\n    }\r\n    //Owner functions\r\n       function changeOwnership(address payable newOwner)public onlyOwner returns(bool){\r\n        owner=newOwner;\r\n        return true;\r\n    }    \r\n    function owner_fund()public payable onlyOwner returns (bool){\r\n        owner.transfer(address(this).balance);\r\n        return true;\r\n    }\r\n    function get_Tree(address wallet)public view returns(address[] memory){\r\n        user memory obj=users[wallet];\r\n        return obj.reffrals;\r\n    }\r\n    function change_creator(address payable _newAddress,address _oldAddress)public onlyOwner returns(string memory){\r\n        if(creator1==_oldAddress){\r\n            creator1=_newAddress;\r\n        }\r\n        else if(creator2==_oldAddress){\r\n            creator2=_newAddress;\r\n        }\r\n        else if(creator3==_oldAddress){\r\n            creator3=_newAddress;\r\n        }\r\n        else if(creator4==_oldAddress){\r\n            creator4=_newAddress;\r\n        }\r\n        else{\r\n            return \"your address does not found\";\r\n        }\r\n        return \"your address succesfuly changed\";\r\n    }\r\n    function close() public payable onlyOwner { //onlyOwner is custom modifier\r\n  selfdestruct(owner);  // `owner` is the owners address\r\n}\r\nfunction owner_withdraw()public payable onlyOwner returns (bool){\r\n    user memory obj=users[owner];\r\n    require(obj.earning>0,\"your earnings are less than 0\");\r\n    owner.transfer(obj.earning);\r\n    users[owner].earning=0;\r\n    return true;\r\n}\r\n \r\n}"}}}