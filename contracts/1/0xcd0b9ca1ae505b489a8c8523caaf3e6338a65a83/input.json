{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "SURFstacker.sol": {
      "content": "pragma solidity ^0.6.12;\r\n\r\ninterface Router {\r\n\tfunction WETH() external pure returns (address);\r\n\tfunction swapExactETHForTokens(uint256 _amountOutMin, address[] calldata _path, address _to, uint256 _deadline) external payable returns (uint256[] memory);\r\n}\r\n\r\ninterface SURF {\r\n\tfunction whirlpoolAddress() external view returns (address);\r\n\tfunction balanceOf(address) external view returns (uint256);\r\n\tfunction approve(address, uint256) external returns (bool);\r\n\tfunction transfer(address, uint256) external returns (bool);\r\n\tfunction transferFrom(address, address, uint256) external returns (bool);\r\n}\r\n\r\ninterface SURF3d {\r\n\tfunction whirlpoolManager() external view returns (address);\r\n\tfunction dividendsOf(address) external view returns (uint256);\r\n\tfunction buyFor(uint256, address) external returns (uint256);\r\n\tfunction withdraw() external returns (uint256);\r\n}\r\n\r\ninterface Whirlpool {\r\n\tfunction userInfo(address) external view returns (uint256, uint256, uint256);\r\n\tfunction claim() external;\r\n}\r\n\r\ncontract SURFstacker {\r\n\r\n\tuint256 constant private FLOAT_SCALAR = 2**64;\r\n\tuint256 constant private MIN_DEPOSIT = 1e20; // 100 SURF min\r\n\tuint256 constant private MAX_DEPOSIT = 1e22; // 10,000 SURF max\r\n\tuint256 constant private RETURN = 115; // deposit + 15% extra repaid\r\n\tuint256 constant private S3D_BUY = 382; // 38.2% of deposits buy S3D for the WhirlpoolManager contract\r\n\r\n\tstruct Deposit {\r\n\t\taddress user;\r\n\t\tuint96 timestamp;\r\n\t\tuint128 deposit;\r\n\t\tuint128 paid;\r\n\t}\r\n\r\n\tstruct Info {\r\n\t\tDeposit[] queue;\r\n\t\tuint256 paidToIndex;\r\n\t\tuint256 totalDeposited;\r\n\t\tmapping(address => uint256) deposits;\r\n\t\tuint256 openingBlock;\r\n\t\tRouter router;\r\n\t\tSURF surf;\r\n\t\tSURF3d s3d;\r\n\t\tWhirlpool whirlpool;\r\n\t}\r\n\tInfo private info;\r\n\t\r\n\r\n\tevent Deposited(uint256 indexed index, address indexed user, uint256 amount);\r\n\tevent Paid(uint256 indexed index, address indexed user, uint256 amount);\r\n\tevent PaidOff(uint256 indexed index, address indexed user, uint256 totalPaid);\r\n\r\n\r\n\tconstructor(address _surf, address _s3d, uint256 _openingBlock) public {\r\n\t\tinfo.router = Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\t\tinfo.surf = SURF(_surf);\r\n\t\tinfo.s3d = SURF3d(_s3d);\r\n\t\tinfo.whirlpool = Whirlpool(info.surf.whirlpoolAddress());\r\n\t\tinfo.openingBlock = _openingBlock;\r\n\t}\r\n\r\n\treceive() external payable {\r\n\t\tif (msg.sender == tx.origin) {\r\n\t\t\tdeposit();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction deposit() public payable {\r\n\t\tdepositFor(msg.sender);\r\n\t}\r\n\r\n\tfunction depositFor(address _user) public payable {\r\n\t\trequire(msg.value > 0);\r\n\t\t_depositETH(msg.value, _user);\r\n\t}\r\n\r\n\tfunction buy(uint256 _amount) external {\r\n\t\tbuyFor(_amount, msg.sender);\r\n\t}\r\n\r\n\tfunction buyFor(uint256 _amount, address _user) public {\r\n\t\tuint256 _balanceBefore = info.surf.balanceOf(address(this));\r\n\t\tinfo.surf.transferFrom(msg.sender, address(this), _amount);\r\n\t\tuint256 _amountReceived = info.surf.balanceOf(address(this)) - _balanceBefore;\r\n\t\t_deposit(_amountReceived, _user);\r\n\t}\r\n\r\n\tfunction tokenCallback(address _from, uint256 _tokens, bytes calldata) external returns (bool) {\r\n\t\trequire(msg.sender == address(info.surf));\r\n\t\t_deposit(_tokens, _from);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction processDividends() external {\r\n\t\tuint256 _balanceBefore = info.surf.balanceOf(address(this));\r\n\t\tif (info.s3d.dividendsOf(address(this)) > 0) {\r\n\t\t\tinfo.s3d.withdraw();\r\n\t\t}\r\n\t\t(uint256 _staked, , ) = info.whirlpool.userInfo(address(this));\r\n\t\tif (_staked > 0) {\r\n\t\t\tinfo.whirlpool.claim();\r\n\t\t}\r\n\t\tuint256 _amountReceived = info.surf.balanceOf(address(this)) - _balanceBefore;\r\n\t\tif (_amountReceived > 0) {\r\n\t\t\t_process(_amountReceived);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction allInfoFor(address _user) external view returns (uint256 totalDeposits, uint256 paidToIndex, uint256 totalDeposited, uint256 openingBlock, uint256 currentBlock, uint256 userETH, uint256 userSURF, uint256 userDeposit) {\r\n\t\ttotalDeposits = info.queue.length;\r\n\t\tpaidToIndex = info.paidToIndex;\r\n\t\ttotalDeposited = info.totalDeposited;\r\n\t\topeningBlock = info.openingBlock;\r\n\t\tcurrentBlock = block.number;\r\n\t\tuserETH = _user.balance;\r\n\t\tuserSURF = info.surf.balanceOf(_user);\r\n\t\tuserDeposit = info.deposits[_user];\r\n\t}\r\n\r\n\tfunction getDeposit(uint256 _index) public view returns (address user, uint256 timestamp, uint256 depositAmount, uint256 paid, uint256 remaining) {\r\n\t\trequire(_index < info.queue.length);\r\n\t\tDeposit memory _dep = info.queue[_index];\r\n\t\tuser = _dep.user;\r\n\t\ttimestamp = _dep.timestamp;\r\n\t\tdepositAmount = _dep.deposit;\r\n\t\tpaid = _dep.paid;\r\n\t\tremaining = RETURN * depositAmount / 100 - paid;\r\n\t}\r\n\r\n\tfunction getDeposits(uint256[] memory _indexes) public view returns (address[] memory users, uint256[] memory timestamps, uint256[] memory deposits, uint256[] memory paids, uint256[] memory remainings) {\r\n\t\tuint256 _length = _indexes.length;\r\n\t\tusers = new address[](_length);\r\n\t\ttimestamps = new uint256[](_length);\r\n\t\tdeposits = new uint256[](_length);\r\n\t\tpaids = new uint256[](_length);\r\n\t\tremainings = new uint256[](_length);\r\n\t\tfor (uint256 i = 0; i < _length; i++) {\r\n\t\t\t(users[i], timestamps[i], deposits[i], paids[i], remainings[i]) = getDeposit(_indexes[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getDepositsTable(uint256 _limit, uint256 _page, bool _isAsc, bool _onlyUnpaid) external view returns (uint256[] memory indexes, address[] memory users, uint256[] memory timestamps, uint256[] memory deposits, uint256[] memory paids, uint256[] memory remainings, uint256 totalDeposits, uint256 totalPages) {\r\n\t\trequire(_limit > 0);\r\n\t\ttotalDeposits = info.queue.length - (_onlyUnpaid ? info.paidToIndex : 0);\r\n\r\n\t\tif (totalDeposits > 0) {\r\n\t\t\ttotalPages = (totalDeposits / _limit) + (totalDeposits % _limit == 0 ? 0 : 1);\r\n\t\t\trequire(_page < totalPages);\r\n\r\n\t\t\tuint256 _offset = _limit * _page;\r\n\t\t\tif (_page == totalPages - 1 && totalDeposits % _limit != 0) {\r\n\t\t\t\t_limit = totalDeposits % _limit;\r\n\t\t\t}\r\n\r\n\t\t\tindexes = new uint256[](_limit);\r\n\t\t\tfor (uint256 i = 0; i < _limit; i++) {\r\n\t\t\t\tindexes[i] = (_isAsc ? _offset + i : totalDeposits - _offset - i - 1) + (_onlyUnpaid ? info.paidToIndex : 0);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttotalPages = 0;\r\n\t\t\tindexes = new uint256[](0);\r\n\t\t}\r\n\t\t(users, timestamps, deposits, paids, remainings) = getDeposits(indexes);\r\n\t}\r\n\r\n\r\n\tfunction _depositETH(uint256 _value, address _user) internal {\r\n\t\tuint256 _balanceBefore = info.surf.balanceOf(address(this));\r\n\t\taddress[] memory _poolPath = new address[](2);\r\n\t\t_poolPath[0] = info.router.WETH();\r\n\t\t_poolPath[1] = address(info.surf);\r\n\t\tinfo.router.swapExactETHForTokens{value: _value}(0, _poolPath, address(this), block.timestamp + 5 minutes);\r\n\t\tuint256 _amount = info.surf.balanceOf(address(this)) - _balanceBefore;\r\n\t\t_deposit(_amount, _user);\r\n\t}\r\n\r\n\tfunction _deposit(uint256 _amount, address _user) internal {\r\n\t\trequire(block.number >= info.openingBlock && _amount >= MIN_DEPOSIT && _amount <= MAX_DEPOSIT);\r\n\r\n\t\tDeposit memory _newDeposit = Deposit({\r\n\t\t\tuser: _user,\r\n\t\t\ttimestamp: uint96(block.timestamp),\r\n\t\t\tdeposit: uint128(_amount),\r\n\t\t\tpaid: 0\r\n\t\t});\r\n\t\tinfo.queue.push(_newDeposit);\r\n\t\tinfo.totalDeposited += _amount;\r\n\t\tinfo.deposits[_user] += _amount;\r\n\t\temit Deposited(info.queue.length - 1, _user, _amount);\r\n\r\n\t\tuint256 _s3dBuyAmount = S3D_BUY * _amount / 1000;\r\n\t\t_purchaseS3D(_s3dBuyAmount);\r\n\r\n\t\tuint256 _amountPayable = _amount - _s3dBuyAmount;\r\n\t\t_process(_amountPayable);\r\n\t}\r\n\r\n\tfunction _purchaseS3D(uint256 _amount) internal {\r\n\t\tinfo.surf.approve(address(info.s3d), _amount);\r\n\t\tinfo.s3d.buyFor(_amount, info.s3d.whirlpoolManager());\r\n\t}\r\n\r\n\tfunction _process(uint256 _amount) internal {\r\n\t\twhile (_amount > 0) {\r\n\t\t\tuint256 _currentIndex = info.paidToIndex;\r\n\t\t\tif (_currentIndex >= info.queue.length) {\r\n\t\t\t\t_purchaseS3D(_amount);\r\n\t\t\t\t_amount = 0;\r\n\t\t\t} else {\r\n\t\t\t\tDeposit storage _currentDeposit = info.queue[_currentIndex];\r\n\t\t\t\tuint256 _amountPayable = _amount;\r\n\t\t\t\tuint256 _totalPayable = RETURN * _currentDeposit.deposit / 100;\r\n\t\t\t\tuint256 _amountRemaining = _totalPayable - _currentDeposit.paid;\r\n\t\t\t\tif (_amountRemaining <= _amountPayable) {\r\n\t\t\t\t\t_amountPayable = _amountRemaining;\r\n\t\t\t\t\temit PaidOff(_currentIndex, _currentDeposit.user, _totalPayable);\r\n\t\t\t\t\tinfo.paidToIndex++;\r\n\t\t\t\t}\r\n\t\t\t\t_currentDeposit.paid += uint128(_amountPayable);\r\n\t\t\t\tinfo.surf.transfer(_currentDeposit.user, _amountPayable);\r\n\t\t\t\temit Paid(_currentIndex, _currentDeposit.user, _amountPayable);\r\n\t\t\t\t_amount -= _amountPayable;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}"
    }
  }
}