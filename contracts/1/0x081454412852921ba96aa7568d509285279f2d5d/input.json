{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"QuantumSC.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\ncontract QuantumSC {\r\n  uint public quantityLevelsPool;\r\n  address private ownerAddress;\r\n  address private investorsAddress;\r\n  address private adminAddress;\r\n  uint public controllerUserId;\r\n\r\n  struct LevelPool {\r\n    uint level;\r\n    bool status;\r\n    uint price;\r\n    uint reinvestments;\r\n    mapping(uint => address[]) partners;\r\n  }\r\n\r\n  struct User {\r\n    uint id;\r\n    address userAddress;\r\n    address sponsor;\r\n    uint balance;\r\n    mapping(uint => LevelPool) levelsPool;\r\n  }\r\n\r\n  mapping(address => User) public users;\r\n\r\n  struct LevelManagerPool {\r\n    uint usersQuantityController;\r\n    uint currentTurnContoller;\r\n    uint accumulateBalanceLevel;\r\n    mapping(uint => address) userAddressForTurn;\r\n  }\r\n\r\n  mapping(uint => LevelManagerPool) public levelManagerPool;\r\n\r\n  mapping(uint => uint) public levelPricesMigratePool;\r\n  mapping(uint => uint) public buyLevelSurplusBalancePool;\r\n\r\n  event UserRegisterEvent(address indexed user, uint id);\r\n  event BuyLevelEvent(address indexed user, uint id, uint level);\r\n\r\n  constructor() public {\r\n    setInitialData();\r\n    setTurnsPool();\r\n    setLevelPricesMigrateAndSurplus();\r\n    adminUsersRegistration(ownerAddress, true);\r\n    adminUsersRegistration(investorsAddress, false);\r\n  }\r\n\r\n  function setLevelPricesMigrateAndSurplus() private {\r\n    for (uint i = 1; i <= quantityLevelsPool; i++) {\r\n      if (i == 1) {\r\n        levelPricesMigratePool[i] = 0.04 ether;\r\n      } else if(i == 2) {\r\n        levelPricesMigratePool[i] = levelPricesMigratePool[i-1] * 2;\r\n        buyLevelSurplusBalancePool[i] = 0.02 ether;\r\n      } else {\r\n        levelPricesMigratePool[i] = levelPricesMigratePool[i-1] * 2;\r\n        buyLevelSurplusBalancePool[i] = buyLevelSurplusBalancePool[i-1] * 2;\r\n      }\r\n    }\r\n  }\r\n\r\n  function setInitialData() private {\r\n    ownerAddress = msg.sender;\r\n    investorsAddress = 0x0E5ae5a5CF40351A80c039CFA05266565bc0be62;\r\n    adminAddress = 0x1c1399229ca9CB653f23fdE549bC3Ab79D8A9E7a;\r\n    quantityLevelsPool = 13;\r\n    controllerUserId = 0;\r\n  }\r\n\r\n  function setTurnsPool() private {\r\n    for (uint i = 1; i <= quantityLevelsPool; i++) {\r\n      levelManagerPool[i].usersQuantityController = 0;\r\n      levelManagerPool[i].currentTurnContoller = 1;\r\n      levelManagerPool[i].accumulateBalanceLevel = 0 ether;\r\n    }\r\n  }\r\n\r\n  function adminUsersRegistration(address userAddress, bool isOwner) private {\r\n    controllerUserId ++;\r\n    for (uint j = 1; j <= quantityLevelsPool; j++) {\r\n      levelManagerPool[j].usersQuantityController ++;\r\n    }\r\n    User memory temporaryUser = User(controllerUserId, userAddress, address(0), 0);\r\n    users[userAddress] = temporaryUser;\r\n    setDataLevelsPool(userAddress);\r\n    for (uint k = 1; k <= quantityLevelsPool; k++) {\r\n      users[userAddress].levelsPool[k].status = true;\r\n    }\r\n    for (uint i = 1; i <= quantityLevelsPool; i++) {\r\n      if (isOwner) {\r\n        levelManagerPool[i].userAddressForTurn[1] = userAddress;\r\n      } else {\r\n        levelManagerPool[i].userAddressForTurn[2] = userAddress;\r\n      }\r\n    }\r\n  }\r\n\r\n  function usersRegistration(address sponsor) public validUserRegistration(sponsor) payable {\r\n    controllerUserId ++;\r\n    levelManagerPool[1].usersQuantityController ++;\r\n    User memory temporaryUser = User(controllerUserId, msg.sender, sponsor, 0);\r\n    users[msg.sender] = temporaryUser;\r\n    setDataLevelsPool(msg.sender);\r\n    users[msg.sender].levelsPool[1].status = true;\r\n    levelManagerPool[1].userAddressForTurn[levelManagerPool[1].usersQuantityController] = msg.sender;\r\n    levelManagerPool[1].accumulateBalanceLevel += 0.04 ether;\r\n    transferBalance(adminAddress, 0.03 ether);\r\n    transferBalance(users[msg.sender].sponsor, 0.01 ether);\r\n    validateStatusAllLevels(msg.sender, 1, true);\r\n  }\r\n\r\n  function validateStatusAllLevels(address userAddress, uint startLevel, bool isRegister) private {\r\n    for (uint i = startLevel; i <= quantityLevelsPool; i++) {\r\n      address turnAddress = levelManagerPool[i].userAddressForTurn[levelManagerPool[i].currentTurnContoller];\r\n      uint lengthPartnersArray = users[turnAddress].levelsPool[i].partners[\r\n        users[turnAddress].levelsPool[i].reinvestments\r\n      ].length;\r\n      uint acumulateBalanceInLevel = levelManagerPool[i].accumulateBalanceLevel;\r\n\r\n      uint highestAccumulated = (levelPricesMigratePool[i] + levelPricesMigratePool[i]/2);\r\n      \r\n      if (\r\n        (lengthPartnersArray == 0 && acumulateBalanceInLevel == levelPricesMigratePool[i]) ||\r\n        (lengthPartnersArray == 0 && acumulateBalanceInLevel == highestAccumulated)\r\n      ) {\r\n        if (i == 1) {\r\n          users[turnAddress].levelsPool[i].partners[users[turnAddress].levelsPool[i].reinvestments].push(\r\n            userAddress\r\n          );\r\n        } else {\r\n          users[turnAddress].levelsPool[i].partners[users[turnAddress].levelsPool[i].reinvestments].push(\r\n            levelManagerPool[i].userAddressForTurn[levelManagerPool[i].usersQuantityController]\r\n          );\r\n        }\r\n\r\n        transferBalance(turnAddress, (levelPricesMigratePool[i]*80)/100);\r\n        \r\n        if (users[turnAddress].id == 1 || users[turnAddress].id == 2) {\r\n          transferBalance(ownerAddress, (levelPricesMigratePool[i]*20)/100);\r\n        } else {\r\n          transferBalance(users[turnAddress].sponsor, (levelPricesMigratePool[i]*20)/100);\r\n        }\r\n\r\n        if (acumulateBalanceInLevel == highestAccumulated) {\r\n          levelManagerPool[i].accumulateBalanceLevel = levelPricesMigratePool[i]/2;\r\n        } else {\r\n          levelManagerPool[i].accumulateBalanceLevel = 0 ether;\r\n        }\r\n      } else if (\r\n        (lengthPartnersArray == 1 && acumulateBalanceInLevel == levelPricesMigratePool[i]) ||\r\n        (lengthPartnersArray == 1 && acumulateBalanceInLevel == highestAccumulated)\r\n      ) {\r\n        if (i == 1) {\r\n          users[turnAddress].levelsPool[i].partners[users[turnAddress].levelsPool[i].reinvestments].push(\r\n            userAddress\r\n          );\r\n        } else {\r\n          users[turnAddress].levelsPool[i].partners[users[turnAddress].levelsPool[i].reinvestments].push(\r\n            levelManagerPool[i].userAddressForTurn[levelManagerPool[i].usersQuantityController]\r\n          );\r\n        }\r\n        \r\n        if (i < 13) {\r\n          levelManagerPool[i+1].accumulateBalanceLevel += levelPricesMigratePool[i];\r\n        } else {\r\n          transferBalance(adminAddress, levelPricesMigratePool[i]);\r\n        }\r\n\r\n        if (acumulateBalanceInLevel == highestAccumulated) {\r\n          levelManagerPool[i].accumulateBalanceLevel = levelPricesMigratePool[i]/2;\r\n        } else {\r\n          levelManagerPool[i].accumulateBalanceLevel = 0 ether;\r\n        }\r\n      } else if (\r\n        (lengthPartnersArray == 2 && acumulateBalanceInLevel == levelPricesMigratePool[i]) ||\r\n        (lengthPartnersArray == 2 && acumulateBalanceInLevel == highestAccumulated)\r\n      ) {\r\n        if (i == 1) {\r\n          users[turnAddress].levelsPool[i].partners[users[turnAddress].levelsPool[i].reinvestments].push(\r\n            userAddress\r\n          );\r\n        } else {\r\n          users[turnAddress].levelsPool[i].partners[users[turnAddress].levelsPool[i].reinvestments].push(\r\n            levelManagerPool[i].userAddressForTurn[levelManagerPool[i].usersQuantityController]\r\n          );\r\n        }\r\n        \r\n        if (i < 13) {\r\n          levelManagerPool[i+1].accumulateBalanceLevel += levelPricesMigratePool[i];\r\n          users[turnAddress].levelsPool[i+1].status = true;\r\n          levelManagerPool[i+1].usersQuantityController ++;\r\n          levelManagerPool[i+1].userAddressForTurn[levelManagerPool[i+1].usersQuantityController] = turnAddress;\r\n          levelManagerPool[i].currentTurnContoller ++;\r\n        } else {\r\n          transferBalance(adminAddress, levelPricesMigratePool[i]);\r\n        }\r\n\r\n        if (acumulateBalanceInLevel == highestAccumulated) {\r\n          levelManagerPool[i].accumulateBalanceLevel = levelPricesMigratePool[i]/2;\r\n        } else {\r\n          levelManagerPool[i].accumulateBalanceLevel = 0 ether;\r\n        }\r\n\r\n        users[turnAddress].levelsPool[i].reinvestments ++;\r\n      }\r\n    }\r\n\r\n    if (isRegister) {\r\n      emit UserRegisterEvent(userAddress, users[userAddress].id);\r\n    } else {\r\n      emit BuyLevelEvent(userAddress, users[userAddress].id, startLevel);\r\n    }\r\n  }\r\n  \r\n  function buyLevelPool(uint level) public validLevelBuy(level) payable {\r\n    levelManagerPool[level].usersQuantityController ++;\r\n    users[msg.sender].levelsPool[level].status = true;\r\n    levelManagerPool[level].userAddressForTurn[levelManagerPool[level].usersQuantityController] = msg.sender;\r\n    levelManagerPool[level].accumulateBalanceLevel += levelPricesMigratePool[level];\r\n    transferBalance(users[msg.sender].sponsor, buyLevelSurplusBalancePool[level]);\r\n    validateStatusAllLevels(msg.sender, level, false);\r\n  }\r\n\r\n  function setDataLevelsPool(address userAddress) private {\r\n    uint price = 0.05 ether;\r\n\r\n    for (uint i = 1; i <= quantityLevelsPool; i++) {\r\n      if (i > 1) {\r\n        price = price * 2;\r\n      }\r\n\r\n      users[userAddress].levelsPool[i].level = i;\r\n      users[userAddress].levelsPool[i].status = false;\r\n      users[userAddress].levelsPool[i].price = price;\r\n      users[userAddress].levelsPool[i].reinvestments = 1;\r\n    }\r\n  }\r\n\r\n  function validateUserExists(address userAddress) public view returns(bool) {\r\n    return (users[userAddress].id != 0);\r\n  }\r\n\r\n  function transferBalance(address transferAddress, uint amount) private {\r\n    transferAddress.transfer(amount);\r\n    users[transferAddress].balance += amount;\r\n  }\r\n\r\n  function getDataLevel(address myAddress, uint level, uint reivestment) public view returns(uint, bool, uint, uint, address[]) {\r\n    return (\r\n      users[myAddress].levelsPool[level].level,\r\n      users[myAddress].levelsPool[level].status,\r\n      users[myAddress].levelsPool[level].price,\r\n      users[myAddress].levelsPool[level].reinvestments,\r\n      users[myAddress].levelsPool[level].partners[reivestment]\r\n    );\r\n  }\r\n\r\n  function getTurnUser(uint level) public view returns(address) {\r\n    return (\r\n      levelManagerPool[level].userAddressForTurn[levelManagerPool[level].currentTurnContoller]\r\n    );\r\n  }\r\n\r\n  modifier validUserRegistration(address sponsor) {\r\n    require(msg.value == 0.08 ether, \"0.08 ether is required\");\r\n    require(validateUserExists(sponsor), \"Sponsor does not exists\");\r\n    require(!(validateUserExists(msg.sender)), \"User already exists\");\r\n    _;\r\n  }\r\n\r\n  modifier validLevelBuy(uint level) {\r\n    require((level > 0 && level <= quantityLevelsPool), \"The level does not exist\");\r\n    require(validateUserExists(msg.sender), \"Invalid user\");\r\n    require(!users[msg.sender].levelsPool[level].status, \"Level already purchased\");\r\n    if (level > 1) { require(users[msg.sender].levelsPool[level - 1].status, \"Can not buy this level\"); }\r\n    require(msg.value == users[msg.sender].levelsPool[level].price, \"Value level purchase does not match\");\r\n    _;\r\n  }\r\n  \r\n  function getAccumulateBalanceContract() public view returns(uint) {\r\n    return address(this).balance;\r\n  }\r\n  \r\n  function sendToOwnerAccumulateBalanceContract() validateIsOwner() public {\r\n    ownerAddress.transfer(address(this).balance);\r\n  }\r\n\r\n  modifier validateIsOwner() {\r\n    require((msg.sender == ownerAddress), \"This action in only allowed for owner\");\r\n    _;\r\n  }\r\n}"}}}