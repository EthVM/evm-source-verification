{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ADAMSTAKE.sol":{"content":"pragma solidity ^0.8.10;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address _owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract ADAMSTAKE {\r\n    using SafeMath for uint256;\r\n\r\n    //Variables\r\n    IERC20 public stakeToken;\r\n    IERC20 public rewardToken;\r\n    address payable public owner;\r\n    uint256 public totalUniqueStakers;\r\n    uint256 public totalStaked;\r\n    uint256 public minStake;\r\n    uint256 public constant percentDivider = 100000;\r\n\r\n    //arrays\r\n    uint256[4] public percentages = [0, 0, 0, 0];\r\n    uint256[4] public APY = [8000,9000,10000,11000];\r\n    uint256[4] public durations = [15 days, 30 days, 60 days, 90 days];\r\n\r\n    \r\n    //structures\r\n    struct Stake {\r\n        uint256 stakeTime;\r\n        uint256 withdrawTime;\r\n        uint256 amount;\r\n        uint256 bonus;\r\n        uint256 plan;\r\n        bool withdrawan;\r\n    }\r\n\r\n    struct User {\r\n        uint256 totalstakeduser;\r\n        uint256 stakecount;\r\n        uint256 claimedstakeTokens;\r\n        mapping(uint256 => Stake) stakerecord;\r\n    }\r\n\r\n    //mappings\r\n    mapping(address => User) public users;\r\n    mapping(address => bool) public uniqueStaker;\r\n\r\n    //modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: Not an owner\");\r\n        _;\r\n    }\r\n\r\n    //events\r\n    event Staked(\r\n        address indexed _user,\r\n        uint256 indexed _amount,\r\n        uint256 indexed _Time\r\n    );\r\n\r\n    \r\n\r\n    event Withdrawn(\r\n        address indexed _user,\r\n        uint256 indexed _amount,\r\n        uint256 indexed _Time\r\n    );\r\n\r\n    event UNIQUESTAKERS(address indexed _user);\r\n\r\n    // constructor\r\n    constructor() {\r\n        owner = payable(msg.sender);\r\n        stakeToken = IERC20(0xca7b3ba66556C4Da2E2A9AFeF9C64F909A59430a);\r\n        rewardToken = IERC20(0x5dD17EAaeeCE9f5E6CC27aF42861B8769C82E447);\r\n        minStake = 7500000000000;\r\n        minStake = minStake.mul(10**stakeToken.decimals());\r\n        for(uint256 i ; i < percentages.length;i++){\r\n            percentages[i] = APYtoPercentage(APY[i], durations[i].div(1 days));\r\n        }\r\n\r\n    }\r\n\r\n    // functions\r\n\r\n\r\n    //writeable\r\n    function stake(uint256 amount, uint256 plan) public {\r\n        require(plan >= 0 && plan < 5, \"put valid plan details\");\r\n        require(\r\n            amount >= minStake,\r\n            \"cant deposit need to stake more than minimum amount\"\r\n        );\r\n        if (!uniqueStaker[msg.sender]) {\r\n            uniqueStaker[msg.sender] = true;\r\n            totalUniqueStakers++;\r\n            emit UNIQUESTAKERS(msg.sender);\r\n        }\r\n        User storage user = users[msg.sender];\r\n        stakeToken.transferFrom(msg.sender, owner, amount);\r\n        user.totalstakeduser += amount;\r\n        user.stakerecord[user.stakecount].plan = plan;\r\n        user.stakerecord[user.stakecount].stakeTime = block.timestamp;\r\n        user.stakerecord[user.stakecount].amount = amount;\r\n        user.stakerecord[user.stakecount].withdrawTime = block.timestamp.add(durations[plan]);\r\n        user.stakerecord[user.stakecount].bonus = amount.mul(percentages[plan]).div(percentDivider);\r\n        user.stakecount++;\r\n        totalStaked += amount;\r\n        emit Staked(msg.sender, amount, block.timestamp);\r\n    }\r\n\r\n    function withdraw(uint256 count) public {\r\n        User storage user = users[msg.sender];\r\n        require(user.stakecount >= count, \"Invalid Stake index\");\r\n        require(\r\n            !user.stakerecord[count].withdrawan,\r\n            \" withdraw completed \"\r\n        );\r\n        stakeToken.transferFrom(\r\n            owner,\r\n            msg.sender,\r\n            user.stakerecord[count].amount\r\n        );\r\n        rewardToken.transferFrom(\r\n            owner,\r\n            msg.sender,\r\n            user.stakerecord[count].bonus\r\n        );\r\n        user.claimedstakeTokens += user.stakerecord[count].amount;\r\n        user.claimedstakeTokens += user.stakerecord[count].bonus;\r\n        user.stakerecord[count].withdrawan = true;\r\n        emit Withdrawn(\r\n            msg.sender,\r\n            user.stakerecord[count].amount,\r\n            block.timestamp);\r\n    }\r\n\r\n    function changeOwner(address payable _newOwner) external onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function migrateStuckFunds() external onlyOwner {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n    function migratelostToken(address lostToken) external onlyOwner {\r\n        IERC20(lostToken).transfer(\r\n            owner,\r\n            IERC20(lostToken).balanceOf(address(this))\r\n        );\r\n    }\r\n    function setminimumtokens(uint256 amount) external onlyOwner {\r\n        minStake = amount;\r\n    }\r\n    function setStakeToken(IERC20 token) external onlyOwner {\r\n        stakeToken = token;\r\n    }\r\n    function setRewardtoken(IERC20 token) external onlyOwner {\r\n        rewardToken = token;\r\n    }\r\n    function setpercentages(uint256 amount1,uint256 amount2,uint256 amount3,uint256 amount4) external onlyOwner {\r\n        percentages[0] = amount1;\r\n        percentages[1] = amount2;\r\n        percentages[2] = amount3;\r\n        percentages[3] = amount4;\r\n    }\r\n\r\n    //readable\r\n    function APYtoPercentage(uint256 apy, uint256 duration) public pure returns(uint256){\r\n        return apy.mul(duration).div(365);\r\n    }\r\n    function stakedetails(address add, uint256 count)\r\n        public\r\n        view\r\n        returns (\r\n        // uint256 stakeTime,\r\n        uint256 withdrawTime,\r\n        uint256 amount,\r\n        uint256 bonus,\r\n        uint256 plan,\r\n        bool withdrawan\r\n        )\r\n    {\r\n        return (\r\n            // users[add].stakerecord[count].stakeTime,\r\n            users[add].stakerecord[count].withdrawTime,\r\n            users[add].stakerecord[count].amount,\r\n            users[add].stakerecord[count].bonus,\r\n            users[add].stakerecord[count].plan,\r\n            users[add].stakerecord[count].withdrawan\r\n        );\r\n    }\r\n\r\n    function calculateRewards(uint256 amount, uint256 plan)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return amount.mul(percentages[plan]).div(percentDivider);\r\n    }\r\n\r\n    function currentStaked(address add) external view returns (uint256) {\r\n        uint256 currentstaked;\r\n        for (uint256 i; i < users[add].stakecount; i++) {\r\n            if (!users[add].stakerecord[i].withdrawan) {\r\n                currentstaked += users[add].stakerecord[i].amount;\r\n            }\r\n        }\r\n        return currentstaked;\r\n    }\r\n\r\n    function getContractBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getContractstakeTokenBalance() external view returns (uint256) {\r\n        return stakeToken.allowance(owner, address(this));\r\n    }\r\n\r\n    function getCurrentwithdrawTime() external view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n}\r\n\r\n//library\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"}}}