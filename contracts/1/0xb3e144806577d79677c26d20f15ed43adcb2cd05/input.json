{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Provide.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.2;\r\n\r\n\r\n/// @title Proxy\r\n/// @dev Proxy contract which supports upgrading a singleton implementation delegate.\r\nabstract contract Proxy {\r\n\r\n  /// @dev retrieve the address of the current implementation contract\r\n  /// @return impl address of the current implementation\r\n  function __implementation() public virtual view returns (address impl);\r\n\r\n  /// @dev delegatecall is issued against the current implementation delegate;\r\n  /// any return data is forwarded to the caller.\r\n  fallback() external payable {\r\n    address _impl = __implementation();\r\n    require(_impl != address(0));\r\n\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      calldatacopy(ptr, 0x0, calldatasize())\r\n      let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0x0, 0x0)\r\n      let size := returndatasize()\r\n      returndatacopy(ptr, 0x0, size)\r\n\r\n      switch result\r\n      case 0 { revert(ptr, size) }\r\n      default { return(ptr, size) }\r\n    }\r\n  }\r\n\r\n  /// @dev no-op receipt of ETH\r\n  receive() external payable {}\r\n}\r\n\r\n/// @title UpgradableProxy\r\n/// @dev proxy contract with upgradable implementation delegate address\r\ncontract UpgradableProxy is Proxy {\r\n\r\n  // storage address of the implementation delegate contract address\r\n  bytes32 private constant implStorageAddress = keccak256(\"network.provide.proxy.implementation\");\r\n\r\n  /// @dev event emitted upon upgrade of the implementation address\r\n  /// @param implementation address of the upgraded implementation delegate\r\n  event Upgraded(address indexed implementation);\r\n\r\n  /// @dev retrieve the address of the current implementation contract\r\n  /// @return impl address of the current implementation\r\n  function __implementation() public override view returns (address impl) {\r\n    bytes32 _saddr = implStorageAddress;\r\n    assembly {\r\n      impl := sload(_saddr)\r\n    }\r\n  }\r\n\r\n  /// @dev set the address of the current implementation contract\r\n  /// @param _implementation address representing the new implementation to be set\r\n  function __setImplementation(address _implementation) internal {\r\n    address _current = __implementation();\r\n    require(_current != _implementation, 'given implementation contract address is already set');\r\n\r\n    bytes32 _saddr = implStorageAddress;\r\n    assembly {\r\n      sstore(_saddr, _implementation)\r\n    }\r\n\r\n    emit Upgraded(_implementation);\r\n  }\r\n}\r\n\r\n/// @title UpgradableNetwork\r\n/// @dev provide.network upgradable contracts suite entrypoint\r\ncontract UpgradableNetwork is UpgradableProxy {\r\n\r\n  // storage address of the contract owner\r\n  bytes32 private constant ownerStorageAddress = keccak256(\"network.provide.proxy.owner\");\r\n\r\n  /// @dev event emitted upon a transfer of ownership\r\n  /// @param from address of the previous owner\r\n  /// @param to address of the new owner\r\n  event OwnershipTransferred(address from, address to);\r\n\r\n  /// initialize the contract owner to the sender\r\n  constructor() {\r\n    __setOwner(msg.sender);\r\n  }\r\n\r\n  /// @dev require `msg.sender == owner`\r\n  modifier onlyOwner() {\r\n    require(msg.sender == __owner());\r\n    _;\r\n  }\r\n\r\n  /// @dev read the address of the owner\r\n  /// @return owner_ the address of the owner\r\n  function __owner() public view returns (address owner_) {\r\n    bytes32 _position = ownerStorageAddress;\r\n    assembly {\r\n      owner_ := sload(_position)\r\n    }\r\n  }\r\n\r\n  /// @dev internally set the owner\r\n  /// @param _owner address of the new owner\r\n  function __setOwner(address _owner) internal {\r\n    bytes32 _position = ownerStorageAddress;\r\n    assembly {\r\n      sstore(_position, _owner)\r\n    }\r\n  }\r\n\r\n  /// @dev transfer ownership to the given address\r\n  /// @param _owner address to which ownership will be transferred\r\n  function __transferOwnership(address _owner) public onlyOwner {\r\n    require(_owner != address(0), 'ownership cannot be transferred to 0x');\r\n    emit OwnershipTransferred(__owner(), _owner);\r\n    __setOwner(_owner);\r\n  }\r\n\r\n  /// @dev allows the proxy owner to upgrade the proxy by modifying the implementation contract address\r\n  /// @param _implementation representing the address of the new implementation to be set.\r\n  function __upgrade(address _implementation) public onlyOwner {\r\n    __setImplementation(_implementation);\r\n  }\r\n\r\n  /// @dev upgrade the current implementation delegate contract by modifying the address\r\n  /// and passing calldata to the new implementation for initialization\r\n  /// @param _implementation representing the address of the new implementation to be set.\r\n  /// @param _data represents the msg.data to bet sent in the low level call. This parameter may include the function\r\n  /// signature of the implementation to be called with the needed payload\r\n  function __upgradeInit(address _implementation, bytes calldata _data) public payable onlyOwner {\r\n    __upgrade(_implementation);\r\n    (bool _success,  ) = address(this).call{value: msg.value}(_data);\r\n    require(_success, 'failed to upgrade implementation contract');\r\n  }\r\n}\r\n\r\n/// @title Provide\r\n/// @dev provide.network upgradable entrypoint\r\ncontract Provide is UpgradableNetwork {\r\n\r\n  /// @dev initialize the upgradable proxy entrypoint with\r\n  /// the initial network implementation contract\r\n  constructor(address _network) {\r\n    __setOwner(msg.sender);\r\n\r\n    if (_network != address(0)) {\r\n      __upgrade(_network);\r\n    }\r\n  }\r\n}"}}}