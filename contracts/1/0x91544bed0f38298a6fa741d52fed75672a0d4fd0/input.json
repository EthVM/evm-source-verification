{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"lifeStage.sol":{"content":"pragma solidity 0.5.16;\r\n\r\ncontract lifeStage {\r\n    \r\n    struct User {\r\n        uint id;\r\n        address referrer;\r\n        uint partnersCount;\r\n        uint totalETHEarnings;\r\n        uint zeroBonusStartMonth;\r\n        uint zeroBonusEndMonth;\r\n        uint  zreEarnedETH;\r\n        uint  ldbEarnedETH;\r\n        uint [] userLDBDays;\r\n        uint currLDBDay;\r\n        uint currZREMonth;\r\n        bool zeroBonus;\r\n        \r\n        \r\n        mapping(uint => bool) userZREReceived;\r\n        \r\n        mapping(uint => UserSLAP) userSLAP;\r\n        \r\n        mapping(uint8 => bool) activeA7Levels;\r\n        mapping(uint8 => bool) activeP7Levels;\r\n        \r\n        mapping(uint8 => A7) a7Matrix;\r\n        mapping(uint8 => P7) p7Matrix;\r\n    }\r\n    \r\n    \r\n    struct UserSLAP{\r\n        uint slap;\r\n        uint referralCount;\r\n        bool received;\r\n    }\r\n    \r\n    struct A7 {\r\n        address currentReferrer;\r\n        address[] referrals;\r\n        uint referralsCount;\r\n        bool blocked;\r\n        uint reinvestCount;\r\n    }\r\n    \r\n    struct P7 {\r\n        address currentReferrer;\r\n        address[] firstLevelReferrals;\r\n        address[] secondLevelReferrals;\r\n        uint referralsCount;\r\n        bool blocked;\r\n        uint reinvestCount;\r\n\r\n        address closedPart;\r\n    }\r\n    \r\n    struct divZRERecord\r\n    {\r\n        uint totalDividendCollection;\r\n        uint totalEligibleCount;\r\n        uint nextMonthEligibleCount;\r\n        uint withdrawalCount;\r\n        uint withdrawalDividend;\r\n        bool withdrawStatus;\r\n    }\r\n    \r\n    struct divLDRecord  \r\n    {\r\n        uint totalSLAPCollection;\r\n        uint totalS1EligibleCount;\r\n        uint totalS2EligibleCount;\r\n        uint totalS3EligibleCount;\r\n        uint totalS4EligibleCount;\r\n        uint totalS5EligibleCount;\r\n        bool withdrawStatus;\r\n    }\r\n    \r\n    divLDRecord[] public  LDB;\r\n    divZRERecord[] public ZRE;\r\n\r\n    uint8 public constant LAST_LEVEL = 2;\r\n    uint public oneMonthDuration = 30 days;\r\n    uint public oneDayDuration = 1 days;\r\n    uint public thisMonthEnd;\r\n    uint public thisDayEnd;\r\n    uint public adminLDBCommission;\r\n    uint public adminZRECommission;\r\n    bool public lockStatus;\r\n    \r\n    mapping(address => User) public users;\r\n    mapping(uint => address) public idToAddress;\r\n\r\n    uint public lastUserId = 2;\r\n    address public owner;\r\n    uint public LDBPrice = 0.05 ether;\r\n    uint public SLAPPrice = LDBPrice*(80 ether)/(100 ether);\r\n    uint public LDBAdminCommission = LDBPrice*(20 ether)/(100 ether);\r\n    uint public ZREPrice = (SLAPPrice * (20 ether)/(100 ether));\r\n    uint public LDBDisPrice = 80 ether;\r\n    uint public ZREETHLimit = 0.3 ether;\r\n    \r\n    uint public totalEarnedETH=0;\r\n    uint public currLDB;\r\n    uint public currZRE;\r\n    \r\n    mapping(uint8 => uint) public levelPrice;\r\n    \r\n    event Registration(address indexed user, address indexed referrer, uint indexed userId, uint referrerId, uint _time);\r\n    event Reinvest(address indexed user, address indexed currentReferrer, address indexed caller, uint8 matrix, uint8 level, uint _time);\r\n    event Upgrade(address indexed user, address indexed referrer, uint8 matrix, uint8 level, uint _time);\r\n    event NewUserPlace(address indexed user, address indexed referrer, uint8 matrix, uint8 level, uint8 place, uint _time);\r\n    event MissedEthReceive(address indexed receiver, address indexed from, uint8 matrix, uint8 level, uint _time);\r\n    event SentExtraEthDividends(address indexed from, address indexed receiver, uint8 matrix, uint8 level, uint _time);\r\n    event LDBWithdrawal(address indexed _user, uint indexed _day, uint _amount, uint _time);\r\n    event ZREWithdrawal(address indexed _user, uint indexed _month, uint _amount, uint _time);\r\n    \r\n    \r\n    constructor() public {\r\n        levelPrice[1] = 0.05 ether;\r\n        levelPrice[2] = 0.1 ether;\r\n        // for (uint8 i = 2; i <= LAST_LEVEL; i++) {\r\n        //     levelPrice[i] = levelPrice[i-1] * 2;\r\n        // }\r\n        \r\n        owner = msg.sender;\r\n        \r\n        User memory user = User({\r\n            id: 1,\r\n            referrer: address(0),\r\n            partnersCount: uint(0),\r\n            totalETHEarnings:0,\r\n            zeroBonusStartMonth:0,\r\n            zeroBonusEndMonth:0,\r\n            zreEarnedETH:0,\r\n            ldbEarnedETH:0,\r\n            userLDBDays: new uint[](0),\r\n            currLDBDay:0,\r\n            currZREMonth:0,\r\n            zeroBonus:true\r\n        });\r\n        \r\n        users[owner] = user;\r\n        idToAddress[1] = owner;\r\n        \r\n        for (uint8 i = 1; i <= 2; i++) {\r\n            users[owner].activeA7Levels[i] = true;\r\n            users[owner].activeP7Levels[i] = true;\r\n        }\r\n        \r\n        \r\n        startNextDay();\r\n        startNextMonth();\r\n        \r\n        uint lastZREIndex = ZRE.length -1;\r\n        users[owner].zeroBonusStartMonth = lastZREIndex+1;\r\n        ZRE[lastZREIndex].nextMonthEligibleCount++;\r\n    }\r\n    \r\n    function() external payable {\r\n        if(msg.data.length == 0) {\r\n            return registration(msg.sender, owner);\r\n        }\r\n        \r\n        registration(msg.sender, bytesToAddress(msg.data));\r\n    }\r\n\r\n    function registrationExt(address referrerAddress) external payable {\r\n        require(lockStatus == false,\"Contract is locked\");\r\n        registration(msg.sender, referrerAddress);\r\n    }\r\n    \r\n    function buyNewLevel(uint8 matrix, uint8 level) external payable {\r\n        require(lockStatus == false,\"Contract is locked\");\r\n        require(isUserExists(msg.sender), \"user is not exists. Register first.\");\r\n        require(matrix == 1 || matrix == 2, \"invalid matrix\");\r\n        require(msg.value == levelPrice[level], \"invalid price\");\r\n        require(level > 1 && level <= 2, \"invalid level\");\r\n\r\n        if (matrix == 1) {\r\n            require(!users[msg.sender].activeA7Levels[level], \"level already activated\");\r\n\r\n            if (users[msg.sender].a7Matrix[level-1].blocked) {\r\n                users[msg.sender].a7Matrix[level-1].blocked = false;\r\n            }\r\n    \r\n            address freeX3Referrer = findFreeA7Referrer(msg.sender, level);\r\n            users[msg.sender].a7Matrix[level].currentReferrer = freeX3Referrer;\r\n            users[msg.sender].activeA7Levels[level] = true;\r\n            updateA7Referrer(msg.sender, freeX3Referrer, level);\r\n            \r\n            emit Upgrade(msg.sender, freeX3Referrer, 1, level, now);\r\n\r\n        } else {\r\n            require(!users[msg.sender].activeP7Levels[level], \"level already activated\"); \r\n\r\n            if (users[msg.sender].p7Matrix[level-1].blocked) {\r\n                users[msg.sender].p7Matrix[level-1].blocked = false;\r\n            }\r\n\r\n            address freeP7Referrer = findFreeP7Referrer(msg.sender, level);\r\n            \r\n            users[msg.sender].activeP7Levels[level] = true;\r\n            updateP7Referrer(msg.sender, freeP7Referrer, level);\r\n            \r\n            emit Upgrade(msg.sender, freeP7Referrer, 2, level, now);\r\n        }\r\n    }    \r\n    \r\n    function startNextDay() public returns(bool)\r\n    {\r\n        require(msg.sender == owner,\"Invalid user address\");\r\n        require(thisDayEnd < now,\"day end not reached\");\r\n        thisDayEnd = now + oneDayDuration;\r\n        divLDRecord memory temp;\r\n        temp.totalS1EligibleCount = 1;\r\n        temp.totalS2EligibleCount = 1;\r\n        temp.totalS3EligibleCount = 1;\r\n        temp.totalS4EligibleCount = 1;\r\n        temp.totalS5EligibleCount = 1;\r\n        \r\n        LDB.push(temp);\r\n        \r\n        uint lastLDBIndex = LDB.length-1;\r\n        currLDB = lastLDBIndex;\r\n        users[owner].userSLAP[lastLDBIndex].slap = 5;\r\n        \r\n        if(lastLDBIndex > 0){\r\n            LDB[lastLDBIndex-1].withdrawStatus = true;\r\n            \r\n            if(adminLDBCommission > 0){\r\n                require(\r\n                    address(uint160(owner)).send(adminLDBCommission),\r\n                    \"ZRE admin fee transfer failed\"\r\n                );\r\n                \r\n                users[owner].totalETHEarnings += adminLDBCommission;\r\n                adminLDBCommission = 0;\r\n            }\r\n            \r\n        }\r\n        \r\n        return (true);\r\n    }\r\n    \r\n    function startNextMonth() public returns(bool)\r\n    {\r\n        require(msg.sender == owner,\"Invalid user address\");\r\n        require(thisMonthEnd < now,\"month end not reached\");\r\n        thisMonthEnd = now + oneMonthDuration;\r\n        divZRERecord memory temp;\r\n        temp.totalEligibleCount = 0;\r\n        ZRE.push(temp);\r\n        uint lastDivPoolIndex = ZRE.length -1;\r\n        currZRE = lastDivPoolIndex;\r\n        \r\n         if (lastDivPoolIndex > 0)\r\n        {\r\n            ZRE[lastDivPoolIndex].totalEligibleCount = ZRE[lastDivPoolIndex -1].totalEligibleCount + ZRE[lastDivPoolIndex -1].nextMonthEligibleCount;\r\n            ZRE[lastDivPoolIndex -1].withdrawStatus = true;\r\n            \r\n            if(adminZRECommission > 0){\r\n                require(\r\n                    address(uint160(owner)).send(adminZRECommission),\r\n                    \"ZRE admin fee transfer failed\"\r\n                );\r\n                users[owner].totalETHEarnings += adminZRECommission;\r\n                adminZRECommission = 0;\r\n            }\r\n        }\r\n        \r\n        if(lastDivPoolIndex == 1)\r\n            ZRE[lastDivPoolIndex].totalDividendCollection = ZRE[lastDivPoolIndex-1].totalDividendCollection;\r\n        \r\n        return (true);\r\n    }\r\n    \r\n    function registration(address userAddress, address referrerAddress) private {\r\n        require(msg.value == levelPrice[1]*3, \"registration cost 0.15\");\r\n        require(!isUserExists(userAddress), \"user exists\");\r\n        require(isUserExists(referrerAddress), \"referrer not exists\");\r\n        \r\n        User memory user = User({\r\n            id: lastUserId,\r\n            referrer: referrerAddress,\r\n            partnersCount: 0,\r\n            totalETHEarnings:0,\r\n            zeroBonusStartMonth:0,\r\n            zeroBonusEndMonth:0,\r\n            zreEarnedETH:0,\r\n            ldbEarnedETH:0,\r\n            userLDBDays: new uint[](0),\r\n            currLDBDay:0,\r\n            currZREMonth:0,\r\n            zeroBonus:true\r\n        });\r\n        \r\n        users[userAddress] = user;\r\n        idToAddress[lastUserId] = userAddress;\r\n        \r\n        users[userAddress].referrer = referrerAddress;\r\n        \r\n        users[userAddress].activeA7Levels[1] = true; \r\n        users[userAddress].activeP7Levels[1] = true;\r\n        \r\n        lastUserId++;\r\n        \r\n        users[referrerAddress].partnersCount++;\r\n        \r\n        LDB[LDB.length -1].totalSLAPCollection += SLAPPrice;\r\n        \r\n        slapDistrubution( referrerAddress, LDB.length -1);\r\n        \r\n        ZRE[ZRE.length -1].totalDividendCollection += ZREPrice*(80 ether)/ (100 ether);\r\n        \r\n        users[msg.sender].zeroBonusStartMonth = ZRE.length;\r\n        users[msg.sender].currZREMonth = users[msg.sender].zeroBonusStartMonth;\r\n        ZRE[ZRE.length -1].nextMonthEligibleCount++;\r\n\r\n        if(users[referrerAddress].zeroBonus)\r\n        {\r\n            if((ZRE.length-1) == 0)\r\n                ZRE[ZRE.length -1].nextMonthEligibleCount--;\r\n            else    \r\n                ZRE[ZRE.length -1].totalEligibleCount--;\r\n            \r\n            users[referrerAddress].zeroBonus = false;\r\n            users[referrerAddress].zeroBonusEndMonth = ZRE.length -1;\r\n        }\r\n        \r\n        address freeA7Referrer = findFreeA7Referrer(userAddress, 1);\r\n        users[userAddress].a7Matrix[1].currentReferrer = freeA7Referrer;\r\n        updateA7Referrer(userAddress, freeA7Referrer, 1);\r\n\r\n        updateP7Referrer(userAddress, findFreeP7Referrer(userAddress, 1), 1);\r\n        \r\n        adminLDBCommission += LDBAdminCommission;\r\n        adminZRECommission += ((ZREPrice)*(20 ether)/ (100 ether));\r\n        \r\n        emit Registration(userAddress, referrerAddress, users[userAddress].id, users[referrerAddress].id, now);\r\n    }\r\n    \r\n    function withdrawLDB(uint _day) public returns(bool)\r\n    {\r\n        address payable caller = msg.sender;\r\n        require(lockStatus == false,\"Contract is locked\");\r\n        require(users[caller].id > 0, 'User not exist');\r\n        require(_day <= LDB.length -1,\"invalid end day\");\r\n        require(LDB[_day].totalSLAPCollection > 0,\"LDB divident is zero\");\r\n        require(LDB[_day].withdrawStatus == true,\"this day divident is not actived\");\r\n        \r\n        uint totalAmount;\r\n            \r\n        require(users[caller].userSLAP[_day].received == false,\"User already rceived\");\r\n        require(users[caller].userSLAP[_day].slap > 0,\"User not qualified to receive LDB\");\r\n        \r\n        uint slapPercent;\r\n        uint _slap = users[caller].userSLAP[_day].slap;\r\n        if(_slap == 1){\r\n            slapPercent = LDB[_day].totalSLAPCollection*(10 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS1EligibleCount;\r\n        }\r\n        else if(_slap == 2){\r\n            slapPercent = LDB[_day].totalSLAPCollection*(10 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS1EligibleCount;\r\n            slapPercent = LDB[_day].totalSLAPCollection*(20 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS2EligibleCount;\r\n        }\r\n        else if(_slap == 3){\r\n            slapPercent = LDB[_day].totalSLAPCollection*(10 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS1EligibleCount;\r\n            slapPercent = LDB[_day].totalSLAPCollection*(20 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS2EligibleCount;\r\n            slapPercent = LDB[_day].totalSLAPCollection*(20 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS3EligibleCount;\r\n        }\r\n        else if(_slap == 4){\r\n            slapPercent = LDB[_day].totalSLAPCollection*(10 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS1EligibleCount;\r\n            slapPercent = LDB[_day].totalSLAPCollection*(20 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS2EligibleCount;\r\n            slapPercent = LDB[_day].totalSLAPCollection*(20 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS3EligibleCount;\r\n            slapPercent = LDB[_day].totalSLAPCollection*(20 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS4EligibleCount;\r\n        }\r\n        else if(_slap == 5){\r\n            slapPercent = LDB[_day].totalSLAPCollection*(10 ether)/(100 ether);\r\n            totalAmount =slapPercent/LDB[_day].totalS1EligibleCount;\r\n            slapPercent = LDB[_day].totalSLAPCollection*(20 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS2EligibleCount;\r\n            slapPercent = LDB[_day].totalSLAPCollection*(20 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS3EligibleCount;\r\n            slapPercent = LDB[_day].totalSLAPCollection*(20 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS4EligibleCount;\r\n            slapPercent = LDB[_day].totalSLAPCollection*(10 ether)/(100 ether);\r\n            totalAmount +=slapPercent/LDB[_day].totalS5EligibleCount;\r\n        }\r\n        users[caller].userSLAP[_day].received = true;\r\n        users[caller].currLDBDay = _day;\r\n        \r\n        require(address(uint160(caller)).send(totalAmount),\"transfer failed\");\r\n        users[msg.sender].ldbEarnedETH += totalAmount;\r\n        users[msg.sender].totalETHEarnings += totalAmount;\r\n        totalEarnedETH += totalAmount;\r\n        \r\n        emit LDBWithdrawal( msg.sender, _day, totalAmount, now);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function withdrawZRE(uint _month) public returns(bool){\r\n        require(lockStatus == false,\"Contract is locked\");\r\n        require(_month <= ZRE.length -1,\"invalid end month\");\r\n        require(users[msg.sender].id > 0, 'User not exist');\r\n        require(_month > 0,\"month should be greather than zero\");\r\n        require(ZRE[_month].totalDividendCollection > 0,\"month divident is zero\");\r\n        require(ZRE[_month].withdrawStatus == true,\"this month divident is not activated\");\r\n        \r\n        \r\n        uint totalAmount;\r\n        \r\n        require(\r\n            (_month >= users[msg.sender].zeroBonusStartMonth) &&\r\n            ((_month < users[msg.sender].zeroBonusEndMonth) || ((users[msg.sender].zeroBonusEndMonth == 0) && (users[msg.sender].zeroBonus == true))),\r\n            \"invalid month\"\r\n        );\r\n        \r\n        require(!users[msg.sender].userZREReceived[_month],\"already received\");\r\n        \r\n        if(_month > 1){\r\n            if((_month-1) >= users[msg.sender].zeroBonusStartMonth)\r\n                require(users[msg.sender].userZREReceived[_month-1],\"previous month withdrawal not happened\");\r\n        }\r\n        \r\n        totalAmount = ZRE[_month].totalDividendCollection / ZRE[_month].totalEligibleCount;\r\n        users[msg.sender].userZREReceived[_month] = true;\r\n        users[msg.sender].currZREMonth = _month;\r\n        \r\n        ZRE[_month].withdrawalCount++;\r\n        \r\n        require(ZRE[_month].withdrawalCount <= ZRE[_month].totalEligibleCount,\"withdrawal count exceed\");\r\n        \r\n        if((users[msg.sender].zreEarnedETH+totalAmount) > ZREETHLimit){\r\n            totalAmount = ZREETHLimit - users[msg.sender].zreEarnedETH+totalAmount;\r\n            \r\n            if(users[msg.sender].zeroBonus == true){\r\n                users[msg.sender].zeroBonus = false;\r\n                users[msg.sender].zeroBonusEndMonth = _month+1;\r\n                for(uint i = _month+1; i< ZRE.length;i++){\r\n                    ZRE[i].totalEligibleCount--;                \r\n                }    \r\n            }\r\n            \r\n        }\r\n            \r\n        require(msg.sender.send(totalAmount),\"invalid transfer\");\r\n        \r\n        users[msg.sender].zreEarnedETH += totalAmount;\r\n        ZRE[_month].withdrawalDividend += totalAmount;\r\n        users[msg.sender].totalETHEarnings += totalAmount;\r\n        totalEarnedETH += totalAmount;\r\n        \r\n        emit ZREWithdrawal( msg.sender, _month, totalAmount, now);\r\n    }\r\n    \r\n    \r\n    function slapDistrubution(address _userAddress, uint _lastLDBIndex) internal {\r\n        users[_userAddress].userSLAP[_lastLDBIndex].referralCount++;\r\n \r\n        if(_userAddress != owner){\r\n            if(users[_userAddress].userSLAP[_lastLDBIndex].referralCount >= 5){\r\n                \r\n                if((users[_userAddress].userLDBDays.length ==0) || (users[_userAddress].userLDBDays[users[_userAddress].userLDBDays.length-1] != _lastLDBIndex)) // current slap count\r\n                    users[_userAddress].userLDBDays.push(_lastLDBIndex);\r\n                    \r\n                if(users[_userAddress].userSLAP[_lastLDBIndex].referralCount ==5){\r\n                    users[_userAddress].userSLAP[_lastLDBIndex].slap = 1;\r\n                    LDB[_lastLDBIndex].totalS1EligibleCount++;\r\n                }\r\n                else if(users[_userAddress].userSLAP[_lastLDBIndex].referralCount ==10){\r\n                    users[_userAddress].userSLAP[_lastLDBIndex].slap = 2;\r\n                    LDB[_lastLDBIndex].totalS2EligibleCount++;\r\n                }\r\n                else if(users[_userAddress].userSLAP[_lastLDBIndex].referralCount ==15){\r\n                    users[_userAddress].userSLAP[_lastLDBIndex].slap = 3;\r\n                    LDB[_lastLDBIndex].totalS3EligibleCount++;\r\n                }\r\n                else if(users[_userAddress].userSLAP[_lastLDBIndex].referralCount ==20){\r\n                    users[_userAddress].userSLAP[_lastLDBIndex].slap = 4;\r\n                    LDB[_lastLDBIndex].totalS4EligibleCount++;\r\n                }\r\n                else if(users[_userAddress].userSLAP[_lastLDBIndex].referralCount ==25){\r\n                    users[_userAddress].userSLAP[_lastLDBIndex].slap = 5;\r\n                    LDB[_lastLDBIndex].totalS5EligibleCount++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    function updateA7Referrer(address userAddress, address referrerAddress, uint8 level) private {\r\n        users[referrerAddress].a7Matrix[level].referrals.push(userAddress);\r\n        users[referrerAddress].a7Matrix[level].referralsCount++;\r\n        \r\n        if (users[referrerAddress].a7Matrix[level].referrals.length < 3) {\r\n            emit NewUserPlace(userAddress, referrerAddress, 1, level, uint8(users[referrerAddress].a7Matrix[level].referrals.length), now);\r\n            return sendETHDividends(referrerAddress, userAddress, 1, level);\r\n        }\r\n        \r\n        emit NewUserPlace(userAddress, referrerAddress, 1, level, 3, now);\r\n        //close matrix\r\n        users[referrerAddress].a7Matrix[level].referrals = new address[](0);\r\n        if (!users[referrerAddress].activeA7Levels[level+1] && level != LAST_LEVEL) {\r\n            users[referrerAddress].a7Matrix[level].blocked = true;\r\n        }\r\n\r\n        //create new one by recursion\r\n        if (referrerAddress != owner) {\r\n            //check referrer active level\r\n            address freeReferrerAddress = findFreeA7Referrer(referrerAddress, level);\r\n            if (users[referrerAddress].a7Matrix[level].currentReferrer != freeReferrerAddress) {\r\n                users[referrerAddress].a7Matrix[level].currentReferrer = freeReferrerAddress;\r\n            }\r\n            \r\n            users[referrerAddress].a7Matrix[level].reinvestCount++;\r\n            emit Reinvest(referrerAddress, freeReferrerAddress, userAddress, 1, level, now);\r\n            updateA7Referrer(referrerAddress, freeReferrerAddress, level);\r\n        } else {\r\n            sendETHDividends(owner, userAddress, 1, level);\r\n            users[owner].a7Matrix[level].reinvestCount++;\r\n            emit Reinvest(owner, address(0), userAddress, 1, level, now);\r\n        }\r\n    }\r\n\r\n    function updateP7Referrer(address userAddress, address referrerAddress, uint8 level) private {\r\n        require(users[referrerAddress].activeP7Levels[level], \"500. Referrer level is inactive\");\r\n        \r\n        if (users[referrerAddress].p7Matrix[level].firstLevelReferrals.length < 2) {\r\n            users[referrerAddress].p7Matrix[level].firstLevelReferrals.push(userAddress);\r\n            users[referrerAddress].p7Matrix[level].referralsCount++;\r\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, uint8(users[referrerAddress].p7Matrix[level].firstLevelReferrals.length), now);\r\n            \r\n            //set current level\r\n            users[userAddress].p7Matrix[level].currentReferrer = referrerAddress;\r\n\r\n            if (referrerAddress == owner) {\r\n                return sendETHDividends(referrerAddress, userAddress, 2, level);\r\n            }\r\n            \r\n            address ref = users[referrerAddress].p7Matrix[level].currentReferrer;            \r\n            users[ref].p7Matrix[level].secondLevelReferrals.push(userAddress); \r\n            users[ref].p7Matrix[level].referralsCount++;\r\n            \r\n            uint len = users[ref].p7Matrix[level].firstLevelReferrals.length;\r\n            \r\n            if ((len == 2) && \r\n                (users[ref].p7Matrix[level].firstLevelReferrals[0] == referrerAddress) &&\r\n                (users[ref].p7Matrix[level].firstLevelReferrals[1] == referrerAddress)) {\r\n                if (users[referrerAddress].p7Matrix[level].firstLevelReferrals.length == 1) {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 5, now);\r\n                } else {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 6, now);\r\n                }\r\n            }  else if ((len == 1 || len == 2) &&\r\n                    users[ref].p7Matrix[level].firstLevelReferrals[0] == referrerAddress) {\r\n                if (users[referrerAddress].p7Matrix[level].firstLevelReferrals.length == 1) {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 3, now);\r\n                } else {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 4, now);\r\n                }\r\n            } else if (len == 2 && users[ref].p7Matrix[level].firstLevelReferrals[1] == referrerAddress) {\r\n                if (users[referrerAddress].p7Matrix[level].firstLevelReferrals.length == 1) {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 5, now);\r\n                } else {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 6, now);\r\n                }\r\n            }\r\n\r\n            return updateP7ReferrerSecondLevel(userAddress, ref, level);\r\n        }\r\n        \r\n        users[referrerAddress].p7Matrix[level].secondLevelReferrals.push(userAddress);\r\n        users[referrerAddress].p7Matrix[level].referralsCount++;\r\n\r\n        if (users[referrerAddress].p7Matrix[level].closedPart != address(0)) {\r\n            if ((users[referrerAddress].p7Matrix[level].firstLevelReferrals[0] == \r\n                users[referrerAddress].p7Matrix[level].firstLevelReferrals[1]) &&\r\n                (users[referrerAddress].p7Matrix[level].firstLevelReferrals[0] ==\r\n                users[referrerAddress].p7Matrix[level].closedPart)) {\r\n\r\n                updateP7(userAddress, referrerAddress, level, true);\r\n                return updateP7ReferrerSecondLevel(userAddress, referrerAddress, level);\r\n            } else if (users[referrerAddress].p7Matrix[level].firstLevelReferrals[0] == \r\n                users[referrerAddress].p7Matrix[level].closedPart) {\r\n                updateP7(userAddress, referrerAddress, level, true);\r\n                return updateP7ReferrerSecondLevel(userAddress, referrerAddress, level);\r\n            } else {\r\n                updateP7(userAddress, referrerAddress, level, false);\r\n                return updateP7ReferrerSecondLevel(userAddress, referrerAddress, level);\r\n            }\r\n        }\r\n\r\n        if (users[referrerAddress].p7Matrix[level].firstLevelReferrals[1] == userAddress) {\r\n            updateP7(userAddress, referrerAddress, level, false);\r\n            return updateP7ReferrerSecondLevel(userAddress, referrerAddress, level);\r\n        } else if (users[referrerAddress].p7Matrix[level].firstLevelReferrals[0] == userAddress) {\r\n            updateP7(userAddress, referrerAddress, level, true);\r\n            return updateP7ReferrerSecondLevel(userAddress, referrerAddress, level);\r\n        }\r\n        \r\n        if (users[users[referrerAddress].p7Matrix[level].firstLevelReferrals[0]].p7Matrix[level].firstLevelReferrals.length <= \r\n            users[users[referrerAddress].p7Matrix[level].firstLevelReferrals[1]].p7Matrix[level].firstLevelReferrals.length) {\r\n            updateP7(userAddress, referrerAddress, level, false);\r\n        } else {\r\n            updateP7(userAddress, referrerAddress, level, true);\r\n        }\r\n        \r\n        updateP7ReferrerSecondLevel(userAddress, referrerAddress, level);\r\n    }\r\n\r\n    function updateP7(address userAddress, address referrerAddress, uint8 level, bool x2) private {\r\n        if (!x2) {\r\n            users[users[referrerAddress].p7Matrix[level].firstLevelReferrals[0]].p7Matrix[level].firstLevelReferrals.push(userAddress);\r\n            users[users[referrerAddress].p7Matrix[level].firstLevelReferrals[0]].p7Matrix[level].referralsCount++;\r\n            emit NewUserPlace(userAddress, users[referrerAddress].p7Matrix[level].firstLevelReferrals[0], 2, level, uint8(users[users[referrerAddress].p7Matrix[level].firstLevelReferrals[0]].p7Matrix[level].firstLevelReferrals.length), now);\r\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, 2 + uint8(users[users[referrerAddress].p7Matrix[level].firstLevelReferrals[0]].p7Matrix[level].firstLevelReferrals.length), now);\r\n            //set current level\r\n            users[userAddress].p7Matrix[level].currentReferrer = users[referrerAddress].p7Matrix[level].firstLevelReferrals[0];\r\n        } else {\r\n            users[users[referrerAddress].p7Matrix[level].firstLevelReferrals[1]].p7Matrix[level].firstLevelReferrals.push(userAddress);\r\n            users[users[referrerAddress].p7Matrix[level].firstLevelReferrals[1]].p7Matrix[level].referralsCount++;\r\n            emit NewUserPlace(userAddress, users[referrerAddress].p7Matrix[level].firstLevelReferrals[1], 2, level, uint8(users[users[referrerAddress].p7Matrix[level].firstLevelReferrals[1]].p7Matrix[level].firstLevelReferrals.length), now);\r\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, 4 + uint8(users[users[referrerAddress].p7Matrix[level].firstLevelReferrals[1]].p7Matrix[level].firstLevelReferrals.length), now);\r\n            //set current level\r\n            users[userAddress].p7Matrix[level].currentReferrer = users[referrerAddress].p7Matrix[level].firstLevelReferrals[1];\r\n        }\r\n    }\r\n    \r\n    function updateP7ReferrerSecondLevel(address userAddress, address referrerAddress, uint8 level) private {\r\n        if (users[referrerAddress].p7Matrix[level].secondLevelReferrals.length < 4) {\r\n            return sendETHDividends(referrerAddress, userAddress, 2, level);\r\n        }\r\n        \r\n        address[] memory x6 = users[users[referrerAddress].p7Matrix[level].currentReferrer].p7Matrix[level].firstLevelReferrals;\r\n        \r\n        if (x6.length == 2) {\r\n            if (x6[0] == referrerAddress ||\r\n                x6[1] == referrerAddress) {\r\n                users[users[referrerAddress].p7Matrix[level].currentReferrer].p7Matrix[level].closedPart = referrerAddress;\r\n            } else if (x6.length == 1) {\r\n                if (x6[0] == referrerAddress) {\r\n                    users[users[referrerAddress].p7Matrix[level].currentReferrer].p7Matrix[level].closedPart = referrerAddress;\r\n                }\r\n            }\r\n        }\r\n        \r\n        users[referrerAddress].p7Matrix[level].firstLevelReferrals = new address[](0);\r\n        users[referrerAddress].p7Matrix[level].secondLevelReferrals = new address[](0);\r\n        users[referrerAddress].p7Matrix[level].closedPart = address(0);\r\n\r\n        if (!users[referrerAddress].activeP7Levels[level+1] && level != LAST_LEVEL) {\r\n            users[referrerAddress].p7Matrix[level].blocked = true;\r\n        }\r\n\r\n        users[referrerAddress].p7Matrix[level].reinvestCount++;\r\n        \r\n        if (referrerAddress != owner) {\r\n            address freeReferrerAddress = findFreeP7Referrer(referrerAddress, level);\r\n\r\n            emit Reinvest(referrerAddress, freeReferrerAddress, userAddress, 2, level, now);\r\n            updateP7Referrer(referrerAddress, freeReferrerAddress, level);\r\n        } else {\r\n            emit Reinvest(owner, address(0), userAddress, 2, level, now);\r\n            sendETHDividends(owner, userAddress, 2, level);\r\n        }\r\n    }\r\n    \r\n     /**\r\n     * @dev Contract balance withdraw\r\n     * @param _toUser  receiver addrress\r\n     * @param _amount  withdraw amount\r\n     */ \r\n    function failSafe(address payable _toUser, uint _amount) public returns (bool) {\r\n        require(msg.sender == owner, \"Only Owner Wallet\");\r\n        require(_toUser != address(0), \"Invalid Address\");\r\n        require(address(this).balance >= _amount, \"Insufficient balance\");\r\n\r\n        (_toUser).transfer(_amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev To lock/unlock the contract\r\n     * @param _lockStatus  status in bool\r\n     */\r\n    function contractLock(bool _lockStatus) public returns (bool) {\r\n        require(msg.sender == owner, \"Invalid ownerWallet\");\r\n\r\n        lockStatus = _lockStatus;\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function findFreeA7Referrer(address userAddress, uint8 level) public view returns(address) {\r\n        while (true) {\r\n            if (users[users[userAddress].referrer].activeA7Levels[level]) {\r\n                return users[userAddress].referrer;\r\n            }\r\n            \r\n            userAddress = users[userAddress].referrer;\r\n        }\r\n    }\r\n    \r\n    function findFreeP7Referrer(address userAddress, uint8 level) public view returns(address) {\r\n        while (true) {\r\n            if (users[users[userAddress].referrer].activeP7Levels[level]) {\r\n                return users[userAddress].referrer;\r\n            }\r\n            \r\n            userAddress = users[userAddress].referrer;\r\n        }\r\n    }\r\n        \r\n    function usersActiveA7Levels(address userAddress, uint8 level) public view returns(bool) {\r\n        return users[userAddress].activeA7Levels[level];\r\n    }\r\n\r\n    function usersActiveP7Levels(address userAddress, uint8 level) public view returns(bool) {\r\n        return users[userAddress].activeP7Levels[level];\r\n    }\r\n\r\n    function usersA7Matrix(address userAddress, uint8 level) public view returns(address, address[] memory, uint, uint, bool) {\r\n        return (users[userAddress].a7Matrix[level].currentReferrer,\r\n                users[userAddress].a7Matrix[level].referrals,\r\n                users[userAddress].a7Matrix[level].reinvestCount,\r\n                users[userAddress].a7Matrix[level].referralsCount,\r\n                users[userAddress].a7Matrix[level].blocked);\r\n    }\r\n\r\n    function usersp7Matrix(address userAddress, uint8 level) public view returns(address, address[] memory, address[] memory, uint, bool, address) {\r\n        return (users[userAddress].p7Matrix[level].currentReferrer,\r\n                users[userAddress].p7Matrix[level].firstLevelReferrals,\r\n                users[userAddress].p7Matrix[level].secondLevelReferrals,\r\n                users[userAddress].p7Matrix[level].reinvestCount,\r\n                users[userAddress].p7Matrix[level].blocked,\r\n                users[userAddress].p7Matrix[level].closedPart);\r\n    }\r\n    \r\n    function usersp7MatrixRefferalsCount(address userAddress, uint8 level) public view returns(uint){\r\n        return users[userAddress].p7Matrix[level].referralsCount;\r\n    }\r\n    \r\n    function usersLDBDays(address userAddress) public view returns(uint[] memory){\r\n        return users[userAddress].userLDBDays;\r\n    }\r\n    \r\n    \r\n    function isUserExists(address user) public view returns (bool) {\r\n        return (users[user].id != 0);\r\n    }\r\n    \r\n    function viewUserZREReceived(address _user, uint _month) public view returns(bool){\r\n        return users[_user].userZREReceived[_month];   \r\n    }\r\n    \r\n    function viewUserSLAP(address _user, uint _day) public view returns(uint , uint, bool){\r\n        return (users[_user].userSLAP[_day].slap,users[_user].userSLAP[_day].referralCount,users[_user].userSLAP[_day].received);   \r\n    }\r\n\r\n    function findEthReceiver(address userAddress, address _from, uint8 matrix, uint8 level) private returns(address, bool) {\r\n        address receiver = userAddress;\r\n        bool isExtraDividends;\r\n        if (matrix == 1) {\r\n            while (true) {\r\n                if (users[receiver].a7Matrix[level].blocked) {\r\n                    emit MissedEthReceive(receiver, _from, 1, level, now);\r\n                    isExtraDividends = true;\r\n                    receiver = users[receiver].a7Matrix[level].currentReferrer;\r\n                } else {\r\n                    return (receiver, isExtraDividends);\r\n                }\r\n            }\r\n        } else {\r\n            while (true) {\r\n                if (users[receiver].p7Matrix[level].blocked) {\r\n                    emit MissedEthReceive(receiver, _from, 2, level, now);\r\n                    isExtraDividends = true;\r\n                    receiver = users[receiver].p7Matrix[level].currentReferrer;\r\n                } else {\r\n                    return (receiver, isExtraDividends);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function sendETHDividends(address userAddress, address _from, uint8 matrix, uint8 level) private {\r\n        (address receiver, bool isExtraDividends) = findEthReceiver(userAddress, _from, matrix, level);\r\n\r\n        require(address(uint160(receiver)).send(levelPrice[level]),\"amount transferred\");\r\n        users[receiver].totalETHEarnings += levelPrice[level];\r\n        totalEarnedETH += levelPrice[level];\r\n        \r\n        if (isExtraDividends) {\r\n            emit SentExtraEthDividends(_from, receiver, matrix, level, now);\r\n        }\r\n    }\r\n    \r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}"}}}