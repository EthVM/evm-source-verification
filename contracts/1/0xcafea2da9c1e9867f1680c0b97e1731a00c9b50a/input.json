{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ClaimsReward.sol": {
      "content": "// File: contracts/interfaces/IPooledStaking.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ninterface IPooledStaking {\r\n\r\n  function accumulateReward(address contractAddress, uint amount) external;\r\n\r\n  function pushBurn(address contractAddress, uint amount) external;\r\n\r\n  function hasPendingActions() external view returns (bool);\r\n\r\n  function contractStake(address contractAddress) external view returns (uint);\r\n\r\n  function stakerReward(address staker) external view returns (uint);\r\n\r\n  function stakerDeposit(address staker) external view returns (uint);\r\n\r\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint);\r\n\r\n  function withdraw(uint amount) external;\r\n\r\n  function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);\r\n\r\n  function withdrawReward(address stakerAddress) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n *\r\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\r\n * metering changes introduced in the Istanbul hardfork.\r\n */\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts/abstract/INXMMaster.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract INXMMaster {\r\n\r\n  address public tokenAddress;\r\n\r\n  address public owner;\r\n\r\n  uint public pauseTime;\r\n\r\n  function delegateCallBack(bytes32 myid) external;\r\n\r\n  function masterInitialized() public view returns (bool);\r\n\r\n  function isInternal(address _add) public view returns (bool);\r\n\r\n  function isPause() public view returns (bool check);\r\n\r\n  function isOwner(address _add) public view returns (bool);\r\n\r\n  function isMember(address _add) public view returns (bool);\r\n\r\n  function checkIsAuthToGoverned(address _add) public view returns (bool);\r\n\r\n  function updatePauseTime(uint _time) public;\r\n\r\n  function dAppLocker() public view returns (address _add);\r\n\r\n  function dAppToken() public view returns (address _add);\r\n\r\n  function getLatestAddress(bytes2 _contractName) public view returns (address payable contractAddress);\r\n}\r\n\r\n// File: contracts/abstract/MasterAware.sol\r\n\r\n/*\r\n    Copyright (C) 2020 NexusMutual.io\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/\r\n*/\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract MasterAware {\r\n\r\n  INXMMaster public master;\r\n\r\n  modifier onlyMember {\r\n    require(master.isMember(msg.sender), \"Caller is not a member\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyInternal {\r\n    require(master.isInternal(msg.sender), \"Caller is not an internal contract\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyMaster {\r\n    if (address(master) != address(0)) {\r\n      require(address(master) == msg.sender, \"Not master\");\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier onlyGovernance {\r\n    require(\r\n      master.checkIsAuthToGoverned(msg.sender),\r\n      \"Caller is not authorized to govern\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused {\r\n    require(master.isPause(), \"System is not paused\");\r\n    _;\r\n  }\r\n\r\n  modifier whenNotPaused {\r\n    require(!master.isPause(), \"System is paused\");\r\n    _;\r\n  }\r\n\r\n  function changeMasterAddress(address masterAddress) public onlyMaster {\r\n    master = INXMMaster(masterAddress);\r\n  }\r\n}\r\n\r\n// File: contracts/abstract/Iupgradable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract Iupgradable {\r\n\r\n  INXMMaster public ms;\r\n  address public nxMasterAddress;\r\n\r\n  modifier onlyInternal {\r\n    require(ms.isInternal(msg.sender));\r\n    _;\r\n  }\r\n\r\n  modifier isMemberAndcheckPause {\r\n    require(ms.isPause() == false && ms.isMember(msg.sender) == true);\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwner {\r\n    require(ms.isOwner(msg.sender));\r\n    _;\r\n  }\r\n\r\n  modifier checkPause {\r\n    require(ms.isPause() == false);\r\n    _;\r\n  }\r\n\r\n  modifier isMember {\r\n    require(ms.isMember(msg.sender), \"Not member\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Iupgradable Interface to update dependent contract address\r\n   */\r\n  function changeDependentContractAddress() public;\r\n\r\n  /**\r\n   * @dev change master address\r\n   * @param _masterAddress is the new address\r\n   */\r\n  function changeMasterAddress(address _masterAddress) public {\r\n    if (address(ms) != address(0)) {\r\n      require(address(ms) == msg.sender, \"Not master\");\r\n    }\r\n\r\n    ms = INXMMaster(_masterAddress);\r\n    nxMasterAddress = _masterAddress;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/modules/cover/QuotationData.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract QuotationData is Iupgradable {\r\n  using SafeMath for uint;\r\n\r\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\r\n\r\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\r\n\r\n  struct Cover {\r\n    address payable memberAddress;\r\n    bytes4 currencyCode;\r\n    uint sumAssured;\r\n    uint16 coverPeriod;\r\n    uint validUntil;\r\n    address scAddress;\r\n    uint premiumNXM;\r\n  }\r\n\r\n  struct HoldCover {\r\n    uint holdCoverId;\r\n    address payable userAddress;\r\n    address scAddress;\r\n    bytes4 coverCurr;\r\n    uint[] coverDetails;\r\n    uint16 coverPeriod;\r\n  }\r\n\r\n  address public authQuoteEngine;\r\n\r\n  mapping(bytes4 => uint) internal currencyCSA;\r\n  mapping(address => uint[]) internal userCover;\r\n  mapping(address => uint[]) public userHoldedCover;\r\n  mapping(address => bool) public refundEligible;\r\n  mapping(address => mapping(bytes4 => uint)) internal currencyCSAOfSCAdd;\r\n  mapping(uint => uint8) public coverStatus;\r\n  mapping(uint => uint) public holdedCoverIDStatus;\r\n  mapping(uint => bool) public timestampRepeated;\r\n\r\n\r\n  Cover[] internal allCovers;\r\n  HoldCover[] internal allCoverHolded;\r\n\r\n  uint public stlp;\r\n  uint public stl;\r\n  uint public pm;\r\n  uint public minDays;\r\n  uint public tokensRetained;\r\n  address public kycAuthAddress;\r\n\r\n  event CoverDetailsEvent(\r\n    uint indexed cid,\r\n    address scAdd,\r\n    uint sumAssured,\r\n    uint expiry,\r\n    uint premium,\r\n    uint premiumNXM,\r\n    bytes4 curr\r\n  );\r\n\r\n  event CoverStatusEvent(uint indexed cid, uint8 statusNum);\r\n\r\n  constructor(address _authQuoteAdd, address _kycAuthAdd) public {\r\n    authQuoteEngine = _authQuoteAdd;\r\n    kycAuthAddress = _kycAuthAdd;\r\n    stlp = 90;\r\n    stl = 100;\r\n    pm = 30;\r\n    minDays = 30;\r\n    tokensRetained = 10;\r\n    allCovers.push(Cover(address(0), \"0x00\", 0, 0, 0, address(0), 0));\r\n    uint[] memory arr = new uint[](1);\r\n    allCoverHolded.push(HoldCover(0, address(0), address(0), 0x00, arr, 0));\r\n\r\n  }\r\n\r\n  /// @dev Adds the amount in Total Sum Assured of a given currency of a given smart contract address.\r\n  /// @param _add Smart Contract Address.\r\n  /// @param _amount Amount to be added.\r\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\r\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].add(_amount);\r\n  }\r\n\r\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency and smart contract address.\r\n  /// @param _add Smart Contract Address.\r\n  /// @param _amount Amount to be subtracted.\r\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\r\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].sub(_amount);\r\n  }\r\n\r\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency.\r\n  /// @param _curr Currency Name.\r\n  /// @param _amount Amount to be subtracted.\r\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\r\n    currencyCSA[_curr] = currencyCSA[_curr].sub(_amount);\r\n  }\r\n\r\n  /// @dev Adds the amount in Total Sum Assured of a given currency.\r\n  /// @param _curr Currency Name.\r\n  /// @param _amount Amount to be added.\r\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\r\n    currencyCSA[_curr] = currencyCSA[_curr].add(_amount);\r\n  }\r\n\r\n  /// @dev sets bit for timestamp to avoid replay attacks.\r\n  function setTimestampRepeated(uint _timestamp) external onlyInternal {\r\n    timestampRepeated[_timestamp] = true;\r\n  }\r\n\r\n  /// @dev Creates a blank new cover.\r\n  function addCover(\r\n    uint16 _coverPeriod,\r\n    uint _sumAssured,\r\n    address payable _userAddress,\r\n    bytes4 _currencyCode,\r\n    address _scAddress,\r\n    uint premium,\r\n    uint premiumNXM\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    uint expiryDate = now.add(uint(_coverPeriod).mul(1 days));\r\n    allCovers.push(Cover(_userAddress, _currencyCode,\r\n      _sumAssured, _coverPeriod, expiryDate, _scAddress, premiumNXM));\r\n    uint cid = allCovers.length.sub(1);\r\n    userCover[_userAddress].push(cid);\r\n    emit CoverDetailsEvent(cid, _scAddress, _sumAssured, expiryDate, premium, premiumNXM, _currencyCode);\r\n  }\r\n\r\n  /// @dev create holded cover which will process after verdict of KYC.\r\n  function addHoldCover(\r\n    address payable from,\r\n    address scAddress,\r\n    bytes4 coverCurr,\r\n    uint[] calldata coverDetails,\r\n    uint16 coverPeriod\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    uint holdedCoverLen = allCoverHolded.length;\r\n    holdedCoverIDStatus[holdedCoverLen] = uint(HCIDStatus.kycPending);\r\n    allCoverHolded.push(HoldCover(holdedCoverLen, from, scAddress,\r\n      coverCurr, coverDetails, coverPeriod));\r\n    userHoldedCover[from].push(allCoverHolded.length.sub(1));\r\n\r\n  }\r\n\r\n  ///@dev sets refund eligible bit.\r\n  ///@param _add user address.\r\n  ///@param status indicates if user have pending kyc.\r\n  function setRefundEligible(address _add, bool status) external onlyInternal {\r\n    refundEligible[_add] = status;\r\n  }\r\n\r\n  /// @dev to set current status of particular holded coverID (1 for not completed KYC,\r\n  /// 2 for KYC passed, 3 for failed KYC or full refunded,\r\n  /// 4 for KYC completed but cover not processed)\r\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external onlyInternal {\r\n    holdedCoverIDStatus[holdedCoverID] = status;\r\n  }\r\n\r\n  /**\r\n   * @dev to set address of kyc authentication\r\n   * @param _add is the new address\r\n   */\r\n  function setKycAuthAddress(address _add) external onlyInternal {\r\n    kycAuthAddress = _add;\r\n  }\r\n\r\n  /// @dev Changes authorised address for generating quote off chain.\r\n  function changeAuthQuoteEngine(address _add) external onlyInternal {\r\n    authQuoteEngine = _add;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Uint Parameters of a code\r\n   * @param code whose details we want\r\n   * @return string value of the code\r\n   * @return associated amount (time or perc or value) to the code\r\n   */\r\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\r\n    codeVal = code;\r\n\r\n    if (code == \"STLP\") {\r\n      val = stlp;\r\n\r\n    } else if (code == \"STL\") {\r\n\r\n      val = stl;\r\n\r\n    } else if (code == \"PM\") {\r\n\r\n      val = pm;\r\n\r\n    } else if (code == \"QUOMIND\") {\r\n\r\n      val = minDays;\r\n\r\n    } else if (code == \"QUOTOK\") {\r\n\r\n      val = tokensRetained;\r\n\r\n    }\r\n\r\n  }\r\n\r\n  /// @dev Gets Product details.\r\n  /// @return  _minDays minimum cover period.\r\n  /// @return  _PM Profit margin.\r\n  /// @return  _STL short term Load.\r\n  /// @return  _STLP short term load period.\r\n  function getProductDetails()\r\n  external\r\n  view\r\n  returns (\r\n    uint _minDays,\r\n    uint _pm,\r\n    uint _stl,\r\n    uint _stlp\r\n  )\r\n  {\r\n\r\n    _minDays = minDays;\r\n    _pm = pm;\r\n    _stl = stl;\r\n    _stlp = stlp;\r\n  }\r\n\r\n  /// @dev Gets total number covers created till date.\r\n  function getCoverLength() external view returns (uint len) {\r\n    return (allCovers.length);\r\n  }\r\n\r\n  /// @dev Gets Authorised Engine address.\r\n  function getAuthQuoteEngine() external view returns (address _add) {\r\n    _add = authQuoteEngine;\r\n  }\r\n\r\n  /// @dev Gets the Total Sum Assured amount of a given currency.\r\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount) {\r\n    amount = currencyCSA[_curr];\r\n  }\r\n\r\n  /// @dev Gets all the Cover ids generated by a given address.\r\n  /// @param _add User's address.\r\n  /// @return allCover array of covers.\r\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover) {\r\n    return (userCover[_add]);\r\n  }\r\n\r\n  /// @dev Gets total number of covers generated by a given address\r\n  function getUserCoverLength(address _add) external view returns (uint len) {\r\n    len = userCover[_add].length;\r\n  }\r\n\r\n  /// @dev Gets the status of a given cover.\r\n  function getCoverStatusNo(uint _cid) external view returns (uint8) {\r\n    return coverStatus[_cid];\r\n  }\r\n\r\n  /// @dev Gets the Cover Period (in days) of a given cover.\r\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp) {\r\n    cp = allCovers[_cid].coverPeriod;\r\n  }\r\n\r\n  /// @dev Gets the Sum Assured Amount of a given cover.\r\n  function getCoverSumAssured(uint _cid) external view returns (uint sa) {\r\n    sa = allCovers[_cid].sumAssured;\r\n  }\r\n\r\n  /// @dev Gets the Currency Name in which a given cover is assured.\r\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr) {\r\n    curr = allCovers[_cid].currencyCode;\r\n  }\r\n\r\n  /// @dev Gets the validity date (timestamp) of a given cover.\r\n  function getValidityOfCover(uint _cid) external view returns (uint date) {\r\n    date = allCovers[_cid].validUntil;\r\n  }\r\n\r\n  /// @dev Gets Smart contract address of cover.\r\n  function getscAddressOfCover(uint _cid) external view returns (uint, address) {\r\n    return (_cid, allCovers[_cid].scAddress);\r\n  }\r\n\r\n  /// @dev Gets the owner address of a given cover.\r\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add) {\r\n    _add = allCovers[_cid].memberAddress;\r\n  }\r\n\r\n  /// @dev Gets the premium amount of a given cover in NXM.\r\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM) {\r\n    _premiumNXM = allCovers[_cid].premiumNXM;\r\n  }\r\n\r\n  /// @dev Provides the details of a cover Id\r\n  /// @param _cid cover Id\r\n  /// @return memberAddress cover user address.\r\n  /// @return scAddress smart contract Address\r\n  /// @return currencyCode currency of cover\r\n  /// @return sumAssured sum assured of cover\r\n  /// @return premiumNXM premium in NXM\r\n  function getCoverDetailsByCoverID1(\r\n    uint _cid\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint cid,\r\n    address _memberAddress,\r\n    address _scAddress,\r\n    bytes4 _currencyCode,\r\n    uint _sumAssured,\r\n    uint premiumNXM\r\n  )\r\n  {\r\n    return (\r\n    _cid,\r\n    allCovers[_cid].memberAddress,\r\n    allCovers[_cid].scAddress,\r\n    allCovers[_cid].currencyCode,\r\n    allCovers[_cid].sumAssured,\r\n    allCovers[_cid].premiumNXM\r\n    );\r\n  }\r\n\r\n  /// @dev Provides details of a cover Id\r\n  /// @param _cid cover Id\r\n  /// @return status status of cover.\r\n  /// @return sumAssured Sum assurance of cover.\r\n  /// @return coverPeriod Cover Period of cover (in days).\r\n  /// @return validUntil is validity of cover.\r\n  function getCoverDetailsByCoverID2(\r\n    uint _cid\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint cid,\r\n    uint8 status,\r\n    uint sumAssured,\r\n    uint16 coverPeriod,\r\n    uint validUntil\r\n  )\r\n  {\r\n\r\n    return (\r\n    _cid,\r\n    coverStatus[_cid],\r\n    allCovers[_cid].sumAssured,\r\n    allCovers[_cid].coverPeriod,\r\n    allCovers[_cid].validUntil\r\n    );\r\n  }\r\n\r\n  /// @dev Provides details of a holded cover Id\r\n  /// @param _hcid holded cover Id\r\n  /// @return scAddress SmartCover address of cover.\r\n  /// @return coverCurr currency of cover.\r\n  /// @return coverPeriod Cover Period of cover (in days).\r\n  function getHoldedCoverDetailsByID1(\r\n    uint _hcid\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint hcid,\r\n    address scAddress,\r\n    bytes4 coverCurr,\r\n    uint16 coverPeriod\r\n  )\r\n  {\r\n    return (\r\n    _hcid,\r\n    allCoverHolded[_hcid].scAddress,\r\n    allCoverHolded[_hcid].coverCurr,\r\n    allCoverHolded[_hcid].coverPeriod\r\n    );\r\n  }\r\n\r\n  /// @dev Gets total number holded covers created till date.\r\n  function getUserHoldedCoverLength(address _add) external view returns (uint) {\r\n    return userHoldedCover[_add].length;\r\n  }\r\n\r\n  /// @dev Gets holded cover index by index of user holded covers.\r\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint) {\r\n    return userHoldedCover[_add][index];\r\n  }\r\n\r\n  /// @dev Provides the details of a holded cover Id\r\n  /// @param _hcid holded cover Id\r\n  /// @return memberAddress holded cover user address.\r\n  /// @return coverDetails array contains SA, Cover Currency Price,Price in NXM, Expiration time of Qoute.\r\n  function getHoldedCoverDetailsByID2(\r\n    uint _hcid\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint hcid,\r\n    address payable memberAddress,\r\n    uint[] memory coverDetails\r\n  )\r\n  {\r\n    return (\r\n    _hcid,\r\n    allCoverHolded[_hcid].userAddress,\r\n    allCoverHolded[_hcid].coverDetails\r\n    );\r\n  }\r\n\r\n  /// @dev Gets the Total Sum Assured amount of a given currency and smart contract address.\r\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount) {\r\n    amount = currencyCSAOfSCAdd[_add][_curr];\r\n  }\r\n\r\n  //solhint-disable-next-line\r\n  function changeDependentContractAddress() public {}\r\n\r\n  /// @dev Changes the status of a given cover.\r\n  /// @param _cid cover Id.\r\n  /// @param _stat New status.\r\n  function changeCoverStatusNo(uint _cid, uint8 _stat) public onlyInternal {\r\n    coverStatus[_cid] = _stat;\r\n    emit CoverStatusEvent(_cid, _stat);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates Uint Parameters of a code\r\n   * @param code whose details we want to update\r\n   * @param val value to set\r\n   */\r\n  function updateUintParameters(bytes8 code, uint val) public {\r\n\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    if (code == \"STLP\") {\r\n      _changeSTLP(val);\r\n\r\n    } else if (code == \"STL\") {\r\n\r\n      _changeSTL(val);\r\n\r\n    } else if (code == \"PM\") {\r\n\r\n      _changePM(val);\r\n\r\n    } else if (code == \"QUOMIND\") {\r\n\r\n      _changeMinDays(val);\r\n\r\n    } else if (code == \"QUOTOK\") {\r\n\r\n      _setTokensRetained(val);\r\n\r\n    } else {\r\n\r\n      revert(\"Invalid param code\");\r\n    }\r\n\r\n  }\r\n\r\n  /// @dev Changes the existing Profit Margin value\r\n  function _changePM(uint _pm) internal {\r\n    pm = _pm;\r\n  }\r\n\r\n  /// @dev Changes the existing Short Term Load Period (STLP) value.\r\n  function _changeSTLP(uint _stlp) internal {\r\n    stlp = _stlp;\r\n  }\r\n\r\n  /// @dev Changes the existing Short Term Load (STL) value.\r\n  function _changeSTL(uint _stl) internal {\r\n    stl = _stl;\r\n  }\r\n\r\n  /// @dev Changes the existing Minimum cover period (in days)\r\n  function _changeMinDays(uint _days) internal {\r\n    minDays = _days;\r\n  }\r\n\r\n  /**\r\n   * @dev to set the the amount of tokens retained\r\n   * @param val is the amount retained\r\n   */\r\n  function _setTokensRetained(uint val) internal {\r\n    tokensRetained = val;\r\n  }\r\n}\r\n\r\n// File: contracts/modules/token/external/OZIERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface OZIERC20 {\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n  external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n  external returns (bool);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n  external view returns (uint256);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/modules/token/external/OZSafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary OZSafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/modules/token/NXMToken.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract NXMToken is OZIERC20 {\r\n  using OZSafeMath for uint256;\r\n\r\n  event WhiteListed(address indexed member);\r\n\r\n  event BlackListed(address indexed member);\r\n\r\n  mapping(address => uint256) private _balances;\r\n\r\n  mapping(address => mapping(address => uint256)) private _allowed;\r\n\r\n  mapping(address => bool) public whiteListed;\r\n\r\n  mapping(address => uint) public isLockedForMV;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  string public name = \"NXM\";\r\n  string public symbol = \"NXM\";\r\n  uint8 public decimals = 18;\r\n  address public operator;\r\n\r\n  modifier canTransfer(address _to) {\r\n    require(whiteListed[_to]);\r\n    _;\r\n  }\r\n\r\n  modifier onlyOperator() {\r\n    if (operator != address(0))\r\n      require(msg.sender == operator);\r\n    _;\r\n  }\r\n\r\n  constructor(address _founderAddress, uint _initialSupply) public {\r\n    _mint(_founderAddress, _initialSupply);\r\n  }\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param owner The address to query the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return _balances[owner];\r\n  }\r\n\r\n  /**\r\n  * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n  * @param owner address The address which owns the funds.\r\n  * @param spender address The address which will spend the funds.\r\n  * @return A uint256 specifying the amount of tokens still available for the spender.\r\n  */\r\n  function allowance(\r\n    address owner,\r\n    address spender\r\n  )\r\n  public\r\n  view\r\n  returns (uint256)\r\n  {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  /**\r\n  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n  * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n  * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n  * @param spender The address which will spend the funds.\r\n  * @param value The amount of tokens to be spent.\r\n  */\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n  * approve should be called when allowed_[_spender] == 0. To increment\r\n  * allowed value is better to use this function to avoid 2 calls (and wait until\r\n  * the first transaction is mined)\r\n  * From MonolithDAO Token.sol\r\n  * @param spender The address which will spend the funds.\r\n  * @param addedValue The amount of tokens to increase the allowance by.\r\n  */\r\n  function increaseAllowance(\r\n    address spender,\r\n    uint256 addedValue\r\n  )\r\n  public\r\n  returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n    _allowed[msg.sender][spender].add(addedValue));\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n  * approve should be called when allowed_[_spender] == 0. To decrement\r\n  * allowed value is better to use this function to avoid 2 calls (and wait until\r\n  * the first transaction is mined)\r\n  * From MonolithDAO Token.sol\r\n  * @param spender The address which will spend the funds.\r\n  * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n  */\r\n  function decreaseAllowance(\r\n    address spender,\r\n    uint256 subtractedValue\r\n  )\r\n  public\r\n  returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n    _allowed[msg.sender][spender].sub(subtractedValue));\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds a user to whitelist\r\n  * @param _member address to add to whitelist\r\n  */\r\n  function addToWhiteList(address _member) public onlyOperator returns (bool) {\r\n    whiteListed[_member] = true;\r\n    emit WhiteListed(_member);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev removes a user from whitelist\r\n  * @param _member address to remove from whitelist\r\n  */\r\n  function removeFromWhiteList(address _member) public onlyOperator returns (bool) {\r\n    whiteListed[_member] = false;\r\n    emit BlackListed(_member);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev change operator address\r\n  * @param _newOperator address of new operator\r\n  */\r\n  function changeOperator(address _newOperator) public onlyOperator returns (bool) {\r\n    operator = _newOperator;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev burns an amount of the tokens of the message sender\r\n  * account.\r\n  * @param amount The amount that will be burnt.\r\n  */\r\n  function burn(uint256 amount) public returns (bool) {\r\n    _burn(msg.sender, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Burns a specific amount of tokens from the target address and decrements allowance\r\n  * @param from address The address which you want to send tokens from\r\n  * @param value uint256 The amount of token to be burned\r\n  */\r\n  function burnFrom(address from, uint256 value) public returns (bool) {\r\n    _burnFrom(from, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev function that mints an amount of the token and assigns it to\r\n  * an account.\r\n  * @param account The account that will receive the created tokens.\r\n  * @param amount The amount that will be created.\r\n  */\r\n  function mint(address account, uint256 amount) public onlyOperator {\r\n    _mint(account, amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function transfer(address to, uint256 value) public canTransfer(to) returns (bool) {\r\n\r\n    require(isLockedForMV[msg.sender] < now); // if not voted under governance\r\n    require(value <= _balances[msg.sender]);\r\n    _transfer(to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer tokens to the operator from the specified address\r\n  * @param from The address to transfer from.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function operatorTransfer(address from, uint256 value) public onlyOperator returns (bool) {\r\n    require(value <= _balances[from]);\r\n    _transferFrom(from, operator, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer tokens from one address to another\r\n  * @param from address The address which you want to send tokens from\r\n  * @param to address The address which you want to transfer to\r\n  * @param value uint256 the amount of tokens to be transferred\r\n  */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n  public\r\n  canTransfer(to)\r\n  returns (bool)\r\n  {\r\n    require(isLockedForMV[from] < now); // if not voted under governance\r\n    require(value <= _balances[from]);\r\n    require(value <= _allowed[from][msg.sender]);\r\n    _transferFrom(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Lock the user's tokens\r\n   * @param _of user's address.\r\n   */\r\n  function lockForMemberVote(address _of, uint _days) public onlyOperator {\r\n    if (_days.add(now) > isLockedForMV[_of])\r\n      isLockedForMV[_of] = _days.add(now);\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function _transfer(address to, uint256 value) internal {\r\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    emit Transfer(msg.sender, to, value);\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer tokens from one address to another\r\n  * @param from address The address which you want to send tokens from\r\n  * @param to address The address which you want to transfer to\r\n  * @param value uint256 the amount of tokens to be transferred\r\n  */\r\n  function _transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n  internal\r\n  {\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal function that mints an amount of the token and assigns it to\r\n  * an account. This encapsulates the modification of balances such that the\r\n  * proper events are emitted.\r\n  * @param account The account that will receive the created tokens.\r\n  * @param amount The amount that will be created.\r\n  */\r\n  function _mint(address account, uint256 amount) internal {\r\n    require(account != address(0));\r\n    _totalSupply = _totalSupply.add(amount);\r\n    _balances[account] = _balances[account].add(amount);\r\n    emit Transfer(address(0), account, amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal function that burns an amount of the token of a given\r\n  * account.\r\n  * @param account The account whose tokens will be burnt.\r\n  * @param amount The amount that will be burnt.\r\n  */\r\n  function _burn(address account, uint256 amount) internal {\r\n    require(amount <= _balances[account]);\r\n\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    _balances[account] = _balances[account].sub(amount);\r\n    emit Transfer(account, address(0), amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal function that burns an amount of the token of a given\r\n  * account, deducting from the sender's allowance for said account. Uses the\r\n  * internal burn function.\r\n  * @param account The account whose tokens will be burnt.\r\n  * @param value The amount that will be burnt.\r\n  */\r\n  function _burnFrom(address account, uint256 value) internal {\r\n    require(value <= _allowed[account][msg.sender]);\r\n\r\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n    // this function needs to emit an event with the updated approval.\r\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\r\n      value);\r\n    _burn(account, value);\r\n  }\r\n}\r\n\r\n// File: contracts/modules/token/external/IERC1132.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC1132 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/1132\r\n */\r\n\r\ncontract IERC1132 {\r\n  /**\r\n   * @dev Reasons why a user's tokens have been locked\r\n   */\r\n  mapping(address => bytes32[]) public lockReason;\r\n\r\n  /**\r\n   * @dev locked token structure\r\n   */\r\n  struct LockToken {\r\n    uint256 amount;\r\n    uint256 validity;\r\n    bool claimed;\r\n  }\r\n\r\n  /**\r\n   * @dev Holds number & validity of tokens locked for a given reason for\r\n   *      a specified address\r\n   */\r\n  mapping(address => mapping(bytes32 => LockToken)) public locked;\r\n\r\n  /**\r\n   * @dev Records data of all the tokens Locked\r\n   */\r\n  event Locked(\r\n    address indexed _of,\r\n    bytes32 indexed _reason,\r\n    uint256 _amount,\r\n    uint256 _validity\r\n  );\r\n\r\n  /**\r\n   * @dev Records data of all the tokens unlocked\r\n   */\r\n  event Unlocked(\r\n    address indexed _of,\r\n    bytes32 indexed _reason,\r\n    uint256 _amount\r\n  );\r\n\r\n  /**\r\n   * @dev Locks a specified amount of tokens against an address,\r\n   *      for a specified reason and time\r\n   * @param _reason The reason to lock tokens\r\n   * @param _amount Number of tokens to be locked\r\n   * @param _time Lock time in seconds\r\n   */\r\n  function lock(bytes32 _reason, uint256 _amount, uint256 _time)\r\n  public returns (bool);\r\n\r\n  /**\r\n   * @dev Returns tokens locked for a specified address for a\r\n   *      specified reason\r\n   *\r\n   * @param _of The address whose tokens are locked\r\n   * @param _reason The reason to query the lock tokens for\r\n   */\r\n  function tokensLocked(address _of, bytes32 _reason)\r\n  public view returns (uint256 amount);\r\n\r\n  /**\r\n   * @dev Returns tokens locked for a specified address for a\r\n   *      specified reason at a specific time\r\n   *\r\n   * @param _of The address whose tokens are locked\r\n   * @param _reason The reason to query the lock tokens for\r\n   * @param _time The timestamp to query the lock tokens for\r\n   */\r\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n  public view returns (uint256 amount);\r\n\r\n  /**\r\n   * @dev Returns total tokens held by an address (locked + transferable)\r\n   * @param _of The address to query the total balance of\r\n   */\r\n  function totalBalanceOf(address _of)\r\n  public view returns (uint256 amount);\r\n\r\n  /**\r\n   * @dev Extends lock for a specified reason and time\r\n   * @param _reason The reason to lock tokens\r\n   * @param _time Lock extension time in seconds\r\n   */\r\n  function extendLock(bytes32 _reason, uint256 _time)\r\n  public returns (bool);\r\n\r\n  /**\r\n   * @dev Increase number of tokens locked for a specified reason\r\n   * @param _reason The reason to lock tokens\r\n   * @param _amount Number of tokens to be increased\r\n   */\r\n  function increaseLockAmount(bytes32 _reason, uint256 _amount)\r\n  public returns (bool);\r\n\r\n  /**\r\n   * @dev Returns unlockable tokens for a specified address for a specified reason\r\n   * @param _of The address to query the the unlockable token count of\r\n   * @param _reason The reason to query the unlockable tokens for\r\n   */\r\n  function tokensUnlockable(address _of, bytes32 _reason)\r\n  public view returns (uint256 amount);\r\n\r\n  /**\r\n   * @dev Unlocks the unlockable tokens of a specified address\r\n   * @param _of Address of user, claiming back unlockable tokens\r\n   */\r\n  function unlock(address _of)\r\n  public returns (uint256 unlockableTokens);\r\n\r\n  /**\r\n   * @dev Gets the unlockable tokens of a specified address\r\n   * @param _of The address to query the the unlockable token count of\r\n   */\r\n  function getUnlockableTokens(address _of)\r\n  public view returns (uint256 unlockableTokens);\r\n\r\n}\r\n\r\n// File: contracts/modules/token/TokenController.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU General Public License as published by\r\n  the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n  along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract TokenController is IERC1132, Iupgradable {\r\n  using SafeMath for uint256;\r\n\r\n  event Burned(address indexed member, bytes32 lockedUnder, uint256 amount);\r\n\r\n  NXMToken public token;\r\n  IPooledStaking public pooledStaking;\r\n  uint public minCALockTime = uint(30).mul(1 days);\r\n  bytes32 private constant CLA = bytes32(\"CLA\");\r\n\r\n  /**\r\n  * @dev Just for interface\r\n  */\r\n  function changeDependentContractAddress() public {\r\n    token = NXMToken(ms.tokenAddress());\r\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\"PS\"));\r\n  }\r\n\r\n  /**\r\n   * @dev to change the operator address\r\n   * @param _newOperator is the new address of operator\r\n   */\r\n  function changeOperator(address _newOperator) public onlyInternal {\r\n    token.changeOperator(_newOperator);\r\n  }\r\n\r\n  /**\r\n   * @dev Proxies token transfer through this contract to allow staking when members are locked for voting\r\n   * @param _from   Source address\r\n   * @param _to     Destination address\r\n   * @param _value  Amount to transfer\r\n   */\r\n  function operatorTransfer(address _from, address _to, uint _value) onlyInternal external returns (bool) {\r\n    require(msg.sender == address(pooledStaking), \"Call is only allowed from PooledStaking address\");\r\n    require(token.operatorTransfer(_from, _value), \"Operator transfer failed\");\r\n    require(token.transfer(_to, _value), \"Internal transfer failed\");\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Locks a specified amount of tokens,\r\n  *    for CLA reason and for a specified time\r\n  * @param _reason The reason to lock tokens, currently restricted to CLA\r\n  * @param _amount Number of tokens to be locked\r\n  * @param _time Lock time in seconds\r\n  */\r\n  function lock(bytes32 _reason, uint256 _amount, uint256 _time) public checkPause returns (bool)\r\n  {\r\n    require(_reason == CLA, \"Restricted to reason CLA\");\r\n    require(minCALockTime <= _time, \"Should lock for minimum time\");\r\n    // If tokens are already locked, then functions extendLock or\r\n    // increaseLockAmount should be used to make any changes\r\n    _lock(msg.sender, _reason, _amount, _time);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Locks a specified amount of tokens against an address,\r\n  *    for a specified reason and time\r\n  * @param _reason The reason to lock tokens\r\n  * @param _amount Number of tokens to be locked\r\n  * @param _time Lock time in seconds\r\n  * @param _of address whose tokens are to be locked\r\n  */\r\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time)\r\n  public\r\n  onlyInternal\r\n  returns (bool)\r\n  {\r\n    // If tokens are already locked, then functions extendLock or\r\n    // increaseLockAmount should be used to make any changes\r\n    _lock(_of, _reason, _amount, _time);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Extends lock for reason CLA for a specified time\r\n  * @param _reason The reason to lock tokens, currently restricted to CLA\r\n  * @param _time Lock extension time in seconds\r\n  */\r\n  function extendLock(bytes32 _reason, uint256 _time)\r\n  public\r\n  checkPause\r\n  returns (bool)\r\n  {\r\n    require(_reason == CLA, \"Restricted to reason CLA\");\r\n    _extendLock(msg.sender, _reason, _time);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Extends lock for a specified reason and time\r\n  * @param _reason The reason to lock tokens\r\n  * @param _time Lock extension time in seconds\r\n  */\r\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time)\r\n  public\r\n  onlyInternal\r\n  returns (bool)\r\n  {\r\n    _extendLock(_of, _reason, _time);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Increase number of tokens locked for a CLA reason\r\n  * @param _reason The reason to lock tokens, currently restricted to CLA\r\n  * @param _amount Number of tokens to be increased\r\n  */\r\n  function increaseLockAmount(bytes32 _reason, uint256 _amount)\r\n  public\r\n  checkPause\r\n  returns (bool)\r\n  {\r\n    require(_reason == CLA, \"Restricted to reason CLA\");\r\n    require(_tokensLocked(msg.sender, _reason) > 0);\r\n    token.operatorTransfer(msg.sender, _amount);\r\n\r\n    locked[msg.sender][_reason].amount = locked[msg.sender][_reason].amount.add(_amount);\r\n    emit Locked(msg.sender, _reason, _amount, locked[msg.sender][_reason].validity);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev burns tokens of an address\r\n   * @param _of is the address to burn tokens of\r\n   * @param amount is the amount to burn\r\n   * @return the boolean status of the burning process\r\n   */\r\n  function burnFrom(address _of, uint amount) public onlyInternal returns (bool) {\r\n    return token.burnFrom(_of, amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Burns locked tokens of a user\r\n  * @param _of address whose tokens are to be burned\r\n  * @param _reason lock reason for which tokens are to be burned\r\n  * @param _amount amount of tokens to burn\r\n  */\r\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) public onlyInternal {\r\n    _burnLockedTokens(_of, _reason, _amount);\r\n  }\r\n\r\n  /**\r\n  * @dev reduce lock duration for a specified reason and time\r\n  * @param _of The address whose tokens are locked\r\n  * @param _reason The reason to lock tokens\r\n  * @param _time Lock reduction time in seconds\r\n  */\r\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) public onlyInternal {\r\n    _reduceLock(_of, _reason, _time);\r\n  }\r\n\r\n  /**\r\n  * @dev Released locked tokens of an address locked for a specific reason\r\n  * @param _of address whose tokens are to be released from lock\r\n  * @param _reason reason of the lock\r\n  * @param _amount amount of tokens to release\r\n  */\r\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount)\r\n  public\r\n  onlyInternal\r\n  {\r\n    _releaseLockedTokens(_of, _reason, _amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Adds an address to whitelist maintained in the contract\r\n  * @param _member address to add to whitelist\r\n  */\r\n  function addToWhitelist(address _member) public onlyInternal {\r\n    token.addToWhiteList(_member);\r\n  }\r\n\r\n  /**\r\n  * @dev Removes an address from the whitelist in the token\r\n  * @param _member address to remove\r\n  */\r\n  function removeFromWhitelist(address _member) public onlyInternal {\r\n    token.removeFromWhiteList(_member);\r\n  }\r\n\r\n  /**\r\n  * @dev Mints new token for an address\r\n  * @param _member address to reward the minted tokens\r\n  * @param _amount number of tokens to mint\r\n  */\r\n  function mint(address _member, uint _amount) public onlyInternal {\r\n    token.mint(_member, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Lock the user's tokens\r\n   * @param _of user's address.\r\n   */\r\n  function lockForMemberVote(address _of, uint _days) public onlyInternal {\r\n    token.lockForMemberVote(_of, _days);\r\n  }\r\n\r\n  /**\r\n  * @dev Unlocks the unlockable tokens against CLA of a specified address\r\n  * @param _of Address of user, claiming back unlockable tokens against CLA\r\n  */\r\n  function unlock(address _of)\r\n  public\r\n  checkPause\r\n  returns (uint256 unlockableTokens)\r\n  {\r\n    unlockableTokens = _tokensUnlockable(_of, CLA);\r\n    if (unlockableTokens > 0) {\r\n      locked[_of][CLA].claimed = true;\r\n      emit Unlocked(_of, CLA, unlockableTokens);\r\n      require(token.transfer(_of, unlockableTokens));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Updates Uint Parameters of a code\r\n   * @param code whose details we want to update\r\n   * @param val value to set\r\n   */\r\n  function updateUintParameters(bytes8 code, uint val) public {\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    if (code == \"MNCLT\") {\r\n      minCALockTime = val.mul(1 days);\r\n    } else {\r\n      revert(\"Invalid param code\");\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the validity of locked tokens of a specified address\r\n  * @param _of The address to query the validity\r\n  * @param reason reason for which tokens were locked\r\n  */\r\n  function getLockedTokensValidity(address _of, bytes32 reason)\r\n  public\r\n  view\r\n  returns (uint256 validity)\r\n  {\r\n    validity = locked[_of][reason].validity;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the unlockable tokens of a specified address\r\n  * @param _of The address to query the the unlockable token count of\r\n  */\r\n  function getUnlockableTokens(address _of)\r\n  public\r\n  view\r\n  returns (uint256 unlockableTokens)\r\n  {\r\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n      unlockableTokens = unlockableTokens.add(_tokensUnlockable(_of, lockReason[_of][i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Returns tokens locked for a specified address for a\r\n  *    specified reason\r\n  *\r\n  * @param _of The address whose tokens are locked\r\n  * @param _reason The reason to query the lock tokens for\r\n  */\r\n  function tokensLocked(address _of, bytes32 _reason)\r\n  public\r\n  view\r\n  returns (uint256 amount)\r\n  {\r\n    return _tokensLocked(_of, _reason);\r\n  }\r\n\r\n  /**\r\n  * @dev Returns unlockable tokens for a specified address for a specified reason\r\n  * @param _of The address to query the the unlockable token count of\r\n  * @param _reason The reason to query the unlockable tokens for\r\n  */\r\n  function tokensUnlockable(address _of, bytes32 _reason)\r\n  public\r\n  view\r\n  returns (uint256 amount)\r\n  {\r\n    return _tokensUnlockable(_of, _reason);\r\n  }\r\n\r\n  function totalSupply() public view returns (uint256)\r\n  {\r\n    return token.totalSupply();\r\n  }\r\n\r\n  /**\r\n  * @dev Returns tokens locked for a specified address for a\r\n  *    specified reason at a specific time\r\n  *\r\n  * @param _of The address whose tokens are locked\r\n  * @param _reason The reason to query the lock tokens for\r\n  * @param _time The timestamp to query the lock tokens for\r\n  */\r\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n  public\r\n  view\r\n  returns (uint256 amount)\r\n  {\r\n    return _tokensLockedAtTime(_of, _reason, _time);\r\n  }\r\n\r\n  /**\r\n  * @dev Returns the total amount of tokens held by an address:\r\n  *   transferable + locked + staked for pooled staking - pending burns.\r\n  *   Used by Claims and Governance in member voting to calculate the user's vote weight.\r\n  *\r\n  * @param _of The address to query the total balance of\r\n  * @param _of The address to query the total balance of\r\n  */\r\n  function totalBalanceOf(address _of) public view returns (uint256 amount) {\r\n\r\n    amount = token.balanceOf(_of);\r\n\r\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n      amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\r\n    }\r\n\r\n    uint stakerReward = pooledStaking.stakerReward(_of);\r\n    uint stakerDeposit = pooledStaking.stakerDeposit(_of);\r\n\r\n    amount = amount.add(stakerDeposit).add(stakerReward);\r\n  }\r\n\r\n  /**\r\n  * @dev Returns the total locked tokens at time\r\n  *   Returns the total amount of locked and staked tokens at a given time. Used by MemberRoles to check eligibility\r\n  *   for withdraw / switch membership. Includes tokens locked for Claim Assessment and staked for Risk Assessment.\r\n  *   Does not take into account pending burns.\r\n  *\r\n  * @param _of member whose locked tokens are to be calculate\r\n  * @param _time timestamp when the tokens should be locked\r\n  */\r\n  function totalLockedBalance(address _of, uint256 _time) public view returns (uint256 amount) {\r\n\r\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n      amount = amount.add(_tokensLockedAtTime(_of, lockReason[_of][i], _time));\r\n    }\r\n\r\n    amount = amount.add(pooledStaking.stakerDeposit(_of));\r\n  }\r\n\r\n  /**\r\n  * @dev Locks a specified amount of tokens against an address,\r\n  *    for a specified reason and time\r\n  * @param _of address whose tokens are to be locked\r\n  * @param _reason The reason to lock tokens\r\n  * @param _amount Number of tokens to be locked\r\n  * @param _time Lock time in seconds\r\n  */\r\n  function _lock(address _of, bytes32 _reason, uint256 _amount, uint256 _time) internal {\r\n    require(_tokensLocked(_of, _reason) == 0);\r\n    require(_amount != 0);\r\n\r\n    if (locked[_of][_reason].amount == 0) {\r\n      lockReason[_of].push(_reason);\r\n    }\r\n\r\n    require(token.operatorTransfer(_of, _amount));\r\n\r\n    uint256 validUntil = now.add(_time); // solhint-disable-line\r\n    locked[_of][_reason] = LockToken(_amount, validUntil, false);\r\n    emit Locked(_of, _reason, _amount, validUntil);\r\n  }\r\n\r\n  /**\r\n  * @dev Returns tokens locked for a specified address for a\r\n  *    specified reason\r\n  *\r\n  * @param _of The address whose tokens are locked\r\n  * @param _reason The reason to query the lock tokens for\r\n  */\r\n  function _tokensLocked(address _of, bytes32 _reason)\r\n  internal\r\n  view\r\n  returns (uint256 amount)\r\n  {\r\n    if (!locked[_of][_reason].claimed) {\r\n      amount = locked[_of][_reason].amount;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Returns tokens locked for a specified address for a\r\n  *    specified reason at a specific time\r\n  *\r\n  * @param _of The address whose tokens are locked\r\n  * @param _reason The reason to query the lock tokens for\r\n  * @param _time The timestamp to query the lock tokens for\r\n  */\r\n  function _tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n  internal\r\n  view\r\n  returns (uint256 amount)\r\n  {\r\n    if (locked[_of][_reason].validity > _time) {\r\n      amount = locked[_of][_reason].amount;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Extends lock for a specified reason and time\r\n  * @param _of The address whose tokens are locked\r\n  * @param _reason The reason to lock tokens\r\n  * @param _time Lock extension time in seconds\r\n  */\r\n  function _extendLock(address _of, bytes32 _reason, uint256 _time) internal {\r\n    require(_tokensLocked(_of, _reason) > 0);\r\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\r\n    locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);\r\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\r\n  }\r\n\r\n  /**\r\n  * @dev reduce lock duration for a specified reason and time\r\n  * @param _of The address whose tokens are locked\r\n  * @param _reason The reason to lock tokens\r\n  * @param _time Lock reduction time in seconds\r\n  */\r\n  function _reduceLock(address _of, bytes32 _reason, uint256 _time) internal {\r\n    require(_tokensLocked(_of, _reason) > 0);\r\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\r\n    locked[_of][_reason].validity = locked[_of][_reason].validity.sub(_time);\r\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\r\n  }\r\n\r\n  /**\r\n  * @dev Returns unlockable tokens for a specified address for a specified reason\r\n  * @param _of The address to query the the unlockable token count of\r\n  * @param _reason The reason to query the unlockable tokens for\r\n  */\r\n  function _tokensUnlockable(address _of, bytes32 _reason) internal view returns (uint256 amount)\r\n  {\r\n    if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) {\r\n      amount = locked[_of][_reason].amount;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Burns locked tokens of a user\r\n  * @param _of address whose tokens are to be burned\r\n  * @param _reason lock reason for which tokens are to be burned\r\n  * @param _amount amount of tokens to burn\r\n  */\r\n  function _burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal {\r\n    uint256 amount = _tokensLocked(_of, _reason);\r\n    require(amount >= _amount);\r\n\r\n    if (amount == _amount) {\r\n      locked[_of][_reason].claimed = true;\r\n    }\r\n\r\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\r\n    if (locked[_of][_reason].amount == 0) {\r\n      _removeReason(_of, _reason);\r\n    }\r\n    token.burn(_amount);\r\n    emit Burned(_of, _reason, _amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Released locked tokens of an address locked for a specific reason\r\n  * @param _of address whose tokens are to be released from lock\r\n  * @param _reason reason of the lock\r\n  * @param _amount amount of tokens to release\r\n  */\r\n  function _releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal\r\n  {\r\n    uint256 amount = _tokensLocked(_of, _reason);\r\n    require(amount >= _amount);\r\n\r\n    if (amount == _amount) {\r\n      locked[_of][_reason].claimed = true;\r\n    }\r\n\r\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\r\n    if (locked[_of][_reason].amount == 0) {\r\n      _removeReason(_of, _reason);\r\n    }\r\n    require(token.transfer(_of, _amount));\r\n    emit Unlocked(_of, _reason, _amount);\r\n  }\r\n\r\n  function _removeReason(address _of, bytes32 _reason) internal {\r\n    uint len = lockReason[_of].length;\r\n    for (uint i = 0; i < len; i++) {\r\n      if (lockReason[_of][i] == _reason) {\r\n        lockReason[_of][i] = lockReason[_of][len.sub(1)];\r\n        lockReason[_of].pop();\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/modules/governance/external/Governed.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ninterface IMaster {\r\n  function getLatestAddress(bytes2 _module) external view returns (address);\r\n}\r\n\r\ncontract Governed {\r\n\r\n  address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\r\n\r\n  /// @dev modifier that allows only the authorized addresses to execute the function\r\n  modifier onlyAuthorizedToGovern() {\r\n    IMaster ms = IMaster(masterAddress);\r\n    require(ms.getLatestAddress(\"GV\") == msg.sender, \"Not authorized\");\r\n    _;\r\n  }\r\n\r\n  /// @dev checks if an address is authorized to govern\r\n  function isAuthorizedToGovern(address _toCheck) public view returns (bool) {\r\n    IMaster ms = IMaster(masterAddress);\r\n    return (ms.getLatestAddress(\"GV\") == _toCheck);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/modules/governance/external/IProposalCategory.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IProposalCategory {\r\n\r\n  event Category(\r\n    uint indexed categoryId,\r\n    string categoryName,\r\n    string actionHash\r\n  );\r\n\r\n  /// @dev Adds new category\r\n  /// @param _name Category name\r\n  /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n  /// @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n  /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n  /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n  /// @param _closingTime Vote closing time for Each voting layer\r\n  /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n  /// @param _contractAddress address of contract to call after proposal is accepted\r\n  /// @param _contractName name of contract to be called after proposal is accepted\r\n  /// @param _incentives rewards to distributed after proposal is accepted\r\n  function addCategory(\r\n    string calldata _name,\r\n    uint _memberRoleToVote,\r\n    uint _majorityVotePerc,\r\n    uint _quorumPerc,\r\n    uint[] calldata _allowedToCreateProposal,\r\n    uint _closingTime,\r\n    string calldata _actionHash,\r\n    address _contractAddress,\r\n    bytes2 _contractName,\r\n    uint[] calldata _incentives\r\n  )\r\n  external;\r\n\r\n  /// @dev gets category details\r\n  function category(uint _categoryId)\r\n  external\r\n  view\r\n  returns (\r\n    uint categoryId,\r\n    uint memberRoleToVote,\r\n    uint majorityVotePerc,\r\n    uint quorumPerc,\r\n    uint[] memory allowedToCreateProposal,\r\n    uint closingTime,\r\n    uint minStake\r\n  );\r\n\r\n  ///@dev gets category action details\r\n  function categoryAction(uint _categoryId)\r\n  external\r\n  view\r\n  returns (\r\n    uint categoryId,\r\n    address contractAddress,\r\n    bytes2 contractName,\r\n    uint defaultIncentive\r\n  );\r\n\r\n  /// @dev Gets Total number of categories added till now\r\n  function totalCategories() external view returns (uint numberOfCategories);\r\n\r\n  /// @dev Updates category details\r\n  /// @param _categoryId Category id that needs to be updated\r\n  /// @param _name Category name\r\n  /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n  /// @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n  /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n  /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n  /// @param _closingTime Vote closing time for Each voting layer\r\n  /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n  /// @param _contractAddress address of contract to call after proposal is accepted\r\n  /// @param _contractName name of contract to be called after proposal is accepted\r\n  /// @param _incentives rewards to distributed after proposal is accepted\r\n  function updateCategory(\r\n    uint _categoryId,\r\n    string memory _name,\r\n    uint _memberRoleToVote,\r\n    uint _majorityVotePerc,\r\n    uint _quorumPerc,\r\n    uint[] memory _allowedToCreateProposal,\r\n    uint _closingTime,\r\n    string memory _actionHash,\r\n    address _contractAddress,\r\n    bytes2 _contractName,\r\n    uint[] memory _incentives\r\n  )\r\n  public;\r\n\r\n}\r\n\r\n// File: contracts/modules/governance/ProposalCategory.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract ProposalCategory is Governed, IProposalCategory, Iupgradable {\r\n\r\n  bool public constructorCheck;\r\n  MemberRoles internal mr;\r\n\r\n  struct CategoryStruct {\r\n    uint memberRoleToVote;\r\n    uint majorityVotePerc;\r\n    uint quorumPerc;\r\n    uint[] allowedToCreateProposal;\r\n    uint closingTime;\r\n    uint minStake;\r\n  }\r\n\r\n  struct CategoryAction {\r\n    uint defaultIncentive;\r\n    address contractAddress;\r\n    bytes2 contractName;\r\n  }\r\n\r\n  CategoryStruct[] internal allCategory;\r\n  mapping(uint => CategoryAction) internal categoryActionData;\r\n  mapping(uint => uint) public categoryABReq;\r\n  mapping(uint => uint) public isSpecialResolution;\r\n  mapping(uint => bytes) public categoryActionHashes;\r\n\r\n  bool public categoryActionHashUpdated;\r\n\r\n  /**\r\n  * @dev Adds new category (Discontinued, moved functionality to newCategory)\r\n  * @param _name Category name\r\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n  * @param _closingTime Vote closing time for Each voting layer\r\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n  * @param _contractAddress address of contract to call after proposal is accepted\r\n  * @param _contractName name of contract to be called after proposal is accepted\r\n  * @param _incentives rewards to distributed after proposal is accepted\r\n  */\r\n  function addCategory(\r\n    string calldata _name,\r\n    uint _memberRoleToVote,\r\n    uint _majorityVotePerc,\r\n    uint _quorumPerc,\r\n    uint[] calldata _allowedToCreateProposal,\r\n    uint _closingTime,\r\n    string calldata _actionHash,\r\n    address _contractAddress,\r\n    bytes2 _contractName,\r\n    uint[] calldata _incentives\r\n  ) external {}\r\n\r\n  /**\r\n  * @dev Initiates Default settings for Proposal Category contract (Adding default categories)\r\n  */\r\n  function proposalCategoryInitiate() external {}\r\n\r\n  /**\r\n  * @dev Initiates Default action function hashes for existing categories\r\n  * To be called after the contract has been upgraded by governance\r\n  */\r\n  function updateCategoryActionHashes() external onlyOwner {\r\n\r\n    require(!categoryActionHashUpdated, \"Category action hashes already updated\");\r\n    categoryActionHashUpdated = true;\r\n    categoryActionHashes[1] = abi.encodeWithSignature(\"addRole(bytes32,string,address)\");\r\n    categoryActionHashes[2] = abi.encodeWithSignature(\"updateRole(address,uint256,bool)\");\r\n    categoryActionHashes[3] = abi.encodeWithSignature(\"newCategory(string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\"); // solhint-disable-line\r\n    categoryActionHashes[4] = abi.encodeWithSignature(\"editCategory(uint256,string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\"); // solhint-disable-line\r\n    categoryActionHashes[5] = abi.encodeWithSignature(\"upgradeContractImplementation(bytes2,address)\");\r\n    categoryActionHashes[6] = abi.encodeWithSignature(\"startEmergencyPause()\");\r\n    categoryActionHashes[7] = abi.encodeWithSignature(\"addEmergencyPause(bool,bytes4)\");\r\n    categoryActionHashes[8] = abi.encodeWithSignature(\"burnCAToken(uint256,uint256,address)\");\r\n    categoryActionHashes[9] = abi.encodeWithSignature(\"setUserClaimVotePausedOn(address)\");\r\n    categoryActionHashes[12] = abi.encodeWithSignature(\"transferEther(uint256,address)\");\r\n    categoryActionHashes[13] = abi.encodeWithSignature(\"addInvestmentAssetCurrency(bytes4,address,bool,uint64,uint64,uint8)\"); // solhint-disable-line\r\n    categoryActionHashes[14] = abi.encodeWithSignature(\"changeInvestmentAssetHoldingPerc(bytes4,uint64,uint64)\");\r\n    categoryActionHashes[15] = abi.encodeWithSignature(\"changeInvestmentAssetStatus(bytes4,bool)\");\r\n    categoryActionHashes[16] = abi.encodeWithSignature(\"swapABMember(address,address)\");\r\n    categoryActionHashes[17] = abi.encodeWithSignature(\"addCurrencyAssetCurrency(bytes4,address,uint256)\");\r\n    categoryActionHashes[20] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n    categoryActionHashes[21] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n    categoryActionHashes[22] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n    categoryActionHashes[23] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n    categoryActionHashes[24] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n    categoryActionHashes[25] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n    categoryActionHashes[26] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n    categoryActionHashes[27] = abi.encodeWithSignature(\"updateAddressParameters(bytes8,address)\");\r\n    categoryActionHashes[28] = abi.encodeWithSignature(\"updateOwnerParameters(bytes8,address)\");\r\n    categoryActionHashes[29] = abi.encodeWithSignature(\"upgradeMultipleContracts(bytes2[],address[])\");\r\n    categoryActionHashes[30] = abi.encodeWithSignature(\"changeCurrencyAssetAddress(bytes4,address)\");\r\n    categoryActionHashes[31] = abi.encodeWithSignature(\"changeCurrencyAssetBaseMin(bytes4,uint256)\");\r\n    categoryActionHashes[32] = abi.encodeWithSignature(\"changeInvestmentAssetAddressAndDecimal(bytes4,address,uint8)\"); // solhint-disable-line\r\n    categoryActionHashes[33] = abi.encodeWithSignature(\"externalLiquidityTrade()\");\r\n  }\r\n\r\n  /**\r\n  * @dev Gets Total number of categories added till now\r\n  */\r\n  function totalCategories() external view returns (uint) {\r\n    return allCategory.length;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets category details\r\n  */\r\n  function category(uint _categoryId) external view returns (uint, uint, uint, uint, uint[] memory, uint, uint) {\r\n    return (\r\n    _categoryId,\r\n    allCategory[_categoryId].memberRoleToVote,\r\n    allCategory[_categoryId].majorityVotePerc,\r\n    allCategory[_categoryId].quorumPerc,\r\n    allCategory[_categoryId].allowedToCreateProposal,\r\n    allCategory[_categoryId].closingTime,\r\n    allCategory[_categoryId].minStake\r\n    );\r\n  }\r\n\r\n  /**\r\n  * @dev Gets category ab required and isSpecialResolution\r\n  * @return the category id\r\n  * @return if AB voting is required\r\n  * @return is category a special resolution\r\n  */\r\n  function categoryExtendedData(uint _categoryId) external view returns (uint, uint, uint) {\r\n    return (\r\n    _categoryId,\r\n    categoryABReq[_categoryId],\r\n    isSpecialResolution[_categoryId]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the category acion details\r\n   * @param _categoryId is the category id in concern\r\n   * @return the category id\r\n   * @return the contract address\r\n   * @return the contract name\r\n   * @return the default incentive\r\n   */\r\n  function categoryAction(uint _categoryId) external view returns (uint, address, bytes2, uint) {\r\n\r\n    return (\r\n    _categoryId,\r\n    categoryActionData[_categoryId].contractAddress,\r\n    categoryActionData[_categoryId].contractName,\r\n    categoryActionData[_categoryId].defaultIncentive\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the category acion details of a category id\r\n   * @param _categoryId is the category id in concern\r\n   * @return the category id\r\n   * @return the contract address\r\n   * @return the contract name\r\n   * @return the default incentive\r\n   * @return action function hash\r\n   */\r\n  function categoryActionDetails(uint _categoryId) external view returns (uint, address, bytes2, uint, bytes memory) {\r\n    return (\r\n    _categoryId,\r\n    categoryActionData[_categoryId].contractAddress,\r\n    categoryActionData[_categoryId].contractName,\r\n    categoryActionData[_categoryId].defaultIncentive,\r\n    categoryActionHashes[_categoryId]\r\n    );\r\n  }\r\n\r\n  /**\r\n  * @dev Updates dependant contract addresses\r\n  */\r\n  function changeDependentContractAddress() public {\r\n    mr = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n  }\r\n\r\n  /**\r\n  * @dev Adds new category\r\n  * @param _name Category name\r\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n  * @param _closingTime Vote closing time for Each voting layer\r\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n  * @param _contractAddress address of contract to call after proposal is accepted\r\n  * @param _contractName name of contract to be called after proposal is accepted\r\n  * @param _incentives rewards to distributed after proposal is accepted\r\n  * @param _functionHash function signature to be executed\r\n  */\r\n  function newCategory(\r\n    string memory _name,\r\n    uint _memberRoleToVote,\r\n    uint _majorityVotePerc,\r\n    uint _quorumPerc,\r\n    uint[] memory _allowedToCreateProposal,\r\n    uint _closingTime,\r\n    string memory _actionHash,\r\n    address _contractAddress,\r\n    bytes2 _contractName,\r\n    uint[] memory _incentives,\r\n    string memory _functionHash\r\n  )\r\n  public\r\n  onlyAuthorizedToGovern\r\n  {\r\n\r\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\r\n\r\n    require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\r\n\r\n    require(_incentives[3] <= 1, \"Invalid special resolution flag\");\r\n\r\n    //If category is special resolution role authorized should be member\r\n    if (_incentives[3] == 1) {\r\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\r\n      _majorityVotePerc = 0;\r\n      _quorumPerc = 0;\r\n    }\r\n\r\n    _addCategory(\r\n      _name,\r\n      _memberRoleToVote,\r\n      _majorityVotePerc,\r\n      _quorumPerc,\r\n      _allowedToCreateProposal,\r\n      _closingTime,\r\n      _actionHash,\r\n      _contractAddress,\r\n      _contractName,\r\n      _incentives\r\n    );\r\n\r\n\r\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\r\n      categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the master address and update it's instance\r\n   * @param _masterAddress is the new master address\r\n   */\r\n  function changeMasterAddress(address _masterAddress) public {\r\n    if (masterAddress != address(0))\r\n      require(masterAddress == msg.sender);\r\n    masterAddress = _masterAddress;\r\n    ms = INXMMaster(_masterAddress);\r\n    nxMasterAddress = _masterAddress;\r\n\r\n  }\r\n\r\n  /**\r\n  * @dev Updates category details (Discontinued, moved functionality to editCategory)\r\n  * @param _categoryId Category id that needs to be updated\r\n  * @param _name Category name\r\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n  * @param _closingTime Vote closing time for Each voting layer\r\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n  * @param _contractAddress address of contract to call after proposal is accepted\r\n  * @param _contractName name of contract to be called after proposal is accepted\r\n  * @param _incentives rewards to distributed after proposal is accepted\r\n  */\r\n  function updateCategory(\r\n    uint _categoryId,\r\n    string memory _name,\r\n    uint _memberRoleToVote,\r\n    uint _majorityVotePerc,\r\n    uint _quorumPerc,\r\n    uint[] memory _allowedToCreateProposal,\r\n    uint _closingTime,\r\n    string memory _actionHash,\r\n    address _contractAddress,\r\n    bytes2 _contractName,\r\n    uint[] memory _incentives\r\n  ) public {}\r\n\r\n  /**\r\n  * @dev Updates category details\r\n  * @param _categoryId Category id that needs to be updated\r\n  * @param _name Category name\r\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n  * @param _closingTime Vote closing time for Each voting layer\r\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n  * @param _contractAddress address of contract to call after proposal is accepted\r\n  * @param _contractName name of contract to be called after proposal is accepted\r\n  * @param _incentives rewards to distributed after proposal is accepted\r\n  * @param _functionHash function signature to be executed\r\n  */\r\n  function editCategory(\r\n    uint _categoryId,\r\n    string memory _name,\r\n    uint _memberRoleToVote,\r\n    uint _majorityVotePerc,\r\n    uint _quorumPerc,\r\n    uint[] memory _allowedToCreateProposal,\r\n    uint _closingTime,\r\n    string memory _actionHash,\r\n    address _contractAddress,\r\n    bytes2 _contractName,\r\n    uint[] memory _incentives,\r\n    string memory _functionHash\r\n  )\r\n  public\r\n  onlyAuthorizedToGovern\r\n  {\r\n    require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\r\n\r\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\r\n\r\n    require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\r\n\r\n    require(_incentives[3] <= 1, \"Invalid special resolution flag\");\r\n\r\n    //If category is special resolution role authorized should be member\r\n    if (_incentives[3] == 1) {\r\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\r\n      _majorityVotePerc = 0;\r\n      _quorumPerc = 0;\r\n    }\r\n\r\n    delete categoryActionHashes[_categoryId];\r\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\r\n      categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\r\n    }\r\n    allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\r\n    allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\r\n    allCategory[_categoryId].closingTime = _closingTime;\r\n    allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\r\n    allCategory[_categoryId].minStake = _incentives[0];\r\n    allCategory[_categoryId].quorumPerc = _quorumPerc;\r\n    categoryActionData[_categoryId].defaultIncentive = _incentives[1];\r\n    categoryActionData[_categoryId].contractName = _contractName;\r\n    categoryActionData[_categoryId].contractAddress = _contractAddress;\r\n    categoryABReq[_categoryId] = _incentives[2];\r\n    isSpecialResolution[_categoryId] = _incentives[3];\r\n    emit Category(_categoryId, _name, _actionHash);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal call to add new category\r\n  * @param _name Category name\r\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n  * @param _closingTime Vote closing time for Each voting layer\r\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n  * @param _contractAddress address of contract to call after proposal is accepted\r\n  * @param _contractName name of contract to be called after proposal is accepted\r\n  * @param _incentives rewards to distributed after proposal is accepted\r\n  */\r\n  function _addCategory(\r\n    string memory _name,\r\n    uint _memberRoleToVote,\r\n    uint _majorityVotePerc,\r\n    uint _quorumPerc,\r\n    uint[] memory _allowedToCreateProposal,\r\n    uint _closingTime,\r\n    string memory _actionHash,\r\n    address _contractAddress,\r\n    bytes2 _contractName,\r\n    uint[] memory _incentives\r\n  )\r\n  internal\r\n  {\r\n    require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\r\n    allCategory.push(\r\n      CategoryStruct(\r\n        _memberRoleToVote,\r\n        _majorityVotePerc,\r\n        _quorumPerc,\r\n        _allowedToCreateProposal,\r\n        _closingTime,\r\n        _incentives[0]\r\n      )\r\n    );\r\n    uint categoryId = allCategory.length - 1;\r\n    categoryActionData[categoryId] = CategoryAction(_incentives[1], _contractAddress, _contractName);\r\n    categoryABReq[categoryId] = _incentives[2];\r\n    isSpecialResolution[categoryId] = _incentives[3];\r\n    emit Category(categoryId, _name, _actionHash);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal call to check if given roles are valid or not\r\n  */\r\n  function _verifyMemberRoles(uint _memberRoleToVote, uint[] memory _allowedToCreateProposal)\r\n  internal view returns (uint) {\r\n    uint totalRoles = mr.totalRoles();\r\n    if (_memberRoleToVote >= totalRoles) {\r\n      return 0;\r\n    }\r\n    for (uint i = 0; i < _allowedToCreateProposal.length; i++) {\r\n      if (_allowedToCreateProposal[i] >= totalRoles) {\r\n        return 0;\r\n      }\r\n    }\r\n    return 1;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/modules/governance/external/IGovernance.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IGovernance {\r\n\r\n  event Proposal(\r\n    address indexed proposalOwner,\r\n    uint256 indexed proposalId,\r\n    uint256 dateAdd,\r\n    string proposalTitle,\r\n    string proposalSD,\r\n    string proposalDescHash\r\n  );\r\n\r\n  event Solution(\r\n    uint256 indexed proposalId,\r\n    address indexed solutionOwner,\r\n    uint256 indexed solutionId,\r\n    string solutionDescHash,\r\n    uint256 dateAdd\r\n  );\r\n\r\n  event Vote(\r\n    address indexed from,\r\n    uint256 indexed proposalId,\r\n    uint256 indexed voteId,\r\n    uint256 dateAdd,\r\n    uint256 solutionChosen\r\n  );\r\n\r\n  event RewardClaimed(\r\n    address indexed member,\r\n    uint gbtReward\r\n  );\r\n\r\n  /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal.\r\n  event VoteCast (uint256 proposalId);\r\n\r\n  /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can\r\n  ///      call any offchain actions\r\n  event ProposalAccepted (uint256 proposalId);\r\n\r\n  /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\r\n  event CloseProposalOnTime (\r\n    uint256 indexed proposalId,\r\n    uint256 time\r\n  );\r\n\r\n  /// @dev ActionSuccess event is called whenever an onchain action is executed.\r\n  event ActionSuccess (\r\n    uint256 proposalId\r\n  );\r\n\r\n  /// @dev Creates a new proposal\r\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n  function createProposal(\r\n    string calldata _proposalTitle,\r\n    string calldata _proposalSD,\r\n    string calldata _proposalDescHash,\r\n    uint _categoryId\r\n  )\r\n  external;\r\n\r\n  /// @dev Edits the details of an existing proposal and creates new version\r\n  /// @param _proposalId Proposal id that details needs to be updated\r\n  /// @param _proposalDescHash Proposal description hash having long and short description of proposal.\r\n  function updateProposal(\r\n    uint _proposalId,\r\n    string calldata _proposalTitle,\r\n    string calldata _proposalSD,\r\n    string calldata _proposalDescHash\r\n  )\r\n  external;\r\n\r\n  /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\r\n  function categorizeProposal(\r\n    uint _proposalId,\r\n    uint _categoryId,\r\n    uint _incentives\r\n  )\r\n  external;\r\n\r\n  /// @dev Submit proposal with solution\r\n  /// @param _proposalId Proposal id\r\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n  function submitProposalWithSolution(\r\n    uint _proposalId,\r\n    string calldata _solutionHash,\r\n    bytes calldata _action\r\n  )\r\n  external;\r\n\r\n  /// @dev Creates a new proposal with solution and votes for the solution\r\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n  function createProposalwithSolution(\r\n    string calldata _proposalTitle,\r\n    string calldata _proposalSD,\r\n    string calldata _proposalDescHash,\r\n    uint _categoryId,\r\n    string calldata _solutionHash,\r\n    bytes calldata _action\r\n  )\r\n  external;\r\n\r\n  /// @dev Casts vote\r\n  /// @param _proposalId Proposal id\r\n  /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\r\n  function submitVote(uint _proposalId, uint _solutionChosen) external;\r\n\r\n  function closeProposal(uint _proposalId) external;\r\n\r\n  function claimReward(address _memberAddress, uint _maxRecords) external returns (uint pendingDAppReward);\r\n\r\n  function proposal(uint _proposalId)\r\n  external\r\n  view\r\n  returns (\r\n    uint proposalId,\r\n    uint category,\r\n    uint status,\r\n    uint finalVerdict,\r\n    uint totalReward\r\n  );\r\n\r\n  function canCloseProposal(uint _proposalId) public view returns (uint closeValue);\r\n\r\n  function allowedToCatgorize() public view returns (uint roleId);\r\n\r\n}\r\n\r\n// File: contracts/modules/governance/Governance.sol\r\n\r\n// /* Copyright (C) 2017 GovBlocks.io\r\n\r\n//   This program is free software: you can redistribute it and/or modify\r\n//     it under the terms of the GNU General Public License as published by\r\n//     the Free Software Foundation, either version 3 of the License, or\r\n//     (at your option) any later version.\r\n\r\n//   This program is distributed in the hope that it will be useful,\r\n//     but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n//     GNU General Public License for more details.\r\n\r\n//   You should have received a copy of the GNU General Public License\r\n//     along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract Governance is IGovernance, Iupgradable {\r\n\r\n  using SafeMath for uint;\r\n\r\n  enum ProposalStatus {\r\n    Draft,\r\n    AwaitingSolution,\r\n    VotingStarted,\r\n    Accepted,\r\n    Rejected,\r\n    Majority_Not_Reached_But_Accepted,\r\n    Denied\r\n  }\r\n\r\n  struct ProposalData {\r\n    uint propStatus;\r\n    uint finalVerdict;\r\n    uint category;\r\n    uint commonIncentive;\r\n    uint dateUpd;\r\n    address owner;\r\n  }\r\n\r\n  struct ProposalVote {\r\n    address voter;\r\n    uint proposalId;\r\n    uint dateAdd;\r\n  }\r\n\r\n  struct VoteTally {\r\n    mapping(uint => uint) memberVoteValue;\r\n    mapping(uint => uint) abVoteValue;\r\n    uint voters;\r\n  }\r\n\r\n  struct DelegateVote {\r\n    address follower;\r\n    address leader;\r\n    uint lastUpd;\r\n  }\r\n\r\n  ProposalVote[] internal allVotes;\r\n  DelegateVote[] public allDelegation;\r\n\r\n  mapping(uint => ProposalData) internal allProposalData;\r\n  mapping(uint => bytes[]) internal allProposalSolutions;\r\n  mapping(address => uint[]) internal allVotesByMember;\r\n  mapping(uint => mapping(address => bool)) public rewardClaimed;\r\n  mapping(address => mapping(uint => uint)) public memberProposalVote;\r\n  mapping(address => uint) public followerDelegation;\r\n  mapping(address => uint) internal followerCount;\r\n  mapping(address => uint[]) internal leaderDelegation;\r\n  mapping(uint => VoteTally) public proposalVoteTally;\r\n  mapping(address => bool) public isOpenForDelegation;\r\n  mapping(address => uint) public lastRewardClaimed;\r\n\r\n  bool internal constructorCheck;\r\n  uint public tokenHoldingTime;\r\n  uint internal roleIdAllowedToCatgorize;\r\n  uint internal maxVoteWeigthPer;\r\n  uint internal specialResolutionMajPerc;\r\n  uint internal maxFollowers;\r\n  uint internal totalProposals;\r\n  uint internal maxDraftTime;\r\n\r\n  MemberRoles internal memberRole;\r\n  ProposalCategory internal proposalCategory;\r\n  TokenController internal tokenInstance;\r\n\r\n  mapping(uint => uint) public proposalActionStatus;\r\n  mapping(uint => uint) internal proposalExecutionTime;\r\n  mapping(uint => mapping(address => bool)) public proposalRejectedByAB;\r\n  mapping(uint => uint) internal actionRejectedCount;\r\n\r\n  bool internal actionParamsInitialised;\r\n  uint internal actionWaitingTime;\r\n  uint constant internal AB_MAJ_TO_REJECT_ACTION = 3;\r\n\r\n  enum ActionStatus {\r\n    Pending,\r\n    Accepted,\r\n    Rejected,\r\n    Executed,\r\n    NoAction\r\n  }\r\n\r\n  /**\r\n  * @dev Called whenever an action execution is failed.\r\n  */\r\n  event ActionFailed (\r\n    uint256 proposalId\r\n  );\r\n\r\n  /**\r\n  * @dev Called whenever an AB member rejects the action execution.\r\n  */\r\n  event ActionRejected (\r\n    uint256 indexed proposalId,\r\n    address rejectedBy\r\n  );\r\n\r\n  /**\r\n  * @dev Checks if msg.sender is proposal owner\r\n  */\r\n  modifier onlyProposalOwner(uint _proposalId) {\r\n    require(msg.sender == allProposalData[_proposalId].owner, \"Not allowed\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if proposal is opened for voting\r\n  */\r\n  modifier voteNotStarted(uint _proposalId) {\r\n    require(allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted));\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if msg.sender is allowed to create proposal under given category\r\n  */\r\n  modifier isAllowed(uint _categoryId) {\r\n    require(allowedToCreateProposal(_categoryId), \"Not allowed\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if msg.sender is allowed categorize proposal under given category\r\n  */\r\n  modifier isAllowedToCategorize() {\r\n    require(memberRole.checkRole(msg.sender, roleIdAllowedToCatgorize), \"Not allowed\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if msg.sender had any pending rewards to be claimed\r\n  */\r\n  modifier checkPendingRewards {\r\n    require(getPendingReward(msg.sender) == 0, \"Claim reward\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Event emitted whenever a proposal is categorized\r\n  */\r\n  event ProposalCategorized(\r\n    uint indexed proposalId,\r\n    address indexed categorizedBy,\r\n    uint categoryId\r\n  );\r\n\r\n  /**\r\n   * @dev Removes delegation of an address.\r\n   * @param _add address to undelegate.\r\n   */\r\n  function removeDelegation(address _add) external onlyInternal {\r\n    _unDelegate(_add);\r\n  }\r\n\r\n  /**\r\n  * @dev Creates a new proposal\r\n  * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n  * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n  */\r\n  function createProposal(\r\n    string calldata _proposalTitle,\r\n    string calldata _proposalSD,\r\n    string calldata _proposalDescHash,\r\n    uint _categoryId\r\n  )\r\n  external isAllowed(_categoryId)\r\n  {\r\n    require(ms.isMember(msg.sender), \"Not Member\");\r\n\r\n    _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\r\n  }\r\n\r\n  /**\r\n  * @dev Edits the details of an existing proposal\r\n  * @param _proposalId Proposal id that details needs to be updated\r\n  * @param _proposalDescHash Proposal description hash having long and short description of proposal.\r\n  */\r\n  function updateProposal(\r\n    uint _proposalId,\r\n    string calldata _proposalTitle,\r\n    string calldata _proposalSD,\r\n    string calldata _proposalDescHash\r\n  )\r\n  external onlyProposalOwner(_proposalId)\r\n  {\r\n    require(\r\n      allProposalSolutions[_proposalId].length < 2,\r\n      \"Not allowed\"\r\n    );\r\n    allProposalData[_proposalId].propStatus = uint(ProposalStatus.Draft);\r\n    allProposalData[_proposalId].category = 0;\r\n    allProposalData[_proposalId].commonIncentive = 0;\r\n    emit Proposal(\r\n      allProposalData[_proposalId].owner,\r\n      _proposalId,\r\n      now,\r\n      _proposalTitle,\r\n      _proposalSD,\r\n      _proposalDescHash\r\n    );\r\n  }\r\n\r\n  /**\r\n  * @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\r\n  */\r\n  function categorizeProposal(\r\n    uint _proposalId,\r\n    uint _categoryId,\r\n    uint _incentive\r\n  )\r\n  external\r\n  voteNotStarted(_proposalId) isAllowedToCategorize\r\n  {\r\n    _categorizeProposal(_proposalId, _categoryId, _incentive);\r\n  }\r\n\r\n  /**\r\n  * @dev Submit proposal with solution\r\n  * @param _proposalId Proposal id\r\n  * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n  */\r\n  function submitProposalWithSolution(\r\n    uint _proposalId,\r\n    string calldata _solutionHash,\r\n    bytes calldata _action\r\n  )\r\n  external\r\n  onlyProposalOwner(_proposalId)\r\n  {\r\n\r\n    require(allProposalData[_proposalId].propStatus == uint(ProposalStatus.AwaitingSolution));\r\n\r\n    _proposalSubmission(_proposalId, _solutionHash, _action);\r\n  }\r\n\r\n  /**\r\n  * @dev Creates a new proposal with solution\r\n  * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n  * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n  * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n  */\r\n  function createProposalwithSolution(\r\n    string calldata _proposalTitle,\r\n    string calldata _proposalSD,\r\n    string calldata _proposalDescHash,\r\n    uint _categoryId,\r\n    string calldata _solutionHash,\r\n    bytes calldata _action\r\n  )\r\n  external isAllowed(_categoryId)\r\n  {\r\n\r\n\r\n    uint proposalId = totalProposals;\r\n\r\n    _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\r\n\r\n    require(_categoryId > 0);\r\n\r\n    _proposalSubmission(\r\n      proposalId,\r\n      _solutionHash,\r\n      _action\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Submit a vote on the proposal.\r\n   * @param _proposalId to vote upon.\r\n   * @param _solutionChosen is the chosen vote.\r\n   */\r\n  function submitVote(uint _proposalId, uint _solutionChosen) external {\r\n\r\n    require(allProposalData[_proposalId].propStatus ==\r\n      uint(Governance.ProposalStatus.VotingStarted), \"Not allowed\");\r\n\r\n    require(_solutionChosen < allProposalSolutions[_proposalId].length);\r\n\r\n\r\n    _submitVote(_proposalId, _solutionChosen);\r\n  }\r\n\r\n  /**\r\n   * @dev Closes the proposal.\r\n   * @param _proposalId of proposal to be closed.\r\n   */\r\n  function closeProposal(uint _proposalId) external {\r\n    uint category = allProposalData[_proposalId].category;\r\n\r\n\r\n    uint _memberRole;\r\n    if (allProposalData[_proposalId].dateUpd.add(maxDraftTime) <= now &&\r\n      allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted)) {\r\n      _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n    } else {\r\n      require(canCloseProposal(_proposalId) == 1);\r\n      (, _memberRole,,,,,) = proposalCategory.category(allProposalData[_proposalId].category);\r\n      if (_memberRole == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n        _closeAdvisoryBoardVote(_proposalId, category);\r\n      } else {\r\n        _closeMemberVote(_proposalId, category);\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Claims reward for member.\r\n   * @param _memberAddress to claim reward of.\r\n   * @param _maxRecords maximum number of records to claim reward for.\r\n   _proposals list of proposals of which reward will be claimed.\r\n   * @return amount of pending reward.\r\n   */\r\n  function claimReward(address _memberAddress, uint _maxRecords)\r\n  external returns (uint pendingDAppReward)\r\n  {\r\n\r\n    uint voteId;\r\n    address leader;\r\n    uint lastUpd;\r\n\r\n    require(msg.sender == ms.getLatestAddress(\"CR\"));\r\n\r\n    uint delegationId = followerDelegation[_memberAddress];\r\n    DelegateVote memory delegationData = allDelegation[delegationId];\r\n    if (delegationId > 0 && delegationData.leader != address(0)) {\r\n      leader = delegationData.leader;\r\n      lastUpd = delegationData.lastUpd;\r\n    } else\r\n      leader = _memberAddress;\r\n\r\n    uint proposalId;\r\n    uint totalVotes = allVotesByMember[leader].length;\r\n    uint lastClaimed = totalVotes;\r\n    uint j;\r\n    uint i;\r\n    for (i = lastRewardClaimed[_memberAddress]; i < totalVotes && j < _maxRecords; i++) {\r\n      voteId = allVotesByMember[leader][i];\r\n      proposalId = allVotes[voteId].proposalId;\r\n      if (proposalVoteTally[proposalId].voters > 0 && (allVotes[voteId].dateAdd > (\r\n      lastUpd.add(tokenHoldingTime)) || leader == _memberAddress)) {\r\n        if (allProposalData[proposalId].propStatus > uint(ProposalStatus.VotingStarted)) {\r\n          if (!rewardClaimed[voteId][_memberAddress]) {\r\n            pendingDAppReward = pendingDAppReward.add(\r\n              allProposalData[proposalId].commonIncentive.div(\r\n                proposalVoteTally[proposalId].voters\r\n              )\r\n            );\r\n            rewardClaimed[voteId][_memberAddress] = true;\r\n            j++;\r\n          }\r\n        } else {\r\n          if (lastClaimed == totalVotes) {\r\n            lastClaimed = i;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (lastClaimed == totalVotes) {\r\n      lastRewardClaimed[_memberAddress] = i;\r\n    } else {\r\n      lastRewardClaimed[_memberAddress] = lastClaimed;\r\n    }\r\n\r\n    if (j > 0) {\r\n      emit RewardClaimed(\r\n        _memberAddress,\r\n        pendingDAppReward\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets delegation acceptance status of individual user\r\n   * @param _status delegation acceptance status\r\n   */\r\n  function setDelegationStatus(bool _status) external isMemberAndcheckPause checkPendingRewards {\r\n    isOpenForDelegation[msg.sender] = _status;\r\n  }\r\n\r\n  /**\r\n   * @dev Delegates vote to an address.\r\n   * @param _add is the address to delegate vote to.\r\n   */\r\n  function delegateVote(address _add) external isMemberAndcheckPause checkPendingRewards {\r\n\r\n    require(ms.masterInitialized());\r\n\r\n    require(allDelegation[followerDelegation[_add]].leader == address(0));\r\n\r\n    if (followerDelegation[msg.sender] > 0) {\r\n      require((allDelegation[followerDelegation[msg.sender]].lastUpd).add(tokenHoldingTime) < now);\r\n    }\r\n\r\n    require(!alreadyDelegated(msg.sender));\r\n    require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.Owner)));\r\n    require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)));\r\n\r\n\r\n    require(followerCount[_add] < maxFollowers);\r\n\r\n    if (allVotesByMember[msg.sender].length > 0) {\r\n      require((allVotes[allVotesByMember[msg.sender][allVotesByMember[msg.sender].length - 1]].dateAdd).add(tokenHoldingTime)\r\n        < now);\r\n    }\r\n\r\n    require(ms.isMember(_add));\r\n\r\n    require(isOpenForDelegation[_add]);\r\n\r\n    allDelegation.push(DelegateVote(msg.sender, _add, now));\r\n    followerDelegation[msg.sender] = allDelegation.length - 1;\r\n    leaderDelegation[_add].push(allDelegation.length - 1);\r\n    followerCount[_add]++;\r\n    lastRewardClaimed[msg.sender] = allVotesByMember[_add].length;\r\n  }\r\n\r\n  /**\r\n   * @dev Undelegates the sender\r\n   */\r\n  function unDelegate() external isMemberAndcheckPause checkPendingRewards {\r\n    _unDelegate(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Triggers action of accepted proposal after waiting time is finished\r\n   */\r\n  function triggerAction(uint _proposalId) external {\r\n    require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted) && proposalExecutionTime[_proposalId] <= now, \"Cannot trigger\");\r\n    _triggerAction(_proposalId, allProposalData[_proposalId].category);\r\n  }\r\n\r\n  /**\r\n   * @dev Provides option to Advisory board member to reject proposal action execution within actionWaitingTime, if found suspicious\r\n   */\r\n  function rejectAction(uint _proposalId) external {\r\n    require(memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && proposalExecutionTime[_proposalId] > now);\r\n\r\n    require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted));\r\n\r\n    require(!proposalRejectedByAB[_proposalId][msg.sender]);\r\n\r\n    require(\r\n      keccak256(proposalCategory.categoryActionHashes(allProposalData[_proposalId].category))\r\n      != keccak256(abi.encodeWithSignature(\"swapABMember(address,address)\"))\r\n    );\r\n\r\n    proposalRejectedByAB[_proposalId][msg.sender] = true;\r\n    actionRejectedCount[_proposalId]++;\r\n    emit ActionRejected(_proposalId, msg.sender);\r\n    if (actionRejectedCount[_proposalId] == AB_MAJ_TO_REJECT_ACTION) {\r\n      proposalActionStatus[_proposalId] = uint(ActionStatus.Rejected);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets intial actionWaitingTime value\r\n   * To be called after governance implementation has been updated\r\n   */\r\n  function setInitialActionParameters() external onlyOwner {\r\n    require(!actionParamsInitialised);\r\n    actionParamsInitialised = true;\r\n    actionWaitingTime = 24 * 1 hours;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Uint Parameters of a code\r\n   * @param code whose details we want\r\n   * @return string value of the code\r\n   * @return associated amount (time or perc or value) to the code\r\n   */\r\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\r\n\r\n    codeVal = code;\r\n\r\n    if (code == \"GOVHOLD\") {\r\n\r\n      val = tokenHoldingTime / (1 days);\r\n\r\n    } else if (code == \"MAXFOL\") {\r\n\r\n      val = maxFollowers;\r\n\r\n    } else if (code == \"MAXDRFT\") {\r\n\r\n      val = maxDraftTime / (1 days);\r\n\r\n    } else if (code == \"EPTIME\") {\r\n\r\n      val = ms.pauseTime() / (1 days);\r\n\r\n    } else if (code == \"ACWT\") {\r\n\r\n      val = actionWaitingTime / (1 hours);\r\n\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets all details of a propsal\r\n   * @param _proposalId whose details we want\r\n   * @return proposalId\r\n   * @return category\r\n   * @return status\r\n   * @return finalVerdict\r\n   * @return totalReward\r\n   */\r\n  function proposal(uint _proposalId)\r\n  external\r\n  view\r\n  returns (\r\n    uint proposalId,\r\n    uint category,\r\n    uint status,\r\n    uint finalVerdict,\r\n    uint totalRewar\r\n  )\r\n  {\r\n    return (\r\n    _proposalId,\r\n    allProposalData[_proposalId].category,\r\n    allProposalData[_proposalId].propStatus,\r\n    allProposalData[_proposalId].finalVerdict,\r\n    allProposalData[_proposalId].commonIncentive\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets some details of a propsal\r\n   * @param _proposalId whose details we want\r\n   * @return proposalId\r\n   * @return number of all proposal solutions\r\n   * @return amount of votes\r\n   */\r\n  function proposalDetails(uint _proposalId) external view returns (uint, uint, uint) {\r\n    return (\r\n    _proposalId,\r\n    allProposalSolutions[_proposalId].length,\r\n    proposalVoteTally[_proposalId].voters\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets solution action on a proposal\r\n   * @param _proposalId whose details we want\r\n   * @param _solution whose details we want\r\n   * @return action of a solution on a proposal\r\n   */\r\n  function getSolutionAction(uint _proposalId, uint _solution) external view returns (uint, bytes memory) {\r\n    return (\r\n    _solution,\r\n    allProposalSolutions[_proposalId][_solution]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets length of propsal\r\n   * @return length of propsal\r\n   */\r\n  function getProposalLength() external view returns (uint) {\r\n    return totalProposals;\r\n  }\r\n\r\n  /**\r\n   * @dev Get followers of an address\r\n   * @return get followers of an address\r\n   */\r\n  function getFollowers(address _add) external view returns (uint[] memory) {\r\n    return leaderDelegation[_add];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets pending rewards of a member\r\n   * @param _memberAddress in concern\r\n   * @return amount of pending reward\r\n   */\r\n  function getPendingReward(address _memberAddress)\r\n  public view returns (uint pendingDAppReward)\r\n  {\r\n    uint delegationId = followerDelegation[_memberAddress];\r\n    address leader;\r\n    uint lastUpd;\r\n    DelegateVote memory delegationData = allDelegation[delegationId];\r\n\r\n    if (delegationId > 0 && delegationData.leader != address(0)) {\r\n      leader = delegationData.leader;\r\n      lastUpd = delegationData.lastUpd;\r\n    } else\r\n      leader = _memberAddress;\r\n\r\n    uint proposalId;\r\n    for (uint i = lastRewardClaimed[_memberAddress]; i < allVotesByMember[leader].length; i++) {\r\n      if (allVotes[allVotesByMember[leader][i]].dateAdd > (\r\n      lastUpd.add(tokenHoldingTime)) || leader == _memberAddress) {\r\n        if (!rewardClaimed[allVotesByMember[leader][i]][_memberAddress]) {\r\n          proposalId = allVotes[allVotesByMember[leader][i]].proposalId;\r\n          if (proposalVoteTally[proposalId].voters > 0 && allProposalData[proposalId].propStatus\r\n          > uint(ProposalStatus.VotingStarted)) {\r\n            pendingDAppReward = pendingDAppReward.add(\r\n              allProposalData[proposalId].commonIncentive.div(\r\n                proposalVoteTally[proposalId].voters\r\n              )\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Updates Uint Parameters of a code\r\n   * @param code whose details we want to update\r\n   * @param val value to set\r\n   */\r\n  function updateUintParameters(bytes8 code, uint val) public {\r\n\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    if (code == \"GOVHOLD\") {\r\n\r\n      tokenHoldingTime = val * 1 days;\r\n\r\n    } else if (code == \"MAXFOL\") {\r\n\r\n      maxFollowers = val;\r\n\r\n    } else if (code == \"MAXDRFT\") {\r\n\r\n      maxDraftTime = val * 1 days;\r\n\r\n    } else if (code == \"EPTIME\") {\r\n\r\n      ms.updatePauseTime(val * 1 days);\r\n\r\n    } else if (code == \"ACWT\") {\r\n\r\n      actionWaitingTime = val * 1 hours;\r\n\r\n    } else {\r\n\r\n      revert(\"Invalid code\");\r\n\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Updates all dependency addresses to latest ones from Master\r\n  */\r\n  function changeDependentContractAddress() public {\r\n    tokenInstance = TokenController(ms.dAppLocker());\r\n    memberRole = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n    proposalCategory = ProposalCategory(ms.getLatestAddress(\"PC\"));\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if msg.sender is allowed to create a proposal under given category\r\n  */\r\n  function allowedToCreateProposal(uint category) public view returns (bool check) {\r\n    if (category == 0)\r\n      return true;\r\n    uint[] memory mrAllowed;\r\n    (,,,, mrAllowed,,) = proposalCategory.category(category);\r\n    for (uint i = 0; i < mrAllowed.length; i++) {\r\n      if (mrAllowed[i] == 0 || memberRole.checkRole(msg.sender, mrAllowed[i]))\r\n        return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if an address is already delegated\r\n   * @param _add in concern\r\n   * @return bool value if the address is delegated or not\r\n   */\r\n  function alreadyDelegated(address _add) public view returns (bool delegated) {\r\n    for (uint i = 0; i < leaderDelegation[_add].length; i++) {\r\n      if (allDelegation[leaderDelegation[_add][i]].leader == _add) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Checks If the proposal voting time is up and it's ready to close\r\n  *      i.e. Closevalue is 1 if proposal is ready to be closed, 2 if already closed, 0 otherwise!\r\n  * @param _proposalId Proposal id to which closing value is being checked\r\n  */\r\n  function canCloseProposal(uint _proposalId)\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    uint dateUpdate;\r\n    uint pStatus;\r\n    uint _closingTime;\r\n    uint _roleId;\r\n    uint majority;\r\n    pStatus = allProposalData[_proposalId].propStatus;\r\n    dateUpdate = allProposalData[_proposalId].dateUpd;\r\n    (, _roleId, majority, , , _closingTime,) = proposalCategory.category(allProposalData[_proposalId].category);\r\n    if (\r\n      pStatus == uint(ProposalStatus.VotingStarted)\r\n    ) {\r\n      uint numberOfMembers = memberRole.numberOfMembers(_roleId);\r\n      if (_roleId == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n        if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers) >= majority\r\n        || proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0]) == numberOfMembers\r\n          || dateUpdate.add(_closingTime) <= now) {\r\n\r\n          return 1;\r\n        }\r\n      } else {\r\n        if (numberOfMembers == proposalVoteTally[_proposalId].voters\r\n          || dateUpdate.add(_closingTime) <= now)\r\n          return 1;\r\n      }\r\n    } else if (pStatus > uint(ProposalStatus.VotingStarted)) {\r\n      return 2;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Id of member role allowed to categorize the proposal\r\n   * @return roleId allowed to categorize the proposal\r\n   */\r\n  function allowedToCatgorize() public view returns (uint roleId) {\r\n    return roleIdAllowedToCatgorize;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets vote tally data\r\n   * @param _proposalId in concern\r\n   * @param _solution of a proposal id\r\n   * @return member vote value\r\n   * @return advisory board vote value\r\n   * @return amount of votes\r\n   */\r\n  function voteTallyData(uint _proposalId, uint _solution) public view returns (uint, uint, uint) {\r\n    return (proposalVoteTally[_proposalId].memberVoteValue[_solution],\r\n    proposalVoteTally[_proposalId].abVoteValue[_solution], proposalVoteTally[_proposalId].voters);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to create proposal\r\n   * @param _proposalTitle of proposal\r\n   * @param _proposalSD is short description of proposal\r\n   * @param _proposalDescHash IPFS hash value of propsal\r\n   * @param _categoryId of proposal\r\n   */\r\n  function _createProposal(\r\n    string memory _proposalTitle,\r\n    string memory _proposalSD,\r\n    string memory _proposalDescHash,\r\n    uint _categoryId\r\n  )\r\n  internal\r\n  {\r\n    require(proposalCategory.categoryABReq(_categoryId) == 0 || _categoryId == 0);\r\n    uint _proposalId = totalProposals;\r\n    allProposalData[_proposalId].owner = msg.sender;\r\n    allProposalData[_proposalId].dateUpd = now;\r\n    allProposalSolutions[_proposalId].push(\"\");\r\n    totalProposals++;\r\n\r\n    emit Proposal(\r\n      msg.sender,\r\n      _proposalId,\r\n      now,\r\n      _proposalTitle,\r\n      _proposalSD,\r\n      _proposalDescHash\r\n    );\r\n\r\n    if (_categoryId > 0)\r\n      _categorizeProposal(_proposalId, _categoryId, 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to categorize a proposal\r\n   * @param _proposalId of proposal\r\n   * @param _categoryId of proposal\r\n   * @param _incentive is commonIncentive\r\n   */\r\n  function _categorizeProposal(\r\n    uint _proposalId,\r\n    uint _categoryId,\r\n    uint _incentive\r\n  )\r\n  internal\r\n  {\r\n    require(\r\n      _categoryId > 0 && _categoryId < proposalCategory.totalCategories(),\r\n      \"Invalid category\"\r\n    );\r\n    allProposalData[_proposalId].category = _categoryId;\r\n    allProposalData[_proposalId].commonIncentive = _incentive;\r\n    allProposalData[_proposalId].propStatus = uint(ProposalStatus.AwaitingSolution);\r\n\r\n    emit ProposalCategorized(_proposalId, msg.sender, _categoryId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to add solution to a proposal\r\n   * @param _proposalId in concern\r\n   * @param _action on that solution\r\n   * @param _solutionHash string value\r\n   */\r\n  function _addSolution(uint _proposalId, bytes memory _action, string memory _solutionHash)\r\n  internal\r\n  {\r\n    allProposalSolutions[_proposalId].push(_action);\r\n    emit Solution(_proposalId, msg.sender, allProposalSolutions[_proposalId].length - 1, _solutionHash, now);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal call to add solution and open proposal for voting\r\n  */\r\n  function _proposalSubmission(\r\n    uint _proposalId,\r\n    string memory _solutionHash,\r\n    bytes memory _action\r\n  )\r\n  internal\r\n  {\r\n\r\n    uint _categoryId = allProposalData[_proposalId].category;\r\n    if (proposalCategory.categoryActionHashes(_categoryId).length == 0) {\r\n      require(keccak256(_action) == keccak256(\"\"));\r\n      proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);\r\n    }\r\n\r\n    _addSolution(\r\n      _proposalId,\r\n      _action,\r\n      _solutionHash\r\n    );\r\n\r\n    _updateProposalStatus(_proposalId, uint(ProposalStatus.VotingStarted));\r\n    (, , , , , uint closingTime,) = proposalCategory.category(_categoryId);\r\n    emit CloseProposalOnTime(_proposalId, closingTime.add(now));\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to submit vote\r\n   * @param _proposalId of proposal in concern\r\n   * @param _solution for that proposal\r\n   */\r\n  function _submitVote(uint _proposalId, uint _solution) internal {\r\n\r\n    uint delegationId = followerDelegation[msg.sender];\r\n    uint mrSequence;\r\n    uint majority;\r\n    uint closingTime;\r\n    (, mrSequence, majority, , , closingTime,) = proposalCategory.category(allProposalData[_proposalId].category);\r\n\r\n    require(allProposalData[_proposalId].dateUpd.add(closingTime) > now, \"Closed\");\r\n\r\n    require(memberProposalVote[msg.sender][_proposalId] == 0, \"Not allowed\");\r\n    require((delegationId == 0) || (delegationId > 0 && allDelegation[delegationId].leader == address(0) &&\r\n    _checkLastUpd(allDelegation[delegationId].lastUpd)));\r\n\r\n    require(memberRole.checkRole(msg.sender, mrSequence), \"Not Authorized\");\r\n    uint totalVotes = allVotes.length;\r\n\r\n    allVotesByMember[msg.sender].push(totalVotes);\r\n    memberProposalVote[msg.sender][_proposalId] = totalVotes;\r\n\r\n    allVotes.push(ProposalVote(msg.sender, _proposalId, now));\r\n\r\n    emit Vote(msg.sender, _proposalId, totalVotes, now, _solution);\r\n    if (mrSequence == uint(MemberRoles.Role.Owner)) {\r\n      if (_solution == 1)\r\n        _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), allProposalData[_proposalId].category, 1, MemberRoles.Role.Owner);\r\n      else\r\n        _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\r\n\r\n    } else {\r\n      uint numberOfMembers = memberRole.numberOfMembers(mrSequence);\r\n      _setVoteTally(_proposalId, _solution, mrSequence);\r\n\r\n      if (mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n        if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers)\r\n        >= majority\r\n          || (proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0])) == numberOfMembers) {\r\n          emit VoteCast(_proposalId);\r\n        }\r\n      } else {\r\n        if (numberOfMembers == proposalVoteTally[_proposalId].voters)\r\n          emit VoteCast(_proposalId);\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to set vote tally of a proposal\r\n   * @param _proposalId of proposal in concern\r\n   * @param _solution of proposal in concern\r\n   * @param mrSequence number of members for a role\r\n   */\r\n  function _setVoteTally(uint _proposalId, uint _solution, uint mrSequence) internal\r\n  {\r\n    uint categoryABReq;\r\n    uint isSpecialResolution;\r\n    (, categoryABReq, isSpecialResolution) = proposalCategory.categoryExtendedData(allProposalData[_proposalId].category);\r\n    if (memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && (categoryABReq > 0) ||\r\n      mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n      proposalVoteTally[_proposalId].abVoteValue[_solution]++;\r\n    }\r\n    tokenInstance.lockForMemberVote(msg.sender, tokenHoldingTime);\r\n    if (mrSequence != uint(MemberRoles.Role.AdvisoryBoard)) {\r\n      uint voteWeight;\r\n      uint voters = 1;\r\n      uint tokenBalance = tokenInstance.totalBalanceOf(msg.sender);\r\n      uint totalSupply = tokenInstance.totalSupply();\r\n      if (isSpecialResolution == 1) {\r\n        voteWeight = tokenBalance.add(10 ** 18);\r\n      } else {\r\n        voteWeight = (_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10 ** 18);\r\n      }\r\n      DelegateVote memory delegationData;\r\n      for (uint i = 0; i < leaderDelegation[msg.sender].length; i++) {\r\n        delegationData = allDelegation[leaderDelegation[msg.sender][i]];\r\n        if (delegationData.leader == msg.sender &&\r\n          _checkLastUpd(delegationData.lastUpd)) {\r\n          if (memberRole.checkRole(delegationData.follower, mrSequence)) {\r\n            tokenBalance = tokenInstance.totalBalanceOf(delegationData.follower);\r\n            tokenInstance.lockForMemberVote(delegationData.follower, tokenHoldingTime);\r\n            voters++;\r\n            if (isSpecialResolution == 1) {\r\n              voteWeight = voteWeight.add(tokenBalance.add(10 ** 18));\r\n            } else {\r\n              voteWeight = voteWeight.add((_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10 ** 18));\r\n            }\r\n          }\r\n        }\r\n      }\r\n      proposalVoteTally[_proposalId].memberVoteValue[_solution] = proposalVoteTally[_proposalId].memberVoteValue[_solution].add(voteWeight);\r\n      proposalVoteTally[_proposalId].voters = proposalVoteTally[_proposalId].voters + voters;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets minimum of two numbers\r\n   * @param a one of the two numbers\r\n   * @param b one of the two numbers\r\n   * @return minimum number out of the two\r\n   */\r\n  function _minOf(uint a, uint b) internal pure returns (uint res) {\r\n    res = a;\r\n    if (res > b)\r\n      res = b;\r\n  }\r\n\r\n  /**\r\n   * @dev Check the time since last update has exceeded token holding time or not\r\n   * @param _lastUpd is last update time\r\n   * @return the bool which tells if the time since last update has exceeded token holding time or not\r\n   */\r\n  function _checkLastUpd(uint _lastUpd) internal view returns (bool) {\r\n    return (now - _lastUpd) > tokenHoldingTime;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if the vote count against any solution passes the threshold value or not.\r\n  */\r\n  function _checkForThreshold(uint _proposalId, uint _category) internal view returns (bool check) {\r\n    uint categoryQuorumPerc;\r\n    uint roleAuthorized;\r\n    (, roleAuthorized, , categoryQuorumPerc, , ,) = proposalCategory.category(_category);\r\n    check = ((proposalVoteTally[_proposalId].memberVoteValue[0]\r\n    .add(proposalVoteTally[_proposalId].memberVoteValue[1]))\r\n    .mul(100))\r\n    .div(\r\n      tokenInstance.totalSupply().add(\r\n        memberRole.numberOfMembers(roleAuthorized).mul(10 ** 18)\r\n      )\r\n    ) >= categoryQuorumPerc;\r\n  }\r\n\r\n  /**\r\n   * @dev Called when vote majority is reached\r\n   * @param _proposalId of proposal in concern\r\n   * @param _status of proposal in concern\r\n   * @param category of proposal in concern\r\n   * @param max vote value of proposal in concern\r\n   */\r\n  function _callIfMajReached(uint _proposalId, uint _status, uint category, uint max, MemberRoles.Role role) internal {\r\n\r\n    allProposalData[_proposalId].finalVerdict = max;\r\n    _updateProposalStatus(_proposalId, _status);\r\n    emit ProposalAccepted(_proposalId);\r\n    if (proposalActionStatus[_proposalId] != uint(ActionStatus.NoAction)) {\r\n      if (role == MemberRoles.Role.AdvisoryBoard) {\r\n        _triggerAction(_proposalId, category);\r\n      } else {\r\n        proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);\r\n        proposalExecutionTime[_proposalId] = actionWaitingTime.add(now);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to trigger action of accepted proposal\r\n   */\r\n  function _triggerAction(uint _proposalId, uint _categoryId) internal {\r\n    proposalActionStatus[_proposalId] = uint(ActionStatus.Executed);\r\n    bytes2 contractName;\r\n    address actionAddress;\r\n    bytes memory _functionHash;\r\n    (, actionAddress, contractName, , _functionHash) = proposalCategory.categoryActionDetails(_categoryId);\r\n    if (contractName == \"MS\") {\r\n      actionAddress = address(ms);\r\n    } else if (contractName != \"EX\") {\r\n      actionAddress = ms.getLatestAddress(contractName);\r\n    }\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool actionStatus,) = actionAddress.call(abi.encodePacked(_functionHash, allProposalSolutions[_proposalId][1]));\r\n    if (actionStatus) {\r\n      emit ActionSuccess(_proposalId);\r\n    } else {\r\n      proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);\r\n      emit ActionFailed(_proposalId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to update proposal status\r\n   * @param _proposalId of proposal in concern\r\n   * @param _status of proposal to set\r\n   */\r\n  function _updateProposalStatus(uint _proposalId, uint _status) internal {\r\n    if (_status == uint(ProposalStatus.Rejected) || _status == uint(ProposalStatus.Denied)) {\r\n      proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);\r\n    }\r\n    allProposalData[_proposalId].dateUpd = now;\r\n    allProposalData[_proposalId].propStatus = _status;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to undelegate a follower\r\n   * @param _follower is address of follower to undelegate\r\n   */\r\n  function _unDelegate(address _follower) internal {\r\n    uint followerId = followerDelegation[_follower];\r\n    if (followerId > 0) {\r\n\r\n      followerCount[allDelegation[followerId].leader] = followerCount[allDelegation[followerId].leader].sub(1);\r\n      allDelegation[followerId].leader = address(0);\r\n      allDelegation[followerId].lastUpd = now;\r\n\r\n      lastRewardClaimed[_follower] = allVotesByMember[_follower].length;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to close member voting\r\n   * @param _proposalId of proposal in concern\r\n   * @param category of proposal in concern\r\n   */\r\n  function _closeMemberVote(uint _proposalId, uint category) internal {\r\n    uint isSpecialResolution;\r\n    uint abMaj;\r\n    (, abMaj, isSpecialResolution) = proposalCategory.categoryExtendedData(category);\r\n    if (isSpecialResolution == 1) {\r\n      uint acceptedVotePerc = proposalVoteTally[_proposalId].memberVoteValue[1].mul(100)\r\n      .div(\r\n        tokenInstance.totalSupply().add(\r\n          memberRole.numberOfMembers(uint(MemberRoles.Role.Member)).mul(10 ** 18)\r\n        ));\r\n      if (acceptedVotePerc >= specialResolutionMajPerc) {\r\n        _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\r\n      } else {\r\n        _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n      }\r\n    } else {\r\n      if (_checkForThreshold(_proposalId, category)) {\r\n        uint majorityVote;\r\n        (,, majorityVote,,,,) = proposalCategory.category(category);\r\n        if (\r\n          ((proposalVoteTally[_proposalId].memberVoteValue[1].mul(100))\r\n          .div(proposalVoteTally[_proposalId].memberVoteValue[0]\r\n          .add(proposalVoteTally[_proposalId].memberVoteValue[1])\r\n          ))\r\n          >= majorityVote\r\n        ) {\r\n          _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\r\n        } else {\r\n          _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\r\n        }\r\n      } else {\r\n        if (abMaj > 0 && proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\r\n        .div(memberRole.numberOfMembers(uint(MemberRoles.Role.AdvisoryBoard))) >= abMaj) {\r\n          _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\r\n        } else {\r\n          _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (proposalVoteTally[_proposalId].voters > 0) {\r\n      tokenInstance.mint(ms.getLatestAddress(\"CR\"), allProposalData[_proposalId].commonIncentive);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to close advisory board voting\r\n   * @param _proposalId of proposal in concern\r\n   * @param category of proposal in concern\r\n   */\r\n  function _closeAdvisoryBoardVote(uint _proposalId, uint category) internal {\r\n    uint _majorityVote;\r\n    MemberRoles.Role _roleId = MemberRoles.Role.AdvisoryBoard;\r\n    (,, _majorityVote,,,,) = proposalCategory.category(category);\r\n    if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\r\n    .div(memberRole.numberOfMembers(uint(_roleId))) >= _majorityVote) {\r\n      _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, _roleId);\r\n    } else {\r\n      _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n    }\r\n\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/modules/token/TokenData.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract TokenData is Iupgradable {\r\n  using SafeMath for uint;\r\n\r\n  address payable public walletAddress;\r\n  uint public lockTokenTimeAfterCoverExp;\r\n  uint public bookTime;\r\n  uint public lockCADays;\r\n  uint public lockMVDays;\r\n  uint public scValidDays;\r\n  uint public joiningFee;\r\n  uint public stakerCommissionPer;\r\n  uint public stakerMaxCommissionPer;\r\n  uint public tokenExponent;\r\n  uint public priceStep;\r\n\r\n  struct StakeCommission {\r\n    uint commissionEarned;\r\n    uint commissionRedeemed;\r\n  }\r\n\r\n  struct Stake {\r\n    address stakedContractAddress;\r\n    uint stakedContractIndex;\r\n    uint dateAdd;\r\n    uint stakeAmount;\r\n    uint unlockedAmount;\r\n    uint burnedAmount;\r\n    uint unLockableBeforeLastBurn;\r\n  }\r\n\r\n  struct Staker {\r\n    address stakerAddress;\r\n    uint stakerIndex;\r\n  }\r\n\r\n  struct CoverNote {\r\n    uint amount;\r\n    bool isDeposited;\r\n  }\r\n\r\n  /**\r\n   * @dev mapping of uw address to array of sc address to fetch\r\n   * all staked contract address of underwriter, pushing\r\n   * data into this array of Stake returns stakerIndex\r\n   */\r\n  mapping(address => Stake[]) public stakerStakedContracts;\r\n\r\n  /**\r\n   * @dev mapping of sc address to array of UW address to fetch\r\n   * all underwritters of the staked smart contract\r\n   * pushing data into this mapped array returns scIndex\r\n   */\r\n  mapping(address => Staker[]) public stakedContractStakers;\r\n\r\n  /**\r\n   * @dev mapping of staked contract Address to the array of StakeCommission\r\n   * here index of this array is stakedContractIndex\r\n   */\r\n  mapping(address => mapping(uint => StakeCommission)) public stakedContractStakeCommission;\r\n\r\n  mapping(address => uint) public lastCompletedStakeCommission;\r\n\r\n  /**\r\n   * @dev mapping of the staked contract address to the current\r\n   * staker index who will receive commission.\r\n   */\r\n  mapping(address => uint) public stakedContractCurrentCommissionIndex;\r\n\r\n  /**\r\n   * @dev mapping of the staked contract address to the\r\n   * current staker index to burn token from.\r\n   */\r\n  mapping(address => uint) public stakedContractCurrentBurnIndex;\r\n\r\n  /**\r\n   * @dev mapping to return true if Cover Note deposited against coverId\r\n   */\r\n  mapping(uint => CoverNote) public depositedCN;\r\n\r\n  mapping(address => uint) internal isBookedTokens;\r\n\r\n  event Commission(\r\n    address indexed stakedContractAddress,\r\n    address indexed stakerAddress,\r\n    uint indexed scIndex,\r\n    uint commissionAmount\r\n  );\r\n\r\n  constructor(address payable _walletAdd) public {\r\n    walletAddress = _walletAdd;\r\n    bookTime = 12 hours;\r\n    joiningFee = 2000000000000000; // 0.002 Ether\r\n    lockTokenTimeAfterCoverExp = 35 days;\r\n    scValidDays = 250;\r\n    lockCADays = 7 days;\r\n    lockMVDays = 2 days;\r\n    stakerCommissionPer = 20;\r\n    stakerMaxCommissionPer = 50;\r\n    tokenExponent = 4;\r\n    priceStep = 1000;\r\n  }\r\n\r\n  /**\r\n   * @dev Change the wallet address which receive Joining Fee\r\n   */\r\n  function changeWalletAddress(address payable _address) external onlyInternal {\r\n    walletAddress = _address;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Uint Parameters of a code\r\n   * @param code whose details we want\r\n   * @return string value of the code\r\n   * @return associated amount (time or perc or value) to the code\r\n   */\r\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\r\n    codeVal = code;\r\n    if (code == \"TOKEXP\") {\r\n\r\n      val = tokenExponent;\r\n\r\n    } else if (code == \"TOKSTEP\") {\r\n\r\n      val = priceStep;\r\n\r\n    } else if (code == \"RALOCKT\") {\r\n\r\n      val = scValidDays;\r\n\r\n    } else if (code == \"RACOMM\") {\r\n\r\n      val = stakerCommissionPer;\r\n\r\n    } else if (code == \"RAMAXC\") {\r\n\r\n      val = stakerMaxCommissionPer;\r\n\r\n    } else if (code == \"CABOOKT\") {\r\n\r\n      val = bookTime / (1 hours);\r\n\r\n    } else if (code == \"CALOCKT\") {\r\n\r\n      val = lockCADays / (1 days);\r\n\r\n    } else if (code == \"MVLOCKT\") {\r\n\r\n      val = lockMVDays / (1 days);\r\n\r\n    } else if (code == \"QUOLOCKT\") {\r\n\r\n      val = lockTokenTimeAfterCoverExp / (1 days);\r\n\r\n    } else if (code == \"JOINFEE\") {\r\n\r\n      val = joiningFee;\r\n\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Just for interface\r\n  */\r\n  function changeDependentContractAddress() public {//solhint-disable-line\r\n  }\r\n\r\n  /**\r\n   * @dev to get the contract staked by a staker\r\n   * @param _stakerAddress is the address of the staker\r\n   * @param _stakerIndex is the index of staker\r\n   * @return the address of staked contract\r\n   */\r\n  function getStakerStakedContractByIndex(\r\n    address _stakerAddress,\r\n    uint _stakerIndex\r\n  )\r\n  public\r\n  view\r\n  returns (address stakedContractAddress)\r\n  {\r\n    stakedContractAddress = stakerStakedContracts[\r\n    _stakerAddress][_stakerIndex].stakedContractAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev to get the staker's staked burned\r\n   * @param _stakerAddress is the address of the staker\r\n   * @param _stakerIndex is the index of staker\r\n   * @return amount burned\r\n   */\r\n  function getStakerStakedBurnedByIndex(\r\n    address _stakerAddress,\r\n    uint _stakerIndex\r\n  )\r\n  public\r\n  view\r\n  returns (uint burnedAmount)\r\n  {\r\n    burnedAmount = stakerStakedContracts[\r\n    _stakerAddress][_stakerIndex].burnedAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev to get the staker's staked unlockable before the last burn\r\n   * @param _stakerAddress is the address of the staker\r\n   * @param _stakerIndex is the index of staker\r\n   * @return unlockable staked tokens\r\n   */\r\n  function getStakerStakedUnlockableBeforeLastBurnByIndex(\r\n    address _stakerAddress,\r\n    uint _stakerIndex\r\n  )\r\n  public\r\n  view\r\n  returns (uint unlockable)\r\n  {\r\n    unlockable = stakerStakedContracts[\r\n    _stakerAddress][_stakerIndex].unLockableBeforeLastBurn;\r\n  }\r\n\r\n  /**\r\n   * @dev to get the staker's staked contract index\r\n   * @param _stakerAddress is the address of the staker\r\n   * @param _stakerIndex is the index of staker\r\n   * @return is the index of the smart contract address\r\n   */\r\n  function getStakerStakedContractIndex(\r\n    address _stakerAddress,\r\n    uint _stakerIndex\r\n  )\r\n  public\r\n  view\r\n  returns (uint scIndex)\r\n  {\r\n    scIndex = stakerStakedContracts[\r\n    _stakerAddress][_stakerIndex].stakedContractIndex;\r\n  }\r\n\r\n  /**\r\n   * @dev to get the staker index of the staked contract\r\n   * @param _stakedContractAddress is the address of the staked contract\r\n   * @param _stakedContractIndex is the index of staked contract\r\n   * @return is the index of the staker\r\n   */\r\n  function getStakedContractStakerIndex(\r\n    address _stakedContractAddress,\r\n    uint _stakedContractIndex\r\n  )\r\n  public\r\n  view\r\n  returns (uint sIndex)\r\n  {\r\n    sIndex = stakedContractStakers[\r\n    _stakedContractAddress][_stakedContractIndex].stakerIndex;\r\n  }\r\n\r\n  /**\r\n   * @dev to get the staker's initial staked amount on the contract\r\n   * @param _stakerAddress is the address of the staker\r\n   * @param _stakerIndex is the index of staker\r\n   * @return staked amount\r\n   */\r\n  function getStakerInitialStakedAmountOnContract(\r\n    address _stakerAddress,\r\n    uint _stakerIndex\r\n  )\r\n  public\r\n  view\r\n  returns (uint amount)\r\n  {\r\n    amount = stakerStakedContracts[\r\n    _stakerAddress][_stakerIndex].stakeAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev to get the staker's staked contract length\r\n   * @param _stakerAddress is the address of the staker\r\n   * @return length of staked contract\r\n   */\r\n  function getStakerStakedContractLength(\r\n    address _stakerAddress\r\n  )\r\n  public\r\n  view\r\n  returns (uint length)\r\n  {\r\n    length = stakerStakedContracts[_stakerAddress].length;\r\n  }\r\n\r\n  /**\r\n   * @dev to get the staker's unlocked tokens which were staked\r\n   * @param _stakerAddress is the address of the staker\r\n   * @param _stakerIndex is the index of staker\r\n   * @return amount\r\n   */\r\n  function getStakerUnlockedStakedTokens(\r\n    address _stakerAddress,\r\n    uint _stakerIndex\r\n  )\r\n  public\r\n  view\r\n  returns (uint amount)\r\n  {\r\n    amount = stakerStakedContracts[\r\n    _stakerAddress][_stakerIndex].unlockedAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev pushes the unlocked staked tokens by a staker.\r\n   * @param _stakerAddress address of staker.\r\n   * @param _stakerIndex index of the staker to distribute commission.\r\n   * @param _amount amount to be given as commission.\r\n   */\r\n  function pushUnlockedStakedTokens(\r\n    address _stakerAddress,\r\n    uint _stakerIndex,\r\n    uint _amount\r\n  )\r\n  public\r\n  onlyInternal\r\n  {\r\n    stakerStakedContracts[_stakerAddress][\r\n    _stakerIndex].unlockedAmount = stakerStakedContracts[_stakerAddress][\r\n    _stakerIndex].unlockedAmount.add(_amount);\r\n  }\r\n\r\n  /**\r\n   * @dev pushes the Burned tokens for a staker.\r\n   * @param _stakerAddress address of staker.\r\n   * @param _stakerIndex index of the staker.\r\n   * @param _amount amount to be burned.\r\n   */\r\n  function pushBurnedTokens(\r\n    address _stakerAddress,\r\n    uint _stakerIndex,\r\n    uint _amount\r\n  )\r\n  public\r\n  onlyInternal\r\n  {\r\n    stakerStakedContracts[_stakerAddress][\r\n    _stakerIndex].burnedAmount = stakerStakedContracts[_stakerAddress][\r\n    _stakerIndex].burnedAmount.add(_amount);\r\n  }\r\n\r\n  /**\r\n   * @dev pushes the unLockable tokens for a staker before last burn.\r\n   * @param _stakerAddress address of staker.\r\n   * @param _stakerIndex index of the staker.\r\n   * @param _amount amount to be added to unlockable.\r\n   */\r\n  function pushUnlockableBeforeLastBurnTokens(\r\n    address _stakerAddress,\r\n    uint _stakerIndex,\r\n    uint _amount\r\n  )\r\n  public\r\n  onlyInternal\r\n  {\r\n    stakerStakedContracts[_stakerAddress][\r\n    _stakerIndex].unLockableBeforeLastBurn = stakerStakedContracts[_stakerAddress][\r\n    _stakerIndex].unLockableBeforeLastBurn.add(_amount);\r\n  }\r\n\r\n  /**\r\n   * @dev sets the unLockable tokens for a staker before last burn.\r\n   * @param _stakerAddress address of staker.\r\n   * @param _stakerIndex index of the staker.\r\n   * @param _amount amount to be added to unlockable.\r\n   */\r\n  function setUnlockableBeforeLastBurnTokens(\r\n    address _stakerAddress,\r\n    uint _stakerIndex,\r\n    uint _amount\r\n  )\r\n  public\r\n  onlyInternal\r\n  {\r\n    stakerStakedContracts[_stakerAddress][\r\n    _stakerIndex].unLockableBeforeLastBurn = _amount;\r\n  }\r\n\r\n  /**\r\n   * @dev pushes the earned commission earned by a staker.\r\n   * @param _stakerAddress address of staker.\r\n   * @param _stakedContractAddress address of smart contract.\r\n   * @param _stakedContractIndex index of the staker to distribute commission.\r\n   * @param _commissionAmount amount to be given as commission.\r\n   */\r\n  function pushEarnedStakeCommissions(\r\n    address _stakerAddress,\r\n    address _stakedContractAddress,\r\n    uint _stakedContractIndex,\r\n    uint _commissionAmount\r\n  )\r\n  public\r\n  onlyInternal\r\n  {\r\n    stakedContractStakeCommission[_stakedContractAddress][_stakedContractIndex].\r\n    commissionEarned = stakedContractStakeCommission[_stakedContractAddress][\r\n    _stakedContractIndex].commissionEarned.add(_commissionAmount);\r\n\r\n    emit Commission(\r\n      _stakerAddress,\r\n      _stakedContractAddress,\r\n      _stakedContractIndex,\r\n      _commissionAmount\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev pushes the redeemed commission redeemed by a staker.\r\n   * @param _stakerAddress address of staker.\r\n   * @param _stakerIndex index of the staker to distribute commission.\r\n   * @param _amount amount to be given as commission.\r\n   */\r\n  function pushRedeemedStakeCommissions(\r\n    address _stakerAddress,\r\n    uint _stakerIndex,\r\n    uint _amount\r\n  )\r\n  public\r\n  onlyInternal\r\n  {\r\n    uint stakedContractIndex = stakerStakedContracts[\r\n    _stakerAddress][_stakerIndex].stakedContractIndex;\r\n    address stakedContractAddress = stakerStakedContracts[\r\n    _stakerAddress][_stakerIndex].stakedContractAddress;\r\n    stakedContractStakeCommission[stakedContractAddress][stakedContractIndex].\r\n    commissionRedeemed = stakedContractStakeCommission[\r\n    stakedContractAddress][stakedContractIndex].commissionRedeemed.add(_amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets stake commission given to an underwriter\r\n   * for particular stakedcontract on given index.\r\n   * @param _stakerAddress address of staker.\r\n   * @param _stakerIndex index of the staker commission.\r\n   */\r\n  function getStakerEarnedStakeCommission(\r\n    address _stakerAddress,\r\n    uint _stakerIndex\r\n  )\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    return _getStakerEarnedStakeCommission(_stakerAddress, _stakerIndex);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets stake commission redeemed by an underwriter\r\n   * for particular staked contract on given index.\r\n   * @param _stakerAddress address of staker.\r\n   * @param _stakerIndex index of the staker commission.\r\n   * @return commissionEarned total amount given to staker.\r\n   */\r\n  function getStakerRedeemedStakeCommission(\r\n    address _stakerAddress,\r\n    uint _stakerIndex\r\n  )\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    return _getStakerRedeemedStakeCommission(_stakerAddress, _stakerIndex);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets total stake commission given to an underwriter\r\n   * @param _stakerAddress address of staker.\r\n   * @return totalCommissionEarned total commission earned by staker.\r\n   */\r\n  function getStakerTotalEarnedStakeCommission(\r\n    address _stakerAddress\r\n  )\r\n  public\r\n  view\r\n  returns (uint totalCommissionEarned)\r\n  {\r\n    totalCommissionEarned = 0;\r\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\r\n      totalCommissionEarned = totalCommissionEarned.\r\n      add(_getStakerEarnedStakeCommission(_stakerAddress, i));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets total stake commission given to an underwriter\r\n   * @param _stakerAddress address of staker.\r\n   * @return totalCommissionEarned total commission earned by staker.\r\n   */\r\n  function getStakerTotalReedmedStakeCommission(\r\n    address _stakerAddress\r\n  )\r\n  public\r\n  view\r\n  returns (uint totalCommissionRedeemed)\r\n  {\r\n    totalCommissionRedeemed = 0;\r\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\r\n      totalCommissionRedeemed = totalCommissionRedeemed.add(\r\n        _getStakerRedeemedStakeCommission(_stakerAddress, i));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev set flag to deposit/ undeposit cover note\r\n   * against a cover Id\r\n   * @param coverId coverId of Cover\r\n   * @param flag true/false for deposit/undeposit\r\n   */\r\n  function setDepositCN(uint coverId, bool flag) public onlyInternal {\r\n\r\n    if (flag == true) {\r\n      require(!depositedCN[coverId].isDeposited, \"Cover note already deposited\");\r\n    }\r\n\r\n    depositedCN[coverId].isDeposited = flag;\r\n  }\r\n\r\n  /**\r\n   * @dev set locked cover note amount\r\n   * against a cover Id\r\n   * @param coverId coverId of Cover\r\n   * @param amount amount of nxm to be locked\r\n   */\r\n  function setDepositCNAmount(uint coverId, uint amount) public onlyInternal {\r\n\r\n    depositedCN[coverId].amount = amount;\r\n  }\r\n\r\n  /**\r\n   * @dev to get the staker address on a staked contract\r\n   * @param _stakedContractAddress is the address of the staked contract in concern\r\n   * @param _stakedContractIndex is the index of staked contract's index\r\n   * @return address of staker\r\n   */\r\n  function getStakedContractStakerByIndex(\r\n    address _stakedContractAddress,\r\n    uint _stakedContractIndex\r\n  )\r\n  public\r\n  view\r\n  returns (address stakerAddress)\r\n  {\r\n    stakerAddress = stakedContractStakers[\r\n    _stakedContractAddress][_stakedContractIndex].stakerAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev to get the length of stakers on a staked contract\r\n   * @param _stakedContractAddress is the address of the staked contract in concern\r\n   * @return length in concern\r\n   */\r\n  function getStakedContractStakersLength(\r\n    address _stakedContractAddress\r\n  )\r\n  public\r\n  view\r\n  returns (uint length)\r\n  {\r\n    length = stakedContractStakers[_stakedContractAddress].length;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds a new stake record.\r\n   * @param _stakerAddress staker address.\r\n   * @param _stakedContractAddress smart contract address.\r\n   * @param _amount amountof NXM to be staked.\r\n   */\r\n  function addStake(\r\n    address _stakerAddress,\r\n    address _stakedContractAddress,\r\n    uint _amount\r\n  )\r\n  public\r\n  onlyInternal\r\n  returns (uint scIndex)\r\n  {\r\n    scIndex = (stakedContractStakers[_stakedContractAddress].push(\r\n      Staker(_stakerAddress, stakerStakedContracts[_stakerAddress].length))).sub(1);\r\n    stakerStakedContracts[_stakerAddress].push(\r\n      Stake(_stakedContractAddress, scIndex, now, _amount, 0, 0, 0));\r\n  }\r\n\r\n  /**\r\n   * @dev books the user's tokens for maintaining Assessor Velocity,\r\n   * i.e. once a token is used to cast a vote as a Claims assessor,\r\n   * @param _of user's address.\r\n   */\r\n  function bookCATokens(address _of) public onlyInternal {\r\n    require(!isCATokensBooked(_of), \"Tokens already booked\");\r\n    isBookedTokens[_of] = now.add(bookTime);\r\n  }\r\n\r\n  /**\r\n   * @dev to know if claim assessor's tokens are booked or not\r\n   * @param _of is the claim assessor's address in concern\r\n   * @return boolean representing the status of tokens booked\r\n   */\r\n  function isCATokensBooked(address _of) public view returns (bool res) {\r\n    if (now < isBookedTokens[_of])\r\n      res = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the index which will receive commission.\r\n   * @param _stakedContractAddress smart contract address.\r\n   * @param _index current index.\r\n   */\r\n  function setStakedContractCurrentCommissionIndex(\r\n    address _stakedContractAddress,\r\n    uint _index\r\n  )\r\n  public\r\n  onlyInternal\r\n  {\r\n    stakedContractCurrentCommissionIndex[_stakedContractAddress] = _index;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the last complete commission index\r\n   * @param _stakerAddress smart contract address.\r\n   * @param _index current index.\r\n   */\r\n  function setLastCompletedStakeCommissionIndex(\r\n    address _stakerAddress,\r\n    uint _index\r\n  )\r\n  public\r\n  onlyInternal\r\n  {\r\n    lastCompletedStakeCommission[_stakerAddress] = _index;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the index till which commission is distrubuted.\r\n   * @param _stakedContractAddress smart contract address.\r\n   * @param _index current index.\r\n   */\r\n  function setStakedContractCurrentBurnIndex(\r\n    address _stakedContractAddress,\r\n    uint _index\r\n  )\r\n  public\r\n  onlyInternal\r\n  {\r\n    stakedContractCurrentBurnIndex[_stakedContractAddress] = _index;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates Uint Parameters of a code\r\n   * @param code whose details we want to update\r\n   * @param val value to set\r\n   */\r\n  function updateUintParameters(bytes8 code, uint val) public {\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    if (code == \"TOKEXP\") {\r\n\r\n      _setTokenExponent(val);\r\n\r\n    } else if (code == \"TOKSTEP\") {\r\n\r\n      _setPriceStep(val);\r\n\r\n    } else if (code == \"RALOCKT\") {\r\n\r\n      _changeSCValidDays(val);\r\n\r\n    } else if (code == \"RACOMM\") {\r\n\r\n      _setStakerCommissionPer(val);\r\n\r\n    } else if (code == \"RAMAXC\") {\r\n\r\n      _setStakerMaxCommissionPer(val);\r\n\r\n    } else if (code == \"CABOOKT\") {\r\n\r\n      _changeBookTime(val * 1 hours);\r\n\r\n    } else if (code == \"CALOCKT\") {\r\n\r\n      _changelockCADays(val * 1 days);\r\n\r\n    } else if (code == \"MVLOCKT\") {\r\n\r\n      _changelockMVDays(val * 1 days);\r\n\r\n    } else if (code == \"QUOLOCKT\") {\r\n\r\n      _setLockTokenTimeAfterCoverExp(val * 1 days);\r\n\r\n    } else if (code == \"JOINFEE\") {\r\n\r\n      _setJoiningFee(val);\r\n\r\n    } else {\r\n      revert(\"Invalid param code\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to get stake commission given to an\r\n   * underwriter for particular stakedcontract on given index.\r\n   * @param _stakerAddress address of staker.\r\n   * @param _stakerIndex index of the staker commission.\r\n   */\r\n  function _getStakerEarnedStakeCommission(\r\n    address _stakerAddress,\r\n    uint _stakerIndex\r\n  )\r\n  internal\r\n  view\r\n  returns (uint amount)\r\n  {\r\n    uint _stakedContractIndex;\r\n    address _stakedContractAddress;\r\n    _stakedContractAddress = stakerStakedContracts[\r\n    _stakerAddress][_stakerIndex].stakedContractAddress;\r\n    _stakedContractIndex = stakerStakedContracts[\r\n    _stakerAddress][_stakerIndex].stakedContractIndex;\r\n    amount = stakedContractStakeCommission[\r\n    _stakedContractAddress][_stakedContractIndex].commissionEarned;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to get stake commission redeemed by an\r\n   * underwriter for particular stakedcontract on given index.\r\n   * @param _stakerAddress address of staker.\r\n   * @param _stakerIndex index of the staker commission.\r\n   */\r\n  function _getStakerRedeemedStakeCommission(\r\n    address _stakerAddress,\r\n    uint _stakerIndex\r\n  )\r\n  internal\r\n  view\r\n  returns (uint amount)\r\n  {\r\n    uint _stakedContractIndex;\r\n    address _stakedContractAddress;\r\n    _stakedContractAddress = stakerStakedContracts[\r\n    _stakerAddress][_stakerIndex].stakedContractAddress;\r\n    _stakedContractIndex = stakerStakedContracts[\r\n    _stakerAddress][_stakerIndex].stakedContractIndex;\r\n    amount = stakedContractStakeCommission[\r\n    _stakedContractAddress][_stakedContractIndex].commissionRedeemed;\r\n  }\r\n\r\n  /**\r\n   * @dev to set the percentage of staker commission\r\n   * @param _val is new percentage value\r\n   */\r\n  function _setStakerCommissionPer(uint _val) internal {\r\n    stakerCommissionPer = _val;\r\n  }\r\n\r\n  /**\r\n   * @dev to set the max percentage of staker commission\r\n   * @param _val is new percentage value\r\n   */\r\n  function _setStakerMaxCommissionPer(uint _val) internal {\r\n    stakerMaxCommissionPer = _val;\r\n  }\r\n\r\n  /**\r\n   * @dev to set the token exponent value\r\n   * @param _val is new value\r\n   */\r\n  function _setTokenExponent(uint _val) internal {\r\n    tokenExponent = _val;\r\n  }\r\n\r\n  /**\r\n   * @dev to set the price step\r\n   * @param _val is new value\r\n   */\r\n  function _setPriceStep(uint _val) internal {\r\n    priceStep = _val;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes number of days for which NXM needs to staked in case of underwriting\r\n   */\r\n  function _changeSCValidDays(uint _days) internal {\r\n    scValidDays = _days;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the time period up to which tokens will be locked.\r\n   *      Used to generate the validity period of tokens booked by\r\n   *      a user for participating in claim's assessment/claim's voting.\r\n   */\r\n  function _changeBookTime(uint _time) internal {\r\n    bookTime = _time;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes lock CA days - number of days for which tokens\r\n   * are locked while submitting a vote.\r\n   */\r\n  function _changelockCADays(uint _val) internal {\r\n    lockCADays = _val;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes lock MV days - number of days for which tokens are locked\r\n   * while submitting a vote.\r\n   */\r\n  function _changelockMVDays(uint _val) internal {\r\n    lockMVDays = _val;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes extra lock period for a cover, post its expiry.\r\n   */\r\n  function _setLockTokenTimeAfterCoverExp(uint time) internal {\r\n    lockTokenTimeAfterCoverExp = time;\r\n  }\r\n\r\n  /**\r\n   * @dev Set the joining fee for membership\r\n   */\r\n  function _setJoiningFee(uint _amount) internal {\r\n    joiningFee = _amount;\r\n  }\r\n}\r\n\r\n// File: contracts/modules/token/TokenFunctions.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract TokenFunctions is Iupgradable {\r\n  using SafeMath for uint;\r\n\r\n  NXMToken public tk;\r\n  TokenController public tc;\r\n  TokenData public td;\r\n  QuotationData public qd;\r\n  IPooledStaking public pooledStaking;\r\n\r\n  event BurnCATokens(uint claimId, address addr, uint amount);\r\n\r\n  /**\r\n   * @dev Rewards stakers on purchase of cover on smart contract.\r\n   * @param _contractAddress smart contract address.\r\n   * @param _coverPriceNXM cover price in NXM.\r\n   */\r\n  function pushStakerRewards(address _contractAddress, uint _coverPriceNXM) external onlyInternal {\r\n    uint rewardValue = _coverPriceNXM.mul(td.stakerCommissionPer()).div(100);\r\n    pooledStaking.accumulateReward(_contractAddress, rewardValue);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\r\n   * @param _of address of the coverHolder.\r\n   * @param _coverId coverId of the cover.\r\n   */\r\n  function getUserLockedCNTokens(address _of, uint _coverId) external view returns (uint) {\r\n    return _getUserLockedCNTokens(_of, _coverId);\r\n  }\r\n\r\n  /**\r\n   * @dev to get the all the cover locked tokens of a user\r\n   * @param _of is the user address in concern\r\n   * @return amount locked\r\n   */\r\n  function getUserAllLockedCNTokens(address _of) external view returns (uint amount) {\r\n    for (uint i = 0; i < qd.getUserCoverLength(_of); i++) {\r\n      amount = amount.add(_getUserLockedCNTokens(_of, qd.getAllCoversOfUser(_of)[i]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns amount of NXM Tokens locked as Cover Note against given coverId.\r\n   * @param _coverId coverId of the cover.\r\n   */\r\n  function getLockedCNAgainstCover(uint _coverId) external view returns (uint) {\r\n    return _getLockedCNAgainstCover(_coverId);\r\n  }\r\n\r\n  /**\r\n   * @dev Change Dependent Contract Address\r\n   */\r\n  function changeDependentContractAddress() public {\r\n    tk = NXMToken(ms.tokenAddress());\r\n    td = TokenData(ms.getLatestAddress(\"TD\"));\r\n    tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\"PS\"));\r\n  }\r\n\r\n  /**\r\n   * @dev Set the flag to check if cover note is deposited against the cover id\r\n   * @param coverId Cover Id.\r\n   */\r\n  function depositCN(uint coverId) public onlyInternal returns (bool success) {\r\n    require(_getLockedCNAgainstCover(coverId) > 0, \"No cover note available\");\r\n    td.setDepositCN(coverId, true);\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @param _of address of Member\r\n   * @param _coverId Cover Id\r\n   * @param _lockTime Pending Time + Cover Period 7*1 days\r\n   */\r\n  function extendCNEPOff(address _of, uint _coverId, uint _lockTime) public onlyInternal {\r\n    uint timeStamp = now.add(_lockTime);\r\n    uint coverValidUntil = qd.getValidityOfCover(_coverId);\r\n    if (timeStamp >= coverValidUntil) {\r\n      bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, _coverId));\r\n      tc.extendLockOf(_of, reason, timeStamp);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev to burn the deposited cover tokens\r\n   * @param coverId is id of cover whose tokens have to be burned\r\n   * @return the status of the successful burning\r\n   */\r\n  function burnDepositCN(uint coverId) public onlyInternal returns (bool success) {\r\n    address _of = qd.getCoverMemberAddress(coverId);\r\n    uint amount;\r\n    (amount,) = td.depositedCN(coverId);\r\n    amount = (amount.mul(50)).div(100);\r\n    bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, coverId));\r\n    tc.burnLockedTokens(_of, reason, amount);\r\n    success = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Unlocks covernote locked against a given cover\r\n   * @param coverId id of cover\r\n   */\r\n  function unlockCN(uint coverId) public onlyInternal {\r\n    (, bool isDeposited) = td.depositedCN(coverId);\r\n    require(!isDeposited, \"Cover note is deposited and can not be released\");\r\n    uint lockedCN = _getLockedCNAgainstCover(coverId);\r\n    if (lockedCN != 0) {\r\n      address coverHolder = qd.getCoverMemberAddress(coverId);\r\n      bytes32 reason = keccak256(abi.encodePacked(\"CN\", coverHolder, coverId));\r\n      tc.releaseLockedTokens(coverHolder, reason, lockedCN);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Burns tokens used for fraudulent voting against a claim\r\n   * @param claimid Claim Id.\r\n   * @param _value number of tokens to be burned\r\n   * @param _of Claim Assessor's address.\r\n   */\r\n  function burnCAToken(uint claimid, uint _value, address _of) public {\r\n\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    tc.burnLockedTokens(_of, \"CLA\", _value);\r\n    emit BurnCATokens(claimid, _of, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev to lock cover note tokens\r\n   * @param coverNoteAmount is number of tokens to be locked\r\n   * @param coverPeriod is cover period in concern\r\n   * @param coverId is the cover id of cover in concern\r\n   * @param _of address whose tokens are to be locked\r\n   */\r\n  function lockCN(\r\n    uint coverNoteAmount,\r\n    uint coverPeriod,\r\n    uint coverId,\r\n    address _of\r\n  )\r\n  public\r\n  onlyInternal\r\n  {\r\n    uint validity = (coverPeriod * 1 days).add(td.lockTokenTimeAfterCoverExp());\r\n    bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, coverId));\r\n    td.setDepositCNAmount(coverId, coverNoteAmount);\r\n    tc.lockOf(_of, reason, coverNoteAmount, validity);\r\n  }\r\n\r\n  /**\r\n   * @dev to check if a  member is locked for member vote\r\n   * @param _of is the member address in concern\r\n   * @return the boolean status\r\n   */\r\n  function isLockedForMemberVote(address _of) public view returns (bool) {\r\n    return now < tk.isLockedForMV(_of);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\r\n   * @param _coverId coverId of the cover.\r\n   */\r\n  function _getLockedCNAgainstCover(uint _coverId) internal view returns (uint) {\r\n    address coverHolder = qd.getCoverMemberAddress(_coverId);\r\n    bytes32 reason = keccak256(abi.encodePacked(\"CN\", coverHolder, _coverId));\r\n    return tc.tokensLockedAtTime(coverHolder, reason, now);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\r\n   * @param _of address of the coverHolder.\r\n   * @param _coverId coverId of the cover.\r\n   */\r\n  function _getUserLockedCNTokens(address _of, uint _coverId) internal view returns (uint) {\r\n    bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, _coverId));\r\n    return tc.tokensLockedAtTime(_of, reason, now);\r\n  }\r\n}\r\n\r\n// File: contracts/modules/claims/ClaimsData.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract ClaimsData is Iupgradable {\r\n  using SafeMath for uint;\r\n\r\n  struct Claim {\r\n    uint coverId;\r\n    uint dateUpd;\r\n  }\r\n\r\n  struct Vote {\r\n    address voter;\r\n    uint tokens;\r\n    uint claimId;\r\n    int8 verdict;\r\n    bool rewardClaimed;\r\n  }\r\n\r\n  struct ClaimsPause {\r\n    uint coverid;\r\n    uint dateUpd;\r\n    bool submit;\r\n  }\r\n\r\n  struct ClaimPauseVoting {\r\n    uint claimid;\r\n    uint pendingTime;\r\n    bool voting;\r\n  }\r\n\r\n  struct RewardDistributed {\r\n    uint lastCAvoteIndex;\r\n    uint lastMVvoteIndex;\r\n\r\n  }\r\n\r\n  struct ClaimRewardDetails {\r\n    uint percCA;\r\n    uint percMV;\r\n    uint tokenToBeDist;\r\n\r\n  }\r\n\r\n  struct ClaimTotalTokens {\r\n    uint accept;\r\n    uint deny;\r\n  }\r\n\r\n  struct ClaimRewardStatus {\r\n    uint percCA;\r\n    uint percMV;\r\n  }\r\n\r\n  ClaimRewardStatus[] internal rewardStatus;\r\n\r\n  Claim[] internal allClaims;\r\n  Vote[] internal allvotes;\r\n  ClaimsPause[] internal claimPause;\r\n  ClaimPauseVoting[] internal claimPauseVotingEP;\r\n\r\n  mapping(address => RewardDistributed) internal voterVoteRewardReceived;\r\n  mapping(uint => ClaimRewardDetails) internal claimRewardDetail;\r\n  mapping(uint => ClaimTotalTokens) internal claimTokensCA;\r\n  mapping(uint => ClaimTotalTokens) internal claimTokensMV;\r\n  mapping(uint => int8) internal claimVote;\r\n  mapping(uint => uint) internal claimsStatus;\r\n  mapping(uint => uint) internal claimState12Count;\r\n  mapping(uint => uint[]) internal claimVoteCA;\r\n  mapping(uint => uint[]) internal claimVoteMember;\r\n  mapping(address => uint[]) internal voteAddressCA;\r\n  mapping(address => uint[]) internal voteAddressMember;\r\n  mapping(address => uint[]) internal allClaimsByAddress;\r\n  mapping(address => mapping(uint => uint)) internal userClaimVoteCA;\r\n  mapping(address => mapping(uint => uint)) internal userClaimVoteMember;\r\n  mapping(address => uint) public userClaimVotePausedOn;\r\n\r\n  uint internal claimPauseLastsubmit;\r\n  uint internal claimStartVotingFirstIndex;\r\n  uint public pendingClaimStart;\r\n  uint public claimDepositTime;\r\n  uint public maxVotingTime;\r\n  uint public minVotingTime;\r\n  uint public payoutRetryTime;\r\n  uint public claimRewardPerc;\r\n  uint public minVoteThreshold;\r\n  uint public maxVoteThreshold;\r\n  uint public majorityConsensus;\r\n  uint public pauseDaysCA;\r\n\r\n  event ClaimRaise(\r\n    uint indexed coverId,\r\n    address indexed userAddress,\r\n    uint claimId,\r\n    uint dateSubmit\r\n  );\r\n\r\n  event VoteCast(\r\n    address indexed userAddress,\r\n    uint indexed claimId,\r\n    bytes4 indexed typeOf,\r\n    uint tokens,\r\n    uint submitDate,\r\n    int8 verdict\r\n  );\r\n\r\n  constructor() public {\r\n    pendingClaimStart = 1;\r\n    maxVotingTime = 48 * 1 hours;\r\n    minVotingTime = 12 * 1 hours;\r\n    payoutRetryTime = 24 * 1 hours;\r\n    allvotes.push(Vote(address(0), 0, 0, 0, false));\r\n    allClaims.push(Claim(0, 0));\r\n    claimDepositTime = 7 days;\r\n    claimRewardPerc = 20;\r\n    minVoteThreshold = 5;\r\n    maxVoteThreshold = 10;\r\n    majorityConsensus = 70;\r\n    pauseDaysCA = 3 days;\r\n    _addRewardIncentive();\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the pending claim start variable,\r\n   * the lowest claim id with a pending decision/payout.\r\n   */\r\n  function setpendingClaimStart(uint _start) external onlyInternal {\r\n    require(pendingClaimStart <= _start);\r\n    pendingClaimStart = _start;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the max vote index for which claim assessor has received reward\r\n   * @param _voter address of the voter.\r\n   * @param caIndex last index till which reward was distributed for CA\r\n   */\r\n  function setRewardDistributedIndexCA(address _voter, uint caIndex) external onlyInternal {\r\n    voterVoteRewardReceived[_voter].lastCAvoteIndex = caIndex;\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Used to pause claim assessor activity for 3 days\r\n   * @param user Member address whose claim voting ability needs to be paused\r\n   */\r\n  function setUserClaimVotePausedOn(address user) external {\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    userClaimVotePausedOn[user] = now;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the max vote index for which member has received reward\r\n   * @param _voter address of the voter.\r\n   * @param mvIndex last index till which reward was distributed for member\r\n   */\r\n  function setRewardDistributedIndexMV(address _voter, uint mvIndex) external onlyInternal {\r\n\r\n    voterVoteRewardReceived[_voter].lastMVvoteIndex = mvIndex;\r\n  }\r\n\r\n  /**\r\n   * @param claimid claim id.\r\n   * @param percCA reward Percentage reward for claim assessor\r\n   * @param percMV reward Percentage reward for members\r\n   * @param tokens total tokens to be rewarded\r\n   */\r\n  function setClaimRewardDetail(\r\n    uint claimid,\r\n    uint percCA,\r\n    uint percMV,\r\n    uint tokens\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    claimRewardDetail[claimid].percCA = percCA;\r\n    claimRewardDetail[claimid].percMV = percMV;\r\n    claimRewardDetail[claimid].tokenToBeDist = tokens;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the reward claim status against a vote id.\r\n   * @param _voteid vote Id.\r\n   * @param claimed true if reward for vote is claimed, else false.\r\n   */\r\n  function setRewardClaimed(uint _voteid, bool claimed) external onlyInternal {\r\n    allvotes[_voteid].rewardClaimed = claimed;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the final vote's result(either accepted or declined)of a claim.\r\n   * @param _claimId Claim Id.\r\n   * @param _verdict 1 if claim is accepted,-1 if declined.\r\n   */\r\n  function changeFinalVerdict(uint _claimId, int8 _verdict) external onlyInternal {\r\n    claimVote[_claimId] = _verdict;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a new claim.\r\n   */\r\n  function addClaim(\r\n    uint _claimId,\r\n    uint _coverId,\r\n    address _from,\r\n    uint _nowtime\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    allClaims.push(Claim(_coverId, _nowtime));\r\n    allClaimsByAddress[_from].push(_claimId);\r\n  }\r\n\r\n  /**\r\n   * @dev Add Vote's details of a given claim.\r\n   */\r\n  function addVote(\r\n    address _voter,\r\n    uint _tokens,\r\n    uint claimId,\r\n    int8 _verdict\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    allvotes.push(Vote(_voter, _tokens, claimId, _verdict, false));\r\n  }\r\n\r\n  /**\r\n   * @dev Stores the id of the claim assessor vote given to a claim.\r\n   * Maintains record of all votes given by all the CA to a claim.\r\n   * @param _claimId Claim Id to which vote has given by the CA.\r\n   * @param _voteid Vote Id.\r\n   */\r\n  function addClaimVoteCA(uint _claimId, uint _voteid) external onlyInternal {\r\n    claimVoteCA[_claimId].push(_voteid);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the id of the vote.\r\n   * @param _from Claim assessor's address who has given the vote.\r\n   * @param _claimId Claim Id for which vote has been given by the CA.\r\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\r\n   */\r\n  function setUserClaimVoteCA(\r\n    address _from,\r\n    uint _claimId,\r\n    uint _voteid\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    userClaimVoteCA[_from][_claimId] = _voteid;\r\n    voteAddressCA[_from].push(_voteid);\r\n  }\r\n\r\n  /**\r\n   * @dev Stores the tokens locked by the Claim Assessors during voting of a given claim.\r\n   * @param _claimId Claim Id.\r\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\r\n   * -1 for deny and increases the tokens of claim as deny.\r\n   * @param _tokens Number of tokens.\r\n   */\r\n  function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\r\n    if (_vote == 1)\r\n      claimTokensCA[_claimId].accept = claimTokensCA[_claimId].accept.add(_tokens);\r\n    if (_vote == - 1)\r\n      claimTokensCA[_claimId].deny = claimTokensCA[_claimId].deny.add(_tokens);\r\n  }\r\n\r\n  /**\r\n   * @dev Stores the tokens locked by the Members during voting of a given claim.\r\n   * @param _claimId Claim Id.\r\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\r\n   * -1 for deny and increases the tokens of claim as deny.\r\n   * @param _tokens Number of tokens.\r\n   */\r\n  function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\r\n    if (_vote == 1)\r\n      claimTokensMV[_claimId].accept = claimTokensMV[_claimId].accept.add(_tokens);\r\n    if (_vote == - 1)\r\n      claimTokensMV[_claimId].deny = claimTokensMV[_claimId].deny.add(_tokens);\r\n  }\r\n\r\n  /**\r\n   * @dev Stores the id of the member vote given to a claim.\r\n   * Maintains record of all votes given by all the Members to a claim.\r\n   * @param _claimId Claim Id to which vote has been given by the Member.\r\n   * @param _voteid Vote Id.\r\n   */\r\n  function addClaimVotemember(uint _claimId, uint _voteid) external onlyInternal {\r\n    claimVoteMember[_claimId].push(_voteid);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the id of the vote.\r\n   * @param _from Member's address who has given the vote.\r\n   * @param _claimId Claim Id for which vote has been given by the Member.\r\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\r\n   */\r\n  function setUserClaimVoteMember(\r\n    address _from,\r\n    uint _claimId,\r\n    uint _voteid\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    userClaimVoteMember[_from][_claimId] = _voteid;\r\n    voteAddressMember[_from].push(_voteid);\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Increases the count of failure until payout of a claim is successful.\r\n   */\r\n  function updateState12Count(uint _claimId, uint _cnt) external onlyInternal {\r\n    claimState12Count[_claimId] = claimState12Count[_claimId].add(_cnt);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets status of a claim.\r\n   * @param _claimId Claim Id.\r\n   * @param _stat Status number.\r\n   */\r\n  function setClaimStatus(uint _claimId, uint _stat) external onlyInternal {\r\n    claimsStatus[_claimId] = _stat;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the timestamp of a given claim at which the Claim's details has been updated.\r\n   * @param _claimId Claim Id of claim which has been changed.\r\n   * @param _dateUpd timestamp at which claim is updated.\r\n   */\r\n  function setClaimdateUpd(uint _claimId, uint _dateUpd) external onlyInternal {\r\n    allClaims[_claimId].dateUpd = _dateUpd;\r\n  }\r\n\r\n  /**\r\n   @dev Queues Claims during Emergency Pause.\r\n   */\r\n  function setClaimAtEmergencyPause(\r\n    uint _coverId,\r\n    uint _dateUpd,\r\n    bool _submit\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    claimPause.push(ClaimsPause(_coverId, _dateUpd, _submit));\r\n  }\r\n\r\n  /**\r\n   * @dev Set submission flag for Claims queued during emergency pause.\r\n   * Set to true after EP is turned off and the claim is submitted .\r\n   */\r\n  function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external onlyInternal {\r\n    claimPause[_index].submit = _submit;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the index from which claim needs to be\r\n   * submitted when emergency pause is swithched off.\r\n   */\r\n  function setFirstClaimIndexToSubmitAfterEP(\r\n    uint _firstClaimIndexToSubmit\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    claimPauseLastsubmit = _firstClaimIndexToSubmit;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the pending vote duration for a claim in case of emergency pause.\r\n   */\r\n  function setPendingClaimDetails(\r\n    uint _claimId,\r\n    uint _pendingTime,\r\n    bool _voting\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    claimPauseVotingEP.push(ClaimPauseVoting(_claimId, _pendingTime, _voting));\r\n  }\r\n\r\n  /**\r\n   * @dev Sets voting flag true after claim is reopened for voting after emergency pause.\r\n   */\r\n  function setPendingClaimVoteStatus(uint _claimId, bool _vote) external onlyInternal {\r\n    claimPauseVotingEP[_claimId].voting = _vote;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the index from which claim needs to be\r\n   * reopened when emergency pause is swithched off.\r\n   */\r\n  function setFirstClaimIndexToStartVotingAfterEP(\r\n    uint _claimStartVotingFirstIndex\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    claimStartVotingFirstIndex = _claimStartVotingFirstIndex;\r\n  }\r\n\r\n  /**\r\n   * @dev Calls Vote Event.\r\n   */\r\n  function callVoteEvent(\r\n    address _userAddress,\r\n    uint _claimId,\r\n    bytes4 _typeOf,\r\n    uint _tokens,\r\n    uint _submitDate,\r\n    int8 _verdict\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    emit VoteCast(\r\n      _userAddress,\r\n      _claimId,\r\n      _typeOf,\r\n      _tokens,\r\n      _submitDate,\r\n      _verdict\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Calls Claim Event.\r\n   */\r\n  function callClaimEvent(\r\n    uint _coverId,\r\n    address _userAddress,\r\n    uint _claimId,\r\n    uint _datesubmit\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    emit ClaimRaise(_coverId, _userAddress, _claimId, _datesubmit);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Uint Parameters by parameter code\r\n   * @param code whose details we want\r\n   * @return string value of the parameter\r\n   * @return associated amount (time or perc or value) to the code\r\n   */\r\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\r\n    codeVal = code;\r\n    if (code == \"CAMAXVT\") {\r\n      val = maxVotingTime / (1 hours);\r\n\r\n    } else if (code == \"CAMINVT\") {\r\n\r\n      val = minVotingTime / (1 hours);\r\n\r\n    } else if (code == \"CAPRETRY\") {\r\n\r\n      val = payoutRetryTime / (1 hours);\r\n\r\n    } else if (code == \"CADEPT\") {\r\n\r\n      val = claimDepositTime / (1 days);\r\n\r\n    } else if (code == \"CAREWPER\") {\r\n\r\n      val = claimRewardPerc;\r\n\r\n    } else if (code == \"CAMINTH\") {\r\n\r\n      val = minVoteThreshold;\r\n\r\n    } else if (code == \"CAMAXTH\") {\r\n\r\n      val = maxVoteThreshold;\r\n\r\n    } else if (code == \"CACONPER\") {\r\n\r\n      val = majorityConsensus;\r\n\r\n    } else if (code == \"CAPAUSET\") {\r\n      val = pauseDaysCA / (1 days);\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Get claim queued during emergency pause by index.\r\n   */\r\n  function getClaimOfEmergencyPauseByIndex(\r\n    uint _index\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint coverId,\r\n    uint dateUpd,\r\n    bool submit\r\n  )\r\n  {\r\n    coverId = claimPause[_index].coverid;\r\n    dateUpd = claimPause[_index].dateUpd;\r\n    submit = claimPause[_index].submit;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the Claim's details of given claimid.\r\n   */\r\n  function getAllClaimsByIndex(\r\n    uint _claimId\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint coverId,\r\n    int8 vote,\r\n    uint status,\r\n    uint dateUpd,\r\n    uint state12Count\r\n  )\r\n  {\r\n    return (\r\n    allClaims[_claimId].coverId,\r\n    claimVote[_claimId],\r\n    claimsStatus[_claimId],\r\n    allClaims[_claimId].dateUpd,\r\n    claimState12Count[_claimId]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the vote id of a given claim of a given Claim Assessor.\r\n   */\r\n  function getUserClaimVoteCA(\r\n    address _add,\r\n    uint _claimId\r\n  )\r\n  external\r\n  view\r\n  returns (uint idVote)\r\n  {\r\n    return userClaimVoteCA[_add][_claimId];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the vote id of a given claim of a given member.\r\n   */\r\n  function getUserClaimVoteMember(\r\n    address _add,\r\n    uint _claimId\r\n  )\r\n  external\r\n  view\r\n  returns (uint idVote)\r\n  {\r\n    return userClaimVoteMember[_add][_claimId];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the count of all votes.\r\n   */\r\n  function getAllVoteLength() external view returns (uint voteCount) {\r\n    return allvotes.length.sub(1); // Start Index always from 1.\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the status number of a given claim.\r\n   * @param _claimId Claim id.\r\n   * @return statno Status Number.\r\n   */\r\n  function getClaimStatusNumber(uint _claimId) external view returns (uint claimId, uint statno) {\r\n    return (_claimId, claimsStatus[_claimId]);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the reward percentage to be distributed for a given status id\r\n   * @param statusNumber the number of type of status\r\n   * @return percCA reward Percentage for claim assessor\r\n   * @return percMV reward Percentage for members\r\n   */\r\n  function getRewardStatus(uint statusNumber) external view returns (uint percCA, uint percMV) {\r\n    return (rewardStatus[statusNumber].percCA, rewardStatus[statusNumber].percMV);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the number of tries that have been made for a successful payout of a Claim.\r\n   */\r\n  function getClaimState12Count(uint _claimId) external view returns (uint num) {\r\n    num = claimState12Count[_claimId];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the last update date of a claim.\r\n   */\r\n  function getClaimDateUpd(uint _claimId) external view returns (uint dateupd) {\r\n    dateupd = allClaims[_claimId].dateUpd;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets all Claims created by a user till date.\r\n   * @param _member user's address.\r\n   * @return claimarr List of Claims id.\r\n   */\r\n  function getAllClaimsByAddress(address _member) external view returns (uint[] memory claimarr) {\r\n    return allClaimsByAddress[_member];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the number of tokens that has been locked\r\n   * while giving vote to a claim by  Claim Assessors.\r\n   * @param _claimId Claim Id.\r\n   * @return accept Total number of tokens when CA accepts the claim.\r\n   * @return deny Total number of tokens when CA declines the claim.\r\n   */\r\n  function getClaimsTokenCA(\r\n    uint _claimId\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint claimId,\r\n    uint accept,\r\n    uint deny\r\n  )\r\n  {\r\n    return (\r\n    _claimId,\r\n    claimTokensCA[_claimId].accept,\r\n    claimTokensCA[_claimId].deny\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the number of tokens that have been\r\n   * locked while assessing a claim as a member.\r\n   * @param _claimId Claim Id.\r\n   * @return accept Total number of tokens in acceptance of the claim.\r\n   * @return deny Total number of tokens against the claim.\r\n   */\r\n  function getClaimsTokenMV(\r\n    uint _claimId\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint claimId,\r\n    uint accept,\r\n    uint deny\r\n  )\r\n  {\r\n    return (\r\n    _claimId,\r\n    claimTokensMV[_claimId].accept,\r\n    claimTokensMV[_claimId].deny\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the total number of votes cast as Claims assessor for/against a given claim\r\n   */\r\n  function getCaClaimVotesToken(uint _claimId) external view returns (uint claimId, uint cnt) {\r\n    claimId = _claimId;\r\n    cnt = 0;\r\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\r\n      cnt = cnt.add(allvotes[claimVoteCA[_claimId][i]].tokens);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the total number of tokens cast as a member for/against a given claim\r\n   */\r\n  function getMemberClaimVotesToken(\r\n    uint _claimId\r\n  )\r\n  external\r\n  view\r\n  returns (uint claimId, uint cnt)\r\n  {\r\n    claimId = _claimId;\r\n    cnt = 0;\r\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\r\n      cnt = cnt.add(allvotes[claimVoteMember[_claimId][i]].tokens);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Provides information of a vote when given its vote id.\r\n   * @param _voteid Vote Id.\r\n   */\r\n  function getVoteDetails(uint _voteid)\r\n  external view\r\n  returns (\r\n    uint tokens,\r\n    uint claimId,\r\n    int8 verdict,\r\n    bool rewardClaimed\r\n  )\r\n  {\r\n    return (\r\n    allvotes[_voteid].tokens,\r\n    allvotes[_voteid].claimId,\r\n    allvotes[_voteid].verdict,\r\n    allvotes[_voteid].rewardClaimed\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the voter's address of a given vote id.\r\n   */\r\n  function getVoterVote(uint _voteid) external view returns (address voter) {\r\n    return allvotes[_voteid].voter;\r\n  }\r\n\r\n  /**\r\n   * @dev Provides information of a Claim when given its claim id.\r\n   * @param _claimId Claim Id.\r\n   */\r\n  function getClaim(\r\n    uint _claimId\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint claimId,\r\n    uint coverId,\r\n    int8 vote,\r\n    uint status,\r\n    uint dateUpd,\r\n    uint state12Count\r\n  )\r\n  {\r\n    return (\r\n    _claimId,\r\n    allClaims[_claimId].coverId,\r\n    claimVote[_claimId],\r\n    claimsStatus[_claimId],\r\n    allClaims[_claimId].dateUpd,\r\n    claimState12Count[_claimId]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the total number of votes of a given claim.\r\n   * @param _claimId Claim Id.\r\n   * @param _ca if 1: votes given by Claim Assessors to a claim,\r\n   * else returns the number of votes of given by Members to a claim.\r\n   * @return len total number of votes for/against a given claim.\r\n   */\r\n  function getClaimVoteLength(\r\n    uint _claimId,\r\n    uint8 _ca\r\n  )\r\n  external\r\n  view\r\n  returns (uint claimId, uint len)\r\n  {\r\n    claimId = _claimId;\r\n    if (_ca == 1)\r\n      len = claimVoteCA[_claimId].length;\r\n    else\r\n      len = claimVoteMember[_claimId].length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the verdict of a vote using claim id and index.\r\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\r\n   * @return ver 1 if vote was given in favour,-1 if given in against.\r\n   */\r\n  function getVoteVerdict(\r\n    uint _claimId,\r\n    uint _index,\r\n    uint8 _ca\r\n  )\r\n  external\r\n  view\r\n  returns (int8 ver)\r\n  {\r\n    if (_ca == 1)\r\n      ver = allvotes[claimVoteCA[_claimId][_index]].verdict;\r\n    else\r\n      ver = allvotes[claimVoteMember[_claimId][_index]].verdict;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the Number of tokens of a vote using claim id and index.\r\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\r\n   * @return tok Number of tokens.\r\n   */\r\n  function getVoteToken(\r\n    uint _claimId,\r\n    uint _index,\r\n    uint8 _ca\r\n  )\r\n  external\r\n  view\r\n  returns (uint tok)\r\n  {\r\n    if (_ca == 1)\r\n      tok = allvotes[claimVoteCA[_claimId][_index]].tokens;\r\n    else\r\n      tok = allvotes[claimVoteMember[_claimId][_index]].tokens;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the Voter's address of a vote using claim id and index.\r\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\r\n   * @return voter Voter's address.\r\n   */\r\n  function getVoteVoter(\r\n    uint _claimId,\r\n    uint _index,\r\n    uint8 _ca\r\n  )\r\n  external\r\n  view\r\n  returns (address voter)\r\n  {\r\n    if (_ca == 1)\r\n      voter = allvotes[claimVoteCA[_claimId][_index]].voter;\r\n    else\r\n      voter = allvotes[claimVoteMember[_claimId][_index]].voter;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets total number of Claims created by a user till date.\r\n   * @param _add User's address.\r\n   */\r\n  function getUserClaimCount(address _add) external view returns (uint len) {\r\n    len = allClaimsByAddress[_add].length;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates number of Claims that are in pending state.\r\n   */\r\n  function getClaimLength() external view returns (uint len) {\r\n    len = allClaims.length.sub(pendingClaimStart);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the Number of all the Claims created till date.\r\n   */\r\n  function actualClaimLength() external view returns (uint len) {\r\n    len = allClaims.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets details of a claim.\r\n   * @param _index claim id = pending claim start + given index\r\n   * @param _add User's address.\r\n   * @return coverid cover against which claim has been submitted.\r\n   * @return claimId Claim  Id.\r\n   * @return voteCA verdict of vote given as a Claim Assessor.\r\n   * @return voteMV verdict of vote given as a Member.\r\n   * @return statusnumber Status of claim.\r\n   */\r\n  function getClaimFromNewStart(\r\n    uint _index,\r\n    address _add\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint coverid,\r\n    uint claimId,\r\n    int8 voteCA,\r\n    int8 voteMV,\r\n    uint statusnumber\r\n  )\r\n  {\r\n    uint i = pendingClaimStart.add(_index);\r\n    coverid = allClaims[i].coverId;\r\n    claimId = i;\r\n    if (userClaimVoteCA[_add][i] > 0)\r\n      voteCA = allvotes[userClaimVoteCA[_add][i]].verdict;\r\n    else\r\n      voteCA = 0;\r\n\r\n    if (userClaimVoteMember[_add][i] > 0)\r\n      voteMV = allvotes[userClaimVoteMember[_add][i]].verdict;\r\n    else\r\n      voteMV = 0;\r\n\r\n    statusnumber = claimsStatus[i];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets details of a claim of a user at a given index.\r\n   */\r\n  function getUserClaimByIndex(\r\n    uint _index,\r\n    address _add\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint status,\r\n    uint coverid,\r\n    uint claimId\r\n  )\r\n  {\r\n    claimId = allClaimsByAddress[_add][_index];\r\n    status = claimsStatus[claimId];\r\n    coverid = allClaims[claimId].coverId;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Id of all the votes given to a claim.\r\n   * @param _claimId Claim Id.\r\n   * @return ca id of all the votes given by Claim assessors to a claim.\r\n   * @return mv id of all the votes given by members to a claim.\r\n   */\r\n  function getAllVotesForClaim(\r\n    uint _claimId\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint claimId,\r\n    uint[] memory ca,\r\n    uint[] memory mv\r\n  )\r\n  {\r\n    return (_claimId, claimVoteCA[_claimId], claimVoteMember[_claimId]);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Number of tokens deposit in a vote using\r\n   * Claim assessor's address and claim id.\r\n   * @return tokens Number of deposited tokens.\r\n   */\r\n  function getTokensClaim(\r\n    address _of,\r\n    uint _claimId\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint claimId,\r\n    uint tokens\r\n  )\r\n  {\r\n    return (_claimId, allvotes[userClaimVoteCA[_of][_claimId]].tokens);\r\n  }\r\n\r\n  /**\r\n   * @param _voter address of the voter.\r\n   * @return lastCAvoteIndex last index till which reward was distributed for CA\r\n   * @return lastMVvoteIndex last index till which reward was distributed for member\r\n   */\r\n  function getRewardDistributedIndex(\r\n    address _voter\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint lastCAvoteIndex,\r\n    uint lastMVvoteIndex\r\n  )\r\n  {\r\n    return (\r\n    voterVoteRewardReceived[_voter].lastCAvoteIndex,\r\n    voterVoteRewardReceived[_voter].lastMVvoteIndex\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @param claimid claim id.\r\n   * @return perc_CA reward Percentage for claim assessor\r\n   * @return perc_MV reward Percentage for members\r\n   * @return tokens total tokens to be rewarded\r\n   */\r\n  function getClaimRewardDetail(\r\n    uint claimid\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint percCA,\r\n    uint percMV,\r\n    uint tokens\r\n  )\r\n  {\r\n    return (\r\n    claimRewardDetail[claimid].percCA,\r\n    claimRewardDetail[claimid].percMV,\r\n    claimRewardDetail[claimid].tokenToBeDist\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets cover id of a claim.\r\n   */\r\n  function getClaimCoverId(uint _claimId) external view returns (uint claimId, uint coverid) {\r\n    return (_claimId, allClaims[_claimId].coverId);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets total number of tokens staked during voting by Claim Assessors.\r\n   * @param _claimId Claim Id.\r\n   * @param _verdict 1 to get total number of accept tokens, -1 to get total number of deny tokens.\r\n   * @return token token Number of tokens(either accept or deny on the basis of verdict given as parameter).\r\n   */\r\n  function getClaimVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\r\n    claimId = _claimId;\r\n    token = 0;\r\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\r\n      if (allvotes[claimVoteCA[_claimId][i]].verdict == _verdict)\r\n        token = token.add(allvotes[claimVoteCA[_claimId][i]].tokens);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets total number of tokens staked during voting by Members.\r\n   * @param _claimId Claim Id.\r\n   * @param _verdict 1 to get total number of accept tokens,\r\n   *  -1 to get total number of deny tokens.\r\n   * @return token token Number of tokens(either accept or\r\n   * deny on the basis of verdict given as parameter).\r\n   */\r\n  function getClaimMVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\r\n    claimId = _claimId;\r\n    token = 0;\r\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\r\n      if (allvotes[claimVoteMember[_claimId][i]].verdict == _verdict)\r\n        token = token.add(allvotes[claimVoteMember[_claimId][i]].tokens);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param _voter address  of voteid\r\n   * @param index index to get voteid in CA\r\n   */\r\n  function getVoteAddressCA(address _voter, uint index) external view returns (uint) {\r\n    return voteAddressCA[_voter][index];\r\n  }\r\n\r\n  /**\r\n   * @param _voter address  of voter\r\n   * @param index index to get voteid in member vote\r\n   */\r\n  function getVoteAddressMember(address _voter, uint index) external view returns (uint) {\r\n    return voteAddressMember[_voter][index];\r\n  }\r\n\r\n  /**\r\n   * @param _voter address  of voter\r\n   */\r\n  function getVoteAddressCALength(address _voter) external view returns (uint) {\r\n    return voteAddressCA[_voter].length;\r\n  }\r\n\r\n  /**\r\n   * @param _voter address  of voter\r\n   */\r\n  function getVoteAddressMemberLength(address _voter) external view returns (uint) {\r\n    return voteAddressMember[_voter].length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the Final result of voting of a claim.\r\n   * @param _claimId Claim id.\r\n   * @return verdict 1 if claim is accepted, -1 if declined.\r\n   */\r\n  function getFinalVerdict(uint _claimId) external view returns (int8 verdict) {\r\n    return claimVote[_claimId];\r\n  }\r\n\r\n  /**\r\n   * @dev Get number of Claims queued for submission during emergency pause.\r\n   */\r\n  function getLengthOfClaimSubmittedAtEP() external view returns (uint len) {\r\n    len = claimPause.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the index from which claim needs to be\r\n   * submitted when emergency pause is swithched off.\r\n   */\r\n  function getFirstClaimIndexToSubmitAfterEP() external view returns (uint indexToSubmit) {\r\n    indexToSubmit = claimPauseLastsubmit;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets number of Claims to be reopened for voting post emergency pause period.\r\n   */\r\n  function getLengthOfClaimVotingPause() external view returns (uint len) {\r\n    len = claimPauseVotingEP.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets claim details to be reopened for voting after emergency pause.\r\n   */\r\n  function getPendingClaimDetailsByIndex(\r\n    uint _index\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint claimId,\r\n    uint pendingTime,\r\n    bool voting\r\n  )\r\n  {\r\n    claimId = claimPauseVotingEP[_index].claimid;\r\n    pendingTime = claimPauseVotingEP[_index].pendingTime;\r\n    voting = claimPauseVotingEP[_index].voting;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the index from which claim needs to be reopened when emergency pause is swithched off.\r\n   */\r\n  function getFirstClaimIndexToStartVotingAfterEP() external view returns (uint firstindex) {\r\n    firstindex = claimStartVotingFirstIndex;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates Uint Parameters of a code\r\n   * @param code whose details we want to update\r\n   * @param val value to set\r\n   */\r\n  function updateUintParameters(bytes8 code, uint val) public {\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    if (code == \"CAMAXVT\") {\r\n      _setMaxVotingTime(val * 1 hours);\r\n\r\n    } else if (code == \"CAMINVT\") {\r\n\r\n      _setMinVotingTime(val * 1 hours);\r\n\r\n    } else if (code == \"CAPRETRY\") {\r\n\r\n      _setPayoutRetryTime(val * 1 hours);\r\n\r\n    } else if (code == \"CADEPT\") {\r\n\r\n      _setClaimDepositTime(val * 1 days);\r\n\r\n    } else if (code == \"CAREWPER\") {\r\n\r\n      _setClaimRewardPerc(val);\r\n\r\n    } else if (code == \"CAMINTH\") {\r\n\r\n      _setMinVoteThreshold(val);\r\n\r\n    } else if (code == \"CAMAXTH\") {\r\n\r\n      _setMaxVoteThreshold(val);\r\n\r\n    } else if (code == \"CACONPER\") {\r\n\r\n      _setMajorityConsensus(val);\r\n\r\n    } else if (code == \"CAPAUSET\") {\r\n      _setPauseDaysCA(val * 1 days);\r\n    } else {\r\n\r\n      revert(\"Invalid param code\");\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Iupgradable Interface to update dependent contract address\r\n   */\r\n  function changeDependentContractAddress() public onlyInternal {}\r\n\r\n  /**\r\n   * @dev Adds status under which a claim can lie.\r\n   * @param percCA reward percentage for claim assessor\r\n   * @param percMV reward percentage for members\r\n   */\r\n  function _pushStatus(uint percCA, uint percMV) internal {\r\n    rewardStatus.push(ClaimRewardStatus(percCA, percMV));\r\n  }\r\n\r\n  /**\r\n   * @dev adds reward incentive for all possible claim status for Claim assessors and members\r\n   */\r\n  function _addRewardIncentive() internal {\r\n    _pushStatus(0, 0); // 0  Pending-Claim Assessor Vote\r\n    _pushStatus(0, 0); // 1 Pending-Claim Assessor Vote Denied, Pending Member Vote\r\n    _pushStatus(0, 0); // 2 Pending-CA Vote Threshold not Reached Accept, Pending Member Vote\r\n    _pushStatus(0, 0); // 3 Pending-CA Vote Threshold not Reached Deny, Pending Member Vote\r\n    _pushStatus(0, 0); // 4 Pending-CA Consensus not reached Accept, Pending Member Vote\r\n    _pushStatus(0, 0); // 5 Pending-CA Consensus not reached Deny, Pending Member Vote\r\n    _pushStatus(100, 0); // 6 Final-Claim Assessor Vote Denied\r\n    _pushStatus(100, 0); // 7 Final-Claim Assessor Vote Accepted\r\n    _pushStatus(0, 100); // 8 Final-Claim Assessor Vote Denied, MV Accepted\r\n    _pushStatus(0, 100); // 9 Final-Claim Assessor Vote Denied, MV Denied\r\n    _pushStatus(0, 0); // 10 Final-Claim Assessor Vote Accept, MV Nodecision\r\n    _pushStatus(0, 0); // 11 Final-Claim Assessor Vote Denied, MV Nodecision\r\n    _pushStatus(0, 0); // 12 Claim Accepted Payout Pending\r\n    _pushStatus(0, 0); // 13 Claim Accepted No Payout\r\n    _pushStatus(0, 0); // 14 Claim Accepted Payout Done\r\n  }\r\n\r\n  /**\r\n   * @dev Sets Maximum time(in seconds) for which claim assessment voting is open\r\n   */\r\n  function _setMaxVotingTime(uint _time) internal {\r\n    maxVotingTime = _time;\r\n  }\r\n\r\n  /**\r\n   *  @dev Sets Minimum time(in seconds) for which claim assessment voting is open\r\n   */\r\n  function _setMinVotingTime(uint _time) internal {\r\n    minVotingTime = _time;\r\n  }\r\n\r\n  /**\r\n   *  @dev Sets Minimum vote threshold required\r\n   */\r\n  function _setMinVoteThreshold(uint val) internal {\r\n    minVoteThreshold = val;\r\n  }\r\n\r\n  /**\r\n   *  @dev Sets Maximum vote threshold required\r\n   */\r\n  function _setMaxVoteThreshold(uint val) internal {\r\n    maxVoteThreshold = val;\r\n  }\r\n\r\n  /**\r\n   *  @dev Sets the value considered as Majority Consenus in voting\r\n   */\r\n  function _setMajorityConsensus(uint val) internal {\r\n    majorityConsensus = val;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the payout retry time\r\n   */\r\n  function _setPayoutRetryTime(uint _time) internal {\r\n    payoutRetryTime = _time;\r\n  }\r\n\r\n  /**\r\n   *  @dev Sets percentage of reward given for claim assessment\r\n   */\r\n  function _setClaimRewardPerc(uint _val) internal {\r\n\r\n    claimRewardPerc = _val;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the time for which claim is deposited.\r\n   */\r\n  function _setClaimDepositTime(uint _time) internal {\r\n\r\n    claimDepositTime = _time;\r\n  }\r\n\r\n  /**\r\n   *  @dev Sets number of days claim assessment will be paused\r\n   */\r\n  function _setPauseDaysCA(uint val) internal {\r\n    pauseDaysCA = val;\r\n  }\r\n}\r\n\r\n// File: contracts/modules/claims/Claims.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Claims is Iupgradable {\r\n  using SafeMath for uint;\r\n\r\n  TokenFunctions internal tf;\r\n  NXMToken internal tk;\r\n  TokenController internal tc;\r\n  ClaimsReward internal cr;\r\n  Pool internal p1;\r\n  ClaimsData internal cd;\r\n  TokenData internal td;\r\n  QuotationData internal qd;\r\n\r\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\r\n\r\n  /**\r\n   * @dev Sets the status of claim using claim id.\r\n   * @param claimId claim id.\r\n   * @param stat status to be set.\r\n   */\r\n  function setClaimStatus(uint claimId, uint stat) external onlyInternal {\r\n    _setClaimStatus(claimId, stat);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets claim details of claim id = pending claim start + given index\r\n   */\r\n  function getClaimFromNewStart(\r\n    uint index\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint coverId,\r\n    uint claimId,\r\n    int8 voteCA,\r\n    int8 voteMV,\r\n    uint statusnumber\r\n  )\r\n  {\r\n    (coverId, claimId, voteCA, voteMV, statusnumber) = cd.getClaimFromNewStart(index, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets details of a claim submitted by the calling user, at a given index\r\n   */\r\n  function getUserClaimByIndex(\r\n    uint index\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint status,\r\n    uint coverId,\r\n    uint claimId\r\n  )\r\n  {\r\n    uint statusno;\r\n    (statusno, coverId, claimId) = cd.getUserClaimByIndex(index, msg.sender);\r\n    status = statusno;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets details of a given claim id.\r\n   * @param _claimId Claim Id.\r\n   * @return status Current status of claim id\r\n   * @return finalVerdict Decision made on the claim, 1 -> acceptance, -1 -> denial\r\n   * @return claimOwner Address through which claim is submitted\r\n   * @return coverId Coverid associated with the claim id\r\n   */\r\n  function getClaimbyIndex(uint _claimId) external view returns (\r\n    uint claimId,\r\n    uint status,\r\n    int8 finalVerdict,\r\n    address claimOwner,\r\n    uint coverId\r\n  )\r\n  {\r\n    uint stat;\r\n    claimId = _claimId;\r\n    (, coverId, finalVerdict, stat,,) = cd.getClaim(_claimId);\r\n    claimOwner = qd.getCoverMemberAddress(coverId);\r\n    status = stat;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates total amount that has been used to assess a claim.\r\n   * Computaion:Adds acceptCA(tokens used for voting in favor of a claim)\r\n   * denyCA(tokens used for voting against a claim) *  current token price.\r\n   * @param claimId Claim Id.\r\n   * @param member Member type 0 -> Claim Assessors, else members.\r\n   * @return tokens Total Amount used in Claims assessment.\r\n   */\r\n  function getCATokens(uint claimId, uint member) external view returns (uint tokens) {\r\n    uint coverId;\r\n    (, coverId) = cd.getClaimCoverId(claimId);\r\n\r\n    bytes4 currency = qd.getCurrencyOfCover(coverId);\r\n    address asset = cr.getCurrencyAssetAddress(currency);\r\n    uint tokenx1e18 = p1.getTokenPrice(asset);\r\n\r\n    uint accept;\r\n    uint deny;\r\n    if (member == 0) {\r\n      (, accept, deny) = cd.getClaimsTokenCA(claimId);\r\n    } else {\r\n      (, accept, deny) = cd.getClaimsTokenMV(claimId);\r\n    }\r\n    tokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18); // amount (not in tokens)\r\n  }\r\n\r\n  /**\r\n   * Iupgradable Interface to update dependent contract address\r\n   */\r\n  function changeDependentContractAddress() public onlyInternal {\r\n    tk = NXMToken(ms.tokenAddress());\r\n    td = TokenData(ms.getLatestAddress(\"TD\"));\r\n    tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n    tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n    p1 = Pool(ms.getLatestAddress(\"P1\"));\r\n    cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\r\n    cd = ClaimsData(ms.getLatestAddress(\"CD\"));\r\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the pending claim start variable,\r\n   * the lowest claim id with a pending decision/payout.\r\n   */\r\n  function changePendingClaimStart() public onlyInternal {\r\n\r\n    uint origstat;\r\n    uint state12Count;\r\n    uint pendingClaimStart = cd.pendingClaimStart();\r\n    uint actualClaimLength = cd.actualClaimLength();\r\n    for (uint i = pendingClaimStart; i < actualClaimLength; i++) {\r\n      (, , , origstat, , state12Count) = cd.getClaim(i);\r\n\r\n      if (origstat > 5 && ((origstat != 12) || (origstat == 12 && state12Count >= 60))) {\r\n        cd.setpendingClaimStart(i);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Submits a claim for a given cover note.\r\n   * Adds claim to queue incase of emergency pause else directly submits the claim.\r\n   * @param coverId Cover Id.\r\n   */\r\n  function submitClaim(uint coverId) public {\r\n    address qadd = qd.getCoverMemberAddress(coverId);\r\n    require(qadd == msg.sender);\r\n    uint8 cStatus;\r\n    (, cStatus,,,) = qd.getCoverDetailsByCoverID2(coverId);\r\n    require(cStatus != uint8(QuotationData.CoverStatus.ClaimSubmitted), \"Claim already submitted\");\r\n    require(cStatus != uint8(QuotationData.CoverStatus.CoverExpired), \"Cover already expired\");\r\n    if (ms.isPause() == false) {\r\n      _addClaim(coverId, now, qadd);\r\n    } else {\r\n      cd.setClaimAtEmergencyPause(coverId, now, false);\r\n      qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.Requested));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Submits the Claims queued once the emergency pause is switched off.\r\n   */\r\n  function submitClaimAfterEPOff() public onlyInternal {\r\n    uint lengthOfClaimSubmittedAtEP = cd.getLengthOfClaimSubmittedAtEP();\r\n    uint firstClaimIndexToSubmitAfterEP = cd.getFirstClaimIndexToSubmitAfterEP();\r\n    uint coverId;\r\n    uint dateUpd;\r\n    bool submit;\r\n    address qadd;\r\n    for (uint i = firstClaimIndexToSubmitAfterEP; i < lengthOfClaimSubmittedAtEP; i++) {\r\n      (coverId, dateUpd, submit) = cd.getClaimOfEmergencyPauseByIndex(i);\r\n      require(submit == false);\r\n      qadd = qd.getCoverMemberAddress(coverId);\r\n      _addClaim(coverId, dateUpd, qadd);\r\n      cd.setClaimSubmittedAtEPTrue(i, true);\r\n    }\r\n    cd.setFirstClaimIndexToSubmitAfterEP(lengthOfClaimSubmittedAtEP);\r\n  }\r\n\r\n  /**\r\n   * @dev Castes vote for members who have tokens locked under Claims Assessment\r\n   * @param claimId  claim id.\r\n   * @param verdict 1 for Accept,-1 for Deny.\r\n   */\r\n  function submitCAVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\r\n    require(checkVoteClosing(claimId) != 1);\r\n    require(cd.userClaimVotePausedOn(msg.sender).add(cd.pauseDaysCA()) < now);\r\n    uint tokens = tc.tokensLockedAtTime(msg.sender, \"CLA\", now.add(cd.claimDepositTime()));\r\n    require(tokens > 0);\r\n    uint stat;\r\n    (, stat) = cd.getClaimStatusNumber(claimId);\r\n    require(stat == 0);\r\n    require(cd.getUserClaimVoteCA(msg.sender, claimId) == 0);\r\n    td.bookCATokens(msg.sender);\r\n    cd.addVote(msg.sender, tokens, claimId, verdict);\r\n    cd.callVoteEvent(msg.sender, claimId, \"CAV\", tokens, now, verdict);\r\n    uint voteLength = cd.getAllVoteLength();\r\n    cd.addClaimVoteCA(claimId, voteLength);\r\n    cd.setUserClaimVoteCA(msg.sender, claimId, voteLength);\r\n    cd.setClaimTokensCA(claimId, verdict, tokens);\r\n    tc.extendLockOf(msg.sender, \"CLA\", td.lockCADays());\r\n    int close = checkVoteClosing(claimId);\r\n    if (close == 1) {\r\n      cr.changeClaimStatus(claimId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Submits a member vote for assessing a claim.\r\n   * Tokens other than those locked under Claims\r\n   * Assessment can be used to cast a vote for a given claim id.\r\n   * @param claimId Selected claim id.\r\n   * @param verdict 1 for Accept,-1 for Deny.\r\n   */\r\n  function submitMemberVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\r\n    require(checkVoteClosing(claimId) != 1);\r\n    uint stat;\r\n    uint tokens = tc.totalBalanceOf(msg.sender);\r\n    (, stat) = cd.getClaimStatusNumber(claimId);\r\n    require(stat >= 1 && stat <= 5);\r\n    require(cd.getUserClaimVoteMember(msg.sender, claimId) == 0);\r\n    cd.addVote(msg.sender, tokens, claimId, verdict);\r\n    cd.callVoteEvent(msg.sender, claimId, \"MV\", tokens, now, verdict);\r\n    tc.lockForMemberVote(msg.sender, td.lockMVDays());\r\n    uint voteLength = cd.getAllVoteLength();\r\n    cd.addClaimVotemember(claimId, voteLength);\r\n    cd.setUserClaimVoteMember(msg.sender, claimId, voteLength);\r\n    cd.setClaimTokensMV(claimId, verdict, tokens);\r\n    int close = checkVoteClosing(claimId);\r\n    if (close == 1) {\r\n      cr.changeClaimStatus(claimId);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Pause Voting of All Pending Claims when Emergency Pause Start.\r\n  */\r\n  function pauseAllPendingClaimsVoting() public onlyInternal {\r\n    uint firstIndex = cd.pendingClaimStart();\r\n    uint actualClaimLength = cd.actualClaimLength();\r\n    for (uint i = firstIndex; i < actualClaimLength; i++) {\r\n      if (checkVoteClosing(i) == 0) {\r\n        uint dateUpd = cd.getClaimDateUpd(i);\r\n        cd.setPendingClaimDetails(i, (dateUpd.add(cd.maxVotingTime())).sub(now), false);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Resume the voting phase of all Claims paused due to an emergency pause.\r\n   */\r\n  function startAllPendingClaimsVoting() public onlyInternal {\r\n    uint firstIndx = cd.getFirstClaimIndexToStartVotingAfterEP();\r\n    uint i;\r\n    uint lengthOfClaimVotingPause = cd.getLengthOfClaimVotingPause();\r\n    for (i = firstIndx; i < lengthOfClaimVotingPause; i++) {\r\n      uint pendingTime;\r\n      uint claimID;\r\n      (claimID, pendingTime,) = cd.getPendingClaimDetailsByIndex(i);\r\n      uint pTime = (now.sub(cd.maxVotingTime())).add(pendingTime);\r\n      cd.setClaimdateUpd(claimID, pTime);\r\n      cd.setPendingClaimVoteStatus(i, true);\r\n      uint coverid;\r\n      (, coverid) = cd.getClaimCoverId(claimID);\r\n      address qadd = qd.getCoverMemberAddress(coverid);\r\n      tf.extendCNEPOff(qadd, coverid, pendingTime.add(cd.claimDepositTime()));\r\n    }\r\n    cd.setFirstClaimIndexToStartVotingAfterEP(i);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if voting of a claim should be closed or not.\r\n   * @param claimId Claim Id.\r\n   * @return close 1 -> voting should be closed, 0 -> if voting should not be closed,\r\n   * -1 -> voting has already been closed.\r\n   */\r\n  function checkVoteClosing(uint claimId) public view returns (int8 close) {\r\n    close = 0;\r\n    uint status;\r\n    (, status) = cd.getClaimStatusNumber(claimId);\r\n    uint dateUpd = cd.getClaimDateUpd(claimId);\r\n    if (status == 12 && dateUpd.add(cd.payoutRetryTime()) < now) {\r\n      if (cd.getClaimState12Count(claimId) < 60)\r\n        close = 1;\r\n    }\r\n\r\n    if (status > 5 && status != 12) {\r\n      close = - 1;\r\n    } else if (status != 12 && dateUpd.add(cd.maxVotingTime()) <= now) {\r\n      close = 1;\r\n    } else if (status != 12 && dateUpd.add(cd.minVotingTime()) >= now) {\r\n      close = 0;\r\n    } else if (status == 0 || (status >= 1 && status <= 5)) {\r\n      close = _checkVoteClosingFinal(claimId, status);\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if voting of a claim should be closed or not.\r\n   * Internally called by checkVoteClosing method\r\n   * for Claims whose status number is 0 or status number lie between 2 and 6.\r\n   * @param claimId Claim Id.\r\n   * @param status Current status of claim.\r\n   * @return close 1 if voting should be closed,0 in case voting should not be closed,\r\n   * -1 if voting has already been closed.\r\n   */\r\n  function _checkVoteClosingFinal(uint claimId, uint status) internal view returns (int8 close) {\r\n    close = 0;\r\n    uint coverId;\r\n    (, coverId) = cd.getClaimCoverId(claimId);\r\n\r\n    bytes4 currency = qd.getCurrencyOfCover(coverId);\r\n    address asset = cr.getCurrencyAssetAddress(currency);\r\n    uint tokenx1e18 = p1.getTokenPrice(asset);\r\n\r\n    uint accept;\r\n    uint deny;\r\n    (, accept, deny) = cd.getClaimsTokenCA(claimId);\r\n    uint caTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\r\n    (, accept, deny) = cd.getClaimsTokenMV(claimId);\r\n    uint mvTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\r\n    uint sumassured = qd.getCoverSumAssured(coverId).mul(DECIMAL1E18);\r\n    if (status == 0 && caTokens >= sumassured.mul(10)) {\r\n      close = 1;\r\n    } else if (status >= 1 && status <= 5 && mvTokens >= sumassured.mul(10)) {\r\n      close = 1;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the status of an existing claim id, based on current\r\n   * status and current conditions of the system\r\n   * @param claimId Claim Id.\r\n   * @param stat status number.\r\n   */\r\n  function _setClaimStatus(uint claimId, uint stat) internal {\r\n\r\n    uint origstat;\r\n    uint state12Count;\r\n    uint dateUpd;\r\n    uint coverId;\r\n    (, coverId, , origstat, dateUpd, state12Count) = cd.getClaim(claimId);\r\n    (, origstat) = cd.getClaimStatusNumber(claimId);\r\n\r\n    if (stat == 12 && origstat == 12) {\r\n      cd.updateState12Count(claimId, 1);\r\n    }\r\n    cd.setClaimStatus(claimId, stat);\r\n\r\n    if (state12Count >= 60 && stat == 12) {\r\n      cd.setClaimStatus(claimId, 13);\r\n      qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimDenied));\r\n    }\r\n\r\n    cd.setClaimdateUpd(claimId, now);\r\n  }\r\n\r\n  /**\r\n   * @dev Submits a claim for a given cover note.\r\n   * Set deposits flag against cover.\r\n   */\r\n  function _addClaim(uint coverId, uint time, address add) internal {\r\n    tf.depositCN(coverId);\r\n    uint len = cd.actualClaimLength();\r\n    cd.addClaim(len, coverId, add, now);\r\n    cd.callClaimEvent(coverId, add, len, time);\r\n    qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimSubmitted));\r\n  }\r\n}\r\n\r\n// File: contracts/modules/claims/ClaimsReward.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\n//Claims Reward Contract contains the functions for calculating number of tokens\r\n// that will get rewarded, unlocked or burned depending upon the status of claim.\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ClaimsReward is Iupgradable {\r\n  using SafeMath for uint;\r\n\r\n  NXMToken internal tk;\r\n  TokenController internal tc;\r\n  TokenFunctions internal tf;\r\n  TokenData internal td;\r\n  QuotationData internal qd;\r\n  Claims internal c1;\r\n  ClaimsData internal cd;\r\n  Pool internal pool;\r\n  Governance internal gv;\r\n  IPooledStaking internal pooledStaking;\r\n  MemberRoles internal memberRoles;\r\n\r\n  // assigned in constructor\r\n  address public DAI;\r\n\r\n  // constants\r\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\r\n\r\n  constructor (address masterAddress, address _daiAddress) public {\r\n    changeMasterAddress(masterAddress);\r\n    DAI = _daiAddress;\r\n  }\r\n\r\n  function changeDependentContractAddress() public onlyInternal {\r\n    c1 = Claims(ms.getLatestAddress(\"CL\"));\r\n    cd = ClaimsData(ms.getLatestAddress(\"CD\"));\r\n    tk = NXMToken(ms.tokenAddress());\r\n    tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n    td = TokenData(ms.getLatestAddress(\"TD\"));\r\n    tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n    gv = Governance(ms.getLatestAddress(\"GV\"));\r\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\"PS\"));\r\n    memberRoles = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n    pool = Pool(ms.getLatestAddress(\"P1\"));\r\n  }\r\n\r\n  /// @dev Decides the next course of action for a given claim.\r\n  function changeClaimStatus(uint claimid) public checkPause onlyInternal {\r\n\r\n    (, uint coverid) = cd.getClaimCoverId(claimid);\r\n    (, uint status) = cd.getClaimStatusNumber(claimid);\r\n\r\n    // when current status is \"Pending-Claim Assessor Vote\"\r\n    if (status == 0) {\r\n      _changeClaimStatusCA(claimid, coverid, status);\r\n    } else if (status >= 1 && status <= 5) {\r\n      _changeClaimStatusMV(claimid, coverid, status);\r\n    } else if (status == 12) {// when current status is \"Claim Accepted Payout Pending\"\r\n\r\n      bool payoutSucceeded = attemptClaimPayout(coverid);\r\n\r\n      if (payoutSucceeded) {\r\n        c1.setClaimStatus(claimid, 14);\r\n      } else {\r\n        c1.setClaimStatus(claimid, 12);\r\n      }\r\n    }\r\n\r\n    c1.changePendingClaimStart();\r\n  }\r\n\r\n  function getCurrencyAssetAddress(bytes4 currency) public view returns (address) {\r\n\r\n    if (currency == \"ETH\") {\r\n      return ETH;\r\n    }\r\n\r\n    if (currency == \"DAI\") {\r\n      return DAI;\r\n    }\r\n\r\n    revert(\"ClaimsReward: unknown asset\");\r\n  }\r\n\r\n  function attemptClaimPayout(uint coverId) internal returns (bool success) {\r\n\r\n    uint sumAssured = qd.getCoverSumAssured(coverId);\r\n    // TODO: when adding new cover currencies, fetch the correct decimals for this multiplication\r\n    uint sumAssuredWei = sumAssured.mul(1e18);\r\n\r\n    // get asset address\r\n    bytes4 coverCurrency = qd.getCurrencyOfCover(coverId);\r\n    address asset = getCurrencyAssetAddress(coverCurrency);\r\n\r\n    // get payout address\r\n    address payable coverHolder = qd.getCoverMemberAddress(coverId);\r\n    address payable payoutAddress = memberRoles.getClaimPayoutAddress(coverHolder);\r\n\r\n    // execute the payout\r\n    bool payoutSucceeded = pool.sendClaimPayout(asset, payoutAddress, sumAssuredWei);\r\n\r\n    if (payoutSucceeded) {\r\n\r\n      // burn staked tokens\r\n      (, address scAddress) = qd.getscAddressOfCover(coverId);\r\n      uint tokenPrice = pool.getTokenPrice(asset);\r\n\r\n      // note: for new assets \"18\" needs to be replaced with target asset decimals\r\n      uint burnNXMAmount = sumAssuredWei.mul(1e18).div(tokenPrice);\r\n      pooledStaking.pushBurn(scAddress, burnNXMAmount);\r\n\r\n      // adjust total sum assured\r\n      (, address coverContract) = qd.getscAddressOfCover(coverId);\r\n      qd.subFromTotalSumAssured(coverCurrency, sumAssured);\r\n      qd.subFromTotalSumAssuredSC(coverContract, coverCurrency, sumAssured);\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /// @dev Amount of tokens to be rewarded to a user for a particular vote id.\r\n  /// @param check 1 -> CA vote, else member vote\r\n  /// @param voteid vote id for which reward has to be Calculated\r\n  /// @param flag if 1 calculate even if claimed,else don't calculate if already claimed\r\n  /// @return tokenCalculated reward to be given for vote id\r\n  /// @return lastClaimedCheck true if final verdict is still pending for that voteid\r\n  /// @return tokens number of tokens locked under that voteid\r\n  /// @return perc percentage of reward to be given.\r\n  function getRewardToBeGiven(\r\n    uint check,\r\n    uint voteid,\r\n    uint flag\r\n  )\r\n  public\r\n  view\r\n  returns (\r\n    uint tokenCalculated,\r\n    bool lastClaimedCheck,\r\n    uint tokens,\r\n    uint perc\r\n  )\r\n\r\n  {\r\n    uint claimId;\r\n    int8 verdict;\r\n    bool claimed;\r\n    uint tokensToBeDist;\r\n    uint totalTokens;\r\n    (tokens, claimId, verdict, claimed) = cd.getVoteDetails(voteid);\r\n    lastClaimedCheck = false;\r\n    int8 claimVerdict = cd.getFinalVerdict(claimId);\r\n    if (claimVerdict == 0) {\r\n      lastClaimedCheck = true;\r\n    }\r\n\r\n    if (claimVerdict == verdict && (claimed == false || flag == 1)) {\r\n\r\n      if (check == 1) {\r\n        (perc, , tokensToBeDist) = cd.getClaimRewardDetail(claimId);\r\n      } else {\r\n        (, perc, tokensToBeDist) = cd.getClaimRewardDetail(claimId);\r\n      }\r\n\r\n      if (perc > 0) {\r\n        if (check == 1) {\r\n          if (verdict == 1) {\r\n            (, totalTokens,) = cd.getClaimsTokenCA(claimId);\r\n          } else {\r\n            (,, totalTokens) = cd.getClaimsTokenCA(claimId);\r\n          }\r\n        } else {\r\n          if (verdict == 1) {\r\n            (, totalTokens,) = cd.getClaimsTokenMV(claimId);\r\n          } else {\r\n            (,, totalTokens) = cd.getClaimsTokenMV(claimId);\r\n          }\r\n        }\r\n        tokenCalculated = (perc.mul(tokens).mul(tokensToBeDist)).div(totalTokens.mul(100));\r\n\r\n\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Transfers all tokens held by contract to a new contract in case of upgrade.\r\n  function upgrade(address _newAdd) public onlyInternal {\r\n    uint amount = tk.balanceOf(address(this));\r\n    if (amount > 0) {\r\n      require(tk.transfer(_newAdd, amount));\r\n    }\r\n\r\n  }\r\n\r\n  /// @dev Total reward in token due for claim by a user.\r\n  /// @return total total number of tokens\r\n  function getRewardToBeDistributedByUser(address _add) public view returns (uint total) {\r\n    uint lengthVote = cd.getVoteAddressCALength(_add);\r\n    uint lastIndexCA;\r\n    uint lastIndexMV;\r\n    uint tokenForVoteId;\r\n    uint voteId;\r\n    (lastIndexCA, lastIndexMV) = cd.getRewardDistributedIndex(_add);\r\n\r\n    for (uint i = lastIndexCA; i < lengthVote; i++) {\r\n      voteId = cd.getVoteAddressCA(_add, i);\r\n      (tokenForVoteId,,,) = getRewardToBeGiven(1, voteId, 0);\r\n      total = total.add(tokenForVoteId);\r\n    }\r\n\r\n    lengthVote = cd.getVoteAddressMemberLength(_add);\r\n\r\n    for (uint j = lastIndexMV; j < lengthVote; j++) {\r\n      voteId = cd.getVoteAddressMember(_add, j);\r\n      (tokenForVoteId,,,) = getRewardToBeGiven(0, voteId, 0);\r\n      total = total.add(tokenForVoteId);\r\n    }\r\n    return (total);\r\n  }\r\n\r\n  /// @dev Gets reward amount and claiming status for a given claim id.\r\n  /// @return reward amount of tokens to user.\r\n  /// @return claimed true if already claimed false if yet to be claimed.\r\n  function getRewardAndClaimedStatus(uint check, uint claimId) public view returns (uint reward, bool claimed) {\r\n    uint voteId;\r\n    uint claimid;\r\n    uint lengthVote;\r\n\r\n    if (check == 1) {\r\n      lengthVote = cd.getVoteAddressCALength(msg.sender);\r\n      for (uint i = 0; i < lengthVote; i++) {\r\n        voteId = cd.getVoteAddressCA(msg.sender, i);\r\n        (, claimid, , claimed) = cd.getVoteDetails(voteId);\r\n        if (claimid == claimId) {break;}\r\n      }\r\n    } else {\r\n      lengthVote = cd.getVoteAddressMemberLength(msg.sender);\r\n      for (uint j = 0; j < lengthVote; j++) {\r\n        voteId = cd.getVoteAddressMember(msg.sender, j);\r\n        (, claimid, , claimed) = cd.getVoteDetails(voteId);\r\n        if (claimid == claimId) {break;}\r\n      }\r\n    }\r\n    (reward,,,) = getRewardToBeGiven(check, voteId, 1);\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Function used to claim all pending rewards : Claims Assessment + Risk Assessment + Governance\r\n   * Claim assesment, Risk assesment, Governance rewards\r\n   */\r\n  function claimAllPendingReward(uint records) public isMemberAndcheckPause {\r\n    _claimRewardToBeDistributed(records);\r\n    pooledStaking.withdrawReward(msg.sender);\r\n    uint governanceRewards = gv.claimReward(msg.sender, records);\r\n    if (governanceRewards > 0) {\r\n      require(tk.transfer(msg.sender, governanceRewards));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Function used to get pending rewards of a particular user address.\r\n   * @param _add user address.\r\n   * @return total reward amount of the user\r\n   */\r\n  function getAllPendingRewardOfUser(address _add) public view returns (uint) {\r\n    uint caReward = getRewardToBeDistributedByUser(_add);\r\n    uint pooledStakingReward = pooledStaking.stakerReward(_add);\r\n    uint governanceReward = gv.getPendingReward(_add);\r\n    return caReward.add(pooledStakingReward).add(governanceReward);\r\n  }\r\n\r\n  /// @dev Rewards/Punishes users who  participated in Claims assessment.\r\n  //    Unlocking and burning of the tokens will also depend upon the status of claim.\r\n  /// @param claimid Claim Id.\r\n  function _rewardAgainstClaim(uint claimid, uint coverid, uint status) internal {\r\n\r\n    uint premiumNXM = qd.getCoverPremiumNXM(coverid);\r\n    uint distributableTokens = premiumNXM.mul(cd.claimRewardPerc()).div(100); // 20% of premium\r\n\r\n    uint percCA;\r\n    uint percMV;\r\n\r\n    (percCA, percMV) = cd.getRewardStatus(status);\r\n    cd.setClaimRewardDetail(claimid, percCA, percMV, distributableTokens);\r\n\r\n    if (percCA > 0 || percMV > 0) {\r\n      tc.mint(address(this), distributableTokens);\r\n    }\r\n\r\n    // denied\r\n    if (status == 6 || status == 9 || status == 11) {\r\n\r\n      cd.changeFinalVerdict(claimid, - 1);\r\n      td.setDepositCN(coverid, false); // Unset flag\r\n      tf.burnDepositCN(coverid); // burn Deposited CN\r\n\r\n    // accepted\r\n    } else if (status == 7 || status == 8 || status == 10) {\r\n\r\n      cd.changeFinalVerdict(claimid, 1);\r\n      td.setDepositCN(coverid, false); // Unset flag\r\n      tf.unlockCN(coverid);\r\n\r\n      bool payoutSucceeded = attemptClaimPayout(coverid);\r\n\r\n      // 12 = payout pending, 14 = payout succeeded\r\n      uint nextStatus = payoutSucceeded ? 14 : 12;\r\n      c1.setClaimStatus(claimid, nextStatus);\r\n    }\r\n  }\r\n\r\n  /// @dev Computes the result of Claim Assessors Voting for a given claim id.\r\n  function _changeClaimStatusCA(uint claimid, uint coverid, uint status) internal {\r\n    // Check if voting should be closed or not\r\n    if (c1.checkVoteClosing(claimid) == 1) {\r\n      uint caTokens = c1.getCATokens(claimid, 0); // converted in cover currency.\r\n      uint accept;\r\n      uint deny;\r\n      uint acceptAndDeny;\r\n      bool rewardOrPunish;\r\n      uint sumAssured;\r\n      (, accept) = cd.getClaimVote(claimid, 1);\r\n      (, deny) = cd.getClaimVote(claimid, - 1);\r\n      acceptAndDeny = accept.add(deny);\r\n      accept = accept.mul(100);\r\n      deny = deny.mul(100);\r\n\r\n      if (caTokens == 0) {\r\n        status = 3;\r\n      } else {\r\n        sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\r\n        // Min threshold reached tokens used for voting > 5* sum assured\r\n        if (caTokens > sumAssured.mul(5)) {\r\n\r\n          if (accept.div(acceptAndDeny) > 70) {\r\n            status = 7;\r\n            qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimAccepted));\r\n            rewardOrPunish = true;\r\n          } else if (deny.div(acceptAndDeny) > 70) {\r\n            status = 6;\r\n            qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimDenied));\r\n            rewardOrPunish = true;\r\n          } else if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\r\n            status = 4;\r\n          } else {\r\n            status = 5;\r\n          }\r\n\r\n        } else {\r\n\r\n          if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\r\n            status = 2;\r\n          } else {\r\n            status = 3;\r\n          }\r\n        }\r\n      }\r\n\r\n      c1.setClaimStatus(claimid, status);\r\n\r\n      if (rewardOrPunish) {\r\n        _rewardAgainstClaim(claimid, coverid, status);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Computes the result of Member Voting for a given claim id.\r\n  function _changeClaimStatusMV(uint claimid, uint coverid, uint status) internal {\r\n\r\n    // Check if voting should be closed or not\r\n    if (c1.checkVoteClosing(claimid) == 1) {\r\n      uint8 coverStatus;\r\n      uint statusOrig = status;\r\n      uint mvTokens = c1.getCATokens(claimid, 1); // converted in cover currency.\r\n\r\n      // If tokens used for acceptance >50%, claim is accepted\r\n      uint sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\r\n      uint thresholdUnreached = 0;\r\n      // Minimum threshold for member voting is reached only when\r\n      // value of tokens used for voting > 5* sum assured of claim id\r\n      if (mvTokens < sumAssured.mul(5)) {\r\n        thresholdUnreached = 1;\r\n      }\r\n\r\n      uint accept;\r\n      (, accept) = cd.getClaimMVote(claimid, 1);\r\n      uint deny;\r\n      (, deny) = cd.getClaimMVote(claimid, - 1);\r\n\r\n      if (accept.add(deny) > 0) {\r\n        if (accept.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\r\n        statusOrig <= 5 && thresholdUnreached == 0) {\r\n          status = 8;\r\n          coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\r\n        } else if (deny.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\r\n        statusOrig <= 5 && thresholdUnreached == 0) {\r\n          status = 9;\r\n          coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\r\n        }\r\n      }\r\n\r\n      if (thresholdUnreached == 1 && (statusOrig == 2 || statusOrig == 4)) {\r\n        status = 10;\r\n        coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\r\n      } else if (thresholdUnreached == 1 && (statusOrig == 5 || statusOrig == 3 || statusOrig == 1)) {\r\n        status = 11;\r\n        coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\r\n      }\r\n\r\n      c1.setClaimStatus(claimid, status);\r\n      qd.changeCoverStatusNo(coverid, uint8(coverStatus));\r\n      // Reward/Punish Claim Assessors and Members who participated in Claims assessment\r\n      _rewardAgainstClaim(claimid, coverid, status);\r\n    }\r\n  }\r\n\r\n  /// @dev Allows a user to claim all pending  Claims assessment rewards.\r\n  function _claimRewardToBeDistributed(uint _records) internal {\r\n    uint lengthVote = cd.getVoteAddressCALength(msg.sender);\r\n    uint voteid;\r\n    uint lastIndex;\r\n    (lastIndex,) = cd.getRewardDistributedIndex(msg.sender);\r\n    uint total = 0;\r\n    uint tokenForVoteId = 0;\r\n    bool lastClaimedCheck;\r\n    uint _days = td.lockCADays();\r\n    bool claimed;\r\n    uint counter = 0;\r\n    uint claimId;\r\n    uint perc;\r\n    uint i;\r\n    uint lastClaimed = lengthVote;\r\n\r\n    for (i = lastIndex; i < lengthVote && counter < _records; i++) {\r\n      voteid = cd.getVoteAddressCA(msg.sender, i);\r\n      (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\r\n      if (lastClaimed == lengthVote && lastClaimedCheck == true) {\r\n        lastClaimed = i;\r\n      }\r\n      (, claimId, , claimed) = cd.getVoteDetails(voteid);\r\n\r\n      if (perc > 0 && !claimed) {\r\n        counter++;\r\n        cd.setRewardClaimed(voteid, true);\r\n      } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\r\n        (perc,,) = cd.getClaimRewardDetail(claimId);\r\n        if (perc == 0) {\r\n          counter++;\r\n        }\r\n        cd.setRewardClaimed(voteid, true);\r\n      }\r\n      if (tokenForVoteId > 0) {\r\n        total = tokenForVoteId.add(total);\r\n      }\r\n    }\r\n    if (lastClaimed == lengthVote) {\r\n      cd.setRewardDistributedIndexCA(msg.sender, i);\r\n    }\r\n    else {\r\n      cd.setRewardDistributedIndexCA(msg.sender, lastClaimed);\r\n    }\r\n    lengthVote = cd.getVoteAddressMemberLength(msg.sender);\r\n    lastClaimed = lengthVote;\r\n    _days = _days.mul(counter);\r\n    if (tc.tokensLockedAtTime(msg.sender, \"CLA\", now) > 0) {\r\n      tc.reduceLock(msg.sender, \"CLA\", _days);\r\n    }\r\n    (, lastIndex) = cd.getRewardDistributedIndex(msg.sender);\r\n    lastClaimed = lengthVote;\r\n    counter = 0;\r\n    for (i = lastIndex; i < lengthVote && counter < _records; i++) {\r\n      voteid = cd.getVoteAddressMember(msg.sender, i);\r\n      (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\r\n      if (lastClaimed == lengthVote && lastClaimedCheck == true) {\r\n        lastClaimed = i;\r\n      }\r\n      (, claimId, , claimed) = cd.getVoteDetails(voteid);\r\n      if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\r\n        cd.setRewardClaimed(voteid, true);\r\n        counter++;\r\n      }\r\n      if (tokenForVoteId > 0) {\r\n        total = tokenForVoteId.add(total);\r\n      }\r\n    }\r\n    if (total > 0) {\r\n      require(tk.transfer(msg.sender, total));\r\n    }\r\n    if (lastClaimed == lengthVote) {\r\n      cd.setRewardDistributedIndexMV(msg.sender, i);\r\n    }\r\n    else {\r\n      cd.setRewardDistributedIndexMV(msg.sender, lastClaimed);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Function used to claim the commission earned by the staker.\r\n   */\r\n  function _claimStakeCommission(uint _records, address _user) external onlyInternal {\r\n    uint total = 0;\r\n    uint len = td.getStakerStakedContractLength(_user);\r\n    uint lastCompletedStakeCommission = td.lastCompletedStakeCommission(_user);\r\n    uint commissionEarned;\r\n    uint commissionRedeemed;\r\n    uint maxCommission;\r\n    uint lastCommisionRedeemed = len;\r\n    uint counter;\r\n    uint i;\r\n\r\n    for (i = lastCompletedStakeCommission; i < len && counter < _records; i++) {\r\n      commissionRedeemed = td.getStakerRedeemedStakeCommission(_user, i);\r\n      commissionEarned = td.getStakerEarnedStakeCommission(_user, i);\r\n      maxCommission = td.getStakerInitialStakedAmountOnContract(\r\n        _user, i).mul(td.stakerMaxCommissionPer()).div(100);\r\n      if (lastCommisionRedeemed == len && maxCommission != commissionEarned)\r\n        lastCommisionRedeemed = i;\r\n      td.pushRedeemedStakeCommissions(_user, i, commissionEarned.sub(commissionRedeemed));\r\n      total = total.add(commissionEarned.sub(commissionRedeemed));\r\n      counter++;\r\n    }\r\n    if (lastCommisionRedeemed == len) {\r\n      td.setLastCompletedStakeCommissionIndex(_user, i);\r\n    } else {\r\n      td.setLastCompletedStakeCommissionIndex(_user, lastCommisionRedeemed);\r\n    }\r\n\r\n    if (total > 0)\r\n      require(tk.transfer(_user, total)); // solhint-disable-line\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/modules/governance/MemberRoles.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MemberRoles is Governed, Iupgradable {\r\n\r\n  TokenController public dAppToken;\r\n  TokenData internal td;\r\n  QuotationData internal qd;\r\n  ClaimsReward internal cr;\r\n  Governance internal gv;\r\n  TokenFunctions internal tf;\r\n  NXMToken public tk;\r\n\r\n  struct MemberRoleDetails {\r\n    uint memberCounter;\r\n    mapping(address => bool) memberActive;\r\n    address[] memberAddress;\r\n    address authorized;\r\n  }\r\n\r\n  enum Role {UnAssigned, AdvisoryBoard, Member, Owner}\r\n\r\n  event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\r\n\r\n  event switchedMembership(address indexed previousMember, address indexed newMember, uint timeStamp);\r\n\r\n  event ClaimPayoutAddressSet(address indexed member, address indexed payoutAddress);\r\n\r\n  MemberRoleDetails[] internal memberRoleData;\r\n  bool internal constructorCheck;\r\n  uint public maxABCount;\r\n  bool public launched;\r\n  uint public launchedOn;\r\n\r\n  mapping (address => address payable) internal claimPayoutAddress;\r\n\r\n  modifier checkRoleAuthority(uint _memberRoleId) {\r\n    if (memberRoleData[_memberRoleId].authorized != address(0))\r\n      require(msg.sender == memberRoleData[_memberRoleId].authorized);\r\n    else\r\n      require(isAuthorizedToGovern(msg.sender), \"Not Authorized\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev to swap advisory board member\r\n   * @param _newABAddress is address of new AB member\r\n   * @param _removeAB is advisory board member to be removed\r\n   */\r\n  function swapABMember(\r\n    address _newABAddress,\r\n    address _removeAB\r\n  )\r\n  external\r\n  checkRoleAuthority(uint(Role.AdvisoryBoard)) {\r\n\r\n    _updateRole(_newABAddress, uint(Role.AdvisoryBoard), true);\r\n    _updateRole(_removeAB, uint(Role.AdvisoryBoard), false);\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev to swap the owner address\r\n   * @param _newOwnerAddress is the new owner address\r\n   */\r\n  function swapOwner(\r\n    address _newOwnerAddress\r\n  )\r\n  external {\r\n    require(msg.sender == address(ms));\r\n    _updateRole(ms.owner(), uint(Role.Owner), false);\r\n    _updateRole(_newOwnerAddress, uint(Role.Owner), true);\r\n  }\r\n\r\n  /**\r\n   * @dev is used to add initital advisory board members\r\n   * @param abArray is the list of initial advisory board members\r\n   */\r\n  function addInitialABMembers(address[] calldata abArray) external onlyOwner {\r\n\r\n    //Ensure that NXMaster has initialized.\r\n    require(ms.masterInitialized());\r\n\r\n    require(maxABCount >=\r\n      SafeMath.add(numberOfMembers(uint(Role.AdvisoryBoard)), abArray.length)\r\n    );\r\n    //AB count can't exceed maxABCount\r\n    for (uint i = 0; i < abArray.length; i++) {\r\n      require(checkRole(abArray[i], uint(MemberRoles.Role.Member)));\r\n      _updateRole(abArray[i], uint(Role.AdvisoryBoard), true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev to change max number of AB members allowed\r\n   * @param _val is the new value to be set\r\n   */\r\n  function changeMaxABCount(uint _val) external onlyInternal {\r\n    maxABCount = _val;\r\n  }\r\n\r\n  /**\r\n   * @dev Iupgradable Interface to update dependent contract address\r\n   */\r\n  function changeDependentContractAddress() public {\r\n    td = TokenData(ms.getLatestAddress(\"TD\"));\r\n    cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\r\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n    gv = Governance(ms.getLatestAddress(\"GV\"));\r\n    tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n    tk = NXMToken(ms.tokenAddress());\r\n    dAppToken = TokenController(ms.getLatestAddress(\"TC\"));\r\n  }\r\n\r\n  /**\r\n   * @dev to change the master address\r\n   * @param _masterAddress is the new master address\r\n   */\r\n  function changeMasterAddress(address _masterAddress) public {\r\n    if (masterAddress != address(0))\r\n      require(masterAddress == msg.sender);\r\n    masterAddress = _masterAddress;\r\n    ms = INXMMaster(_masterAddress);\r\n    nxMasterAddress = _masterAddress;\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev to initiate the member roles\r\n   * @param _firstAB is the address of the first AB member\r\n   * @param memberAuthority is the authority (role) of the member\r\n   */\r\n  function memberRolesInitiate(address _firstAB, address memberAuthority) public {\r\n    require(!constructorCheck);\r\n    _addInitialMemberRoles(_firstAB, memberAuthority);\r\n    constructorCheck = true;\r\n  }\r\n\r\n  /// @dev Adds new member role\r\n  /// @param _roleName New role name\r\n  /// @param _roleDescription New description hash\r\n  /// @param _authorized Authorized member against every role id\r\n  function addRole(//solhint-disable-line\r\n    bytes32 _roleName,\r\n    string memory _roleDescription,\r\n    address _authorized\r\n  )\r\n  public\r\n  onlyAuthorizedToGovern {\r\n    _addRole(_roleName, _roleDescription, _authorized);\r\n  }\r\n\r\n  /// @dev Assign or Delete a member from specific role.\r\n  /// @param _memberAddress Address of Member\r\n  /// @param _roleId RoleId to update\r\n  /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\r\n  function updateRole(//solhint-disable-line\r\n    address _memberAddress,\r\n    uint _roleId,\r\n    bool _active\r\n  )\r\n  public\r\n  checkRoleAuthority(_roleId) {\r\n    _updateRole(_memberAddress, _roleId, _active);\r\n  }\r\n\r\n  /**\r\n   * @dev to add members before launch\r\n   * @param userArray is list of addresses of members\r\n   * @param tokens is list of tokens minted for each array element\r\n   */\r\n  function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {\r\n    require(!launched);\r\n\r\n    for (uint i = 0; i < userArray.length; i++) {\r\n      require(!ms.isMember(userArray[i]));\r\n      dAppToken.addToWhitelist(userArray[i]);\r\n      _updateRole(userArray[i], uint(Role.Member), true);\r\n      dAppToken.mint(userArray[i], tokens[i]);\r\n    }\r\n    launched = true;\r\n    launchedOn = now;\r\n\r\n  }\r\n\r\n  /**\r\n    * @dev Called by user to pay joining membership fee\r\n    */\r\n  function payJoiningFee(address _userAddress) public payable {\r\n    require(_userAddress != address(0));\r\n    require(!ms.isPause(), \"Emergency Pause Applied\");\r\n    if (msg.sender == address(ms.getLatestAddress(\"QT\"))) {\r\n      require(td.walletAddress() != address(0), \"No walletAddress present\");\r\n      dAppToken.addToWhitelist(_userAddress);\r\n      _updateRole(_userAddress, uint(Role.Member), true);\r\n      td.walletAddress().transfer(msg.value);\r\n    } else {\r\n      require(!qd.refundEligible(_userAddress));\r\n      require(!ms.isMember(_userAddress));\r\n      require(msg.value == td.joiningFee());\r\n      qd.setRefundEligible(_userAddress, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev to perform kyc verdict\r\n   * @param _userAddress whose kyc is being performed\r\n   * @param verdict of kyc process\r\n   */\r\n  function kycVerdict(address payable _userAddress, bool verdict) public {\r\n\r\n    require(msg.sender == qd.kycAuthAddress());\r\n    require(!ms.isPause());\r\n    require(_userAddress != address(0));\r\n    require(!ms.isMember(_userAddress));\r\n    require(qd.refundEligible(_userAddress));\r\n    if (verdict) {\r\n      qd.setRefundEligible(_userAddress, false);\r\n      uint fee = td.joiningFee();\r\n      dAppToken.addToWhitelist(_userAddress);\r\n      _updateRole(_userAddress, uint(Role.Member), true);\r\n      td.walletAddress().transfer(fee); // solhint-disable-line\r\n\r\n    } else {\r\n      qd.setRefundEligible(_userAddress, false);\r\n      _userAddress.transfer(td.joiningFee()); // solhint-disable-line\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Called by existed member if wish to Withdraw membership.\r\n   */\r\n  function withdrawMembership() public {\r\n\r\n    require(!ms.isPause() && ms.isMember(msg.sender));\r\n    require(dAppToken.totalLockedBalance(msg.sender, now) == 0); // solhint-disable-line\r\n    require(!tf.isLockedForMemberVote(msg.sender)); // No locked tokens for Member/Governance voting\r\n    require(cr.getAllPendingRewardOfUser(msg.sender) == 0); // No pending reward to be claimed(claim assesment).\r\n    require(dAppToken.tokensUnlockable(msg.sender, \"CLA\") == 0, \"Member should have no CLA unlockable tokens\");\r\n\r\n    gv.removeDelegation(msg.sender);\r\n    dAppToken.burnFrom(msg.sender, tk.balanceOf(msg.sender));\r\n    _updateRole(msg.sender, uint(Role.Member), false);\r\n    dAppToken.removeFromWhitelist(msg.sender); // need clarification on whitelist\r\n\r\n    if (claimPayoutAddress[msg.sender] != address(0)) {\r\n      claimPayoutAddress[msg.sender] = address(0);\r\n      emit ClaimPayoutAddressSet(msg.sender, address(0));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Called by existed member if wish to switch membership to other address.\r\n   * @param _add address of user to forward membership.\r\n   */\r\n  function switchMembership(address _add) external {\r\n\r\n    require(!ms.isPause() && ms.isMember(msg.sender) && !ms.isMember(_add));\r\n    require(dAppToken.totalLockedBalance(msg.sender, now) == 0); // solhint-disable-line\r\n    require(!tf.isLockedForMemberVote(msg.sender)); // No locked tokens for Member/Governance voting\r\n    require(cr.getAllPendingRewardOfUser(msg.sender) == 0); // No pending reward to be claimed(claim assesment).\r\n    require(dAppToken.tokensUnlockable(msg.sender, \"CLA\") == 0, \"Member should have no CLA unlockable tokens\");\r\n\r\n    gv.removeDelegation(msg.sender);\r\n    dAppToken.addToWhitelist(_add);\r\n    _updateRole(_add, uint(Role.Member), true);\r\n    tk.transferFrom(msg.sender, _add, tk.balanceOf(msg.sender));\r\n    _updateRole(msg.sender, uint(Role.Member), false);\r\n    dAppToken.removeFromWhitelist(msg.sender);\r\n\r\n    address payable previousPayoutAddress = claimPayoutAddress[msg.sender];\r\n\r\n    if (previousPayoutAddress != address(0)) {\r\n\r\n      address payable storedAddress = previousPayoutAddress == _add ? address(0) : previousPayoutAddress;\r\n\r\n      claimPayoutAddress[msg.sender] = address(0);\r\n      claimPayoutAddress[_add] = storedAddress;\r\n\r\n      // emit event for old address reset\r\n      emit ClaimPayoutAddressSet(msg.sender, address(0));\r\n\r\n      if (storedAddress != address(0)) {\r\n        // emit event for setting the payout address on the new member address if it's non zero\r\n        emit ClaimPayoutAddressSet(_add, storedAddress);\r\n      }\r\n    }\r\n\r\n    emit switchedMembership(msg.sender, _add, now);\r\n  }\r\n\r\n  function getClaimPayoutAddress(address payable _member) external view returns (address payable) {\r\n    address payable payoutAddress = claimPayoutAddress[_member];\r\n    return payoutAddress != address(0) ? payoutAddress : _member;\r\n  }\r\n\r\n  function setClaimPayoutAddress(address payable _address) external {\r\n\r\n    require(!ms.isPause(), \"system is paused\");\r\n    require(ms.isMember(msg.sender), \"sender is not a member\");\r\n    require(_address != msg.sender, \"should be different than the member address\");\r\n\r\n    claimPayoutAddress[msg.sender] = _address;\r\n    emit ClaimPayoutAddressSet(msg.sender, _address);\r\n  }\r\n\r\n  /// @dev Return number of member roles\r\n  function totalRoles() public view returns (uint256) {//solhint-disable-line\r\n    return memberRoleData.length;\r\n  }\r\n\r\n  /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\r\n  /// @param _roleId roleId to update its Authorized Address\r\n  /// @param _newAuthorized New authorized address against role id\r\n  function changeAuthorized(uint _roleId, address _newAuthorized) public checkRoleAuthority(_roleId) {//solhint-disable-line\r\n    memberRoleData[_roleId].authorized = _newAuthorized;\r\n  }\r\n\r\n  /// @dev Gets the member addresses assigned by a specific role\r\n  /// @param _memberRoleId Member role id\r\n  /// @return roleId Role id\r\n  /// @return allMemberAddress Member addresses of specified role id\r\n  function members(uint _memberRoleId) public view returns (uint, address[] memory memberArray) {//solhint-disable-line\r\n    uint length = memberRoleData[_memberRoleId].memberAddress.length;\r\n    uint i;\r\n    uint j = 0;\r\n    memberArray = new address[](memberRoleData[_memberRoleId].memberCounter);\r\n    for (i = 0; i < length; i++) {\r\n      address member = memberRoleData[_memberRoleId].memberAddress[i];\r\n      if (memberRoleData[_memberRoleId].memberActive[member] && !_checkMemberInArray(member, memberArray)) {//solhint-disable-line\r\n        memberArray[j] = member;\r\n        j++;\r\n      }\r\n    }\r\n\r\n    return (_memberRoleId, memberArray);\r\n  }\r\n\r\n  /// @dev Gets all members' length\r\n  /// @param _memberRoleId Member role id\r\n  /// @return memberRoleData[_memberRoleId].memberCounter Member length\r\n  function numberOfMembers(uint _memberRoleId) public view returns (uint) {//solhint-disable-line\r\n    return memberRoleData[_memberRoleId].memberCounter;\r\n  }\r\n\r\n  /// @dev Return member address who holds the right to add/remove any member from specific role.\r\n  function authorized(uint _memberRoleId) public view returns (address) {//solhint-disable-line\r\n    return memberRoleData[_memberRoleId].authorized;\r\n  }\r\n\r\n  /// @dev Get All role ids array that has been assigned to a member so far.\r\n  function roles(address _memberAddress) public view returns (uint[] memory) {//solhint-disable-line\r\n    uint length = memberRoleData.length;\r\n    uint[] memory assignedRoles = new uint[](length);\r\n    uint counter = 0;\r\n    for (uint i = 1; i < length; i++) {\r\n      if (memberRoleData[i].memberActive[_memberAddress]) {\r\n        assignedRoles[counter] = i;\r\n        counter++;\r\n      }\r\n    }\r\n    return assignedRoles;\r\n  }\r\n\r\n  /// @dev Returns true if the given role id is assigned to a member.\r\n  /// @param _memberAddress Address of member\r\n  /// @param _roleId Checks member's authenticity with the roleId.\r\n  /// i.e. Returns true if this roleId is assigned to member\r\n  function checkRole(address _memberAddress, uint _roleId) public view returns (bool) {//solhint-disable-line\r\n    if (_roleId == uint(Role.UnAssigned))\r\n      return true;\r\n    else\r\n      if (memberRoleData[_roleId].memberActive[_memberAddress]) //solhint-disable-line\r\n        return true;\r\n      else\r\n        return false;\r\n  }\r\n\r\n  /// @dev Return total number of members assigned against each role id.\r\n  /// @return totalMembers Total members in particular role id\r\n  function getMemberLengthForAllRoles() public view returns (uint[] memory totalMembers) {//solhint-disable-line\r\n    totalMembers = new uint[](memberRoleData.length);\r\n    for (uint i = 0; i < memberRoleData.length; i++) {\r\n      totalMembers[i] = numberOfMembers(i);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev to update the member roles\r\n   * @param _memberAddress in concern\r\n   * @param _roleId the id of role\r\n   * @param _active if active is true, add the member, else remove it\r\n   */\r\n  function _updateRole(address _memberAddress,\r\n    uint _roleId,\r\n    bool _active) internal {\r\n    // require(_roleId != uint(Role.TokenHolder), \"Membership to Token holder is detected automatically\");\r\n    if (_active) {\r\n      require(!memberRoleData[_roleId].memberActive[_memberAddress]);\r\n      memberRoleData[_roleId].memberCounter = SafeMath.add(memberRoleData[_roleId].memberCounter, 1);\r\n      memberRoleData[_roleId].memberActive[_memberAddress] = true;\r\n      memberRoleData[_roleId].memberAddress.push(_memberAddress);\r\n    } else {\r\n      require(memberRoleData[_roleId].memberActive[_memberAddress]);\r\n      memberRoleData[_roleId].memberCounter = SafeMath.sub(memberRoleData[_roleId].memberCounter, 1);\r\n      delete memberRoleData[_roleId].memberActive[_memberAddress];\r\n    }\r\n  }\r\n\r\n  /// @dev Adds new member role\r\n  /// @param _roleName New role name\r\n  /// @param _roleDescription New description hash\r\n  /// @param _authorized Authorized member against every role id\r\n  function _addRole(\r\n    bytes32 _roleName,\r\n    string memory _roleDescription,\r\n    address _authorized\r\n  ) internal {\r\n    emit MemberRole(memberRoleData.length, _roleName, _roleDescription);\r\n    memberRoleData.push(MemberRoleDetails(0, new address[](0), _authorized));\r\n  }\r\n\r\n  /**\r\n   * @dev to check if member is in the given member array\r\n   * @param _memberAddress in concern\r\n   * @param memberArray in concern\r\n   * @return boolean to represent the presence\r\n   */\r\n  function _checkMemberInArray(\r\n    address _memberAddress,\r\n    address[] memory memberArray\r\n  )\r\n  internal\r\n  pure\r\n  returns (bool memberExists)\r\n  {\r\n    uint i;\r\n    for (i = 0; i < memberArray.length; i++) {\r\n      if (memberArray[i] == _memberAddress) {\r\n        memberExists = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev to add initial member roles\r\n   * @param _firstAB is the member address to be added\r\n   * @param memberAuthority is the member authority(role) to be added for\r\n   */\r\n  function _addInitialMemberRoles(address _firstAB, address memberAuthority) internal {\r\n    maxABCount = 5;\r\n    _addRole(\"Unassigned\", \"Unassigned\", address(0));\r\n    _addRole(\r\n      \"Advisory Board\",\r\n      \"Selected few members that are deeply entrusted by the dApp. An ideal advisory board should be a mix of skills of domain, governance, research, technology, consulting etc to improve the performance of the dApp.\", //solhint-disable-line\r\n      address(0)\r\n    );\r\n    _addRole(\r\n      \"Member\",\r\n      \"Represents all users of Mutual.\", //solhint-disable-line\r\n      memberAuthority\r\n    );\r\n    _addRole(\r\n      \"Owner\",\r\n      \"Represents Owner of Mutual.\", //solhint-disable-line\r\n      address(0)\r\n    );\r\n    // _updateRole(_firstAB, uint(Role.AdvisoryBoard), true);\r\n    _updateRole(_firstAB, uint(Role.Owner), true);\r\n    // _updateRole(_firstAB, uint(Role.Member), true);\r\n    launchedOn = 0;\r\n  }\r\n\r\n  function memberAtIndex(uint _memberRoleId, uint index) external view returns (address, bool) {\r\n    address memberAddress = memberRoleData[_memberRoleId].memberAddress[index];\r\n    return (memberAddress, memberRoleData[_memberRoleId].memberActive[memberAddress]);\r\n  }\r\n\r\n  function membersLength(uint _memberRoleId) external view returns (uint) {\r\n    return memberRoleData[_memberRoleId].memberAddress.length;\r\n  }\r\n}\r\n\r\n// File: contracts/modules/oracles/PriceFeedOracle.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract Aggregator {\r\n  function latestAnswer() public view returns (int);\r\n}\r\n\r\ncontract PriceFeedOracle {\r\n  using SafeMath for uint;\r\n\r\n  mapping (address => address) public aggregators;\r\n  address public daiAddress;\r\n  address constant public ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n  constructor (address[] memory assets, address[] memory _aggregators, address _daiAddress) public {\r\n    require(assets.length == _aggregators.length, \"PriceFeedOracle: assets and _aggregators need to have same length\");\r\n    for (uint i = 0; i < assets.length; i++) {\r\n      aggregators[assets[i]] = _aggregators[i];\r\n    }\r\n    daiAddress = _daiAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the amount of ether in wei that are equivalent to 1 unit (10 ** decimals) of asset\r\n   * @param asset quoted currency\r\n   * @return price in ether\r\n   */\r\n  function getAssetToEthRate(address asset) public view returns (uint) {\r\n\r\n    if (asset == ETH) {\r\n      return 1 ether;\r\n    }\r\n\r\n    address aggregatorAddress = aggregators[asset];\r\n\r\n    if (aggregatorAddress == address(0)) {\r\n      revert(\"PriceFeedOracle: Oracle asset not found\");\r\n    }\r\n\r\n    int rate = Aggregator(aggregatorAddress).latestAnswer();\r\n    require(rate > 0, \"PriceFeedOracle: Rate must be > 0\");\r\n\r\n    return uint(rate);\r\n  }\r\n\r\n  /**\r\n  * @dev Returns the amount of currency that is equivalent to ethIn amount of ether.\r\n  * @param asset quoted  Supported values: [\"DAI\", \"ETH\"]\r\n  * @param ethIn amount of ether to be converted to the currency\r\n  * @return price in ether\r\n  */\r\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint) {\r\n\r\n    if (asset == daiAddress) {\r\n      return ethIn.mul(1e18).div(getAssetToEthRate(daiAddress));\r\n    }\r\n\r\n    if (asset == ETH) {\r\n      return ethIn;\r\n    }\r\n\r\n    revert(\"PriceFeedOracle: Unknown asset\");\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/modules/capital/PoolData.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract DSValue {\r\n  function peek() public view returns (bytes32, bool);\r\n\r\n  function read() public view returns (bytes32);\r\n}\r\n\r\ncontract PoolData is Iupgradable {\r\n  using SafeMath for uint;\r\n\r\n  struct ApiId {\r\n    bytes4 typeOf;\r\n    bytes4 currency;\r\n    uint id;\r\n    uint64 dateAdd;\r\n    uint64 dateUpd;\r\n  }\r\n\r\n  struct CurrencyAssets {\r\n    address currAddress;\r\n    uint baseMin;\r\n    uint varMin;\r\n  }\r\n\r\n  struct InvestmentAssets {\r\n    address currAddress;\r\n    bool status;\r\n    uint64 minHoldingPercX100;\r\n    uint64 maxHoldingPercX100;\r\n    uint8 decimals;\r\n  }\r\n\r\n  struct IARankDetails {\r\n    bytes4 maxIACurr;\r\n    uint64 maxRate;\r\n    bytes4 minIACurr;\r\n    uint64 minRate;\r\n  }\r\n\r\n  struct McrData {\r\n    uint mcrPercx100;\r\n    uint mcrEther;\r\n    uint vFull; //Pool funds\r\n    uint64 date;\r\n  }\r\n\r\n  IARankDetails[] internal allIARankDetails;\r\n  McrData[] public allMCRData;\r\n\r\n  bytes4[] internal allInvestmentCurrencies;\r\n  bytes4[] internal allCurrencies;\r\n  bytes32[] public allAPIcall;\r\n  mapping(bytes32 => ApiId) public allAPIid;\r\n  mapping(uint64 => uint) internal datewiseId;\r\n  mapping(bytes16 => uint) internal currencyLastIndex;\r\n  mapping(bytes4 => CurrencyAssets) internal allCurrencyAssets;\r\n  mapping(bytes4 => InvestmentAssets) internal allInvestmentAssets;\r\n  mapping(bytes4 => uint) internal caAvgRate;\r\n  mapping(bytes4 => uint) internal iaAvgRate;\r\n\r\n  address public notariseMCR;\r\n  address public daiFeedAddress;\r\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\r\n  uint public uniswapDeadline;\r\n  uint public liquidityTradeCallbackTime;\r\n  uint public lastLiquidityTradeTrigger;\r\n  uint64 internal lastDate;\r\n  uint public variationPercX100;\r\n  uint public iaRatesTime;\r\n  uint public minCap;\r\n  uint public mcrTime;\r\n  uint public a;\r\n  uint public shockParameter;\r\n  uint public c;\r\n  uint public mcrFailTime;\r\n  uint public ethVolumeLimit;\r\n  uint public capReached;\r\n  uint public capacityLimit;\r\n\r\n  constructor(address _notariseAdd, address _daiFeedAdd, address _daiAdd) public {\r\n    notariseMCR = _notariseAdd;\r\n    daiFeedAddress = _daiFeedAdd;\r\n    c = 5800000;\r\n    a = 1028;\r\n    mcrTime = 24 hours;\r\n    mcrFailTime = 6 hours;\r\n    allMCRData.push(McrData(0, 0, 0, 0));\r\n    minCap = 12000 * DECIMAL1E18;\r\n    shockParameter = 50;\r\n    variationPercX100 = 100; // 1%\r\n    iaRatesTime = 24 hours; // 24 hours in seconds\r\n    uniswapDeadline = 20 minutes;\r\n    liquidityTradeCallbackTime = 4 hours;\r\n    ethVolumeLimit = 4;\r\n    capacityLimit = 10;\r\n    allCurrencies.push(\"ETH\");\r\n    allCurrencyAssets[\"ETH\"] = CurrencyAssets(address(0), 1000 * DECIMAL1E18, 0);\r\n    allCurrencies.push(\"DAI\");\r\n    allCurrencyAssets[\"DAI\"] = CurrencyAssets(_daiAdd, 50000 * DECIMAL1E18, 0);\r\n    allInvestmentCurrencies.push(\"ETH\");\r\n    allInvestmentAssets[\"ETH\"] = InvestmentAssets(address(0), true, 2500, 10000, 18);\r\n    allInvestmentCurrencies.push(\"DAI\");\r\n    allInvestmentAssets[\"DAI\"] = InvestmentAssets(_daiAdd, true, 250, 1500, 18);\r\n  }\r\n\r\n  /**\r\n   * @dev to set the maximum cap allowed\r\n   * @param val is the new value\r\n   */\r\n  function setCapReached(uint val) external onlyInternal {\r\n    capReached = val;\r\n  }\r\n\r\n  /// @dev Updates the 3 day average rate of a IA currency.\r\n  /// To be replaced by MakerDao's on chain rates\r\n  /// @param curr IA Currency Name.\r\n  /// @param rate Average exchange rate X 100 (of last 3 days).\r\n  function updateIAAvgRate(bytes4 curr, uint rate) external onlyInternal {\r\n    iaAvgRate[curr] = rate;\r\n  }\r\n\r\n  /// @dev Updates the 3 day average rate of a CA currency.\r\n  /// To be replaced by MakerDao's on chain rates\r\n  /// @param curr Currency Name.\r\n  /// @param rate Average exchange rate X 100 (of last 3 days).\r\n  function updateCAAvgRate(bytes4 curr, uint rate) external onlyInternal {\r\n    caAvgRate[curr] = rate;\r\n  }\r\n\r\n  /// @dev Adds details of (Minimum Capital Requirement)MCR.\r\n  /// @param mcrp Minimum Capital Requirement percentage (MCR% * 100 ,Ex:for 54.56% ,given 5456)\r\n  /// @param vf Pool fund value in Ether used in the last full daily calculation from the Capital model.\r\n  function pushMCRData(uint mcrp, uint mcre, uint vf, uint64 time) external onlyInternal {\r\n    allMCRData.push(McrData(mcrp, mcre, vf, time));\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the Timestamp at which result of oracalize call is received.\r\n   */\r\n  function updateDateUpdOfAPI(bytes32 myid) external onlyInternal {\r\n    allAPIid[myid].dateUpd = uint64(now);\r\n  }\r\n\r\n  /**\r\n   * @dev Saves the details of the Oraclize API.\r\n   * @param myid Id return by the oraclize query.\r\n   * @param _typeof type of the query for which oraclize call is made.\r\n   * @param id ID of the proposal,quote,cover etc. for which oraclize call is made\r\n   */\r\n  function saveApiDetails(bytes32 myid, bytes4 _typeof, uint id) external onlyInternal {\r\n    allAPIid[myid] = ApiId(_typeof, \"\", id, uint64(now), uint64(now));\r\n  }\r\n\r\n  /**\r\n   * @dev Stores the id return by the oraclize query.\r\n   * Maintains record of all the Ids return by oraclize query.\r\n   * @param myid Id return by the oraclize query.\r\n   */\r\n  function addInAllApiCall(bytes32 myid) external onlyInternal {\r\n    allAPIcall.push(myid);\r\n  }\r\n\r\n  /**\r\n   * @dev Saves investment asset rank details.\r\n   * @param maxIACurr Maximum ranked investment asset currency.\r\n   * @param maxRate Maximum ranked investment asset rate.\r\n   * @param minIACurr Minimum ranked investment asset currency.\r\n   * @param minRate Minimum ranked investment asset rate.\r\n   * @param date in yyyymmdd.\r\n   */\r\n  function saveIARankDetails(\r\n    bytes4 maxIACurr,\r\n    uint64 maxRate,\r\n    bytes4 minIACurr,\r\n    uint64 minRate,\r\n    uint64 date\r\n  )\r\n  external\r\n  onlyInternal\r\n  {\r\n    allIARankDetails.push(IARankDetails(maxIACurr, maxRate, minIACurr, minRate));\r\n    datewiseId[date] = allIARankDetails.length.sub(1);\r\n  }\r\n\r\n  /**\r\n   * @dev to get the time for the laste liquidity trade trigger\r\n   */\r\n  function setLastLiquidityTradeTrigger() external onlyInternal {\r\n    lastLiquidityTradeTrigger = now;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates Last Date.\r\n   */\r\n  function updatelastDate(uint64 newDate) external onlyInternal {\r\n    lastDate = newDate;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds currency asset currency.\r\n   * @param curr currency of the asset\r\n   * @param currAddress address of the currency\r\n   * @param baseMin base minimum in 10^18.\r\n   */\r\n  function addCurrencyAssetCurrency(\r\n    bytes4 curr,\r\n    address currAddress,\r\n    uint baseMin\r\n  )\r\n  external\r\n  {\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    allCurrencies.push(curr);\r\n    allCurrencyAssets[curr] = CurrencyAssets(currAddress, baseMin, 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Adds investment asset.\r\n   */\r\n  function addInvestmentAssetCurrency(\r\n    bytes4 curr,\r\n    address currAddress,\r\n    bool status,\r\n    uint64 minHoldingPercX100,\r\n    uint64 maxHoldingPercX100,\r\n    uint8 decimals\r\n  )\r\n  external\r\n  {\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    allInvestmentCurrencies.push(curr);\r\n    allInvestmentAssets[curr] = InvestmentAssets(currAddress, status,\r\n      minHoldingPercX100, maxHoldingPercX100, decimals);\r\n  }\r\n\r\n  /**\r\n   * @dev Changes base minimum of a given currency asset.\r\n   */\r\n  function changeCurrencyAssetBaseMin(bytes4 curr, uint baseMin) external {\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    allCurrencyAssets[curr].baseMin = baseMin;\r\n  }\r\n\r\n  /**\r\n   * @dev changes variable minimum of a given currency asset.\r\n   */\r\n  function changeCurrencyAssetVarMin(bytes4 curr, uint varMin) external onlyInternal {\r\n    allCurrencyAssets[curr].varMin = varMin;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the investment asset status.\r\n   */\r\n  function changeInvestmentAssetStatus(bytes4 curr, bool status) external {\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    allInvestmentAssets[curr].status = status;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the investment asset Holding percentage of a given currency.\r\n   */\r\n  function changeInvestmentAssetHoldingPerc(\r\n    bytes4 curr,\r\n    uint64 minPercX100,\r\n    uint64 maxPercX100\r\n  )\r\n  external\r\n  {\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    allInvestmentAssets[curr].minHoldingPercX100 = minPercX100;\r\n    allInvestmentAssets[curr].maxHoldingPercX100 = maxPercX100;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Currency asset token address.\r\n   */\r\n  function changeCurrencyAssetAddress(bytes4 curr, address currAdd) external {\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    allCurrencyAssets[curr].currAddress = currAdd;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes Investment asset token address.\r\n   */\r\n  function changeInvestmentAssetAddressAndDecimal(\r\n    bytes4 curr,\r\n    address currAdd,\r\n    uint8 newDecimal\r\n  )\r\n  external\r\n  {\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    allInvestmentAssets[curr].currAddress = currAdd;\r\n    allInvestmentAssets[curr].decimals = newDecimal;\r\n  }\r\n\r\n  /// @dev Changes address allowed to post MCR.\r\n  function changeNotariseAddress(address _add) external onlyInternal {\r\n    notariseMCR = _add;\r\n  }\r\n\r\n  /// @dev updates daiFeedAddress address.\r\n  /// @param _add address of DAI feed.\r\n  function changeDAIfeedAddress(address _add) external onlyInternal {\r\n    daiFeedAddress = _add;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Uint Parameters of a code\r\n   * @param code whose details we want\r\n   * @return string value of the code\r\n   * @return associated amount (time or perc or value) to the code\r\n   */\r\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\r\n    codeVal = code;\r\n    if (code == \"MCRTIM\") {\r\n      val = mcrTime / (1 hours);\r\n\r\n    } else if (code == \"MCRFTIM\") {\r\n\r\n      val = mcrFailTime / (1 hours);\r\n\r\n    } else if (code == \"MCRMIN\") {\r\n\r\n      val = minCap;\r\n\r\n    } else if (code == \"MCRSHOCK\") {\r\n\r\n      val = shockParameter;\r\n\r\n    } else if (code == \"MCRCAPL\") {\r\n\r\n      val = capacityLimit;\r\n\r\n    } else if (code == \"IMZ\") {\r\n\r\n      val = variationPercX100;\r\n\r\n    } else if (code == \"IMRATET\") {\r\n\r\n      val = iaRatesTime / (1 hours);\r\n\r\n    } else if (code == \"IMUNIDL\") {\r\n\r\n      val = uniswapDeadline / (1 minutes);\r\n\r\n    } else if (code == \"IMLIQT\") {\r\n\r\n      val = liquidityTradeCallbackTime / (1 hours);\r\n\r\n    } else if (code == \"IMETHVL\") {\r\n\r\n      val = ethVolumeLimit;\r\n\r\n    } else if (code == \"C\") {\r\n      val = c;\r\n\r\n    } else if (code == \"A\") {\r\n\r\n      val = a;\r\n\r\n    }\r\n\r\n  }\r\n\r\n  /// @dev Checks whether a given address can notaise MCR data or not.\r\n  /// @param _add Address.\r\n  /// @return res Returns 0 if address is not authorized, else 1.\r\n  function isnotarise(address _add) external view returns (bool res) {\r\n    res = false;\r\n    if (_add == notariseMCR)\r\n      res = true;\r\n  }\r\n\r\n  /// @dev Gets the details of last added MCR.\r\n  /// @return mcrPercx100 Total Minimum Capital Requirement percentage of that month of year(multiplied by 100).\r\n  /// @return vFull Total Pool fund value in Ether used in the last full daily calculation.\r\n  function getLastMCR() external view returns (uint mcrPercx100, uint mcrEtherx1E18, uint vFull, uint64 date) {\r\n    uint index = allMCRData.length.sub(1);\r\n    return (\r\n    allMCRData[index].mcrPercx100,\r\n    allMCRData[index].mcrEther,\r\n    allMCRData[index].vFull,\r\n    allMCRData[index].date\r\n    );\r\n  }\r\n\r\n  /// @dev Gets last Minimum Capital Requirement percentage of Capital Model\r\n  /// @return val MCR% value,multiplied by 100.\r\n  function getLastMCRPerc() external view returns (uint) {\r\n    return allMCRData[allMCRData.length.sub(1)].mcrPercx100;\r\n  }\r\n\r\n  /// @dev Gets last Ether price of Capital Model\r\n  /// @return val ether value,multiplied by 100.\r\n  function getLastMCREther() external view returns (uint) {\r\n    return allMCRData[allMCRData.length.sub(1)].mcrEther;\r\n  }\r\n\r\n  /// @dev Gets Pool fund value in Ether used in the last full daily calculation from the Capital model.\r\n  function getLastVfull() external view returns (uint) {\r\n    return allMCRData[allMCRData.length.sub(1)].vFull;\r\n  }\r\n\r\n  /// @dev Gets last Minimum Capital Requirement in Ether.\r\n  /// @return date of MCR.\r\n  function getLastMCRDate() external view returns (uint64 date) {\r\n    date = allMCRData[allMCRData.length.sub(1)].date;\r\n  }\r\n\r\n  /// @dev Gets details for token price calculation.\r\n  function getTokenPriceDetails(bytes4 curr) external view returns (uint _a, uint _c, uint rate) {\r\n    _a = a;\r\n    _c = c;\r\n    rate = _getAvgRate(curr, false);\r\n  }\r\n\r\n  /// @dev Gets the total number of times MCR calculation has been made.\r\n  function getMCRDataLength() external view returns (uint len) {\r\n    len = allMCRData.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets investment asset rank details by given date.\r\n   */\r\n  function getIARankDetailsByDate(\r\n    uint64 date\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    bytes4 maxIACurr,\r\n    uint64 maxRate,\r\n    bytes4 minIACurr,\r\n    uint64 minRate\r\n  )\r\n  {\r\n    uint index = datewiseId[date];\r\n    return (\r\n    allIARankDetails[index].maxIACurr,\r\n    allIARankDetails[index].maxRate,\r\n    allIARankDetails[index].minIACurr,\r\n    allIARankDetails[index].minRate\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Last Date.\r\n   */\r\n  function getLastDate() external view returns (uint64 date) {\r\n    return lastDate;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets investment currency for a given index.\r\n   */\r\n  function getInvestmentCurrencyByIndex(uint index) external view returns (bytes4 currName) {\r\n    return allInvestmentCurrencies[index];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets count of investment currency.\r\n   */\r\n  function getInvestmentCurrencyLen() external view returns (uint len) {\r\n    return allInvestmentCurrencies.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets all the investment currencies.\r\n   */\r\n  function getAllInvestmentCurrencies() external view returns (bytes4[] memory currencies) {\r\n    return allInvestmentCurrencies;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets All currency for a given index.\r\n   */\r\n  function getCurrenciesByIndex(uint index) external view returns (bytes4 currName) {\r\n    return allCurrencies[index];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets count of All currency.\r\n   */\r\n  function getAllCurrenciesLen() external view returns (uint len) {\r\n    return allCurrencies.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets all currencies\r\n   */\r\n  function getAllCurrencies() external view returns (bytes4[] memory currencies) {\r\n    return allCurrencies;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets currency asset details for a given currency.\r\n   */\r\n  function getCurrencyAssetVarBase(\r\n    bytes4 curr\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    bytes4 currency,\r\n    uint baseMin,\r\n    uint varMin\r\n  )\r\n  {\r\n    return (\r\n    curr,\r\n    allCurrencyAssets[curr].baseMin,\r\n    allCurrencyAssets[curr].varMin\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets minimum variable value for currency asset.\r\n   */\r\n  function getCurrencyAssetVarMin(bytes4 curr) external view returns (uint varMin) {\r\n    return allCurrencyAssets[curr].varMin;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets base minimum of  a given currency asset.\r\n   */\r\n  function getCurrencyAssetBaseMin(bytes4 curr) external view returns (uint baseMin) {\r\n    return allCurrencyAssets[curr].baseMin;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets investment asset maximum and minimum holding percentage of a given currency.\r\n   */\r\n  function getInvestmentAssetHoldingPerc(\r\n    bytes4 curr\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    uint64 minHoldingPercX100,\r\n    uint64 maxHoldingPercX100\r\n  )\r\n  {\r\n    return (\r\n    allInvestmentAssets[curr].minHoldingPercX100,\r\n    allInvestmentAssets[curr].maxHoldingPercX100\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets investment asset decimals.\r\n   */\r\n  function getInvestmentAssetDecimals(bytes4 curr) external view returns (uint8 decimal) {\r\n    return allInvestmentAssets[curr].decimals;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets investment asset maximum holding percentage of a given currency.\r\n   */\r\n  function getInvestmentAssetMaxHoldingPerc(bytes4 curr) external view returns (uint64 maxHoldingPercX100) {\r\n    return allInvestmentAssets[curr].maxHoldingPercX100;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets investment asset minimum holding percentage of a given currency.\r\n   */\r\n  function getInvestmentAssetMinHoldingPerc(bytes4 curr) external view returns (uint64 minHoldingPercX100) {\r\n    return allInvestmentAssets[curr].minHoldingPercX100;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets investment asset details of a given currency\r\n   */\r\n  function getInvestmentAssetDetails(\r\n    bytes4 curr\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    bytes4 currency,\r\n    address currAddress,\r\n    bool status,\r\n    uint64 minHoldingPerc,\r\n    uint64 maxHoldingPerc,\r\n    uint8 decimals\r\n  )\r\n  {\r\n    return (\r\n    curr,\r\n    allInvestmentAssets[curr].currAddress,\r\n    allInvestmentAssets[curr].status,\r\n    allInvestmentAssets[curr].minHoldingPercX100,\r\n    allInvestmentAssets[curr].maxHoldingPercX100,\r\n    allInvestmentAssets[curr].decimals\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Currency asset token address.\r\n   */\r\n  function getCurrencyAssetAddress(bytes4 curr) external view returns (address) {\r\n    return allCurrencyAssets[curr].currAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets investment asset token address.\r\n   */\r\n  function getInvestmentAssetAddress(bytes4 curr) external view returns (address) {\r\n    return allInvestmentAssets[curr].currAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets investment asset active Status of a given currency.\r\n   */\r\n  function getInvestmentAssetStatus(bytes4 curr) external view returns (bool status) {\r\n    return allInvestmentAssets[curr].status;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets type of oraclize query for a given Oraclize Query ID.\r\n   * @param myid Oraclize Query ID identifying the query for which the result is being received.\r\n   * @return _typeof It could be of type \"quote\",\"quotation\",\"cover\",\"claim\" etc.\r\n   */\r\n  function getApiIdTypeOf(bytes32 myid) external view returns (bytes4) {\r\n    return allAPIid[myid].typeOf;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets ID associated to oraclize query for a given Oraclize Query ID.\r\n   * @param myid Oraclize Query ID identifying the query for which the result is being received.\r\n   * @return id1 It could be the ID of \"proposal\",\"quotation\",\"cover\",\"claim\" etc.\r\n   */\r\n  function getIdOfApiId(bytes32 myid) external view returns (uint) {\r\n    return allAPIid[myid].id;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the Timestamp of a oracalize call.\r\n   */\r\n  function getDateAddOfAPI(bytes32 myid) external view returns (uint64) {\r\n    return allAPIid[myid].dateAdd;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the Timestamp at which result of oracalize call is received.\r\n   */\r\n  function getDateUpdOfAPI(bytes32 myid) external view returns (uint64) {\r\n    return allAPIid[myid].dateUpd;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets currency by oracalize id.\r\n   */\r\n  function getCurrOfApiId(bytes32 myid) external view returns (bytes4) {\r\n    return allAPIid[myid].currency;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets ID return by the oraclize query of a given index.\r\n   * @param index Index.\r\n   * @return myid ID return by the oraclize query.\r\n   */\r\n  function getApiCallIndex(uint index) external view returns (bytes32 myid) {\r\n    myid = allAPIcall[index];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Length of API call.\r\n   */\r\n  function getApilCallLength() external view returns (uint) {\r\n    return allAPIcall.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Get Details of Oraclize API when given Oraclize Id.\r\n   * @param myid ID return by the oraclize query.\r\n   * @return _typeof ype of the query for which oraclize\r\n   * call is made.(\"proposal\",\"quote\",\"quotation\" etc.)\r\n   */\r\n  function getApiCallDetails(\r\n    bytes32 myid\r\n  )\r\n  external\r\n  view\r\n  returns (\r\n    bytes4 _typeof,\r\n    bytes4 curr,\r\n    uint id,\r\n    uint64 dateAdd,\r\n    uint64 dateUpd\r\n  )\r\n  {\r\n    return (\r\n    allAPIid[myid].typeOf,\r\n    allAPIid[myid].currency,\r\n    allAPIid[myid].id,\r\n    allAPIid[myid].dateAdd,\r\n    allAPIid[myid].dateUpd\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Updates Uint Parameters of a code\r\n   * @param code whose details we want to update\r\n   * @param val value to set\r\n   */\r\n  function updateUintParameters(bytes8 code, uint val) public {\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    if (code == \"MCRTIM\") {\r\n      _changeMCRTime(val * 1 hours);\r\n\r\n    } else if (code == \"MCRFTIM\") {\r\n\r\n      _changeMCRFailTime(val * 1 hours);\r\n\r\n    } else if (code == \"MCRMIN\") {\r\n\r\n      _changeMinCap(val);\r\n\r\n    } else if (code == \"MCRSHOCK\") {\r\n\r\n      _changeShockParameter(val);\r\n\r\n    } else if (code == \"MCRCAPL\") {\r\n\r\n      _changeCapacityLimit(val);\r\n\r\n    } else if (code == \"IMZ\") {\r\n\r\n      _changeVariationPercX100(val);\r\n\r\n    } else if (code == \"IMRATET\") {\r\n\r\n      _changeIARatesTime(val * 1 hours);\r\n\r\n    } else if (code == \"IMUNIDL\") {\r\n\r\n      _changeUniswapDeadlineTime(val * 1 minutes);\r\n\r\n    } else if (code == \"IMLIQT\") {\r\n\r\n      _changeliquidityTradeCallbackTime(val * 1 hours);\r\n\r\n    } else if (code == \"IMETHVL\") {\r\n\r\n      _setEthVolumeLimit(val);\r\n\r\n    } else if (code == \"C\") {\r\n      _changeC(val);\r\n\r\n    } else if (code == \"A\") {\r\n\r\n      _changeA(val);\r\n\r\n    } else {\r\n      revert(\"Invalid param code\");\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev to get the average rate of currency rate\r\n   * @param curr is the currency in concern\r\n   * @return required rate\r\n   */\r\n  function getCAAvgRate(bytes4 curr) public view returns (uint rate) {\r\n    return _getAvgRate(curr, false);\r\n  }\r\n\r\n  /**\r\n   * @dev to get the average rate of investment rate\r\n   * @param curr is the investment in concern\r\n   * @return required rate\r\n   */\r\n  function getIAAvgRate(bytes4 curr) public view returns (uint rate) {\r\n    return _getAvgRate(curr, true);\r\n  }\r\n\r\n  function changeDependentContractAddress() public onlyInternal {}\r\n\r\n  /// @dev Gets the average rate of a CA currency.\r\n  /// @param curr Currency Name.\r\n  /// @return rate Average rate X 100(of last 3 days).\r\n  function _getAvgRate(bytes4 curr, bool isIA) internal view returns (uint rate) {\r\n    if (curr == \"DAI\") {\r\n      DSValue ds = DSValue(daiFeedAddress);\r\n      rate = uint(ds.read()).div(uint(10) ** 16);\r\n    } else if (isIA) {\r\n      rate = iaAvgRate[curr];\r\n    } else {\r\n      rate = caAvgRate[curr];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev to set the ethereum volume limit\r\n   * @param val is the new limit value\r\n   */\r\n  function _setEthVolumeLimit(uint val) internal {\r\n    ethVolumeLimit = val;\r\n  }\r\n\r\n  /// @dev Sets minimum Cap.\r\n  function _changeMinCap(uint newCap) internal {\r\n    minCap = newCap;\r\n  }\r\n\r\n  /// @dev Sets Shock Parameter.\r\n  function _changeShockParameter(uint newParam) internal {\r\n    shockParameter = newParam;\r\n  }\r\n\r\n  /// @dev Changes time period for obtaining new MCR data from external oracle query.\r\n  function _changeMCRTime(uint _time) internal {\r\n    mcrTime = _time;\r\n  }\r\n\r\n  /// @dev Sets MCR Fail time.\r\n  function _changeMCRFailTime(uint _time) internal {\r\n    mcrFailTime = _time;\r\n  }\r\n\r\n  /**\r\n   * @dev to change the uniswap deadline time\r\n   * @param newDeadline is the value\r\n   */\r\n  function _changeUniswapDeadlineTime(uint newDeadline) internal {\r\n    uniswapDeadline = newDeadline;\r\n  }\r\n\r\n  /**\r\n   * @dev to change the liquidity trade call back time\r\n   * @param newTime is the new value to be set\r\n   */\r\n  function _changeliquidityTradeCallbackTime(uint newTime) internal {\r\n    liquidityTradeCallbackTime = newTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes time after which investment asset rates need to be fed.\r\n   */\r\n  function _changeIARatesTime(uint _newTime) internal {\r\n    iaRatesTime = _newTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the variation range percentage.\r\n   */\r\n  function _changeVariationPercX100(uint newPercX100) internal {\r\n    variationPercX100 = newPercX100;\r\n  }\r\n\r\n  /// @dev Changes Growth Step\r\n  function _changeC(uint newC) internal {\r\n    c = newC;\r\n  }\r\n\r\n  /// @dev Changes scaling factor.\r\n  function _changeA(uint val) internal {\r\n    a = val;\r\n  }\r\n\r\n  /**\r\n   * @dev to change the capacity limit\r\n   * @param val is the new value\r\n   */\r\n  function _changeCapacityLimit(uint val) internal {\r\n    capacityLimit = val;\r\n  }\r\n}\r\n\r\n// File: contracts/modules/capital/MCR.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MCR is Iupgradable {\r\n  using SafeMath for uint;\r\n\r\n  Pool public pool;\r\n  PoolData public pd;\r\n  NXMToken public tk;\r\n  QuotationData public qd;\r\n  MemberRoles public mr;\r\n  TokenData public td;\r\n  ProposalCategory public proposalCategory;\r\n\r\n  uint private constant minCapFactor = uint(10) ** 21;\r\n\r\n  uint public variableMincap;\r\n  uint public dynamicMincapThresholdx100 = 13000;\r\n  uint public dynamicMincapIncrementx100 = 100;\r\n\r\n  event MCREvent(\r\n    uint indexed date,\r\n    uint blockNumber,\r\n    bytes4[] allCurr,\r\n    uint[] allCurrRates,\r\n    uint mcrEtherx100,\r\n    uint mcrPercx100,\r\n    uint vFull\r\n  );\r\n\r\n  constructor (address masterAddress) public {\r\n\r\n    changeMasterAddress(masterAddress);\r\n\r\n    // we'll pass the zero address on the first deploy\r\n    // due to missing previous MCR contract\r\n    if (masterAddress == address(0)) {\r\n      return;\r\n    }\r\n\r\n    address mcrAddress = ms.getLatestAddress(\"MC\");\r\n    MCR previousMCR = MCR(mcrAddress);\r\n\r\n    // fetch MCR parameters from previous contract\r\n    variableMincap = previousMCR.variableMincap();\r\n    dynamicMincapThresholdx100 = previousMCR.dynamicMincapThresholdx100();\r\n    dynamicMincapIncrementx100 = previousMCR.dynamicMincapIncrementx100();\r\n  }\r\n\r\n  /**\r\n   * @dev Adds new MCR data.\r\n   * @param mcrP  Minimum Capital Requirement in percentage.\r\n   * @param vF Pool fund value in Ether used in the last full daily calculation of the Capital model.\r\n   * @param onlyDate  Date(yyyymmdd) at which MCR details are getting added.\r\n   */\r\n  function addMCRData(\r\n    uint mcrP,\r\n    uint mcrE,\r\n    uint vF,\r\n    bytes4[] calldata curr,\r\n    uint[] calldata _threeDayAvg,\r\n    uint64 onlyDate\r\n  )\r\n  external\r\n  checkPause\r\n  {\r\n    require(proposalCategory.constructorCheck());\r\n    require(pd.isnotarise(msg.sender));\r\n    if (mr.launched() && pd.capReached() != 1) {\r\n\r\n      if (mcrP >= 10000)\r\n        pd.setCapReached(1);\r\n\r\n    }\r\n    uint len = pd.getMCRDataLength();\r\n    _addMCRData(len, onlyDate, curr, mcrE, mcrP, vF, _threeDayAvg);\r\n  }\r\n\r\n  // proxying this call through mcr contract to get rid of pd from pool\r\n  function getLastMCREther() external view returns (uint) {\r\n    return pd.getLastMCREther();\r\n  }\r\n\r\n  /**\r\n   * @dev Iupgradable Interface to update dependent contract address\r\n   */\r\n  function changeDependentContractAddress() public {\r\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n    pool = Pool(ms.getLatestAddress(\"P1\"));\r\n    pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n    tk = NXMToken(ms.tokenAddress());\r\n    mr = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n    td = TokenData(ms.getLatestAddress(\"TD\"));\r\n    proposalCategory = ProposalCategory(ms.getLatestAddress(\"PC\"));\r\n  }\r\n\r\n  /**\r\n   * @dev Gets total sum assured (in ETH).\r\n   * @return amount of sum assured\r\n   */\r\n  function getAllSumAssurance() public view returns (uint) {\r\n\r\n    PriceFeedOracle priceFeed = pool.priceFeedOracle();\r\n    address daiAddress = priceFeed.daiAddress();\r\n\r\n    uint ethAmount = qd.getTotalSumAssured(\"ETH\").mul(1e18);\r\n    uint daiAmount = qd.getTotalSumAssured(\"DAI\").mul(1e18);\r\n\r\n    uint daiRate = priceFeed.getAssetToEthRate(daiAddress);\r\n    uint daiAmountInEth = daiAmount.mul(daiRate).div(1e18);\r\n\r\n    return ethAmount.add(daiAmountInEth);\r\n  }\r\n\r\n  function getThresholdValues(uint vtp, uint vF, uint totalSA, uint minCap) public view returns (uint lowerThreshold, uint upperThreshold)\r\n  {\r\n    minCap = (minCap.mul(minCapFactor)).add(variableMincap);\r\n    uint lower = 0;\r\n    if (vtp >= vF) {\r\n      // Max Threshold = [MAX(Vtp, Vfull) x 120] / mcrMinCap\r\n      upperThreshold = vtp.mul(120).mul(100).div((minCap));\r\n    } else {\r\n      upperThreshold = vF.mul(120).mul(100).div((minCap));\r\n    }\r\n\r\n    if (vtp > 0) {\r\n      lower = totalSA.mul(pd.shockParameter()).div(100);\r\n      if (lower < minCap.mul(11).div(10))\r\n        lower = minCap.mul(11).div(10);\r\n    }\r\n    if (lower > 0) {\r\n      // Min Threshold = [Vtp / MAX(TotalActiveSA x ShockParameter, mcrMinCap x 1.1)] x 100\r\n      lowerThreshold = vtp.mul(100).mul(100).div(lower);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Uint Parameters of a code\r\n   * @param code whose details we want\r\n   * @return string value of the code\r\n   * @return associated amount (time or perc or value) to the code\r\n   */\r\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\r\n    codeVal = code;\r\n    if (code == \"DMCT\") {\r\n      val = dynamicMincapThresholdx100;\r\n\r\n    } else if (code == \"DMCI\") {\r\n\r\n      val = dynamicMincapIncrementx100;\r\n\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Updates Uint Parameters of a code\r\n   * @param code whose details we want to update\r\n   * @param val value to set\r\n   */\r\n  function updateUintParameters(bytes8 code, uint val) public {\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    if (code == \"DMCT\") {\r\n      dynamicMincapThresholdx100 = val;\r\n\r\n    } else if (code == \"DMCI\") {\r\n\r\n      dynamicMincapIncrementx100 = val;\r\n\r\n    }\r\n    else {\r\n      revert(\"Invalid param code\");\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Adds MCR Data. Checks if MCR is within valid\r\n   * thresholds in order to rule out any incorrect calculations\r\n   */\r\n  function _addMCRData(\r\n    uint len,\r\n    uint64 newMCRDate,\r\n    bytes4[] memory curr,\r\n    uint mcrE,\r\n    uint mcrP,\r\n    uint vF,\r\n    uint[] memory _threeDayAvg\r\n  )\r\n  internal\r\n  {\r\n    uint lowerThreshold = 0;\r\n    uint upperThreshold = 0;\r\n\r\n    if (len > 1) {\r\n      uint vtp = pool.getPoolValueInEth();\r\n      (lowerThreshold, upperThreshold) = getThresholdValues(vtp, vF, getAllSumAssurance(), pd.minCap());\r\n    }\r\n\r\n    if (mcrP > dynamicMincapThresholdx100) {\r\n      variableMincap = (variableMincap.mul(dynamicMincapIncrementx100.add(10000)).add(minCapFactor.mul(pd.minCap().mul(dynamicMincapIncrementx100)))).div(10000);\r\n    }\r\n\r\n    // Explanation for above formula :-\r\n    // actual formula -> variableMinCap =  variableMinCap + (variableMinCap+minCap)*dynamicMincapIncrement/100\r\n    // Implemented formula is simplified form of actual formula.\r\n    // Let consider above formula as b = b + (a+b)*c/100\r\n    // here, dynamicMincapIncrement is in x100 format.\r\n    // so b+(a+b)*cx100/10000 can be written as => (10000.b + b.cx100 + a.cx100)/10000.\r\n    // It can further simplify to (b.(10000+cx100) + a.cx100)/10000.\r\n    if (len == 1 || (mcrP) >= lowerThreshold && (mcrP) <= upperThreshold) {\r\n\r\n      pd.pushMCRData(mcrP, mcrE, vF, newMCRDate);\r\n\r\n      for (uint i = 0; i < curr.length; i++) {\r\n        pd.updateCAAvgRate(curr[i], _threeDayAvg[i]);\r\n      }\r\n\r\n      emit MCREvent(newMCRDate, block.number, curr, _threeDayAvg, mcrE, mcrP, vF);\r\n      return;\r\n    }\r\n\r\n    revert(\"MCR: Failed\");\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/modules/cover/Quotation.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Quotation is Iupgradable {\r\n  using SafeMath for uint;\r\n\r\n  TokenFunctions public tf;\r\n  TokenController public tc;\r\n  TokenData public td;\r\n  Pool public pool;\r\n  PoolData public pd;\r\n  QuotationData public qd;\r\n  MCR public m1;\r\n  MemberRoles public mr;\r\n  ClaimsReward public cr;\r\n\r\n  bool internal locked;\r\n\r\n  event RefundEvent(address indexed user, bool indexed status, uint holdedCoverID, bytes32 reason);\r\n\r\n  modifier noReentrancy() {\r\n    require(!locked, \"Reentrant call.\");\r\n    locked = true;\r\n    _;\r\n    locked = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Iupgradable Interface to update dependent contract address\r\n   */\r\n  function changeDependentContractAddress() public onlyInternal {\r\n    m1 = MCR(ms.getLatestAddress(\"MC\"));\r\n    tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n    tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n    td = TokenData(ms.getLatestAddress(\"TD\"));\r\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n    pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n    mr = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n    cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\r\n    pool = Pool(ms.getLatestAddress(\"P1\"));\r\n  }\r\n\r\n  function sendEther() public payable {\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Expires a cover after a set period of time.\r\n   * Changes the status of the Cover and reduces the current\r\n   * sum assured of all areas in which the quotation lies\r\n   * Unlocks the CN tokens of the cover. Updates the Total Sum Assured value.\r\n   * @param _cid Cover Id.\r\n   */\r\n  function expireCover(uint _cid) public {\r\n    require(checkCoverExpired(_cid) && qd.getCoverStatusNo(_cid) != uint(QuotationData.CoverStatus.CoverExpired));\r\n\r\n    tf.unlockCN(_cid);\r\n    bytes4 curr;\r\n    address scAddress;\r\n    uint sumAssured;\r\n    (,, scAddress, curr, sumAssured,) = qd.getCoverDetailsByCoverID1(_cid);\r\n    if (qd.getCoverStatusNo(_cid) != uint(QuotationData.CoverStatus.ClaimAccepted))\r\n      _removeSAFromCSA(_cid, sumAssured);\r\n    qd.changeCoverStatusNo(_cid, uint8(QuotationData.CoverStatus.CoverExpired));\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if a cover should get expired/closed or not.\r\n   * @param _cid Cover Index.\r\n   * @return expire true if the Cover's time has expired, false otherwise.\r\n   */\r\n  function checkCoverExpired(uint _cid) public view returns (bool expire) {\r\n\r\n    expire = qd.getValidityOfCover(_cid) < uint64(now);\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the Sum Assured Amount of all the quotation.\r\n   * @param _cid Cover id\r\n   * @param _amount that will get subtracted Current Sum Assured\r\n   * amount that comes under a quotation.\r\n   */\r\n  function removeSAFromCSA(uint _cid, uint _amount) public onlyInternal {\r\n    _removeSAFromCSA(_cid, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Makes Cover funded via NXM tokens.\r\n   * @param smartCAdd Smart Contract Address\r\n   */\r\n  function makeCoverUsingNXMTokens(\r\n    uint[] memory coverDetails,\r\n    uint16 coverPeriod,\r\n    bytes4 coverCurr,\r\n    address smartCAdd,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s\r\n  )\r\n  public\r\n  isMemberAndcheckPause\r\n  {\r\n\r\n    tc.burnFrom(msg.sender, coverDetails[2]); // need burn allowance\r\n    _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s, true);\r\n  }\r\n\r\n  /**\r\n   * @dev Verifies cover details signed off chain.\r\n   * @param from address of funder.\r\n   * @param scAddress Smart Contract Address\r\n   */\r\n  function verifyCoverDetails(\r\n    address payable from,\r\n    address scAddress,\r\n    bytes4 coverCurr,\r\n    uint[] memory coverDetails,\r\n    uint16 coverPeriod,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s\r\n  )\r\n  public\r\n  onlyInternal\r\n  {\r\n    _verifyCoverDetails(\r\n      from,\r\n      scAddress,\r\n      coverCurr,\r\n      coverDetails,\r\n      coverPeriod,\r\n      _v,\r\n      _r,\r\n      _s,\r\n      false\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Verifies signature.\r\n   * @param coverDetails details related to cover.\r\n   * @param coverPeriod validity of cover.\r\n   * @param smaratCA smarat contract address.\r\n   * @param _v argument from vrs hash.\r\n   * @param _r argument from vrs hash.\r\n   * @param _s argument from vrs hash.\r\n   */\r\n  function verifySign(\r\n    uint[] memory coverDetails,\r\n    uint16 coverPeriod,\r\n    bytes4 curr,\r\n    address smaratCA,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s\r\n  )\r\n  public\r\n  view\r\n  returns (bool)\r\n  {\r\n    require(smaratCA != address(0));\r\n    require(pd.capReached() == 1, \"Can not buy cover until cap reached for 1st time\");\r\n    bytes32 hash = getOrderHash(coverDetails, coverPeriod, curr, smaratCA);\r\n    return isValidSignature(hash, _v, _r, _s);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets order hash for given cover details.\r\n   * @param coverDetails details realted to cover.\r\n   * @param coverPeriod validity of cover.\r\n   * @param smaratCA smarat contract address.\r\n   */\r\n  function getOrderHash(\r\n    uint[] memory coverDetails,\r\n    uint16 coverPeriod,\r\n    bytes4 curr,\r\n    address smaratCA\r\n  )\r\n  public\r\n  view\r\n  returns (bytes32)\r\n  {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        coverDetails[0],\r\n        curr, coverPeriod,\r\n        smaratCA,\r\n        coverDetails[1],\r\n        coverDetails[2],\r\n        coverDetails[3],\r\n        coverDetails[4],\r\n        address(this)\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Verifies signature.\r\n   * @param hash order hash\r\n   * @param v argument from vrs hash.\r\n   * @param r argument from vrs hash.\r\n   * @param s argument from vrs hash.\r\n   */\r\n  function isValidSignature(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {\r\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n    bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\r\n    address a = ecrecover(prefixedHash, v, r, s);\r\n    return (a == qd.getAuthQuoteEngine());\r\n  }\r\n\r\n  /**\r\n   * @dev to get the status of recently holded coverID\r\n   * @param userAdd is the user address in concern\r\n   * @return the status of the concerned coverId\r\n   */\r\n  function getRecentHoldedCoverIdStatus(address userAdd) public view returns (int) {\r\n\r\n    uint holdedCoverLen = qd.getUserHoldedCoverLength(userAdd);\r\n    if (holdedCoverLen == 0) {\r\n      return - 1;\r\n    } else {\r\n      uint holdedCoverID = qd.getUserHoldedCoverByIndex(userAdd, holdedCoverLen.sub(1));\r\n      return int(qd.holdedCoverIDStatus(holdedCoverID));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev to get the verdict of kyc process\r\n   * @param status is the kyc status\r\n   * @param _add is the address of member\r\n   */\r\n  function kycVerdict(address _add, bool status) public checkPause noReentrancy {\r\n    require(msg.sender == qd.kycAuthAddress());\r\n    _kycTrigger(status, _add);\r\n  }\r\n\r\n  /**\r\n   * @dev transfering Ethers to newly created quotation contract.\r\n   */\r\n  function transferAssetsToNewContract(address newAdd) public onlyInternal noReentrancy {\r\n    uint amount = address(this).balance;\r\n    IERC20 erc20;\r\n    if (amount > 0) {\r\n      // newAdd.transfer(amount);\r\n      Quotation newQT = Quotation(newAdd);\r\n      newQT.sendEther.value(amount)();\r\n    }\r\n    uint currAssetLen = pd.getAllCurrenciesLen();\r\n    for (uint64 i = 1; i < currAssetLen; i++) {\r\n      bytes4 currName = pd.getCurrenciesByIndex(i);\r\n      address currAddr = pd.getCurrencyAssetAddress(currName);\r\n      erc20 = IERC20(currAddr); // solhint-disable-line\r\n      if (erc20.balanceOf(address(this)) > 0) {\r\n        require(erc20.transfer(newAdd, erc20.balanceOf(address(this))));\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Creates cover of the quotation, changes the status of the quotation ,\r\n   * updates the total sum assured and locks the tokens of the cover against a quote.\r\n   * @param from Quote member Ethereum address.\r\n   */\r\n\r\n  function _makeCover(//solhint-disable-line\r\n    address payable from,\r\n    address scAddress,\r\n    bytes4 coverCurr,\r\n    uint[] memory coverDetails,\r\n    uint16 coverPeriod\r\n  )\r\n  internal\r\n  {\r\n    uint cid = qd.getCoverLength();\r\n\r\n    qd.addCover(\r\n      coverPeriod,\r\n      coverDetails[0],\r\n      from,\r\n      coverCurr,\r\n      scAddress,\r\n      coverDetails[1],\r\n      coverDetails[2]\r\n    );\r\n\r\n    uint coverNoteAmount = (coverDetails[2].mul(qd.tokensRetained())).div(100);\r\n    tc.mint(from, coverNoteAmount);\r\n    tf.lockCN(coverNoteAmount, coverPeriod, cid, from);\r\n    qd.addInTotalSumAssured(coverCurr, coverDetails[0]);\r\n    qd.addInTotalSumAssuredSC(scAddress, coverCurr, coverDetails[0]);\r\n\r\n    tf.pushStakerRewards(scAddress, coverDetails[2]);\r\n  }\r\n\r\n  /**\r\n   * @dev Makes a cover.\r\n   * @param from address of funder.\r\n   * @param scAddress Smart Contract Address\r\n   */\r\n  function _verifyCoverDetails(\r\n    address payable from,\r\n    address scAddress,\r\n    bytes4 coverCurr,\r\n    uint[] memory coverDetails,\r\n    uint16 coverPeriod,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s,\r\n    bool isNXM\r\n  ) internal {\r\n    require(coverDetails[3] > now);\r\n    require(!qd.timestampRepeated(coverDetails[4]));\r\n    qd.setTimestampRepeated(coverDetails[4]);\r\n    require(coverPeriod >= 30 && coverPeriod <= 365, \"Quotation: Cover period out of bounds\");\r\n\r\n    address asset = cr.getCurrencyAssetAddress(coverCurr);\r\n    if (coverCurr != \"ETH\" && !isNXM) {\r\n      pool.transferAssetFrom(asset, from, coverDetails[1]);\r\n    }\r\n\r\n    require(verifySign(coverDetails, coverPeriod, coverCurr, scAddress, _v, _r, _s));\r\n    _makeCover(from, scAddress, coverCurr, coverDetails, coverPeriod);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the Sum Assured Amount of all the quotation.\r\n   * @param _cid Cover id\r\n   * @param _amount that will get subtracted Current Sum Assured\r\n   * amount that comes under a quotation.\r\n   */\r\n  function _removeSAFromCSA(uint _cid, uint _amount) internal checkPause {\r\n    address _add;\r\n    bytes4 coverCurr;\r\n    (,, _add, coverCurr,,) = qd.getCoverDetailsByCoverID1(_cid);\r\n    qd.subFromTotalSumAssured(coverCurr, _amount);\r\n    qd.subFromTotalSumAssuredSC(_add, coverCurr, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev to trigger the kyc process\r\n   * @param status is the kyc status\r\n   * @param _add is the address of member\r\n   */\r\n  function _kycTrigger(bool status, address _add) internal {\r\n\r\n    uint holdedCoverLen = qd.getUserHoldedCoverLength(_add).sub(1);\r\n    uint holdedCoverID = qd.getUserHoldedCoverByIndex(_add, holdedCoverLen);\r\n    address payable userAdd;\r\n    address scAddress;\r\n    bytes4 coverCurr;\r\n    uint16 coverPeriod;\r\n    uint[]  memory coverDetails = new uint[](4);\r\n    IERC20 erc20;\r\n\r\n    (, userAdd, coverDetails) = qd.getHoldedCoverDetailsByID2(holdedCoverID);\r\n    (, scAddress, coverCurr, coverPeriod) = qd.getHoldedCoverDetailsByID1(holdedCoverID);\r\n    require(qd.refundEligible(userAdd));\r\n    qd.setRefundEligible(userAdd, false);\r\n    require(qd.holdedCoverIDStatus(holdedCoverID) == uint(QuotationData.HCIDStatus.kycPending));\r\n    uint joinFee = td.joiningFee();\r\n    if (status) {\r\n      mr.payJoiningFee.value(joinFee)(userAdd);\r\n      if (coverDetails[3] > now) {\r\n        qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycPass));\r\n        if (coverCurr == \"ETH\") {\r\n          (bool ok,) = address(pool).call.value(coverDetails[1])(\"\");\r\n          require(ok, \"Quotation: ether transfer to pool failed\");\r\n        } else {\r\n          erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); // solhint-disable-line\r\n          require(erc20.transfer(address(pool), coverDetails[1]));\r\n        }\r\n        emit RefundEvent(userAdd, status, holdedCoverID, \"KYC Passed\");\r\n        _makeCover(userAdd, scAddress, coverCurr, coverDetails, coverPeriod);\r\n\r\n      } else {\r\n        qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycPassNoCover));\r\n        if (coverCurr == \"ETH\") {\r\n          userAdd.transfer(coverDetails[1]);\r\n        } else {\r\n          erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); // solhint-disable-line\r\n          require(erc20.transfer(userAdd, coverDetails[1]));\r\n        }\r\n        emit RefundEvent(userAdd, status, holdedCoverID, \"Cover Failed\");\r\n      }\r\n    } else {\r\n      qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycFailedOrRefunded));\r\n      uint totalRefund = joinFee;\r\n      if (coverCurr == \"ETH\") {\r\n        totalRefund = coverDetails[1].add(joinFee);\r\n      } else {\r\n        erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); // solhint-disable-line\r\n        require(erc20.transfer(userAdd, coverDetails[1]));\r\n      }\r\n      userAdd.transfer(totalRefund);\r\n      emit RefundEvent(userAdd, status, holdedCoverID, \"KYC Failed\");\r\n    }\r\n\r\n  }\r\n}\r\n\r\n// File: contracts/external/uniswap/IUniswapV2Router01.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface IUniswapV2Router01 {\r\n\r\n  function factory() external pure returns (address);\r\n\r\n  function WETH() external pure returns (address);\r\n\r\n  function addLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint amountADesired,\r\n    uint amountBDesired,\r\n    uint amountAMin,\r\n    uint amountBMin,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n  function addLiquidityETH(\r\n    address token,\r\n    uint amountTokenDesired,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline\r\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n  function removeLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint liquidity,\r\n    uint amountAMin,\r\n    uint amountBMin,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint amountA, uint amountB);\r\n\r\n  function removeLiquidityETH(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint amountToken, uint amountETH);\r\n\r\n  function removeLiquidityWithPermit(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint liquidity,\r\n    uint amountAMin,\r\n    uint amountBMin,\r\n    address to,\r\n    uint deadline,\r\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountA, uint amountB);\r\n\r\n  function removeLiquidityETHWithPermit(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline,\r\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountToken, uint amountETH);\r\n\r\n  function swapExactTokensForTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n\r\n  function swapTokensForExactTokens(\r\n    uint amountOut,\r\n    uint amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n\r\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n  external\r\n  payable\r\n  returns (uint[] memory amounts);\r\n\r\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n  external\r\n  returns (uint[] memory amounts);\r\n\r\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n  external\r\n  returns (uint[] memory amounts);\r\n\r\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n  external\r\n  payable\r\n  returns (uint[] memory amounts);\r\n\r\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\r\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\r\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n// File: contracts/external/uniswap/IUniswapV2Router02.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract IUniswapV2Router02 is IUniswapV2Router01 {\r\n\r\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint amountETH);\r\n\r\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline,\r\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountETH);\r\n\r\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n  ) external;\r\n\r\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n  ) external payable;\r\n\r\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n  ) external;\r\n}\r\n\r\n// File: @uniswap/lib/contracts/libraries/FixedPoint.sol\r\n\r\npragma solidity >=0.4.0;\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // range: [0, 2**144 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq144x112 {\r\n        uint _x;\r\n    }\r\n\r\n    uint8 private constant RESOLUTION = 112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(x) << RESOLUTION);\r\n    }\r\n\r\n    // encodes a uint144 as a UQ144x112\r\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\r\n        return uq144x112(uint256(x) << RESOLUTION);\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\r\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\r\n        return uq112x112(self._x / uint224(x));\r\n    }\r\n\r\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\r\n    // reverts on overflow\r\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\r\n        uint z;\r\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\r\n        return uq144x112(z);\r\n    }\r\n\r\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\r\n    // equivalent to encode(numerator).div(denominator)\r\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\r\n    }\r\n\r\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\r\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\r\n        return uint112(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\r\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\r\n        return uint144(self._x >> RESOLUTION);\r\n    }\r\n}\r\n\r\n// File: @uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\n\r\n\r\n// library with helper methods for oracles that are concerned with computing average prices\r\nlibrary UniswapV2OracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2 ** 32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(\r\n        address pair\r\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\r\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            // subtraction overflow is desired\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n            // addition overflow is desired\r\n            // counterfactual\r\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n            // counterfactual\r\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/modules/oracles/TwapOracle.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract TwapOracle {\r\n  using FixedPoint for *;\r\n\r\n  struct Bucket {\r\n    uint timestamp;\r\n    uint price0Cumulative;\r\n    uint price1Cumulative;\r\n  }\r\n\r\n  event Updated(address indexed pair, uint timestamp, uint price0Cumulative, uint price1Cumulative);\r\n\r\n  uint constant public periodSize = 1800;\r\n  uint constant public periodsPerWindow = 8;\r\n  uint constant public windowSize = periodSize * periodsPerWindow;\r\n\r\n  address public factory;\r\n\r\n  // token pair => Bucket[8]\r\n  mapping(address => Bucket[8]) public buckets;\r\n\r\n  constructor (address _factory) public {\r\n    factory = _factory;\r\n  }\r\n\r\n  /* utils */\r\n\r\n  // https://uniswap.org/docs/v2/smart-contract-integration/getting-pair-addresses/\r\n  function _pairFor(address _factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n\r\n    // sort tokens\r\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n\r\n    require(token0 != token1, \"TWAP: identical addresses\");\r\n    require(token0 != address(0), \"TWAP: zero address\");\r\n\r\n    pair = address(uint(keccak256(abi.encodePacked(\r\n        hex'ff',\r\n        _factory,\r\n        keccak256(abi.encodePacked(token0, token1)),\r\n        hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'\r\n      ))));\r\n  }\r\n\r\n  function timestampToIndex(uint timestamp) internal pure returns (uint index) {\r\n    uint epochPeriod = timestamp / periodSize;\r\n    return epochPeriod % periodsPerWindow;\r\n  }\r\n\r\n  function pairFor(address tokenA, address tokenB) external view returns (address pair) {\r\n    return _pairFor(factory, tokenA, tokenB);\r\n  }\r\n\r\n  function currentBucketIndex() external view returns (uint index) {\r\n    return timestampToIndex(block.timestamp);\r\n  }\r\n\r\n  /* update */\r\n\r\n  function update(address[] calldata pairs) external {\r\n\r\n    for (uint i = 0; i < pairs.length; i++) {\r\n\r\n      // note: not reusing canUpdate() because we need the bucket variable\r\n      address pair = pairs[i];\r\n      uint index = timestampToIndex(block.timestamp);\r\n      Bucket storage bucket = buckets[pair][index];\r\n\r\n      if (block.timestamp - bucket.timestamp < periodSize) {\r\n        continue;\r\n      }\r\n\r\n      (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\r\n      bucket.timestamp = block.timestamp;\r\n      bucket.price0Cumulative = price0Cumulative;\r\n      bucket.price1Cumulative = price1Cumulative;\r\n\r\n      emit Updated(pair, block.timestamp, price0Cumulative, price1Cumulative);\r\n    }\r\n  }\r\n\r\n  function canUpdate(address pair) external view returns (bool) {\r\n\r\n    uint index = timestampToIndex(block.timestamp);\r\n    Bucket storage bucket = buckets[pair][index];\r\n    uint timeElapsed = block.timestamp - bucket.timestamp;\r\n\r\n    return timeElapsed > periodSize;\r\n  }\r\n\r\n  /* consult */\r\n\r\n  function _getCumulativePrices(\r\n    address tokenIn,\r\n    address tokenOut\r\n  ) internal view returns (uint priceCumulativeStart, uint priceCumulativeEnd, uint timeElapsed) {\r\n\r\n    uint currentIndex = timestampToIndex(block.timestamp);\r\n    uint firstBucketIndex = (currentIndex + 1) % periodsPerWindow;\r\n\r\n    address pair = _pairFor(factory, tokenIn, tokenOut);\r\n    Bucket storage firstBucket = buckets[pair][firstBucketIndex];\r\n\r\n    timeElapsed = block.timestamp - firstBucket.timestamp;\r\n    require(timeElapsed <= windowSize, \"TWAP: missing historical reading\");\r\n    require(timeElapsed >= windowSize - periodSize * 2, \"TWAP: unexpected time elapsed\");\r\n\r\n    (uint price0Cumulative, uint price1Cumulative,) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\r\n\r\n    if (tokenIn < tokenOut) {\r\n      return (firstBucket.price0Cumulative, price0Cumulative, timeElapsed);\r\n    }\r\n\r\n    return (firstBucket.price1Cumulative, price1Cumulative, timeElapsed);\r\n  }\r\n\r\n  function _computeAmountOut(\r\n    uint priceCumulativeStart,\r\n    uint priceCumulativeEnd,\r\n    uint timeElapsed,\r\n    uint amountIn\r\n  ) internal pure returns (uint amountOut) {\r\n\r\n    // overflow is desired.\r\n    FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\r\n      uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\r\n    );\r\n\r\n    return priceAverage.mul(amountIn).decode144();\r\n  }\r\n\r\n  /**\r\n   *  @dev Returns the amount out corresponding to the amount in for a given token using the\r\n   *  @dev   moving average over the time range [now - [windowSize, windowSize - periodSize * 2], now]\r\n   *  @dev   update must have been called for the bucket corresponding to timestamp `now - windowSize`\r\n   */\r\n  function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\r\n\r\n    uint pastPriceCumulative;\r\n    uint currentPriceCumulative;\r\n    uint timeElapsed;\r\n\r\n    (pastPriceCumulative, currentPriceCumulative, timeElapsed) = _getCumulativePrices(tokenIn, tokenOut);\r\n\r\n    return _computeAmountOut(\r\n      pastPriceCumulative,\r\n      currentPriceCumulative,\r\n      timeElapsed,\r\n      amountIn\r\n    );\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/modules/capital/SwapAgent.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\nlibrary SwapAgent {\r\n  using SafeMath for uint;\r\n\r\n  struct AssetData {\r\n    uint112 minAmount;\r\n    uint112 maxAmount;\r\n    uint32 lastSwapTime;\r\n    // 18 decimals of precision. 0.01% -> 0.0001 -> 1e14\r\n    uint maxSlippageRatio;\r\n  }\r\n\r\n  IUniswapV2Router02 constant public router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n  uint constant public MAX_LIQUIDITY_RATIO = 3 * 1e15;\r\n\r\n  function getSwapQuote(\r\n    uint tokenAmountIn,\r\n    IERC20 fromToken,\r\n    IERC20 toToken\r\n  ) public view returns (uint tokenAmountOut) {\r\n\r\n    address[] memory path = new address[](2);\r\n    path[0] = address(fromToken);\r\n    path[1] = address(toToken);\r\n    uint[] memory amountsOut = router.getAmountsOut(tokenAmountIn, path);\r\n\r\n    return amountsOut[1];\r\n  }\r\n\r\n  function swapETHForAsset(\r\n    address _oracle,\r\n    AssetData storage assetData,\r\n    address toTokenAddress,\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    uint minLeftETH\r\n  ) external returns (uint) {\r\n\r\n    uint balanceBefore = IERC20(toTokenAddress).balanceOf(address(this));\r\n    address WETH = router.WETH();\r\n\r\n    {\r\n      // scope for swap frequency check\r\n      uint timeSinceLastTrade = block.timestamp.sub(uint(assetData.lastSwapTime));\r\n      require(timeSinceLastTrade > TwapOracle(_oracle).periodSize(), \"SwapAgent: too fast\");\r\n    }\r\n\r\n    {\r\n      // scope for liquidity check\r\n      address pairAddress = TwapOracle(_oracle).pairFor(WETH, toTokenAddress);\r\n      IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\r\n      (uint112 reserve0, uint112 reserve1, /* time */) = pair.getReserves();\r\n\r\n      uint ethReserve = WETH < toTokenAddress ? reserve0 : reserve1;\r\n      uint maxTradable = ethReserve.mul(MAX_LIQUIDITY_RATIO).div(1e18);\r\n\r\n      require(amountIn <= maxTradable, \"SwapAgent: exceeds max tradable amount\");\r\n    }\r\n\r\n    {\r\n      // scope for ether checks\r\n      uint ethBalanceBefore = address(this).balance;\r\n      uint ethBalanceAfter = ethBalanceBefore.sub(amountIn);\r\n      require(ethBalanceAfter >= minLeftETH, \"SwapAgent: insufficient ether left\");\r\n    }\r\n\r\n    {\r\n      // scope for token checks\r\n      uint avgAmountOut = TwapOracle(_oracle).consult(WETH, amountIn, toTokenAddress);\r\n      uint maxSlippageAmount = avgAmountOut.mul(assetData.maxSlippageRatio).div(1e18);\r\n      uint minOutOnMaxSlippage = avgAmountOut.sub(maxSlippageAmount);\r\n\r\n      // gas optimisation: reads both values using a single SLOAD\r\n      (uint minAssetAmount, uint maxAssetAmount) = (assetData.minAmount, assetData.maxAmount);\r\n\r\n      require(amountOutMin >= minOutOnMaxSlippage, \"SwapAgent: amountOutMin < minOutOnMaxSlippage\");\r\n      require(balanceBefore < minAssetAmount, \"SwapAgent: balanceBefore >= min\");\r\n      require(balanceBefore.add(amountOutMin) <= maxAssetAmount, \"SwapAgent: balanceAfter > max\");\r\n    }\r\n\r\n    address[] memory path = new address[](2);\r\n    path[0] = WETH;\r\n    path[1] = toTokenAddress;\r\n    router.swapExactETHForTokens.value(amountIn)(amountOutMin, path, address(this), block.timestamp);\r\n\r\n    assetData.lastSwapTime = uint32(block.timestamp);\r\n\r\n    uint balanceAfter = IERC20(toTokenAddress).balanceOf(address(this));\r\n    uint amountOut = balanceAfter.sub(balanceBefore);\r\n\r\n    return amountOut;\r\n  }\r\n\r\n  function swapAssetForETH(\r\n    address _oracle,\r\n    AssetData storage assetData,\r\n    address fromTokenAddress,\r\n    uint amountIn,\r\n    uint amountOutMin\r\n  ) external returns (uint) {\r\n\r\n    uint tokenBalanceBefore = IERC20(fromTokenAddress).balanceOf(address(this));\r\n    uint balanceBefore = address(this).balance;\r\n    address WETH = router.WETH();\r\n\r\n    {\r\n      // scope for swap frequency check\r\n      uint timeSinceLastTrade = block.timestamp.sub(uint(assetData.lastSwapTime));\r\n      require(timeSinceLastTrade > TwapOracle(_oracle).periodSize(), \"SwapAgent: too fast\");\r\n    }\r\n\r\n    {\r\n      // scope for liquidity check\r\n      address pairAddress = TwapOracle(_oracle).pairFor(fromTokenAddress, WETH);\r\n      IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\r\n      (uint112 reserve0, uint112 reserve1, /* time */) = pair.getReserves();\r\n\r\n      uint tokenReserve = fromTokenAddress < WETH ? reserve0 : reserve1;\r\n      uint maxTradable = tokenReserve.mul(MAX_LIQUIDITY_RATIO).div(1e18);\r\n\r\n      require(amountIn <= maxTradable, \"SwapAgent: exceeds max tradable amount\");\r\n    }\r\n\r\n    {\r\n      // scope for token checks\r\n      uint avgAmountOut = TwapOracle(_oracle).consult(fromTokenAddress, amountIn, WETH);\r\n      uint maxSlippageAmount = avgAmountOut.mul(assetData.maxSlippageRatio).div(1e18);\r\n      uint minOutOnMaxSlippage = avgAmountOut.sub(maxSlippageAmount);\r\n\r\n      // gas optimisation: reads both values using a single SLOAD\r\n      (uint minAssetAmount, uint maxAssetAmount) = (assetData.minAmount, assetData.maxAmount);\r\n\r\n      require(amountOutMin >= minOutOnMaxSlippage, \"SwapAgent: amountOutMin < minOutOnMaxSlippage\");\r\n      require(tokenBalanceBefore > maxAssetAmount, \"SwapAgent: tokenBalanceBefore <= max\");\r\n      require(tokenBalanceBefore.sub(amountIn) >= minAssetAmount, \"SwapAgent: tokenBalanceAfter < min\");\r\n    }\r\n\r\n    address[] memory path = new address[](2);\r\n    path[0] = fromTokenAddress;\r\n    path[1] = router.WETH();\r\n    IERC20(fromTokenAddress).approve(address(router), amountIn);\r\n    router.swapExactTokensForETH(amountIn, amountOutMin, path, address(this), block.timestamp);\r\n\r\n    assetData.lastSwapTime = uint32(block.timestamp);\r\n\r\n    uint balanceAfter = address(this).balance;\r\n    uint amountOut = balanceAfter.sub(balanceBefore);\r\n\r\n    return amountOut;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/modules/capital/Pool.sol\r\n\r\n/* Copyright (C) 2020 NexusMutual.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Pool is MasterAware, ReentrancyGuard {\r\n  using Address for address;\r\n  using SafeMath for uint;\r\n  using SafeERC20 for IERC20;\r\n\r\n  /* storage */\r\n  address[] public assets;\r\n  mapping(address => SwapAgent.AssetData) public assetData;\r\n\r\n  // contracts\r\n  Quotation public quotation;\r\n  NXMToken public nxmToken;\r\n  TokenController public tokenController;\r\n  MCR public mcr;\r\n\r\n  // parameters\r\n  address public twapOracle;\r\n  address public swapController;\r\n  uint public minPoolEth;\r\n  PriceFeedOracle public priceFeedOracle;\r\n\r\n  /* constants */\r\n  address constant public ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n  uint public constant MCR_RATIO_DECIMALS = 4;\r\n  uint public constant MAX_MCR_RATIO = 40000; // 400%\r\n  uint public constant MAX_BUY_SELL_MCR_ETH_FRACTION = 500; // 5%. 4 decimal points\r\n\r\n  uint internal constant CONSTANT_C = 5800000;\r\n  uint internal constant CONSTANT_A = 1028 * 1e13;\r\n  uint internal constant TOKEN_EXPONENT = 4;\r\n\r\n  /* events */\r\n  event Payout(address indexed to, address indexed asset, uint amount);\r\n  event NXMSold (address indexed member, uint nxmIn, uint ethOut);\r\n  event NXMBought (address indexed member, uint ethIn, uint nxmOut);\r\n  event Swapped(address indexed fromAsset, address indexed toAsset, uint amountIn, uint amountOut);\r\n\r\n  /* logic */\r\n  modifier onlySwapController {\r\n    require(msg.sender == swapController, \"Pool: not swapController\");\r\n    _;\r\n  }\r\n\r\n  constructor (\r\n    address[] memory _assets,\r\n    uint112[] memory _minAmounts,\r\n    uint112[] memory _maxAmounts,\r\n    uint[] memory _maxSlippageRatios,\r\n    address _master,\r\n    address _priceOracle,\r\n    address _twapOracle,\r\n    address _swapController\r\n  ) public {\r\n\r\n    require(_assets.length == _minAmounts.length, \"Pool: length mismatch\");\r\n    require(_assets.length == _maxAmounts.length, \"Pool: length mismatch\");\r\n    require(_assets.length == _maxSlippageRatios.length, \"Pool: length mismatch\");\r\n\r\n    for (uint i = 0; i < _assets.length; i++) {\r\n\r\n      address asset = _assets[i];\r\n      require(asset != address(0), \"Pool: asset is zero address\");\r\n      require(_maxAmounts[i] >= _minAmounts[i], \"Pool: max < min\");\r\n      require(_maxSlippageRatios[i] <= 1 ether, \"Pool: max < min\");\r\n\r\n      assets.push(asset);\r\n      assetData[asset].minAmount = _minAmounts[i];\r\n      assetData[asset].maxAmount = _maxAmounts[i];\r\n      assetData[asset].maxSlippageRatio = _maxSlippageRatios[i];\r\n    }\r\n\r\n    master = INXMMaster(_master);\r\n    priceFeedOracle = PriceFeedOracle(_priceOracle);\r\n    twapOracle = _twapOracle;\r\n    swapController = _swapController;\r\n  }\r\n\r\n  // fallback function\r\n  function() external payable {}\r\n\r\n  // for legacy Pool1 upgrade compatibility\r\n  function sendEther() external payable {}\r\n\r\n  /**\r\n   * @dev Calculates total value of all pool assets in ether\r\n   */\r\n  function getPoolValueInEth() public view returns (uint) {\r\n\r\n    uint total = address(this).balance;\r\n\r\n    for (uint i = 0; i < assets.length; i++) {\r\n\r\n      address assetAddress = assets[i];\r\n      IERC20 token = IERC20(assetAddress);\r\n\r\n      uint rate = priceFeedOracle.getAssetToEthRate(assetAddress);\r\n      require(rate > 0, \"Pool: zero rate\");\r\n\r\n      uint assetBalance = token.balanceOf(address(this));\r\n      uint assetValue = assetBalance.mul(rate).div(1e18);\r\n\r\n      total = total.add(assetValue);\r\n    }\r\n\r\n    return total;\r\n  }\r\n\r\n  /* asset related functions */\r\n\r\n  function getAssets() external view returns (address[] memory) {\r\n    return assets;\r\n  }\r\n\r\n  function getAssetDetails(address _asset) external view returns (\r\n    uint balance,\r\n    uint112 min,\r\n    uint112 max,\r\n    uint32 lastAssetSwapTime,\r\n    uint maxSlippageRatio\r\n  ) {\r\n\r\n    IERC20 token = IERC20(_asset);\r\n    balance = token.balanceOf(address(this));\r\n    SwapAgent.AssetData memory data = assetData[_asset];\r\n\r\n    return (balance, data.minAmount, data.maxAmount, data.lastSwapTime, data.maxSlippageRatio);\r\n  }\r\n\r\n  function addAsset(\r\n    address _asset,\r\n    uint112 _min,\r\n    uint112 _max,\r\n    uint _maxSlippageRatio\r\n  ) external onlyGovernance {\r\n\r\n    require(_asset != address(0), \"Pool: asset is zero address\");\r\n    require(_max >= _min, \"Pool: max < min\");\r\n    require(_maxSlippageRatio <= 1 ether, \"Pool: max slippage ratio > 1\");\r\n\r\n    for (uint i = 0; i < assets.length; i++) {\r\n      require(_asset != assets[i], \"Pool: asset exists\");\r\n    }\r\n\r\n    assets.push(_asset);\r\n    assetData[_asset] = SwapAgent.AssetData(_min, _max, 0, _maxSlippageRatio);\r\n  }\r\n\r\n  function removeAsset(address _asset) external onlyGovernance {\r\n\r\n    for (uint i = 0; i < assets.length; i++) {\r\n\r\n      if (_asset != assets[i]) {\r\n        continue;\r\n      }\r\n\r\n      delete assetData[_asset];\r\n      assets[i] = assets[assets.length - 1];\r\n      assets.pop();\r\n\r\n      return;\r\n    }\r\n\r\n    revert(\"Pool: asset not found\");\r\n  }\r\n\r\n  function setAssetDetails(\r\n    address _asset,\r\n    uint112 _min,\r\n    uint112 _max,\r\n    uint _maxSlippageRatio\r\n  ) external onlyGovernance {\r\n\r\n    require(_min <= _max, \"Pool: min > max\");\r\n    require(_maxSlippageRatio <= 1 ether, \"Pool: max slippage ratio > 1\");\r\n\r\n    for (uint i = 0; i < assets.length; i++) {\r\n\r\n      if (_asset != assets[i]) {\r\n        continue;\r\n      }\r\n\r\n      assetData[_asset].minAmount = _min;\r\n      assetData[_asset].maxAmount = _max;\r\n      assetData[_asset].maxSlippageRatio = _maxSlippageRatio;\r\n\r\n      return;\r\n    }\r\n\r\n    revert(\"Pool: asset not found\");\r\n  }\r\n\r\n  /* swap functions */\r\n\r\n  function getSwapQuote(\r\n    uint tokenAmountIn,\r\n    IERC20 fromToken,\r\n    IERC20 toToken\r\n  ) public view returns (uint tokenAmountOut) {\r\n\r\n    return SwapAgent.getSwapQuote(\r\n      tokenAmountIn,\r\n      fromToken,\r\n      toToken\r\n    );\r\n  }\r\n\r\n  function swapETHForAsset(\r\n    address toTokenAddress,\r\n    uint amountIn,\r\n    uint amountOutMin\r\n  ) external whenNotPaused onlySwapController nonReentrant {\r\n\r\n    SwapAgent.AssetData storage assetDetails = assetData[toTokenAddress];\r\n\r\n    uint amountOut = SwapAgent.swapETHForAsset(\r\n      twapOracle,\r\n      assetDetails,\r\n      toTokenAddress,\r\n      amountIn,\r\n      amountOutMin,\r\n      minPoolEth\r\n    );\r\n\r\n    emit Swapped(ETH, toTokenAddress, amountIn, amountOut);\r\n  }\r\n\r\n  function swapAssetForETH(\r\n    address fromTokenAddress,\r\n    uint amountIn,\r\n    uint amountOutMin\r\n  ) external whenNotPaused onlySwapController nonReentrant {\r\n\r\n    uint amountOut = SwapAgent.swapAssetForETH(\r\n      twapOracle,\r\n      assetData[fromTokenAddress],\r\n      fromTokenAddress,\r\n      amountIn,\r\n      amountOutMin\r\n    );\r\n\r\n    emit Swapped(fromTokenAddress, ETH, amountIn, amountOut);\r\n  }\r\n\r\n  /* claim related functions */\r\n\r\n  /**\r\n   * @dev Execute the payout in case a claim is accepted\r\n   * @param asset token address or 0xEee...EEeE for ether\r\n   * @param payoutAddress send funds to this address\r\n   * @param amount amount to send\r\n   */\r\n  function sendClaimPayout (\r\n    address asset,\r\n    address payable payoutAddress,\r\n    uint amount\r\n  ) external onlyInternal nonReentrant returns (bool success) {\r\n\r\n    bool ok;\r\n\r\n    if (asset == ETH) {\r\n      // solhint-disable-next-line avoid-low-level-calls\r\n      (ok, /* data */) = payoutAddress.call.value(amount)(\"\");\r\n    } else {\r\n      ok =  _safeTokenTransfer(asset, payoutAddress, amount);\r\n    }\r\n\r\n    if (ok) {\r\n      emit Payout(payoutAddress, asset, amount);\r\n    }\r\n\r\n    return ok;\r\n  }\r\n\r\n  /**\r\n   * @dev safeTransfer implementation that does not revert\r\n   * @param tokenAddress ERC20 address\r\n   * @param to destination\r\n   * @param value amount to send\r\n   * @return success true if the transfer was successfull\r\n   */\r\n  function _safeTokenTransfer (\r\n    address tokenAddress,\r\n    address to,\r\n    uint256 value\r\n  ) internal returns (bool) {\r\n\r\n    // token address is not a contract\r\n    if (!tokenAddress.isContract()) {\r\n      return false;\r\n    }\r\n\r\n    IERC20 token = IERC20(tokenAddress);\r\n    bytes memory data = abi.encodeWithSelector(token.transfer.selector, to, value);\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = tokenAddress.call(data);\r\n\r\n    // low-level call failed/reverted\r\n    if (!success) {\r\n      return false;\r\n    }\r\n\r\n    // tokens that don't have return data\r\n    if (returndata.length == 0) {\r\n      return true;\r\n    }\r\n\r\n    // tokens that have return data will return a bool\r\n    return abi.decode(returndata, (bool));\r\n  }\r\n\r\n  /* pool lifecycle functions */\r\n\r\n  function transferAsset(\r\n    address asset,\r\n    address payable destination,\r\n    uint amount\r\n  ) external onlyGovernance nonReentrant {\r\n\r\n    require(assetData[asset].maxAmount == 0, \"Pool: max not zero\");\r\n    require(destination != address(0), \"Pool: dest zero\");\r\n\r\n    IERC20 token = IERC20(asset);\r\n    uint balance = token.balanceOf(address(this));\r\n    uint transferableAmount = amount > balance ? balance : amount;\r\n\r\n    token.safeTransfer(destination, transferableAmount);\r\n  }\r\n\r\n  function upgradeCapitalPool(address payable newPoolAddress) external onlyMaster nonReentrant {\r\n\r\n    // transfer ether\r\n    uint ethBalance = address(this).balance;\r\n    (bool ok, /* data */) = newPoolAddress.call.value(ethBalance)(\"\");\r\n    require(ok, \"Pool: transfer failed\");\r\n\r\n    // transfer assets\r\n    for (uint i = 0; i < assets.length; i++) {\r\n      IERC20 token = IERC20(assets[i]);\r\n      uint tokenBalance = token.balanceOf(address(this));\r\n      token.safeTransfer(newPoolAddress, tokenBalance);\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Update dependent contract address\r\n   * @dev Implements MasterAware interface function\r\n   */\r\n  function changeDependentContractAddress() public {\r\n    nxmToken = NXMToken(master.tokenAddress());\r\n    tokenController = TokenController(master.getLatestAddress(\"TC\"));\r\n    quotation = Quotation(master.getLatestAddress(\"QT\"));\r\n    mcr = MCR(master.getLatestAddress(\"MC\"));\r\n  }\r\n\r\n  /* cover purchase functions */\r\n\r\n  /// @dev Enables user to purchase cover with funding in ETH.\r\n  /// @param smartCAdd Smart Contract Address\r\n  function makeCoverBegin(\r\n    address smartCAdd,\r\n    bytes4 coverCurr,\r\n    uint[] memory coverDetails,\r\n    uint16 coverPeriod,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s\r\n  ) public payable onlyMember whenNotPaused {\r\n\r\n    require(coverCurr == \"ETH\", \"Pool: Unexpected asset type\");\r\n    require(msg.value == coverDetails[1], \"Pool: ETH amount does not match premium\");\r\n\r\n    quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\r\n  }\r\n\r\n  /**\r\n   * @dev Enables user to purchase cover via currency asset eg DAI\r\n   */\r\n  function makeCoverUsingCA(\r\n    address smartCAdd,\r\n    bytes4 coverCurr,\r\n    uint[] memory coverDetails,\r\n    uint16 coverPeriod,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s\r\n  ) public onlyMember whenNotPaused {\r\n    require(coverCurr != \"ETH\", \"Pool: Unexpected asset type\");\r\n    quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\r\n  }\r\n\r\n  function transferAssetFrom (address asset, address from, uint amount) public onlyInternal whenNotPaused {\r\n    IERC20 token = IERC20(asset);\r\n    token.safeTransferFrom(from, address(this), amount);\r\n  }\r\n\r\n  /* token sale functions */\r\n\r\n  /**\r\n   * @dev (DEPRECATED, use sellTokens function instead) Allows selling of NXM for ether.\r\n   * Seller first needs to give this contract allowance to\r\n   * transfer/burn tokens in the NXMToken contract\r\n   * @param  _amount Amount of NXM to sell\r\n   * @return success returns true on successfull sale\r\n   */\r\n  function sellNXMTokens(uint _amount) public onlyMember whenNotPaused returns (bool success) {\r\n    sellNXM(_amount, 0);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev (DEPRECATED, use calculateNXMForEth function instead) Returns the amount of wei a seller will get for selling NXM\r\n   * @param amount Amount of NXM to sell\r\n   * @return weiToPay Amount of wei the seller will get\r\n   */\r\n  function getWei(uint amount) external view returns (uint weiToPay) {\r\n    return getEthForNXM(amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Buys NXM tokens with ETH.\r\n   * @param  minTokensOut Minimum amount of tokens to be bought. Revert if boughtTokens falls below this number.\r\n   * @return boughtTokens number of bought tokens.\r\n   */\r\n  function buyNXM(uint minTokensOut) public payable onlyMember whenNotPaused {\r\n\r\n    uint ethIn = msg.value;\r\n    require(ethIn > 0, \"Pool: ethIn > 0\");\r\n\r\n    uint totalAssetValue = getPoolValueInEth().sub(ethIn);\r\n    uint mcrEth = mcr.getLastMCREther();\r\n    uint mcrRatio = calculateMCRRatio(totalAssetValue, mcrEth);\r\n    require(mcrRatio <= MAX_MCR_RATIO, \"Pool: Cannot purchase if MCR% > 400%\");\r\n    uint tokensOut = calculateNXMForEth(ethIn, totalAssetValue, mcrEth);\r\n    require(tokensOut >= minTokensOut, \"Pool: tokensOut is less than minTokensOut\");\r\n    tokenController.mint(msg.sender, tokensOut);\r\n\r\n    emit NXMBought(msg.sender, ethIn, tokensOut);\r\n  }\r\n\r\n  /**\r\n   * @dev Sell NXM tokens and receive ETH.\r\n   * @param tokenAmount Amount of tokens to sell.\r\n   * @param  minEthOut Minimum amount of ETH to be received. Revert if ethOut falls below this number.\r\n   * @return ethOut amount of ETH received in exchange for the tokens.\r\n   */\r\n  function sellNXM(uint tokenAmount, uint minEthOut) public onlyMember nonReentrant whenNotPaused {\r\n\r\n    require(nxmToken.balanceOf(msg.sender) >= tokenAmount, \"Pool: Not enough balance\");\r\n    require(nxmToken.isLockedForMV(msg.sender) <= now, \"Pool: NXM tokens are locked for voting\");\r\n\r\n    uint currentTotalAssetValue = getPoolValueInEth();\r\n    uint mcrEth = mcr.getLastMCREther();\r\n    uint ethOut = calculateEthForNXM(tokenAmount, currentTotalAssetValue, mcrEth);\r\n    require(currentTotalAssetValue.sub(ethOut) >= mcrEth, \"Pool: MCR% cannot fall below 100%\");\r\n    require(ethOut >= minEthOut, \"Pool: ethOut < minEthOut\");\r\n\r\n    tokenController.burnFrom(msg.sender, tokenAmount);\r\n    (bool ok, /* data */) = msg.sender.call.value(ethOut)(\"\");\r\n    require(ok, \"Pool: Sell transfer failed\");\r\n\r\n    emit NXMSold(msg.sender, tokenAmount, ethOut);\r\n  }\r\n\r\n  /**\r\n   * @dev Get value in tokens for an ethAmount purchase.\r\n   * @param ethAmount amount of ETH used for buying.\r\n   * @return tokenValue tokens obtained by buying worth of ethAmount\r\n   */\r\n  function getNXMForEth(\r\n    uint ethAmount\r\n  ) public view returns (uint) {\r\n    uint totalAssetValue = getPoolValueInEth();\r\n    uint mcrEth = mcr.getLastMCREther();\r\n    return calculateNXMForEth(ethAmount, totalAssetValue, mcrEth);\r\n  }\r\n\r\n  function calculateNXMForEth(\r\n    uint ethAmount,\r\n    uint currentTotalAssetValue,\r\n    uint mcrEth\r\n  ) public pure returns (uint) {\r\n\r\n    require(\r\n      ethAmount <= mcrEth.mul(MAX_BUY_SELL_MCR_ETH_FRACTION).div(10 ** MCR_RATIO_DECIMALS),\r\n      \"Pool: Purchases worth higher than 5% of MCReth are not allowed\"\r\n    );\r\n\r\n    /*\r\n      The price formula is:\r\n      P(V) = A + MCReth / C *  MCR% ^ 4\r\n      where MCR% = V / MCReth\r\n      P(V) = A + 1 / (C * MCReth ^ 3) *  V ^ 4\r\n\r\n      To compute the number of tokens issued we can integrate with respect to V the following:\r\n        T = V / P(V)\r\n        which assumes that for an infinitesimally small change in locked value V price is constant and we\r\n        get an infinitesimally change in token supply T.\r\n      This is not computable on-chain, below we use an approximation that works well assuming\r\n       * MCR% stays within [100%, 400%]\r\n       * ethAmount <= 5% * MCReth\r\n\r\n      Use a simplified formula excluding the constant A price offset to compute the amount of tokens to be minted.\r\n      AdjustedP(V) = 1 / (C * MCReth ^ 3) *  V ^ 4\r\n      AdjustedP(V) = 1 / (C * MCReth ^ 3) *  V ^ 4\r\n\r\n      For a very small variation in tokens T, we have,  T = V / P(V), to get total T we integrate with respect to V.\r\n      adjustedTokenAmount =  (dV / AdjustedP(V)) from V0 (currentTotalAssetValue) to V1 (nextTotalAssetValue)\r\n      adjustedTokenAmount =  ((C * MCReth ^ 3) / V ^ 4 * dV) from V0 to V1\r\n      Evaluating the above using the antiderivative of the function we get:\r\n      adjustedTokenAmount = - MCReth ^ 3 * C / (3 * V1 ^3) + MCReth * C /(3 * V0 ^ 3)\r\n    */\r\n\r\n    if (currentTotalAssetValue == 0 || mcrEth.div(currentTotalAssetValue) > 1e12) {\r\n      /*\r\n       If the currentTotalAssetValue = 0, adjustedTokenPrice approaches 0. Therefore we can assume the price is A.\r\n       If currentTotalAssetValue is far smaller than mcrEth, MCR% approaches 0, let the price be A (baseline price).\r\n       This avoids overflow in the calculateIntegralAtPoint computation.\r\n       This approximation is safe from arbitrage since at MCR% < 100% no sells are possible.\r\n      */\r\n      uint tokenPrice = CONSTANT_A;\r\n      return ethAmount.mul(1e18).div(tokenPrice);\r\n    }\r\n\r\n    // MCReth * C /(3 * V0 ^ 3)\r\n    uint point0 = calculateIntegralAtPoint(currentTotalAssetValue, mcrEth);\r\n    // MCReth * C / (3 * V1 ^3)\r\n    uint nextTotalAssetValue = currentTotalAssetValue.add(ethAmount);\r\n    uint point1 = calculateIntegralAtPoint(nextTotalAssetValue, mcrEth);\r\n    uint adjustedTokenAmount = point0.sub(point1);\r\n    /*\r\n      Compute a preliminary adjustedTokenPrice for the minted tokens based on the adjustedTokenAmount above,\r\n      and to that add the A constant (the price offset previously removed in the adjusted Price formula)\r\n      to obtain the finalPrice and ultimately the tokenValue based on the finalPrice.\r\n\r\n      adjustedPrice = ethAmount / adjustedTokenAmount\r\n      finalPrice = adjustedPrice + A\r\n      tokenValue = ethAmount  / finalPrice\r\n    */\r\n    // ethAmount is multiplied by 1e18 to cancel out the multiplication factor of 1e18 of the adjustedTokenAmount\r\n    uint adjustedTokenPrice = ethAmount.mul(1e18).div(adjustedTokenAmount);\r\n    uint tokenPrice = adjustedTokenPrice.add(CONSTANT_A);\r\n\r\n    return ethAmount.mul(1e18).div(tokenPrice);\r\n  }\r\n\r\n  /**\r\n   * @dev integral(V) =  MCReth ^ 3 * C / (3 * V ^ 3) * 1e18\r\n   * computation result is multiplied by 1e18 to allow for a precision of 18 decimals.\r\n   * NOTE: omits the minus sign of the correct integral to use a uint result type for simplicity\r\n   * WARNING: this low-level function should be called from a contract which checks that\r\n   * mcrEth / assetValue < 1e17 (no overflow) and assetValue != 0\r\n   */\r\n  function calculateIntegralAtPoint(\r\n    uint assetValue,\r\n    uint mcrEth\r\n  ) internal pure returns (uint) {\r\n\r\n    return CONSTANT_C\r\n      .mul(1e18)\r\n      .div(3)\r\n      .mul(mcrEth).div(assetValue)\r\n      .mul(mcrEth).div(assetValue)\r\n      .mul(mcrEth).div(assetValue);\r\n  }\r\n\r\n  function getEthForNXM(uint nxmAmount) public view returns (uint ethAmount) {\r\n    uint currentTotalAssetValue = getPoolValueInEth();\r\n    uint mcrEth = mcr.getLastMCREther();\r\n    return calculateEthForNXM(nxmAmount, currentTotalAssetValue, mcrEth);\r\n  }\r\n\r\n  /**\r\n   * @dev Computes token sell value for a tokenAmount in ETH with a sell spread of 2.5%.\r\n   * for values in ETH of the sale <= 1% * MCReth the sell spread is very close to the exact value of 2.5%.\r\n   * for values higher than that sell spread may exceed 2.5%\r\n   * (The higher amount being sold at any given time the higher the spread)\r\n   */\r\n  function calculateEthForNXM(\r\n    uint nxmAmount,\r\n    uint currentTotalAssetValue,\r\n    uint mcrEth\r\n  ) public pure returns (uint) {\r\n\r\n    // Step 1. Calculate spot price at current values and amount of ETH if tokens are sold at that price\r\n    uint spotPrice0 = calculateTokenSpotPrice(currentTotalAssetValue, mcrEth);\r\n    uint spotEthAmount = nxmAmount.mul(spotPrice0).div(1e18);\r\n\r\n    //  Step 2. Calculate spot price using V = currentTotalAssetValue - spotEthAmount from step 1\r\n    uint totalValuePostSpotPriceSell = currentTotalAssetValue.sub(spotEthAmount);\r\n    uint spotPrice1 = calculateTokenSpotPrice(totalValuePostSpotPriceSell, mcrEth);\r\n\r\n    // Step 3. Min [average[Price(0), Price(1)] x ( 1 - Sell Spread), Price(1) ]\r\n    // Sell Spread = 2.5%\r\n    uint averagePriceWithSpread = spotPrice0.add(spotPrice1).div(2).mul(975).div(1000);\r\n    uint finalPrice = averagePriceWithSpread < spotPrice1 ? averagePriceWithSpread : spotPrice1;\r\n    uint ethAmount = finalPrice.mul(nxmAmount).div(1e18);\r\n\r\n    require(\r\n      ethAmount <= mcrEth.mul(MAX_BUY_SELL_MCR_ETH_FRACTION).div(10 ** MCR_RATIO_DECIMALS),\r\n      \"Pool: Sales worth more than 5% of MCReth are not allowed\"\r\n    );\r\n\r\n    return ethAmount;\r\n  }\r\n\r\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) public pure returns (uint) {\r\n    return totalAssetValue.mul(10 ** MCR_RATIO_DECIMALS).div(mcrEth);\r\n  }\r\n\r\n  /**\r\n  * @dev Calculates token price in ETH 1 NXM token. TokenPrice = A + (MCReth / C) * MCR%^4\r\n  */\r\n  function calculateTokenSpotPrice(uint totalAssetValue, uint mcrEth) public pure returns (uint tokenPrice) {\r\n\r\n    uint mcrRatio = calculateMCRRatio(totalAssetValue, mcrEth);\r\n    uint precisionDecimals = 10 ** TOKEN_EXPONENT.mul(MCR_RATIO_DECIMALS);\r\n\r\n    return mcrEth\r\n      .mul(mcrRatio ** TOKEN_EXPONENT)\r\n      .div(CONSTANT_C)\r\n      .div(precisionDecimals)\r\n      .add(CONSTANT_A);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the NXM price in a given asset\r\n   * @param asset Asset name.\r\n   */\r\n  function getTokenPrice(address asset) public view returns (uint tokenPrice) {\r\n\r\n    uint totalAssetValue = getPoolValueInEth();\r\n    uint mcrEth = mcr.getLastMCREther();\r\n    uint tokenSpotPriceEth = calculateTokenSpotPrice(totalAssetValue, mcrEth);\r\n\r\n    return priceFeedOracle.getAssetForEth(asset, tokenSpotPriceEth);\r\n  }\r\n\r\n  function getMCRRatio() public view returns (uint) {\r\n    uint totalAssetValue = getPoolValueInEth();\r\n    uint mcrEth = mcr.getLastMCREther();\r\n    return calculateMCRRatio(totalAssetValue, mcrEth);\r\n  }\r\n\r\n  function updateUintParameters(bytes8 code, uint value) external onlyGovernance {\r\n\r\n    if (code == \"MIN_ETH\") {\r\n      minPoolEth = value;\r\n      return;\r\n    }\r\n\r\n    revert(\"Pool: unknown parameter\");\r\n  }\r\n\r\n  function updateAddressParameters(bytes8 code, address value) external onlyGovernance {\r\n\r\n    if (code == \"TWAP\") {\r\n      twapOracle = value;\r\n      return;\r\n    }\r\n\r\n    if (code == \"SWAP\") {\r\n      swapController = value;\r\n      return;\r\n    }\r\n\r\n    if (code == \"PRC_FEED\") {\r\n      priceFeedOracle = PriceFeedOracle(value);\r\n      return;\r\n    }\r\n\r\n    revert(\"Pool: unknown parameter\");\r\n  }\r\n}"
    }
  }
}