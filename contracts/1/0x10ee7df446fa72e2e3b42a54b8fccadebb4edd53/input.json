{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"UnityDEX.sol":{"content":"pragma solidity 0.5.13;  /*\r\n \r\n \r\n \r\n \r\n    ___________________________________________________________________\r\n      _      _                                        ______           \r\n      |  |  /          /                                /              \r\n    --|-/|-/-----__---/----__----__---_--_----__-------/-------__------\r\n      |/ |/    /___) /   /   ' /   ) / /  ) /___)     /      /   )     \r\n    __/__|____(___ _/___(___ _(___/_/_/__/_(___ _____/______(___/__o_o_\r\n    \r\n        \r\n       \r\n\r\n██╗   ██╗███╗   ██╗██╗████████╗██╗   ██╗    ██████╗ ███████╗██╗  ██╗\r\n██║   ██║████╗  ██║██║╚══██╔══╝╚██╗ ██╔╝    ██╔══██╗██╔════╝╚██╗██╔╝\r\n██║   ██║██╔██╗ ██║██║   ██║    ╚████╔╝     ██║  ██║█████╗   ╚███╔╝ \r\n██║   ██║██║╚██╗██║██║   ██║     ╚██╔╝      ██║  ██║██╔══╝   ██╔██╗ \r\n╚██████╔╝██║ ╚████║██║   ██║      ██║       ██████╔╝███████╗██╔╝ ██╗\r\n ╚═════╝ ╚═╝  ╚═══╝╚═╝   ╚═╝      ╚═╝       ╚═════╝ ╚══════╝╚═╝  ╚═╝\r\n                                                                    \r\n\r\n\r\n\r\n\r\n                                                                                     \r\n                                                                                     \r\n------------------------------------------------------------------------------------------------------\r\n Copyright (c) 2021 Onwards Unity DEX Inc. ( https://unity-dex.io )\r\n Contract designed with ❤ by EtherAuthority  ( https://EtherAuthority.io )\r\n------------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n\r\n//*******************************************************************\r\n//------------------------ SafeMath Library -------------------------\r\n//*******************************************************************\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface ERC20Essential \r\n{\r\n\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------ Contract to Manage Ownership -------------------//\r\n//*******************************************************************//\r\n    \r\ncontract owned {\r\n    address public owner;\r\n    address private newOwner;\r\n\r\n\r\n    event OwnershipTransferred(uint256 curTime, address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, 'Only owner can call this function');\r\n        _;\r\n    }\r\n\r\n\r\n    function onlyOwnerTransferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //this flow is to prevent transferring ownership to wrong wallet by mistake\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, 'Only new owner can call this function');\r\n        emit OwnershipTransferred(now, owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract UnityDEX is owned {\r\n  using SafeMath for uint256;\r\n  bool public safeGuard; // To hault all non owner functions in case of imergency - by default false\r\n  address public feeAccount; //the account that will receive fees\r\n  uint public tradingFee = 300; // 300 = 0.3%\r\n  \r\n  //referrals\r\n  uint256 public refPercent = 10;  // percent to calculate referal bonous - by default 10% of trading fee\r\n  \r\n  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\r\n  mapping (address => mapping (bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n  \r\n  /* Mapping to track referrer. The second address is the address of referrer, the Up-line/ Sponsor */\r\n  mapping (address => address) public referrers;\r\n  /* Mapping to track referrer bonus for all the referrers */\r\n  mapping (address => uint) public referrerBonusBalance;\r\n  \r\n  event Order(uint256 curTime, address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires,  address user);\r\n  event Cancel(uint256 curTime, address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, address user, uint8 v, bytes32 r, bytes32 s);\r\n  event Trade( uint256 curTime, address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give, uint256 orderBookID);\r\n  event Deposit(uint256 curTime, address token, address user, uint amount, uint balance);\r\n  event Withdraw(uint256 curTime, address token, address user, uint amount, uint balance);\r\n  event OwnerWithdrawCommission(address indexed owner, address indexed tokenAddress, uint256 amount);\r\n  \r\n  // Events to track ether transfer to referrers\r\n  event ReferrerBonus(address indexed referer, address indexed trader, uint256 referralBonus, uint256 timestamp );\r\n  event ReferrerBonusWithdrawn(address indexed referrer, uint256 indexed amount);\r\n\r\n  \r\n\r\n    constructor() public {\r\n        feeAccount = msg.sender;\r\n    }\r\n\r\n    function changeSafeguardStatus() onlyOwner public\r\n    {\r\n        if (safeGuard == false)\r\n        {\r\n            safeGuard = true;\r\n        }\r\n        else\r\n        {\r\n            safeGuard = false;    \r\n        }\r\n    }\r\n\r\n    //Calculate percent and return result\r\n    function calculatePercentage(uint256 PercentOf, uint256 percentTo ) internal pure returns (uint256) \r\n    {\r\n        uint256 factor = 100000;    //so to make 1000 = 1%\r\n        require(percentTo <= factor, 'percentTo must be less than factor');\r\n        uint256 c = PercentOf.mul(percentTo).div(factor);\r\n        return c;\r\n    }  \r\n\r\n\r\n\r\n    \r\n  // contract accepts incoming ether -  this needed in case owner want to fund refPool\r\n  function() payable external {  }\r\n\r\n\r\n  function changeFeeAccount(address feeAccount_) public onlyOwner {\r\n    feeAccount = feeAccount_;\r\n  }\r\n\r\n  function changetradingFee(uint tradingFee_) public onlyOwner{\r\n    require(tradingFee_ <= 10000, 'trading fee can not be more than 100%');\r\n    tradingFee = tradingFee_;\r\n  }\r\n  \r\n  function availableOwnerCommissionEther() public view returns(uint256){\r\n      //assress 0x0 only holds ether as fee\r\n      return tokens[address(0)][feeAccount];\r\n  }\r\n  \r\n  function availableOwnerCommissionToken(address tokenAddress) public view returns(uint256){\r\n      //assress 0x0 only holds ether as fee\r\n      return tokens[tokenAddress][feeAccount];\r\n  }\r\n  \r\n  function withdrawOwnerCommissoinEther() public  returns (string memory){\r\n      require(msg.sender == feeAccount, 'Invalid caller');\r\n      uint256 amount = availableOwnerCommissionEther();\r\n      require (amount > 0, 'Nothing to withdraw');\r\n      tokens[address(0)][feeAccount] = 0;\r\n      msg.sender.transfer(amount);\r\n      emit OwnerWithdrawCommission(msg.sender, address(0), amount);\r\n      return \"Ether withdrawn successfully\";\r\n  }\r\n  \r\n  function withdrawOwnerCommissoinToken(address tokenAddress) public  returns (string memory){\r\n      require(msg.sender == feeAccount, 'Invalid caller');\r\n      uint256 amount = availableOwnerCommissionToken(tokenAddress);\r\n      require (amount > 0, 'Nothing to withdraw');\r\n      tokens[tokenAddress][feeAccount] = 0;\r\n      ERC20Essential(tokenAddress).transfer(msg.sender, amount);\r\n      emit OwnerWithdrawCommission(msg.sender, tokenAddress, amount);\r\n      return \"Token withdrawn successfully\";\r\n  }\r\n\r\n  function deposit() public payable {\r\n    tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].add(msg.value);\r\n    emit Deposit(now, address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\r\n  }\r\n\r\n  function withdraw(uint amount) public {\r\n    require(!safeGuard,\"System Paused by Admin\");\r\n    require(tokens[address(0)][msg.sender] >= amount, 'Not enough balance');\r\n    tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].sub(amount);\r\n    msg.sender.transfer(amount);\r\n    emit Withdraw(now, address(0), msg.sender, amount, tokens[address(0)][msg.sender]);\r\n  }\r\n\r\n  function depositToken(address token, uint amount) public {\r\n    //remember to call Token(address).approve(address(this), amount) or this contract will not be able to do the transfer on your behalf.\r\n    require(token!=address(0), 'Invalid token address');\r\n    require(ERC20Essential(token).transferFrom(msg.sender, address(this), amount), 'tokens could not be transferred');\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\r\n    emit Deposit(now, token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\t\r\n  function withdrawToken(address token, uint amount) public {\r\n    require(!safeGuard,\"System Paused by Admin\");\r\n    require(token!=address(0), 'Invalid token address');\r\n    require(tokens[token][msg.sender] >= amount, 'not enough token balance');\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\r\n\t  ERC20Essential(token).transfer(msg.sender, amount);\r\n    emit Withdraw(now, token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function balanceOf(address token, address user) public view returns (uint) {\r\n    return tokens[token][user];\r\n  }\r\n\r\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires) public {\r\n    bytes32 hash = keccak256(abi.encodePacked(address(this), tokenGet, amountGet, tokenGive, amountGive, expires));\r\n    orders[msg.sender][hash] = true;\r\n    emit Order(now, tokenGet, amountGet, tokenGive, amountGive, expires, msg.sender);\r\n  }\r\n\r\n\r\n    /* address[4] addressArray elements\r\n        0 = tokenGet\r\n        1 = tokenGive\r\n        2 = tradeMaker\r\n        3 = referrer\r\n    */\r\n  function trade(address[4] memory addressArray, uint amountGet, uint amountGive, uint expires, uint8 v, bytes32 r, bytes32 s, uint amount, uint orderBookID) public {\r\n    require(!safeGuard,\"System Paused by Admin\");\r\n    //amount is in amountGet terms\r\n    bytes32 hash = keccak256(abi.encodePacked(address(this), addressArray[0], amountGet, addressArray[1], amountGive, expires));\r\n    require(orders[addressArray[2]][hash] || ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)),v,r,s) == addressArray[2], 'Invalid trade parameters');\r\n    require(block.number <= expires, 'Trade is expired');\r\n    require(orderFills[addressArray[2]][hash].add(amount) <= amountGet, 'Trade order is filled');\r\n\r\n    tradeBalances(addressArray, amountGet, amountGive, amount );\r\n    orderFills[addressArray[2]][hash] = orderFills[addressArray[2]][hash].add(amount);\r\n    \r\n    emit Trade(now, addressArray[0], amount, addressArray[1], amountGive * amount / amountGet, addressArray[2], msg.sender, orderBookID);\r\n  }\r\n    \r\n    /**\r\n        addressArray array elements\r\n        0 = tokenGet\r\n        1 = tokenGive\r\n        2 = user\r\n        3 = referrer\r\n    */\r\n  function tradeBalances(address[4] memory addressArray, uint amountGet, uint amountGive, uint amount) internal {\r\n    \r\n    uint tradingFeeXfer = calculatePercentage(amount,tradingFee);\r\n    \r\n    //processing referrers bonus - which is % of the trading fee\r\n    processReferrerBonus(addressArray[3], tradingFeeXfer);\r\n\r\n    tokens[addressArray[0]][msg.sender] = tokens[addressArray[0]][msg.sender].sub(amount.add(tradingFeeXfer));\r\n    tokens[addressArray[0]][addressArray[2]] = tokens[addressArray[0]][addressArray[2]].add(amount);\r\n    tokens[addressArray[0]][feeAccount] = tokens[addressArray[0]][feeAccount].add(tradingFeeXfer);\r\n\r\n    tokens[addressArray[1]][addressArray[2]] = tokens[addressArray[1]][addressArray[2]].sub(amountGive.mul(amount) / amountGet);\r\n    tokens[addressArray[1]][msg.sender] = tokens[addressArray[1]][msg.sender].add(amountGive.mul(amount) / amountGet);\r\n  }\r\n  \r\n  \r\n\r\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public view returns(bool) {\r\n    \r\n    if (!(\r\n      tokens[tokenGet][sender] >= amount &&\r\n      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, user, v, r, s) >= amount\r\n    )) return false;\r\n    return true;\r\n  }\r\n  \r\n  function testVRS(address tokenGet, uint256 amountGet, address tokenGive, uint256 amountGive, uint256 expires, uint8 v, bytes32 r, bytes32 s ) public view returns(address){\r\n      \r\n      bytes32 hash = keccak256(abi.encodePacked(address(this), tokenGet, amountGet, tokenGive, amountGive, expires));\r\n     \r\n      return ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)),v,r,s);\r\n    \r\n  }\r\n\r\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, address user, uint8 v, bytes32 r, bytes32 s) public view returns(uint) {\r\n    bytes32 hash = keccak256(abi.encodePacked(address(this), tokenGet, amountGet, tokenGive, amountGive, expires));\r\n    uint available1;\r\n    if (!(\r\n      (orders[user][hash] || ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)),v,r,s) == user) &&\r\n      block.number <= expires\r\n    )) return 0;\r\n    available1 = tokens[tokenGive][user].mul(amountGet) / amountGive;\r\n    \r\n    if (amountGet.sub(orderFills[user][hash])<available1) return amountGet.sub(orderFills[user][hash]);\r\n    return available1;\r\n    \r\n  }\r\n\r\n  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, address user) public view returns(uint) {\r\n    bytes32 hash = keccak256(abi.encodePacked(address(this), tokenGet, amountGet, tokenGive, amountGive, expires));\r\n    return orderFills[user][hash];\r\n  }\r\n\r\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint8 v, bytes32 r, bytes32 s) public {\r\n    require(!safeGuard,\"System Paused by Admin\");\r\n    bytes32 hash = keccak256(abi.encodePacked(address(this), tokenGet, amountGet, tokenGive, amountGive, expires));\r\n    require(orders[msg.sender][hash] || ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)),v,r,s) == msg.sender, 'Invalid trade order');\r\n    orderFills[msg.sender][hash] = amountGet;\r\n    emit Cancel(now, tokenGet, amountGet, tokenGive, amountGive, expires, msg.sender, v, r, s);\r\n  }\r\n\r\n\r\n\r\n//==================================================//\r\n//              REFERRAL SECTION CODE               //\r\n//==================================================//\r\n\r\nfunction processReferrerBonus(address _referrer, uint256 _tradingFeeLocal) internal {\r\n      \r\n      address existingReferrer = referrers[msg.sender];\r\n      \r\n      if(_referrer != address(0) && existingReferrer != address(0) ){\r\n        referrerBonusBalance[existingReferrer] += _tradingFeeLocal * refPercent / 100;\r\n        emit ReferrerBonus(_referrer, msg.sender, _tradingFeeLocal * refPercent / 100, now );\r\n      }\r\n      else if(_referrer != address(0) && existingReferrer == address(0) ){\r\n        //no referrer exist, but provided in trade function call\r\n        referrerBonusBalance[_referrer] += _tradingFeeLocal * refPercent / 100;\r\n        referrers[msg.sender] = _referrer;\r\n        emit ReferrerBonus(_referrer, msg.sender, _tradingFeeLocal * refPercent / 100, now );\r\n      }\r\n  }\r\n  \r\n  function changeRefPercent(uint256 newRefPercent) public onlyOwner returns (string memory){\r\n      require(newRefPercent <= 100, 'newRefPercent can not be more than 100');\r\n      refPercent = newRefPercent;\r\n      return \"refPool fee updated successfully\";\r\n  }\r\n  \r\n  /**\r\n        * Function will allow users to withdraw their referrer bonus  \r\n    */\r\n    function claimReferrerBonus() public returns(bool) {\r\n        \r\n        address payable msgSender = msg.sender;\r\n        \r\n        uint256 referralBonus = referrerBonusBalance[msgSender];\r\n        \r\n        require(referralBonus > 0, 'Insufficient referrer bonus');\r\n        referrerBonusBalance[msgSender] = 0;\r\n        \r\n        \r\n        //transfer the referrer bonus\r\n        msgSender.transfer(referralBonus);\r\n        \r\n        //fire event\r\n        emit ReferrerBonusWithdrawn(msgSender, referralBonus);\r\n        \r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}"}}}