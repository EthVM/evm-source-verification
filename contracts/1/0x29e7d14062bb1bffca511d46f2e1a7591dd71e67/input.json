{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/kp3rv2_oraclefactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}\n\ninterface IKeep3rV1 {\n    function keepers(address keeper) external returns (bool);\n    function KPRH() external view returns (IKeep3rV1Helper);\n    function receipt(address credit, address keeper, uint amount) external;\n}\n\ninterface IKeep3rV1Helper {\n    function getQuoteLimit(uint gasUsed) external view returns (uint);\n}\n\n// sliding oracle that uses observations collected to provide moving price averages in the past\ncontract Keep3rV2Oracle {\n\n    constructor(address _pair) {\n        _factory = msg.sender;\n        pair = _pair;\n        (,,uint32 timestamp) = IUniswapV2Pair(_pair).getReserves();\n        uint112 _price0CumulativeLast = uint112(IUniswapV2Pair(_pair).price0CumulativeLast() * e10 / Q112);\n        uint112 _price1CumulativeLast = uint112(IUniswapV2Pair(_pair).price1CumulativeLast() * e10 / Q112);\n        observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\n    }\n\n    struct Observation {\n        uint32 timestamp;\n        uint112 price0Cumulative;\n        uint112 price1Cumulative;\n    }\n\n    modifier factory() {\n        require(msg.sender == _factory, \"!F\");\n        _;\n    }\n\n    Observation[65535] public observations;\n    uint16 public length;\n\n    address immutable _factory;\n    address immutable public pair;\n    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n    uint constant periodSize = 1800;\n    uint Q112 = 2**112;\n    uint e10 = 10**18;\n\n    // Pre-cache slots for cheaper oracle writes\n    function cache(uint size) external {\n        uint _length = length+size;\n        for (uint i = length; i < _length; i++) observations[i].timestamp = 1;\n    }\n\n    // update the current feed for free\n    function update() external factory returns (bool) {\n        return _update();\n    }\n\n    function updateable() external view returns (bool) {\n        Observation memory _point = observations[length-1];\n        (,, uint timestamp) = IUniswapV2Pair(pair).getReserves();\n        uint timeElapsed = timestamp - _point.timestamp;\n        return timeElapsed > periodSize;\n    }\n\n    function _update() internal returns (bool) {\n        Observation memory _point = observations[length-1];\n        (,, uint32 timestamp) = IUniswapV2Pair(pair).getReserves();\n        uint32 timeElapsed = timestamp - _point.timestamp;\n        if (timeElapsed > periodSize) {\n            uint112 _price0CumulativeLast = uint112(IUniswapV2Pair(pair).price0CumulativeLast() * e10 / Q112);\n            uint112 _price1CumulativeLast = uint112(IUniswapV2Pair(pair).price1CumulativeLast() * e10 / Q112);\n            observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\n            return true;\n        }\n        return false;\n    }\n\n    function _computeAmountOut(uint start, uint end, uint elapsed, uint amountIn) internal view returns (uint amountOut) {\n        amountOut = amountIn * (end - start) / e10 / elapsed;\n    }\n\n    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut, uint lastUpdatedAgo) {\n        (address token0,) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\n\n        Observation memory _observation = observations[length-1];\n        uint price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast() * e10 / Q112;\n        uint price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast() * e10 / Q112;\n        (,,uint timestamp) = IUniswapV2Pair(pair).getReserves();\n\n        // Handle edge cases where we have no updates, will revert on first reading set\n        if (timestamp == _observation.timestamp) {\n            _observation = observations[length-2];\n        }\n\n        uint timeElapsed = timestamp - _observation.timestamp;\n        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n        if (token0 == tokenIn) {\n            amountOut = _computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n        } else {\n            amountOut = _computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n        }\n        lastUpdatedAgo = timeElapsed;\n    }\n\n    function quote(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint amountOut, uint lastUpdatedAgo) {\n        (address token0,) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\n\n        uint priceAverageCumulative = 0;\n        uint _length = length-1;\n        uint i = _length - points;\n        Observation memory currentObservation;\n        Observation memory nextObservation;\n\n        uint nextIndex = 0;\n        if (token0 == tokenIn) {\n            for (; i < _length; i++) {\n                nextIndex = i+1;\n                currentObservation = observations[i];\n                nextObservation = observations[nextIndex];\n                priceAverageCumulative += _computeAmountOut(\n                    currentObservation.price0Cumulative,\n                    nextObservation.price0Cumulative,\n                    nextObservation.timestamp - currentObservation.timestamp, amountIn);\n            }\n        } else {\n            for (; i < _length; i++) {\n                nextIndex = i+1;\n                currentObservation = observations[i];\n                nextObservation = observations[nextIndex];\n                priceAverageCumulative += _computeAmountOut(\n                    currentObservation.price1Cumulative,\n                    nextObservation.price1Cumulative,\n                    nextObservation.timestamp - currentObservation.timestamp, amountIn);\n            }\n        }\n        amountOut = priceAverageCumulative / points;\n\n        (,,uint timestamp) = IUniswapV2Pair(pair).getReserves();\n        lastUpdatedAgo = timestamp - nextObservation.timestamp;\n    }\n\n    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint[] memory prices, uint lastUpdatedAgo) {\n        (address token0,) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\n        prices = new uint[](points);\n\n        if (token0 == tokenIn) {\n            {\n                uint _length = length-1;\n                uint i = _length - (points * window);\n                uint _index = 0;\n                Observation memory nextObservation;\n                for (; i < _length; i+=window) {\n                    Observation memory currentObservation;\n                    currentObservation = observations[i];\n                    nextObservation = observations[i + window];\n                    prices[_index] = _computeAmountOut(\n                        currentObservation.price0Cumulative,\n                        nextObservation.price0Cumulative,\n                        nextObservation.timestamp - currentObservation.timestamp, amountIn);\n                    _index = _index + 1;\n                }\n\n                (,,uint timestamp) = IUniswapV2Pair(pair).getReserves();\n                lastUpdatedAgo = timestamp - nextObservation.timestamp;\n            }\n        } else {\n            {\n                uint _length = length-1;\n                uint i = _length - (points * window);\n                uint _index = 0;\n                Observation memory nextObservation;\n                for (; i < _length; i+=window) {\n                    Observation memory currentObservation;\n                    currentObservation = observations[i];\n                    nextObservation = observations[i + window];\n                    prices[_index] = _computeAmountOut(\n                        currentObservation.price1Cumulative,\n                        nextObservation.price1Cumulative,\n                        nextObservation.timestamp - currentObservation.timestamp, amountIn);\n                    _index = _index + 1;\n                }\n\n                (,,uint timestamp) = IUniswapV2Pair(pair).getReserves();\n                lastUpdatedAgo = timestamp - nextObservation.timestamp;\n            }\n        }\n    }\n}\n\ncontract Keep3rV2OracleFactory {\n\n    function pairForSushi(address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n                hex'ff',\n                0xc35DADB65012eC5796536bD9864eD8773aBc74C4,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n            )))));\n    }\n\n    function pairForUni(address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n                hex'ff',\n                0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n            )))));\n    }\n\n    modifier keeper() {\n        require(KP3R.keepers(msg.sender), \"!K\");\n        _;\n    }\n\n    modifier upkeep() {\n        uint _gasUsed = gasleft();\n        require(KP3R.keepers(msg.sender), \"!K\");\n        _;\n        uint _received = KP3R.KPRH().getQuoteLimit(_gasUsed - gasleft());\n        KP3R.receipt(address(KP3R), msg.sender, _received);\n    }\n\n    address public governance;\n    address public pendingGovernance;\n\n    /**\n     * @notice Allows governance to change governance (for future upgradability)\n     * @param _governance new governance address to set\n     */\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!G\");\n        pendingGovernance = _governance;\n    }\n\n    /**\n     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\n     */\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"!pG\");\n        governance = pendingGovernance;\n    }\n\n    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n\n    address[] internal _pairs;\n    mapping(address => Keep3rV2Oracle) public feeds;\n\n    function pairs() external view returns (address[] memory) {\n        return _pairs;\n    }\n\n    constructor() {\n        governance = msg.sender;\n    }\n\n    function update(address pair) external keeper returns (bool) {\n        return feeds[pair].update();\n    }\n\n    function byteCode(address pair) external pure returns (bytes memory bytecode) {\n        bytecode = abi.encodePacked(type(Keep3rV2Oracle).creationCode, abi.encode(pair));\n    }\n\n    function deploy(address pair) external returns (address feed) {\n        require(msg.sender == governance, \"!G\");\n        require(address(feeds[pair]) == address(0), 'PE');\n        bytes memory bytecode = abi.encodePacked(type(Keep3rV2Oracle).creationCode, abi.encode(pair));\n        bytes32 salt = keccak256(abi.encodePacked(pair));\n        assembly {\n            feed := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n            if iszero(extcodesize(feed)) {\n                revert(0, 0)\n            }\n        }\n        feeds[pair] = Keep3rV2Oracle(feed);\n        _pairs.push(pair);\n    }\n\n    function work() external upkeep {\n        require(workable(), \"!W\");\n        for (uint i = 0; i < _pairs.length; i++) {\n            feeds[_pairs[i]].update();\n        }\n    }\n\n    function work(address pair) external upkeep {\n        require(feeds[pair].update(), \"!W\");\n    }\n\n    function workForFree() external keeper {\n        for (uint i = 0; i < _pairs.length; i++) {\n            feeds[_pairs[i]].update();\n        }\n    }\n\n    function workForFree(address pair) external keeper {\n        feeds[pair].update();\n    }\n\n    function cache(uint size) external {\n        for (uint i = 0; i < _pairs.length; i++) {\n            feeds[_pairs[i]].cache(size);\n        }\n    }\n\n    function cache(address pair, uint size) external {\n        feeds[pair].cache(size);\n    }\n\n    function workable() public view returns (bool canWork) {\n        canWork = true;\n        for (uint i = 0; i < _pairs.length; i++) {\n            if (!feeds[_pairs[i]].updateable()) {\n                canWork = false;\n            }\n        }\n    }\n\n    function workable(address pair) public view returns (bool) {\n        return feeds[pair].updateable();\n    }\n\n    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window, bool sushiswap) external view returns (uint[] memory prices, uint lastUpdatedAgo) {\n        address _pair = sushiswap ? pairForSushi(tokenIn, tokenOut) : pairForUni(tokenIn, tokenOut);\n        return feeds[_pair].sample(tokenIn, amountIn, tokenOut, points, window);\n    }\n\n    function sample(address pair, address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint[] memory prices, uint lastUpdatedAgo) {\n        return feeds[pair].sample(tokenIn, amountIn, tokenOut, points, window);\n    }\n\n    function quote(address tokenIn, uint amountIn, address tokenOut, uint points, bool sushiswap) external view returns (uint amountOut, uint lastUpdatedAgo) {\n        address _pair = sushiswap ? pairForSushi(tokenIn, tokenOut) : pairForUni(tokenIn, tokenOut);\n        return feeds[_pair].quote(tokenIn, amountIn, tokenOut, points);\n    }\n\n    function quote(address pair, address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint amountOut, uint lastUpdatedAgo) {\n        return feeds[pair].quote(tokenIn, amountIn, tokenOut, points);\n    }\n\n    function current(address tokenIn, uint amountIn, address tokenOut, bool sushiswap) external view returns (uint amountOut, uint lastUpdatedAgo) {\n        address _pair = sushiswap ? pairForSushi(tokenIn, tokenOut) : pairForUni(tokenIn, tokenOut);\n        return feeds[_pair].current(tokenIn, amountIn, tokenOut);\n    }\n\n    function current(address pair, address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut, uint lastUpdatedAgo) {\n        return feeds[pair].current(tokenIn, amountIn, tokenOut);\n    }\n}"
    }
  }
}