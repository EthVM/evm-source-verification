{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/AaRouterMinter.sol": {
      "content": "\r\npragma solidity 0.6.4;\r\n\r\ninterface Minter {\r\n    function FreezeFreeMint(uint amt, address user, uint dapp) external;\r\n    function mintHXB(uint value, address receiver) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function balanceOf (address account) external view returns (uint256);\r\n    function mintRatio() external pure returns (uint256);//hxb\r\n    function mintBlock() external pure returns (bool);//hxy/hxb\r\n}\r\n\r\ninterface HEX {\r\n    function xfLobbyEnter(address referrerAddr)\r\n    external\r\n    payable;\r\n\r\n    function xfLobbyExit(uint256 enterDay, uint256 count)\r\n    external;\r\n\r\n    function xfLobbyPendingDays(address memberAddr)\r\n    external\r\n    view\r\n    returns (uint256[2] memory words);\r\n\r\n    function balanceOf (address account)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n    function transfer (address recipient, uint256 amount)\r\n    external \r\n    returns (bool);\r\n\r\n    function currentDay ()\r\n    external\r\n    view\r\n    returns (uint256);\r\n}\r\n\r\n\r\ncontract TokenEvents {\r\n\r\n    //when a user freezes tokens\r\n    event TokenFreeze(\r\n        address indexed user,\r\n        uint value,\r\n        address indexed token\r\n    );\r\n\r\n    //when a user unfreezes tokens\r\n    event TokenUnfreeze(\r\n        address indexed user,\r\n        uint value,\r\n        address indexed token\r\n    );\r\n\r\n}\r\n\r\ncontract Router is TokenEvents {\r\n\r\n    struct CustomerState {\r\n        uint16 nextPendingDay;\r\n        mapping(uint256 => uint256) contributionByDay;\r\n    }\r\n\r\n    struct LobbyContributionState {\r\n        uint256 totalValue;\r\n        uint256 heartsReceived;\r\n    }\r\n\r\n    struct ContractStateCache {\r\n        uint256 currentDay;\r\n        uint256 nextPendingDay;\r\n    }\r\n\r\n    event LobbyJoined(\r\n        uint40 timestamp,\r\n        uint16 day,\r\n        uint256 amount,\r\n        address indexed customer,\r\n        address indexed affiliate\r\n    );\r\n\r\n    event LobbyLeft(\r\n        uint40 timestamp,\r\n        uint16 day,\r\n        uint256 hearts\r\n    );\r\n\r\n    event MissedLobby(\r\n        uint40 timestamp,\r\n        uint16 day\r\n    );\r\n    \r\n    //minting HXY/HXB/HXP\r\n    address internal hxyAddress = address(0xf3A2ace8e48751c965eA0A1D064303AcA53842b9);\r\n    address internal hxbAddress = address(0x9BB6fd000109E24Eb38B0Deb806382fF9247E478);\r\n    address internal hxpAddress = address(0x16aB6ED897D04856Ff138122Db4b7767078a20F3);\r\n    \r\n    Minter internal hxy = Minter(hxyAddress);\r\n    Minter internal hxb = Minter(hxbAddress);\r\n    Minter internal hxp = Minter(hxpAddress);\r\n    \r\n    uint public hxyRatio = 100;\r\n    uint public hxbRatio = 1000;\r\n    uint public hxpRatio = 10000;\r\n    bool public multisigSet;\r\n    address public multisig = address(0);\r\n    address public splitter = address(0x7d68C0321cf6B3A12E6e5D5ABbAA8F2A13d77FDd);\r\n    \r\n    //freeze setup\r\n    uint internal daySeconds = 86400; // seconds in a day\r\n    uint public totalHxyFrozen;\r\n    uint public totalHxbLocked;\r\n    uint public totalHxpFrozen;\r\n    bool public hxpUnlocked;\r\n    \r\n    mapping (address => uint) public mintedHxy;//balance of HXY minted and not yet frozen by user\r\n    mapping (address => uint) public mintedHxb;//balance of HXB minted and not yet locked by user\r\n    mapping (address => uint) public mintedHxp;//balance of HXP minted and not yet frozen by user\r\n    \r\n    mapping (address => uint) public tokenHxyFrozenBalances;//balance of HXY frozen mapped by user\r\n    mapping (address => uint) public tokenHxbLockedBalances;//balance of HXB locked mapped by user\r\n    mapping (address => uint) public tokenHxpFrozenBalances;//balance of HXP frozen mapped by user\r\n\r\n    mapping (address => Frozen) public frozen;\r\n\r\n    struct Frozen{\r\n        uint256 freezeHxyStartTimestamp;\r\n        uint256 lockHxbStartTimestamp;\r\n        uint256 freezeHxpStartTimestamp;\r\n    }\r\n    \r\n    // from HEX\r\n    uint16 private constant LAUNCH_PHASE_DAYS = 350;\r\n    uint16 private constant LAUNCH_PHASE_END_DAY = 351;\r\n    uint256 private constant XF_LOBBY_DAY_WORDS = (LAUNCH_PHASE_END_DAY + 255) >> 8;\r\n\r\n    // constants & mappings we need\r\n    mapping(address => bool) admins;\r\n    address management1 = 0x383B80128D3378d9d63Ef8B4189971c9240F031e;\r\n    address management2 = 0xA65C4cffC2e9848f6fc946030D8942E17F151aa4;\r\n    address internal _p1 = 0xb5cDb0AD2b6097cB051B27D3149Ef80eAA623527;\r\n    address internal _p2 = 0x86b0C0c3fF5aDE3a6F00180D09C1CEEB2b7765eA;\r\n    address internal _p3 = 0x975C3Da56B958AB3581D3789544b1cf19c0b8b23;\r\n    address internal _p4 = 0x454f203260a74C0A8B5c0a78fbA5B4e8B31dCC63;\r\n    address internal _p5 = 0x976A70754568F4A7D15D04fc8b0d56f914791f5B;\r\n    address internal _p6 = 0xed03F181FCa480a03Dd708e3d87A0441cD43513f;\r\n    uint managementShare;\r\n    \r\n    HEX private constant hx = HEX(0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39);\r\n    uint256 private contractNextPendingDay;\r\n    uint256 public constant HEX_LAUNCH_TIME = 1575331200;\r\n    mapping(address => uint8) private registeredAffiliates;\r\n    mapping(uint256 => LobbyContributionState) private totalValueByDay;\r\n    mapping(address => CustomerState) private customerData;\r\n    mapping(uint8 => uint8) public affiliateRankPercentages;\r\n    \r\n    modifier onlyMultisig(){\r\n        require(msg.sender == multisig, \"not authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmins(){\r\n        require(admins[msg.sender], \"not an admin\");\r\n        _;\r\n    }\r\n\r\n    constructor()\r\n    public\r\n    {\r\n        admins[msg.sender] = true;\r\n        contractNextPendingDay = _getHexContractDay(); // today is the next day to resolve\r\n        affiliateRankPercentages[0] = 0;\r\n        affiliateRankPercentages[1] = 50;\r\n        affiliateRankPercentages[2] = 100;\r\n    }\r\n    \r\n    function enterLobby(address customer, address affiliate)\r\n    public\r\n    payable\r\n    {\r\n        require(msg.value > 0, \"invalid eth value\");\r\n        bool isAffiliate = false;\r\n        uint8 affiliateLevel = registeredAffiliates[msg.sender];\r\n        uint8 affiliateSplit = affiliateRankPercentages[affiliateLevel];\r\n        if(affiliate != address(0) && affiliateSplit > 0){\r\n            // real affiliate, use them for ref\r\n            uint256 affiliateValue = msg.value * affiliateSplit / 100;\r\n            isAffiliate = true;\r\n            hx.xfLobbyEnter{value:affiliateValue}(affiliate);\r\n            if(msg.value - affiliateValue > 0){\r\n                hx.xfLobbyEnter{value:msg.value - affiliateValue}(splitter);\r\n            }\r\n        } else {\r\n            hx.xfLobbyEnter{value:msg.value}(splitter);\r\n        }\r\n\r\n        // record customer contribution\r\n        uint256 currentDay = _getHexContractDay();\r\n        totalValueByDay[currentDay].totalValue += msg.value;\r\n        customerData[customer].contributionByDay[currentDay] += msg.value;\r\n        if(customerData[customer].nextPendingDay == 0){\r\n            // new user\r\n            customerData[customer].nextPendingDay = uint16(currentDay);\r\n        }\r\n\r\n        //if the splitter is used as referral, set the zero address as affiliate\r\n        address referrerAddr = isAffiliate ? affiliate : address(0);\r\n        emit LobbyJoined(\r\n            uint40(block.timestamp),\r\n            uint16(currentDay),\r\n            msg.value,\r\n            customer,\r\n            referrerAddr\r\n          );\r\n    }\r\n\r\n    function exitLobbiesBeforeDay(address customer, uint256 day)\r\n    public\r\n    {\r\n        ContractStateCache memory state = ContractStateCache(_getHexContractDay(), contractNextPendingDay);\r\n        uint256 _day = day > 0 ? day : state.currentDay;\r\n        require(customerData[customer].nextPendingDay < _day,\r\n            \"Customer has no active lobby entries for this time period\");\r\n        _leaveLobbies(state, _day);\r\n        // next pending day was updated as part of leaveLobbies\r\n        contractNextPendingDay = state.nextPendingDay;\r\n        _distributeShare(customer, _day);\r\n    }\r\n\r\n    function registerAffiliate(address affiliateContract, uint8 affiliateRank)\r\n    public\r\n    onlyAdmins\r\n    {\r\n        require(registeredAffiliates[affiliateContract] == 0, \"Affiliate contract is already registered\");\r\n        registeredAffiliates[affiliateContract] = affiliateRank;\r\n    }\r\n\r\n    function updateAffiliateRank(address affiliateContract, uint8 affiliateRank)\r\n    public\r\n    onlyAdmins\r\n    {\r\n        require(affiliateRank != registeredAffiliates[affiliateContract], \"New Affiliate rank must be different than previous\");\r\n        require(affiliateRankPercentages[affiliateRank] >= affiliateRankPercentages[registeredAffiliates[affiliateContract]],\r\n                \"Cannot set an affiliateRank with lower percentage than previous\");\r\n        registeredAffiliates[affiliateContract] = affiliateRank;\r\n    }\r\n\r\n    function addAffiliateRank(uint8 affiliateRank, uint8 rankSplitPercentage)\r\n    public\r\n    onlyAdmins\r\n    {\r\n        require(affiliateRankPercentages[affiliateRank] == 0, \"Affiliate rank already exists\");\r\n        require(rankSplitPercentage > 0 && rankSplitPercentage <= 100,\r\n            \"Affiliate Split must be between 0-100%\");\r\n        affiliateRankPercentages[affiliateRank] = rankSplitPercentage;\r\n    }\r\n\r\n    function verifyAffiliate(address affiliateContract)\r\n    public\r\n    view\r\n    returns (bool, uint8)\r\n    {\r\n        return (registeredAffiliates[affiliateContract] > 0, registeredAffiliates[affiliateContract]);\r\n    }\r\n\r\n    function batchLeaveLobby(uint256 day, uint256 batchSize)\r\n    public\r\n    {\r\n        require(day < _getHexContractDay(), \"You must only leave lobbies that have ended\");\r\n        uint256[XF_LOBBY_DAY_WORDS] memory joinedDays = hx.xfLobbyPendingDays(address(this));\r\n        require((joinedDays[day >> 8] & (1 << (day & 255))) >> (day & 255) == 1, \"You may only leave lobbies with active entries\");\r\n\r\n        uint256 balance = hx.balanceOf(address(this));\r\n        _leaveLobby(day, batchSize, balance);\r\n    }\r\n\r\n    receive()\r\n    external\r\n    payable\r\n    {\r\n        if(msg.value > 0)\r\n        {\r\n          // If someone just sends eth, get them in a lobby with no affiliate, i.e. splitter\r\n          enterLobby(msg.sender, address(0));\r\n        }\r\n          else\r\n        {\r\n          //if the transaction value is 0, exit lobbies instead\r\n          exitLobbiesBeforeDay(msg.sender, 0);\r\n        }\r\n    }\r\n\r\n    function _getHexContractDay()\r\n    private\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(HEX_LAUNCH_TIME < block.timestamp, \"Launch time not before current block\");\r\n        return (block.timestamp - HEX_LAUNCH_TIME) / 1 days;\r\n    }\r\n\r\n    function _leaveLobbies(ContractStateCache memory currentState, uint256 beforeDay)\r\n    private\r\n    {\r\n        uint256 newBalance = hx.balanceOf(address(this));\r\n        //uint256 oldBalance;\r\n        if(currentState.nextPendingDay < beforeDay){\r\n            uint256[XF_LOBBY_DAY_WORDS] memory joinedDays = hx.xfLobbyPendingDays(address(this));\r\n            while(currentState.nextPendingDay < beforeDay){\r\n                if( (joinedDays[currentState.nextPendingDay >> 8] & (1 << (currentState.nextPendingDay & 255))) >>\r\n                    (currentState.nextPendingDay & 255) == 1){\r\n                    // leaving 0 means leave \"all\"\r\n                    newBalance = _leaveLobby(currentState.nextPendingDay, 0, newBalance);\r\n                    emit LobbyLeft(uint40(block.timestamp),\r\n                        uint16(currentState.nextPendingDay),\r\n                        totalValueByDay[currentState.nextPendingDay].heartsReceived);\r\n                } else {\r\n                    emit MissedLobby(uint40(block.timestamp),\r\n                     uint16(currentState.nextPendingDay));\r\n                }\r\n                currentState.nextPendingDay++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _leaveLobby(uint256 lobby, uint256 numEntries, uint256 balance)\r\n    private\r\n    returns (uint256)\r\n    {\r\n        hx.xfLobbyExit(lobby, numEntries);\r\n        uint256 oldBalance = balance;\r\n        balance = hx.balanceOf(address(this));\r\n        totalValueByDay[lobby].heartsReceived += balance - oldBalance;\r\n        require(totalValueByDay[lobby].heartsReceived > 0, \"Hearts received for a lobby is 0\");\r\n        return balance;\r\n    }\r\n\r\n    function _distributeShare(address customer, uint256 endDay)\r\n    private\r\n    returns (uint256)\r\n    {\r\n        uint256 totalShare = 0;\r\n        CustomerState storage user = customerData[customer];\r\n        uint256 nextDay = user.nextPendingDay;\r\n        if(nextDay > 0 && nextDay < endDay){\r\n            while(nextDay < endDay){\r\n                if(totalValueByDay[nextDay].totalValue > 0 && totalValueByDay[nextDay].heartsReceived > 0){\r\n                    require(totalValueByDay[nextDay].heartsReceived > 0, \"Hearts received must be > 0, leave lobby for day\");\r\n                    totalShare += user.contributionByDay[nextDay] *\r\n                        totalValueByDay[nextDay].heartsReceived /\r\n                        totalValueByDay[nextDay].totalValue;\r\n                }\r\n                nextDay++;\r\n            }\r\n            if(totalShare > 0){\r\n                uint initialShare = totalShare * 100 / 110;\r\n                uint splitShare = (totalShare - initialShare) / 2;\r\n                uint customerShare = initialShare + splitShare;\r\n                require(hx.transfer(customer, customerShare), strConcat(\"Failed to transfer \",uint2str(customerShare),\", insufficient balance\"));\r\n                managementShare += splitShare;//50% of 10% bonus to management\r\n                //mint if at least 1 HEX\r\n                if(customerShare >= 100000000){\r\n                    //HXY\r\n                    if(hxyAddress != address(0)){\r\n                        uint y = customerShare / hxyRatio;\r\n                        if(hxy.balanceOf(address(this)) >= y){\r\n                            //hxy.transfer(customer, y);\r\n                            mintedHxy[customer] += y;\r\n                        }\r\n                    }\r\n                    //HXB\r\n                    if(hxbAddress != address(0)){\r\n                         //is hxb minting ceased? transfer from contract balance if so\r\n                         if(hxb.mintBlock()){\r\n                            uint b = customerShare / hxbRatio;\r\n                            if(hxb.balanceOf(address(this)) >= b){\r\n                                //hxb.transfer(customer, b); \r\n                                mintedHxb[customer] += b;\r\n                            }\r\n                        }\r\n                        else{\r\n                          require(hxb.mintHXB(((customerShare / hxbRatio) * hxb.mintRatio()), address(this)), \"could not mint HXB\");\r\n                          mintedHxb[customer] += customerShare / hxbRatio;\r\n                        }\r\n                    }\r\n                    //HXP\r\n                    if(hxpAddress != address(0)){\r\n                        uint p = customerShare / hxpRatio;\r\n                        if(hxp.balanceOf(address(this)) >= p){\r\n                            //hxp.transfer(customer, p);\r\n                            mintedHxp[customer] += p;\r\n                        }\r\n                    }\r\n                }   \r\n            }\r\n        }\r\n        if(nextDay != user.nextPendingDay){\r\n            user.nextPendingDay = uint16(nextDay);\r\n        }\r\n\r\n        return totalShare;\r\n    }\r\n    \r\n    \r\n        ////////////////////////////////////////////////////////\r\n    /////////////////PUBLIC FACING - FREEZE CONTROL//////////\r\n    //////////////////////////////////////////////////////\r\n    \r\n    \r\n    //freeze HXY tokens to contract\r\n    function Freeze(address token)\r\n        public\r\n    {\r\n        if(isFreezeFinished(msg.sender, token)){\r\n            Unfreeze(token);//unfreezes all currently frozen tokens\r\n        }\r\n        uint amt;\r\n        //update balances\r\n        if(token == hxyAddress){\r\n            amt = mintedHxy[msg.sender];\r\n            require(amt > 0, \"Error: insufficient balance available to freeze\");//ensure user has enough funds allocated\r\n            mintedHxy[msg.sender] = 0;\r\n            tokenHxyFrozenBalances[msg.sender] += amt;\r\n            totalHxyFrozen += amt;\r\n            frozen[msg.sender].freezeHxyStartTimestamp = now;\r\n        }\r\n        else if(token == hxbAddress){\r\n            amt = mintedHxb[msg.sender];\r\n            require(amt > 0, \"Error: insufficient balance available to lock\");//ensure user has enough funds allocated\r\n            mintedHxb[msg.sender] = 0;\r\n            tokenHxbLockedBalances[msg.sender] += amt;\r\n            totalHxbLocked += amt;\r\n            frozen[msg.sender].lockHxbStartTimestamp = now;\r\n        }\r\n        else if(token == hxpAddress){\r\n            amt = mintedHxp[msg.sender];\r\n            require(amt > 0, \"Error: insufficient balance available to freeze\");//ensure user has enough funds allocated\r\n            mintedHxp[msg.sender] = 0;\r\n            tokenHxpFrozenBalances[msg.sender] += amt;\r\n            totalHxpFrozen += amt;\r\n            frozen[msg.sender].freezeHxpStartTimestamp = now;\r\n        }\r\n        else{\r\n            revert();\r\n        }\r\n        emit TokenFreeze(msg.sender, amt, token);\r\n    }\r\n    \r\n    //unfreeze HXY tokens from contract\r\n    function Unfreeze(address token)\r\n        public\r\n    {\r\n        uint amt;\r\n        if(token == hxyAddress){\r\n            require(tokenHxyFrozenBalances[msg.sender] > 0,\"Error: unsufficient frozen balance\");//ensure user has enough frozen funds\r\n            require(isFreezeFinished(msg.sender, token), \"tokens cannot be unfrozen yet, min 90 days\");\r\n            amt = tokenHxyFrozenBalances[msg.sender];\r\n            tokenHxyFrozenBalances[msg.sender] = 0;\r\n            frozen[msg.sender].freezeHxyStartTimestamp = 0;\r\n            totalHxyFrozen -= amt;\r\n            hxy.transfer(msg.sender, amt);//make transfer\r\n        }\r\n        else if(token == hxbAddress){\r\n            require(tokenHxbLockedBalances[msg.sender] > 0,\"Error: unsufficient frozen balance\");//ensure user has enough frozen funds\r\n            require(isFreezeFinished(msg.sender, token), \"tokens cannot be unlocked yet, max HXB supply much be reached\");\r\n            amt = tokenHxbLockedBalances[msg.sender];\r\n            tokenHxbLockedBalances[msg.sender] = 0;\r\n            frozen[msg.sender].lockHxbStartTimestamp = 0;\r\n            totalHxbLocked -= amt;\r\n            hxb.transfer(msg.sender, amt);//make transfer\r\n        }\r\n        else if(token == hxpAddress){\r\n            require(tokenHxpFrozenBalances[msg.sender] > 0,\"Error: unsufficient frozen balance\");//ensure user has enough frozen funds\r\n            require(isFreezeFinished(msg.sender, token), \"tokens cannot be unfrozen yet, can be unfrozen on platform launch\");\r\n            amt = tokenHxpFrozenBalances[msg.sender];\r\n            tokenHxpFrozenBalances[msg.sender] = 0;\r\n            frozen[msg.sender].freezeHxpStartTimestamp = 0;\r\n            totalHxpFrozen -= amt;\r\n            hxp.transfer(msg.sender, amt);//make transfer\r\n        }\r\n\r\n        else{\r\n            revert();\r\n        }\r\n\r\n        emit TokenUnfreeze(msg.sender, amt, token);\r\n    }\r\n    \r\n    ///////////////////////////////\r\n    ////////VIEW ONLY//////////////\r\n    ///////////////////////////////\r\n\r\n\r\n//HXY frozen for 365 days , HXB locked till maxSupply , HXP frozen till platform launch\r\n    function isFreezeFinished(address _user, address token)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        if(token == hxyAddress){\r\n            if(frozen[_user].freezeHxyStartTimestamp == 0){\r\n                return false;\r\n            }\r\n            else{\r\n               return (frozen[_user].freezeHxyStartTimestamp + (365 * daySeconds)) <= now;               \r\n            }\r\n        }\r\n        else if(token == hxbAddress){\r\n            if(frozen[_user].lockHxbStartTimestamp == 0){\r\n                return false;\r\n            }\r\n            else{\r\n                return hxb.mintBlock();   \r\n            }\r\n        }\r\n        else if(token == hxpAddress){\r\n            if(frozen[_user].freezeHxpStartTimestamp == 0){\r\n                return false;\r\n            }\r\n            else{\r\n                return hxpUnlocked;\r\n            }\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    function distributeManagementShare()\r\n        public\r\n    {\r\n        require(managementShare > 1);\r\n        uint tenPercent = managementShare / 10;\r\n        require(hx.transfer(management1, (tenPercent * 2)), \"failed to transfer\");\r\n        require(hx.transfer(management2, (tenPercent * 2)), \"failed to transfer\");\r\n        require(hx.transfer(_p1, tenPercent), \"failed to transfer\");\r\n        require(hx.transfer(_p2, tenPercent), \"failed to transfer\");\r\n        require(hx.transfer(_p3, tenPercent), \"failed to transfer\");\r\n        require(hx.transfer(_p4, tenPercent), \"failed to transfer\");\r\n        require(hx.transfer(_p5, tenPercent), \"failed to transfer\");\r\n        require(hx.transfer(_p6, tenPercent), \"failed to transfer\");\r\n        managementShare = 0;\r\n    }\r\n    \r\n    ///////////////////////\r\n    /////ADMIN ONLY/////////\r\n    //////////////////////\r\n    \r\n    function setHXYAddress(address _hxyAddress)\r\n        onlyMultisig\r\n        public\r\n    {\r\n        hxyAddress = _hxyAddress;\r\n        hxy = Minter(hxyAddress);\r\n    }\r\n    \r\n    function setHXBAddress(address _hxbAddress)\r\n        onlyMultisig\r\n        public\r\n    {\r\n        hxbAddress = _hxbAddress;\r\n        hxb = Minter(hxbAddress);\r\n    }\r\n    \r\n    function setHXPAddress(address _hxpAddress)\r\n        onlyMultisig\r\n        public\r\n    {\r\n        hxpAddress = _hxpAddress;\r\n        hxp = Minter(hxpAddress);\r\n    }\r\n    \r\n    function setSplitter(address _splitter)\r\n        onlyMultisig\r\n        public\r\n    {\r\n        require(_splitter != address(0));\r\n        splitter = _splitter;\r\n    }\r\n    \r\n    function setMultisig(address _multisig)\r\n        onlyAdmins\r\n        public\r\n    {\r\n        require(_multisig != address(0));\r\n        require(!multisigSet);\r\n        multisig = _multisig;\r\n        multisigSet = true;\r\n    }\r\n    \r\n    function setRatios(uint _hxy, uint _hxb, uint _hxp)\r\n        onlyMultisig\r\n        public\r\n    {\r\n        hxyRatio = _hxy;\r\n        hxbRatio = _hxb;\r\n        hxpRatio = _hxp;\r\n    }\r\n    \r\n    \r\n    function unlockHxp()\r\n        onlyMultisig\r\n        public\r\n    {\r\n        hxpUnlocked = true;    \r\n    }\r\n    \r\n    function uint2str(uint i)\r\n    internal\r\n    pure returns (string memory _uintAsString)\r\n    {\r\n        uint _i = i;\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c\r\n    , string memory _d, string memory _e)\r\n    private\r\n    pure\r\n    returns (string memory){\r\n    bytes memory _ba = bytes(_a);\r\n    bytes memory _bb = bytes(_b);\r\n    bytes memory _bc = bytes(_c);\r\n    bytes memory _bd = bytes(_d);\r\n    bytes memory _be = bytes(_e);\r\n    string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n    bytes memory babcde = bytes(abcde);\r\n    uint k = 0;\r\n    for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n    for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n    for (uint i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n    for (uint i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n    for (uint i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n    return string(babcde);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d)\r\n    private\r\n    pure\r\n    returns (string memory) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c)\r\n    private\r\n    pure\r\n    returns (string memory) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b)\r\n    private\r\n    pure\r\n    returns (string memory) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n}"
    }
  }
}