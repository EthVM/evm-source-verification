{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/EVAI.IO.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2020-07-21\n */\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.10;\n\n//--------------------------------------\n//  EVAI contract\n//\n// Symbol      : EVAI\n// Name        : EVAI.IO\n// Total supply: 1000000000\n// Decimals    : 8\n//--------------------------------------\n\nabstract contract ERC20Interface {\n    function totalSupply() external view virtual returns (uint256);\n\n    function balanceOf(address tokenOwner)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function allowance(address tokenOwner, address spender)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function transfer(address to, uint256 tokens)\n        external\n        virtual\n        returns (bool);\n\n    function approve(address spender, uint256 tokens)\n        external\n        virtual\n        returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokens\n    ) external virtual returns (bool);\n\n    function burn(uint256 tokens) external virtual returns (bool success);\n\n    function buy(address to, uint256 tokens) external virtual returns (bool);\n\n    function operationProfit(uint256 _profit) external virtual returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n    event Approval(\n        address indexed tokenOwner,\n        address indexed spender,\n        uint256 tokens\n    );\n    event Burn(address from, address, uint256 value);\n    event Profit(address from, uint256 profit, uint256 totalProfit);\n}\n\n// ----------------------------------------------------------------------------\n// Safe Math Library\n// ----------------------------------------------------------------------------\ncontract SafeMath {\n    function safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) {\n        c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        c = a - b;\n        return c;\n    }\n}\n\ncontract Evaitoken is ERC20Interface, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public initialSupply;\n    uint256 public _totalSupply;\n    address public owner;\n    uint256 public totalProfit;\n    uint256 public profit;\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n    mapping(uint256 => uint256) internal token;\n\n    constructor() public {\n        name = \"EVAI.IO\";\n        symbol = \"EVAI\";\n        decimals = 8;\n        _totalSupply = 1000000000 * 10**uint256(decimals);\n        initialSupply = _totalSupply;\n        balances[msg.sender] = _totalSupply;\n        owner = msg.sender;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return safeSub(_totalSupply, balances[address(0)]);\n    }\n\n    function balanceOf(address tokenOwner)\n        external\n        view\n        override\n        returns (uint256 getBalance)\n    {\n        return balances[tokenOwner];\n    }\n\n    function allowance(address tokenOwner, address spender)\n        external\n        view\n        override\n        returns (uint256 remaining)\n    {\n        return allowed[tokenOwner][spender];\n    }\n\n    function approve(address spender, uint256 tokens)\n        external\n        override\n        returns (bool success)\n    {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    function transfer(address to, uint256 tokens)\n        external\n        override\n        returns (bool success)\n    {\n        require(to != address(0));\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokens\n    ) external override returns (bool success) {\n        require(to != address(0));\n        balances[from] = safeSub(balances[from], tokens);\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    function buy(address to, uint256 tokens)\n        external\n        override\n        returns (bool success)\n    {\n        require(to != address(0));\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    function operationProfit(uint256 _profit)\n        external\n        override\n        returns (bool success)\n    {\n        require(owner == msg.sender, \"This is not owner\");\n        profit = _profit;\n        totalProfit = safeAdd(totalProfit, profit);\n        emit Profit(msg.sender, profit, totalProfit);\n        return true;\n    }\n\n    function burn(uint256 tokens) external override returns (bool success) {\n        require(owner == msg.sender, \"This is not owner\");\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        _totalSupply = safeSub(_totalSupply, tokens);\n        emit Burn(msg.sender, address(0), tokens);\n        return true;\n    }\n}\n"}}}