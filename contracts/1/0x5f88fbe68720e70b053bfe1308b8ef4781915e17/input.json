{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"swapverse.sol":{"content":"// SPDX-License-Identifier: MIT\r\n pragma solidity ^0.8.6;\r\n\r\n library SafeMath {\r\n \r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n interface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function getOwner() external view returns (address);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n  \r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n \r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {return msg.sender;}\r\n    function _msgData() internal view virtual returns (bytes calldata) {this; return msg.data;}\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size; assembly { size := extcodesize(account) } return size > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");(bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n\r\n    }\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) { return returndata; } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {revert(errorMessage);}\r\n        }\r\n    }\r\n}\r\n \r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    address private _previousOwner;\r\n    uint256 private _lockTime;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function getUnlockTime() public view returns (uint256) {\r\n        return _lockTime;\r\n    }\r\n\r\n    function getTime() public view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function lock(uint256 time) public virtual onlyOwner {\r\n        _previousOwner = _owner;\r\n        _owner = address(0);\r\n        _lockTime = block.timestamp + time;\r\n        emit OwnershipTransferred(_owner, address(0));\r\n    }\r\n\r\n    function unlock() public virtual {\r\n        require(_previousOwner == msg.sender, \"You don't have permission to unlock\");\r\n        require(block.timestamp > _lockTime , \"Contract is locked until 7 days\");\r\n        emit OwnershipTransferred(_owner, _previousOwner);\r\n        _owner = _previousOwner;\r\n        _previousOwner = address(0);\r\n    }\r\n}\r\n \r\n contract swapverse is IERC20Metadata, Context, Ownable {\r\n     using SafeMath for uint256;\r\n     using Address for address;\r\n     address public initialTokenReceiver = 0x7cE4D7946EDE50125396864BB7f162908AC361Ec;\r\n     address public marketingFeeReceiver = 0x0276d02885363Fda45A7d9c37D7757F6dB521501;\r\n     address public developmentwallet = 0x50A304cEF095aC943434B67AF254a8d3Eba1a998;\r\n     address public burnFeeReceiver = 0x3BE05d94c24Fe4404eD261376127cD1814dBAcc8;\r\n     address public deadAddress = 0x000000000000000000000000000000000000dEaD;\r\n\r\n     string constant _name = \"Swapverse\";\r\n     string constant _symbol = \"VSWAP\";\r\n     uint8 constant _decimals = 9;\r\n\r\n     uint256 private constant MAX = ~uint256(0);\r\n     uint256 internal constant _tTotal = 1000000000 * 10**6 * 10**9;\r\n     uint256 internal _rTotal = (MAX - (MAX % _tTotal));\r\n\r\n     uint256 public _tFeeTotal;\r\n     \r\n     uint256 public tFeePercent = 100;\r\n     uint256 public marektingFeePercent = 100;\r\n     uint256 public burnFeePercent = 100;\r\n\r\n     uint256 public _tFee = 1;\r\n     uint256 internal _previoustFee = _tFee;\r\n     \r\n     uint256 public _marketingFee =1;\r\n     uint256 internal _previousmaketingFee = _marketingFee;\r\n\r\n     uint256 public _burnFee = 1;\r\n     uint256 internal _previousburnFee = _burnFee;\r\n\r\n     mapping (address => uint256) internal _rOwned;\r\n     mapping (address => uint256) internal _tOwned;\r\n     mapping (address => mapping (address => uint256)) internal _allowances;\r\n \r\n     mapping (address => bool) internal _isExcludedFromFee;\r\n     mapping (address => bool) internal _isExcluded;\r\n     address[] private _excluded;\r\n     \r\n     constructor () {\r\n         _rOwned[initialTokenReceiver] = _rTotal;      \r\n         _isExcludedFromFee[owner()] = true;\r\n         _isExcludedFromFee[initialTokenReceiver] = true;\r\n         _isExcludedFromFee[address(this)] = true;\r\n         _isExcludedFromFee[marketingFeeReceiver] = true;\r\n         _isExcludedFromFee[developmentwallet] = true;\r\n         _isExcludedFromFee[burnFeeReceiver] = true;\r\n         emit Transfer(address(0), _msgSender(), _tTotal);\r\n     }\r\n     function name() external pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n \r\n    function symbol() external pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n \r\n     function totalSupply() external pure override returns (uint256) {\r\n         return _tTotal;\r\n     }\r\n     \r\n     function getOwner() external view override returns (address) { \r\n         return owner(); \r\n         \r\n     }\r\n \r\n     function balanceOf(address account) public view override returns (uint256) {\r\n         if (_isExcluded[account]) return _tOwned[account];\r\n         return tokenFromReflection(_rOwned[account]);\r\n     }\r\n \r\n     function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n         _transfer(_msgSender(), recipient, amount);\r\n         return true;\r\n     }\r\n \r\n     function allowance(address owner, address spender) public view override returns (uint256) {\r\n         return _allowances[owner][spender];\r\n     }\r\n \r\n     function approve(address spender, uint256 amount) public override returns (bool) {\r\n         _approve(_msgSender(), spender, amount);\r\n         return true;\r\n     }\r\n \r\n     function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n         _transfer(sender, recipient, amount);\r\n         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n         return true;\r\n     }\r\n \r\n     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n         return true;\r\n     }\r\n     \r\n     \r\n     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n         return true;\r\n     }\r\n \r\n     function isExcludedFromReward(address account) public view returns (bool) {\r\n         return _isExcluded[account];\r\n     }\r\n \r\n     function totalFees() public view returns (uint256) {\r\n         return _tFeeTotal;\r\n     }\r\n \r\n     function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\r\n         require(tAmount <= _tTotal, \"Amount must be less than supply\");\r\n         if (!deductTransferFee) {\r\n             (uint256 rAmount,,,,,,) = _getValues(tAmount);\r\n             return rAmount;\r\n         } else {\r\n             (,uint256 rTransferAmount,,,,,) = _getValues(tAmount);\r\n             return rTransferAmount;\r\n         }\r\n     }\r\n \r\n     function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\r\n         require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n         uint256 currentRate =  _getRate();\r\n         return rAmount.div(currentRate);\r\n     }\r\n     \r\n     function setMarketingFeeReceiver(address _marketingFeeReceiver) external onlyOwner() {\r\n         marketingFeeReceiver = _marketingFeeReceiver;\r\n     }\r\n     \r\n     function setBurnFeeReceiver(address _burnFeeReceiver) external onlyOwner() {\r\n         burnFeeReceiver = _burnFeeReceiver;\r\n     }\r\n \r\n     function excludeFromReward(address account) public onlyOwner() {\r\n         require(!_isExcluded[account], \"Account is already excluded\");\r\n         if(_rOwned[account] > 0) {\r\n             _tOwned[account] = tokenFromReflection(_rOwned[account]);\r\n         }\r\n         _isExcluded[account] = true;\r\n         _excluded.push(account);\r\n     }\r\n \r\n     function includeInReward(address account) external onlyOwner() {\r\n         require(_isExcluded[account], \"Account is already excluded\");\r\n         for (uint256 i = 0; i < _excluded.length; i++) {\r\n             if (_excluded[i] == account) {\r\n                 _excluded[i] = _excluded[_excluded.length - 1];\r\n                 _tOwned[account] = 0;\r\n                 _isExcluded[account] = false;\r\n                 _excluded.pop();\r\n                 break;\r\n             }\r\n         }\r\n     }\r\n     function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 marketingFee, uint256 burnFee) = _getValues(tAmount);\r\n         _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n         _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \r\n         _takeFee(marketingFee, marketingFeeReceiver);\r\n         _takeFee(burnFee, burnFeeReceiver);\r\n         _reflectFee(rFee, tFee);\r\n         emit Transfer(sender, recipient, tTransferAmount);\r\n     }\r\n     \r\n     function excludeFromFee(address account) public onlyOwner() {\r\n         _isExcludedFromFee[account] = true;\r\n     }\r\n     \r\n     function includeInFee(address account) public onlyOwner() {\r\n         _isExcludedFromFee[account] = false;\r\n     }\r\n     \r\n     function setReflectionFeePercent(uint256 _tFeePercent) external onlyOwner() {\r\n         require(_tFeePercent >= 0, \"_tFeePercent should be same or bigger than 0\");\r\n         require(_tFeePercent <= 100, \"_tFeePercent should be same or smaller than 100\");\r\n         tFeePercent = _tFeePercent;\r\n     }\r\n     \r\n     function setMarketingFeePercent(uint256 _marektingFeePercent) external onlyOwner() {\r\n         require(_marektingFeePercent >= 0, \"_marektingFeePercent should be same or bigger than 0\");\r\n         require(_marektingFeePercent <= 100, \"_marektingFeePercent should be same or smaller than 100\");\r\n         marektingFeePercent = _marektingFeePercent;\r\n     }\r\n     function setBurnFeePercent(uint256 _burnFeePercent) external onlyOwner() {\r\n         require(_burnFeePercent >= 0, \"_burnFeePercent should be same or bigger than 0\");\r\n         require(_burnFeePercent <= 100, \"_burnFeePercent should be same or smaller than 100\");\r\n         burnFeePercent = _burnFeePercent;\r\n     }   \r\n \r\n     function _reflectFee(uint256 rFee, uint256 tFee) internal {\r\n         _rTotal = _rTotal.sub(rFee);\r\n         _tFeeTotal = _tFeeTotal.add(tFee);\r\n     }\r\n \r\n     function _getValues(uint256 tAmount) internal view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\r\n         (uint256 tTransferAmount, uint256 tFee, uint256 marketingFee, uint256 burnFee) = _getTValues(tAmount);\r\n         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, marketingFee, burnFee, _getRate());\r\n         return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, marketingFee, burnFee);\r\n     }\r\n \r\n     function _getTValues(uint256 tAmount) internal view returns (uint256, uint256, uint256, uint256) {\r\n         uint256 tFee = calculateReflectionFee(tAmount);\r\n         uint256 marketingFee = calculateMarketingFee(tAmount);\r\n         uint256 burnFee = calculateBurnFee(tAmount);\r\n         uint256 tTransferAmount = tAmount.sub(tFee).sub(marketingFee).sub(burnFee);\r\n         return (tTransferAmount, tFee, marketingFee, burnFee);\r\n     }\r\n \r\n     function _getRValues(uint256 tAmount, uint256 tFee, uint256 marketingFee, uint256 burnFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n         uint256 rAmount = tAmount.mul(currentRate);\r\n         uint256 rFee = tFee.mul(currentRate);\r\n         uint256 rmarketingFee = marketingFee.mul(currentRate);\r\n         uint256 rburnFee = burnFee.mul(currentRate);\r\n         uint256 rTransferAmount = rAmount.sub(rFee).sub(rmarketingFee).sub(rburnFee);\r\n         return (rAmount, rTransferAmount, rFee);\r\n     }\r\n \r\n     function _getRate() internal view returns(uint256) {\r\n         (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n         return rSupply.div(tSupply);\r\n     }\r\n \r\n     function _getCurrentSupply() internal view returns(uint256, uint256) {\r\n         uint256 rSupply = _rTotal;\r\n         uint256 tSupply = _tTotal;      \r\n         for (uint256 i = 0; i < _excluded.length; i++) {\r\n             if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\r\n             rSupply = rSupply.sub(_rOwned[_excluded[i]]);\r\n             tSupply = tSupply.sub(_tOwned[_excluded[i]]);\r\n         }\r\n         if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n         return (rSupply, tSupply);\r\n     }\r\n     \r\n     function calculateReflectionFee(uint256 _amount) internal view returns (uint256) {\r\n         return _amount.mul(_tFee).mul(tFeePercent).div(\r\n             10**4\r\n         );\r\n     }\r\n\r\n     function calculateMarketingFee(uint256 _amount) internal view returns (uint256) {\r\n         return _amount.mul(_marketingFee).mul(marektingFeePercent).div(\r\n             10**4\r\n         );\r\n     }\r\n\r\n     function calculateBurnFee(uint256 _amount) internal view returns (uint256) {\r\n         return _amount.mul(_burnFee).mul(burnFeePercent).div(\r\n             10**4\r\n         );\r\n     }\r\n     \r\n     function removeAllFee() internal {\r\n         if(_tFee == 0 && _marketingFee == 0 &&  _burnFee == 0) return;\r\n         \r\n         _previoustFee = _tFee;\r\n         _previousmaketingFee = _marketingFee;\r\n         _previousburnFee = _burnFee;\r\n         \r\n         _tFee = 0;\r\n         _marketingFee = 0;\r\n         _burnFee = 0;\r\n     }\r\n     \r\n     function restoreAllFee() internal {\r\n        _tFee = _previoustFee;\r\n        _marketingFee = _previousmaketingFee;\r\n        _burnFee = _previousburnFee;\r\n     }\r\n     \r\n     function isExcludedFromFee(address account) public view returns(bool) {\r\n         return _isExcludedFromFee[account];\r\n     }\r\n     \r\n \r\n     function _approve(address owner, address spender, uint256 amount) internal {\r\n         require(owner != address(0), \"ERC20: approve from the zero address\");\r\n         require(spender != address(0), \"ERC20: approve to the zero address\");\r\n \r\n         _allowances[owner][spender] = amount;\r\n         emit Approval(owner, spender, amount);\r\n     }\r\n \r\n     function _transfer(address from, address to, uint256 amount) internal {\r\n         require(from != address(0), \"ERC20: transfer from the zero address\");\r\n         require(to != address(0), \"ERC20: transfer to the zero address\");\r\n         require(from != address(deadAddress), \"Token: transfer from the burn address\");\r\n         require(amount > 0, \"Transfer amount must be greater than zero\");\r\n         bool takeFee = true;\r\n         \r\n         if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\r\n             takeFee = false;\r\n         }         \r\n         _tokenTransfer(from,to,amount,takeFee);\r\n     }\r\n\r\n     function _takeFee(uint256 fee, address feeRecevier) internal {\r\n        uint256 currentRate =  _getRate();\r\n        uint256 rFee = fee.mul(currentRate);\r\n        _rOwned[feeRecevier] = _rOwned[feeRecevier].add(rFee);\r\n        if(_isExcluded[feeRecevier])\r\n            _tOwned[feeRecevier] = _tOwned[feeRecevier].add(rFee);\r\n\r\n     }\r\n\r\n     function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\r\n         if(!takeFee)\r\n             removeAllFee();\r\n         \r\n         if (_isExcluded[sender] && !_isExcluded[recipient]) {\r\n             _transferFromExcluded(sender, recipient, amount);\r\n         } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\r\n             _transferToExcluded(sender, recipient, amount);\r\n         } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\r\n             _transferStandard(sender, recipient, amount);\r\n         } else if (_isExcluded[sender] && _isExcluded[recipient]) {\r\n             _transferBothExcluded(sender, recipient, amount);\r\n         } else {\r\n             _transferStandard(sender, recipient, amount);\r\n         }\r\n         \r\n         if(!takeFee)\r\n             restoreAllFee();\r\n     }\r\n \r\n     function _transferStandard(address sender, address recipient, uint256 tAmount) private {\r\n         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 marketingFee, uint256 burnFee) = _getValues(tAmount);\r\n         _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n         _takeFee(marketingFee, marketingFeeReceiver);\r\n         _takeFee(burnFee, burnFeeReceiver);\r\n         _reflectFee(rFee, tFee);\r\n         emit Transfer(sender, recipient, tTransferAmount);\r\n     }\r\n \r\n     function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 marketingFee, uint256 burnFee) = _getValues(tAmount);\r\n         _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \r\n         _takeFee(marketingFee, marketingFeeReceiver);\r\n         _takeFee(burnFee, burnFeeReceiver);\r\n         _reflectFee(rFee, tFee);\r\n         emit Transfer(sender, recipient, tTransferAmount);\r\n     }\r\n \r\n     function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 marketingFee, uint256 burnFee) = _getValues(tAmount);\r\n         _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n         _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \r\n         _takeFee(marketingFee, marketingFeeReceiver);\r\n         _takeFee(burnFee, burnFeeReceiver);\r\n         _reflectFee(rFee, tFee);\r\n         emit Transfer(sender, recipient, tTransferAmount);\r\n     }\r\n\r\n     receive() external payable {}\r\n }"}}}