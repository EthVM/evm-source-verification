{"language":"Solidity","settings":{"evmVersion":"byzantium","libraries":{"Lottery.sol":{"Helper":"0x15417d5f299423b8f60c9e1443038b8efdfa6d6c"}},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Lottery.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n*   gibmireinbier - Full Stack Blockchain Developer\r\n*   0xA4a799086aE18D7db6C4b57f496B081b44888888\r\n*   gibmireinbier@gmail.com\r\n*/\r\n\r\n/*\r\n    CHANGELOGS:\r\n    . GrandPot : 2 rewards per round\r\n        5% pot with winner rate 100%, \r\n            no dividends, no fund to F2M contract\r\n\r\n        15% pot with winner rate dynamic, init at 1st round with rate = ((initGrandPot * 2 * 100 / 68) * avgMul / SLP) + 1000;\r\n            push 12% to F2M contract (10% dividends, 2% fund) => everybody happy! // --REMOVED\r\n            if total tickets > rate then 100% got winner\r\n            no winner : increased in the next round\r\n            got winner : decreased in the next round\r\n\r\n    . Bounty : received 30% bought tickets of bountyhunter back in the next round instead of ETH\r\n        (bonus tickets not included)\r\n    . SBountys : received 10% bought tickets of sbountyhunter back in the next round instead of ETH\r\n        (bonus tickets not included)\r\n        claimable only in pending time between 2 rounds\r\n\r\n    . 1% bought tickets as bonus to next round (1st buy turn)\r\n        (bonus Tickets not included)\r\n\r\n    . Jackpot: rates increased from (1/Rate1, 1/Rate2) to (1/(Rate1 - 1), 1/(Rate2 - 1)) after each buy\r\n        and reseted if jackpot triggered.\r\n        jackpot rate = (ethAmount / 0.1) * rate, max winrate = 1/2\r\n        no dividends, no fund to F2M contract\r\n\r\n    . Ticketsnumbers start from 1 in every rounds\r\n\r\n    . Multiplier system: \r\n        . all tickets got same weight = 1\r\n        . 2 decimals in stead of 0\r\n        . Multi = (grandPot / initGrandPot) * x * y * z\r\n            x = (11 - timer1) / 4  + 1 (unit = hour(s), max = 15/4)\r\n                timer1 updated real time, but x got delay 60 seconds from last buy\r\n\r\n            y = (6 - timer2) / 3 + 1 (unit = day(s), max = 3)\r\n\r\n            z = 4 if isGoldenMin, else 1\r\n            GOLDEN MINUTE : realTime, set = 8 atm\r\n            that means from x: 08 : 00 to x:08:59 is goldenMin and z = 4\r\n\r\n    . Waiting time between 2 rounds 24 hours -> 18 hours\r\n\r\n    . addPot :\r\n        80% -> grandPot\r\n        10% -> majorPot\r\n        10% -> minorPot\r\n\r\n    BUGS FIXED:\r\n    . Jackpot rate increased with multi = ethAmount / 0.1 (ether)\r\n        no more split buy required\r\n    . GrandPot getWeightRange() problems\r\n\r\n    AUTHORS:\r\n    . Seizo : \r\n        Tickets bonus per 100 tickets,\r\n        setLastRound anytime\r\n        remove pushDividend when grandPot, jackpot triggered, called only on tickets buying\r\n        remove round0\r\n\r\n    . Clark : Multiplier system\r\n        0xd9cd43AD9cD04183b5083E9E6c8DD0CE0c08eDe3\r\n\r\n    . GMEB : Tickets bounty system, Math. formulas\r\n        0xA4a799086aE18D7db6C4b57f496B081b44888888\r\n\r\n    . Kuroo Hazama : Dynamic rate\r\n        0x1E55fa952FCBc1f917746277C9C99cf65D53EbC8\r\n*/\r\n\r\nlibrary Helper {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant public ZOOM = 1000;\r\n    uint256 constant public SDIVIDER = 3450000;\r\n    uint256 constant public PDIVIDER = 3450000;\r\n    uint256 constant public RDIVIDER = 1580000;\r\n    // Starting LS price (SLP)\r\n    uint256 constant public SLP = 0.002 ether;\r\n    // Starting Added Time (SAT)\r\n    uint256 constant public SAT = 30; // seconds\r\n    // Price normalization (PN)\r\n    uint256 constant public PN = 777;\r\n    // EarlyIncome base\r\n    uint256 constant public PBASE = 13;\r\n    uint256 constant public PMULTI = 26;\r\n    uint256 constant public LBase = 1;\r\n\r\n    uint256 constant public ONE_HOUR = 3600;\r\n    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\r\n    //uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\r\n    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\r\n    uint256 constant public TIMEOUT2 = 7 * ONE_DAY;\r\n    \r\n    function bytes32ToString (bytes32 data)\r\n        public\r\n        pure\r\n        returns (string) \r\n    {\r\n        bytes memory bytesString = new bytes(32);\r\n        for (uint j=0; j<32; j++) {\r\n            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[j] = char;\r\n            }\r\n        }\r\n        return string(bytesString);\r\n    }\r\n    \r\n    function uintToBytes32(uint256 n)\r\n        public\r\n        pure\r\n        returns (bytes32) \r\n    {\r\n        return bytes32(n);\r\n    }\r\n    \r\n    function bytes32ToUint(bytes32 n) \r\n        public\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        return uint256(n);\r\n    }\r\n    \r\n    function stringToBytes32(string memory source) \r\n        public\r\n        pure\r\n        returns (bytes32 result) \r\n    {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n    \r\n    function stringToUint(string memory source) \r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return bytes32ToUint(stringToBytes32(source));\r\n    }\r\n    \r\n    function uintToString(uint256 _uint) \r\n        public\r\n        pure\r\n        returns (string)\r\n    {\r\n        return bytes32ToString(uintToBytes32(_uint));\r\n    }\r\n\r\n/*     \r\n    function getSlice(uint256 begin, uint256 end, string text) public pure returns (string) {\r\n        bytes memory a = new bytes(end-begin+1);\r\n        for(uint i = 0; i <= end - begin; i++){\r\n            a[i] = bytes(text)[i + begin - 1];\r\n        }\r\n        return string(a);    \r\n    }\r\n */\r\n    function validUsername(string _username)\r\n        public\r\n        pure\r\n        returns(bool)\r\n    {\r\n        uint256 len = bytes(_username).length;\r\n        // Im Raum [4, 18]\r\n        if ((len < 4) || (len > 18)) return false;\r\n        // Letzte Char != ' '\r\n        if (bytes(_username)[len-1] == 32) return false;\r\n        // Erste Char != '0'\r\n        return uint256(bytes(_username)[0]) != 48;\r\n    }\r\n\r\n    // Lottery Helper\r\n\r\n    // Seconds added per LT = SAT - ((Current no. of LT + 1) / SDIVIDER)^6\r\n    function getAddedTime(uint256 _rTicketSum, uint256 _tAmount)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        //Luppe = 10000 = 10^4\r\n        uint256 base = (_rTicketSum + 1).mul(10000) / SDIVIDER;\r\n        uint256 expo = base;\r\n        expo = expo.mul(expo).mul(expo); // ^3\r\n        expo = expo.mul(expo); // ^6\r\n        // div 10000^6\r\n        expo = expo / (10**24);\r\n\r\n        if (expo > SAT) return 0;\r\n        return (SAT - expo).mul(_tAmount);\r\n    }\r\n\r\n    function getNewEndTime(uint256 toAddTime, uint256 slideEndTime, uint256 fixedEndTime)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _slideEndTime = (slideEndTime).add(toAddTime);\r\n        uint256 timeout = _slideEndTime.sub(block.timestamp);\r\n        // timeout capped at TIMEOUT1\r\n        if (timeout > TIMEOUT1) timeout = TIMEOUT1;\r\n        _slideEndTime = (block.timestamp).add(timeout);\r\n        // Capped at fixedEndTime\r\n        if (_slideEndTime > fixedEndTime)  return fixedEndTime;\r\n        return _slideEndTime;\r\n    }\r\n\r\n    // get random in range [1, _range] with _seed\r\n    function getRandom(uint256 _seed, uint256 _range)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        if (_range == 0) return _seed;\r\n        return (_seed % _range) + 1;\r\n    }\r\n\r\n\r\n    function getEarlyIncomeMul(uint256 _ticketSum)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        // Early-Multiplier = 1 + PBASE / (1 + PMULTI * ((Current No. of LT)/RDIVIDER)^6)\r\n        uint256 base = _ticketSum * ZOOM / RDIVIDER;\r\n        uint256 expo = base.mul(base).mul(base); //^3\r\n        expo = expo.mul(expo) / (ZOOM**6); //^6\r\n        return (1 + PBASE / (1 + expo.mul(PMULTI)));\r\n    }\r\n\r\n    // get reveiced Tickets, based on current round ticketSum\r\n    function getTAmount(uint256 _ethAmount, uint256 _ticketSum) \r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 _tPrice = getTPrice(_ticketSum);\r\n        return _ethAmount.div(_tPrice);\r\n    }\r\n\r\n    function isGoldenMin(\r\n        uint256 _slideEndTime\r\n        )\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        uint256 _restTime1 = _slideEndTime.sub(block.timestamp);\r\n        // golden min. exist if timer1 < 6 hours\r\n        if (_restTime1 > 6 hours) return false;\r\n        uint256 _min = (block.timestamp / 60) % 60;\r\n        return _min == 8;\r\n    }\r\n\r\n    // percent ZOOM = 100, ie. mul = 2.05 return 205\r\n    // Lotto-Multiplier = ((grandPot / initGrandPot)^2) * x * y * z\r\n    // x = (TIMEOUT1 - timer1 - 1) / 4 + 1 => (unit = hour, max = 11/4 + 1 = 3.75) \r\n    // y = (TIMEOUT2 - timer2 - 1) / 3 + 1) => (unit = day max = 3)\r\n    // z = isGoldenMin ? 4 : 1\r\n    function getTMul(\r\n        uint256 _initGrandPot,\r\n        uint256 _grandPot, \r\n        uint256 _slideEndTime, \r\n        uint256 _fixedEndTime\r\n        )\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _pZoom = 100;\r\n        uint256 base = _initGrandPot != 0 ?_pZoom.mul(_grandPot) / _initGrandPot : _pZoom;\r\n        uint256 expo = base.mul(base);\r\n        uint256 _timer1 = _slideEndTime.sub(block.timestamp) / 1 hours; // 0.. 11\r\n        uint256 _timer2 = _fixedEndTime.sub(block.timestamp) / 1 days; // 0 .. 6\r\n        uint256 x = (_pZoom * (11 - _timer1) / 4) + _pZoom; // [1, 3.75]\r\n        uint256 y = (_pZoom * (6 - _timer2) / 3) + _pZoom; // [1, 3]\r\n        uint256 z = isGoldenMin(_slideEndTime) ? 4 : 1;\r\n        uint256 res = expo.mul(x).mul(y).mul(z) / (_pZoom ** 3); // ~ [1, 90]\r\n        return res;\r\n    }\r\n\r\n    // get ticket price, based on current round ticketSum\r\n    //unit in ETH, no need / zoom^6\r\n    function getTPrice(uint256 _ticketSum)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 base = (_ticketSum + 1).mul(ZOOM) / PDIVIDER;\r\n        uint256 expo = base;\r\n        expo = expo.mul(expo).mul(expo); // ^3\r\n        expo = expo.mul(expo); // ^6\r\n        uint256 tPrice = SLP + expo / PN;\r\n        return tPrice;\r\n    }\r\n\r\n    // used to draw grandpot results\r\n    // weightRange = roundWeight * grandpot / (grandpot - initGrandPot)\r\n    // grandPot = initGrandPot + round investedSum(for grandPot)\r\n    function getWeightRange(uint256 initGrandPot)\r\n        public\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 avgMul = 30;\r\n        return ((initGrandPot * 2 * 100 / 68) * avgMul / SLP) + 1000;\r\n    }\r\n\r\n    // dynamic rate _RATE = n\r\n    // major rate = 1/n with _RATE = 1000 999 ... 1\r\n    // minor rate = 1/n with _RATE = 500 499 ... 1\r\n    // loop = _ethAmount / _MIN\r\n    // lose rate = ((n- 1) / n) * ((n- 2) / (n - 1)) * ... * ((n- k) / (n - k + 1)) = (n - k) / n\r\n    function isJackpot(\r\n        uint256 _seed,\r\n        uint256 _RATE,\r\n        uint256 _MIN,\r\n        uint256 _ethAmount\r\n        )\r\n        public\r\n        pure\r\n        returns(bool)\r\n    {\r\n        // _RATE >= 2\r\n        uint256 k = _ethAmount / _MIN;\r\n        if (k == 0) return false;\r\n        // LOSE RATE MIN 50%, WIN RATE MAX 50%\r\n        uint256 _loseCap = _RATE / 2;\r\n        // IF _RATE - k > _loseCap\r\n        if (_RATE > k + _loseCap) _loseCap = _RATE - k;\r\n\r\n        bool _lose = (_seed % _RATE) < _loseCap;\r\n        return !_lose;\r\n    }\r\n}\r\n\r\ncontract Lottery {\r\n    using SafeMath for uint256;\r\n\r\n    modifier withdrawRight(){\r\n        require(msg.sender == address(bankContract), \"Bank only\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDevTeam() {\r\n        require(msg.sender == devTeam, \"only for development team\");\r\n        _;\r\n    }\r\n\r\n    modifier buyable() {\r\n        require(block.timestamp > round[curRoundId].startTime, \"not ready to sell Ticket\");\r\n        require(block.timestamp < round[curRoundId].slideEndTime, \"round over\");\r\n        require(block.number <= round[curRoundId].keyBlockNr, \"round over\");\r\n        _;\r\n    }\r\n\r\n    modifier notStarted() {\r\n        require(block.timestamp < round[curRoundId].startTime, \"round started\");\r\n        _;\r\n    }\r\n\r\n    enum RewardType {\r\n        Minor,\r\n        Major,\r\n        Grand,\r\n        Bounty\r\n    }\r\n\r\n    // 1 buy = 1 slot = _ethAmount => (tAmount, tMul) \r\n    struct Slot {\r\n        address buyer;\r\n        uint256 rId;\r\n        // ticket numbers in range and unique in all rounds\r\n        uint256 tNumberFrom;\r\n        uint256 tNumberTo;\r\n        uint256 ethAmount;\r\n        uint256 salt;\r\n    }\r\n\r\n    struct Round {\r\n        // earlyIncome weight sum\r\n        uint256 rEarlyIncomeWeight;\r\n        // blockNumber to get hash as random seed\r\n        uint256 keyBlockNr;\r\n        mapping(address => bool) pBonusReceived;\r\n\r\n        mapping(address => uint256) pBoughtTicketSum;\r\n        mapping(address => uint256) pTicketSum;\r\n        mapping(address => uint256) pInvestedSum;\r\n\r\n        // early income weight by address\r\n        mapping(address => uint256) pEarlyIncomeWeight;\r\n        mapping(address => uint256) pEarlyIncomeCredit;\r\n        mapping(address => uint256) pEarlyIncomeClaimed;\r\n        // early income per weight\r\n        uint256 ppw;\r\n        // endTime increased every slot sold\r\n        // endTime limited by fixedEndTime\r\n        uint256 startTime;\r\n        uint256 slideEndTime;\r\n        uint256 fixedEndTime;\r\n\r\n        // ticketSum from round 1 to this round\r\n        uint256 ticketSum;\r\n        // investedSum from round 1 to this round\r\n        uint256 investedSum;\r\n        // number of slots from round 1 to this round\r\n        uint256 slotSum;\r\n    }\r\n\r\n    // round started with this grandPot amount,\r\n    // used to calculate the rate for grandPot results\r\n    // init in roundInit function\r\n    uint256 public initGrandPot;\r\n\r\n    Slot[] public slot;\r\n    // slotId logs by address\r\n    mapping( address => uint256[]) pSlot;\r\n    mapping( address => uint256) public pSlotSum;\r\n\r\n    // logs by address\r\n    mapping( address => uint256) public pTicketSum;\r\n    mapping( address => uint256) public pInvestedSum;\r\n\r\n    CitizenInterface public citizenContract;\r\n    F2mInterface public f2mContract;\r\n    BankInterface public bankContract;\r\n    RewardInterface public rewardContract;\r\n\r\n    address public devTeam;\r\n\r\n    uint256 constant public ZOOM = 1000;\r\n    uint256 constant public ONE_HOUR = 60 * 60;\r\n    uint256 constant public ONE_DAY = 24 * ONE_HOUR;\r\n    uint256 constant public TIMEOUT0 = 3 * ONE_HOUR;\r\n    uint256 constant public TIMEOUT1 = 12 * ONE_HOUR;\r\n    uint256 constant public TIMEOUT2 = 7 * ONE_DAY;\r\n    uint256 constant public FINALIZE_WAIT_DURATION = 60; // 60 Seconds\r\n    uint256 constant public NEWROUND_WAIT_DURATION = 18 * ONE_HOUR; // 24 Hours\r\n\r\n    // 15 seconds on Ethereum, 12 seconds used instead to make sure blockHash unavaiable\r\n    // when slideEndTime reached\r\n    // keyBlockNumber will be estimated again after every slot buy\r\n    uint256 constant public BLOCK_TIME = 12;\r\n    uint256 constant public MAX_BLOCK_DISTANCE = 250;\r\n\r\n    uint256 constant public TBONUS_RATE = 100;\r\n    uint256 public CASHOUT_REQ = 1;\r\n\r\n    uint256 public GRAND_RATE;\r\n    uint256 public MAJOR_RATE = 1001;\r\n    uint256 public MINOR_RATE = 501;\r\n    uint256 constant public MAJOR_MIN = 0.1 ether;\r\n    uint256 constant public MINOR_MIN = 0.1 ether;\r\n\r\n    //Bonus Tickets : Bounty + 7 sBounty\r\n    uint256 public bountyPercent = 30;\r\n    uint256 public sBountyPercent = 10;\r\n\r\n    //uint256 public toNextPotPercent = 27;\r\n    uint256 public grandRewardPercent = 15;\r\n    uint256 public sGrandRewardPercent = 5;\r\n    uint256 public jRewardPercent = 60;\r\n\r\n    uint256 public toTokenPercent = 12; // 10% dividends 2% fund\r\n    uint256 public toBuyTokenPercent = 1;\r\n    uint256 public earlyIncomePercent = 22;\r\n    uint256 public toRefPercent = 15;\r\n\r\n    // sum == 100% = toPotPercent/100 * investedSum\r\n    // uint256 public grandPercent = 80; //68;\r\n    uint256 public majorPercent = 10; // 24;\r\n    uint256 public minorPercent = 10; // 8;\r\n\r\n    uint256 public grandPot;\r\n    uint256 public majorPot;\r\n    uint256 public minorPot;\r\n\r\n    uint256 public curRoundId;\r\n    uint256 public lastRoundId = 88888888;\r\n\r\n    mapping (address => uint256) public rewardBalance;\r\n    // used to save gas on earlyIncome calculating, curRoundId never included\r\n    // only earlyIncome from round 1st to curRoundId-1 are fixed\r\n    mapping (address => uint256) public lastWithdrawnRound;\r\n    mapping (address => uint256) public earlyIncomeScannedSum;\r\n\r\n    mapping (uint256 => Round) public round;\r\n\r\n    // Current Round\r\n\r\n    // first SlotId in last Block to fire jackpot\r\n    uint256 public jSlot;\r\n    // jackpot results of all slots in same block will be drawed at the same time,\r\n    // by player, who buys the first slot in next block\r\n    uint256 public lastBlockNr;\r\n    // added by slot salt after every slot buy\r\n    // does not matter with overflow\r\n    uint256 public curRSalt;\r\n    // ticket sum of current round\r\n    uint256 public curRTicketSum;\r\n\r\n    uint256 public lastBuyTime;\r\n    uint256 public lastEndTime;\r\n    uint256 constant multiDelayTime = 60;\r\n\r\n    constructor (address _devTeam)\r\n        public\r\n    {\r\n        // register address in network\r\n        DevTeamInterface(_devTeam).setLotteryAddress(address(this));\r\n        devTeam = _devTeam;\r\n    }\r\n\r\n    // _contract = [f2mAddress, bankAddress, citizenAddress, lotteryAddress, rewardAddress, whitelistAddress];\r\n    function joinNetwork(address[6] _contract)\r\n        public\r\n    {\r\n        require(address(citizenContract) == 0x0,\"already setup\");\r\n        f2mContract = F2mInterface(_contract[0]);\r\n        bankContract = BankInterface(_contract[1]);\r\n        citizenContract = CitizenInterface(_contract[2]);\r\n        //lotteryContract = LotteryInterface(lotteryAddress);\r\n        rewardContract = RewardInterface(_contract[4]);\r\n    }\r\n\r\n    function activeFirstRound()\r\n        public\r\n        onlyDevTeam()\r\n    {\r\n        require(curRoundId == 0, \"already activated\");\r\n        initRound();\r\n        GRAND_RATE = getWeightRange();\r\n    }\r\n\r\n    // Core Functions\r\n\r\n    function pushToPot() \r\n        public \r\n        payable\r\n    {\r\n        addPot(msg.value);\r\n    }\r\n\r\n    function checkpoint() \r\n        private\r\n    {\r\n        // dummy slot between every 2 rounds\r\n        // dummy slot never win jackpot cause of min 0.1 ETH\r\n        Slot memory _slot;\r\n        // _slot.tNumberTo = round[curRoundId].ticketSum;\r\n        slot.push(_slot);\r\n\r\n        Round memory _round;\r\n        _round.startTime = NEWROUND_WAIT_DURATION.add(block.timestamp);\r\n        // started with 3 hours timeout\r\n        _round.slideEndTime = TIMEOUT0 + _round.startTime;\r\n        _round.fixedEndTime = TIMEOUT2 + _round.startTime;\r\n        _round.keyBlockNr = genEstKeyBlockNr(_round.slideEndTime);\r\n        _round.ticketSum = round[curRoundId].ticketSum;\r\n        _round.investedSum = round[curRoundId].investedSum;\r\n        _round.slotSum = slot.length;\r\n\r\n        curRoundId = curRoundId + 1;\r\n        round[curRoundId] = _round;\r\n\r\n        initGrandPot = grandPot;\r\n        curRTicketSum = 0;\r\n    }\r\n\r\n    // from round 28+ function -- REMOVED\r\n    function isLastRound()\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return (curRoundId == lastRoundId);\r\n    }\r\n\r\n    function goNext()\r\n        private\r\n    {\r\n        grandPot = 0;\r\n        majorPot = 0;\r\n        minorPot = 0;\r\n        f2mContract.pushDividends.value(this.balance)();\r\n        // never start\r\n        round[curRoundId].startTime = block.timestamp * 10;\r\n        round[curRoundId].slideEndTime = block.timestamp * 10 + 1;\r\n        CASHOUT_REQ = 0;\r\n    }\r\n\r\n    function initRound()\r\n        private\r\n    {\r\n        // update all Round Log\r\n        checkpoint();\r\n        if (isLastRound()) goNext();\r\n        updateMulti();\r\n    }\r\n\r\n    function finalizeable() \r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        uint256 finalizeTime = FINALIZE_WAIT_DURATION.add(round[curRoundId].slideEndTime);\r\n        if (finalizeTime > block.timestamp) return false; // too soon to finalize\r\n        if (getEstKeyBlockNr(curRoundId) >= block.number) return false; //block hash not exist\r\n        return curRoundId > 0;\r\n    }\r\n\r\n    // bounty\r\n    function finalize()\r\n        public\r\n    {\r\n        require(finalizeable(), \"Not ready to draw results\");\r\n        uint256 _pRoundTicketSum = round[curRoundId].pBoughtTicketSum[msg.sender];\r\n        uint256 _bountyTicketSum = _pRoundTicketSum * bountyPercent / 100;\r\n        endRound(msg.sender, _bountyTicketSum);\r\n        initRound();\r\n        mintSlot(msg.sender, _bountyTicketSum, 0, 0);\r\n    }\r\n\r\n    function mintReward(\r\n        address _lucker,\r\n        uint256 _winNr,\r\n        uint256 _slotId,\r\n        uint256 _value,\r\n        RewardType _rewardType)\r\n        private\r\n    {\r\n        // add reward balance if its not Bounty Type and winner != 0x0\r\n        if ((_rewardType != RewardType.Bounty) && (_lucker != 0x0))\r\n            rewardBalance[_lucker] = rewardBalance[_lucker].add(_value);\r\n        // reward log\r\n        rewardContract.mintReward(\r\n            _lucker,\r\n            curRoundId,\r\n            _winNr,\r\n            slot[_slotId].tNumberFrom,\r\n            slot[_slotId].tNumberTo,\r\n            _value,\r\n            uint256(_rewardType)\r\n        );\r\n    }\r\n\r\n    function mintSlot(\r\n        address _buyer,\r\n        // uint256 _rId,\r\n        // ticket numbers in range and unique in all rounds\r\n        // uint256 _tNumberFrom,\r\n        // uint256 _tNumberTo,\r\n        uint256 _tAmount,\r\n        uint256 _ethAmount,\r\n        uint256 _salt\r\n        )\r\n        private\r\n    {\r\n        uint256 _tNumberFrom = curRTicketSum + 1;\r\n        uint256 _tNumberTo = _tNumberFrom + _tAmount - 1;\r\n        Slot memory _slot;\r\n        _slot.buyer = _buyer;\r\n        _slot.rId = curRoundId;\r\n        _slot.tNumberFrom = _tNumberFrom;\r\n        _slot.tNumberTo = _tNumberTo;\r\n        _slot.ethAmount = _ethAmount;\r\n        _slot.salt = _salt;\r\n        slot.push(_slot);\r\n        updateTicketSum(_buyer, _tAmount);\r\n        round[curRoundId].slotSum = slot.length;\r\n        pSlot[_buyer].push(slot.length - 1);\r\n    }\r\n\r\n    function jackpot()\r\n        private\r\n    {\r\n        // get blocknumber to get blockhash\r\n        uint256 keyBlockNr = getKeyBlockNr(lastBlockNr);//block.number;\r\n        // salt not effected by jackpot, too risk\r\n        uint256 seed = getSeed(keyBlockNr);\r\n        // slot numberic from 1 ... totalSlot(round)\r\n        // jackpot for all slot in last block, jSlot <= i <= lastSlotId (=slotSum - 1)\r\n        // _to = first Slot in new block\r\n        //uint256 _to = round[curRoundId].slotSum;\r\n\r\n        uint256 jReward;\r\n        // uint256 toF2mAmount;\r\n        address winner;\r\n        // jackpot check for slots in last block\r\n        while (jSlot + 1 < round[curRoundId].slotSum) {\r\n            // majorPot\r\n            if (MAJOR_RATE > 2) MAJOR_RATE--;\r\n            if (Helper.isJackpot(seed, MAJOR_RATE, MAJOR_MIN, slot[jSlot].ethAmount)){\r\n\r\n                winner = slot[jSlot].buyer;\r\n                jReward = majorPot / 100 * jRewardPercent;\r\n                mintReward(winner, 0, jSlot, jReward, RewardType.Major);\r\n                majorPot = majorPot - jReward;\r\n                MAJOR_RATE = 1001;\r\n            }\r\n            seed = seed + jSlot;\r\n            // minorPot\r\n            if (MINOR_RATE > 2) MINOR_RATE--;\r\n            if (Helper.isJackpot(seed, MINOR_RATE, MINOR_MIN, slot[jSlot].ethAmount)){\r\n\r\n                winner = slot[jSlot].buyer;\r\n                jReward = minorPot / 100 * jRewardPercent;\r\n                mintReward(winner, 0, jSlot, jReward, RewardType.Minor);\r\n                minorPot = minorPot - jReward;\r\n                MINOR_RATE = 501;\r\n            }\r\n            seed = seed + jSlot;\r\n            jSlot++;\r\n        }\r\n    }\r\n\r\n    function endRound(address _bountyHunter, uint256 _bountyTicketSum)\r\n        private\r\n    {\r\n        // GRAND_RATE = GRAND_RATE * 9 / 10; // REMOVED\r\n        uint256 _rId = curRoundId;\r\n        uint256 keyBlockNr = getKeyBlockNr(round[_rId].keyBlockNr);\r\n        // curRSalt SAFE, CHECKED\r\n        uint256 _seed = getSeed(keyBlockNr) + curRSalt;\r\n        uint256 onePercent = grandPot / 100;\r\n\r\n        // 0 : 5% grandPot, 100% winRate\r\n        // 1 : 15% grandPot, dynamic winRate\r\n        uint256[2] memory rGrandReward = [\r\n            onePercent * sGrandRewardPercent, \r\n            onePercent * grandRewardPercent\r\n        ];\r\n        uint256[2] memory weightRange = [\r\n            curRTicketSum, \r\n            GRAND_RATE > curRTicketSum ? GRAND_RATE : curRTicketSum\r\n        ];\r\n        // REMOVED\r\n        // uint256[2] memory toF2mAmount = [0, onePercent * toTokenPercent];\r\n\r\n        // 1st turn for small grandPot (val = 5% rate = 100%)\r\n        // 2nd turn for big grandPot (val = 15%, rate = max(GRAND_RATE, curRTicketSum), 12% to F2M contract if got winner)\r\n\r\n        for (uint256 i = 0; i < 2; i++){\r\n            address _winner = 0x0;\r\n            uint256 _winSlot = 0;\r\n            uint256 _winNr = Helper.getRandom(_seed, weightRange[i]);\r\n            // if winNr > curRTicketSum => no winner this turn\r\n            // win Slot : fromWeight <= winNr <= toWeight\r\n            // got winner this rolling turn\r\n            if (_winNr <= curRTicketSum) {\r\n                // grandPot -= rGrandReward[i] + toF2mAmount[i];\r\n                grandPot -= rGrandReward[i];\r\n                // big grandPot 15%\r\n                if (i == 1) {\r\n                    GRAND_RATE = GRAND_RATE * 2;\r\n                    // f2mContract.pushDividends.value(toF2mAmount[i])();\r\n                }\r\n                _winSlot = getWinSlot(_winNr);\r\n                _winner = slot[_winSlot].buyer;\r\n                _seed = _seed + (_seed / 10);\r\n            }\r\n            mintReward(_winner, _winNr, _winSlot, rGrandReward[i], RewardType.Grand);\r\n        }\r\n\r\n        mintReward(_bountyHunter, 0, 0, _bountyTicketSum, RewardType.Bounty);\r\n        rewardContract.resetCounter(curRoundId);\r\n        GRAND_RATE = (GRAND_RATE / 100) * 99 + 1;\r\n    }\r\n\r\n    function buy(string _sSalt)\r\n        public\r\n        payable\r\n    {\r\n        buyFor(_sSalt, msg.sender);\r\n    }\r\n\r\n    function updateInvested(address _buyer, uint256 _ethAmount)\r\n        private\r\n    {\r\n        round[curRoundId].investedSum += _ethAmount;\r\n        round[curRoundId].pInvestedSum[_buyer] += _ethAmount;\r\n        pInvestedSum[_buyer] += _ethAmount;\r\n    }\r\n\r\n    function updateTicketSum(address _buyer, uint256 _tAmount)\r\n        private\r\n    {\r\n        round[curRoundId].ticketSum = round[curRoundId].ticketSum + _tAmount;\r\n        round[curRoundId].pTicketSum[_buyer] = round[curRoundId].pTicketSum[_buyer] + _tAmount;\r\n        curRTicketSum = curRTicketSum + _tAmount;\r\n        pTicketSum[_buyer] = pTicketSum[_buyer] + _tAmount;\r\n    }\r\n\r\n    function updateEarlyIncome(address _buyer, uint256 _pWeight)\r\n        private\r\n    {\r\n        round[curRoundId].rEarlyIncomeWeight = _pWeight.add(round[curRoundId].rEarlyIncomeWeight);\r\n        round[curRoundId].pEarlyIncomeWeight[_buyer] = _pWeight.add(round[curRoundId].pEarlyIncomeWeight[_buyer]);\r\n        round[curRoundId].pEarlyIncomeCredit[_buyer] = round[curRoundId].pEarlyIncomeCredit[_buyer].add(_pWeight.mul(round[curRoundId].ppw));\r\n    }\r\n\r\n    function getBonusTickets(address _buyer)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        if (round[curRoundId].pBonusReceived[_buyer]) return 0;\r\n        round[curRoundId].pBonusReceived[_buyer] = true;\r\n        return round[curRoundId - 1].pBoughtTicketSum[_buyer] / TBONUS_RATE;\r\n    }\r\n\r\n    function updateMulti()\r\n        private\r\n    {\r\n        if (lastBuyTime + multiDelayTime < block.timestamp) {\r\n            lastEndTime = round[curRoundId].slideEndTime;\r\n        }\r\n        lastBuyTime = block.timestamp;\r\n    }\r\n\r\n    function buyFor(string _sSalt, address _sender) \r\n        public\r\n        payable\r\n        buyable()\r\n    {\r\n        uint256 _salt = Helper.stringToUint(_sSalt);\r\n        uint256 _ethAmount = msg.value;\r\n        uint256 _ticketSum = curRTicketSum;\r\n        require(_ethAmount >= Helper.getTPrice(_ticketSum), \"not enough to buy 1 ticket\");\r\n\r\n        // investedSum logs\r\n        updateInvested(_sender, _ethAmount);\r\n        updateMulti();\r\n        // update salt\r\n        curRSalt = curRSalt + _salt;\r\n        uint256 _tAmount = Helper.getTAmount(_ethAmount, _ticketSum);\r\n        uint256 _tMul = getTMul(); // 100x Zoomed\r\n        uint256 _pMul = Helper.getEarlyIncomeMul(_ticketSum);\r\n        uint256 _pWeight = _pMul.mul(_tAmount);\r\n        uint256 _toAddTime = Helper.getAddedTime(_ticketSum, _tAmount);\r\n        addTime(curRoundId, _toAddTime);\r\n        _tAmount = _tAmount.mul(_tMul) / 100;\r\n        round[curRoundId].pBoughtTicketSum[_sender] += _tAmount;\r\n        mintSlot(_sender, _tAmount + getBonusTickets(_sender), _ethAmount, _salt);\r\n\r\n        // EarlyIncome Weight\r\n        // ppw and credit zoomed x1000\r\n        // earlyIncome mul of each ticket in this slot\r\n        updateEarlyIncome(_sender, _pWeight);\r\n\r\n        // first slot in this block draw jacpot results for \r\n        // all slot in last block\r\n        if (lastBlockNr != block.number) {\r\n            jackpot();\r\n            lastBlockNr = block.number;\r\n        }\r\n\r\n        distributeSlotBuy(_sender, curRoundId, _ethAmount);\r\n\r\n        round[curRoundId].keyBlockNr = genEstKeyBlockNr(round[curRoundId].slideEndTime);\r\n    }\r\n\r\n    function distributeSlotBuy(address _sender, uint256 _rId, uint256 _ethAmount)\r\n        private\r\n    {\r\n        uint256 onePercent = _ethAmount / 100;\r\n        uint256 toF2mAmount = onePercent * toTokenPercent; // 12\r\n        uint256 toRefAmount = onePercent * toRefPercent; // 10\r\n        uint256 toBuyTokenAmount = onePercent * toBuyTokenPercent; //1\r\n        uint256 earlyIncomeAmount = onePercent * earlyIncomePercent; //27\r\n        uint256 taxAmount = toF2mAmount + toRefAmount + toBuyTokenAmount + earlyIncomeAmount; // 50\r\n        uint256 taxedEthAmount = _ethAmount.sub(taxAmount); // 50\r\n        addPot(taxedEthAmount);\r\n        \r\n        // 10% Ref\r\n        citizenContract.pushRefIncome.value(toRefAmount)(_sender);\r\n        // 2% Fund + 10% Dividends \r\n        f2mContract.pushDividends.value(toF2mAmount)();\r\n        // 1% buy Token\r\n        f2mContract.buyFor.value(toBuyTokenAmount)(_sender);\r\n        // 27% Early\r\n        uint256 deltaPpw = (earlyIncomeAmount * ZOOM).div(round[_rId].rEarlyIncomeWeight);\r\n        round[_rId].ppw = deltaPpw.add(round[_rId].ppw);\r\n    }\r\n\r\n    function claimEarlyIncomebyAddress(address _buyer)\r\n        private\r\n    {\r\n        if (curRoundId == 0) return;\r\n        claimEarlyIncomebyAddressRound(_buyer, curRoundId);\r\n        uint256 _rId = curRoundId - 1;\r\n        while ((_rId > lastWithdrawnRound[_buyer]) && (_rId + 20 > curRoundId)) {\r\n            earlyIncomeScannedSum[_buyer] += claimEarlyIncomebyAddressRound(_buyer, _rId);\r\n            _rId = _rId - 1;\r\n        }\r\n    }\r\n\r\n    function claimEarlyIncomebyAddressRound(address _buyer, uint256 _rId)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        uint256 _amount = getCurEarlyIncomeByAddressRound(_buyer, _rId);\r\n        if (_amount == 0) return 0;\r\n        round[_rId].pEarlyIncomeClaimed[_buyer] = _amount.add(round[_rId].pEarlyIncomeClaimed[_buyer]);\r\n        rewardBalance[_buyer] = _amount.add(rewardBalance[_buyer]);\r\n        return _amount;\r\n    }\r\n\r\n    function withdrawFor(address _sender)\r\n        public\r\n        withdrawRight()\r\n        returns(uint256)\r\n    {\r\n        if (curRoundId == 0) return;\r\n        claimEarlyIncomebyAddress(_sender);\r\n        lastWithdrawnRound[_sender] = curRoundId - 1;\r\n        uint256 _amount = rewardBalance[_sender];\r\n        rewardBalance[_sender] = 0;\r\n        bankContract.pushToBank.value(_amount)(_sender);\r\n        return _amount;\r\n    }\r\n    \r\n    function addTime(uint256 _rId, uint256 _toAddTime)\r\n        private\r\n    {\r\n        round[_rId].slideEndTime = Helper.getNewEndTime(_toAddTime, round[_rId].slideEndTime, round[_rId].fixedEndTime);\r\n    }\r\n\r\n    // distribute to 3 pots Grand, Majorm Minor\r\n    function addPot(uint256 _amount)\r\n        private\r\n    {\r\n        uint256 onePercent = _amount / 100;\r\n        uint256 toMinor = onePercent * minorPercent;\r\n        uint256 toMajor = onePercent * majorPercent;\r\n        uint256 toGrand = _amount - toMinor - toMajor;\r\n\r\n        minorPot = minorPot + toMinor;\r\n        majorPot = majorPot + toMajor;\r\n        grandPot = grandPot + toGrand;\r\n    }\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////\r\n    // READ FUNCTIONS\r\n    //////////////////////////////////////////////////////////////////\r\n\r\n    function isWinSlot(uint256 _slotId, uint256 _keyNumber)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return (slot[_slotId - 1].tNumberTo < _keyNumber) && (slot[_slotId].tNumberTo >= _keyNumber);\r\n    }\r\n\r\n    function getWeightRange()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return Helper.getWeightRange(initGrandPot);\r\n    }\r\n\r\n    function getWinSlot(uint256 _keyNumber)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // return 0 if not found\r\n        uint256 _to = slot.length - 1;\r\n        uint256 _from = round[curRoundId-1].slotSum + 1; // dummy slot ignore\r\n        uint256 _pivot;\r\n        //Slot memory _slot;\r\n        uint256 _pivotTo;\r\n        // Binary search\r\n        while (_from <= _to) {\r\n            _pivot = (_from + _to) / 2;\r\n            _pivotTo = slot[_pivot].tNumberTo;\r\n            if (isWinSlot(_pivot, _keyNumber)) return _pivot;\r\n            if (_pivotTo < _keyNumber) { // in right side\r\n                _from = _pivot + 1;\r\n            } else { // in left side\r\n                _to = _pivot - 1;\r\n            }\r\n        }\r\n        return _pivot; // never happens or smt gone wrong\r\n    }\r\n\r\n    // Key Block in future\r\n    function genEstKeyBlockNr(uint256 _endTime) \r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        if (block.timestamp >= _endTime) return block.number + 8; \r\n        uint256 timeDist = _endTime - block.timestamp;\r\n        uint256 estBlockDist = timeDist / BLOCK_TIME;\r\n        return block.number + estBlockDist + 8;\r\n    }\r\n\r\n    // get block hash of first block with blocktime > _endTime\r\n    function getSeed(uint256 _keyBlockNr)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Key Block not mined atm\r\n        if (block.number <= _keyBlockNr) return block.number;\r\n        return uint256(blockhash(_keyBlockNr));\r\n    }\r\n\r\n    // current reward balance\r\n    function getRewardBalance(address _buyer)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return rewardBalance[_buyer];\r\n    } \r\n\r\n    // GET endTime\r\n    function getSlideEndTime(uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(round[_rId].slideEndTime);\r\n    }\r\n\r\n    function getFixedEndTime(uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(round[_rId].fixedEndTime);\r\n    }\r\n\r\n    function getTotalPot()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return grandPot + majorPot + minorPot;\r\n    }\r\n\r\n    // EarlyIncome\r\n    function getEarlyIncomeByAddress(address _buyer)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _sum = earlyIncomeScannedSum[_buyer];\r\n        uint256 _fromRound = lastWithdrawnRound[_buyer] + 1; // >=1\r\n        if (_fromRound + 100 < curRoundId) _fromRound = curRoundId - 100;\r\n        uint256 _rId = _fromRound;\r\n        while (_rId <= curRoundId) {\r\n            _sum = _sum + getEarlyIncomeByAddressRound(_buyer, _rId);\r\n            _rId++;\r\n        }\r\n        return _sum;\r\n    }\r\n\r\n    // included claimed amount\r\n    function getEarlyIncomeByAddressRound(address _buyer, uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _pWeight = round[_rId].pEarlyIncomeWeight[_buyer];\r\n        uint256 _ppw = round[_rId].ppw;\r\n        uint256 _rCredit = round[_rId].pEarlyIncomeCredit[_buyer];\r\n        uint256 _rEarlyIncome = ((_ppw.mul(_pWeight)).sub(_rCredit)).div(ZOOM);\r\n        return _rEarlyIncome;\r\n    }\r\n\r\n    function getCurEarlyIncomeByAddress(address _buyer)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _sum = 0;\r\n        uint256 _fromRound = lastWithdrawnRound[_buyer] + 1; // >=1\r\n        if (_fromRound + 100 < curRoundId) _fromRound = curRoundId - 100;\r\n        uint256 _rId = _fromRound;\r\n        while (_rId <= curRoundId) {\r\n            _sum = _sum.add(getCurEarlyIncomeByAddressRound(_buyer, _rId));\r\n            _rId++;\r\n        }\r\n        return _sum;\r\n    }\r\n\r\n    function getCurEarlyIncomeByAddressRound(address _buyer, uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _rEarlyIncome = getEarlyIncomeByAddressRound(_buyer, _rId);\r\n        return _rEarlyIncome.sub(round[_rId].pEarlyIncomeClaimed[_buyer]);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////\r\n\r\n    function getEstKeyBlockNr(uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return round[_rId].keyBlockNr;\r\n    }\r\n\r\n    function getKeyBlockNr(uint256 _estKeyBlockNr)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        require(block.number > _estKeyBlockNr, \"blockHash not avaiable\");\r\n        uint256 jump = (block.number - _estKeyBlockNr) / MAX_BLOCK_DISTANCE * MAX_BLOCK_DISTANCE;\r\n        return _estKeyBlockNr + jump;\r\n    }\r\n\r\n    // Logs\r\n    function getCurRoundId()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return curRoundId;\r\n    }\r\n\r\n    function getTPrice()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return Helper.getTPrice(curRTicketSum);\r\n    }\r\n\r\n    function getTMul()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return Helper.getTMul(\r\n                initGrandPot, \r\n                grandPot, \r\n                lastBuyTime + multiDelayTime < block.timestamp ? round[curRoundId].slideEndTime : lastEndTime, \r\n                round[curRoundId].fixedEndTime\r\n            );\r\n    }\r\n\r\n    function getPMul()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return Helper.getEarlyIncomeMul(curRTicketSum);\r\n    }\r\n\r\n    function getPTicketSumByRound(uint256 _rId, address _buyer)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return round[_rId].pTicketSum[_buyer];\r\n    }\r\n\r\n    function getTicketSumToRound(uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return round[_rId].ticketSum;\r\n    }\r\n\r\n    function getPInvestedSumByRound(uint256 _rId, address _buyer)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return round[_rId].pInvestedSum[_buyer];\r\n    }\r\n\r\n    function getInvestedSumToRound(uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return round[_rId].investedSum;\r\n    }\r\n\r\n    function getPSlotLength(address _sender)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return pSlot[_sender].length;\r\n    }\r\n\r\n    function getSlotLength()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return slot.length;\r\n    }\r\n\r\n    function getSlotId(address _sender, uint256 i)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return pSlot[_sender][i];\r\n    }\r\n\r\n    function getSlotInfo(uint256 _slotId)\r\n        public\r\n        view\r\n        returns(address, uint256[4], string)\r\n    {\r\n        Slot memory _slot = slot[_slotId];\r\n        return (_slot.buyer,[_slot.rId, _slot.tNumberFrom, _slot.tNumberTo, _slot.ethAmount], Helper.uintToString(_slot.salt));\r\n    }\r\n\r\n    function cashoutable(address _address) \r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        // need 1 ticket of curRound or lastRound in waiting time to start new round\r\n        if (round[curRoundId].pTicketSum[_address] >= CASHOUT_REQ) return true;\r\n        if (round[curRoundId].startTime > block.timestamp) {\r\n            // underflow return false\r\n            uint256 _lastRoundTickets = getPTicketSumByRound(curRoundId - 1, _address);\r\n            if (_lastRoundTickets >= CASHOUT_REQ) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // set endRound, prepare to upgrade new version\r\n    function setLastRound(uint256 _lastRoundId) \r\n        public\r\n        onlyDevTeam()\r\n    {\r\n        require(_lastRoundId >= 8 && _lastRoundId > curRoundId, \"too early to end\");\r\n        require(lastRoundId == 88888888, \"already set\");\r\n        lastRoundId = _lastRoundId;\r\n\r\n    }\r\n\r\n    function sBountyClaim(address _sBountyHunter)\r\n        public\r\n        notStarted()\r\n        returns(uint256)\r\n    {\r\n        require(msg.sender == address(rewardContract), \"only Reward contract can manage sBountys\");\r\n        uint256 _lastRoundTickets = round[curRoundId - 1].pBoughtTicketSum[_sBountyHunter];\r\n        uint256 _sBountyTickets = _lastRoundTickets * sBountyPercent / 100;\r\n        mintSlot(_sBountyHunter, _sBountyTickets, 0, 0);\r\n        return _sBountyTickets;\r\n    }\r\n\r\n    /*\r\n        TEST\r\n    */\r\n\r\n    // function forceEndRound() \r\n    //     public\r\n    // {\r\n    //     round[curRoundId].keyBlockNr = block.number;\r\n    //     round[curRoundId].slideEndTime = block.timestamp;\r\n    //     round[curRoundId].fixedEndTime = block.timestamp;\r\n    // }\r\n\r\n    // function setTimer1(uint256 _hours)\r\n    //     public\r\n    // {\r\n    //     round[curRoundId].slideEndTime = block.timestamp + _hours * 1 hours + 60;\r\n    //     round[curRoundId].keyBlockNr = genEstKeyBlockNr(round[curRoundId].slideEndTime);\r\n    // }\r\n\r\n    // function setTimer2(uint256 _days)\r\n    //     public\r\n    // {\r\n    //     round[curRoundId].fixedEndTime = block.timestamp + _days * 1 days + 60;\r\n    //     require(round[curRoundId].fixedEndTime >= round[curRoundId].slideEndTime, \"invalid test data\");\r\n    // }\r\n}\r\n\r\ninterface F2mInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    // one time called\r\n    // function disableRound0() public;\r\n    function activeBuy() public;\r\n    // function premine() public;\r\n    // Dividends from all sources (DApps, Donate ...)\r\n    function pushDividends() public payable;\r\n    /**\r\n     * Converts all of caller's dividends to tokens.\r\n     */\r\n    function buyFor(address _buyer) public payable;\r\n    function sell(uint256 _tokenAmount) public;\r\n    function exit() public;\r\n    function devTeamWithdraw() public returns(uint256);\r\n    function withdrawFor(address sender) public returns(uint256);\r\n    function transfer(address _to, uint256 _tokenAmount) public returns(bool);\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    function setAutoBuy() public;\r\n    /*==========================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    ==========================================*/\r\n    function ethBalance(address _address) public view returns(uint256);\r\n    function myBalance() public view returns(uint256);\r\n    function myEthBalance() public view returns(uint256);\r\n\r\n    function swapToken() public;\r\n    function setNewToken(address _newTokenAddress) public;\r\n}\r\n\r\ninterface CitizenInterface {\r\n \r\n    function joinNetwork(address[6] _contract) public;\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    function devTeamWithdraw() public;\r\n\r\n    /*----------  WRITE FUNCTIONS  ----------*/\r\n    function updateUsername(string _sNewUsername) public;\r\n    //Sources: Token contract, DApps\r\n    function pushRefIncome(address _sender) public payable;\r\n    function withdrawFor(address _sender) public payable returns(uint256);\r\n    function devTeamReinvest() public returns(uint256);\r\n\r\n    /*----------  READ FUNCTIONS  ----------*/\r\n    function getRefWallet(address _address) public view returns(uint256);\r\n}\r\n\r\ninterface DevTeamInterface {\r\n    function setF2mAddress(address _address) public;\r\n    function setLotteryAddress(address _address) public;\r\n    function setCitizenAddress(address _address) public;\r\n    function setBankAddress(address _address) public;\r\n    function setRewardAddress(address _address) public;\r\n    function setWhitelistAddress(address _address) public;\r\n\r\n    function setupNetwork() public;\r\n}\r\n\r\ninterface BankInterface {\r\n    function joinNetwork(address[6] _contract) public;\r\n    function pushToBank(address _player) public payable;\r\n}\r\n\r\ninterface RewardInterface {\r\n\r\n    function mintReward(\r\n        address _lucker,\r\n        uint256 curRoundId,\r\n        uint256 _winNr,\r\n        uint256 _tNumberFrom,\r\n        uint256 _tNumberTo,\r\n        uint256 _value,\r\n        uint256 _rewardType)\r\n        public;\r\n        \r\n    function joinNetwork(address[6] _contract) public;\r\n    function pushBounty(uint256 _curRoundId) public payable;\r\n    function resetCounter(uint256 _curRoundId) public;\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}"}}}