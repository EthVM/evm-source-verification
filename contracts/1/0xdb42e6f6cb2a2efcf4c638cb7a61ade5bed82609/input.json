{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "NFTFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.2;\r\npragma experimental ABIEncoderV2;\r\n// File: contracts/ICounterfactualNFT.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/**\r\n * @title ICounterfactualNFT\r\n */\r\nabstract contract ICounterfactualNFT\r\n{\r\n    function initialize(address owner, string memory _uri)\r\n        public\r\n        virtual;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/Create2Upgradeable.sol\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/Create2.sol)\r\n\r\n\r\n/**\r\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\r\n * `CREATE2` can be used to compute in advance the address where a smart\r\n * contract will be deployed, which allows for interesting new mechanisms known\r\n * as 'counterfactual interactions'.\r\n *\r\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\r\n * information.\r\n */\r\nlibrary Create2Upgradeable {\r\n    /**\r\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\r\n     * will be deployed can be known in advance via {computeAddress}.\r\n     *\r\n     * The bytecode for a contract can be obtained from Solidity with\r\n     * `type(contractName).creationCode`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `bytecode` must not be empty.\r\n     * - `salt` must have not been used for `bytecode` already.\r\n     * - the factory must have a balance of at least `amount`.\r\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\r\n     */\r\n    function deploy(\r\n        uint256 amount,\r\n        bytes32 salt,\r\n        bytes memory bytecode\r\n    ) internal returns (address) {\r\n        address addr;\r\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\r\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\r\n        assembly {\r\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\r\n        }\r\n        require(addr != address(0), \"Create2: Failed on deploy\");\r\n        return addr;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\r\n     * `bytecodeHash` or `salt` will result in a new destination address.\r\n     */\r\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\r\n        return computeAddress(salt, bytecodeHash, address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\r\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\r\n     */\r\n    function computeAddress(\r\n        bytes32 salt,\r\n        bytes32 bytecodeHash,\r\n        address deployer\r\n    ) internal pure returns (address) {\r\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\r\n        return address(uint160(uint256(_data)));\r\n    }\r\n}\r\n\r\n// File: contracts/external/CloneFactory.sol\r\n\r\n// This code is taken from https://eips.ethereum.org/EIPS/eip-1167\r\n// Modified to a library and generalized to support create/create2.\r\n\r\n/*\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2018 Murray Software, LLC.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n//solhint-disable max-line-length\r\n//solhint-disable no-inline-assembly\r\n\r\nlibrary CloneFactory {\r\n  function getByteCode(address target) internal pure returns (bytes memory byteCode) {\r\n    bytes20 targetBytes = bytes20(target);\r\n    assembly {\r\n      byteCode := mload(0x40)\r\n      mstore(byteCode, 0x37)\r\n\r\n      let clone := add(byteCode, 0x20)\r\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n      mstore(add(clone, 0x14), targetBytes)\r\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n\r\n      mstore(0x40, add(byteCode, 0x60))\r\n    }\r\n  }\r\n}\r\n\r\n// File: ../contracts/NFTFactory.sol\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n/// @title NFTFactory\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\ncontract NFTFactory\r\n{\r\n    event NFTContractCreated (address nftContract, address owner, string baseURI);\r\n\r\n    string public constant NFT_CONTRACT_CREATION = \"NFT_CONTRACT_CREATION\";\r\n    address public immutable implementation;\r\n\r\n    constructor(\r\n        address _implementation\r\n        )\r\n    {\r\n        implementation = _implementation;\r\n    }\r\n\r\n    /// @dev Create a new NFT contract.\r\n    /// @param owner The NFT contract owner.\r\n    /// @param baseURI The base token URI (empty string allowed/encouraged to use IPFS mode)\r\n    /// @return nftContract The new NFT contract address\r\n    function createNftContract(\r\n        address            owner,\r\n        string    calldata baseURI\r\n        )\r\n        external\r\n        payable\r\n        returns (address nftContract)\r\n    {\r\n        // Deploy the proxy contract\r\n        nftContract = Create2Upgradeable.deploy(\r\n            0,\r\n            keccak256(abi.encodePacked(NFT_CONTRACT_CREATION, owner, baseURI)),\r\n            CloneFactory.getByteCode(implementation)\r\n        );\r\n\r\n        // Initialize\r\n        ICounterfactualNFT(nftContract).initialize(owner, baseURI);\r\n\r\n        emit NFTContractCreated(nftContract, owner, baseURI);\r\n    }\r\n\r\n    function computeNftContractAddress(\r\n        address          owner,\r\n        string  calldata baseURI\r\n        )\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return _computeAddress(owner, baseURI);\r\n    }\r\n\r\n    function getNftContractCreationCode()\r\n        public\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return CloneFactory.getByteCode(implementation);\r\n    }\r\n\r\n    function _computeAddress(\r\n        address          owner,\r\n        string  calldata baseURI\r\n        )\r\n        private\r\n        view\r\n        returns (address)\r\n    {\r\n        return Create2Upgradeable.computeAddress(\r\n            keccak256(abi.encodePacked(NFT_CONTRACT_CREATION, owner, baseURI)),\r\n            keccak256(CloneFactory.getByteCode(implementation))\r\n        );\r\n    }\r\n}"
    }
  }
}