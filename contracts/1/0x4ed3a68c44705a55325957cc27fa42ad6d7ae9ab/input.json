{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "CellarPoolShare.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// VolumeFi Software, Inc.\n\npragma solidity 0.8.11;\n\nimport \"./interfaces.sol\";\n\n/**\n * @title Sommelier Cellar Pool Share contract\n * @notice Main Cellar Pool share contract for Sommelier Network\n * @author VolumeFi Software\n */\n\ncontract CellarPoolShare is ICellarPoolShare, BlockLock {\n    using SafeERC20 for IERC20;\n\n    // Set the Uniswap V3 contract Addresses.\n    address private constant _NONFUNGIBLEPOSITIONMANAGER = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\n\n    address private constant _UNISWAPV3FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\n\n    address private constant _SWAPROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\n\n    address private constant _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    uint256 private constant _DOMINATOR = 10000;\n\n    uint256 private constant _YEAR = 31556952;\n\n    uint256 private constant _TOLERANCE = 25; // 0.5% slippage -> 1.0025 tolerance of sqrtPrice\n\n    AggregatorV3Interface private constant _BTCPRICEFEED =\n        AggregatorV3Interface(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);\n\n    AggregatorV3Interface private constant _ETHPRICEFEED =\n        AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n\n    // Declare the variables and mappings\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    mapping(address => bool) public validator;\n\n    mapping(address => bool) public adjuster;\n\n    uint256 private _totalSupply;\n    address private _owner;\n    bool private _isEntered;\n    string private _name;\n    string private _symbol;\n\n    address public immutable token0;\n    address public immutable token1;\n    uint24 public immutable feeLevel;\n    CellarTickInfo[] public cellarTickInfo;\n    uint256 public lastManageTimestamp;\n    uint256 public performanceFee = 2000;\n    uint256 public managementFee = 200;\n\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner) revert NonPermission();\n        _;\n    }\n\n    modifier onlyValidator() {\n        if (!validator[msg.sender]) revert NonPermission();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_isEntered) revert Reentrance();\n        _isEntered = true;\n        _;\n        _isEntered = false;\n    }\n\n    /**\n     * @notice Create the constructor that identifies \n     * the toke names, symbols, and address for each token \n     * pair of any Uniswap v3 AMM\n     */\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address _token0,\n        address _token1,\n        uint24 _feeLevel,\n        CellarTickInfo[] memory _cellarTickInfo\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        if (_token0 >= _token1) {\n            revert UnsortedTokens();\n        }\n        token0 = _token0;\n        token1 = _token1;\n        feeLevel = _feeLevel;\n        for (uint256 i = 0; i < _cellarTickInfo.length; i++) {\n            if (_cellarTickInfo[i].weight == 0) revert ZeroWeight();\n            if (_cellarTickInfo[i].tokenId != 0) revert NonEmptyTokenId();\n            if (_cellarTickInfo[i].tickUpper <= _cellarTickInfo[i].tickLower) revert WrongTickTier();\n            if (i > 0) {\n                if (_cellarTickInfo[i].tickUpper > _cellarTickInfo[i - 1].tickLower) revert WrongTickTier();\n            }\n            cellarTickInfo.push(\n                CellarTickInfo({\n                    tokenId: 0,\n                    tickUpper: _cellarTickInfo[i].tickUpper,\n                    tickLower: _cellarTickInfo[i].tickLower,\n                    weight: _cellarTickInfo[i].weight\n                })\n            );\n        }\n        lastManageTimestamp = block.timestamp;\n        _owner = msg.sender;\n        validator[msg.sender] = true;\n        adjuster[msg.sender] = true;\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    function totalPrice(uint256 amount0, uint256 amount1) internal view returns (uint256 total) {\n        uint256 priceBtc = uint256(_BTCPRICEFEED.latestAnswer());\n        uint256 priceEth = uint256(_ETHPRICEFEED.latestAnswer());\n        total = priceBtc * amount0 * 10 ** 10 + priceEth * amount1;\n    }\n\n    function addLiquidityForUniV3(CellarAddParams calldata cellarParams)\n        external\n        payable\n        override\n        nonReentrant\n        notLocked(msg.sender)\n    {\n        if (token0 == _WETH) {\n            if (msg.value >= cellarParams.amount0Desired) {\n                if (msg.value > cellarParams.amount0Desired) {\n                    payable(msg.sender).transfer(\n                        msg.value - cellarParams.amount0Desired\n                    );\n                }\n                IWETH(_WETH).deposit{value: cellarParams.amount0Desired}();\n            } else {\n                IERC20(_WETH).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    cellarParams.amount0Desired\n                );\n                if (msg.value > 0) {\n                    payable(msg.sender).transfer(msg.value);\n                }\n            }\n            IERC20(token1).safeTransferFrom(\n                msg.sender,\n                address(this),\n                cellarParams.amount1Desired\n            );\n        } else if (token1 == _WETH) {\n            if (msg.value >= cellarParams.amount1Desired) {\n                if (msg.value > cellarParams.amount1Desired) {\n                    payable(msg.sender).transfer(\n                        msg.value - cellarParams.amount1Desired\n                    );\n                }\n                IWETH(_WETH).deposit{value: cellarParams.amount1Desired}();\n            } else {\n                IERC20(_WETH).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    cellarParams.amount1Desired\n                );\n                if (msg.value > 0) {\n                    payable(msg.sender).transfer(msg.value);\n                }\n            }\n            IERC20(token0).safeTransferFrom(\n                msg.sender,\n                address(this),\n                cellarParams.amount0Desired\n            );\n        } else {\n            IERC20(token0).safeTransferFrom(\n                msg.sender,\n                address(this),\n                cellarParams.amount0Desired\n            );\n            IERC20(token1).safeTransferFrom(\n                msg.sender,\n                address(this),\n                cellarParams.amount1Desired\n            );\n        }\n\n        (\n            uint256 inAmount0,\n            uint256 inAmount1,\n            uint128 liquidityBefore,\n            uint128 liquiditySum\n        ) = _addLiquidity(cellarParams);\n\n        if (liquidityBefore == 0) {\n            _mint(msg.sender, liquiditySum);\n        } else {\n            _mint(\n                msg.sender,\n                FullMath.mulDiv(liquiditySum, _totalSupply, liquidityBefore)\n            );\n        }\n\n        if (inAmount0 < cellarParams.amount0Min || inAmount1 < cellarParams.amount1Min) revert InsufficientAmount();\n\n        if (totalPrice(inAmount0, inAmount1) > 10000 * 10 ** 26) {\n            revert OverDeposit(); // 10000 * 10 ** 18 * 10 ** 8\n        }\n\n        uint256 retAmount0 = cellarParams.amount0Desired - inAmount0;\n        uint256 retAmount1 = cellarParams.amount1Desired - inAmount1;\n\n        if (retAmount0 > 0) {\n            if (token0 == _WETH) {\n                IWETH(_WETH).withdraw(retAmount0);\n                payable(msg.sender).transfer(retAmount0);\n            } else {\n                IERC20(token0).safeTransfer(msg.sender, retAmount0);\n            }\n        }\n        if (retAmount1 > 0) {\n            if (token1 == _WETH) {\n                IWETH(_WETH).withdraw(retAmount1);\n                payable(msg.sender).transfer(retAmount1);\n            } else {\n                IERC20(token1).safeTransfer(msg.sender, retAmount1);\n            }\n        }\n        emit AddedLiquidity(liquiditySum, inAmount0, inAmount1);\n    }\n\n    function removeLiquidityFromUniV3(\n        CellarRemoveParams calldata cellarParams\n    ) external override nonReentrant notLocked(msg.sender) {\n        (uint256 outAmount0, uint256 outAmount1, uint128 liquiditySum, ) =\n            _removeLiquidity(cellarParams, false);\n        _burn(msg.sender, cellarParams.tokenAmount);\n\n        if (outAmount0 < cellarParams.amount0Min || outAmount1 < cellarParams.amount1Min) revert InsufficientAmount();\n\n        if (token0 == _WETH) {\n            IWETH(_WETH).withdraw(outAmount0);\n            payable(msg.sender).transfer(outAmount0);\n            IERC20(token1).safeTransfer(msg.sender, outAmount1);\n        } else {\n            IERC20(token0).safeTransfer(msg.sender, outAmount0);\n            if (token1 == _WETH) {\n                IWETH(_WETH).withdraw(outAmount1);\n                payable(msg.sender).transfer(outAmount1);\n            } else {\n                IERC20(token1).safeTransfer(msg.sender, outAmount1);\n            }\n        }\n        emit RemovedLiquidity(\n            liquiditySum,\n            outAmount0,\n            outAmount1\n        );\n    }\n\n    function _midSwap(\n        address _token0, address _token1,\n        uint256 inAmount0, uint256 inAmount1,\n        uint256 balance0, uint256 balance1,\n        uint256 sqrtPriceX96\n    )\n        private\n    {\n            uint256 swapAmount;\n            // nothing added means either token exists and price range is not out of range for the token.\n            // the case is balance0 > 0, balance1 = 0, swap half amount of token0 into token1\n            if (inAmount0 == 0 && inAmount1 == 0) {\n                swapAmount = balance0 / 2;\n            }\n            // calculate swap amount from bal0, bal1, in0, in1.\n            // bal0, bal1 are token balance to add. in0, in1 are added balance in the first adding liquidity.\n            // approximated result because in swapping, because the price changes.\n            else {\n                swapAmount = (balance0* inAmount1 - balance1 * inAmount0)\n                    /\n                    (FullMath.mulDiv(\n                        FullMath.mulDiv(\n                            inAmount0,\n                            sqrtPriceX96,\n                            FixedPoint96.Q96),\n                        sqrtPriceX96,\n                        FixedPoint96.Q96)\n                    + inAmount1);\n            }\n            IERC20(_token0).safeApprove(_SWAPROUTER, swapAmount);\n            try ISwapRouter(_SWAPROUTER).exactInputSingle(\n                ISwapRouter.ExactInputSingleParams({\n                    tokenIn: _token0,\n                    tokenOut: _token1,\n                    fee: feeLevel,\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    amountIn: swapAmount,\n                    amountOutMinimum: 0,\n                    sqrtPriceLimitX96: 0\n                })\n            ) {} catch {}\n            IERC20(_token0).safeApprove(_SWAPROUTER, 0);\n    }\n\n    /**\n     * @notice invest token into Uniswap V3 liquidity\n     * @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n     * @return totalInAmount0 token0 amount added into liquidity\n     * @return totalInAmount1 token1 amount added into liquidity\n     */\n    function _invest(uint160 sqrtPriceX96)\n        private\n        nonReentrant\n        returns (\n            uint256 totalInAmount0,\n            uint256 totalInAmount1\n        )\n    {\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n\n        (uint256 inAmount0, uint256 inAmount1, , ) =\n            _addLiquidity(\n                CellarAddParams({\n                    amount0Desired: balance0,\n                    amount1Desired: balance1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n            );\n        balance0 = balance0 - inAmount0;\n        balance1 = balance1 - inAmount1;\n\n        totalInAmount0 = totalInAmount0 + inAmount0;\n        totalInAmount1 = totalInAmount1 + inAmount1;\n        // uint256 swapAmount;\n        // b0 / b1 > i0 / i1 means token0 will remain. swap some token0 into token1\n        if (balance0 * inAmount1 > balance1 * inAmount0 || (inAmount0 == 0 && inAmount1 == 0 && balance0 > balance1)) {\n            _midSwap(token0, token1, inAmount0, inAmount1, balance0, balance1, sqrtPriceX96);\n        }\n        // b0 / b1 < i0 / i1 means token1 will remain. swap some token1 into token0\n        if (balance0 * inAmount1 < balance1 * inAmount0 || (inAmount0 == 0 && inAmount1 == 0 && balance0 < balance1)) {\n            uint256 revertedSqrtPriceX96 = FullMath.mulDiv(FixedPoint96.Q96, FixedPoint96.Q96, sqrtPriceX96);\n            _midSwap(token1, token0, inAmount1, inAmount0, balance1, balance0, revertedSqrtPriceX96);\n        }\n        (inAmount0, inAmount1, , ) =\n            _addLiquidity(\n                CellarAddParams({\n                    amount0Desired: IERC20(token0).balanceOf(address(this)),\n                    amount1Desired: IERC20(token1).balanceOf(address(this)),\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n            );\n\n        totalInAmount0 += inAmount0;\n        totalInAmount1 += inAmount1;\n    }\n\n    /**\n     * @notice get management fee from NFLP\n     * @param tokenId The ID of the token to get management fee\n     * @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n     * @param duration duration since last collecting management fee\n     * @return feeAmount0 token0 fee amount\n     * @return feeAmount1 token1 fee amount\n     */\n    function getManagementFee(uint256 tokenId, uint160 sqrtPriceX96, uint256 duration)\n        internal\n        view\n        returns (uint256 feeAmount0, uint256 feeAmount1)\n    {\n        (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) =\n            INonfungiblePositionManager(_NONFUNGIBLEPOSITIONMANAGER)\n                .positions(tokenId);\n        uint160 sqrtPriceAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n        uint160 sqrtPriceBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n        (uint256 amount0, uint256 amount1) =\n            LiquidityAmounts.getAmountsForLiquidity(sqrtPriceX96, sqrtPriceAX96, sqrtPriceBX96, liquidity);\n        feeAmount0 = amount0 * managementFee * duration / _YEAR / _DOMINATOR;\n        feeAmount1 = amount1 * managementFee * duration / _YEAR / _DOMINATOR;\n    }\n\n    function reinvest(uint256 currentPriceX96) external override onlyValidator notLocked(msg.sender) {\n        uint256 weightSum;\n        uint256 balance0;\n        uint256 balance1;\n        uint256 fee0;\n        uint256 fee1;\n        uint256 duration = block.timestamp - lastManageTimestamp;\n        (uint160 sqrtPriceX96, , , , , , ) =\n            IUniswapV3Pool(\n                IUniswapV3Factory(_UNISWAPV3FACTORY).getPool(\n                    token0,\n                    token1,\n                    feeLevel\n                )\n            )\n                .slot0();\n        unchecked{\n            if (uint256(sqrtPriceX96) - currentPriceX96 >= currentPriceX96 * _TOLERANCE / _DOMINATOR\n                && currentPriceX96 - uint256(sqrtPriceX96) >= currentPriceX96 * _TOLERANCE / _DOMINATOR)\n                revert HighSlippage();\n        }\n        for (uint256 index = 0; index < cellarTickInfo.length; index++) {\n            if (cellarTickInfo[index].tokenId == 0) revert InvalidTokenId();\n            weightSum += cellarTickInfo[index].weight;\n            (uint256 amount0, uint256 amount1) =\n                INonfungiblePositionManager(_NONFUNGIBLEPOSITIONMANAGER).collect(\n                    INonfungiblePositionManager.CollectParams({\n                        tokenId: cellarTickInfo[index].tokenId,\n                        recipient: address(this),\n                        amount0Max: type(uint128).max,\n                        amount1Max: type(uint128).max\n                    })\n                );\n            balance0 += amount0;\n            balance1 += amount1;\n            (uint256 mFee0, uint256 mFee1) = getManagementFee(cellarTickInfo[index].tokenId, sqrtPriceX96, duration);\n            fee0 += mFee0;\n            fee1 += mFee1;\n        }\n        uint256 mgmtFee0 = fee0;\n        uint256 mgmtFee1 = fee1;\n        uint256 perfFee0 = balance0 * performanceFee / _DOMINATOR;\n        uint256 perfFee1 = balance1 * performanceFee / _DOMINATOR;\n        fee0 += perfFee0;\n        fee1 += perfFee1;\n        if (fee0 > balance0) {\n            fee0 = balance0;\n            if (mgmtFee0 < balance0) {\n                perfFee0 = balance0 - mgmtFee0;\n            } else {\n                mgmtFee0 = balance0;\n                perfFee0 = 0;\n            }\n        }\n        if (fee1 > balance1) {\n            fee1 = balance1;\n            if (mgmtFee1 < balance1) {\n                perfFee1 = balance1 - mgmtFee1;\n            } else {\n                mgmtFee1 = balance1;\n                perfFee1 = 0;\n            }\n        }\n        lastManageTimestamp = block.timestamp;\n        if (fee0 > 0) {\n            IERC20(token0).safeTransfer(_owner, fee0);\n        }\n        if (fee1 > 0) {\n            IERC20(token1).safeTransfer(_owner, fee1);\n        }\n        (uint256 investedAmount0, uint256 investedAmount1) = _invest(sqrtPriceX96);\n\n        emit Reinvest(\n            balance0,\n            balance1,\n            mgmtFee0,\n            mgmtFee1,\n            perfFee0,\n            perfFee1,\n            investedAmount0,\n            investedAmount1\n        );\n    }\n\n    function rebalance(CellarTickInfo[] memory _cellarTickInfo, uint256 currentPriceX96)\n        external\n        override\n        notLocked(msg.sender)\n    {\n        if (!adjuster[msg.sender]) revert NonPermission();\n        (uint160 sqrtPriceX96, , , , , , ) =\n            IUniswapV3Pool(\n                IUniswapV3Factory(_UNISWAPV3FACTORY).getPool(\n                    token0,\n                    token1,\n                    feeLevel\n                )\n            )\n                .slot0();\n        unchecked{\n            if (uint256(sqrtPriceX96) - currentPriceX96 >= currentPriceX96 * _TOLERANCE / _DOMINATOR\n                && currentPriceX96 - uint256(sqrtPriceX96) >= currentPriceX96 * _TOLERANCE / _DOMINATOR)\n                revert HighSlippage();\n        }\n        CellarRemoveParams memory removeParams =\n            CellarRemoveParams({\n                tokenAmount: _totalSupply,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            });\n\n        (, , , CellarFees memory cellarFees) =\n            _removeLiquidity(removeParams, true);\n        lastManageTimestamp = block.timestamp;\n\n        uint256 fee0 = cellarFees.management0 + cellarFees.performance0;\n        uint256 fee1 = cellarFees.management1 + cellarFees.performance1;\n        if (fee0 > cellarFees.collect0) {\n            fee0 = cellarFees.collect0;\n            if (cellarFees.management0 < cellarFees.collect0) {\n                cellarFees.performance0 = cellarFees.collect0 - cellarFees.management0;\n            } else {\n                cellarFees.management0 = cellarFees.collect0;\n                cellarFees.performance0 = 0;\n            }\n        }\n        if (fee1 > cellarFees.collect1) {\n            fee1 = cellarFees.collect1;\n            if (cellarFees.management1 < cellarFees.collect1) {\n                cellarFees.performance1 = cellarFees.collect1 - cellarFees.management1;\n            } else {\n                cellarFees.management1 = cellarFees.collect1;\n                cellarFees.performance1 = 0;\n            }\n        }\n\n        if (fee0 > 0) {\n            IERC20(token0).safeTransfer(_owner, fee0);\n        }\n        if (fee1 > 0) {\n            IERC20(token1).safeTransfer(_owner, fee1);\n        }\n        for (uint256 i = 0; i < cellarTickInfo.length; i++) {\n            INonfungiblePositionManager(_NONFUNGIBLEPOSITIONMANAGER).burn(\n                cellarTickInfo[i].tokenId\n            );\n        }\n        delete cellarTickInfo;\n        for (uint256 i = 0; i < _cellarTickInfo.length; i++) {\n            if (_cellarTickInfo[i].tickUpper <= _cellarTickInfo[i].tickLower) revert WrongTickTier();\n            if (i > 0) {\n                if (_cellarTickInfo[i].tickUpper > _cellarTickInfo[i - 1].tickLower) revert WrongTickTier();\n            }\n            if (_cellarTickInfo[i].weight == 0) revert ZeroWeight();\n            if (_cellarTickInfo[i].tokenId != 0) revert NonEmptyTokenId();\n            cellarTickInfo.push(_cellarTickInfo[i]);\n        }\n\n        (uint256 investedAmount0, uint256 investedAmount1) = _invest(sqrtPriceX96);\n\n        emit Rebalance(\n            cellarFees.collect0,\n            cellarFees.collect1,\n            cellarFees.management0,\n            cellarFees.management1,\n            cellarFees.performance0,\n            cellarFees.performance1,\n            investedAmount0,\n            investedAmount1\n        );\n    }\n\n    function setValidator(address _validator, bool value) external override onlyOwner {\n        if (_validator == address(0)) revert InvalidInput();\n        validator[_validator] = value;\n        emit SetValidator(_validator, value);\n    }\n\n    function setAdjuster(address _adjuster, bool value) external override onlyOwner {\n        if (_adjuster == address(0)) revert InvalidInput();\n        adjuster[_adjuster] = value;\n        emit SetAdjuster(_adjuster, value);\n    }\n\n    function transferOwnership(address newOwner) external override onlyOwner {\n        if (newOwner == address(0)) revert InvalidInput();\n        _owner = newOwner;\n        emit TransferOwnership(newOwner);\n    }\n\n    function setManagementFee(uint256 newFee) external override onlyOwner {\n        if (newFee >= _DOMINATOR) revert InvalidInput();\n        managementFee = newFee;\n        emit SetManagementFee(newFee);\n    }\n\n    function setPerformanceFee(uint256 newFee) external override onlyOwner {\n        if (newFee >= _DOMINATOR) revert InvalidInput();\n        performanceFee = newFee;\n        emit SetPerformanceFee(newFee);\n    }\n\n    function owner() external view override returns (address) {\n        return _owner;\n    }\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    function allowance(address owner_, address spender)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[owner_][spender];\n    }\n\n    function getCellarTickInfo()\n        external\n        view\n        override\n        returns (CellarTickInfo[] memory)\n    {\n        return cellarTickInfo;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        if (sender == address(0)) revert TransferFromZeroAddress();\n        if (recipient == address(0)) revert TransferToZeroAddress();\n\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        if (account == address(0)) revert MintToZeroAddress();\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        if (account == address(0)) revert BurnFromZeroAddress();\n\n        _balances[account] -= amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner_,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (owner_ == address(0)) revert ApproveFromZeroAddress();\n        if (spender == address(0)) revert ApproveToZeroAddress();\n\n        _allowances[owner_][spender] = amount;\n        emit Approval(owner_, spender, amount);\n    }\n\n    /**\n     * @notice get weight information of positions\n     * @dev every position has its weight but it is for liquidity weight, not token amount weight.\n     *      this function calculates token amount weight and sum of weights from liquidity weight.\n     * @param _cellarTickInfo cellar tick info struct array\n     * @return weightSum0 sum of weights for token0\n     * @return weightSum1 sum of weights for token1\n     * @return liquidityBefore total liquidity of all positions\n     * @return weight0 weights array for token0\n     * @return weight1 weights array for token1\n     */\n    function _getWeightInfo(CellarTickInfo[] memory _cellarTickInfo)\n        internal\n        view\n        returns (\n            uint256 weightSum0,\n            uint256 weightSum1,\n            uint128 liquidityBefore,\n            uint256[] memory weight0,\n            uint256[] memory weight1\n        )\n    {\n        weight0 = new uint256[](_cellarTickInfo.length);\n        weight1 = new uint256[](_cellarTickInfo.length);\n        (uint160 sqrtPriceX96, int24 currentTick, , , , , ) =\n            IUniswapV3Pool(\n                IUniswapV3Factory(_UNISWAPV3FACTORY).getPool(\n                    token0,\n                    token1,\n                    feeLevel\n                )\n            )\n                .slot0();\n        UintPair memory sqrtPrice0;\n        // price of ticks is increasing through ticks.\n        // At the first tick, token0 weight is maximum. Last tick, token1 weight is maximum.\n\n        uint256 weight00;// token0 maximum weight\n        uint256 weight10;// token1 maximum weight\n\n        sqrtPrice0.a = TickMath.getSqrtRatioAtTick(\n            _cellarTickInfo[0].tickLower\n        );\n        sqrtPrice0.b = TickMath.getSqrtRatioAtTick(\n            _cellarTickInfo[0].tickUpper\n        );\n        weight00 = _cellarTickInfo[0].weight; // first position\n        weight10 = _cellarTickInfo[_cellarTickInfo.length - 1].weight; // last position\n\n        // calculate token weight from liquidity weight per tick position\n        for (uint256 i = 0; i < _cellarTickInfo.length; i++) {\n            if (_cellarTickInfo[i].tokenId > 0) {\n                (, , , , , , , uint128 liquidity, , , , ) =\n                    INonfungiblePositionManager(_NONFUNGIBLEPOSITIONMANAGER)\n                        .positions(_cellarTickInfo[i].tokenId);\n                liquidityBefore += liquidity;\n            }\n\n            UintPair memory sqrtCurrentTickPriceX96;\n            sqrtCurrentTickPriceX96.a = TickMath.getSqrtRatioAtTick(\n                _cellarTickInfo[i].tickLower\n            );\n            sqrtCurrentTickPriceX96.b = TickMath.getSqrtRatioAtTick(\n                _cellarTickInfo[i].tickUpper\n            );\n            // current tick is less than tickLower of the position.\n            // token1 amount is 0, So consider token0 amount and weight only.\n            if (currentTick <= _cellarTickInfo[i].tickLower) {\n                weight0[i] = // weight for token0\n                    (FullMath.mulDiv(\n                        FullMath.mulDiv(\n                            FullMath.mulDiv(\n                                sqrtPrice0.a,\n                                sqrtPrice0.b,\n                                sqrtPrice0.b - sqrtPrice0.a\n                            ),\n                            sqrtCurrentTickPriceX96.b -\n                                sqrtCurrentTickPriceX96.a,\n                            sqrtCurrentTickPriceX96.b\n                        ),\n                        FixedPoint96.Q96,\n                        sqrtCurrentTickPriceX96.a\n                    ) // token0 amount\n                     * _cellarTickInfo[i].weight) /\n                    weight00;\n                weightSum0 += weight0[i];\n            // current tick is greater than tickLower of the position.\n            // token0 amount is 0, So consider token1 amount and weight only.\n            } else if (currentTick >= _cellarTickInfo[i].tickUpper) {\n                weight1[i] = // weight for token1\n                    (FullMath.mulDiv(\n                        sqrtCurrentTickPriceX96.b - sqrtCurrentTickPriceX96.a,\n                        FixedPoint96.Q96,\n                        sqrtPrice0.b - sqrtPrice0.a\n                    ) * _cellarTickInfo[i].weight) /\n                    weight10;\n                weightSum1 += weight1[i];\n            // current tick is in the range, recalculate both tokens weight.\n            } else {\n                weight0[i] =\n                    (FullMath.mulDiv(\n                        FullMath.mulDiv(\n                            FullMath.mulDiv(\n                                sqrtPrice0.a,\n                                sqrtPrice0.b,\n                                sqrtPrice0.b - sqrtPrice0.a\n                            ),\n                            sqrtCurrentTickPriceX96.b - sqrtPriceX96,\n                            sqrtCurrentTickPriceX96.b\n                        ),\n                        FixedPoint96.Q96,\n                        sqrtPriceX96\n                    ) * _cellarTickInfo[i].weight) /\n                    weight00;\n\n                weight1[i] =\n                    (FullMath.mulDiv(\n                        sqrtPriceX96 - sqrtCurrentTickPriceX96.a,\n                        FixedPoint96.Q96,\n                        sqrtPrice0.b - sqrtPrice0.a\n                    ) * _cellarTickInfo[i].weight) /\n                    weight10;\n                weightSum0 += weight0[i];\n                weightSum1 += weight1[i];\n            }\n        }\n    }\n\n    /**\n     * @notice modify weight information of positions\n     * @dev some positions consist of either token.\n     *      that's why if we distribute tokens according to the weights, some tokens will remain.\n     *      so we remove weights from the weight sum if the position doesn't include either token.\n     * @param _cellarTickInfo cellar tick info struct array\n     * @param amount0Desired token0 amount to add liquidity\n     * @param amount1Desired token1 amount to add liquidity\n     * @param weightSum0 sum of weights for token0\n     * @param weightSum1 sum of weights for token1\n     * @param weight0 token0 weight array\n     * @param weight1 token1 weight array\n     * @return newWeightSum0 updated sum of weights for token0\n     * @return newWeightSum1 updated sum of weights for token1\n     */\n    function _modifyWeightInfo(\n        CellarTickInfo[] memory _cellarTickInfo,\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 weightSum0,\n        uint256 weightSum1,\n        uint256[] memory weight0,\n        uint256[] memory weight1\n    ) internal view returns (uint256 newWeightSum0, uint256 newWeightSum1) {\n        if (_cellarTickInfo.length == 1) {\n            return (weightSum0, weightSum1);\n        }\n\n        UintPair memory liquidity;\n        (uint160 sqrtPriceX96, , , , , , ) =\n            IUniswapV3Pool(\n                IUniswapV3Factory(_UNISWAPV3FACTORY).getPool(\n                    token0,\n                    token1,\n                    feeLevel\n                )\n            )\n                .slot0();\n        liquidity.a = LiquidityAmounts.getLiquidityForAmounts(\n            sqrtPriceX96,\n            TickMath.getSqrtRatioAtTick(_cellarTickInfo[0].tickLower),\n            TickMath.getSqrtRatioAtTick(_cellarTickInfo[0].tickUpper),\n            FullMath.mulDiv(amount0Desired, weight0[0], weightSum0),\n            FullMath.mulDiv(amount1Desired, weight1[0], weightSum1)\n        );\n        uint256 tickLength = _cellarTickInfo.length - 1;\n        liquidity.b = LiquidityAmounts.getLiquidityForAmounts(\n            sqrtPriceX96,\n            TickMath.getSqrtRatioAtTick(_cellarTickInfo[tickLength].tickLower),\n            TickMath.getSqrtRatioAtTick(_cellarTickInfo[tickLength].tickUpper),\n            FullMath.mulDiv(amount0Desired, weight0[tickLength], weightSum0),\n            FullMath.mulDiv(amount1Desired, weight1[tickLength], weightSum1)\n        );\n\n        if (\n            liquidity.a * _cellarTickInfo[tickLength].weight >\n            liquidity.b * _cellarTickInfo[0].weight\n        ) {\n            if (liquidity.b * _cellarTickInfo[0].weight > 0) {\n                newWeightSum0 = FullMath.mulDiv(\n                    weightSum0,\n                    liquidity.a * _cellarTickInfo[tickLength].weight,\n                    liquidity.b * _cellarTickInfo[0].weight\n                );\n            }\n            else {\n                newWeightSum0 = 0;\n            }\n            newWeightSum1 = weightSum1;\n        } else {\n            newWeightSum0 = weightSum0;\n            if (liquidity.a * _cellarTickInfo[tickLength].weight > 0) {\n                newWeightSum1 = FullMath.mulDiv(\n                    weightSum1,\n                    liquidity.b * _cellarTickInfo[0].weight,\n                    liquidity.a * _cellarTickInfo[tickLength].weight\n                );\n            }\n            else {\n                newWeightSum1 = 0;\n            }\n        }\n    }\n\n    /**\n     * @notice add liquidity into Uniswap positions\n     * @param cellarParams params struct to add liquidity\n     * @return inAmount0 token0 amount added into liquidity\n     * @return inAmount1 token1 amount added into liquidity\n     * @return liquidityBefore liquidity sum before add liquidity\n     * @return liquiditySum liquidity sum after add liquidity\n     */\n    function _addLiquidity(CellarAddParams memory cellarParams)\n        internal\n        returns (\n            uint256 inAmount0,\n            uint256 inAmount1,\n            uint128 liquidityBefore,\n            uint128 liquiditySum\n        )\n    {\n        CellarTickInfo[] memory _cellarTickInfo = cellarTickInfo;\n        IERC20(token0).safeApprove(\n            _NONFUNGIBLEPOSITIONMANAGER,\n            cellarParams.amount0Desired\n        );\n        IERC20(token1).safeApprove(\n            _NONFUNGIBLEPOSITIONMANAGER,\n            cellarParams.amount1Desired\n        );\n\n        uint256 weightSum0;\n        uint256 weightSum1;\n        uint256[] memory weight0 = new uint256[](_cellarTickInfo.length);\n        uint256[] memory weight1 = new uint256[](_cellarTickInfo.length);\n\n        (\n            weightSum0,\n            weightSum1,\n            liquidityBefore,\n            weight0,\n            weight1\n        ) = _getWeightInfo(_cellarTickInfo);\n        if (weightSum0 > 0 && weightSum1 > 0) {\n            (weightSum0, weightSum1) = _modifyWeightInfo(\n                _cellarTickInfo,\n                cellarParams.amount0Desired,\n                cellarParams.amount1Desired,\n                weightSum0,\n                weightSum1,\n                weight0,\n                weight1\n            );\n        }\n\n        for (uint256 i = 0; i < _cellarTickInfo.length; i++) {\n            INonfungiblePositionManager.MintParams memory mintParams =\n                INonfungiblePositionManager.MintParams({\n                    token0: token0,\n                    token1: token1,\n                    fee: feeLevel,\n                    tickLower: _cellarTickInfo[i].tickLower,\n                    tickUpper: _cellarTickInfo[i].tickUpper,\n                    amount0Desired: 0,\n                    amount1Desired: 0,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    recipient: address(this),\n                    deadline: cellarParams.deadline\n                });\n\n                INonfungiblePositionManager.IncreaseLiquidityParams\n                    memory increaseLiquidityParams\n             =\n                INonfungiblePositionManager.IncreaseLiquidityParams({\n                    tokenId: _cellarTickInfo[i].tokenId,\n                    amount0Desired: 0,\n                    amount1Desired: 0,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: cellarParams.deadline\n                });\n            if (weightSum0 > 0) {\n                mintParams.amount0Desired = FullMath.mulDiv(\n                    cellarParams.amount0Desired,\n                    weight0[i],\n                    weightSum0\n                );\n                increaseLiquidityParams.amount0Desired = mintParams\n                    .amount0Desired;\n                mintParams.amount0Min = FullMath.mulDiv(\n                    cellarParams.amount0Min,\n                    weight0[i],\n                    weightSum0\n                );\n                increaseLiquidityParams.amount0Min = mintParams.amount0Min;\n            }\n            if (weightSum1 > 0) {\n                mintParams.amount1Desired = FullMath.mulDiv(\n                    cellarParams.amount1Desired,\n                    weight1[i],\n                    weightSum1\n                );\n                increaseLiquidityParams.amount1Desired = mintParams\n                    .amount1Desired;\n                mintParams.amount1Min = FullMath.mulDiv(\n                    cellarParams.amount1Min,\n                    weight1[i],\n                    weightSum1\n                );\n                increaseLiquidityParams.amount1Min = mintParams.amount1Min;\n            }\n            if (\n                mintParams.amount0Desired > 0 || mintParams.amount1Desired > 0\n            ) {\n                MintResult memory mintResult;\n                if (_cellarTickInfo[i].tokenId == 0) {\n\n                    try INonfungiblePositionManager(_NONFUNGIBLEPOSITIONMANAGER)\n                        .mint(mintParams) returns (uint256 r1, uint128 r2, uint256 r3, uint256 r4) {\n                        mintResult.tokenId = r1;\n                        mintResult.liquidity = r2;\n                        mintResult.amount0 = r3;\n                        mintResult.amount1 = r4;\n                    } catch {}\n\n                    cellarTickInfo[i].tokenId = uint184(mintResult.tokenId);\n\n                    inAmount0 = inAmount0 + mintResult.amount0;\n                    inAmount1 = inAmount1 + mintResult.amount1;\n                    liquiditySum += mintResult.liquidity;\n                } else {\n                    try INonfungiblePositionManager(_NONFUNGIBLEPOSITIONMANAGER)\n                        .increaseLiquidity(increaseLiquidityParams) returns (uint128 r1, uint256 r2, uint256 r3) {\n                        mintResult.liquidity = r1;\n                        mintResult.amount0 = r2;\n                        mintResult.amount1 = r3;\n                    } catch {}\n                    inAmount0 = inAmount0 + mintResult.amount0;\n                    inAmount1 = inAmount1 + mintResult.amount1;\n                    liquiditySum += mintResult.liquidity;\n                }\n            }\n        }\n        IERC20(token0).safeApprove(_NONFUNGIBLEPOSITIONMANAGER, 0);\n        IERC20(token1).safeApprove(_NONFUNGIBLEPOSITIONMANAGER, 0);\n    }\n\n    /**\n     * @notice remove liquidity from Uniswap positions\n     * @param cellarParams params struct to add liquidity\n     * @param getFee true if calculate fee and return as cellarFees param\n            set false when don't need fee calculation for saving gas.\n     * @return outAmount0 token0 amount added into liquidity\n     * @return outAmount1 token1 amount added into liquidity\n     * @return liquiditySum liquidity sum after add liquidity\n     * @return cellarFees fee information struct when getFee is true, otherwise empty\n     */\n    function _removeLiquidity(CellarRemoveParams memory cellarParams, bool getFee)\n        internal\n        returns (\n            uint256 outAmount0,\n            uint256 outAmount1,\n            uint128 liquiditySum,\n            CellarFees memory cellarFees\n        )\n    {\n        CellarTickInfo[] memory _cellarTickInfo = cellarTickInfo;\n        uint256 duration = block.timestamp - lastManageTimestamp;\n        (uint160 sqrtPriceX96, , , , , , ) =\n            IUniswapV3Pool(\n                IUniswapV3Factory(_UNISWAPV3FACTORY).getPool(\n                    token0,\n                    token1,\n                    feeLevel\n                )\n            )\n                .slot0();\n        for (uint256 i = 0; i < _cellarTickInfo.length; i++) {\n            (, , , , , , , uint128 liquidity, , , , ) =\n                INonfungiblePositionManager(_NONFUNGIBLEPOSITIONMANAGER)\n                    .positions(_cellarTickInfo[i].tokenId);\n            uint128 outLiquidity =\n                uint128(\n                    FullMath.mulDiv(\n                        liquidity,\n                        cellarParams.tokenAmount,\n                        _totalSupply\n                    )\n                );\n\n                INonfungiblePositionManager.DecreaseLiquidityParams\n                    memory decreaseLiquidityParams\n             =\n                INonfungiblePositionManager.DecreaseLiquidityParams({\n                    tokenId: _cellarTickInfo[i].tokenId,\n                    liquidity: outLiquidity,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: cellarParams.deadline\n                });\n            UintPair memory amount;\n            (amount.a, amount.b) =\n                INonfungiblePositionManager(_NONFUNGIBLEPOSITIONMANAGER)\n                    .decreaseLiquidity(decreaseLiquidityParams);\n            UintPair memory collectAmount;\n            (collectAmount.a, collectAmount.b) =\n                INonfungiblePositionManager(_NONFUNGIBLEPOSITIONMANAGER).collect(\n                    INonfungiblePositionManager.CollectParams({\n                        tokenId: _cellarTickInfo[i].tokenId,\n                        recipient: address(this),\n                        amount0Max: type(uint128).max,\n                        amount1Max: type(uint128).max\n                    })\n                );\n            outAmount0 = outAmount0 + amount.a;\n            outAmount1 = outAmount1 + amount.b;\n            liquiditySum += outLiquidity;\n            if (getFee) {\n                cellarFees.collect0 = cellarFees.collect0 + collectAmount.a - amount.a;\n                cellarFees.collect1 = cellarFees.collect1 + collectAmount.b - amount.b;\n                (amount.a, amount.b) = getManagementFee(_cellarTickInfo[i].tokenId, sqrtPriceX96, duration);\n                cellarFees.management0 = cellarFees.management0 + amount.a;\n                cellarFees.management1 = cellarFees.management1 + amount.b;\n            }\n        }\n        if (getFee) {\n            cellarFees.performance0 = cellarFees.collect0 * performanceFee / _DOMINATOR;\n            cellarFees.performance1 = cellarFees.collect1 * performanceFee / _DOMINATOR;\n        }\n    }\n\n    receive() external payable {\n        require(msg.sender == _WETH);\n    }\n}\n"
    },
    "interfaces.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// VolumeFi Software, Inc.\n\npragma solidity 0.8.11;\n\n/// Imported from Openzeppelin\n\ninterface IERC20 {\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n}\n\n/// Imported from Uniswap V3\n\ninterface INonfungiblePositionManager {\n\n    /**\n     * @notice The struct to mint a position\n     * @member token0 The address of the token0 for a specific pool\n     * @member token1 The address of the token1 for a specific pool\n     * @member fee The fee associated with the pool\n     * @member tickLower The lower end of the tick range for the position\n     * @member tickUpper The higher end of the tick range for the position\n     * @member amount0Desired The desired amount of token0 to be spent\n     * @member amount1Desired The desired amount of token1 to be spent\n     * @member amount0Min The minimum amount of token0 to spend, which serves as a slippage check\n     * @member amount1Min The minimum amount of token1 to spend, which serves as a slippage check\n     * @member recipient The account that should receive the tokens\n     * @member deadline The time by which the transaction must be included to effect the change\n     */\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    /**\n     * @notice The struct to increase liquidity of a position\n     * @member tokenId The ID of the token for which liquidity is being increased\n     * @member amount0Desired The desired amount of token0 to be spent\n     * @member amount1Desired The desired amount of token1 to be spent\n     * @member amount0Min The minimum amount of token0 to spend, which serves as a slippage check\n     * @member amount1Min The minimum amount of token1 to spend, which serves as a slippage check\n     * @member deadline The time by which the transaction must be included to effect the change\n     */\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /**\n     * @notice The struct to decrease liquidity of a position\n     * @member tokenId The ID of the token for which liquidity is being decreased\n     * @member liquidity The amount by which liquidity will be decreased\n     * @member amount0Min The minimum amount of token0 that should be accounted for the burned liquidity\n     * @member amount1Min The minimum amount of token1 that should be accounted for the burned liquidity\n     * @member deadline The time by which the transaction must be included to effect the change\n     */\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /**\n     * @notice The struct to decrease liquidity of a position\n     * @member tokenId The ID of the NFT for which tokens are being collected\n     * @member recipient The account that should receive the tokens\n     * @member amount0Min The minimum amount of token0 that should be accounted for the burned liquidity\n     * @member amount1Min The minimum amount of token1 that should be accounted for the burned liquidity\n     * @member deadline The time by which the transaction must be included to effect the change\n     */\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params The params necessary to increase liquidity of a position,\n    /// encoded as `IncreaseLiquidityParams` in calldata\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params The params necessary to decrease liquidity of a position\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @param params The params necessary to collect fee\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(CollectParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n    /// must be collected first.\n    /// @param tokenId The ID of the token that is being burned\n    function burn(uint256 tokenId) external payable;\n\n    /// @notice Returns the position information associated with a given token ID.\n    /// @dev Throws if the token ID is not valid.\n    /// @param tokenId The ID of the token that represents the position\n    /// @return nonce The nonce for permits\n    /// @return operator The address that is approved for spending\n    /// @return token0 The address of the token0 for a specific pool\n    /// @return token1 The address of the token1 for a specific pool\n    /// @return fee The fee associated with the pool\n    /// @return tickLower The lower end of the tick range for the position\n    /// @return tickUpper The higher end of the tick range for the position\n    /// @return liquidity The liquidity of the position\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n}\n\n/// Imported from Uniswap V3\n\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n}\n\n/// Imported from Uniswap V3\n\ninterface IUniswapV3Factory {\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n}\n\n/// Imported from Uniswap V3\n\ninterface IUniswapV3Pool {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n}\n\n/// Imported from Openzeppelin\n\nlibrary Address {\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html\n     * ?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"A\");//\"Address: low-level call failed\"\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"B\"//\"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"C\"//\"insufficient balance for call\"\n        );\n        require(isContract(target), \"D\");//\"Address: call to non-contract\"\n\n        (bool success, bytes memory returndata) =\n            target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Imported from Openzeppelin\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"E\"//\"approve non-zero to non-zero\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n        bytes memory returndata =\n            address(token).functionCall(\n                data,\n                \"F\"//\"SafeERC20: low-level call failed\"\n            );\n        if (returndata.length > 0) {\n            require(\n                abi.decode(returndata, (bool)),\n                \"G\"//\"ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n\n/// Imported from Uniswap V3\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n\n/// Imported from Uniswap V3\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked{\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (type(uint256).max - denominator + 1) & denominator;\n\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n}\n\n/// Imported from Uniswap V3\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick)\n        internal\n        pure\n        returns (uint160 sqrtPriceX96)\n    {\n        unchecked{\n            uint256 absTick =\n                tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            require(absTick <= uint256(int256(MAX_TICK)), \"H\");\n\n            uint256 ratio =\n                absTick & 0x1 != 0\n                    ? 0xfffcb933bd6fad37aa2d162d1a594001\n                    : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0)\n                ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0)\n                ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0)\n                ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0)\n                ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0)\n                ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0)\n                ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0)\n                ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0)\n                ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0)\n                ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0)\n                ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0)\n                ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0)\n                ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0)\n                ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0)\n                ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0)\n                ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0)\n                ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0)\n                ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0)\n                ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0)\n                ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160(\n                (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\n            );\n        }\n    }\n}\n\n/// Imported from Uniswap V3\n\n/// @title Liquidity amount functions\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary LiquidityAmounts {\n    /// @notice Downcasts uint256 to uint128\n    /// @param x The uint258 to be downcasted\n    /// @return y The passed value, downcasted to uint128\n    function toUint128(uint256 x) private pure returns (uint128 y) {\n        require((y = uint128(x)) == x);\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount0 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount0(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        uint256 intermediate =\n            FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\n        return\n            toUint128(\n                FullMath.mulDiv(\n                    amount0,\n                    intermediate,\n                    sqrtRatioBX96 - sqrtRatioAX96\n                )\n            );\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount1 The amount1 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount1(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        return\n            toUint128(\n                FullMath.mulDiv(\n                    amount1,\n                    FixedPoint96.Q96,\n                    sqrtRatioBX96 - sqrtRatioAX96\n                )\n            );\n    }\n\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount of token0 being sent in\n    /// @param amount1 The amount of token1 being sent in\n    /// @return liquidity The maximum amount of liquidity received\n    function getLiquidityForAmounts(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            liquidity = getLiquidityForAmount0(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                amount0\n            );\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            uint128 liquidity0 =\n                getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n            uint128 liquidity1 =\n                getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n        } else {\n            liquidity = getLiquidityForAmount1(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                amount1\n            );\n        }\n    }\n\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    function getAmount0ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return\n            FullMath.mulDiv(\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\n                sqrtRatioBX96 - sqrtRatioAX96,\n                sqrtRatioBX96\n            ) / sqrtRatioAX96;\n    }\n\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount1 The amount of token1\n    function getAmount1ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n    }\n\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n        } else {\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n        }\n    }\n}\n\n/// @title interface for CellarPoolShare\n/// @author Steven Jung\ninterface ICellarPoolShare is IERC20 {\n\n    /// @notice Result from mint or add liquidity in Uniswap V3\n    /// @dev Used for decrease local memory variables.\n    /// @member tokenId minted tokenId\n    /// @member liquidity minted liquidity\n    /// @member amount0 added amount of token0 into liquidity\n    /// @member amount1 added amount of token1 into liquidity\n    struct MintResult {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0;\n        uint256 amount1;\n    }\n\n    /**\n     * @notice The struct to increase liquidity of a position\n     * @member amount0Desired The desired amount of token0 to be spent\n     * @member amount1Desired The desired amount of token1 to be spent\n     * @member amount0Min The minimum amount of token0 to spend, which serves as a slippage check\n     * @member amount1Min The minimum amount of token1 to spend, which serves as a slippage check\n     * @member deadline The time by which the transaction must be included to effect the change\n     */\n    struct CellarAddParams {\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /**\n     * @notice The struct to decrease liquidity of a position\n     * @member tokenAmount The amount of cellar token amount by which liquidity will be decreased\n     * @member amount0Min The minimum amount of token0 that should be accounted for the burned liquidity\n     * @member amount1Min The minimum amount of token1 that should be accounted for the burned liquidity\n     * @member deadline The time by which the transaction must be included to effect the change\n     */\n    struct CellarRemoveParams {\n        uint256 tokenAmount;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /**\n     * @notice The struct to decrease liquidity of a position\n     * @member tokenId The tokenId of Uniswap V3 NFLP\n     * @member tickUpper The higher end of the tick range for the position\n     * @member tickLower The lower end of the tick range for the position\n     * @member weight The weight of the current Tick in cellar\n     */\n    struct CellarTickInfo {\n        uint184 tokenId;\n        int24 tickUpper;\n        int24 tickLower;\n        uint24 weight;\n    }\n\n    /// @notice Used for decrease local memory variables.\n    struct UintPair {\n        uint256 a;\n        uint256 b;\n    }\n\n    /**\n     * @notice Used for decrease local memory variables.\n     * @member collect0 collected token0\n     * @member collect1 collected token1\n     * @member management0 management fee of token0\n     * @member management1 management fee of token1\n     * @member performance0 performance fee of token0\n     * @member performance1 performance fee of token1\n     */\n    struct CellarFees {\n        uint256 collect0;\n        uint256 collect1;\n        uint256 management0;\n        uint256 management1;\n        uint256 performance0;\n        uint256 performance1;\n    }\n \n    /// @notice Emitted when liquidity is increased for cellar\n    /// @param liquidity The amount by which liquidity for the NFT position was increased\n    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\n    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\n    event AddedLiquidity(\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when liquidity is decreased from cellar\n    /// @param liquidity The amount by which liquidity for the NFT position was decreased\n    /// @param amount0 The amount of token0 that was collected from the decrease in liquidity\n    /// @param amount1 The amount of token1 that was collected from the decrease in liquidity\n    event RemovedLiquidity(\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when reinvest swap fees into cellar for checking fees\n    /// @param fees0 collected token0\n    /// @param fees1 collected token1\n    /// @param managementFee0 management fee of token0\n    /// @param managementFee1 management fee of token1\n    /// @param performanceFee0 performance fee of token0\n    /// @param performanceFee1 performance fee of token1\n    /// @param amount0 invested amount into liquidity of token0\n    /// @param amount1 invested amount into liquidity of token1\n    event Reinvest (\n        uint256 fees0,\n        uint256 fees1,\n        uint256 managementFee0,\n        uint256 managementFee1,\n        uint256 performanceFee0,\n        uint256 performanceFee1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when rebalance ticks of cellar for checking fees\n    /// @param fees0 collected token0\n    /// @param fees1 collected token1\n    /// @param managementFee0 management fee of token0\n    /// @param managementFee1 management fee of token1\n    /// @param performanceFee0 performance fee of token0\n    /// @param performanceFee1 performance fee of token1\n    /// @param amount0 invested amount into liquidity of token0\n    /// @param amount1 invested amount into liquidity of token1\n    event Rebalance (\n        uint256 fees0,\n        uint256 fees1,\n        uint256 managementFee0,\n        uint256 managementFee1,\n        uint256 performanceFee0,\n        uint256 performanceFee1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when update validator setting\n    /// @param validator validator address to add or remove\n    /// @param value true to add, false to remove\n    event SetValidator (\n        address validator,\n        bool value\n    );\n\n    event SetAdjuster (\n        address adjuster,\n        bool value\n    );\n\n    /// @notice Emitted when transfer ownership\n    /// @param newOwner new owner address\n    event TransferOwnership (\n        address newOwner\n    );\n\n    /// @notice Emitted when update performance fee\n    /// @param newFee new performance fee\n    event SetPerformanceFee (\n        uint256 newFee\n    );\n\n    /// @notice Emitted when update performance fee\n    /// @param newFee new performance fee\n    event SetManagementFee (\n        uint256 newFee\n    );\n\n    error OverDeposit();\n    error UnsortedTokens();\n    error ZeroWeight();\n    error NonEmptyTokenId();\n    error WrongTickTier();\n    error NonPermission();\n    error Reentrance();\n    error InsufficientAmount();\n    error HighSlippage();\n    error InvalidTokenId();\n    error InvalidInput();\n    error TransferToZeroAddress();\n    error TransferFromZeroAddress();\n    error MintToZeroAddress();\n    error BurnFromZeroAddress();\n    error ApproveToZeroAddress();\n    error ApproveFromZeroAddress();\n\n    /// @notice Adding Liquidity For Uniswap V3 NFLP\n    /// @param cellarParams parameter for adding liquidity\n    function addLiquidityForUniV3(CellarAddParams calldata cellarParams)\n        external\n        payable;\n\n    /// @notice Adding Liquidity For Uniswap V3 NFLP\n    /// @param cellarParams parameter for removing liquidity\n    function removeLiquidityFromUniV3(CellarRemoveParams calldata cellarParams)\n        external;\n\n    /// @notice Update cellar tick info\n    /// @param _cellarTickInfo new tick tier information\n    function rebalance(CellarTickInfo[] memory _cellarTickInfo, uint256 currentPrice) external;\n\n    /// @notice collect fee and reinvest in liquidity\n    function reinvest(uint256 currentPriceX96) external;\n\n    /// @notice set validator\n    /// @param _validator address to add or remove from validator list\n    /// @param value add/remove option\n    function setValidator(address _validator, bool value) external;\n\n    /// @notice set adjuster\n    /// @param _adjuster address to add or remove from adjuster list\n    /// @param value add/remove option\n    function setAdjuster(address _adjuster, bool value) external;\n\n    /// @notice transfer ownership to new address\n    /// @param newOwner address of new owner\n    function transferOwnership(address newOwner) external;\n\n    /// @notice update management fee\n    /// @param newFee new management fee value\n    function setManagementFee(uint256 newFee) external;\n\n    /// @notice update performance fee\n    /// @param newFee new performance fee value\n    function setPerformanceFee(uint256 newFee) external;\n\n    /**\n     * @dev Returns owner address\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @dev Returns name of the token as ERC20\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns symbol of the token as ERC20\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns cellar tick info struct array\n     */\n    function getCellarTickInfo() external view returns (CellarTickInfo[] memory);\n\n    /**\n     * @dev Returns decimals of the token as ERC20\n     */\n    function decimals() external pure returns (uint8);\n}\n\ninterface IWETH {\n\n    /**\n     * @dev wrap ETH into WETH\n     */\n    function deposit() external payable;\n\n    /**\n     * @dev unwrap WETH into ETH\n     */\n    function withdraw(uint256) external;\n}\n\n/// @title BlockLock base contract to prevent flash loan attack\ncontract BlockLock {\n    error Locked();\n    // how many blocks are the functions locked for\n    uint256 private constant BLOCK_LOCK_COUNT = 1;\n    // last block for which this address is timelocked\n    mapping(address => uint256) public lastLockedBlock;\n    // modifier to prevent flash loan attack\n    modifier notLocked(address lockedAddress) {\n        if (lastLockedBlock[lockedAddress] > block.number) revert Locked();\n        lastLockedBlock[lockedAddress] = block.number + BLOCK_LOCK_COUNT;\n        _;\n    }\n}\n\n/// @notice AggregatorV3Interface from Chainlink token price oracle\ninterface AggregatorV3Interface {\n    /**\n     * @dev get token price from chainlink price oracle\n     */\n    function latestAnswer() external view returns(int256);\n}\n"
    }
  }
}