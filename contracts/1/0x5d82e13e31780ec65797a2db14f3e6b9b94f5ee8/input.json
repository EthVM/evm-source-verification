{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Aggregate.sol": {
      "content": "\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\nimport \"./Ownable.sol\";\nimport \"./Pausable.sol\";\n\n    /// @title A Fee on Transfer token with automatic reflections to holders.\n    /// @notice Token contract inheriting ERC20 standard with basic access\n    /// control and emergency pause mechanism. The token contract implements\n    /// Fee on Transfer distributed among marketing wallet, acquisition wallets,\n    /// and all token holders (via reflections) on Buy / Sell transactions\n    /// only. Wallet-to-wallet transfers do not incur a fee on transfer.\ncontract Aggregate is ERC20, Pausable, Ownable {\n\n    //--------------------------State Variables---------------------------------\n\n    struct FeeValues {\n          uint256 Amount;\n          uint256 TransferAmount;\n          uint256 ReflectFee;\n          uint256 MarketingFee;\n          uint256 AcquisitionFee;\n      }\n    enum MarketSide {\n      NONE,\n      BUY,\n      SELL\n    }\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n    uint256 private _tTotal;\n    uint256 private _rTotal;\n    uint256 private _tFeeTotal;\n\n    address private _marketingWallet;\n    address[5] private _acquisitionWallets;\n    mapping (address => bool) private _isExchange;\n\n    uint8 private _buyFeeReflect;\n    uint8 private _buyFeeMarketing;\n    uint8 private _buyFeeAcquisition;\n    uint8 private _sellFeeReflect;\n    uint8 private _sellFeeMarketing;\n    uint8 private _sellFeeAcquisition;\n\n    //--------------------------Constructor-------------------------------------\n\n    /// @notice Sets the values for name, symbol, totalSupply, marketingWallet,\n    /// and acquisitionWallets. Initial allocation: 95% to Admin account (for\n    /// liquidity), 2% to Marketing wallet, 3% to Acquisition wallets.\n    /// @param name_ is token name.\n    /// @param symbol_ is token symbol.\n    /// @param supply_ is total token supply.\n    /// @param marketing_ is inital marketing wallet address.\n    /// @param acquisition_ is list of initial 5 acquisition wallet addresses.\n    constructor (\n      string memory name_,\n      string memory symbol_,\n      uint256 supply_,\n      address marketing_,\n      address[] memory acquisition_\n      ) {\n\n      _name = name_;\n      _symbol = symbol_;\n      _tTotal = supply_ * 10**4;\n      _rTotal = (~uint256(0) - (~uint256(0) % _tTotal));\n      _buyFeeReflect = 1;\n      _buyFeeMarketing = 1;\n      _buyFeeAcquisition = 7;\n      _sellFeeReflect = 5;\n      _sellFeeMarketing = 1;\n      _sellFeeAcquisition = 3;\n      _marketingWallet = marketing_;\n      for(uint i = 0; i < _acquisitionWallets.length; i++) {\n        _acquisitionWallets[i] = acquisition_[i];\n      }\n\n      _tOwned[_msgSender()] += _tTotal * 95 / 100;\n      _rOwned[_msgSender()] += _rTotal / 100 * 95;\n      emit Transfer(address(0), _msgSender(), _tOwned[_msgSender()]);\n\n      _tOwned[_marketingWallet] += _tTotal * 2 / 100;\n      _rOwned[_marketingWallet] += _rTotal / 100 * 2;\n      emit Transfer(address(0), _marketingWallet, _tTotal * 2 / 100);\n\n      for(uint i = 0; i < _acquisitionWallets.length; i++){\n        _tOwned[_acquisitionWallets[i]] +=\n          _tTotal * 3 / 100 / _acquisitionWallets.length;\n        _rOwned[_acquisitionWallets[i]] +=\n          _rTotal / 100 * 3 / _acquisitionWallets.length;\n\n        emit Transfer(\n          address(0),\n          _acquisitionWallets[i],\n          _tTotal * 3 / 100 / _acquisitionWallets.length\n          );\n      }\n\n    }\n\n    //--------------------------ERC20 Override Functions------------------------\n\n    /// @notice See {IERC20-totalSupply}.\n    /// @dev Overrides ERC20 totalSupply function.\n    /// @return supply_ is total token supply.\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    /// @notice See {IERC20-balanceOf}.\n    /// @dev Overrides ERC20 balanceOf function. If account is excluded then\n    /// _tOwned balance is returned since that tracks token balance without\n    /// reflections. Otherwise, _rOwned balance is returned after scaling down\n    /// by reflection rate.\n    /// @param account is address to be checked for token balance.\n    /// @return balance_ is token balance of 'account'.\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    /// @notice Number of decimals for token representation.\n    /// @dev Overrides ERC20 decimals function. Value of 4 decimals is required\n    /// to maintain precision of arithmetic operations for reflection fee\n    /// distributions, given the token supply.\n    /// @return decimals_ is number of decimals for display purposes.\n    function decimals() public pure override returns (uint8) {\n        return 4;\n    }\n\n    /// @notice See {IERC20-transfer}.\n    /// @dev Overrides ERC20 _transfer function. Requires 'sender' and\n    /// 'recipient' to be non-zero address to prevent minting/burning and\n    /// non-zero transfer amount. Function determines transaction type 'BUY',\n    /// 'SELL', or 'NONE' depending on whether sender or recipient is exchange\n    /// pair address. Actual token transfer is delegated to {_transferStandard}.\n    /// Function is pausable by token administrator.\n    /// @param sender is address sending token.\n    /// @param recipient is address receiving token.\n    /// @param amount is number of tokens being transferred.\n    function _transfer(\n      address sender,\n      address recipient,\n      uint256 amount\n      ) internal override whenNotPaused {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"ERC20: transfer amount must be greater than zero\");\n        uint256 senderBalance = balanceOf(sender);\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        MarketSide _side;\n        if(_isExchange[sender]){\n            _side = MarketSide.BUY;\n        } else if(_isExchange[recipient]) {\n            _side = MarketSide.SELL;\n        } else {\n            _side = MarketSide.NONE;\n        }\n\n        _transferStandard(sender, recipient, amount, _side);\n    }\n\n    //--------------------------View Functions----------------------------------\n\n    /// @notice Provides scaled down amount based on current reflection rate.\n    /// @dev Helper function for balanceOf function. Scales down a given amount,\n    /// inclusive of reflections, by reflection rate.\n    /// @param rAmount is the amount, inclusive of reflections, to be scaled\n    /// down by reflection rate.\n    /// @return tAmount_ is amount scaled down by current reflection rate.\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total supply\");\n        uint256 currentRate =  _getRate();\n        return rAmount / currentRate;\n    }\n\n    /// @notice Allows checking whether an account has been excluded from\n    /// receiving reflection distributions.\n    /// @param account is address to be checked if excluded from reflections.\n    /// @return excluded_ is true if account is excluded, otherwise, returns\n    /// false.\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    /// @notice Returns which address is receiving marketing fees\n    /// from 'BUY' / 'SELL' transactions.\n    function getMarketingWallet() public view returns (address){\n      return _marketingWallet;\n    }\n\n    /// @notice Returns which address is receiving acquisition fees\n    /// from 'BUY' / 'SELL' transactions at a given index.\n    /// @param index is number between 0 - 4 representing wallets 1 through 5.\n    function getAcquisitionWallet(uint256 index) public view returns (address){\n      require(index < _acquisitionWallets.length, \"Invalid index\");\n      return _acquisitionWallets[index];\n    }\n\n    /// @notice Allows to view total amount of reflection fees collected since\n    /// contract creation.\n    /// @return totalFees_ is total reflection fees collected.\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    //--------------------------Token Transfer----------------------------------\n\n    /// @dev Updates _rOwned and _tOwned balances after deducting applicable\n    /// transaction fees and allocates fees to marketing and acquisition\n    /// wallets. {_getValues} helper function calculates all relevant amounts.\n    /// Emits a {Transfer} event after the balances have been updated.\n    /// @param sender is address sending token.\n    /// @param recipient is address receiving token.\n    /// @param tAmount is number of tokens being transferred.\n    /// @param _side is transaction type: 'BUY', 'SELL', 'NONE'.\n    function _transferStandard(\n      address sender,\n      address recipient,\n      uint256 tAmount,\n      MarketSide _side\n      ) private {\n\n        (\n          FeeValues memory _tValues,\n          FeeValues memory _rValues\n          ) = _getValues(tAmount, _side);\n\n        if(_isExcluded[sender]){\n          _tOwned[sender] -= _tValues.Amount;\n          _rOwned[sender] -= _rValues.Amount;\n        } else {\n          _rOwned[sender] -= _rValues.Amount;\n        }\n\n        if(_isExcluded[recipient]){\n          _tOwned[recipient] += _tValues.TransferAmount;\n          _rOwned[recipient] += _rValues.TransferAmount;\n        } else {\n          _rOwned[recipient] += _rValues.TransferAmount;\n        }\n        emit Transfer(sender, recipient, _tValues.TransferAmount);\n\n        if(_side != MarketSide.NONE){\n          _reflectFee(_rValues.ReflectFee, _tValues.ReflectFee);\n          if(_tValues.MarketingFee > 0) {\n            if(_isExcluded[_marketingWallet]){\n              _tOwned[_marketingWallet] += _tValues.MarketingFee;\n              _rOwned[_marketingWallet] += _rValues.MarketingFee;\n            } else {\n              _rOwned[_marketingWallet] += _rValues.MarketingFee;\n            }\n            emit Transfer(sender, _marketingWallet, _tValues.MarketingFee);\n          }\n\n          if(_tValues.AcquisitionFee > 0) {\n            _acquisitionWalletAlloc(\n              sender, _tValues.AcquisitionFee,\n              _rValues.AcquisitionFee\n              );\n          }\n        }\n    }\n\n    /// @dev Allocates the acquisition wallet fees to each of the five\n    /// acquisition addresses in equal proportion.\n    /// @param sender is address sending token.\n    /// @param tAmount is amount of tokens to be allocated.\n    /// @param rAmount is scaled up amount, inclusive of reflections, of tokens\n    /// to be allocated.\n    function _acquisitionWalletAlloc(\n      address sender,\n      uint256 tAmount,\n      uint256 rAmount\n      ) private {\n        uint256 _tAllocation = tAmount / _acquisitionWallets.length;\n        uint256 _rAllocation = rAmount / _acquisitionWallets.length;\n\n        for(uint i = 0; i < _acquisitionWallets.length; i++){\n          if(_isExcluded[_acquisitionWallets[i]]){\n            _tOwned[_acquisitionWallets[i]] += _tAllocation;\n            _rOwned[_acquisitionWallets[i]] += _rAllocation;\n          } else {\n            _rOwned[_acquisitionWallets[i]] += _rAllocation;\n          }\n          emit Transfer(sender, _acquisitionWallets[i], _tAllocation);\n        }\n    }\n\n    //--------------------------Fee Calculation---------------------------------\n\n    /// @dev Updates {_rTotal} supply by subtracting reflection fees. Updates\n    /// {_tFeeTotal} to add reflection fees. This is used to update the\n    /// reflection rate to calculate users' balances included in reflection.\n    /// @param rFee Scaled up reflection fees from transaction\n    /// @param tFee Actual reflection fees from transaction\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal - rFee;\n        _tFeeTotal = _tFeeTotal + tFee;\n    }\n\n    /// @dev Calculates the required fees to be deducted for given transaction\n    /// amount and transaction type.\n    /// @param tAmount is the amount being transferred by user.\n    /// @param _side is the transaction type: {BUY}, {SELL}, {NONE}.\n    /// @return tValues_ is the calculated actual fee values for transfer\n    /// amount {tAmount}.\n    function _getValues(\n      uint256 tAmount,\n      MarketSide _side\n      ) private view returns (\n        FeeValues memory tValues_,\n        FeeValues memory rValues_\n        ) {\n\n        uint256 currentRate =  _getRate();\n        FeeValues memory _tValues = _getTValues(tAmount, _side);\n        FeeValues memory _rValues = _getRValues(_tValues, currentRate);\n\n        return (_tValues, _rValues);\n    }\n\n    /// @dev Function call {_getFeeValues} to obtain the relevant fee\n    /// percentage for the {_side} transaction type. Calculates the actual\n    /// marketing, acquistion, and reflection fees to be deducted from the\n    /// transfer amount.\n    /// @param tAmount is the amount being transferred by user.\n    /// @param _side is the transaction type: 'BUY', 'SELL', 'NONE'.\n    function _getTValues(\n      uint256 tAmount,\n      MarketSide _side\n      ) private view returns (FeeValues memory) {\n        (\n          uint8 feeReflect_,\n          uint8 feeMarketing_,\n          uint8 feeAcquisition_\n          ) = _getFeeValues(_side);\n\n        FeeValues memory _tValues;\n        _tValues.Amount = tAmount;\n        _tValues.ReflectFee = tAmount * feeReflect_ / 100;\n        _tValues.MarketingFee = tAmount * feeMarketing_ / 100;\n        _tValues.AcquisitionFee = tAmount * feeAcquisition_ / 100;\n        _tValues.TransferAmount =\n          _tValues.Amount\n          - _tValues.ReflectFee\n          - _tValues.MarketingFee\n          - _tValues.AcquisitionFee;\n\n        return (_tValues);\n    }\n\n    /// @dev Scales up the actual transaction fees {_tValues} by reflection\n    /// rate to allow proper update of _rOwned user balance.\n    /// @param _tValues is the struct containing actual transfer amount and\n    /// fees to be deducted.\n    /// @param currentRate is current reflection rate.\n    function _getRValues(\n      FeeValues memory _tValues,\n      uint256 currentRate\n      ) private pure returns (FeeValues memory) {\n\n        FeeValues memory _rValues;\n        _rValues.Amount = _tValues.Amount * currentRate;\n        _rValues.ReflectFee = _tValues.ReflectFee * currentRate;\n        _rValues.MarketingFee = _tValues.MarketingFee * currentRate;\n        _rValues.AcquisitionFee = _tValues.AcquisitionFee * currentRate;\n        _rValues.TransferAmount =\n          _rValues.Amount\n          - _rValues.ReflectFee\n          - _rValues.MarketingFee\n          - _rValues.AcquisitionFee;\n\n        return (_rValues);\n    }\n\n    /// @dev Calculates the reflection rate based on rSupply and rSupply. As\n    /// reflection fees are deducted from rSupply by {_reflectFee} function,\n    /// the reflection rate will decrease, causing users' balances to increase\n    /// by the reflection fee in proportion to the user's balance / total supply\n    function _getRate() private view returns (uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply / tSupply;\n    }\n\n    /// @dev Calculates the transaction fee percentages depending on whether\n    /// user is buying, selling, or transferring the token.\n    /// @param _side is the transaction type: 'BUY', 'SELL', 'NONE'.\n    function _getFeeValues(MarketSide _side) private view returns (\n      uint8,\n      uint8,\n      uint8\n      ) {\n        if(_side == MarketSide.BUY){\n            return (_buyFeeReflect, _buyFeeMarketing, _buyFeeAcquisition);\n        } else if(_side == MarketSide.SELL){\n            return (_sellFeeReflect, _sellFeeMarketing, _sellFeeAcquisition);\n        } else {\n            return (0, 0, 0);\n        }\n    }\n\n    /// @dev Calculates the scaled up and actual token supply exclusive of\n    /// excluded addresses. This impacts the reflection rate (greater decrease)\n    /// to allow included addresses to receive reflections that would have gone\n    /// to excluded accounts.\n    function _getCurrentSupply() private view returns (uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;\n        for (uint256 i = 0; i < _excluded.length; i++) {\n          if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply)\n          return (_rTotal, _tTotal);\n\n          rSupply = rSupply - _rOwned[_excluded[i]];\n          tSupply = tSupply - _tOwned[_excluded[i]];\n        }\n        if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n\n    //--------------------------Restricted Functions----------------------------\n\n    /// @notice Sets the exchange pair address for the token to detect 'BUY',\n    /// 'SELL', or 'NONE' transactions for fee collection. Can only be updated\n    /// by administrator.\n    /// @dev Only transactions to, and from this address will trigger fee\n    /// collection.\n    /// @param exchangePair is the DEX-created contract address of the\n    /// exchange pair.\n    function setExchange(address exchangePair) external onlyOwner {\n        require(!_isExchange[exchangePair], \"Address already Exchange\");\n        _isExchange[exchangePair] = true;\n    }\n\n    /// @notice Removes an exchange pair address from fee collection. Can\n    /// only be updated by administrator.\n    /// @param exchangePair is the DEX-created contract address of the exchange\n    /// pair to be removed as an \"exchange\" for fee collection.\n    function removeExchange(address exchangePair) external onlyOwner {\n        require(_isExchange[exchangePair], \"Address not Exchange\");\n        _isExchange[exchangePair] = false;\n    }\n\n    /// @notice Changes marketing wallet address to receive marketing fee going\n    /// forward. Can only be updated by administrator.\n    /// @param newAddress is the new address to replace existing\n    /// marketing wallet address.\n    function changeMarketing(address newAddress) external onlyOwner {\n        require(newAddress != address(0), \"Address cannot be zero address\");\n        _marketingWallet = newAddress;\n    }\n\n    /// @notice Changes acquisition wallets address to receive acquisition fee\n    /// going forward. Can only be updated by administrator.\n    /// @param index is the acquisition wallet address to be replaced,\n    /// from 0 to 4.\n    /// @param newAddress is the new address to replace existing\n    /// acquisition wallet address.\n    function changeAcquisition(\n      uint256 index,\n      address newAddress\n      ) external onlyOwner {\n        require(index < _acquisitionWallets.length, \"Invalid index value\");\n        require(newAddress != address(0), \"Address cannot be zero address\");\n        _acquisitionWallets[index] = newAddress;\n    }\n\n    /// @notice Changes the reflection, marketing, and acquisition fee\n    /// percentages to be deducted from 'BUY' transaction type. Can only be\n    /// updated by administrator.\n    /// @param reflectFee is the new reflection fee percentage.\n    /// @param marketingFee is the new marketing fee percentage.\n    /// @param acquisitionFee is the new acquisition fee percentage.\n    function setBuyFees(\n      uint8 reflectFee,\n      uint8 marketingFee,\n      uint8 acquisitionFee\n      ) external onlyOwner {\n        require(reflectFee + marketingFee + acquisitionFee < 100,\n          \"Total fee percentage must be less than 100%\"\n          );\n\n        _buyFeeReflect = reflectFee;\n        _buyFeeMarketing = marketingFee;\n        _buyFeeAcquisition = acquisitionFee;\n    }\n\n    /// @notice Changes the reflection, marketing, and acquisition fee\n    /// percentages to be deducted from {SELL} transaction type. Can only be\n    /// updated by administrator.\n    /// @param reflectFee is the new reflection fee percentage.\n    /// @param marketingFee is the new marketing fee percentage.\n    /// @param acquisitionFee is the new acquisition fee percentage.\n    function setSellFees(\n      uint8 reflectFee,\n      uint8 marketingFee,\n      uint8 acquisitionFee\n      ) external onlyOwner {\n        require(reflectFee + marketingFee + acquisitionFee < 100,\n          \"Total fee percentage must be less than 100%\"\n          );\n\n        _sellFeeReflect = reflectFee;\n        _sellFeeMarketing = marketingFee;\n        _sellFeeAcquisition = acquisitionFee;\n    }\n\n    /// @notice Removes address from receiving future reflection distributions.\n    /// Can only be updated by administrator.\n    /// @param account is address to be excluded from reflections.\n    function excludeAccount(address account) external onlyOwner {\n        require(!_isExcluded[account], \"Account already excluded\");\n        require(balanceOf(account) < _tTotal, \"Cannot exclude total supply\");\n         _tOwned[account] = balanceOf(account);\n         _excluded.push(account);\n        _isExcluded[account] = true;\n    }\n\n    /// @notice Includes previously excluded address to receive reflection\n    /// distributions in case of erroneously excluded address. NOTE: Included\n    /// address will receive all previous reflection distribution it should\n    /// have received while address was excluded. Can only be updated by\n    /// administrator.\n    /// @param account is address to be re-included to reflections.\n    function includeAccount(address account) external onlyOwner {\n      require(_isExcluded[account], \"Account already included\");\n\n      for (uint256 i = 0; i < _excluded.length; i++) {\n        if (_excluded[i] == account) {\n          _excluded[i] = _excluded[_excluded.length - 1];\n          _excluded.pop();\n          _isExcluded[account] = false;\n          break;\n        }\n      }\n    }\n\n    /// @notice Pauses token transfer functionality in case of emergency.\n    /// Can only be updated by administrator.\n    function lockToken() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpauses token transfer functionality to allow users to\n    /// transfer token. Can only be updated by administrator.\n    function unlockToken() external onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context {\n    mapping(address => uint256) internal _balances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    string internal _name;\n    string internal _symbol;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     * @return decimal_ is number of decimals for display purposes.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n        /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n}\n"
    },
    "Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     * @return status is current pause status. Returns true if contract is paused, otherwise, returns false.\n     */\n    function paused() public view virtual returns (bool status) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    }
  }
}