{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Vesting.sol":{"content":"pragma solidity ^0.6.12;\n\n/* SPDX-License-Identifier: UNLICENSED */\n\n// ----------------------------------------------------------------------------\n// Safe maths\n// ----------------------------------------------------------------------------\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n    }\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Owned contract\n// ----------------------------------------------------------------------------\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }\n\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n// ----------------------------------------------------------------------------\nabstract contract ERC20Interface {\n    function totalSupply() virtual public view returns (uint);\n    function balanceOf(address tokenOwner) virtual public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) virtual public view returns (uint remaining);\n    function transfer(address to, uint tokens) virtual public returns (bool success);\n    function approve(address spender, uint tokens) virtual public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) virtual public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n\nstruct Schedule {\n    uint32  start;\n    uint32  length;\n    uint256 initial;\n    uint256 tokens;\n}\n\n\ncontract Vesting is Owned, ERC20Interface {\n    using SafeMath for uint;\n\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n\n    mapping(address => Schedule) public schedules;\n    mapping(address => uint256) balances;\n    address public lockedTokenAddress;\n\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    constructor() public {\n        symbol = \"VTLM\";\n        name = \"Vesting Alien Worlds Trilium\";\n        decimals = 4;\n    }\n\n    /* ERC-20 functions, null most of them */\n\n    function balanceOf(address tokenOwner) override virtual public view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n    function totalSupply() override virtual public view returns (uint) {\n        return 0;\n    }\n\n    function allowance(address tokenOwner, address spender) override virtual public view returns (uint remaining){\n        return 0;\n    }\n\n    function transfer(address to, uint tokens) override virtual public returns (bool success) {\n        require(false, \"Use the claim function, not transfer\");\n    }\n\n    function approve(address spender, uint tokens) override virtual public returns (bool success) {\n        require(false, \"Cannot approve spending\");\n    }\n\n    function transferFrom(address from, address to, uint tokens) override virtual public returns (bool success) {\n        require(false, \"Use the claim function, not transferFrom\");\n    }\n\n\n    /* My functions */\n\n    function vestedTotal(address user) private view returns (uint256){\n        uint256 time_now = block.timestamp;\n        uint256 vesting_seconds = 0;\n        Schedule memory s = schedules[user];\n\n        uint256 vested_total = balances[user];\n\n        if (s.start > 0) {\n            if (time_now >= s.start) {\n                vesting_seconds = time_now - s.start;\n\n                uint256 vest_per_second_sats = s.tokens.sub(s.initial);\n                vest_per_second_sats = vest_per_second_sats.div(s.length);\n                \n                vested_total = vesting_seconds.mul(vest_per_second_sats);\n                vested_total = vested_total.add(s.initial); // amount they can withdraw\n            }\n            else {\n                vested_total = 1;\n            }\n            \n            if (vested_total > s.tokens) {\n                vested_total = s.tokens;\n            }\n        }\n\n        return vested_total;\n    }\n\n    function maxClaim(address user) public view returns (uint256) {\n        uint256 vested_total = vestedTotal(user);\n        Schedule memory s = schedules[user];\n        uint256 max = 0;\n\n        if (s.start > 0){\n            uint256 claimed = s.tokens.sub(balances[user]);\n\n            max = vested_total.sub(claimed);\n\n            if (max > balances[user]){\n                max = balances[user];\n            }\n        }\n\n        return max;\n    }\n\n    function claim(uint256 amount) public {\n        require(lockedTokenAddress != address(0x0), \"Locked token contract has not been set\");\n        require(amount > 0, \"Must claim more than 0\");\n        require(balances[msg.sender] > 0, \"No vesting balance found\");\n\n        uint256 vested_total = vestedTotal(msg.sender);\n\n        Schedule memory s = schedules[msg.sender];\n        if (s.start > 0){\n            uint256 remaining_balance = balances[msg.sender].sub(amount);\n\n            if (vested_total < s.tokens) {\n                uint min_balance = s.tokens.sub(vested_total);\n                require(remaining_balance >= min_balance, \"Cannot transfer this amount due to vesting locks\");\n            }\n        }\n\n        balances[msg.sender] = balances[msg.sender].sub(amount);\n        ERC20Interface(lockedTokenAddress).transfer(msg.sender, amount);\n    }\n\n    function setSchedule(address user, uint32 start, uint32 length, uint256 initial, uint256 amount) public onlyOwner {\n        schedules[user].start = start;\n        schedules[user].length = length;\n        schedules[user].initial = initial;\n        schedules[user].tokens = amount;\n    }\n\n    function addTokens(address newOwner, uint256 amount) public onlyOwner {\n        require(lockedTokenAddress != address(0x0), \"Locked token contract has not been set\");\n\n        ERC20Interface tokenContract = ERC20Interface(lockedTokenAddress);\n\n        uint256 userAllowance = tokenContract.allowance(msg.sender, address(this));\n        uint256 fromBalance = tokenContract.balanceOf(msg.sender);\n        require(fromBalance >= amount, \"Sender has insufficient balance\");\n        require(userAllowance >= amount, \"Please allow tokens to be spent by this contract\");\n        tokenContract.transferFrom(msg.sender, address(this), amount);\n\n        balances[newOwner] = balances[newOwner].add(amount);\n    }\n\n    function removeTokens(address owner, uint256 amount) public onlyOwner {\n        ERC20Interface tokenContract = ERC20Interface(lockedTokenAddress);\n        tokenContract.transfer(owner, amount);\n        \n        balances[owner] = balances[owner].sub(amount);\n    }\n\n    function setTokenContract(address _lockedTokenAddress) public onlyOwner {\n        lockedTokenAddress = _lockedTokenAddress;\n    }\n\n    // ------------------------------------------------------------------------\n    // Don't accept ETH\n    // ------------------------------------------------------------------------\n    receive () external payable {\n        revert();\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Owner can transfer out any accidentally sent ERC20 tokens\n    // ------------------------------------------------------------------------\n    function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n    }\n}\n"}}}