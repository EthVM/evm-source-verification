{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":20000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"TrueFarm.sol":{"content":"/*                                                                           \r\n    .'''''''''''..     ..''''''''''''''''..       ..'''''''''''''''..       \r\n    .;;;;;;;;;;;'.   .';;;;;;;;;;;;;;;;;;,.     .,;;;;;;;;;;;;;;;;;,.       \r\n    .;;;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;,.    .,;;;;;;;;;;;;;;;;;;,.       \r\n    .;;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;;,.   .;;;;;;;;;;;;;;;;;;;;,.       \r\n    ';;;;;;;;'.  .';;;;;;;;;;;;;;;;;;;;;;,. .';;;;;;;;;;;;;;;;;;;;;,.       \r\n    ';;;;;,..   .';;;;;;;;;;;;;;;;;;;;;;;,..';;;;;;;;;;;;;;;;;;;;;;,.       \r\n    ......     .';;;;;;;;;;;;;,'''''''''''.,;;;;;;;;;;;;;,'''''''''..       \r\n              .,;;;;;;;;;;;;;.           .,;;;;;;;;;;;;;.                   \r\n             .,;;;;;;;;;;;;,.           .,;;;;;;;;;;;;,.                    \r\n            .,;;;;;;;;;;;;,.           .,;;;;;;;;;;;;,.                     \r\n           .,;;;;;;;;;;;;,.           .;;;;;;;;;;;;;,.     .....            \r\n          .;;;;;;;;;;;;;'.         ..';;;;;;;;;;;;;'.    .',;;;;,'.         \r\n        .';;;;;;;;;;;;;'.         .';;;;;;;;;;;;;;'.   .';;;;;;;;;;.        \r\n       .';;;;;;;;;;;;;'.         .';;;;;;;;;;;;;;'.    .;;;;;;;;;;;,.       \r\n      .,;;;;;;;;;;;;;'...........,;;;;;;;;;;;;;;.      .;;;;;;;;;;;,.       \r\n     .,;;;;;;;;;;;;,..,;;;;;;;;;;;;;;;;;;;;;;;,.       ..;;;;;;;;;,.        \r\n    .,;;;;;;;;;;;;,. .,;;;;;;;;;;;;;;;;;;;;;;,.          .',;;;,,..         \r\n   .,;;;;;;;;;;;;,.  .,;;;;;;;;;;;;;;;;;;;;;,.              ....            \r\n    ..',;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;;,.                               \r\n       ..',;;;;'.    .,;;;;;;;;;;;;;;;;;;;'.                                \r\n          ...'..     .';;;;;;;;;;;;;;,,,'.                                  \r\n                       ...............                                      \r\n*/\r\n\r\n// https://github.com/trusttoken/smart-contracts\r\n// SPDX-License-Identifier: MIT\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/truefi/common/Initializable.sol\r\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/v3.0.0/contracts/Initializable.sol\r\npragma solidity 0.6.10;\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private initializing;\r\n\r\n    /**\r\n     * @dev Modifier to use in the initializer function of a contract.\r\n     */\r\n    modifier initializer() {\r\n        require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n        bool isTopLevelCall = !initializing;\r\n        if (isTopLevelCall) {\r\n            initializing = true;\r\n            initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        address self = address(this);\r\n        uint256 cs;\r\n        assembly {\r\n            cs := extcodesize(self)\r\n        }\r\n        return cs == 0;\r\n    }\r\n\r\n    // Reserved storage space to allow for layout changes in the future.\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/truefi/interface/ITrueDistributor.sol\r\npragma solidity 0.6.10;\r\n\r\ninterface ITrueDistributor {\r\n    function trustToken() external view returns (IERC20);\r\n\r\n    function farm() external view returns (address);\r\n\r\n    function distribute() external;\r\n\r\n    function nextDistribution() external view returns (uint256);\r\n\r\n    function empty() external;\r\n}\r\n\r\n// File: contracts/truefi/interface/ITrueFarm.sol\r\npragma solidity 0.6.10;\r\n\r\ninterface ITrueFarm {\r\n    function stakingToken() external view returns (IERC20);\r\n\r\n    function trustToken() external view returns (IERC20);\r\n\r\n    function trueDistributor() external view returns (ITrueDistributor);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function totalStaked() external view returns (uint256);\r\n\r\n    function stake(uint256 amount) external;\r\n\r\n    function unstake(uint256 amount) external;\r\n\r\n    function claim() external;\r\n\r\n    function exit(uint256 amount) external;\r\n}\r\n\r\n// File: contracts/truefi/TrueFarm.sol\r\npragma solidity 0.6.10;\r\n\r\n/**\r\n * @title TrueFarm\r\n * @notice Deposit liquidity tokens to earn TRU rewards over time\r\n * @dev Staking pool where tokens are staked for TRU rewards\r\n * A Distributor contract decides how much TRU a farm can earn over time\r\n */\r\ncontract TrueFarm is ITrueFarm, Initializable {\r\n    using SafeMath for uint256;\r\n    uint256 constant PRECISION = 1e30;\r\n\r\n    // ================ WARNING ==================\r\n    // ===== THIS CONTRACT IS INITIALIZABLE ======\r\n    // === STORAGE VARIABLES ARE DECLARED BELOW ==\r\n    // REMOVAL OR REORDER OF VARIABLES WILL RESULT\r\n    // ========= IN STORAGE CORRUPTION ===========\r\n\r\n    IERC20 public override stakingToken;\r\n    IERC20 public override trustToken;\r\n    ITrueDistributor public override trueDistributor;\r\n    string public override name;\r\n\r\n    // track stakes\r\n    uint256 public override totalStaked;\r\n    mapping(address => uint256) public staked;\r\n\r\n    // track overall cumulative rewards\r\n    uint256 public cumulativeRewardPerToken;\r\n    // track previous cumulate rewards for accounts\r\n    mapping(address => uint256) public previousCumulatedRewardPerToken;\r\n    // track claimable rewards for accounts\r\n    mapping(address => uint256) public claimableReward;\r\n\r\n    // track total rewards\r\n    uint256 public totalClaimedRewards;\r\n    uint256 public totalFarmRewards;\r\n\r\n    // ======= STORAGE DECLARATION END ============\r\n\r\n    /**\r\n     * @dev Emitted when an account stakes\r\n     * @param who Account staking\r\n     * @param amountStaked Amount of tokens staked\r\n     */\r\n    event Stake(address indexed who, uint256 amountStaked);\r\n\r\n    /**\r\n     * @dev Emitted when an account unstakes\r\n     * @param who Account unstaking\r\n     * @param amountUnstaked Amount of tokens unstaked\r\n     */\r\n    event Unstake(address indexed who, uint256 amountUnstaked);\r\n\r\n    /**\r\n     * @dev Emitted when an account claims TRU rewards\r\n     * @param who Account claiming\r\n     * @param amountClaimed Amount of TRU claimed\r\n     */\r\n    event Claim(address indexed who, uint256 amountClaimed);\r\n\r\n    /**\r\n     * @dev Initalize staking pool with a Distributor contraxct\r\n     * The distributor contract calculates how much TRU rewards this contract\r\n     * gets, and stores TRU for distribution.\r\n     * @param _stakingToken Token to stake\r\n     * @param _trueDistributor Distributor contract\r\n     * @param _name Farm name\r\n     */\r\n    function initialize(\r\n        IERC20 _stakingToken,\r\n        ITrueDistributor _trueDistributor,\r\n        string memory _name\r\n    ) public initializer {\r\n        stakingToken = _stakingToken;\r\n        trueDistributor = _trueDistributor;\r\n        trustToken = _trueDistributor.trustToken();\r\n        name = _name;\r\n        require(trueDistributor.farm() == address(this), \"distributor farm not set\");\r\n    }\r\n\r\n    /**\r\n     * @dev Stake tokens for TRU rewards.\r\n     * @param amount Amount of tokens to stake\r\n     */\r\n    function stake(uint256 amount) external override update {\r\n        staked[msg.sender] = staked[msg.sender].add(amount);\r\n        totalStaked = totalStaked.add(amount);\r\n        require(stakingToken.transferFrom(msg.sender, address(this), amount));\r\n        emit Stake(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal unstake function\r\n     * @param amount Amount of tokens to unstake\r\n     */\r\n    function _unstake(uint256 amount) internal {\r\n        require(amount <= staked[msg.sender], \"TrueFarm: Cannot withdraw amount bigger than available balance\");\r\n        staked[msg.sender] = staked[msg.sender].sub(amount);\r\n        totalStaked = totalStaked.sub(amount);\r\n        require(stakingToken.transfer(msg.sender, amount));\r\n        emit Unstake(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal claim function\r\n     */\r\n    function _claim() internal {\r\n        totalClaimedRewards = totalClaimedRewards.add(claimableReward[msg.sender]);\r\n        uint256 rewardToClaim = claimableReward[msg.sender];\r\n        claimableReward[msg.sender] = 0;\r\n        require(trustToken.transfer(msg.sender, rewardToClaim));\r\n        emit Claim(msg.sender, rewardToClaim);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove staked tokens\r\n     * @param amount Amount of tokens to unstake\r\n     */\r\n    function unstake(uint256 amount) external override update {\r\n        _unstake(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim TRU rewards\r\n     */\r\n    function claim() external override update {\r\n        _claim();\r\n    }\r\n\r\n    /**\r\n     * @dev Unstake amount and claim rewards\r\n     * @param amount Amount of tokens to unstake\r\n     */\r\n    function exit(uint256 amount) external override update {\r\n        _unstake(amount);\r\n        _claim();\r\n    }\r\n\r\n    /**\r\n     * @dev View to estimate the claimable reward for an account\r\n     * @return claimable rewards for account\r\n     */\r\n    function claimable(address account) external view returns (uint256) {\r\n        // estimate pending reward from distributor\r\n        uint256 pending = trueDistributor.nextDistribution();\r\n        // calculate total rewards (including pending)\r\n        uint256 newTotalFarmRewards = trustToken.balanceOf(address(this)).add(pending).add(totalClaimedRewards).mul(PRECISION);\r\n        // calculate block reward\r\n        uint256 totalBlockReward = newTotalFarmRewards.sub(totalFarmRewards);\r\n        // calculate next cumulative reward per token\r\n        uint256 nextcumulativeRewardPerToken = cumulativeRewardPerToken.add(totalBlockReward.div(totalStaked));\r\n        // return claimable reward for this account\r\n        // prettier-ignore\r\n        return claimableReward[account].add(\r\n            staked[account].mul(nextcumulativeRewardPerToken.sub(previousCumulatedRewardPerToken[account])).div(PRECISION));\r\n    }\r\n\r\n    /**\r\n     * @dev Update state and get TRU from distributor\r\n     */\r\n    modifier update() {\r\n        // pull TRU from distributor\r\n        // only pull if there is distribution and distributor farm is set to this farm\r\n        if (trueDistributor.nextDistribution() > 0 && trueDistributor.farm() == address(this)) {\r\n            trueDistributor.distribute();\r\n        }\r\n        // calculate total rewards\r\n        uint256 newTotalFarmRewards = trustToken.balanceOf(address(this)).add(totalClaimedRewards).mul(PRECISION);\r\n        // calculate block reward\r\n        uint256 totalBlockReward = newTotalFarmRewards.sub(totalFarmRewards);\r\n        // update farm rewards\r\n        totalFarmRewards = newTotalFarmRewards;\r\n        // if there are stakers\r\n        if (totalStaked > 0) {\r\n            cumulativeRewardPerToken = cumulativeRewardPerToken.add(totalBlockReward.div(totalStaked));\r\n        }\r\n        // update claimable reward for sender\r\n        claimableReward[msg.sender] = claimableReward[msg.sender].add(\r\n            staked[msg.sender].mul(cumulativeRewardPerToken.sub(previousCumulatedRewardPerToken[msg.sender])).div(PRECISION)\r\n        );\r\n        // update previous cumulative for sender\r\n        previousCumulatedRewardPerToken[msg.sender] = cumulativeRewardPerToken;\r\n        _;\r\n    }\r\n}"}}}