{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CROWN.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2020-12-28\r\n*/\r\n\r\n\r\npragma solidity 0.4.25;\r\npragma experimental \"v0.5.0\";\r\n\r\n\r\ncontract ERC20Token {\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint public totalSupply;\r\n\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    function approve(address spender, uint quantity) public returns (bool);\r\n    function transfer(address to, uint quantity) public returns (bool);\r\n    function transferFrom(address from, address to, uint quantity) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint quantity);\r\n    event Approval(address indexed owner, address indexed spender, uint quantity);\r\n\r\n}\r\n\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    /**\r\n     * @dev Owned Constructor\r\n     * @param _owner The initial owner of the contract.\r\n     */\r\n    constructor(address _owner)\r\n        public\r\n    {\r\n        require(_owner != address(0), \"Null owner address.\");\r\n        owner = _owner;\r\n        emit OwnerChanged(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Nominate a new owner of this contract.\r\n     * @dev Only the current owner may nominate a new owner.\r\n     * @param _owner The new owner to be nominated.\r\n     */\r\n    function nominateNewOwner(address _owner)\r\n        public\r\n        onlyOwner\r\n    {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Accept the nomination to be owner.\r\n     */\r\n    function acceptOwnership()\r\n        external\r\n    {\r\n        require(msg.sender == nominatedOwner, \"Not nominated.\");\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner\r\n    {\r\n        require(msg.sender == owner, \"Not owner.\");\r\n        _;\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title A pausable contract.\r\n * @dev The inheriting contract must itself inherit from Owned, and initialise it.\r\n */\r\ncontract Pausable is Owned {\r\n\r\n    bool public paused;\r\n    \r\n    /**\r\n     * @dev Internal `pause()` with no owner-only constraint.\r\n     */\r\n    function _pause()\r\n        internal\r\n    {\r\n        if (!paused) {\r\n            paused = true;\r\n            emit Paused();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Pause operations of the contract.\r\n     * @dev Functions modified with `onlyUnpaused` will cease to operate,\r\n     *      while functions with `onlyPaused` will start operating.\r\n     *      If this is called while the contract is paused, nothing will happen. \r\n     */\r\n    function pause() \r\n        public\r\n        onlyOwner\r\n    {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Internal `unpause()` with no owner-only constraint.\r\n     */\r\n    function _unpause()\r\n        internal\r\n    {\r\n        if (paused) {\r\n            paused = false;\r\n            emit Unpaused();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Unpause operations of the contract.\r\n     * @dev Functions modified with `onlyPaused` will cease to operate,\r\n     *      while functions with `onlyUnpaused` will start operating.\r\n     *      If this is called while the contract is unpaused, nothing will happen. \r\n     */\r\n    function unpause()\r\n        public\r\n        onlyOwner\r\n    {\r\n        _unpause();\r\n    }\r\n\r\n    modifier onlyPaused {\r\n        require(paused, \"Contract must be paused.\");\r\n        _;\r\n    }\r\n\r\n    modifier pausable {\r\n        require(!paused, \"Contract must not be paused.\");\r\n        _;\r\n    }\r\n\r\n    event Paused();\r\n    event Unpaused();\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title This contract can be destroyed by its owner after a delay elapses.\r\n * @dev The inheriting contract must itself inherit from Owned, and initialise it.\r\n */\r\ncontract SelfDestructible is Owned {\r\n\r\n    uint public selfDestructInitiationTime;\r\n    bool public selfDestructInitiated;\r\n    address public selfDestructBeneficiary;\r\n    uint public constant SELFDESTRUCT_DELAY = 4 weeks;\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param _beneficiary The account which will receive ether upon self-destruct.\r\n     */\r\n    constructor(address _beneficiary)\r\n        public\r\n    {\r\n        selfDestructBeneficiary = _beneficiary;\r\n        emit SelfDestructBeneficiaryUpdated(_beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the beneficiary address of this contract.\r\n     * @dev Only the contract owner may call this. The provided beneficiary must be non-null.\r\n     * @param _beneficiary The address to pay any eth contained in this contract to upon self-destruction.\r\n     */\r\n    function setSelfDestructBeneficiary(address _beneficiary)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(_beneficiary != address(0), \"Beneficiary must not be the zero address.\");\r\n        selfDestructBeneficiary = _beneficiary;\r\n        emit SelfDestructBeneficiaryUpdated(_beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @notice Begin the self-destruction counter of this contract.\r\n     * Once the delay has elapsed, the contract may be self-destructed.\r\n     * @dev Only the contract owner may call this, and only if self-destruct has not been initiated.\r\n     */\r\n    function initiateSelfDestruct()\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(!selfDestructInitiated, \"Self-destruct already initiated.\");\r\n        selfDestructInitiationTime = now;\r\n        selfDestructInitiated = true;\r\n        emit SelfDestructInitiated(SELFDESTRUCT_DELAY);\r\n    }\r\n\r\n    /**\r\n     * @notice Terminate and reset the self-destruction timer.\r\n     * @dev Only the contract owner may call this, and only during self-destruction.\r\n     */\r\n    function terminateSelfDestruct()\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(selfDestructInitiated, \"Self-destruct not yet initiated.\");\r\n        selfDestructInitiationTime = 0;\r\n        selfDestructInitiated = false;\r\n        emit SelfDestructTerminated();\r\n    }\r\n\r\n    /**\r\n     * @notice If the self-destruction delay has elapsed, destroy this contract and\r\n     * remit any ether it owns to the beneficiary address.\r\n     * @dev Only the contract owner may call this.\r\n     */\r\n    function selfDestruct()\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(selfDestructInitiated, \"Self-destruct not yet initiated.\");\r\n        require(selfDestructInitiationTime + SELFDESTRUCT_DELAY < now, \"Self-destruct delay has not yet elapsed.\");\r\n        address beneficiary = selfDestructBeneficiary;\r\n        emit SelfDestructed(beneficiary);\r\n        selfdestruct(beneficiary);\r\n    }\r\n\r\n    event SelfDestructTerminated();\r\n    event SelfDestructed(address beneficiary);\r\n    event SelfDestructInitiated(uint selfDestructDelay);\r\n    event SelfDestructBeneficiaryUpdated(address newBeneficiary);\r\n}\r\n\r\n\r\ncontract CROWN is ERC20Token, Owned, Pausable, SelfDestructible {\r\n\r\n    /**\r\n     * @param _totalSupply The initial supply of tokens, which will be given to\r\n     *                     the initial owner of the contract. This quantity is\r\n     *                     a fixed-point integer with 18 decimal places (wei).\r\n     * @param _owner The initial owner of the contract, who must unpause the contract\r\n     *               before it can be used, but may use the `initBatchTransfer` to disburse\r\n     *               funds to initial token holders before unpausing it.\r\n     */\r\n    constructor(uint _totalSupply, address _owner)\r\n        Owned(_owner)\r\n        Pausable()\r\n        SelfDestructible(_owner)\r\n        public\r\n    {\r\n        _pause();\r\n        name = \"CROWNFINANCE\";\r\n        symbol = \"CRWN\";\r\n        decimals = 8;\r\n        totalSupply = _totalSupply;\r\n        balanceOf[this] = totalSupply;\r\n        emit Transfer(address(0), this, totalSupply);\r\n    }\r\n\r\n\r\n    modifier requireSameLength(uint a, uint b) {\r\n        require(a == b, \"Input array lengths differ.\");\r\n        _;\r\n    }\r\n\r\n    /* Although we could have merged SelfDestructible and Pausable, this\r\n     * modifier keeps those contracts decoupled. */\r\n    modifier pausableIfNotSelfDestructing {\r\n        require(!paused || selfDestructInitiated, \"Contract must not be paused.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the difference of the given arguments. Will throw an exception iff `x < y`.\r\n     * @return `y` subtracted from `x`.\r\n     */\r\n    function safeSub(uint x, uint y)\r\n        pure\r\n        internal\r\n        returns (uint)\r\n    {\r\n        require(y <= x, \"Safe sub failed.\");\r\n        return x - y;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Transfers `quantity` tokens from `from` to `to`.\r\n     * @dev Throws an exception if the balance owned by the `from` address is less than `quantity`, or if\r\n     *      the transfer is to the 0x0 address, in case it was the result of an omitted argument.\r\n     * @param from The spender.\r\n     * @param to The recipient.\r\n     * @param quantity The quantity to transfer, in wei.\r\n     * @return Always returns true if no exception was thrown.\r\n     */\r\n    function _transfer(address from, address to, uint quantity)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(to != address(0), \"Transfers to 0x0 disallowed.\");\r\n        balanceOf[from] = safeSub(balanceOf[from], quantity); // safeSub handles insufficient balance.\r\n        balanceOf[to] += quantity;\r\n        emit Transfer(from, to, quantity);\r\n        return true;\r\n\r\n        /* Since balances are only manipulated here, and the sum of all\r\n         * balances is preserved, no balance is greater than\r\n         * totalSupply; the safeSub implies that balanceOf[to] + quantity is\r\n         * no greater than totalSupply.\r\n         * Thus a safeAdd is unnecessary, since overflow is impossible. */\r\n    }\r\n\r\n    /**\r\n      * @notice ERC20 transfer function; transfers `quantity` tokens from the message sender to `to`.\r\n      * @param to The recipient.\r\n      * @param quantity The quantity to transfer, in wei.\r\n      * @dev Exceptional conditions:\r\n      *          * The contract is paused if it is not self-destructing.\r\n      *          * The sender's balance is less than the transfer quantity.\r\n      *          * The `to` parameter is 0x0.\r\n      * @return Always returns true if no exception was thrown.\r\n      */\r\n    function transfer(address to, uint quantity)\r\n        public\r\n        pausableIfNotSelfDestructing\r\n        returns (bool)\r\n    {\r\n        return _transfer(msg.sender, to, quantity);\r\n    }\r\n\r\n\r\n    function approve(address spender, uint quantity)\r\n        public\r\n        pausableIfNotSelfDestructing\r\n        returns (bool)\r\n    {\r\n        require(spender != address(0), \"Approvals for 0x0 disallowed.\");\r\n        allowance[msg.sender][spender] = quantity;\r\n        emit Approval(msg.sender, spender, quantity);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @notice ERC20 transferFrom function; transfers `quantity` tokens from\r\n      *         `from` to `to` if the sender is approved.\r\n      * @param from The spender; balance is deducted from this account.\r\n      * @param to The recipient.\r\n      * @param quantity The quantity to transfer, in wei.\r\n      * @dev Exceptional conditions:\r\n      *          * The contract is paused if it is not self-destructing.\r\n      *          * The `from` account has approved the sender to spend less than the transfer quantity.\r\n      *          * The `from` account's balance is less than the transfer quantity.\r\n      *          * The `to` parameter is 0x0.\r\n      * @return Always returns true if no exception was thrown.\r\n      */\r\n    function transferFrom(address from, address to, uint quantity)\r\n        public\r\n        pausableIfNotSelfDestructing\r\n        returns (bool)\r\n    {\r\n        // safeSub handles insufficient allowance.\r\n        allowance[from][msg.sender] = safeSub(allowance[from][msg.sender], quantity);\r\n        return _transfer(from, to, quantity);\r\n    }\r\n\r\n\r\n    /**\r\n      * @notice Performs ERC20 transfers in batches; for each `i`,\r\n      *         transfers `quantity[i]` tokens from the message sender to `to[i]`.\r\n      * @param recipients An array of recipients.\r\n      * @param quantities A corresponding array of transfer quantities, in wei.\r\n      * @dev Exceptional conditions:\r\n      *          * The `recipients` and `quantities` arrays differ in length.\r\n      *          * The sender's balance is less than the transfer quantity.\r\n      *          * Any recipient is 0x0.\r\n      * @return Always returns true if no exception was thrown.\r\n      */\r\n    function _batchTransfer(address sender, address[] recipients, uint[] quantities)\r\n        internal\r\n        requireSameLength(recipients.length, quantities.length)\r\n        returns (bool)\r\n    {\r\n        uint length = recipients.length;\r\n        for (uint i = 0; i < length; i++) {\r\n            _transfer(sender, recipients[i], quantities[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @notice Performs ERC20 transfers in batches; for each `i`,\r\n      *         transfers `quantities[i]` tokens from the message sender to `recipients[i]`.\r\n      * @param recipients An array of recipients.\r\n      * @param quantities A corresponding array of transfer quantities, in wei.\r\n      * @dev Exceptional conditions:\r\n      *          * The contract is paused if it is not self-destructing.\r\n      *          * The `recipients` and `quantities` arrays differ in length.\r\n      *          * The sender's balance is less than the transfer quantity.\r\n      *          * Any recipient is 0x0.\r\n      * @return Always returns true if no exception was thrown.\r\n      */\r\n    function batchTransfer(address[] recipients, uint[] quantities)\r\n        external\r\n        pausableIfNotSelfDestructing\r\n        returns (bool)\r\n    {\r\n        return _batchTransfer(msg.sender, recipients, quantities);\r\n    }\r\n\r\n    /**\r\n      * @notice Performs ERC20 approvals in batches; for each `i`,\r\n      *         approves `quantities[i]` tokens to be spent by `spenders[i]`\r\n      *         on behalf of the message sender.\r\n      * @param spenders An array of spenders.\r\n      * @param quantities A corresponding array of approval quantities, in wei.\r\n      * @dev Exceptional conditions:\r\n      *          * The contract is paused if it is not self-destructing.\r\n      *          * The `spenders` and `quantities` arrays differ in length.\r\n      *          * Any spender is 0x0.\r\n      * @return Always returns true if no exception was thrown.\r\n      */\r\n    function batchApprove(address[] spenders, uint[] quantities)\r\n        external\r\n        pausableIfNotSelfDestructing\r\n        requireSameLength(spenders.length, quantities.length)\r\n        returns (bool)\r\n    {\r\n        uint length = spenders.length;\r\n        for (uint i = 0; i < length; i++) {\r\n            approve(spenders[i], quantities[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @notice Performs ERC20 transferFroms in batches; for each `i`,\r\n      *         transfers `quantities[i]` tokens from `spenders[i]` to `recipients[i]`\r\n      *         if the sender is approved.\r\n      * @param spenders An array of spenders.\r\n      * @param recipients An array of recipients.\r\n      * @param quantities A corresponding array of transfer quantities, in wei.\r\n      * @dev For the common use cases of transferring from many spenders to one recipient or vice versa,\r\n      *      the sole spender or recipient must be duplicated in the input array.\r\n      *      Exceptional conditions:\r\n      *          * The contract is paused if it is not self-destructing.\r\n      *          * Any of the `spenders`, `recipients`, or `quantities` arrays differ in length.\r\n      *          * Any spender account has approved the sender to spend less than the transfer quantity.\r\n      *          * Any spender account's balance is less than its corresponding transfer quantity.\r\n      *          * Any recipient is 0x0.\r\n      * @return Always returns true if no exception was thrown.\r\n      */\r\n    function batchTransferFrom(address[] spenders, address[] recipients, uint[] quantities)\r\n        external\r\n        pausableIfNotSelfDestructing\r\n        requireSameLength(spenders.length, recipients.length)\r\n        requireSameLength(recipients.length, quantities.length)\r\n        returns (bool)\r\n    {\r\n        uint length = spenders.length;\r\n        for (uint i = 0; i < length; i++) {\r\n            transferFrom(spenders[i], recipients[i], quantities[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    function contractBatchTransfer(address[] recipients, uint[] quantities)\r\n        external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        return _batchTransfer(this, recipients, quantities);\r\n    }\r\n\r\n}"}}}