{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 9999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "DenGovernance.sol": {
      "content": "pragma solidity >=0.5.12;\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\ncontract ReentrancyGuard {\n    bool private _notEntered;\n\n    constructor () internal {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n\n/**\n * @title ERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas\n     * @param _interfaceId The interface identifier, as specified in ERC-165\n     */\n    function supportsInterface(bytes4 _interfaceId)\n    external\n    view\n    returns (bool);\n}\n\n/**\n * @dev ERC-1155 interface for accepting safe transfers.\n */\ninterface IERC1155TokenReceiver {\n\n  /**\n   * @notice Handle the receipt of a single ERC1155 token type\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\n   * This function MAY throw to revert and reject the transfer\n   * Return of other amount than the magic value MUST result in the transaction being reverted\n   * Note: The token contract address is always the message sender\n   * @param _operator  The address which called the `safeTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _id        The id of the token being transferred\n   * @param _amount    The amount of tokens being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n   */\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\n\n  /**\n   * @notice Handle the receipt of multiple ERC1155 token types\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\n   * This function MAY throw to revert and reject the transfer\n   * Return of other amount than the magic value WILL result in the transaction being reverted\n   * Note: The token contract address is always the message sender\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _ids       An array containing ids of each token being transferred\n   * @param _amounts   An array containing amounts of each token being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n   */\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\n\n  /**\n   * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\n   * @param  interfaceID The ERC-165 interface ID that is queried for support.s\n   * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\n   *      This function MUST NOT consume more than 5,000 gas.\n   * @return Wheter ERC-165 or ERC1155TokenReceiver interfaces are supported.\n   */\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n}\n\ninterface IERC1155 {\n\tfunction safeTransferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _id,\n\t\tuint256 _amount,\n\t\tbytes calldata _data\n\t) external;\n\n\tfunction balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n\tfunction burn(uint256 id, uint256 amount) external;\n}\n\ncontract DenGovernance is ReentrancyGuard {\n\tevent PeriodAdded(uint256 periodId, uint256 endEpoch, uint256 lotId, uint256 maxIssuance);\n\tevent Staked(address owner, uint256 periodId, uint256 quantity);\n\tevent Withdrawn(address, uint256);\n\n\tusing SafeMath for uint256;\n\n\tstruct GovernancePeriod {\n\t\taddress tokenAddress;\n\t\tuint256 amount;\n\t\tuint256 startEpoch;\n\t\tuint256 endEpoch;\n\t\tuint256 lotId;\n\t\tuint256 issued;\n\t\tuint256 maxIssuance;\n\t\tuint256 fee; // 1 decimal allowed Example: 3.5% = 35\n\t\tuint256 feesCollected;\n\t\tuint256 deposited;\n\t\tuint256 withdrawn;\n\t}\n\n\tmapping(uint256 => GovernancePeriod) public governancePeriods;\n\tmapping(address => bool) public protectedTokens;\n\n\tuint256 public totalPeriods;\n\taddress public lotAddress;\n\taddress public denGovernance;\n\n\tconstructor(address _denGovernance, address _lotAddress) public {\n\t\tdenGovernance = _denGovernance;\n\t\tlotAddress = _lotAddress;\n\t}\n\n\tmodifier onlyDenGovernance {\n\t\trequire(msg.sender == denGovernance, \"not owner\");\n\t\t_;\n\t}\n\n\tfunction withdrawCollectedFees(uint256 periodId) public nonReentrant() onlyDenGovernance {\n\t\tGovernancePeriod storage gp = governancePeriods[periodId];\n\t\tuint256 amountToWithdraw = gp.feesCollected;\n\t\tgp.feesCollected = 0;\n\t\trequire(IERC20(gp.tokenAddress).transfer(denGovernance, amountToWithdraw), \"token transfer failed\");\n\t\temit Withdrawn(denGovernance, amountToWithdraw);\n\t}\n\n\tfunction stakeForPeriod(uint256 periodId, uint256 quantity) public {\n\t\tGovernancePeriod storage gp = governancePeriods[periodId];\n\n\t\trequire(block.timestamp >= gp.startEpoch, \"period not open\");\n\t\trequire(block.timestamp <= gp.endEpoch, \"period has ended\");\n\t\trequire(gp.issued.add(quantity) <= gp.maxIssuance, \"requested quantity higher than available\");\n\n\t\tuint256 depositAmount = gp.amount.mul(quantity);\n\t\tuint256 allowance = IERC20(gp.tokenAddress).allowance(msg.sender, address(this));\n\t\trequire(allowance >= depositAmount, \"You need to set a higher allowance\");\n\n\t\t// charge a fee\n\t\tuint256 feeAmount = depositAmount.mul(gp.fee).div(1000);\n\t\tuint256 maxWithdrawAmount = depositAmount.sub(feeAmount);\n\n\t\tgp.feesCollected = gp.feesCollected.add(feeAmount);\n\t\tgp.deposited = gp.deposited.add(maxWithdrawAmount);\n\t\tgp.issued = gp.issued.add(quantity);\n\n\t\trequire(\n\t\t\tIERC20(gp.tokenAddress).transferFrom(msg.sender, address(this), depositAmount),\n\t\t\t\"token transfer failed\"\n\t\t);\n\t\trequire(IERC1155(lotAddress).balanceOf(address(this), gp.lotId) >= quantity, \"lot not present\");\n\t\tIERC1155(lotAddress).safeTransferFrom(address(this), msg.sender, gp.lotId, quantity, \"\");\n\n\t\temit Staked(msg.sender, periodId, quantity);\n\t}\n\n\tfunction withdrawable(uint256 periodId) public view returns (bool) {\n\t\tif (governancePeriods[periodId].endEpoch >= block.timestamp) return true;\n\t\treturn false;\n\t}\n\n\tfunction getOwnerBalance(address owner, uint256 periodId)\n\t\tpublic\n\t\tview\n\t\treturns (uint256 lotBalance, uint256 lpBalance)\n\t{\n\t\tGovernancePeriod memory gp = governancePeriods[periodId];\n\n\t\tlotBalance = IERC1155(lotAddress).balanceOf(owner, gp.lotId);\n\t\tif (lotBalance > gp.issued) return (lotBalance, 0);\n\t\tlpBalance = lotBalance.mul(gp.deposited.div(gp.issued));\n\n\t\treturn (lotBalance, lpBalance);\n\t}\n\n\tfunction _createGovernancePeriod(\n\t\taddress tokenAddress,\n\t\tuint256 lotId,\n\t\tuint256 maxIssuance,\n\t\tuint256 amount,\n\t\tuint256 fee,\n\t\tuint256 startEpoch,\n\t\tuint256 endEpoch\n\t) internal nonReentrant() {\n\t\trequire(fee < 1000, \"fee is too high\");\n\t\trequire(endEpoch > startEpoch, \"end is before start\");\n\t\trequire(endEpoch > block.timestamp, \"epoch has passed\");\n\t\tuint256 periodId = totalPeriods;\n\n\t\tGovernancePeriod memory period =\n\t\t\tGovernancePeriod({\n\t\t\t\ttokenAddress: tokenAddress,\n\t\t\t\tamount: amount,\n\t\t\t\tstartEpoch: startEpoch,\n\t\t\t\tendEpoch: endEpoch,\n\t\t\t\tlotId: lotId,\n\t\t\t\tissued: 0,\n\t\t\t\tmaxIssuance: maxIssuance,\n\t\t\t\tfee: fee,\n\t\t\t\tfeesCollected: 0,\n\t\t\t\tdeposited: 0,\n\t\t\t\twithdrawn: 0\n\t\t\t});\n\n\t\tprotectedTokens[tokenAddress] = true;\n\t\tgovernancePeriods[periodId] = period;\n\t\ttotalPeriods++;\n\n\t\temit PeriodAdded(periodId, endEpoch, lotId, maxIssuance);\n\t}\n\n\tfunction _withdraw(\n\t\taddress owner,\n\t\tuint256 periodId,\n\t\tuint256 lotId,\n\t\tuint256 amount\n\t) internal nonReentrant() {\n\t\tGovernancePeriod storage gp = governancePeriods[periodId];\n\n\t\trequire(block.timestamp >= gp.endEpoch, \"period has not ended\");\n\t\trequire(lotId == gp.lotId, \"lot sent for period is not correct\");\n\t\trequire(amount <= gp.issued, \"invalid amount\");\n\n\t\tuint256 withdrawableLp = amount.mul(gp.deposited.div(gp.issued));\n\t\trequire(gp.withdrawn.add(withdrawableLp) <= gp.deposited, \"invalid amount requested\");\n\t\tgp.withdrawn = gp.withdrawn.add(withdrawableLp);\n\n\t\tIERC1155(lotAddress).burn(gp.lotId, amount);\n\t\trequire(IERC20(gp.tokenAddress).transfer(owner, withdrawableLp), \"token transfer failed\");\n\n\t\temit Withdrawn(owner, amount);\n\t}\n\n\tfunction sweep(address token) external onlyDenGovernance {\n\t\trequire(!protectedTokens[token], \"token is protected\");\n\t\tIERC20(token).transfer(denGovernance, IERC20(token).balanceOf(address(this)));\n\t}\n\n\t// bytes4(keccak256(_createGovernancePeriod()));\n\tbytes4 internal constant CREATEPERIOD_SIG = 0xa3b05fe3;\n\n\t// bytes4(keccak256(_withdraw(uint256)));\n\tbytes4 internal constant WITHDRAW_SIG = 0xac6a2b5d;\n\n\t/**\n\t * @dev Will pass to onERC1155Batch5Received\n\t */\n\tfunction onERC1155Received(\n\t\taddress _operator,\n\t\taddress _from,\n\t\tuint256 _id,\n\t\tuint256 _amount,\n\t\tbytes memory _data\n\t) public returns (bytes4) {\n\t\tuint256[] memory ids = new uint256[](1);\n\t\tuint256[] memory amounts = new uint256[](1);\n\n\t\tids[0] = _id;\n\t\tamounts[0] = _amount;\n\n\t\trequire(\n\t\t\tthis.onERC1155BatchReceived.selector == onERC1155BatchReceived(_operator, _from, ids, amounts, _data),\n\t\t\t\"invalid on receive message\"\n\t\t);\n\n\t\treturn this.onERC1155Received.selector;\n\t}\n\n\tfunction onERC1155BatchReceived(\n\t\taddress _operator,\n\t\taddress _from,\n\t\tuint256[] memory _ids,\n\t\tuint256[] memory _amounts,\n\t\tbytes memory _data\n\t) public returns (bytes4) {\n\t\t// Transferred token needs to be LOT\n\t\trequire(msg.sender == address(lotAddress), \"invalid token address\");\n\t\trequire(_ids.length == 1, \"invalid LOT amount\");\n\n\t\t// Obtain method to call via object signature\n\t\tbytes4 functionSignature = abi.decode(_data, (bytes4));\n\n\t\t/***********************************|\n        |            Deposit LOT            |\n        |__________________________________*/\n\n\t\tif (functionSignature == CREATEPERIOD_SIG) {\n\t\t\trequire(_operator == denGovernance, \"operator must be den governance\");\n\n\t\t\t(, address tokenAddress, uint256 amount, uint256 fee, uint256 startEpoch, uint256 endEpoch) =\n\t\t\t\tabi.decode(_data, (bytes4, address, uint256, uint256, uint256, uint256));\n\t\t\t// 0xa3b05fe300000000000000000000000000000000000000000000000000000000\n\t\t\t_createGovernancePeriod(tokenAddress, _ids[0], _amounts[0], amount, fee, startEpoch, endEpoch);\n\n\t\t\t/***********************************|\n            |           Withdraw LOT            |\n            |__________________________________*/\n\t\t} else if (functionSignature == WITHDRAW_SIG) {\n\t\t\t(, uint256 periodId) = abi.decode(_data, (bytes4, uint256));\n\n\t\t\t_withdraw(_from, periodId, _ids[0], _amounts[0]);\n\t\t} else {\n\t\t\trevert(\"invalid method\");\n\t\t}\n\n\t\t// Return success\n\t\treturn this.onERC1155BatchReceived.selector;\n\t}\n\n\tfunction supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n\t\treturn\n\t\t\tinterfaceID == 0x01ffc9a7 || // ERC-165 support\n\t\t\tinterfaceID == 0x4e2312e0; // ERC-1155 `ERC1155TokenReceiver` support\n\t}\n}"
    }
  }
}