{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 99999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ApolloDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n//Use 0.8.3\r\n\r\ncontract Token {\r\n    function changeArtistAddress(address newAddress) external {}\r\n    function balanceOf(address account) external view returns (uint256){}\r\n    function transfer(address recipient, uint256 amount) external returns (bool){}\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool){}\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract ApolloDAO is Context {\r\n\r\n    Token public immutable apolloToken;\r\n\r\n    event newDaoNomination(address indexed newDAO, address indexed nominator);\r\n\r\n    struct newDAONomination {\r\n    uint256 timeOfNomination;\r\n    address nominator;\r\n    uint256 votesFor;\r\n    uint256 votesAgainst;\r\n    bool votingClosed;\r\n    }\r\n\r\n    struct DAOVotes {\r\n        uint256 voteCount;\r\n        bool votedFor;\r\n    }\r\n\r\n    mapping (address => newDAONomination) private newDAONominations;\r\n    mapping (address => mapping (address => DAOVotes)) private lockedVotes;\r\n\r\n    uint256 public constant daoVotingDuration = 604800;\r\n    uint256 public constant minimumDAOBalance = 20000000000 * 10**9;\r\n    uint256 public totalLockedVotes;\r\n    uint256 public activeDaoNominations;\r\n\r\n    address public approvedNewDAO = address(0);\r\n    uint256 public constant daoUpdateDelay = 604800;\r\n    uint256 public daoApprovedTime;\r\n\r\n\r\n    constructor (address tokenAddress) {\r\n        apolloToken = Token(tokenAddress);\r\n    }\r\n\r\n\r\n    function voteForDAONomination (uint256 voteAmount, address newDAO, bool voteFor) external {\r\n        require(newDAONominations[newDAO].timeOfNomination > 0 , \"There is no DAO Nomination for this address\");\r\n        require(lockedVotes[_msgSender()][newDAO].voteCount == 0, \"User already voted on this nomination\");\r\n        require(approvedNewDAO == address(0), \"There is already an approved new DAO\");\r\n        apolloToken.transferFrom(_msgSender(), address(this), voteAmount);\r\n        totalLockedVotes += voteAmount;\r\n        lockedVotes[_msgSender()][newDAO].voteCount += voteAmount;\r\n        lockedVotes[_msgSender()][newDAO].votedFor = voteFor;\r\n        if(voteFor){\r\n            newDAONominations[newDAO].votesFor += voteAmount;\r\n        } else {\r\n            newDAONominations[newDAO].votesAgainst += voteAmount;\r\n        }\r\n    }\r\n\r\n    function withdrawNewDAOVotes (address newDAO) external {\r\n        uint256 currentVoteCount = lockedVotes[_msgSender()][newDAO].voteCount;\r\n        require(currentVoteCount > 0 , \"You have not cast votes for this nomination\");\r\n        require((totalLockedVotes - currentVoteCount) >= 0, \"Withdrawing would take DAO balance below expected rewards amount\");\r\n        apolloToken.transfer(_msgSender(), currentVoteCount);\r\n\r\n        totalLockedVotes -= currentVoteCount;\r\n        lockedVotes[_msgSender()][newDAO].voteCount -= currentVoteCount;\r\n\r\n        if(lockedVotes[_msgSender()][newDAO].votedFor){\r\n            newDAONominations[newDAO].votesFor -= currentVoteCount;\r\n        } else {\r\n            newDAONominations[newDAO].votesAgainst -= currentVoteCount;\r\n        }\r\n\r\n    }\r\n\r\n    function nominateNewDAO (address newDAO) external {\r\n        require(apolloToken.balanceOf(_msgSender()) >= minimumDAOBalance , \"Nominator does not own enough APOOLLO\");\r\n        newDAONominations[newDAO] = newDAONomination(\r\n            {\r\n                timeOfNomination: block.timestamp,\r\n                nominator: _msgSender(),\r\n                votesFor: 0,\r\n                votesAgainst: 0,\r\n                votingClosed: false\r\n            }\r\n        );\r\n        activeDaoNominations += 1;\r\n        emit newDaoNomination(newDAO, _msgSender());\r\n    }\r\n\r\n    function closeNewDAOVoting (address newDAO) external {\r\n        require(block.timestamp > (newDAONominations[newDAO].timeOfNomination + daoVotingDuration), \"We have not passed the minimum voting duration\");\r\n        require(!newDAONominations[newDAO].votingClosed, \"Voting has already closed for this nomination\");\r\n        require(approvedNewDAO == address(0), \"There is already an approved new DAO\");\r\n\r\n        if(newDAONominations[newDAO].votesFor > newDAONominations[newDAO].votesAgainst){\r\n            approvedNewDAO = newDAO;\r\n            daoApprovedTime = block.timestamp;\r\n        }\r\n        activeDaoNominations -= 1;\r\n        newDAONominations[newDAO].votingClosed = true;\r\n    }\r\n\r\n    function updateDAOAddress() external {\r\n        require(approvedNewDAO != address(0),\"There is not an approved new DAO\");\r\n        require(block.timestamp > (daoApprovedTime + daoUpdateDelay), \"We have finished the delay for an approved DAO\");\r\n        apolloToken.changeArtistAddress(approvedNewDAO);\r\n    }\r\n\r\n    function daoNominationTime(address dao) external view returns (uint256){\r\n        return newDAONominations[dao].timeOfNomination;\r\n    }\r\n\r\n    function daoNominationNominator(address dao) external view returns (address){\r\n        return newDAONominations[dao].nominator;\r\n    }\r\n\r\n    function daoNominationVotesFor(address dao) external view returns (uint256){\r\n        return newDAONominations[dao].votesFor;\r\n    }\r\n\r\n    function daoNominationVotesAgainst(address dao) external view returns (uint256){\r\n        return newDAONominations[dao].votesAgainst;\r\n    }\r\n\r\n    function daoNominationVotingClosed(address dao) external view returns (bool){\r\n        return newDAONominations[dao].votingClosed;\r\n    }\r\n\r\n    function checkAddressVoteAmount(address voter, address dao) external view returns (uint256){\r\n        return lockedVotes[voter][dao].voteCount;\r\n    }\r\n\r\n    function checkAddressVotedFor(address voter, address dao) external view returns (bool){\r\n        return lockedVotes[voter][dao].votedFor;\r\n    }\r\n\r\n\r\n\r\n}"
    }
  }
}