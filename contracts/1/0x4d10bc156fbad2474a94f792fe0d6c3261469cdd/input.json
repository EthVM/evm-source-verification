{"language":"Solidity","sources":{"./contracts/fuse-contracts/contracts/oracles/MasterPriceOracle.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\nimport \"../external/compound/PriceOracle.sol\";\nimport \"../external/compound/CToken.sol\";\nimport \"../external/compound/CErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\n\n/**\n * @title MasterPriceOracle\n * @notice Use a combination of price oracles.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract MasterPriceOracle is Initializable, PriceOracle, BasePriceOracle {\n    /**\n     * @dev Maps underlying token addresses to `PriceOracle` contracts (can be `BasePriceOracle` contracts too).\n     */\n    mapping(address => PriceOracle) public oracles;\n\n    /**\n     * @dev Default/fallback `PriceOracle`.\n     */\n    PriceOracle public defaultOracle;\n\n    /**\n     * @dev The administrator of this `MasterPriceOracle`.\n     */\n    address public admin;\n\n    /**\n     * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n     */\n    bool internal noAdminOverwrite;\n\n    /**\n     * @dev Returns a boolean indicating if `admin` can overwrite existing assignments of oracles to underlying tokens.\n     */\n    function canAdminOverwrite() external view returns (bool) {\n        return !noAdminOverwrite;\n    }\n\n    /**\n     * @dev Event emitted when `admin` is changed.\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @dev Event emitted when the default oracle is changed.\n     */\n    event NewDefaultOracle(address oldOracle, address newOracle);\n\n    /**\n     * @dev Event emitted when an underlying token's oracle is changed.\n     */\n    event NewOracle(address underlying, address oldOracle, address newOracle);\n\n    /**\n     * @dev Constructor to initialize state variables.\n     * @param underlyings The underlying ERC20 token addresses to link to `_oracles`.\n     * @param _oracles The `PriceOracle` contracts to be assigned to `underlyings`.\n     * @param _defaultOracle The default `PriceOracle` contract to use.\n     * @param _admin The admin who can assign oracles to underlying tokens.\n     * @param _canAdminOverwrite Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n     */\n    function initialize(address[] memory underlyings, PriceOracle[] memory _oracles, PriceOracle _defaultOracle, address _admin, bool _canAdminOverwrite) external initializer {\n        // Input validation\n        require(underlyings.length == _oracles.length, \"Lengths of both arrays must be equal.\");\n\n        // Initialize state variables\n        for (uint256 i = 0; i < underlyings.length; i++) {\n            address underlying = underlyings[i];\n            PriceOracle newOracle = _oracles[i];\n            oracles[underlying] = newOracle;\n            emit NewOracle(underlying, address(0), address(newOracle));\n        }\n\n        defaultOracle = _defaultOracle;\n        admin = _admin;\n        noAdminOverwrite = !_canAdminOverwrite;\n    }\n\n    /**\n     * @dev Sets `_oracles` for `underlyings`.\n     */\n    function add(address[] calldata underlyings, PriceOracle[] calldata _oracles) external onlyAdmin {\n        // Input validation\n        require(underlyings.length > 0 && underlyings.length == _oracles.length, \"Lengths of both arrays must be equal and greater than 0.\");\n\n        // Assign oracles to underlying tokens\n        for (uint256 i = 0; i < underlyings.length; i++) {\n            address underlying = underlyings[i];\n            address oldOracle = address(oracles[underlying]);\n            if (noAdminOverwrite) require(oldOracle == address(0), \"Admin cannot overwrite existing assignments of oracles to underlying tokens.\");\n            PriceOracle newOracle = _oracles[i];\n            oracles[underlying] = newOracle;\n            emit NewOracle(underlying, oldOracle, address(newOracle));\n        }\n    }\n\n    /**\n     * @dev Changes the admin and emits an event.\n     */\n    function setDefaultOracle(PriceOracle newOracle) external onlyAdmin {\n        PriceOracle oldOracle = defaultOracle;\n        defaultOracle = newOracle;\n        emit NewDefaultOracle(address(oldOracle), address(newOracle));\n    }\n\n    /**\n     * @dev Changes the admin and emits an event.\n     */\n    function changeAdmin(address newAdmin) external onlyAdmin {\n        address oldAdmin = admin;\n        admin = newAdmin;\n        emit NewAdmin(oldAdmin, newAdmin);\n    }\n\n    /**\n     * @dev Modifier that checks if `msg.sender == admin`.\n     */\n    modifier onlyAdmin {\n        require(msg.sender == admin, \"Sender is not the admin.\");\n        _;\n    }\n\n    /**\n     * @notice Returns the price in ETH of the token underlying `cToken`.\n     * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n     * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n     */\n    function getUnderlyingPrice(CToken cToken) external override view returns (uint) {\n        // Get underlying ERC20 token address\n        address underlying = address(CErc20(address(cToken)).underlying());\n\n        // Return 1e18 for WETH\n        if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) return 1e18;\n\n        // Get underlying price from assigned oracle\n        PriceOracle oracle = oracles[underlying];\n        if (address(oracle) != address(0)) return oracle.getUnderlyingPrice(cToken);\n        if (address(defaultOracle) != address(0)) return defaultOracle.getUnderlyingPrice(cToken);\n        revert(\"Price oracle not found for this underlying token address.\");\n    }\n\n    /**\n     * @dev Attempts to return the price in ETH of `underlying` (implements `BasePriceOracle`).\n     */\n    function price(address underlying) external override view returns (uint) {\n        // Return 1e18 for WETH\n        if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) return 1e18;\n\n        // Get underlying price from assigned oracle\n        PriceOracle oracle = oracles[underlying];\n        if (address(oracle) != address(0)) return BasePriceOracle(address(oracle)).price(underlying);\n        if (address(defaultOracle) != address(0)) return BasePriceOracle(address(defaultOracle)).price(underlying);\n        revert(\"Price oracle not found for this underlying token address.\");\n    }\n}\n"},"./contracts/fuse-contracts/contracts/external/compound/PriceOracle.sol":{"content":"// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\nimport \"./CToken.sol\";\n\ninterface PriceOracle {\n    /**\n      * @notice Get the underlying price of a cToken asset\n      * @param cToken The cToken to get the underlying price of\n      * @return The underlying asset price mantissa (scaled by 1e18).\n      *  Zero means the price is unavailable.\n      */\n    function getUnderlyingPrice(CToken cToken) external view returns (uint);\n}\n"},"./contracts/fuse-contracts/contracts/external/compound/CToken.sol":{"content":"// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ninterface CToken {\n    function admin() external view returns (address);\n    function adminHasRights() external view returns (bool);\n    function fuseAdminHasRights() external view returns (bool);\n    function symbol() external view returns (string memory);\n    function comptroller() external view returns (address);\n    function adminFeeMantissa() external view returns (uint256);\n    function fuseFeeMantissa() external view returns (uint256);\n    function reserveFactorMantissa() external view returns (uint256);\n    function totalReserves() external view returns (uint);\n    function totalAdminFees() external view returns (uint);\n    function totalFuseFees() external view returns (uint);\n\n    function isCToken() external view returns (bool);\n    function isCEther() external view returns (bool);\n\n    function balanceOf(address owner) external view returns (uint);\n    function balanceOfUnderlying(address owner) external returns (uint);\n    function borrowRatePerBlock() external view returns (uint);\n    function supplyRatePerBlock() external view returns (uint);\n    function totalBorrowsCurrent() external returns (uint);\n    function borrowBalanceStored(address account) external view returns (uint);\n    function exchangeRateStored() external view returns (uint);\n    function getCash() external view returns (uint);\n\n    function redeem(uint redeemTokens) external returns (uint);\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n}\n"},"./contracts/fuse-contracts/contracts/external/compound/CErc20.sol":{"content":"// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.6.12;\n\nimport \"./CToken.sol\";\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ninterface CErc20 is CToken {\n    function underlying() external view returns (address);\n    function liquidateBorrow(address borrower, uint repayAmount, CToken cTokenCollateral) external returns (uint);\n}\n"},"./contracts/fuse-contracts/contracts/oracles/BasePriceOracle.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"../external/compound/PriceOracle.sol\";\n\n/**\n * @title BasePriceOracle\n * @notice Returns prices of underlying tokens directly without the caller having to specify a cToken address.\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ninterface BasePriceOracle is PriceOracle {\n    /**\n     * @notice Get the price of an underlying asset.\n     * @param underlying The underlying asset to get the price of.\n     * @return The underlying asset price in ETH as a mantissa (scaled by 1e18).\n     * Zero means the price is unavailable.\n     */\n    function price(address underlying) external view returns (uint);\n}\n"},"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"},"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"}},"settings":{"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","abi"]}}}}