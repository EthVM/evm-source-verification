{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":100},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/arch/Hashing.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./Value.sol\";\n\nlibrary Hashing {\n    using Hashing for Value.Data;\n    using Value for Value.CodePoint;\n\n    function keccak1(bytes32 b) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(b));\n    }\n\n    function keccak2(bytes32 a, bytes32 b) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(a, b));\n    }\n\n    function bytes32FromArray(\n        bytes memory arr,\n        uint256 offset,\n        uint256 arrLength\n    ) internal pure returns (uint256) {\n        uint256 res = 0;\n        for (uint256 i = 0; i < 32; i++) {\n            res = res << 8;\n            bytes1 b = arrLength > offset + i ? arr[offset + i] : bytes1(0);\n            res = res | uint256(uint8(b));\n        }\n        return res;\n    }\n\n    /*\n     * !! Note that dataLength must be a power of two !!\n     *\n     * If you have an arbitrary data length, you can round it up with roundUpToPow2.\n     * The boolean return value tells if the data segment data[startOffset..startOffset+dataLength] only included zeroes.\n     * If pack is true, the returned value is the merkle hash where trailing zeroes are ignored, that is,\n     *   if h is the smallest height for which all data[startOffset+2**h..] are zero, merkle hash of data[startOffset..startOffset+2**h] is returned.\n     * If all elements in the data segment are zero (and pack is true), keccak1(bytes32(0)) is returned.\n     */\n    function merkleRoot(\n        bytes memory data,\n        uint256 rawDataLength,\n        uint256 startOffset,\n        uint256 dataLength,\n        bool pack\n    ) internal pure returns (bytes32, bool) {\n        if (dataLength <= 32) {\n            if (startOffset >= rawDataLength) {\n                return (keccak1(bytes32(0)), true);\n            }\n            bytes32 res = keccak1(bytes32(bytes32FromArray(data, startOffset, rawDataLength)));\n            return (res, res == keccak1(bytes32(0)));\n        }\n        (bytes32 h2, bool zero2) =\n            merkleRoot(data, rawDataLength, startOffset + dataLength / 2, dataLength / 2, false);\n        if (zero2 && pack) {\n            return merkleRoot(data, rawDataLength, startOffset, dataLength / 2, pack);\n        }\n        (bytes32 h1, bool zero1) =\n            merkleRoot(data, rawDataLength, startOffset, dataLength / 2, false);\n        return (keccak2(h1, h2), zero1 && zero2);\n    }\n\n    function roundUpToPow2(uint256 len) internal pure returns (uint256) {\n        if (len <= 1) return 1;\n        else return 2 * roundUpToPow2((len + 1) / 2);\n    }\n\n    function bytesToBufferHash(\n        bytes memory buf,\n        uint256 startOffset,\n        uint256 length\n    ) internal pure returns (bytes32) {\n        (bytes32 mhash, ) =\n            merkleRoot(buf, startOffset + length, startOffset, roundUpToPow2(length), true);\n        return keccak2(bytes32(uint256(123)), mhash);\n    }\n\n    function hashInt(uint256 val) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(val));\n    }\n\n    function hashCodePoint(Value.CodePoint memory cp) internal pure returns (bytes32) {\n        assert(cp.immediate.length < 2);\n        if (cp.immediate.length == 0) {\n            return\n                keccak256(abi.encodePacked(Value.codePointTypeCode(), cp.opcode, cp.nextCodePoint));\n        }\n        return\n            keccak256(\n                abi.encodePacked(\n                    Value.codePointTypeCode(),\n                    cp.opcode,\n                    cp.immediate[0].hash(),\n                    cp.nextCodePoint\n                )\n            );\n    }\n\n    function hashTuplePreImage(bytes32 innerHash, uint256 valueSize)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(uint8(Value.tupleTypeCode()), innerHash, valueSize));\n    }\n\n    function hash(Value.Data memory val) internal pure returns (bytes32) {\n        if (val.typeCode == Value.intTypeCode()) {\n            return hashInt(val.intVal);\n        } else if (val.typeCode == Value.codePointTypeCode()) {\n            return hashCodePoint(val.cpVal);\n        } else if (val.typeCode == Value.tuplePreImageTypeCode()) {\n            return hashTuplePreImage(bytes32(val.intVal), val.size);\n        } else if (val.typeCode == Value.tupleTypeCode()) {\n            Value.Data memory preImage = getTuplePreImage(val.tupleVal);\n            return preImage.hash();\n        } else if (val.typeCode == Value.hashOnlyTypeCode()) {\n            return bytes32(val.intVal);\n        } else if (val.typeCode == Value.bufferTypeCode()) {\n            return keccak256(abi.encodePacked(uint256(123), val.bufferHash));\n        } else {\n            require(false, \"Invalid type code\");\n        }\n    }\n\n    function getTuplePreImage(Value.Data[] memory vals) internal pure returns (Value.Data memory) {\n        require(vals.length <= 8, \"Invalid tuple length\");\n        bytes32[] memory hashes = new bytes32[](vals.length);\n        uint256 hashCount = hashes.length;\n        uint256 size = 1;\n        for (uint256 i = 0; i < hashCount; i++) {\n            hashes[i] = vals[i].hash();\n            size += vals[i].size;\n        }\n        bytes32 firstHash = keccak256(abi.encodePacked(uint8(hashes.length), hashes));\n        return Value.newTuplePreImage(firstHash, size);\n    }\n}\n"},"contracts/arch/IOneStepProof.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"../bridge/interfaces/IBridge.sol\";\nimport \"../bridge/interfaces/ISequencerInbox.sol\";\n\ninterface IOneStepProof {\n    // Bridges is sequencer bridge then delayed bridge\n    function executeStep(\n        address[2] calldata bridges,\n        uint256 initialMessagesRead,\n        bytes32[2] calldata accs,\n        bytes calldata proof,\n        bytes calldata bproof\n    )\n        external\n        view\n        returns (\n            uint64 gas,\n            uint256 afterMessagesRead,\n            bytes32[4] memory fields\n        );\n\n    function executeStepDebug(\n        address[2] calldata bridges,\n        uint256 initialMessagesRead,\n        bytes32[2] calldata accs,\n        bytes calldata proof,\n        bytes calldata bproof\n    ) external view returns (string memory startMachine, string memory afterMachine);\n}\n"},"contracts/arch/Machine.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./Marshaling.sol\";\n\nimport \"../libraries/DebugPrint.sol\";\n\nlibrary Machine {\n    using Hashing for Value.Data;\n\n    // Make sure these don't conflict with Challenge.MACHINE_UNREACHABLE (currently 100)\n    uint256 internal constant MACHINE_EXTENSIVE = 0;\n    uint256 internal constant MACHINE_ERRORSTOP = 1;\n    uint256 internal constant MACHINE_HALT = 2;\n\n    function addStackVal(Value.Data memory stackValHash, Value.Data memory valHash)\n        internal\n        pure\n        returns (Value.Data memory)\n    {\n        Value.Data[] memory vals = new Value.Data[](2);\n        vals[0] = valHash;\n        vals[1] = stackValHash;\n\n        return Hashing.getTuplePreImage(vals);\n    }\n\n    struct Data {\n        bytes32 instructionStackHash;\n        Value.Data dataStack;\n        Value.Data auxStack;\n        Value.Data registerVal;\n        Value.Data staticVal;\n        uint256 arbGasRemaining;\n        bytes32 errHandlerHash;\n        uint256 status;\n    }\n\n    function toString(Data memory machine) internal pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    \"Machine(\",\n                    DebugPrint.bytes32string(machine.instructionStackHash),\n                    \", \\n\",\n                    DebugPrint.bytes32string(machine.dataStack.hash()),\n                    \", \\n\",\n                    DebugPrint.bytes32string(machine.auxStack.hash()),\n                    \", \\n\",\n                    DebugPrint.bytes32string(machine.registerVal.hash()),\n                    \", \\n\",\n                    DebugPrint.bytes32string(machine.staticVal.hash()),\n                    \", \\n\",\n                    DebugPrint.uint2str(machine.arbGasRemaining),\n                    \", \\n\",\n                    DebugPrint.bytes32string(machine.errHandlerHash),\n                    \")\\n\"\n                )\n            );\n    }\n\n    function setErrorStop(Data memory machine) internal pure {\n        machine.status = MACHINE_ERRORSTOP;\n    }\n\n    function setHalt(Data memory machine) internal pure {\n        machine.status = MACHINE_HALT;\n    }\n\n    function addDataStackValue(Data memory machine, Value.Data memory val) internal pure {\n        machine.dataStack = addStackVal(machine.dataStack, val);\n    }\n\n    function addAuxStackValue(Data memory machine, Value.Data memory val) internal pure {\n        machine.auxStack = addStackVal(machine.auxStack, val);\n    }\n\n    function addDataStackInt(Data memory machine, uint256 val) internal pure {\n        machine.dataStack = addStackVal(machine.dataStack, Value.newInt(val));\n    }\n\n    function hash(Data memory machine) internal pure returns (bytes32) {\n        if (machine.status == MACHINE_HALT) {\n            return bytes32(uint256(0));\n        } else if (machine.status == MACHINE_ERRORSTOP) {\n            return bytes32(uint256(1));\n        } else {\n            return\n                keccak256(\n                    abi.encodePacked(\n                        machine.instructionStackHash,\n                        machine.dataStack.hash(),\n                        machine.auxStack.hash(),\n                        machine.registerVal.hash(),\n                        machine.staticVal.hash(),\n                        machine.arbGasRemaining,\n                        machine.errHandlerHash\n                    )\n                );\n        }\n    }\n\n    function clone(Data memory machine) internal pure returns (Data memory) {\n        return\n            Data(\n                machine.instructionStackHash,\n                machine.dataStack,\n                machine.auxStack,\n                machine.registerVal,\n                machine.staticVal,\n                machine.arbGasRemaining,\n                machine.errHandlerHash,\n                machine.status\n            );\n    }\n\n    function deserializeMachine(bytes memory data, uint256 offset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            Data memory // machine\n        )\n    {\n        Data memory m;\n        m.status = MACHINE_EXTENSIVE;\n        uint256 instructionStack;\n        uint256 errHandler;\n        (offset, instructionStack) = Marshaling.deserializeInt(data, offset);\n\n        (offset, m.dataStack) = Marshaling.deserializeHashPreImage(data, offset);\n        (offset, m.auxStack) = Marshaling.deserializeHashPreImage(data, offset);\n        (offset, m.registerVal) = Marshaling.deserialize(data, offset);\n        (offset, m.staticVal) = Marshaling.deserialize(data, offset);\n        (offset, m.arbGasRemaining) = Marshaling.deserializeInt(data, offset);\n        (offset, errHandler) = Marshaling.deserializeInt(data, offset);\n\n        m.instructionStackHash = bytes32(instructionStack);\n        m.errHandlerHash = bytes32(errHandler);\n        return (offset, m);\n    }\n}\n"},"contracts/arch/Marshaling.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./Value.sol\";\nimport \"./Hashing.sol\";\n\nimport \"../libraries/BytesLib.sol\";\n\nlibrary Marshaling {\n    using BytesLib for bytes;\n    using Value for Value.Data;\n\n    // This depends on how it's implemented in arb-os\n    function deserializeMessage(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            bool,\n            uint256,\n            address,\n            uint8,\n            bytes memory\n        )\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 8, \"too short\");\n        uint256 size = 0;\n        for (uint256 i = 0; i < 8; i++) {\n            size *= 256;\n            size += uint8(data[startOffset + 7 - i]);\n        }\n        (, uint256 sender) = deserializeInt(data, startOffset + 8);\n        (, uint256 kind) = deserializeInt(data, startOffset + 8 + 32);\n        bytes memory res = new bytes(size - 64);\n        for (uint256 i = 0; i < size - 64; i++) {\n            res[i] = data[startOffset + 8 + 64 + i];\n        }\n        return (true, startOffset + 8 + size, address(uint160(sender)), uint8(kind), res);\n    }\n\n    function deserializeRawMessage(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            bool,\n            uint256,\n            bytes memory\n        )\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 8, \"too short\");\n        uint256 size = 0;\n        for (uint256 i = 0; i < 8; i++) {\n            size *= 256;\n            size += uint8(data[startOffset + 7 - i]);\n        }\n        bytes memory res = new bytes(size);\n        for (uint256 i = 0; i < size; i++) {\n            res[i] = data[startOffset + 8 + i];\n        }\n        return (true, startOffset + 8 + size, res);\n    }\n\n    function deserializeHashPreImage(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (uint256 offset, Value.Data memory value)\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 64, \"too short\");\n        bytes32 hashData;\n        uint256 size;\n        (offset, hashData) = extractBytes32(data, startOffset);\n        (offset, size) = deserializeInt(data, offset);\n        return (offset, Value.newTuplePreImage(hashData, size));\n    }\n\n    function deserializeInt(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            uint256 // val\n        )\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 32, \"too short\");\n        return (startOffset + 32, data.toUint(startOffset));\n    }\n\n    function deserializeBytes32(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            bytes32 // val\n        )\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 32, \"too short\");\n        return (startOffset + 32, data.toBytes32(startOffset));\n    }\n\n    function deserializeCodePoint(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            Value.Data memory // val\n        )\n    {\n        uint256 offset = startOffset;\n        uint8 immediateType;\n        uint8 opCode;\n        Value.Data memory immediate;\n        bytes32 nextHash;\n\n        (offset, immediateType) = extractUint8(data, offset);\n        (offset, opCode) = extractUint8(data, offset);\n        if (immediateType == 1) {\n            (offset, immediate) = deserialize(data, offset);\n        }\n        (offset, nextHash) = extractBytes32(data, offset);\n        if (immediateType == 1) {\n            return (offset, Value.newCodePoint(opCode, nextHash, immediate));\n        }\n        return (offset, Value.newCodePoint(opCode, nextHash));\n    }\n\n    function deserializeTuple(\n        uint8 memberCount,\n        bytes memory data,\n        uint256 startOffset\n    )\n        internal\n        pure\n        returns (\n            uint256, // offset\n            Value.Data[] memory // val\n        )\n    {\n        uint256 offset = startOffset;\n        Value.Data[] memory members = new Value.Data[](memberCount);\n        for (uint8 i = 0; i < memberCount; i++) {\n            (offset, members[i]) = deserialize(data, offset);\n        }\n        return (offset, members);\n    }\n\n    function deserialize(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            Value.Data memory // val\n        )\n    {\n        require(startOffset < data.length, \"invalid offset\");\n        (uint256 offset, uint8 valType) = extractUint8(data, startOffset);\n        if (valType == Value.intTypeCode()) {\n            uint256 intVal;\n            (offset, intVal) = deserializeInt(data, offset);\n            return (offset, Value.newInt(intVal));\n        } else if (valType == Value.codePointTypeCode()) {\n            return deserializeCodePoint(data, offset);\n        } else if (valType == Value.bufferTypeCode()) {\n            bytes32 hashVal;\n            (offset, hashVal) = deserializeBytes32(data, offset);\n            return (offset, Value.newBuffer(hashVal));\n        } else if (valType == Value.tuplePreImageTypeCode()) {\n            return deserializeHashPreImage(data, offset);\n        } else if (valType >= Value.tupleTypeCode() && valType < Value.valueTypeCode()) {\n            uint8 tupLength = uint8(valType - Value.tupleTypeCode());\n            Value.Data[] memory tupleVal;\n            (offset, tupleVal) = deserializeTuple(tupLength, data, offset);\n            return (offset, Value.newTuple(tupleVal));\n        }\n        require(false, \"invalid typecode\");\n    }\n\n    function extractUint8(bytes memory data, uint256 startOffset)\n        private\n        pure\n        returns (\n            uint256, // offset\n            uint8 // val\n        )\n    {\n        return (startOffset + 1, uint8(data[startOffset]));\n    }\n\n    function extractBytes32(bytes memory data, uint256 startOffset)\n        private\n        pure\n        returns (\n            uint256, // offset\n            bytes32 // val\n        )\n    {\n        return (startOffset + 32, data.toBytes32(startOffset));\n    }\n}\n"},"contracts/arch/OneStepProof.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./IOneStepProof.sol\";\nimport \"./OneStepProofCommon.sol\";\n\nimport \"../bridge/Messages.sol\";\n\nimport \"../libraries/BytesLib.sol\";\n\n// Originally forked from https://github.com/leapdao/solEVM-enforcer/tree/master\n\ncontract OneStepProof is OneStepProofCommon {\n    using Machine for Machine.Data;\n    using Hashing for Value.Data;\n    using Value for Value.Data;\n    using BytesLib for bytes;\n\n    uint256 private constant MAX_PAIRING_COUNT = 30;\n    uint64 internal constant EC_PAIRING_BASE_GAS_COST = 1000;\n    uint64 internal constant EC_PAIRING_POINT_GAS_COST = 500000;\n\n    /* solhint-disable no-inline-assembly */\n\n    // Arithmetic\n\n    function binaryMathOp(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        if (!val1.isInt() || !val2.isInt()) {\n            handleOpcodeError(context);\n            return;\n        }\n        uint256 a = val1.intVal;\n        uint256 b = val2.intVal;\n\n        uint256 c;\n        if (context.opcode == OP_ADD) {\n            assembly {\n                c := add(a, b)\n            }\n        } else if (context.opcode == OP_MUL) {\n            assembly {\n                c := mul(a, b)\n            }\n        } else if (context.opcode == OP_SUB) {\n            assembly {\n                c := sub(a, b)\n            }\n        } else if (context.opcode == OP_EXP) {\n            assembly {\n                c := exp(a, b)\n            }\n        } else if (context.opcode == OP_SIGNEXTEND) {\n            assembly {\n                c := signextend(a, b)\n            }\n        } else if (context.opcode == OP_LT) {\n            assembly {\n                c := lt(a, b)\n            }\n        } else if (context.opcode == OP_GT) {\n            assembly {\n                c := gt(a, b)\n            }\n        } else if (context.opcode == OP_SLT) {\n            assembly {\n                c := slt(a, b)\n            }\n        } else if (context.opcode == OP_SGT) {\n            assembly {\n                c := sgt(a, b)\n            }\n        } else if (context.opcode == OP_AND) {\n            assembly {\n                c := and(a, b)\n            }\n        } else if (context.opcode == OP_OR) {\n            assembly {\n                c := or(a, b)\n            }\n        } else if (context.opcode == OP_XOR) {\n            assembly {\n                c := xor(a, b)\n            }\n        } else if (context.opcode == OP_BYTE) {\n            assembly {\n                c := byte(a, b)\n            }\n        } else if (context.opcode == OP_SHL) {\n            assembly {\n                c := shl(a, b)\n            }\n        } else if (context.opcode == OP_SHR) {\n            assembly {\n                c := shr(a, b)\n            }\n        } else if (context.opcode == OP_SAR) {\n            assembly {\n                c := sar(a, b)\n            }\n        } else if (context.opcode == OP_ETHHASH2) {\n            c = uint256(keccak256(abi.encodePacked(a, b)));\n        } else {\n            assert(false);\n        }\n\n        pushVal(context.stack, Value.newInt(c));\n    }\n\n    function binaryMathOpZero(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        if (!val1.isInt() || !val2.isInt() || val2.intVal == 0) {\n            handleOpcodeError(context);\n            return;\n        }\n        uint256 a = val1.intVal;\n        uint256 b = val2.intVal;\n\n        uint256 c;\n        if (context.opcode == OP_DIV) {\n            assembly {\n                c := div(a, b)\n            }\n        } else if (context.opcode == OP_SDIV) {\n            assembly {\n                c := sdiv(a, b)\n            }\n        } else if (context.opcode == OP_MOD) {\n            assembly {\n                c := mod(a, b)\n            }\n        } else if (context.opcode == OP_SMOD) {\n            assembly {\n                c := smod(a, b)\n            }\n        } else {\n            assert(false);\n        }\n\n        pushVal(context.stack, Value.newInt(c));\n    }\n\n    function executeMathModInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        Value.Data memory val3 = popVal(context.stack);\n        if (!val1.isInt() || !val2.isInt() || !val3.isInt() || val3.intVal == 0) {\n            handleOpcodeError(context);\n            return;\n        }\n        uint256 a = val1.intVal;\n        uint256 b = val2.intVal;\n        uint256 m = val3.intVal;\n\n        uint256 c;\n\n        if (context.opcode == OP_ADDMOD) {\n            assembly {\n                c := addmod(a, b, m)\n            }\n        } else if (context.opcode == OP_MULMOD) {\n            assembly {\n                c := mulmod(a, b, m)\n            }\n        } else {\n            assert(false);\n        }\n\n        pushVal(context.stack, Value.newInt(c));\n    }\n\n    function executeEqInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        pushVal(context.stack, Value.newBoolean(val1.hash() == val2.hash()));\n    }\n\n    function executeIszeroInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        if (!val1.isInt()) {\n            handleOpcodeError(context);\n            return;\n        }\n        uint256 a = val1.intVal;\n        uint256 c;\n        assembly {\n            c := iszero(a)\n        }\n        pushVal(context.stack, Value.newInt(c));\n    }\n\n    function executeNotInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        if (!val1.isInt()) {\n            handleOpcodeError(context);\n            return;\n        }\n        uint256 a = val1.intVal;\n        uint256 c;\n        assembly {\n            c := not(a)\n        }\n        pushVal(context.stack, Value.newInt(c));\n    }\n\n    /* solhint-enable no-inline-assembly */\n\n    // Stack ops\n\n    function executePopInsn(AssertionContext memory context) internal pure {\n        popVal(context.stack);\n    }\n\n    function executeSpushInsn(AssertionContext memory context) internal pure {\n        pushVal(context.stack, context.afterMachine.staticVal);\n    }\n\n    function executeRpushInsn(AssertionContext memory context) internal pure {\n        pushVal(context.stack, context.afterMachine.registerVal);\n    }\n\n    function executeRsetInsn(AssertionContext memory context) internal pure {\n        context.afterMachine.registerVal = popVal(context.stack);\n    }\n\n    function executeJumpInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val = popVal(context.stack);\n        if (!val.isCodePoint()) {\n            handleOpcodeError(context);\n            return;\n        }\n        context.afterMachine.instructionStackHash = val.hash();\n    }\n\n    function executeCjumpInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        if (!val1.isCodePoint() || !val2.isInt()) {\n            handleOpcodeError(context);\n            return;\n        }\n        if (val2.intVal != 0) {\n            context.afterMachine.instructionStackHash = val1.hash();\n        }\n    }\n\n    function executeStackemptyInsn(AssertionContext memory context) internal pure {\n        bool empty =\n            context.stack.length == 0 &&\n                context.afterMachine.dataStack.hash() == Value.newEmptyTuple().hash();\n        pushVal(context.stack, Value.newBoolean(empty));\n    }\n\n    function executePcpushInsn(AssertionContext memory context) internal pure {\n        pushVal(context.stack, Value.newHashedValue(context.startMachine.instructionStackHash, 1));\n    }\n\n    function executeAuxpushInsn(AssertionContext memory context) internal pure {\n        pushVal(context.auxstack, popVal(context.stack));\n    }\n\n    function executeAuxpopInsn(AssertionContext memory context) internal pure {\n        pushVal(context.stack, popVal(context.auxstack));\n    }\n\n    function executeAuxstackemptyInsn(AssertionContext memory context) internal pure {\n        bool empty =\n            context.auxstack.length == 0 &&\n                context.afterMachine.auxStack.hash() == Value.newEmptyTuple().hash();\n        pushVal(context.stack, Value.newBoolean(empty));\n    }\n\n    /* solhint-disable-next-line no-empty-blocks */\n    function executeNopInsn(AssertionContext memory) internal pure {}\n\n    function executeErrpushInsn(AssertionContext memory context) internal pure {\n        pushVal(context.stack, Value.newHashedValue(context.afterMachine.errHandlerHash, 1));\n    }\n\n    function executeErrsetInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val = popVal(context.stack);\n        if (!val.isCodePoint()) {\n            handleOpcodeError(context);\n            return;\n        }\n        context.afterMachine.errHandlerHash = val.hash();\n    }\n\n    // Dup ops\n\n    function executeDup0Insn(AssertionContext memory context) internal pure {\n        Value.Data memory val = popVal(context.stack);\n        pushVal(context.stack, val);\n        pushVal(context.stack, val);\n    }\n\n    function executeDup1Insn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        pushVal(context.stack, val2);\n        pushVal(context.stack, val1);\n        pushVal(context.stack, val2);\n    }\n\n    function executeDup2Insn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        Value.Data memory val3 = popVal(context.stack);\n        pushVal(context.stack, val3);\n        pushVal(context.stack, val2);\n        pushVal(context.stack, val1);\n        pushVal(context.stack, val3);\n    }\n\n    // Swap ops\n\n    function executeSwap1Insn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        pushVal(context.stack, val1);\n        pushVal(context.stack, val2);\n    }\n\n    function executeSwap2Insn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        Value.Data memory val3 = popVal(context.stack);\n        pushVal(context.stack, val1);\n        pushVal(context.stack, val2);\n        pushVal(context.stack, val3);\n    }\n\n    // Tuple ops\n\n    function executeTgetInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        if (!val1.isInt() || !val2.isTuple() || val1.intVal >= val2.valLength()) {\n            handleOpcodeError(context);\n            return;\n        }\n        pushVal(context.stack, val2.tupleVal[val1.intVal]);\n    }\n\n    function executeTsetInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        Value.Data memory val3 = popVal(context.stack);\n        if (!val1.isInt() || !val2.isTuple() || val1.intVal >= val2.valLength()) {\n            handleOpcodeError(context);\n            return;\n        }\n        Value.Data[] memory tupleVals = val2.tupleVal;\n        tupleVals[val1.intVal] = val3;\n        pushVal(context.stack, Value.newTuple(tupleVals));\n    }\n\n    function executeTlenInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        if (!val1.isTuple()) {\n            handleOpcodeError(context);\n            return;\n        }\n        pushVal(context.stack, Value.newInt(val1.valLength()));\n    }\n\n    function executeXgetInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory auxVal = popVal(context.auxstack);\n        if (!val1.isInt() || !auxVal.isTuple() || val1.intVal >= auxVal.valLength()) {\n            handleOpcodeError(context);\n            return;\n        }\n        pushVal(context.auxstack, auxVal);\n        pushVal(context.stack, auxVal.tupleVal[val1.intVal]);\n    }\n\n    function executeXsetInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        Value.Data memory auxVal = popVal(context.auxstack);\n        if (!auxVal.isTuple() || !val1.isInt() || val1.intVal >= auxVal.valLength()) {\n            handleOpcodeError(context);\n            return;\n        }\n        Value.Data[] memory tupleVals = auxVal.tupleVal;\n        tupleVals[val1.intVal] = val2;\n        pushVal(context.auxstack, Value.newTuple(tupleVals));\n    }\n\n    // Logging\n\n    function executeLogInsn(AssertionContext memory context) internal pure {\n        context.logAcc = keccak256(abi.encodePacked(context.logAcc, popVal(context.stack).hash()));\n    }\n\n    // System operations\n\n    function incrementInbox(AssertionContext memory context)\n        private\n        view\n        returns (Value.Data memory message)\n    {\n        bytes memory proof = context.proof;\n\n        // [messageHash, prefixHash, messageDataHash]\n        bytes32[3] memory messageHashes;\n        uint256 inboxSeqNum;\n        Value.Data[] memory tupData = new Value.Data[](8);\n\n        {\n            // Get message out of proof\n            uint8 kind = uint8(proof[context.offset]);\n            context.offset++;\n            uint256 l1BlockNumber;\n            uint256 l1Timestamp;\n            uint256 gasPriceL1;\n            address sender = proof.toAddress(context.offset);\n            context.offset += 20;\n            (context.offset, l1BlockNumber) = Marshaling.deserializeInt(proof, context.offset);\n            (context.offset, l1Timestamp) = Marshaling.deserializeInt(proof, context.offset);\n            (context.offset, inboxSeqNum) = Marshaling.deserializeInt(proof, context.offset);\n            (context.offset, gasPriceL1) = Marshaling.deserializeInt(proof, context.offset);\n            uint256 messageDataLength;\n            (context.offset, messageDataLength) = Marshaling.deserializeInt(proof, context.offset);\n            bytes32 messageBufHash =\n                Hashing.bytesToBufferHash(proof, context.offset, messageDataLength);\n\n            uint256 offset = context.offset;\n            bytes32 messageDataHash;\n            assembly {\n                messageDataHash := keccak256(add(add(proof, 32), offset), messageDataLength)\n            }\n            context.offset += messageDataLength;\n\n            messageHashes[0] = Messages.messageHash(\n                kind,\n                sender,\n                l1BlockNumber,\n                l1Timestamp,\n                inboxSeqNum,\n                gasPriceL1,\n                messageDataHash\n            );\n\n            uint8 expectedSeqKind;\n            if (messageDataLength > 0) {\n                // L2_MSG\n                expectedSeqKind = 3;\n            } else {\n                // END_OF_BLOCK_MESSAGE\n                expectedSeqKind = 6;\n            }\n            if (kind == expectedSeqKind && gasPriceL1 == 0) {\n                // Between the checks in the if statement, inboxSeqNum, and messageHashes[1:],\n                // this constrains all fields without the full message hash.\n                messageHashes[1] = keccak256(abi.encodePacked(sender, l1BlockNumber, l1Timestamp));\n                messageHashes[2] = messageDataHash;\n            }\n\n            tupData[0] = Value.newInt(uint256(kind));\n            tupData[1] = Value.newInt(l1BlockNumber);\n            tupData[2] = Value.newInt(l1Timestamp);\n            tupData[3] = Value.newInt(uint256(sender));\n            tupData[4] = Value.newInt(inboxSeqNum);\n            tupData[5] = Value.newInt(gasPriceL1);\n            tupData[6] = Value.newInt(messageDataLength);\n            tupData[7] = Value.newHashedValue(messageBufHash, 1);\n        }\n\n        uint256 seqBatchNum;\n        (context.offset, seqBatchNum) = Marshaling.deserializeInt(proof, context.offset);\n        uint8 isDelayed = uint8(proof[context.offset]);\n        context.offset++;\n        require(isDelayed == 0 || isDelayed == 1, \"IS_DELAYED_VAL\");\n\n        bytes32 acc;\n        (context.offset, acc) = Marshaling.deserializeBytes32(proof, context.offset);\n        if (isDelayed == 0) {\n            // Start the proof at an arbitrary previous accumulator, as we validate the end accumulator.\n            acc = keccak256(abi.encodePacked(acc, inboxSeqNum, messageHashes[1], messageHashes[2]));\n\n            require(inboxSeqNum == context.totalMessagesRead, \"WRONG_SEQUENCER_MSG_SEQ_NUM\");\n            inboxSeqNum++;\n        } else {\n            // Read in delayed batch info from the proof. These fields are all part of the accumulator hash.\n            uint256 firstSequencerSeqNum;\n            uint256 delayedStart;\n            uint256 delayedEnd;\n            (context.offset, firstSequencerSeqNum) = Marshaling.deserializeInt(\n                proof,\n                context.offset\n            );\n            (context.offset, delayedStart) = Marshaling.deserializeInt(proof, context.offset);\n            (context.offset, delayedEnd) = Marshaling.deserializeInt(proof, context.offset);\n            bytes32 delayedEndAcc = context.delayedBridge.inboxAccs(delayedEnd - 1);\n\n            // Validate the delayed message is included in this sequencer batch.\n            require(inboxSeqNum >= delayedStart, \"DELAYED_START\");\n            require(inboxSeqNum < delayedEnd, \"DELAYED_END\");\n\n            // Validate the delayed message is in the delayed inbox.\n            bytes32 prevDelayedAcc = 0;\n            if (inboxSeqNum > 0) {\n                prevDelayedAcc = context.delayedBridge.inboxAccs(inboxSeqNum - 1);\n            }\n            require(\n                Messages.addMessageToInbox(prevDelayedAcc, messageHashes[0]) ==\n                    context.delayedBridge.inboxAccs(inboxSeqNum),\n                \"DELAYED_ACC\"\n            );\n\n            // Delayed messages are sequenced into a separate sequence number space with the upper bit set.\n            // Note that messageHash is no longer accurate after this point, as this modifies the message.\n            tupData[4] = Value.newInt(inboxSeqNum | (1 << 255));\n            // Confirm that this fits into the correct position of the sequencer sequence.\n            require(\n                inboxSeqNum - delayedStart + firstSequencerSeqNum == context.totalMessagesRead,\n                \"WRONG_DELAYED_MSG_SEQ_NUM\"\n            );\n\n            acc = keccak256(\n                abi.encodePacked(\n                    \"Delayed messages:\",\n                    acc,\n                    firstSequencerSeqNum,\n                    delayedStart,\n                    delayedEnd,\n                    delayedEndAcc\n                )\n            );\n            inboxSeqNum = firstSequencerSeqNum + (delayedEnd - delayedStart);\n        }\n\n        // Get to the end of the batch by hashing in arbitrary future sequencer messages.\n        while (true) {\n            // 0 = sequencer message\n            // 1 = delayed message batch\n            // 2 = end of batch\n            isDelayed = uint8(proof[context.offset]);\n            if (isDelayed == 2) {\n                break;\n            }\n            require(isDelayed == 0 || isDelayed == 1, \"REM_IS_DELAYED_VAL\");\n            context.offset++;\n            if (isDelayed == 0) {\n                bytes32 newerMessagePrefixHash;\n                bytes32 newerMessageDataHash;\n                (context.offset, newerMessagePrefixHash) = Marshaling.deserializeBytes32(\n                    proof,\n                    context.offset\n                );\n                (context.offset, newerMessageDataHash) = Marshaling.deserializeBytes32(\n                    proof,\n                    context.offset\n                );\n                acc = keccak256(\n                    abi.encodePacked(acc, inboxSeqNum, newerMessagePrefixHash, newerMessageDataHash)\n                );\n                inboxSeqNum++;\n            } else {\n                uint256 delayedStart;\n                uint256 delayedEnd;\n                (context.offset, delayedStart) = Marshaling.deserializeInt(proof, context.offset);\n                (context.offset, delayedEnd) = Marshaling.deserializeInt(proof, context.offset);\n                acc = keccak256(\n                    abi.encodePacked(\n                        \"Delayed messages:\",\n                        acc,\n                        inboxSeqNum,\n                        delayedStart,\n                        delayedEnd,\n                        context.delayedBridge.inboxAccs(delayedEnd - 1)\n                    )\n                );\n                inboxSeqNum += delayedEnd - delayedStart;\n            }\n        }\n\n        require(acc == context.sequencerBridge.inboxAccs(seqBatchNum), \"WRONG_BATCH_ACC\");\n\n        context.totalMessagesRead++;\n\n        return Value.newTuple(tupData);\n    }\n\n    function executeInboxInsn(AssertionContext memory context) internal view {\n        pushVal(context.stack, incrementInbox(context));\n    }\n\n    function executeSetGasInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        if (!val1.isInt()) {\n            handleOpcodeError(context);\n            return;\n        }\n        context.afterMachine.arbGasRemaining = val1.intVal;\n    }\n\n    function executePushGasInsn(AssertionContext memory context) internal pure {\n        pushVal(context.stack, Value.newInt(context.afterMachine.arbGasRemaining));\n    }\n\n    function executeErrCodePointInsn(AssertionContext memory context) internal pure {\n        pushVal(context.stack, Value.newHashedValue(CODE_POINT_ERROR, 1));\n    }\n\n    function executePushInsnInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        if (!val1.isInt() || !val2.isCodePoint()) {\n            handleOpcodeError(context);\n            return;\n        }\n        pushVal(context.stack, Value.newCodePoint(uint8(val1.intVal), val2.hash()));\n    }\n\n    function executePushInsnImmInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        Value.Data memory val3 = popVal(context.stack);\n        if (!val1.isInt() || !val3.isCodePoint()) {\n            handleOpcodeError(context);\n            return;\n        }\n        pushVal(context.stack, Value.newCodePoint(uint8(val1.intVal), val3.hash(), val2));\n    }\n\n    function executeSideloadInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        if (!val1.isInt()) {\n            handleOpcodeError(context);\n            return;\n        }\n        Value.Data[] memory values = new Value.Data[](0);\n        pushVal(context.stack, Value.newTuple(values));\n    }\n\n    function executeECRecoverInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        Value.Data memory val3 = popVal(context.stack);\n        Value.Data memory val4 = popVal(context.stack);\n        if (!val1.isInt() || !val2.isInt() || !val3.isInt() || !val4.isInt()) {\n            handleOpcodeError(context);\n            return;\n        }\n        bytes32 r = bytes32(val1.intVal);\n        bytes32 s = bytes32(val2.intVal);\n        if (val3.intVal != 0 && val3.intVal != 1) {\n            pushVal(context.stack, Value.newInt(0));\n            return;\n        }\n        uint8 v = uint8(val3.intVal) + 27;\n        bytes32 message = bytes32(val4.intVal);\n        address ret = ecrecover(message, v, r, s);\n        pushVal(context.stack, Value.newInt(uint256(ret)));\n    }\n\n    /* solhint-disable no-inline-assembly */\n\n    function executeECAddInsn(AssertionContext memory context) internal view {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        Value.Data memory val3 = popVal(context.stack);\n        Value.Data memory val4 = popVal(context.stack);\n        if (!val1.isInt() || !val2.isInt() || !val3.isInt() || !val4.isInt()) {\n            handleOpcodeError(context);\n            return;\n        }\n        uint256[4] memory bnAddInput = [val1.intVal, val2.intVal, val3.intVal, val4.intVal];\n        uint256[2] memory ret;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, bnAddInput, 0x80, ret, 0x40)\n        }\n        if (!success) {\n            // Must end on empty tuple\n            handleOpcodeError(context);\n            return;\n        }\n        pushVal(context.stack, Value.newInt(uint256(ret[1])));\n        pushVal(context.stack, Value.newInt(uint256(ret[0])));\n    }\n\n    function executeECMulInsn(AssertionContext memory context) internal view {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        Value.Data memory val3 = popVal(context.stack);\n        if (!val1.isInt() || !val2.isInt() || !val3.isInt()) {\n            handleOpcodeError(context);\n            return;\n        }\n        uint256[3] memory bnAddInput = [val1.intVal, val2.intVal, val3.intVal];\n        uint256[2] memory ret;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, bnAddInput, 0x80, ret, 0x40)\n        }\n        if (!success) {\n            // Must end on empty tuple\n            handleOpcodeError(context);\n            return;\n        }\n        pushVal(context.stack, Value.newInt(uint256(ret[1])));\n        pushVal(context.stack, Value.newInt(uint256(ret[0])));\n    }\n\n    function executeECPairingInsn(AssertionContext memory context) internal view {\n        Value.Data memory val = popVal(context.stack);\n\n        Value.Data[MAX_PAIRING_COUNT] memory items;\n        bool postGasError = false;\n        uint256 count;\n        for (count = 0; count < MAX_PAIRING_COUNT; count++) {\n            if (!val.isTuple()) {\n                postGasError = true;\n                break;\n            }\n            Value.Data[] memory stackTupleVals = val.tupleVal;\n            if (stackTupleVals.length == 0) {\n                // We reached the bottom of the stack\n                break;\n            }\n            if (stackTupleVals.length != 2) {\n                postGasError = true;\n                break;\n            }\n            items[count] = stackTupleVals[0];\n            val = stackTupleVals[1];\n        }\n\n        if (deductGas(context, uint64(EC_PAIRING_POINT_GAS_COST * count))) {\n            // When we run out of gas, we only charge for an error + gas_set\n            // That means we need to deduct the previously charged base cost here\n            context.gas -= EC_PAIRING_BASE_GAS_COST;\n            handleError(context);\n            return;\n        }\n\n        if (postGasError || !val.isTuple() || val.tupleVal.length != 0) {\n            // Must end on empty tuple\n            handleOpcodeError(context);\n            return;\n        }\n\n        // Allocate the maximum amount of space we might need\n        uint256[MAX_PAIRING_COUNT * 6] memory input;\n        for (uint256 i = 0; i < count; i++) {\n            Value.Data memory pointVal = items[i];\n            if (!pointVal.isTuple()) {\n                handleOpcodeError(context);\n                return;\n            }\n\n            Value.Data[] memory pointTupleVals = pointVal.tupleVal;\n            if (pointTupleVals.length != 6) {\n                handleOpcodeError(context);\n                return;\n            }\n\n            for (uint256 j = 0; j < 6; j++) {\n                if (!pointTupleVals[j].isInt()) {\n                    handleOpcodeError(context);\n                    return;\n                }\n            }\n            input[i * 6] = pointTupleVals[0].intVal;\n            input[i * 6 + 1] = pointTupleVals[1].intVal;\n            input[i * 6 + 2] = pointTupleVals[3].intVal;\n            input[i * 6 + 3] = pointTupleVals[2].intVal;\n            input[i * 6 + 4] = pointTupleVals[5].intVal;\n            input[i * 6 + 5] = pointTupleVals[4].intVal;\n        }\n\n        uint256 inputSize = count * 6 * 0x20;\n        uint256[1] memory out;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, input, inputSize, out, 0x20)\n        }\n\n        if (!success) {\n            handleOpcodeError(context);\n            return;\n        }\n\n        pushVal(context.stack, Value.newBoolean(out[0] != 0));\n    }\n\n    /* solhint-enable no-inline-assembly */\n\n    function executeErrorInsn(AssertionContext memory context) internal pure {\n        handleOpcodeError(context);\n    }\n\n    function executeStopInsn(AssertionContext memory context) internal pure {\n        context.afterMachine.setHalt();\n    }\n\n    function executeNewBuffer(AssertionContext memory context) internal pure {\n        pushVal(context.stack, Value.newBuffer(keccak256(abi.encodePacked(bytes32(0)))));\n    }\n\n    function opInfo(uint256 opCode)\n        internal\n        pure\n        override\n        returns (\n            uint256, // stack pops\n            uint256, // auxstack pops\n            uint64, // gas used\n            function(AssertionContext memory) internal view // impl\n        )\n    {\n        if (opCode == OP_ADD || opCode == OP_MUL || opCode == OP_SUB) {\n            return (2, 0, 3, binaryMathOp);\n        } else if (opCode == OP_DIV || opCode == OP_MOD) {\n            return (2, 0, 4, binaryMathOpZero);\n        } else if (opCode == OP_SDIV || opCode == OP_SMOD) {\n            return (2, 0, 7, binaryMathOpZero);\n        } else if (opCode == OP_ADDMOD || opCode == OP_MULMOD) {\n            return (3, 0, 4, executeMathModInsn);\n        } else if (opCode == OP_EXP) {\n            return (2, 0, 25, binaryMathOp);\n        } else if (opCode == OP_SIGNEXTEND) {\n            return (2, 0, 7, binaryMathOp);\n        } else if (\n            opCode == OP_LT ||\n            opCode == OP_GT ||\n            opCode == OP_SLT ||\n            opCode == OP_SGT ||\n            opCode == OP_AND ||\n            opCode == OP_OR ||\n            opCode == OP_XOR\n        ) {\n            return (2, 0, 2, binaryMathOp);\n        } else if (opCode == OP_EQ) {\n            return (2, 0, 2, executeEqInsn);\n        } else if (opCode == OP_ISZERO) {\n            return (1, 0, 1, executeIszeroInsn);\n        } else if (opCode == OP_NOT) {\n            return (1, 0, 1, executeNotInsn);\n        } else if (opCode == OP_BYTE || opCode == OP_SHL || opCode == OP_SHR || opCode == OP_SAR) {\n            return (2, 0, 4, binaryMathOp);\n        } else if (opCode == OP_POP) {\n            return (1, 0, 1, executePopInsn);\n        } else if (opCode == OP_SPUSH) {\n            return (0, 0, 1, executeSpushInsn);\n        } else if (opCode == OP_RPUSH) {\n            return (0, 0, 1, executeRpushInsn);\n        } else if (opCode == OP_RSET) {\n            return (1, 0, 2, executeRsetInsn);\n        } else if (opCode == OP_JUMP) {\n            return (1, 0, 4, executeJumpInsn);\n        } else if (opCode == OP_CJUMP) {\n            return (2, 0, 4, executeCjumpInsn);\n        } else if (opCode == OP_STACKEMPTY) {\n            return (0, 0, 2, executeStackemptyInsn);\n        } else if (opCode == OP_PCPUSH) {\n            return (0, 0, 1, executePcpushInsn);\n        } else if (opCode == OP_AUXPUSH) {\n            return (1, 0, 1, executeAuxpushInsn);\n        } else if (opCode == OP_AUXPOP) {\n            return (0, 1, 1, executeAuxpopInsn);\n        } else if (opCode == OP_AUXSTACKEMPTY) {\n            return (0, 0, 2, executeAuxstackemptyInsn);\n        } else if (opCode == OP_NOP) {\n            return (0, 0, 1, executeNopInsn);\n        } else if (opCode == OP_ERRPUSH) {\n            return (0, 0, 1, executeErrpushInsn);\n        } else if (opCode == OP_ERRSET) {\n            return (1, 0, 1, executeErrsetInsn);\n        } else if (opCode == OP_DUP0) {\n            return (1, 0, 1, executeDup0Insn);\n        } else if (opCode == OP_DUP1) {\n            return (2, 0, 1, executeDup1Insn);\n        } else if (opCode == OP_DUP2) {\n            return (3, 0, 1, executeDup2Insn);\n        } else if (opCode == OP_SWAP1) {\n            return (2, 0, 1, executeSwap1Insn);\n        } else if (opCode == OP_SWAP2) {\n            return (3, 0, 1, executeSwap2Insn);\n        } else if (opCode == OP_TGET) {\n            return (2, 0, 2, executeTgetInsn);\n        } else if (opCode == OP_TSET) {\n            return (3, 0, 40, executeTsetInsn);\n        } else if (opCode == OP_TLEN) {\n            return (1, 0, 2, executeTlenInsn);\n        } else if (opCode == OP_XGET) {\n            return (1, 1, 3, executeXgetInsn);\n        } else if (opCode == OP_XSET) {\n            return (2, 1, 41, executeXsetInsn);\n        } else if (opCode == OP_BREAKPOINT) {\n            return (0, 0, 100, executeNopInsn);\n        } else if (opCode == OP_LOG) {\n            return (1, 0, 100, executeLogInsn);\n        } else if (opCode == OP_INBOX) {\n            return (0, 0, 40, executeInboxInsn);\n        } else if (opCode == OP_ERROR) {\n            return (0, 0, ERROR_GAS_COST, executeErrorInsn);\n        } else if (opCode == OP_STOP) {\n            return (0, 0, 10, executeStopInsn);\n        } else if (opCode == OP_SETGAS) {\n            return (1, 0, 1, executeSetGasInsn);\n        } else if (opCode == OP_PUSHGAS) {\n            return (0, 0, 1, executePushGasInsn);\n        } else if (opCode == OP_ERR_CODE_POINT) {\n            return (0, 0, 25, executeErrCodePointInsn);\n        } else if (opCode == OP_PUSH_INSN) {\n            return (2, 0, 25, executePushInsnInsn);\n        } else if (opCode == OP_PUSH_INSN_IMM) {\n            return (3, 0, 25, executePushInsnImmInsn);\n        } else if (opCode == OP_SIDELOAD) {\n            return (1, 0, 10, executeSideloadInsn);\n        } else if (opCode == OP_ECRECOVER) {\n            return (4, 0, 20000, executeECRecoverInsn);\n        } else if (opCode == OP_ECADD) {\n            return (4, 0, 3500, executeECAddInsn);\n        } else if (opCode == OP_ECMUL) {\n            return (3, 0, 82000, executeECMulInsn);\n        } else if (opCode == OP_ECPAIRING) {\n            return (1, 0, EC_PAIRING_BASE_GAS_COST, executeECPairingInsn);\n        } else if (opCode == OP_DEBUGPRINT) {\n            return (1, 0, 1, executePopInsn);\n        } else if (opCode == OP_NEWBUFFER) {\n            return (0, 0, 1, executeNewBuffer);\n        } else if (opCode >= OP_HASH && opCode <= OP_SHA256_F) {\n            revert(\"use another contract to handle hashing opcodes\");\n        } else if ((opCode >= OP_GETBUFFER8 && opCode <= OP_SETBUFFER256) || opCode == OP_SEND) {\n            revert(\"use another contract to handle buffer opcodes\");\n        } else {\n            return (0, 0, ERROR_GAS_COST, executeErrorInsn);\n        }\n    }\n}\n"},"contracts/arch/OneStepProofCommon.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./IOneStepProof.sol\";\nimport \"./Value.sol\";\nimport \"./Machine.sol\";\nimport \"../bridge/interfaces/IBridge.sol\";\nimport \"../bridge/interfaces/ISequencerInbox.sol\";\n\nabstract contract OneStepProofCommon is IOneStepProof {\n    using Machine for Machine.Data;\n    using Hashing for Value.Data;\n    using Value for Value.Data;\n\n    uint256 internal constant MAX_UINT256 = ((1 << 128) + 1) * ((1 << 128) - 1);\n\n    uint64 internal constant ERROR_GAS_COST = 5;\n\n    string internal constant BAD_IMM_TYP = \"BAD_IMM_TYP\";\n    string internal constant NO_IMM = \"NO_IMM\";\n    string internal constant STACK_MISSING = \"STACK_MISSING\";\n    string internal constant AUX_MISSING = \"AUX_MISSING\";\n    string internal constant STACK_MANY = \"STACK_MANY\";\n    string internal constant AUX_MANY = \"AUX_MANY\";\n    string internal constant INBOX_VAL = \"INBOX_VAL\";\n\n    // Stop and arithmetic ops\n    uint8 internal constant OP_ADD = 0x01;\n    uint8 internal constant OP_MUL = 0x02;\n    uint8 internal constant OP_SUB = 0x03;\n    uint8 internal constant OP_DIV = 0x04;\n    uint8 internal constant OP_SDIV = 0x05;\n    uint8 internal constant OP_MOD = 0x06;\n    uint8 internal constant OP_SMOD = 0x07;\n    uint8 internal constant OP_ADDMOD = 0x08;\n    uint8 internal constant OP_MULMOD = 0x09;\n    uint8 internal constant OP_EXP = 0x0a;\n    uint8 internal constant OP_SIGNEXTEND = 0x0b;\n\n    // Comparison & bitwise logic\n    uint8 internal constant OP_LT = 0x10;\n    uint8 internal constant OP_GT = 0x11;\n    uint8 internal constant OP_SLT = 0x12;\n    uint8 internal constant OP_SGT = 0x13;\n    uint8 internal constant OP_EQ = 0x14;\n    uint8 internal constant OP_ISZERO = 0x15;\n    uint8 internal constant OP_AND = 0x16;\n    uint8 internal constant OP_OR = 0x17;\n    uint8 internal constant OP_XOR = 0x18;\n    uint8 internal constant OP_NOT = 0x19;\n    uint8 internal constant OP_BYTE = 0x1a;\n    uint8 internal constant OP_SHL = 0x1b;\n    uint8 internal constant OP_SHR = 0x1c;\n    uint8 internal constant OP_SAR = 0x1d;\n\n    // SHA3\n    uint8 internal constant OP_HASH = 0x20;\n    uint8 internal constant OP_TYPE = 0x21;\n    uint8 internal constant OP_ETHHASH2 = 0x22;\n    uint8 internal constant OP_KECCAK_F = 0x23;\n    uint8 internal constant OP_SHA256_F = 0x24;\n\n    // Stack, Memory, Storage and Flow Operations\n    uint8 internal constant OP_POP = 0x30;\n    uint8 internal constant OP_SPUSH = 0x31;\n    uint8 internal constant OP_RPUSH = 0x32;\n    uint8 internal constant OP_RSET = 0x33;\n    uint8 internal constant OP_JUMP = 0x34;\n    uint8 internal constant OP_CJUMP = 0x35;\n    uint8 internal constant OP_STACKEMPTY = 0x36;\n    uint8 internal constant OP_PCPUSH = 0x37;\n    uint8 internal constant OP_AUXPUSH = 0x38;\n    uint8 internal constant OP_AUXPOP = 0x39;\n    uint8 internal constant OP_AUXSTACKEMPTY = 0x3a;\n    uint8 internal constant OP_NOP = 0x3b;\n    uint8 internal constant OP_ERRPUSH = 0x3c;\n    uint8 internal constant OP_ERRSET = 0x3d;\n\n    // Duplication and Exchange operations\n    uint8 internal constant OP_DUP0 = 0x40;\n    uint8 internal constant OP_DUP1 = 0x41;\n    uint8 internal constant OP_DUP2 = 0x42;\n    uint8 internal constant OP_SWAP1 = 0x43;\n    uint8 internal constant OP_SWAP2 = 0x44;\n\n    // Tuple operations\n    uint8 internal constant OP_TGET = 0x50;\n    uint8 internal constant OP_TSET = 0x51;\n    uint8 internal constant OP_TLEN = 0x52;\n    uint8 internal constant OP_XGET = 0x53;\n    uint8 internal constant OP_XSET = 0x54;\n\n    // Logging operations\n    uint8 internal constant OP_BREAKPOINT = 0x60;\n    uint8 internal constant OP_LOG = 0x61;\n\n    // System operations\n    uint8 internal constant OP_SEND = 0x70;\n    // OP_INBOX_PEEK has been removed\n    uint8 internal constant OP_INBOX = 0x72;\n    uint8 internal constant OP_ERROR = 0x73;\n    uint8 internal constant OP_STOP = 0x74;\n    uint8 internal constant OP_SETGAS = 0x75;\n    uint8 internal constant OP_PUSHGAS = 0x76;\n    uint8 internal constant OP_ERR_CODE_POINT = 0x77;\n    uint8 internal constant OP_PUSH_INSN = 0x78;\n    uint8 internal constant OP_PUSH_INSN_IMM = 0x79;\n    // uint8 private constant OP_OPEN_INSN = 0x7a;\n    uint8 internal constant OP_SIDELOAD = 0x7b;\n\n    uint8 internal constant OP_ECRECOVER = 0x80;\n    uint8 internal constant OP_ECADD = 0x81;\n    uint8 internal constant OP_ECMUL = 0x82;\n    uint8 internal constant OP_ECPAIRING = 0x83;\n\n    uint8 internal constant OP_DEBUGPRINT = 0x90;\n\n    // Buffer operations\n    uint8 internal constant OP_NEWBUFFER = 0xa0;\n    uint8 internal constant OP_GETBUFFER8 = 0xa1;\n    uint8 internal constant OP_GETBUFFER64 = 0xa2;\n    uint8 internal constant OP_GETBUFFER256 = 0xa3;\n    uint8 internal constant OP_SETBUFFER8 = 0xa4;\n    uint8 internal constant OP_SETBUFFER64 = 0xa5;\n    uint8 internal constant OP_SETBUFFER256 = 0xa6;\n\n    uint8 internal constant CODE_POINT_TYPECODE = 1;\n    bytes32 internal constant CODE_POINT_ERROR =\n        keccak256(abi.encodePacked(CODE_POINT_TYPECODE, uint8(0), bytes32(0)));\n\n    uint256 internal constant SEND_SIZE_LIMIT = 10000;\n\n    // accs is [sendAcc, logAcc]\n    function executeStep(\n        address[2] calldata bridges,\n        uint256 initialMessagesRead,\n        bytes32[2] calldata accs,\n        bytes calldata proof,\n        bytes calldata bproof\n    )\n        external\n        view\n        override\n        returns (\n            uint64 gas,\n            uint256 afterMessagesRead,\n            bytes32[4] memory fields\n        )\n    {\n        AssertionContext memory context =\n            initializeExecutionContext(initialMessagesRead, accs, proof, bproof, bridges);\n\n        executeOp(context);\n\n        return returnContext(context);\n    }\n\n    function executeStepDebug(\n        address[2] calldata bridges,\n        uint256 initialMessagesRead,\n        bytes32[2] calldata accs,\n        bytes calldata proof,\n        bytes calldata bproof\n    ) external view override returns (string memory startMachine, string memory afterMachine) {\n        AssertionContext memory context =\n            initializeExecutionContext(initialMessagesRead, accs, proof, bproof, bridges);\n\n        executeOp(context);\n        startMachine = Machine.toString(context.startMachine);\n        afterMachine = Machine.toString(context.afterMachine);\n    }\n\n    // fields\n    // startMachineHash,\n    // endMachineHash,\n    // afterInboxAcc,\n    // afterMessagesHash,\n    // afterLogsHash\n\n    function returnContext(AssertionContext memory context)\n        internal\n        pure\n        returns (\n            uint64 gas,\n            uint256 afterMessagesRead,\n            bytes32[4] memory fields\n        )\n    {\n        return (\n            context.gas,\n            context.totalMessagesRead,\n            [\n                Machine.hash(context.startMachine),\n                Machine.hash(context.afterMachine),\n                context.sendAcc,\n                context.logAcc\n            ]\n        );\n    }\n\n    struct ValueStack {\n        uint256 length;\n        Value.Data[] values;\n    }\n\n    function popVal(ValueStack memory stack) internal pure returns (Value.Data memory) {\n        Value.Data memory val = stack.values[stack.length - 1];\n        stack.length--;\n        return val;\n    }\n\n    function pushVal(ValueStack memory stack, Value.Data memory val) internal pure {\n        stack.values[stack.length] = val;\n        stack.length++;\n    }\n\n    struct AssertionContext {\n        ISequencerInbox sequencerBridge;\n        IBridge delayedBridge;\n        Machine.Data startMachine;\n        Machine.Data afterMachine;\n        uint256 totalMessagesRead;\n        bytes32 sendAcc;\n        bytes32 logAcc;\n        uint64 gas;\n        ValueStack stack;\n        ValueStack auxstack;\n        bool hadImmediate;\n        uint8 opcode;\n        bytes proof;\n        uint256 offset;\n        // merkle proofs for buffer\n        bytes bufProof;\n        bool errorOccurred;\n    }\n\n    function handleError(AssertionContext memory context) internal pure {\n        context.errorOccurred = true;\n    }\n\n    function deductGas(AssertionContext memory context, uint64 amount)\n        internal\n        pure\n        returns (bool)\n    {\n        if (context.afterMachine.arbGasRemaining < amount) {\n            // ERROR + GAS_SET\n            context.gas += ERROR_GAS_COST;\n            context.afterMachine.arbGasRemaining = MAX_UINT256;\n            return true;\n        } else {\n            context.gas += amount;\n            context.afterMachine.arbGasRemaining -= amount;\n            return false;\n        }\n    }\n\n    function handleOpcodeError(AssertionContext memory context) internal pure {\n        handleError(context);\n    }\n\n    function initializeExecutionContext(\n        uint256 initialMessagesRead,\n        bytes32[2] calldata accs,\n        bytes memory proof,\n        bytes memory bproof,\n        address[2] calldata bridges\n    ) internal pure returns (AssertionContext memory) {\n        uint8 opCode = uint8(proof[0]);\n        uint8 stackCount = uint8(proof[1]);\n        uint8 auxstackCount = uint8(proof[2]);\n        uint256 offset = 3;\n\n        // Leave some extra space for values pushed on the stack in the proofs\n        Value.Data[] memory stackVals = new Value.Data[](stackCount + 4);\n        Value.Data[] memory auxstackVals = new Value.Data[](auxstackCount + 4);\n        for (uint256 i = 0; i < stackCount; i++) {\n            (offset, stackVals[i]) = Marshaling.deserialize(proof, offset);\n        }\n        for (uint256 i = 0; i < auxstackCount; i++) {\n            (offset, auxstackVals[i]) = Marshaling.deserialize(proof, offset);\n        }\n        Machine.Data memory mach;\n        (offset, mach) = Machine.deserializeMachine(proof, offset);\n\n        uint8 immediate = uint8(proof[offset]);\n        offset += 1;\n\n        AssertionContext memory context;\n        context.sequencerBridge = ISequencerInbox(bridges[0]);\n        context.delayedBridge = IBridge(bridges[1]);\n        context.startMachine = mach;\n        context.afterMachine = mach.clone();\n        context.totalMessagesRead = initialMessagesRead;\n        context.sendAcc = accs[0];\n        context.logAcc = accs[1];\n        context.gas = 0;\n        context.stack = ValueStack(stackCount, stackVals);\n        context.auxstack = ValueStack(auxstackCount, auxstackVals);\n        context.hadImmediate = immediate == 1;\n        context.opcode = opCode;\n        context.proof = proof;\n        context.bufProof = bproof;\n        context.errorOccurred = false;\n        context.offset = offset;\n\n        require(immediate == 0 || immediate == 1, BAD_IMM_TYP);\n        Value.Data memory cp;\n        if (immediate == 0) {\n            cp = Value.newCodePoint(uint8(opCode), context.startMachine.instructionStackHash);\n        } else {\n            // If we have an immediate, there must be at least one stack value\n            require(stackVals.length > 0, NO_IMM);\n            cp = Value.newCodePoint(\n                uint8(opCode),\n                context.startMachine.instructionStackHash,\n                stackVals[stackCount - 1]\n            );\n        }\n        context.startMachine.instructionStackHash = cp.hash();\n\n        // Add the stack and auxstack values to the start machine\n        uint256 i = 0;\n        for (i = 0; i < stackCount - immediate; i++) {\n            context.startMachine.addDataStackValue(stackVals[i]);\n        }\n        for (i = 0; i < auxstackCount; i++) {\n            context.startMachine.addAuxStackValue(auxstackVals[i]);\n        }\n\n        return context;\n    }\n\n    function executeOp(AssertionContext memory context) internal view {\n        (\n            uint256 dataPopCount,\n            uint256 auxPopCount,\n            uint64 gasCost,\n            function(AssertionContext memory) internal view impl\n        ) = opInfo(context.opcode);\n\n        // Require the prover to submit the minimal number of stack items\n        require(\n            ((dataPopCount > 0 || !context.hadImmediate) && context.stack.length <= dataPopCount) ||\n                (context.hadImmediate && dataPopCount == 0 && context.stack.length == 1),\n            STACK_MANY\n        );\n        require(context.auxstack.length <= auxPopCount, AUX_MANY);\n\n        // Update end machine gas remaining before running opcode\n        if (context.stack.length < dataPopCount) {\n            // If we have insufficient values, reject the proof unless the stack has been fully exhausted\n            require(\n                context.afterMachine.dataStack.hash() == Value.newEmptyTuple().hash(),\n                STACK_MISSING\n            );\n            deductGas(context, ERROR_GAS_COST);\n            // If the stack is empty, the instruction underflowed so we have hit an error\n            handleError(context);\n        } else if (context.auxstack.length < auxPopCount) {\n            // If we have insufficient values, reject the proof unless the auxstack has been fully exhausted\n            require(\n                context.afterMachine.auxStack.hash() == Value.newEmptyTuple().hash(),\n                AUX_MISSING\n            );\n            deductGas(context, ERROR_GAS_COST);\n            // If the auxstack is empty, the instruction underflowed so we have hit an error\n            handleError(context);\n        } else if (deductGas(context, gasCost)) {\n            handleError(context);\n        } else {\n            impl(context);\n        }\n\n        if (context.errorOccurred) {\n            if (context.afterMachine.errHandlerHash == CODE_POINT_ERROR) {\n                context.afterMachine.setErrorStop();\n            } else {\n                // Clear error\n                context.errorOccurred = false;\n                context.afterMachine.instructionStackHash = context.afterMachine.errHandlerHash;\n\n                if (!(context.hadImmediate && dataPopCount == 0)) {\n                    context.stack.length = 0;\n                }\n                context.auxstack.length = 0;\n            }\n        }\n\n        // Add the stack and auxstack values to the start machine\n        uint256 i = 0;\n\n        for (i = 0; i < context.stack.length; i++) {\n            context.afterMachine.addDataStackValue(context.stack.values[i]);\n        }\n\n        for (i = 0; i < context.auxstack.length; i++) {\n            context.afterMachine.addAuxStackValue(context.auxstack.values[i]);\n        }\n    }\n\n    function opInfo(uint256 opCode)\n        internal\n        pure\n        virtual\n        returns (\n            uint256, // stack pops\n            uint256, // auxstack pops\n            uint64, // gas used\n            function(AssertionContext memory) internal view // impl\n        );\n}\n"},"contracts/arch/Value.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nlibrary Value {\n    uint8 internal constant INT_TYPECODE = 0;\n    uint8 internal constant CODE_POINT_TYPECODE = 1;\n    uint8 internal constant HASH_PRE_IMAGE_TYPECODE = 2;\n    uint8 internal constant TUPLE_TYPECODE = 3;\n    uint8 internal constant BUFFER_TYPECODE = TUPLE_TYPECODE + 9;\n    // All values received from clients will have type codes less than the VALUE_TYPE_COUNT\n    uint8 internal constant VALUE_TYPE_COUNT = TUPLE_TYPECODE + 10;\n\n    // The following types do not show up in the marshalled format and is\n    // only used for internal tracking purposes\n    uint8 internal constant HASH_ONLY = 100;\n\n    struct CodePoint {\n        uint8 opcode;\n        bytes32 nextCodePoint;\n        Data[] immediate;\n    }\n\n    struct Data {\n        uint256 intVal;\n        CodePoint cpVal;\n        Data[] tupleVal;\n        bytes32 bufferHash;\n        uint8 typeCode;\n        uint256 size;\n    }\n\n    function tupleTypeCode() internal pure returns (uint8) {\n        return TUPLE_TYPECODE;\n    }\n\n    function tuplePreImageTypeCode() internal pure returns (uint8) {\n        return HASH_PRE_IMAGE_TYPECODE;\n    }\n\n    function intTypeCode() internal pure returns (uint8) {\n        return INT_TYPECODE;\n    }\n\n    function bufferTypeCode() internal pure returns (uint8) {\n        return BUFFER_TYPECODE;\n    }\n\n    function codePointTypeCode() internal pure returns (uint8) {\n        return CODE_POINT_TYPECODE;\n    }\n\n    function valueTypeCode() internal pure returns (uint8) {\n        return VALUE_TYPE_COUNT;\n    }\n\n    function hashOnlyTypeCode() internal pure returns (uint8) {\n        return HASH_ONLY;\n    }\n\n    function isValidTupleSize(uint256 size) internal pure returns (bool) {\n        return size <= 8;\n    }\n\n    function typeCodeVal(Data memory val) internal pure returns (Data memory) {\n        if (val.typeCode == 2) {\n            // Map HashPreImage to Tuple\n            return newInt(TUPLE_TYPECODE);\n        }\n        return newInt(val.typeCode);\n    }\n\n    function valLength(Data memory val) internal pure returns (uint8) {\n        if (val.typeCode == TUPLE_TYPECODE) {\n            return uint8(val.tupleVal.length);\n        } else {\n            return 1;\n        }\n    }\n\n    function isInt(Data memory val) internal pure returns (bool) {\n        return val.typeCode == INT_TYPECODE;\n    }\n\n    function isInt64(Data memory val) internal pure returns (bool) {\n        return val.typeCode == INT_TYPECODE && val.intVal < (1 << 64);\n    }\n\n    function isCodePoint(Data memory val) internal pure returns (bool) {\n        return val.typeCode == CODE_POINT_TYPECODE;\n    }\n\n    function isTuple(Data memory val) internal pure returns (bool) {\n        return val.typeCode == TUPLE_TYPECODE;\n    }\n\n    function isBuffer(Data memory val) internal pure returns (bool) {\n        return val.typeCode == BUFFER_TYPECODE;\n    }\n\n    function newEmptyTuple() internal pure returns (Data memory) {\n        return newTuple(new Data[](0));\n    }\n\n    function newBoolean(bool val) internal pure returns (Data memory) {\n        if (val) {\n            return newInt(1);\n        } else {\n            return newInt(0);\n        }\n    }\n\n    function newInt(uint256 _val) internal pure returns (Data memory) {\n        return\n            Data(_val, CodePoint(0, 0, new Data[](0)), new Data[](0), 0, INT_TYPECODE, uint256(1));\n    }\n\n    function newHashedValue(bytes32 valueHash, uint256 valueSize)\n        internal\n        pure\n        returns (Data memory)\n    {\n        return\n            Data(\n                uint256(valueHash),\n                CodePoint(0, 0, new Data[](0)),\n                new Data[](0),\n                0,\n                HASH_ONLY,\n                valueSize\n            );\n    }\n\n    function newTuple(Data[] memory _val) internal pure returns (Data memory) {\n        require(isValidTupleSize(_val.length), \"Tuple must have valid size\");\n        uint256 size = 1;\n\n        for (uint256 i = 0; i < _val.length; i++) {\n            size += _val[i].size;\n        }\n\n        return Data(0, CodePoint(0, 0, new Data[](0)), _val, 0, TUPLE_TYPECODE, size);\n    }\n\n    function newTuplePreImage(bytes32 preImageHash, uint256 size)\n        internal\n        pure\n        returns (Data memory)\n    {\n        return\n            Data(\n                uint256(preImageHash),\n                CodePoint(0, 0, new Data[](0)),\n                new Data[](0),\n                0,\n                HASH_PRE_IMAGE_TYPECODE,\n                size\n            );\n    }\n\n    function newCodePoint(uint8 opCode, bytes32 nextHash) internal pure returns (Data memory) {\n        return newCodePoint(CodePoint(opCode, nextHash, new Data[](0)));\n    }\n\n    function newCodePoint(\n        uint8 opCode,\n        bytes32 nextHash,\n        Data memory immediate\n    ) internal pure returns (Data memory) {\n        Data[] memory imm = new Data[](1);\n        imm[0] = immediate;\n        return newCodePoint(CodePoint(opCode, nextHash, imm));\n    }\n\n    function newCodePoint(CodePoint memory _val) private pure returns (Data memory) {\n        return Data(0, _val, new Data[](0), 0, CODE_POINT_TYPECODE, uint256(1));\n    }\n\n    function newBuffer(bytes32 bufHash) internal pure returns (Data memory) {\n        return\n            Data(\n                uint256(0),\n                CodePoint(0, 0, new Data[](0)),\n                new Data[](0),\n                bufHash,\n                BUFFER_TYPECODE,\n                uint256(1)\n            );\n    }\n}\n"},"contracts/bridge/Messages.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nlibrary Messages {\n    function messageHash(\n        uint8 kind,\n        address sender,\n        uint256 blockNumber,\n        uint256 timestamp,\n        uint256 inboxSeqNum,\n        uint256 gasPriceL1,\n        bytes32 messageDataHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    kind,\n                    sender,\n                    blockNumber,\n                    timestamp,\n                    inboxSeqNum,\n                    gasPriceL1,\n                    messageDataHash\n                )\n            );\n    }\n\n    function addMessageToInbox(bytes32 inbox, bytes32 message) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(inbox, message));\n    }\n}\n"},"contracts/bridge/interfaces/IBridge.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    );\n\n    function deliverMessageToInbox(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    // These are only callable by the admin\n    function setInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // View functions\n\n    function activeOutbox() external view returns (address);\n\n    function allowedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function messageCount() external view returns (uint256);\n}\n"},"contracts/bridge/interfaces/ISequencerInbox.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface ISequencerInbox {\n    event SequencerBatchDelivered(\n        uint256 indexed firstMessageNum,\n        bytes32 indexed beforeAcc,\n        uint256 newMessageCount,\n        bytes32 afterAcc,\n        bytes transactions,\n        uint256[] lengths,\n        uint256[] sectionsMetadata,\n        uint256 seqBatchIndex,\n        address sequencer\n    );\n\n    event SequencerBatchDeliveredFromOrigin(\n        uint256 indexed firstMessageNum,\n        bytes32 indexed beforeAcc,\n        uint256 newMessageCount,\n        bytes32 afterAcc,\n        uint256 seqBatchIndex\n    );\n\n    event DelayedInboxForced(\n        uint256 indexed firstMessageNum,\n        bytes32 indexed beforeAcc,\n        uint256 newMessageCount,\n        uint256 totalDelayedMessagesRead,\n        bytes32[2] afterAccAndDelayed,\n        uint256 seqBatchIndex\n    );\n\n    event SequencerAddressUpdated(address newAddress);\n\n    function setSequencer(address newSequencer) external;\n\n    function messageCount() external view returns (uint256);\n\n    function maxDelayBlocks() external view returns (uint256);\n\n    function maxDelaySeconds() external view returns (uint256);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function proveBatchContainsSequenceNumber(bytes calldata proof, uint256 inboxCount)\n        external\n        view\n        returns (uint256, bytes32);\n}\n"},"contracts/libraries/BytesLib.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\n\npragma solidity ^0.6.11;\n\n/* solhint-disable no-inline-assembly */\nlibrary BytesLib {\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= (_start + 20), \"Read out of bounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= (_start + 1), \"Read out of bounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n}\n/* solhint-enable no-inline-assembly */\n"},"contracts/libraries/DebugPrint.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nlibrary DebugPrint {\n    function char(bytes1 b) private pure returns (bytes1 c) {\n        if (uint8(b) < 10) {\n            return bytes1(uint8(b) + 0x30);\n        } else {\n            return bytes1(uint8(b) + 0x57);\n        }\n    }\n\n    function bytes32string(bytes32 b32) internal pure returns (string memory out) {\n        bytes memory s = new bytes(64);\n\n        for (uint256 i = 0; i < 32; i++) {\n            bytes1 b = bytes1(b32[i]);\n            bytes1 hi = bytes1(uint8(b) / 16);\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n            s[i * 2] = char(hi);\n            s[i * 2 + 1] = char(lo);\n        }\n\n        out = string(s);\n    }\n\n    // Taken from https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n    function uint2str(uint256 _iParam) internal pure returns (string memory _uintAsString) {\n        uint256 _i = _iParam;\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n"}}}