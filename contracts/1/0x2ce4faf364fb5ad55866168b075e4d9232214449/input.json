{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "momentumSale.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity <=0.7.4;\n\nabstract contract ReentrancyGuard {\n\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\nlibrary Math {\n    \n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b > 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n}\n\ninterface IERC20{\n\t\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n}\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\ninterface IMomentumSaleV1{\n\n    function createSaleContract(uint256 _allocated, uint8 _source) external returns(bool);\n\n    function increaseAllocation(uint256 _amount, uint256 _saleId) external returns(bool);\n\n    function purchaseWithEth() external payable returns(bool);\n\n    function adminPurchase(uint256 _amountToken, uint256 _usdPurchase, uint256 _pricePurchase) external returns(bool);\n\n    function fetchTokenPrice() external returns(uint256);\n\n    function claim(uint256 _saleId) external returns(bool);\n\n    function resolveBonus(uint256 _saleId, address _user) external returns(uint256);\n\n    function resolveBonusPercent(uint256 _saleId) external returns(bool);\n\n    function updateNewEdgexSource(address _newSource, uint8 _index) external returns(bool);\n\n    function revokeOwnership(address _newOwner) external returns(bool);\n\n    function updateEthSource(address _newSource) external returns(bool);\n\n    function updateEdgexTokenContract(address _newSource) external returns(bool);\n\n    function updatePricePerToken(uint256 _price) external returns(bool);\n\n}\n\ninterface IWhiteListOracle {\n\n    function whitelist(address _user) external returns(bool);\n\n    function blacklist(address _user) external returns(bool);\n\n    function transferGovernor(address _newGovernor) external returns(bool);\n\n    function whitelisted(address _user) external view returns(bool);\n\n}\n\ncontract MomentumSaleV1 is ReentrancyGuard {\n    \n   address public admin;\n   address public ethWallet;\n   address public organisation;\n   address public governor;\n   address public whitelistOracle;\n    \n   uint256 public totalSaleContracts;\n   uint256 public pricePerToken;\n   address public ethPriceSource;\n   address public edgexTokenContract;\n   uint256 public lastCreated;\n   uint256 public totalOracles = 15;\n\n   struct Sale{\n       uint256 usdPurchase;\n       uint256 pricePurchase; // 8 decimal\n       uint256 amountPurchased;\n       uint256 timestamp;\n       bool isAllocated;\n       uint256 bonus;\n       uint256 saleId;\n   } \n   \n   struct SaleInfo{\n       uint256 start;\n       uint256 end;\n       uint256 allocated;\n       uint256 totalPurchased;\n       uint8 priceSource;\n   }\n   \n   mapping(address => uint256) public totalPurchases;\n   mapping(address => mapping(uint256 => Sale)) public sale;\n   mapping(uint256 => SaleInfo) public info;\n   mapping(uint256 => address) public oracle;\n\n   event RevokeOwnership(address indexed _owner);\n   event UpdatePrice(uint256 _newPrice);\n   event UpdateGovernor(address indexed _governor);\n\n   constructor(\n       address _admin,\n       address _organisation,\n       address _ethWallet,\n       address _governor,\n       uint256 _pricePerToken,\n       address _ethPriceSource,\n       address _whitelistOracle,\n       address _edgexTokenContract\n    ) \n    {\n       admin = _admin;\n       organisation = _organisation;\n       ethWallet = _ethWallet;\n       governor = _governor;\n       pricePerToken = _pricePerToken;\n       whitelistOracle = _whitelistOracle;\n       ethPriceSource = _ethPriceSource;\n       edgexTokenContract = _edgexTokenContract;\n   }\n   \n   modifier onlyAdmin(){\n       require(msg.sender == admin, \"Caller not admin\");\n       _;\n   }\n   \n   modifier onlyGovernor(){\n       require(msg.sender == governor, \"Caller not governor\");\n       _;\n   }\n\n   modifier isZero(address _address){\n       require(_address != address(0),\"Invalid Address\");\n       _;\n   }\n\n   function isWhitelisted(address _user) public virtual view returns(bool){\n        return IWhiteListOracle(whitelistOracle).whitelisted(_user);\n   }\n   \n   function createSaleContract(uint256 _allocated, uint8 _source) public onlyGovernor returns(bool) {\n       require(\n           Math.add(lastCreated,2 hours) < block.timestamp,\n           \"Create After Sometime\"\n       );\n       SaleInfo storage i = info[Math.add(totalSaleContracts,1)];\n       i.start = block.timestamp;\n       i.end = Math.add(block.timestamp,2 hours);\n       i.allocated = Math.mul(_allocated,10 ** 18);\n       i.priceSource = _source;\n       lastCreated = block.timestamp;\n       totalSaleContracts = Math.add(totalSaleContracts,1);\n       return true;   \n   }\n   \n   function increaseAllocation(uint256 _amount, uint256 _saleId) public onlyGovernor returns(bool){\n       SaleInfo storage i = info[_saleId];\n       require(\n         block.timestamp < i.end,\n         \"Sale Ended\"\n       );\n       i.allocated = Math.add(\n                     i.allocated,\n                     Math.mul(_amount,10**18)\n                     );\n       return true;\n       \n   }\n   \n   function purchaseWithEth() public payable nonReentrant returns(bool){\n       SaleInfo storage i = info[totalSaleContracts];\n       require(\n            i.totalPurchased <= i.allocated, \n            \"Sold Out\"\n        );\n        require(\n            block.timestamp < i.end,\n            \"Purchase Ended\"\n        );\n        require(isWhitelisted(msg.sender),\"Address not verified\");\n        (\n            uint256 _amountToken,\n            uint256 _pricePurchase,\n            uint256 _usdPurchase\n        )   = resolverEther(msg.value);\n        Sale storage s = sale[msg.sender][Math.add(totalPurchases[msg.sender],1)];\n        s.usdPurchase = _usdPurchase;\n        s.amountPurchased = _amountToken;\n        s.pricePurchase = _pricePurchase;\n        s.timestamp = block.timestamp;\n        s.saleId = totalSaleContracts;\n        i.totalPurchased = Math.add(i.totalPurchased,_amountToken);\n        totalPurchases[msg.sender] = Math.add(totalPurchases[msg.sender],1);\n        payable(ethWallet).transfer(msg.value);\n        return true;\n   }\n   \n   function adminPurchase(\n        uint256 _amountToken,\n        uint256 _usdPurchase,\n        uint256 _pricePurchase\n        ) public onlyGovernor returns(bool){\n        SaleInfo storage i = info[totalSaleContracts];\n        require(\n            i.totalPurchased <= i.allocated, \n            \"Sold Out\"\n        );\n        require(\n            block.timestamp < i.end,\n            \"Purchase Ended\"\n        );\n        Sale storage s = sale[msg.sender][Math.add(totalPurchases[msg.sender],1)];\n        s.usdPurchase = _usdPurchase;\n        s.amountPurchased = _amountToken;\n        s.pricePurchase = _pricePurchase;\n        s.timestamp = block.timestamp;\n        s.saleId = totalSaleContracts;\n        i.totalPurchased = Math.add(i.totalPurchased,_amountToken);\n        totalPurchases[msg.sender] = Math.add(totalPurchases[msg.sender],1);\n        return true;\n   }\n   \n   function resolverEther(uint256 _amountEther) public view returns(uint256,uint256,uint256){\n        uint256 ethPrice = uint256(fetchEthPrice());\n                ethPrice = Math.mul(_amountEther,ethPrice);\n        uint256 price = fetchTokenPrice();\n        uint256 _tokenAmount = Math.div(ethPrice,price);\n        return(_tokenAmount,price,ethPrice);\n    }\n    \n    function fetchTokenPrice() public view returns(uint256){\n        SaleInfo storage i = info[totalSaleContracts];\n        if(i.priceSource == 0){\n            return pricePerToken;\n        }\n        else{\n            return uint256(fetchEdgexPrice());\n        }\n    }\n   \n   function fetchEthPrice() public view returns (int) {\n        (\n            uint80 roundID, \n            int price,\n            uint startedAt,\n            uint timeStamp,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(ethPriceSource).latestRoundData();\n        return price;\n    }\n    \n    function fetchEdgexPrice() public view returns (uint256) {\n        uint256 totalPrice;\n        uint256 validOracles;\n        for(uint256 i = 0; i < totalOracles ; i++){\n        if(oracle[i] != address(0)){\n        (\n            uint80 roundID, \n            int price,\n            uint startedAt,\n            uint timeStamp,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(oracle[i]).latestRoundData();\n        totalPrice = Math.add(totalPrice,uint256(price));\n        validOracles = Math.add(validOracles,1);\n        }\n        }\n        return Math.div(totalPrice, validOracles);\n    }\n    \n    function claim(uint256 _saleId) public nonReentrant returns(bool){\n        Sale storage s = sale[msg.sender][_saleId];\n        SaleInfo storage i = info[s.saleId];\n        require(\n            !s.isAllocated,\n            \"Already Settled\"\n        );\n        require(\n            block.timestamp > i.end,\n            \"Sale Not Yet Ended\"\n        );\n        uint256 _bonusTokens = resolveBonus(_saleId,msg.sender);\n        s.bonus = _bonusTokens;\n        s.isAllocated = true;\n        IERC20(edgexTokenContract)\n        .transfer(\n            msg.sender, \n            Math.add(s.amountPurchased,_bonusTokens)\n            );\n         IERC20(edgexTokenContract)\n        .transfer(\n            organisation, \n            Math.div(s.amountPurchased,100)\n        );\n        return true;\n    }\n    \n    function resolveBonus(uint256 _saleId,address _user) public view returns(uint256){\n        Sale storage s = sale[_user][_saleId];\n        uint256 _bonusPercent = resolveBonusPercent(s.saleId);\n        uint256 _bonusTokens = Math.mul(s.amountPurchased,_bonusPercent);\n                _bonusTokens = Math.div(_bonusTokens,10**6);\n        return _bonusTokens;\n    }\n    \n    function resolveBonusPercent(uint256 _saleId) public view returns(uint256){\n        SaleInfo storage i = info[_saleId];\n        uint _salePercent = Math.div(\n                            Math.mul(i.totalPurchased,10**6),\n                            i.allocated);\n        if(_salePercent < 30 * 10 ** 4) {\n            return 0;\n        }\n        else if(_salePercent > 30 * 10 ** 4 && _salePercent < 40 * 10 ** 4){\n            return 10000;\n        }\n        else if(_salePercent > 40 * 10 ** 4 && _salePercent < 50 * 10 ** 4){\n            return 25000;\n        }\n        else if(_salePercent > 50 * 10 ** 4 && _salePercent < 60 * 10 ** 4){\n            return 40000;\n        }\n        else if(_salePercent > 60 * 10 ** 4 && _salePercent < 70 * 10 ** 4){\n            return 50000;\n        }\n        else if(_salePercent > 70 * 10 ** 4 && _salePercent < 80 * 10 ** 4){\n            return 65000;\n        }\n        else if(_salePercent > 80 * 10 ** 4 && _salePercent < 90 * 10 ** 4){\n            return 75000;\n        }\n        else{\n            return 100000;\n        }\n    }\n    \n    function updateNewEdgexSource(address _newSource, uint8 index) public onlyAdmin isZero(_newSource) returns(bool){\n        oracle[index] = _newSource;\n        return true;\n    }\n    \n    function revokeOwnership(address _newOwner) public onlyAdmin isZero(_newOwner) returns(bool){\n        admin = payable(_newOwner);\n        emit RevokeOwnership(_newOwner);\n        return true;\n    }\n    \n    function updateEthSource(address _newSource) public onlyAdmin isZero(_newSource) returns(bool){\n        ethPriceSource = _newSource;\n        return true;\n    }\n    \n     function updateEdgexTokenContract(address _newSource) public onlyAdmin isZero(_newSource) returns(bool){\n        edgexTokenContract = _newSource;\n        return true;\n    }\n    \n    function updatePricePerToken(uint256 _price) public onlyAdmin returns(bool){\n        pricePerToken = _price;\n        emit UpdatePrice(_price);\n        return true;\n    }    \n\n    function drain(address _to, uint256 _amount) public onlyAdmin isZero(_to) returns(bool){\n        IERC20(edgexTokenContract).transfer(_to,_amount);\n        return true;\n    }\n\n    function updateWhiteListOracle(address _newOracle) public onlyAdmin isZero(_newOracle) returns(bool){\n        whitelistOracle = _newOracle;\n        return true;\n    }\n\n    function updateGovernor(address _newGovernor) public onlyGovernor isZero(_newGovernor) returns(bool){\n        governor = _newGovernor;\n        emit UpdateGovernor(_newGovernor);\n        return true;\n    }\n\n}"
    }
  }
}