{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CouponClipperV3.sol":{"content":"pragma solidity 0.7.5;\r\n// SPDX-License-Identifier: MIT\r\n\r\n/**\r\nCopyright (c) 2020 Austin Williams\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n**/\r\n\r\ninterface IESDS {\r\n    function redeemCoupons(uint256 _epoch, uint256 _couponAmount) external;\r\n    function transferCoupons(address _sender, address _recipient, uint256 _epoch, uint256 _amount) external;\r\n    function totalRedeemable() external view returns (uint256);\r\n    function epoch() external view returns (uint256);\r\n    function balanceOfCoupons(address _account, uint256 _epoch) external view returns (uint256);\r\n    function advance() external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface ICHI {\r\n    function freeFromUpTo(address _addr, uint256 _amount) external returns (uint256);\r\n}\r\n\r\n// @notice Lets anybody trustlessly redeem coupons on anyone else's behalf for a fee.\r\n//    Requires that the coupon holder has previously approved this contract via the ESDS `approveCoupons` function.\r\n// @dev Bots should scan for the `SetOffer` event emitted by the this contract to find out which \r\n//    users have made offers. They should be sure to verify that the users have \"approved\" this contract.\r\n// @dev This contract's API should be backwards compatible with CouponClipper V1 and V2.\r\ncontract CouponClipperV3 {\r\n    using SafeMath for uint256;\r\n\r\n    IERC20 constant private ESD = IERC20(0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723);\r\n    IESDS constant private ESDS = IESDS(0x443D2f2755DB5942601fa062Cc248aAA153313D3);\r\n    ICHI  constant private CHI = ICHI(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n    \r\n    uint256 constant public MAX_HOUSE_RATE_BPS = 1500; // 15% Max house take from bot proceeds\r\n    \r\n    address public house = 0x7Fb471734271b732FbEEd4B6073F401983a406e1; // collector of house take\r\n    uint256 public houseRate = 1000; // Defaults to 1000 bps (10%) of proceeds. Can be changed via the `changeHouseRate` function.\r\n    \r\n    event SetOffer(address indexed user, uint256 offer);\r\n    event SetHouseRate(uint256 fee);\r\n    \r\n    // frees CHI from msg.sender to reduce gas costs.\r\n    // requires that msg.sender has approved this contract to use their CHI.\r\n    modifier useCHI {\r\n        uint256 gasStart = gasleft();\r\n        _;\r\n        uint256 gasSpent = 21000 + gasStart - gasleft() + (16 * msg.data.length);\r\n        CHI.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\r\n    }\r\n\r\n    // The basis points offered by coupon holders to have their coupons redeemed -- default is 0 bps (0%).\r\n    // E.g., offers[_user] = 500 indicates that _user will pay 500 basis points (5%) to have their coupons redeemed for them.\r\n    mapping(address => uint256) private offers;\r\n\r\n    // @notice Gets the number of basis points the _user is offering the bots.\r\n    // @param _user The account whose offer we're looking up.\r\n    // @return The number of basis points the account is offering to have their coupons redeemed.\r\n    function getOffer(address _user) public view returns (uint256) {\r\n        return offers[_user];\r\n    }\r\n\r\n    // @notice Allows msg.sender to change the number of basis points they are offering.\r\n    // @dev A user's offer cannot be *decreased* during the 15 minutes before the epoch advance (frontrun protection)\r\n    // @param _newOffer The number of basis points msg.sender wants to offer to have their coupons redeemed.\r\n    function setOffer(uint256 _newOffer) external {\r\n        require(_newOffer <= 10_000, \"Offer exceeds 100%.\");\r\n        uint256 oldOffer = offers[msg.sender];\r\n        if (_newOffer < oldOffer) {\r\n            uint256 nextEpoch = ESDS.epoch() + 1;\r\n            uint256 nextEpochStartTime = getEpochStartTime(nextEpoch);\r\n            uint256 timeUntilNextEpoch = nextEpochStartTime.sub(block.timestamp);\r\n            require(timeUntilNextEpoch > 15 minutes, \"You cannot reduce your offer within 15 minutes of the next epoch\");\r\n        }\r\n        \r\n        offers[msg.sender] = _newOffer;\r\n        \r\n        emit SetOffer(msg.sender, _newOffer);\r\n    }\r\n    \r\n    // @notice Internal logic used to redeem coupons on the coupon holder's bahalf\r\n    // @param _user Address of the user holding the coupons (and who has approved this contract)\r\n    // @param _epoch The epoch in which the _user purchased the coupons\r\n    // @param _couponAmount The number of coupons to redeem (18 decimals)\r\n    function _redeem(address _user, uint256 _epoch, uint256 _couponAmount) internal {\r\n        \r\n        // pull user's coupons into this contract (requires that the user has approved this contract)\r\n        ESDS.transferCoupons(_user, address(this), _epoch, _couponAmount); // @audit-info : reverts on failure\r\n        \r\n        // redeem the coupons for ESD\r\n        ESDS.redeemCoupons(_epoch, _couponAmount); // @audit-info : reverts on failure\r\n        \r\n        // pay the fees\r\n        uint256 totalFeeRate = getOffer(_user);\r\n        uint256 totalFee = _couponAmount.mul(totalFeeRate).div(10_000);\r\n        uint256 houseFee = totalFee.mul(houseRate).div(10_000);\r\n        uint256 botFee = totalFee.sub(houseFee);\r\n        ESD.transfer(house, houseFee); // @audit-info : reverts on failure\r\n        ESD.transfer(msg.sender, botFee); // @audit-info : reverts on failure\r\n        \r\n        // send the ESD to the user\r\n        ESD.transfer(_user, _couponAmount.sub(totalFee)); // @audit-info : reverts on failure\r\n    }\r\n    \r\n    // @notice Allows anyone to redeem coupons for ESD on the coupon-holder's bahalf\r\n    // @dev Backwards compatible with CouponClipper V1 and V2.\r\n    function redeem(address _user, uint256 _epoch, uint256 _couponAmount) external {\r\n        _redeem(_user, _epoch, _couponAmount);\r\n    }\r\n    \r\n    // @notice A convenience function for less experienced bot writers. (More advanced bot writers will interact with \r\n    //    this contract via the `redeem` function and wrap it in their own custom logic);\r\n    // @dev Advances the epoch (if needed) and redeems the max amount of coupons possible\r\n    //    Also frees CHI tokens to save on gas (requires that msg.sender has CHI tokens in their\r\n    //    account and has approved this contract to spend their CHI).\r\n    // @param _user The user whose coupons will attempt to be redeemed\r\n    // @param _epoch The epoch in which the coupons were created\r\n    // @param _targetEpoch The epoch that is about to be advanced _to_.\r\n    //    E.g., if the current epoch is 220 and we are about to advance to to epoch 221, then _targetEpoch\r\n    //    would be set to 221. The _targetEpoch is the epoch in which the coupon redemption will be attempted.\r\n    function advanceAndRedeemMax(address _user, uint256 _epoch, uint256 _targetEpoch) external useCHI {\r\n        // End execution early if tx is mined too early\r\n        uint256 targetEpochStartTime = getEpochStartTime(_targetEpoch);\r\n        if (block.timestamp < targetEpochStartTime) { return; }\r\n        \r\n        // advance epoch if it has not already been advanced \r\n        if (ESDS.epoch() != _targetEpoch) {\r\n            ESDS.advance();\r\n            ESD.transfer(msg.sender, 100e18);\r\n        }\r\n        \r\n        // get max redeemable amount\r\n        uint256 totalRedeemable = ESDS.totalRedeemable();\r\n        if (totalRedeemable == 0) { return; } // no coupons to redeem\r\n        uint256 userBalance = ESDS.balanceOfCoupons(_user, _epoch);\r\n        if (userBalance == 0) { return; } // no coupons to redeem\r\n        uint256 maxRedeemableAmount = totalRedeemable < userBalance ? totalRedeemable : userBalance;\r\n        \r\n        // attempt to redeem coupons\r\n        _redeem(_user, _epoch, maxRedeemableAmount);\r\n    }\r\n\r\n    \r\n    // @notice Returns the timestamp at which the _targetEpoch starts\r\n    function getEpochStartTime(uint256 _targetEpoch) public pure returns (uint256) {\r\n        return _targetEpoch.sub(106).mul(28800).add(1602201600);\r\n    }\r\n    \r\n    // @notice Allows house address to change the house address\r\n    function changeHouseAddress(address _newAddress) external {\r\n        require(msg.sender == house);\r\n        house = _newAddress;\r\n    }\r\n    \r\n    // @notice Allows house address to change the house rate\r\n    // @dev House rate can never be larger than MAX_HOUSE_RATE_BPS\r\n    // @dev House rate cannot *increase* fewer than 15 minutes before the next epoch (frontrun protection)\r\n    function changeHouseRate(uint256 _newHouseRate) external {\r\n        require(msg.sender == house, \"only house can update fee\");\r\n        require(_newHouseRate <= MAX_HOUSE_RATE_BPS, \"fee too high\");\r\n        if (_newHouseRate > houseRate) {\r\n            uint256 nextEpoch = ESDS.epoch() + 1;\r\n            uint256 nextEpochStartTime = getEpochStartTime(nextEpoch);\r\n            uint256 timeUntilNextEpoch = nextEpochStartTime.sub(block.timestamp);\r\n            require(timeUntilNextEpoch > 15 minutes, \"Cannot increase house rate within 15 minutes of the next epoch\");\r\n        }\r\n        houseRate = _newHouseRate;\r\n        emit SetHouseRate(_newHouseRate);\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"}}}