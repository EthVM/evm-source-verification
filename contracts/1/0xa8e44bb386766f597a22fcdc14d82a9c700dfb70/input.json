{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/hashelot_dayrings.sol":{"content":"// Hashelot [Day] Rings - v.1.0\r\n// MIT License\r\n// Copyright (c) 2020 Maurizio Ponti\r\n\r\npragma solidity ^0.6.1;\r\n\r\ncontract hashelot_dayrings{ // Son of a lockdown\r\n\r\n    address payable private owner;\r\n\r\n    address payable [] public stackPlayers;\r\n\r\n    uint public stackValue; // Current value to enter the bet\r\n    uint public stackTime;  // The block.number at which the bet started\r\n    uint public stackWait; // What a difference a day made\r\n    uint public stackSoFar; // Total amount of winnings\r\n\r\n    constructor() public{ // Once and for all\r\n        owner = msg.sender;\r\n        stackSoFar = 0;\r\n        stackWait = 5748;\r\n    }\r\n\r\n    modifier OwnerOnly{\r\n        if(msg.sender == owner){\r\n            _;\r\n        }\r\n    }\r\n\r\n    function dustStack() OwnerOnly public payable{\r\n        require (block.number > stackTime+stackWait, \"Unable to dust: there is an ongoing bet.\");\r\n        // Set things right before dusting\r\n        if (stackPlayers.length >= 1){\r\n          closeBet();\r\n        }\r\n        uint _balance = address(this).balance;\r\n        if(_balance > 0){ // Is there something to dust?\r\n          owner.transfer(_balance);\r\n        }\r\n    }\r\n\r\n    function closeBet() public payable {\r\n        uint _block = block.number;\r\n        /* To close a bet there has to be at least one player in and\r\n           enough blocks mined */\r\n        require (_block > stackTime+stackWait && stackPlayers.length >= 1, \"Bet closing error: no bet to claim.\");\r\n        uint currentKey;\r\n        uint _ownerShare;\r\n        uint _winnerShare;\r\n        address payable _winnerKey;\r\n        uint stackTotal = stackPlayers.length*stackValue;\r\n        // 2% of the total stack goes to the owner\r\n        _ownerShare = stackTotal/100*2;\r\n        // The rest goes to the winner\r\n        _winnerShare = stackTotal-_ownerShare;\r\n\r\n        /* Find the winner\r\n           Initialize currentKey and winnerKey to the first entry\r\n           ---\r\n           The winner is such according to\r\n           block.number = stackTime + stackWait + 1 */\r\n\r\n        currentKey = uint(keccak256(abi.encodePacked(blockhash(stackTime+stackWait+1), stackPlayers[0])));\r\n        _winnerKey = stackPlayers[0];\r\n\r\n        for (uint k = 1; k < stackPlayers.length; k++){\r\n          if(uint(keccak256(abi.encodePacked(blockhash(stackTime+stackWait+1), stackPlayers[k]))) < currentKey){\r\n            currentKey = uint(keccak256(abi.encodePacked(blockhash(stackTime+stackWait+1), stackPlayers[k])));\r\n            _winnerKey = stackPlayers[k];\r\n          }\r\n        }  // Gotcha!\r\n\r\n        // Send share to owner\r\n        owner.transfer(_ownerShare);\r\n\r\n        // Send share to winner\r\n        _winnerKey.transfer(_winnerShare);\r\n        stackSoFar = stackSoFar+_winnerShare; // Update the total amount won\r\n        stackValue = 0;\r\n        stackTime = 0;\r\n        delete stackPlayers; // Closing previous bets\r\n    }\r\n\r\n    function checkBalance() public view returns (uint){\r\n        return address(this).balance;\r\n    }\r\n\r\n    function checkPlayers() public view returns (uint){\r\n        return stackPlayers.length;\r\n    }\r\n\r\n    function depositStack() public payable{\r\n        require (msg.value >= 1 finney, \"Deposit error: not enough cash.\"); // At least 1 finney bets\r\n\r\n        uint _block = block.number;\r\n\r\n        // It is possible to enter an ongoing round until stackTime+stackWait\r\n        if (_block > stackTime+stackWait) { // There is no bet in progress\r\n\r\n          // Closing possible previous bets as owner and winner get their share\r\n          if (stackPlayers.length >= 1){\r\n            closeBet();\r\n          }\r\n\r\n          stackValue = msg.value; // New value one needs to enter the bet\r\n          stackTime = _block; // The game starts now!\r\n          stackPlayers.push(msg.sender);\r\n\r\n        }else{ // There actually is a bet in progress!\r\n\r\n          // Are you trying to play twice in the same round?\r\n          bool alreadyIn = false;\r\n          for (uint k = 0; k < stackPlayers.length; k++){\r\n            if (stackPlayers[k] == msg.sender){\r\n              alreadyIn = true;\r\n            }\r\n          }\r\n\r\n          if (alreadyIn){ // Hey, don't play twice!\r\n            msg.sender.transfer(msg.value);\r\n          }else{ // You can enter the round\r\n            // Check if msg.value >= stackValue\r\n            if (msg.value >= stackValue) {\r\n              uint playerChange = msg.value-stackValue;\r\n              if (playerChange > 0) {\r\n                msg.sender.transfer(playerChange);\r\n              }\r\n              stackPlayers.push(msg.sender); // Another player enters the bet\r\n            }else{ // Too poor to enter the bet\r\n              msg.sender.transfer(msg.value);\r\n            }\r\n          }\r\n        }\r\n    }\r\n}\r\n"}}}