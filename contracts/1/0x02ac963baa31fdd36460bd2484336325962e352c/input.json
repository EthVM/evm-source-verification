{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"dao.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\ncontract DAO {\n    address public dao;\n\n    event DAOChanged(address from, address to);\n\n    constructor() {\n        dao = msg.sender;\n        emit DAOChanged(address(0), msg.sender);\n    }\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Only DAO\");\n        _;\n    }\n\n    function changeDAO(address _dao) external onlyDAO {\n        require(_dao != address(0), \"DAO to ZERO\");\n        address olddao = dao;\n        dao = _dao;\n        emit DAOChanged(olddao, dao);\n    }\n\n}\n"},"interfaces.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n// Interfaces for contract interaction\ninterface INterfaces {\n    function balanceOf(address) external returns (uint256);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n}\n\n// For tokens that do not return true on transfers eg. USDT\ninterface INterfacesNoR {\n    function transfer(address, uint256) external;\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external;\n}\n"},"owned.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipChanged(address from, address to);\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipChanged(address(0), msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    // owner can give super-rights to someone\n    function giveOwnership(address user) external onlyOwner {\n        require(user != address(0), \"User renounceOwnership\");\n        newOwner = user;\n    }\n\n    // new owner need to accept\n    function acceptOwnership() external {\n        require(msg.sender == newOwner, \"Only NewOwner\");\n        emit OwnershipChanged(owner, newOwner);\n        owner = msg.sender;\n        delete newOwner;\n    }\n}\n"},"TattooMoneyPublicSaleX.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.7;\n\n// TattooMoney.io Public Sale Contract - via StableCoins, ETH and wBTC\n//\n// USE ONLY OWN WALLET (Metamask, TrustWallet, Trezor, Ledger...)\n// DO NOT SEND FROM EXCHANGES OR ANY SERVICES\n//\n// Use ONLY ETH network, ERC20 tokens (Not Binance/Tron/whatever!)\n//\n// Set approval to contract address or use USDC authorization first\n//\n// DO NOT SEND STABLE TOKENS DIRECTLY - IT WILL NOT COUNT THAT!\n//\n// Need 150k gas limit.\n// Use proper pay* function\n\ncontract TattooMoneyPublicSaleX {\n\n    uint256 private constant DECIMALS_TAT2 = 18;\n    uint256 private constant DECIMALS_DAI = 18;\n    uint256 private constant DECIMALS_USD = 6;\n    uint256 private constant DECIMALS_WBTC = 8;\n\n    /// max tokens per user is 150000 as $15000 is AML limit\n    uint256 public constant maxTokens = 150_000*(10**DECIMALS_TAT2);\n\n    /// contract starts accepting transfers\n    uint256 public  dateStart;\n\n    /// hard time limit\n    uint256 public  dateEnd;\n\n    /// total collected USD\n    uint256 public usdCollected;\n\n    /// sale is limited by tokens count\n    uint256 public tokensLimit;\n\n    /// tokens sold in this sale\n    uint256 public tokensSold;\n\n    uint256 public tokensforadolar = 10*(10**DECIMALS_TAT2);\n\n    // addresses of tokens\n    address public tat2 = 0xb487d0328b109e302b9d817b6f46Cbd738eA08C2;\n    address public usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address public dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public wbtc = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    address public usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address public wbtcoracle = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;\n    address public ethoracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n\n    address public owner;\n    address public newOwner;\n\n    bool public saleEnded;\n\n    // deposited USD tokens per token address\n    mapping(address => uint256) private _deposited;\n\n    /// Tokens bought by user\n    mapping(address => uint256) public tokensBoughtOf;\n\n    mapping(address => bool) public KYCpassed;\n\n    event AcceptedUSD(address indexed user, uint256 amount);\n    event AcceptedWBTC(address indexed user, uint256 amount);\n    event AcceptedETH(address indexed user, uint256 amount);\n\n    string constant ERR_TRANSFER = \"Token transfer failed\";\n    string constant ERR_SALE_LIMIT = \"Token sale limit reached\";\n    string constant ERR_AML = \"AML sale limit reached\";\n    string constant ERR_SOON = \"TOO SOON\";\n\n    /**\n    Contract constructor\n    @param _owner adddress of contract owner\n    @param _startDate sale start timestamp\n    @param _endDate sale end timestamp\n     */\n\n    constructor(\n        address _owner,\n        uint256 _tokensLimit, // 39000000\n        uint256 _startDate, // 9-12-2021  20:22:22 GMT (1642112542)\n        uint256 _endDate //  13-1-2022  22:22:22 GMT (1644704542)\n    ) {\n        owner = _owner;\n        tokensLimit = _tokensLimit * (10**DECIMALS_TAT2);\n        dateStart = _startDate;\n        dateEnd = _endDate;\n    }\n\n    /**\n        Add address that passed KYC\n        @param user address to mark as fee-free\n     */\n    function addKYCpassed(address user) external onlyOwner {\n        KYCpassed[user] = true;\n    }\n\n    /**\n        Remove address form KYC list\n        @param user user to remove\n     */\n    function removeKYCpassed(address user) external onlyOwner {\n        KYCpassed[user] = false;\n    }\n\n    /**\n    Pay in using USDC, use approve/transferFrom\n    @param amount number of USDC (with decimals)\n    */\n    function payUSDC(uint256 amount) external {\n        require(\n            INterfaces(usdc).transferFrom(msg.sender, address(this), amount),\n            ERR_TRANSFER\n        );\n        _pay(msg.sender, amount );\n        _deposited[usdc] += amount;\n    }\n\n    /**\n    Pay in using USDT, need set approval first\n    @param amount USDT amount (with decimals)\n    */\n    function payUSDT(uint256 amount) external {\n        INterfacesNoR(usdt).transferFrom(msg.sender, address(this), amount);\n        _pay(msg.sender, amount );\n        _deposited[usdt] += amount;\n    }\n\n    /**\n    Pay in using DAI, need set approval first\n    @param amount number of DAI (with 6 decimals)\n    */\n    function payDAI(uint256 amount) external {\n        require(\n            INterfaces(dai).transferFrom(msg.sender, address(this), amount),\n            ERR_TRANSFER\n        );\n        _pay(msg.sender, amount / (10**12));\n        _deposited[dai] += amount;\n    }\n\n    /**\n    Pay in using wBTC, need set approval first\n    @param amount number of wBTC (with decimals)\n    */\n    function paywBTC(uint256 amount) external {\n        require(\n            INterfaces(wbtc).transferFrom(msg.sender, address(this), amount),\n            ERR_TRANSFER\n        );\n        _paywBTC(msg.sender, amount );\n        _deposited[wbtc] += amount;\n    }\n\n    //\n    // accept ETH\n    //\n\n    receive() external payable {\n        _payEth(msg.sender, msg.value);\n    }\n\n    function payETH() external payable {\n        _payEth(msg.sender, msg.value);\n    }\n\n    /**\n    Get ETH price from Chainlink.\n    @return price for 1 ETH with 18 decimals\n    */\n    function tokensPerEth() public view returns (uint256) {\n        int256 answer;\n        (, answer, , , ) = INterfaces(ethoracle).latestRoundData();\n        // geting price with 18 decimals\n        return uint256((uint256(answer) * tokensforadolar)/10**8);\n    }\n\n    /**\n    Get BTC price from Chainlink.\n    @return price for 1 BTC with 18 decimals\n    */\n    function tokensPerwBTC() public view returns (uint256) {\n        int256 answer;\n        (, answer, , , ) = INterfaces(wbtcoracle).latestRoundData();\n        // geting price with 18 decimals\n        return uint256((uint256(answer) * tokensforadolar)/10**8);\n    }\n\n    /**\n    How much tokens left to sale\n    */\n    function tokensLeft() external view returns (uint256) {\n        return tokensLimit - tokensSold;\n    }\n\n    function _payEth(address user, uint256 amount) internal notEnded {\n        uint256 sold = (amount * tokensPerEth()) / (10**18);\n        tokensSold += sold;\n        require(tokensSold <= tokensLimit, ERR_SALE_LIMIT);\n        tokensBoughtOf[user] += sold;\n        if(!KYCpassed[user]){\n          require(tokensBoughtOf[user] <= maxTokens, ERR_AML);\n        }\n        _sendTokens(user, sold);\n        emit AcceptedETH(user, amount);\n    }\n\n    function _paywBTC(address user, uint256 amount) internal notEnded {\n        uint256 sold = (amount * tokensPerwBTC()) / (10**8);\n        tokensSold += sold;\n        require(tokensSold <= tokensLimit, ERR_SALE_LIMIT);\n        tokensBoughtOf[user] += sold;\n        if(!KYCpassed[user]){\n          require(tokensBoughtOf[user] <= maxTokens, ERR_AML);\n        }\n        _sendTokens(user, sold);\n        emit AcceptedWBTC(user, amount);\n    }\n\n    function _pay(address user, uint256 usd) internal notEnded {\n        uint256 sold = (usd * tokensforadolar) / (10**6);\n        tokensSold += sold;\n        require(tokensSold <= tokensLimit, ERR_SALE_LIMIT);\n        tokensBoughtOf[user] += sold;\n        if(!KYCpassed[user]){\n          require(tokensBoughtOf[user] <= maxTokens, ERR_AML);\n        }\n        _sendTokens(user, sold);\n        emit AcceptedUSD(user, usd);\n    }\n\n    function _sendTokens(address user, uint256 amount) internal notEnded {\n      require(\n          INterfaces(tat2).transfer(user, amount),\n          ERR_TRANSFER\n      );\n    }\n\n    //\n    // modifiers\n    //\n\n    modifier notEnded() {\n        require(!saleEnded, \"Sale ended\");\n        require(\n            block.timestamp > dateStart && block.timestamp < dateEnd,\n            \"Too soon or too late\"\n        );\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only for contract Owner\");\n        _;\n    }\n\n    /// Take out stables, wBTC  and ETH\n    function takeAll() external onlyOwner {\n        uint256 amt = INterfaces(usdt).balanceOf(address(this));\n        if (amt > 0) {\n            INterfacesNoR(usdt).transfer(owner, amt);\n        }\n        amt = INterfaces(usdc).balanceOf(address(this));\n        if (amt > 0) {\n            require(INterfaces(usdc).transfer(owner, amt), ERR_TRANSFER);\n        }\n        amt = INterfaces(dai).balanceOf(address(this));\n        if (amt > 0) {\n            require(INterfaces(dai).transfer(owner, amt), ERR_TRANSFER);\n        }\n        amt = INterfaces(wbtc).balanceOf(address(this));\n        if (amt > 0) {\n            require(INterfaces(wbtc).transfer(owner, amt), ERR_TRANSFER);\n        }\n        amt = address(this).balance;\n        if (amt > 0) {\n            payable(owner).transfer(amt);\n        }\n    }\n\n    /// we take unsold TAT2\n    function TakeUnsoldTAT2() external onlyOwner {\n        uint256 amt = INterfaces(tat2).balanceOf(address(this));\n        if (amt > 0) {\n            require(INterfaces(tat2).transfer(owner, amt), ERR_TRANSFER);\n        }\n    }\n\n    /// we can recover any ERC20!\n    function recoverErc20(address token) external onlyOwner {\n        uint256 amt = INterfaces(token).balanceOf(address(this));\n        if (amt > 0) {\n            INterfacesNoR(token).transfer(owner, amt); // use broken ERC20 to ignore return value\n        }\n    }\n\n    /// just in case\n    function recoverEth() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    function EndSale() external onlyOwner {\n        saleEnded = true;\n    }\n\n    function changeOwner(address _newOwner) external onlyOwner {\n        newOwner = _newOwner;\n    }\n\n    function acceptOwnership() external {\n        require(\n            msg.sender != address(0) && msg.sender == newOwner,\n            \"Only NewOwner\"\n        );\n        newOwner = address(0);\n        owner = msg.sender;\n    }\n}\n\n// Interfaces for contract interaction\ninterface INterfaces {\n    function balanceOf(address) external returns (uint256);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n    // chainlink ETH/USD, ethoracle\n    // answer|int256 :  304706968812 - 8 decimals\n\n    // chainlink BTC/USD wbtcoracle\n    // answer|int256 : 4419282000000 - 8 decimals\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n// For tokens that do not return true on transfers eg. USDT\ninterface INterfacesNoR {\n    function transfer(address, uint256) external;\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\n// by Patrick\n"}}}