{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Ape.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2021-05-11\n*/\n\npragma solidity =0.8.4;\npragma experimental ABIEncoderV2;\n// Leak alpha with https://twitter.com/mevalphaleak\n\n// All existing flash-loan providers have at least one of the following downsides\n// - Taking excessive fee for the service\n// - Hard to loan multiple assets at once\n// - Horribly inefficient in terms of gas:\n//  - Emitting pointless events\n//  - Creating useless additional transfers\n//  - No SLOAD/SSTORE optimisation past EIP-2929\n\n// ApeBank is introduced to make most gas efficient flash-loans available to everyone completely for free\n// Combined with native gas refunds without any additional sstore operations\n\n// ApeBank doesnt use safeMath and cuts corners everywhere, it isn't suitable for flash-mintable tokens\n// Contract wasnt audited by anyone and there's no benefit for depositing tokens into this contract and no APY\n// Anyone with half-working brain should think twice before putting anything into this contract\ncontract ApeBank {\n    string  public   constant name = \"YEET 2.0\";\n    address internal constant TOKEN_ETH  = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address internal constant TOKEN_WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address internal constant TOKEN_WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    address internal constant TOKEN_DAI  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address internal constant TOKEN_USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address internal constant TOKEN_USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    uint256 internal constant TOKEN_WETH_MULTIPLIER = 10 ** 14; // 0.4$ at the time of contract creation\n    uint256 internal constant TOKEN_WBTC_MULTIPLIER = 10 ** 3;  // 0.5$ at the time of contract creation\n    uint256 internal constant TOKEN_DAI_MULTIPLIER  = 10 ** 18;\n    uint256 internal constant TOKEN_USDC_MULTIPLIER = 10 ** 6;\n    uint256 internal constant TOKEN_USDT_MULTIPLIER = 10 ** 6;\n\n    uint256 internal constant FLAG_BORROW_ETH  = 0x1;\n    uint256 internal constant FLAG_BORROW_WETH = 0x2;\n    uint256 internal constant FLAG_BORROW_WBTC = 0x4;\n    uint256 internal constant FLAG_BORROW_DAI  = 0x8;\n    uint256 internal constant FLAG_BORROW_USDC = 0x10;\n    uint256 internal constant FLAG_BORROW_USDT = 0x20;\n    uint256 internal constant FLAG_COVER_WETH  = 0x40;\n\n    uint256 internal constant FLAG_BURN_NATIVE = 0x80;\n    uint256 internal constant FLAG_BURN_GST2   = 0x100;\n    uint256 internal constant FLAG_BURN_CHI    = 0x200;\n\n    uint256 internal constant FLAG_SMALL_CALLBACK = 0x400;\n    uint256 internal constant FLAG_LARGE_CALLBACK = 0x800;\n\n    uint256 internal constant FLAG_FREE_GAS_TOKEN               = 0x1000;\n    uint256 internal constant FLAG_GAS_TOKEN_BURN_AMOUNT_SHIFT  = 0x1000000000000000000000000000000000000000000000000000000000000;\n\n    Types.BankState public state;\n    Types.GasTokenPrices public gasTokenBurnPrices;\n\n    // Total amount of tokens deposited into ApeBank, this value can be lower than balances in 'state'\n    mapping (address => uint256) public totalDeposits;\n    mapping (address => uint256) public userEthBalances;\n    mapping (address => Types.BankState) public userTokenBalances;\n    // Our hall of fame which allows to use gas tokens for free\n    mapping (address => bool) public bestApeOperators;\n    \n    // Used to collect excess balances and acquire gas tokens\n    address public treasury;\n    address public pendingTresury;\n\n    event Deposit(address indexed user, address indexed token, uint256 amount);\n    event Withdrawal(address indexed user, address indexed token, uint256 amount);\n    event SkimmedBalance(address indexed treasury, address indexed token, uint256 amount);\n    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    constructor () {\n        treasury = msg.sender;\n        pendingTresury = 0x0000000000000000000000000000000000000000;\n        emit TreasuryUpdated(pendingTresury, treasury);\n    }\n    function nominateTreasury(address nomination) external {\n        require(msg.sender == treasury);\n        pendingTresury = nomination;\n    }\n    function acceptNomination() external {\n        require(msg.sender == pendingTresury);\n        emit TreasuryUpdated(treasury, pendingTresury);\n        treasury = pendingTresury;\n        pendingTresury = 0x0000000000000000000000000000000000000000;\n    }\n    function updateGasTokenPrices(uint80 priceGST2, uint80 priceCHI, uint80 priceNative) external {\n        require(msg.sender == treasury);\n        Types.GasTokenPrices memory cachedPrices;\n        cachedPrices.priceGST2 = priceGST2;\n        cachedPrices.priceCHI = priceCHI;\n        cachedPrices.priceNative = priceNative;\n        gasTokenBurnPrices = cachedPrices;\n    }\n    function promoteToFreeGasTokens(address apeOperator) external {\n        require(msg.sender == treasury);\n        bestApeOperators[apeOperator] = true;\n    }\n    \n    fallback() external payable {}\n    receive() external payable {}\n\n    // Logic to skim excess balances into treasury to acquire more gas tokens\n    function skimExcessBalances(address token) external {\n        require(msg.sender == treasury);\n        uint256 minBalanceToKeep = totalDeposits[token] + 1;\n\n        Types.BankState memory cachedBankState = state;\n        uint256 availableBalance;\n        if (token == TOKEN_ETH) {\n            availableBalance = address(this).balance;\n            require(availableBalance > minBalanceToKeep);\n            TransferHelper.safeTransferETH(\n                msg.sender,\n                availableBalance - minBalanceToKeep\n            );\n            // ETH balances aren't saved in state\n        } else {\n            availableBalance = IERC20Token(token).balanceOf(address(this));\n            require(availableBalance > minBalanceToKeep);\n            TransferHelper.safeTransfer(\n                token,\n                msg.sender,\n                availableBalance - minBalanceToKeep\n            );\n\n            if (token == TOKEN_WETH) {\n                cachedBankState.wethBalance = uint32(minBalanceToKeep / TOKEN_WETH_MULTIPLIER);\n            } else if (token == TOKEN_WBTC) {\n                cachedBankState.wbtcBalance = uint32(minBalanceToKeep / TOKEN_WBTC_MULTIPLIER);\n            } else if (token == TOKEN_DAI) {\n                cachedBankState.daiBalance  = uint32(minBalanceToKeep / TOKEN_DAI_MULTIPLIER );\n            } else if (token == TOKEN_USDC) {\n                cachedBankState.usdcBalance = uint32(minBalanceToKeep / TOKEN_USDC_MULTIPLIER);\n            } else if (token == TOKEN_USDT) {\n                cachedBankState.usdtBalance = uint32(minBalanceToKeep / TOKEN_USDT_MULTIPLIER);\n            }\n        }\n\n        require(cachedBankState.numCalls == state.numCalls);\n        cachedBankState.numCalls += 1;\n        state = cachedBankState;\n        emit SkimmedBalance(msg.sender, token, availableBalance - minBalanceToKeep);\n    }\n\n    function deposit(address token, uint256 amount) external payable {\n        Types.BankState memory cachedBankState = state;\n        if (msg.value > 0) {\n            require(token == TOKEN_ETH && msg.value == amount, \"Incorrect deposit amount\");\n            userEthBalances[msg.sender] += msg.value;\n        } else {\n            TransferHelper.safeTransferFrom(\n                token,\n                msg.sender,\n                address(this),\n                amount\n            );            \n            if (token == TOKEN_WETH) {\n                require(amount % TOKEN_WETH_MULTIPLIER == 0, \"Incorrect deposit amount\");\n                uint256 newBalance = cachedBankState.wethBalance + (amount / TOKEN_WETH_MULTIPLIER);\n                require(newBalance < (2 ** 32), \"Bank size is excessive\");\n                cachedBankState.wethBalance = uint32(newBalance);\n                userTokenBalances[msg.sender].wethBalance += uint32(amount / TOKEN_WETH_MULTIPLIER);\n            } else if (token == TOKEN_WBTC) {\n                require(amount % TOKEN_WBTC_MULTIPLIER == 0, \"Incorrect deposit amount\");\n                uint256 newBalance = cachedBankState.wbtcBalance + (amount / TOKEN_WBTC_MULTIPLIER);\n                require(newBalance < (2 ** 32), \"Bank size is excessive\");\n                cachedBankState.wbtcBalance = uint32(newBalance);\n                userTokenBalances[msg.sender].wbtcBalance += uint32(amount / TOKEN_WBTC_MULTIPLIER);\n            } else if (token == TOKEN_DAI) {\n                require(amount % TOKEN_DAI_MULTIPLIER == 0, \"Incorrect deposit amount\");\n                uint256 newBalance = cachedBankState.daiBalance + (amount / TOKEN_DAI_MULTIPLIER);\n                require(newBalance < (2 ** 32), \"Bank size is excessive\");\n                cachedBankState.daiBalance = uint32(newBalance);\n                userTokenBalances[msg.sender].daiBalance += uint32(amount / TOKEN_DAI_MULTIPLIER);\n            } else if (token == TOKEN_USDC) {\n                require(amount % TOKEN_USDC_MULTIPLIER == 0, \"Incorrect deposit amount\");\n                uint256 newBalance = cachedBankState.usdcBalance + (amount / TOKEN_USDC_MULTIPLIER);\n                require(newBalance < (2 ** 32), \"Bank size is excessive\");\n                cachedBankState.usdcBalance = uint32(newBalance);\n                userTokenBalances[msg.sender].usdcBalance += uint32(amount / TOKEN_USDC_MULTIPLIER);\n            } else {\n                require(token == TOKEN_USDT, \"Token not supported\");\n                require(amount % TOKEN_USDT_MULTIPLIER == 0, \"Incorrect deposit amount\");\n                uint256 newBalance = cachedBankState.usdtBalance + (amount / TOKEN_USDT_MULTIPLIER);\n                require(newBalance < (2 ** 32), \"Bank size is excessive\");\n                cachedBankState.usdtBalance = uint32(newBalance);\n                userTokenBalances[msg.sender].usdtBalance += uint32(amount / TOKEN_USDT_MULTIPLIER);\n            }\n        }\n        totalDeposits[token] += amount;\n        \n        require(cachedBankState.numCalls == state.numCalls);\n        cachedBankState.numCalls += 1;\n        state = cachedBankState;\n        emit Deposit(msg.sender, token, amount);\n    }\n\n    function withdraw(address token, uint256 amount) external {\n        Types.BankState memory cachedBankState = state;\n        \n        totalDeposits[token] -= amount;\n        if (token == TOKEN_ETH) {\n            require(userEthBalances[msg.sender] >= amount);\n            userEthBalances[msg.sender] -= amount;\n            // ETH balances aren't saved into state\n            TransferHelper.safeTransferETH(\n                msg.sender,\n                amount\n            );\n        } else {\n            if (token == TOKEN_WETH) {\n                require(amount % TOKEN_WETH_MULTIPLIER == 0, \"Incorrect withdraw amount\");\n                uint256 amountDelta = amount / TOKEN_WETH_MULTIPLIER;\n                require(uint256(userTokenBalances[msg.sender].wethBalance) >= amountDelta);\n                userTokenBalances[msg.sender].wethBalance -= uint32(amountDelta);\n                cachedBankState.wethBalance -= uint32(amountDelta);\n            } else if (token == TOKEN_WBTC) {\n                require(amount % TOKEN_WBTC_MULTIPLIER == 0, \"Incorrect withdraw amount\");\n                uint256 amountDelta = amount / TOKEN_WBTC_MULTIPLIER;\n                require(uint256(userTokenBalances[msg.sender].wbtcBalance) >= amountDelta);\n                userTokenBalances[msg.sender].wbtcBalance -= uint32(amountDelta);\n                cachedBankState.wbtcBalance -= uint32(amountDelta);\n            } else if (token == TOKEN_DAI) {\n                require(amount % TOKEN_DAI_MULTIPLIER == 0, \"Incorrect withdraw amount\");\n                uint256 amountDelta = amount / TOKEN_DAI_MULTIPLIER;\n                require(uint256(userTokenBalances[msg.sender].daiBalance) >= amountDelta);\n                userTokenBalances[msg.sender].daiBalance -= uint32(amountDelta);\n                cachedBankState.daiBalance -= uint32(amountDelta);\n            } else if (token == TOKEN_USDC) {\n                require(amount % TOKEN_USDC_MULTIPLIER == 0, \"Incorrect withdraw amount\");\n                uint256 amountDelta = amount / TOKEN_USDC_MULTIPLIER;\n                require(uint256(userTokenBalances[msg.sender].usdcBalance) >= amountDelta);\n                userTokenBalances[msg.sender].usdcBalance -= uint32(amountDelta);\n                cachedBankState.usdcBalance -= uint32(amountDelta);\n            } else {\n                require(token == TOKEN_USDT, \"Token not supported\");\n                require(amount % TOKEN_USDT_MULTIPLIER == 0, \"Incorrect withdraw amount\");\n                uint256 amountDelta = amount / TOKEN_USDT_MULTIPLIER;\n                require(uint256(userTokenBalances[msg.sender].usdtBalance) >= amountDelta);\n                userTokenBalances[msg.sender].usdtBalance -= uint32(amountDelta);\n                cachedBankState.usdtBalance -= uint32(amountDelta);\n            }\n            TransferHelper.safeTransfer(\n                token,\n                msg.sender,\n                amount\n            );        \n        }\n        \n        require(cachedBankState.numCalls == state.numCalls);\n        cachedBankState.numCalls += 1;\n        state = cachedBankState;\n        emit Withdrawal(msg.sender, token, amount);\n    }\n    \n    function flashApe(address payable callTo, uint256 flags, bytes calldata params) external payable {\n        Types.BankState memory cachedBankState = state;\n\n        if ((flags & FLAG_BORROW_WETH) > 0) {\n            TransferHelper.safeTransfer(\n                TOKEN_WETH,\n                callTo,\n                uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER\n            );\n        }\n        if ((flags & (FLAG_BORROW_WBTC | FLAG_BORROW_DAI | FLAG_BORROW_USDC | FLAG_BORROW_USDT)) > 0) {\n            if ((flags & FLAG_BORROW_WBTC) > 0) {\n                TransferHelper.safeTransfer(\n                    TOKEN_WBTC,\n                    callTo,\n                    uint256(cachedBankState.wbtcBalance) * TOKEN_WBTC_MULTIPLIER\n                );\n            }\n            if ((flags & FLAG_BORROW_DAI) > 0) {\n                TransferHelper.safeTransfer(\n                    TOKEN_DAI,\n                    callTo,\n                    uint256(cachedBankState.daiBalance) * TOKEN_DAI_MULTIPLIER\n                );\n            }\n            if ((flags & FLAG_BORROW_USDC) > 0) {\n                TransferHelper.safeTransfer(\n                    TOKEN_USDC,\n                    callTo,\n                    uint256(cachedBankState.usdcBalance) * TOKEN_USDC_MULTIPLIER\n                );\n            }\n            if ((flags & FLAG_BORROW_USDT) > 0) {\n                TransferHelper.safeTransfer(\n                    TOKEN_USDT,\n                    callTo,\n                    uint256(cachedBankState.usdtBalance) * TOKEN_USDT_MULTIPLIER\n                );\n            }\n        }\n        uint256 oldSelfBalance = address(this).balance;\n\n        // For \"ease\" of integration allowing several different callback options\n        if ((flags & (FLAG_SMALL_CALLBACK | FLAG_LARGE_CALLBACK)) > 0) {\n            // Native payable callbacks\n            if ((flags & FLAG_SMALL_CALLBACK) > 0) {\n                IApeBot(callTo).smallApeCallback{value: ((flags & FLAG_BORROW_ETH) > 0) ? oldSelfBalance - 1 : 0}(\n                    params\n                );\n            } else {\n                IApeBot(callTo).largeApeCallback{value: ((flags & FLAG_BORROW_ETH) > 0) ? oldSelfBalance - 1 : 0}(\n                    msg.sender,\n                    (((flags & FLAG_BORROW_WETH) > 0) ? uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER : 0),\n                    (((flags & FLAG_BORROW_WBTC) > 0) ? uint256(cachedBankState.wbtcBalance) * TOKEN_WBTC_MULTIPLIER : 0),\n                    (((flags & FLAG_BORROW_DAI ) > 0) ? uint256(cachedBankState.daiBalance ) * TOKEN_DAI_MULTIPLIER  : 0),\n                    (((flags & FLAG_BORROW_USDC) > 0) ? uint256(cachedBankState.usdcBalance) * TOKEN_USDC_MULTIPLIER : 0),\n                    (((flags & FLAG_BORROW_USDT) > 0) ? uint256(cachedBankState.usdtBalance) * TOKEN_USDT_MULTIPLIER : 0),\n                    params\n                );\n            }\n        } else {\n            // Immitating popular non-payable callback\n            if ((flags & FLAG_BORROW_ETH) > 0) {\n                TransferHelper.safeTransferETH(\n                    callTo,\n                    oldSelfBalance - 1\n                );\n            }\n            IApeBot(callTo).callFunction(\n                msg.sender,\n                Types.AccountInfo({\n                    owner: address(msg.sender),\n                    number: 1\n                }),\n                params\n            );\n        }\n\n        // Verifying that all funds were returned\n        // If Ether was sent into this function it shouldn't be counted against original balance\n        oldSelfBalance -= msg.value;\n        uint256 newSelfBalance = address(this).balance;\n        // Performing gas refunds\n        if ((flags & (FLAG_BURN_NATIVE | FLAG_BURN_GST2 | FLAG_BURN_CHI)) > 0) {\n            // No point in burning more than 256 tokens\n            uint32 tokensToBurn = uint32((flags / FLAG_GAS_TOKEN_BURN_AMOUNT_SHIFT) & 0xff);\n\n            Types.GasTokenPrices memory cachedBurnPrices;\n            if ((flags & FLAG_FREE_GAS_TOKEN) > 0) {\n                // Bot can enter hall of fame and get free gas tokens for life\n                require(bestApeOperators[msg.sender]);\n            } else {\n                // Otherwise price of these gas tokens would have to be deducted\n                cachedBurnPrices = gasTokenBurnPrices;\n            }\n\n            if (((flags & FLAG_BURN_NATIVE) > 0) && (cachedBankState.totalContractsCreated > cachedBankState.firstContractToDestroy + tokensToBurn)) {\n                _destroyContracts(cachedBankState.firstContractToDestroy, cachedBankState.firstContractToDestroy + tokensToBurn);\n                cachedBankState.firstContractToDestroy += tokensToBurn;\n                require(newSelfBalance > tokensToBurn * cachedBurnPrices.priceNative);\n                newSelfBalance -= tokensToBurn * cachedBurnPrices.priceNative;\n            } else if ((flags & FLAG_BURN_GST2) > 0) {\n                IGasToken(0x0000000000b3F879cb30FE243b4Dfee438691c04).free(tokensToBurn);\n                require(newSelfBalance > tokensToBurn * cachedBurnPrices.priceGST2);\n                newSelfBalance -= tokensToBurn * cachedBurnPrices.priceGST2;\n            } else if ((flags & FLAG_BURN_CHI) > 0) {\n                IGasToken(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c).free(tokensToBurn);\n                require(newSelfBalance > tokensToBurn * cachedBurnPrices.priceCHI);\n                newSelfBalance -= tokensToBurn * cachedBurnPrices.priceCHI;\n            }\n        }\n\n        if ((flags & (FLAG_BORROW_WETH | FLAG_COVER_WETH)) > 0) {\n            // We can combine ETH and WETH balances in this case\n            uint256 wethBalance = IERC20Token(TOKEN_WETH).balanceOf(address(this));\n            require(wethBalance < (2 ** 32) * TOKEN_WETH_MULTIPLIER && (newSelfBalance + wethBalance > oldSelfBalance + uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER));\n\n            if (wethBalance <= uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER) {\n                // User didn't return enough WETH covering via excess ETH\n                uint256 deltaToCover = uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER + 1 - wethBalance;\n                require(newSelfBalance >= oldSelfBalance + deltaToCover);\n\n                WETH9(TOKEN_WETH).deposit{value: deltaToCover}();\n                // newSelfBalance won't be used anywhere below\n                // WETH balance stays the same in the newState\n            } else if (newSelfBalance < oldSelfBalance) {\n                // User didn't return enough ETH covering via excess WETH\n                require(wethBalance > uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER + (oldSelfBalance - newSelfBalance));\n\n                WETH9(TOKEN_WETH).withdraw(oldSelfBalance - newSelfBalance);\n                // newSelfBalance won't be used anywhere below\n                cachedBankState.wethBalance = uint32((wethBalance - (oldSelfBalance - newSelfBalance)) / TOKEN_WETH_MULTIPLIER);\n            } else {\n                cachedBankState.wethBalance = uint32(wethBalance / TOKEN_WETH_MULTIPLIER);\n            }\n        } else {\n            require(newSelfBalance >= oldSelfBalance);\n        }\n\n        if ((flags & (FLAG_BORROW_WBTC | FLAG_BORROW_DAI | FLAG_BORROW_USDC | FLAG_BORROW_USDT)) > 0) {\n            if ((flags & FLAG_BORROW_WBTC) > 0) {\n                uint256 wbtcBalance = IERC20Token(TOKEN_WBTC).balanceOf(address(this));\n                // We use strict comparison here to make sure that token transfers always cost 5k gas and not (20k - 15k)\n                require(wbtcBalance < (2 ** 32) * TOKEN_WBTC_MULTIPLIER && wbtcBalance > uint256(cachedBankState.wbtcBalance) * TOKEN_WBTC_MULTIPLIER);\n                cachedBankState.wbtcBalance = uint32(wbtcBalance / TOKEN_WBTC_MULTIPLIER);\n            }\n            if ((flags & FLAG_BORROW_DAI) > 0) {\n                uint256 daiBalance = IERC20Token(TOKEN_DAI).balanceOf(address(this));\n                // We use strict comparison here to make sure that token transfers always cost 5k gas and not (20k - 15k)\n                require(daiBalance < (2 ** 32) * TOKEN_DAI_MULTIPLIER && daiBalance > uint256(cachedBankState.daiBalance) * TOKEN_DAI_MULTIPLIER);\n                cachedBankState.daiBalance = uint32(daiBalance / TOKEN_DAI_MULTIPLIER);\n            }\n            if ((flags & FLAG_BORROW_USDC) > 0) {\n                uint256 usdcBalance = IERC20Token(TOKEN_USDC).balanceOf(address(this));\n                // We use strict comparison here to make sure that token transfers always cost 5k gas and not (20k - 15k)\n                require(usdcBalance < (2 ** 32) * TOKEN_USDC_MULTIPLIER && usdcBalance > uint256(cachedBankState.usdcBalance) * TOKEN_USDC_MULTIPLIER);\n                cachedBankState.usdcBalance = uint32(usdcBalance / TOKEN_USDC_MULTIPLIER);\n            }\n            if ((flags & FLAG_BORROW_USDT) > 0) {\n                uint256 usdtBalance = IERC20Token(TOKEN_USDT).balanceOf(address(this));\n                // We use strict comparison here to make sure that token transfers always cost 5k gas and not (20k - 15k)\n                require(usdtBalance < (2 ** 32) * TOKEN_USDT_MULTIPLIER && usdtBalance > uint256(cachedBankState.usdtBalance) * TOKEN_USDT_MULTIPLIER);\n                cachedBankState.usdtBalance = uint32(usdtBalance / TOKEN_USDT_MULTIPLIER);\n            }\n        }\n\n        require(cachedBankState.numCalls == state.numCalls);\n        cachedBankState.numCalls += 1;\n        state = cachedBankState;\n    }\n\n    // Logic related to native gas refunds, it's very short but brainfuck level ugly\n    function generateContracts(uint256 amount) external {\n        Types.BankState memory cachedState = state;\n        uint256 offset = cachedState.totalContractsCreated;\n        assembly {\n            mstore(callvalue(), 0x766f454a11ca3a574738c0aab442b62d5d453318585733FF60005260176009f3)\n            for {let i := div(amount, 32)} i {i := sub(i, 1)} {\n                pop(create2(callvalue(), callvalue(), 32, offset))          pop(create2(callvalue(), callvalue(), 32, add(offset, 1)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 2)))  pop(create2(callvalue(), callvalue(), 32, add(offset, 3)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 4)))  pop(create2(callvalue(), callvalue(), 32, add(offset, 5)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 6)))  pop(create2(callvalue(), callvalue(), 32, add(offset, 7)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 8)))  pop(create2(callvalue(), callvalue(), 32, add(offset, 9)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 10))) pop(create2(callvalue(), callvalue(), 32, add(offset, 11)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 12))) pop(create2(callvalue(), callvalue(), 32, add(offset, 13)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 14))) pop(create2(callvalue(), callvalue(), 32, add(offset, 15)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 16))) pop(create2(callvalue(), callvalue(), 32, add(offset, 17)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 18))) pop(create2(callvalue(), callvalue(), 32, add(offset, 19)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 20))) pop(create2(callvalue(), callvalue(), 32, add(offset, 21)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 22))) pop(create2(callvalue(), callvalue(), 32, add(offset, 23)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 24))) pop(create2(callvalue(), callvalue(), 32, add(offset, 25)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 26))) pop(create2(callvalue(), callvalue(), 32, add(offset, 27)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 28))) pop(create2(callvalue(), callvalue(), 32, add(offset, 29)))\n                pop(create2(callvalue(), callvalue(), 32, add(offset, 30))) pop(create2(callvalue(), callvalue(), 32, add(offset, 31)))\n                offset := add(offset, 32)\n            }\n\n            for {let i := and(amount, 0x1F)} i {i := sub(i, 1)} {\n                pop(create2(callvalue(), callvalue(), 32, offset))\n                offset := add(offset, 1)\n            }\n        }\n\n        require(cachedState.numCalls == state.numCalls && offset < 2 ** 32);\n        cachedState.totalContractsCreated = uint32(offset);\n        cachedState.numCalls += 1;\n        state = cachedState;\n    }\n    function _destroyContracts(uint256 firstSlot, uint256 lastSlot) internal {\n        assembly {\n            let i := firstSlot\n\n            let data := mload(0x40)\n            mstore(data, 0xff00000000454a11ca3a574738c0aab442b62d5d450000000000000000000000)\n            mstore(add(data, 53), 0x51b94132314e7e963fa256338c05c5dd9c15d277c686d6750c3bc97835a1ed27)\n            let ptr := add(data, 21)\n            for { } lt(i, lastSlot) { i := add(i, 1) } {\n                mstore(ptr, i)\n                pop(call(gas(), keccak256(data, 85), 0, 0, 0, 0, 0))\n            }\n        }\n    }\n}\n\ninterface IApeBot {\n    function smallApeCallback(bytes calldata data) external payable;\n    function largeApeCallback(\n        address sender,\n        uint wethToReturn,\n        uint wbtcToReturn,\n        uint daiToReturn,\n        uint usdcToReturn,\n        uint usdtToReturn,\n        bytes calldata data\n    ) external payable;\n    function callFunction(address sender, Types.AccountInfo memory accountInfo, bytes memory data) external;\n}\n\nlibrary Types {\n    struct BankState {\n        uint32 wethBalance;\n        uint32 wbtcBalance;\n        uint32 daiBalance;\n        uint32 usdcBalance;\n        uint32 usdtBalance;\n        uint32 firstContractToDestroy;\n        uint32 totalContractsCreated;\n        uint32 numCalls;\n    }\n    struct GasTokenPrices {\n        uint80 priceGST2;\n        uint80 priceCHI;\n        uint80 priceNative;\n    }\n    struct AccountInfo {\n        address owner;\n        uint256 number;\n    }\n}\n\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\n// Only relevant calls in interfaces below\ninterface IERC20Token {\n    function balanceOf(address _owner) external view returns (uint256);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n}\ninterface WETH9 {\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n}\ninterface IGasToken {\n    function free(uint256 value) external returns (uint256);\n}"}}}