{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"HEMP.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // 'MY HEMP' 'HEMP' Smart Contract\r\n    //\r\n    // Symbol      : HEMP\r\n    // Name        : MY HEMP\r\n    // Total supply: 100,000,000\r\n    // Decimals    : 8\r\n    //\r\n    // \r\n    //\r\n    // (c) HEMP Pty Ltd 2022. The MIT Licence.\r\n    // ----------------------------------------------------------------------------\r\n\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Safe maths\r\n    // ----------------------------------------------------------------------------\r\n    library SafeMath {\r\n        function add(uint a, uint b) internal pure returns (uint c) {\r\n            c = a + b;\r\n            require(c >= a);\r\n        }\r\n        function sub(uint a, uint b) internal pure returns (uint c) {\r\n            require(b <= a);\r\n            c = a - b;\r\n        }\r\n        function mul(uint a, uint b) internal pure returns (uint c) {\r\n            c = a * b;\r\n            require(a == 0 || c / a == b);\r\n        }\r\n        function div(uint a, uint b) internal pure returns (uint c) {\r\n            require(b > 0);\r\n            c = a / b;\r\n        }\r\n    }\r\n\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // ERC Token Standard #20 Interface\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n    // ----------------------------------------------------------------------------\r\n    contract ERC20Interface {\r\n        function totalSupply() public view returns (uint);\r\n        function balanceOf(address tokenOwner) public view returns (uint balance);\r\n        function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n        function transfer(address to, uint tokens) public returns (bool success);\r\n        function approve(address spender, uint tokens) public returns (bool success);\r\n        function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n        event Transfer(address indexed from, address indexed to, uint tokens);\r\n        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n        event Burn(address indexed from, uint256 value);\r\n    }\r\n\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Contract function to receive approval and execute function in one call\r\n    //\r\n    // Borrowed from MiniMeToken\r\n    // ----------------------------------------------------------------------------\r\n    contract ApproveAndCallFallBack {\r\n        function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n    }\r\n\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Owned contract\r\n    // ----------------------------------------------------------------------------\r\n    contract Owned {\r\n        address public owner;\r\n        address public newOwner;\r\n\r\n        event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n        constructor() public {\r\n            owner = msg.sender;\r\n        }\r\n\r\n        modifier onlyOwner {\r\n            require(msg.sender == owner);\r\n            _;\r\n        }\r\n\r\n        function transferOwnership(address _newOwner) public onlyOwner {\r\n            newOwner = _newOwner;\r\n        }\r\n        function acceptOwnership() public {\r\n            require(msg.sender == newOwner);\r\n            emit OwnershipTransferred(owner, newOwner);\r\n            owner = newOwner;\r\n            newOwner = address(0);\r\n        }\r\n    }\r\n\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // BEP20 Token, with the addition of symbol, name and decimals and a\r\n    // fixed supply\r\n    // ----------------------------------------------------------------------------\r\n    contract HEMP is ERC20Interface, Owned {\r\n        using SafeMath for uint;\r\n\r\n        string public symbol;\r\n        string public  name;\r\n        uint8 public decimals;\r\n        uint _totalSupply;\r\n\r\n        mapping(address => uint) balances;\r\n        mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n        // ------------------------------------------------------------------------\r\n        // Constructor\r\n        // ------------------------------------------------------------------------\r\n        constructor() public {\r\n            symbol = \"HEMP\";\r\n            name = \"MY HEMP\";\r\n            decimals = 8;\r\n            _totalSupply = 100000000 * 10**uint(decimals);\r\n            balances[owner] = _totalSupply;\r\n            emit Transfer(address(0), owner, _totalSupply);\r\n        }\r\n\r\n\r\n        // ------------------------------------------------------------------------\r\n        // Total supply\r\n        // ------------------------------------------------------------------------\r\n        function totalSupply() public view returns (uint) {\r\n            return _totalSupply.sub(balances[address(0)]);\r\n        }\r\n\r\n\r\n        // ------------------------------------------------------------------------\r\n        // Get the token balance for account `tokenOwner`\r\n        // ------------------------------------------------------------------------\r\n        function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n            return balances[tokenOwner];\r\n        }\r\n\r\n\r\n        // ------------------------------------------------------------------------\r\n        // Transfer the balance from token owner's account to `to` account\r\n        // - Owner's account must have sufficient balance to transfer\r\n        // - 0 value transfers are allowed\r\n        // ------------------------------------------------------------------------\r\n        function transfer(address to, uint tokens) public returns (bool success) {\r\n            balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n            balances[to] = balances[to].add(tokens);\r\n            emit Transfer(msg.sender, to, tokens);\r\n            return true;\r\n        }\r\n\r\n\r\n        // ------------------------------------------------------------------------\r\n        // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n        // from the token owner's account\r\n        //\r\n        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n        // recommends that there are no checks for the approval double-spend attack\r\n        // as this should be implemented in user interfaces\r\n        // ------------------------------------------------------------------------\r\n        function approve(address spender, uint tokens) public returns (bool success) {\r\n            allowed[msg.sender][spender] = tokens;\r\n            emit Approval(msg.sender, spender, tokens);\r\n            return true;\r\n        }\r\n\r\n\r\n        // ------------------------------------------------------------------------\r\n        // Transfer `tokens` from the `from` account to the `to` account\r\n        //\r\n        // The calling account must already have sufficient tokens approve(...)-d\r\n        // for spending from the `from` account and\r\n        // - From account must have sufficient balance to transfer\r\n        // - Spender must have sufficient allowance to transfer\r\n        // - 0 value transfers are allowed\r\n        // ------------------------------------------------------------------------\r\n        function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n            balances[from] = balances[from].sub(tokens);\r\n            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n            balances[to] = balances[to].add(tokens);\r\n            emit Transfer(from, to, tokens);\r\n            return true;\r\n        }\r\n\r\n\r\n        // ------------------------------------------------------------------------\r\n        // Returns the amount of tokens approved by the owner that can be\r\n        // transferred to the spender's account\r\n        // ------------------------------------------------------------------------\r\n        function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\n            return allowed[tokenOwner][spender];\r\n        }\r\n\r\n\r\n        // ------------------------------------------------------------------------\r\n        // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n        // from the token owner's account. The `spender` contract function\r\n        // `receiveApproval(...)` is then executed\r\n        // ------------------------------------------------------------------------\r\n        function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\r\n            allowed[msg.sender][spender] = tokens;\r\n            emit Approval(msg.sender, spender, tokens);\r\n            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n            return true;\r\n        }\r\n\r\n\r\n        // ------------------------------------------------------------------------\r\n        // Owner can transfer out any accidentally sent ERC20 tokens\r\n        // ------------------------------------------------------------------------\r\n        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n            return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n        }\r\n        /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n        function burn(uint256 _value) public returns (bool success) {\r\n            require(balances[msg.sender] >= _value);   // Check if the sender has enough\r\n            balances[msg.sender] -= _value;            // Subtract from the sender\r\n            _totalSupply -= _value;                      // Updates totalSupply\r\n            emit Burn(msg.sender, _value);\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * Destroy tokens from other account\r\n         *\r\n         * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n         *\r\n         * @param _from the address of the sender\r\n         * @param _value the amount of money to burn\r\n         */\r\n        function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n            require(balances[_from] >= _value);                // Check if the targeted balance is enough\r\n            require(_value <= allowed[_from][msg.sender]);    // Check allowance\r\n            balances[_from] -= _value;                         // Subtract from the targeted balance\r\n            allowed[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n            _totalSupply -= _value;                              // Update totalSupply\r\n            emit Burn(_from, _value);\r\n            return true;\r\n        }\r\n    }"}}}