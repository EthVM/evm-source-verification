{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Neuy.sol":{"content":"pragma solidity >=0.7.0 <=0.8.4;\n// PoC Proof of Contribution\n// SPDX-License-Identifier: Unlicensed\ncontract Neuy {\n    string public name = \"NEUY\";\n    string public symbol = \"NEUY\";\n    string public standard = \"NEUY Token v1.0\";\n    uint256 public totalSupply = 72000000 * 10 ** 18;\n    uint public decimals = 18;\n    address payable public owner;\n    address payable public buOwner;\n    address payable public airdropOwner;\n    uint256 public minContributorBalance = 0;\n    string private rewardKeyId;\n    bool public pullEnabled = false;\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner || msg.sender == buOwner);\n        _;\n    }\n    \n    modifier allOwners() {\n        require(msg.sender == owner || msg.sender == buOwner || msg.sender == airdropOwner);\n        _;\n    }\n    \n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 _value\n    );\n\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n    \n    // event for EVM logging\n    event OwnerSet(\n        address indexed oldOwner, \n        address indexed newOwner\n    );\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => string) private claimedRewards;\n    mapping(address => bool) private contributors;\n    mapping(address => string) private contributorsAddresses;\n    \n    constructor(address _buOwner) {\n        balanceOf[msg.sender] = 36000000 * 10 ** 18;\n        balanceOf[_buOwner] = 36000000 * 10 ** 18;\n        buOwner = payable(_buOwner);\n        owner = payable(msg.sender);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        \n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != address(0x0));\n        \n        // Check for sufficent funds\n        require(balanceOf[msg.sender] >= _value, 'insufficent tokens');\n        \n        // Check for overflows\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        \n        // Transfer\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowance[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        \n        // Sufficent funds\n        require(_value <= balanceOf[_from]);\n        \n        // Sufficent allowance\n        require(_value <= allowance[_from][msg.sender]);\n\n        // Transfer\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n\n        allowance[_from][msg.sender] -= _value;\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n    \n    // Change owner\n    function changeOwner(address newOwner) public onlyOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = payable(newOwner);\n    }\n    \n    // Change backup owner\n    function changeBUOwner(address _buOwner) public onlyOwner {\n        require(_buOwner != address(0x0));\n        buOwner = payable(_buOwner);\n    }\n    \n    // Change airdrop owner\n    function changeAirDropOwner(address _airdropOwner) public onlyOwner {\n        require(_airdropOwner != address(0x0));\n        airdropOwner = payable(_airdropOwner);\n    }\n    \n    // Owner destories contract\n    function finalize() public onlyOwner payable {\n        selfdestruct(owner);\n    }\n    \n    // Add contributors\n    function addContributor(address _add, string memory _addS) public onlyOwner {\n        contributors[_add] = true;\n        contributorsAddresses[_add] = _addS;\n    }\n    \n    // Remove contributors\n    function removeContributor(address _add) public onlyOwner {\n        contributors[_add] = false;\n    }\n    \n    // Change minimum balance required by contributors\n    function changeMinBalance(uint256 _newMin) public onlyOwner {\n        minContributorBalance = _newMin * 10 ** 18;\n    }\n    \n    // Airdropping to contributors\n    function contributionAirDrop(address[] memory _to_list, uint[] memory _values) public allOwners payable {\n        require(_to_list.length < 100);\n        require(_to_list.length == _values.length); \n        \n        //Validate reward limit of 2000 * 100\n        uint totalReward = 0;\n        for (uint i = 0; i < _to_list.length; i++) {\n            totalReward += _values[i];\n        }\n        require(totalReward < 200001);\n        \n        for (uint i = 0; i < _to_list.length; i++) {\n            if (balanceOf[_to_list[i]] >= minContributorBalance) {\n                mintToken(_to_list[i], _values[i]);\n            }\n        }\n    }\n    \n    // Private method shared by `contributionAirDrop()`.\n    function mintToken(address _to, uint _value) private {\n        require(_value < 66800); // No single contributor should be able to get more than\n        balanceOf[_to] += _value * 10 ** 16;\n        totalSupply += _value * 10 ** 16;\n        require(totalSupply < 144000000 * 10 ** 18);\n        require(balanceOf[_to] >= _value && totalSupply >= _value); // overflow checks\n        emit Transfer(address(0), _to, _value);\n    }\n    \n    // Set reward key and enable pull\n    function setRewardKey(string memory _rewardId) public onlyOwner {\n        pullEnabled = true;\n        rewardKeyId = _rewardId;\n    }\n    \n    // Change status of pull\n    function setPullStatus(bool _pullStatus) public onlyOwner {\n        pullEnabled = _pullStatus;\n    }\n\n    // Pull contribution reward\n    function claimContributionReward(bytes32 _rewardHash, uint _value) public payable {\n        \n        // Pull reward system must be pullEnabled\n        require(pullEnabled == true);\n        \n        // Verify not already claimed\n        string memory previousRewardId = claimedRewards[msg.sender];\n        string memory presentRewardId = rewardKeyId;\n        require(sha256(abi.encodePacked(previousRewardId)) != sha256(abi.encodePacked(rewardKeyId)));\n        \n        // Contributor hash validation\n        require(_rewardHash == keccak256(abi.encodePacked(rewardKeyId,uintToString(_value),contributorsAddresses[address(msg.sender)])));\n        \n        // Verify authorized contributor\n        require(contributors[msg.sender] == true);    \n\n        // Min contributor balance\n        require(balanceOf[msg.sender] >= minContributorBalance); \n        mintToken(msg.sender, _value);\n        claimedRewards[msg.sender] = presentRewardId;\n    }\n    \n    // Helper method to convert uint To string\n    function uintToString(uint _v) internal pure returns (string memory) {\n        uint maxlength = 100;\n        bytes memory reversed = new bytes(maxlength);\n        uint i = 0;\n        while (_v != 0) {\n            uint remainder = _v % 10;\n            _v = _v / 10;\n            reversed[i++] = bytes1(uint8(48 + remainder));\n        }\n        bytes memory s = new bytes(i); // i + 1 is inefficient\n        for (uint j = 0; j < i; j++) {\n            s[j] = reversed[i - j - 1]; // to avoid the off-by-one error\n        }\n        string memory str = string(s);  // memory isn't implicitly convertible to storage\n        return str;\n    }\n}\n"}}}