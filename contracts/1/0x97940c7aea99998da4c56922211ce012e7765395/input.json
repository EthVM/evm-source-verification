{"language":"Solidity","sources":{"MapleLoan.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity =0.8.7;\n\ninterface IERC20Like {\n\n    function approve(address spender_, uint256 amount_) external returns (bool success_);\n\n    function balanceOf(address account_) external view returns (uint256 balance_);\n\n    function transfer(address recipient_, uint256 amount_) external returns (bool success_);\n\n    function transferFrom(address owner_, address recipient_, uint256 amount_) external returns (bool success_);\n\n}\n\ninterface ILenderLike {\n\n    function poolDelegate() external view returns (address poolDelegate_);\n\n}\n\ninterface IMapleGlobalsLike {\n\n    function investorFee() external view returns (uint256 investorFee_);\n\n    function mapleTreasury() external view returns (address mapleTreasury_);\n\n    function protocolPaused() external view returns (bool paused_);\n\n    function treasuryFee() external view returns (uint256 treasuryFee_);\n\n}\n\ninterface IMapleProxyFactoryLike {\n\n    function mapleGlobals() external view returns (address mapleGlobals_);\n\n    function upgradeInstance(uint256 toVersion_, bytes calldata arguments_) external;\n\n}\n\n/// @title Small Library to standardize erc20 token interactions.\nlibrary ERC20Helper {\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    function transfer(address token_, address to_, uint256 amount_) internal returns (bool success_) {\n        return _call(token_, abi.encodeWithSelector(IERC20Like.transfer.selector, to_, amount_));\n    }\n\n    function transferFrom(address token_, address from_, address to_, uint256 amount_) internal returns (bool success_) {\n        return _call(token_, abi.encodeWithSelector(IERC20Like.transferFrom.selector, from_, to_, amount_));\n    }\n\n    function approve(address token_, address spender_, uint256 amount_) internal returns (bool success_) {\n        // If setting approval to zero fails, return false.\n        if (!_call(token_, abi.encodeWithSelector(IERC20Like.approve.selector, spender_, uint256(0)))) return false;\n\n        // If `amount_` is zero, return true as the previous step already did this.\n        if (amount_ == uint256(0)) return true;\n\n        // Return the result of setting the approval to `amount_`.\n        return _call(token_, abi.encodeWithSelector(IERC20Like.approve.selector, spender_, amount_));\n    }\n\n    function _call(address token_, bytes memory data_) private returns (bool success_) {\n        if (token_.code.length == uint256(0)) return false;\n\n        bytes memory returnData;\n        ( success_, returnData ) = token_.call(data_);\n\n        return success_ && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n}\n\n/// @title An implementation that is to be proxied, must implement IProxied.\ninterface IProxied {\n\n    /**\n     *  @dev The address of the proxy factory.\n     */\n    function factory() external view returns (address factory_);\n\n    /**\n     *  @dev The address of the implementation contract being proxied.\n     */\n    function implementation() external view returns (address implementation_);\n\n    /**\n     *  @dev   Modifies the proxy's implementation address.\n     *  @param newImplementation_ The address of an implementation contract.\n     */\n    function setImplementation(address newImplementation_) external;\n\n    /**\n     *  @dev   Modifies the proxy's storage by delegate-calling a migrator contract with some arguments.\n     *         Access control logic critical since caller can force a selfdestruct via a malicious `migrator_` which is delegatecalled.\n     *  @param migrator_  The address of a migrator contract.\n     *  @param arguments_ Some encoded arguments to use for the migration.\n     */\n    function migrate(address migrator_, bytes calldata arguments_) external;\n\n}\n\n/// @title A Maple implementation that is to be proxied, must implement IMapleProxied.\ninterface IMapleProxied is IProxied {\n\n    /**\n     *  @dev   The instance was upgraded.\n     *  @param toVersion_ The new version of the loan.\n     *  @param arguments_ The upgrade arguments, if any.\n     */\n    event Upgraded(uint256 toVersion_, bytes arguments_);\n\n    /**\n     *  @dev   Upgrades a contract implementation to a specific version.\n     *         Access control logic critical since caller can force a selfdestruct via a malicious `migrator_` which is delegatecalled.\n     *  @param toVersion_ The version to upgrade to.\n     *  @param arguments_ Some encoded arguments to use for the upgrade.\n     */\n    function upgrade(uint256 toVersion_, bytes calldata arguments_) external;\n\n}\n\n/// @title IMapleLoanEvents defines the events for a MapleLoan.\ninterface IMapleLoanEvents {\n\n    /**\n     *  @dev   Borrower was accepted, and set to a new account.\n     *  @param borrower_ The address of the new borrower.\n     */\n    event BorrowerAccepted(address indexed borrower_);\n\n    /**\n     *  @dev   Collateral was posted.\n     *  @param amount_ The amount of collateral posted.\n     */\n    event CollateralPosted(uint256 amount_);\n\n    /**\n     *  @dev   Collateral was removed.\n     *  @param amount_      The amount of collateral removed.\n     *  @param destination_ The recipient of the collateral removed.\n     */\n    event CollateralRemoved(uint256 amount_, address indexed destination_);\n\n    /**\n     *  @dev   The loan was funded.\n     *  @param lender_             The address of the lender.\n     *  @param amount_             The amount funded.\n     *  @param nextPaymentDueDate_ The due date of the next payment.\n     */\n    event Funded(address indexed lender_, uint256 amount_, uint256 nextPaymentDueDate_);\n\n    /**\n     *  @dev   Funds were claimed.\n     *  @param amount_      The amount of funds claimed.\n     *  @param destination_ The recipient of the funds claimed.\n     */\n    event FundsClaimed(uint256 amount_, address indexed destination_);\n\n    /**\n     *  @dev   Funds were drawn.\n     *  @param amount_      The amount of funds drawn.\n     *  @param destination_ The recipient of the funds drawn down.\n     */\n    event FundsDrawnDown(uint256 amount_, address indexed destination_);\n\n    /**\n     *  @dev   Funds were redirected on an additional `fundLoan` call.\n     *  @param amount_      The amount of funds redirected.\n     *  @param destination_ The recipient of the redirected funds.\n     */\n    event FundsRedirected(uint256 amount_, address indexed destination_);\n\n    /**\n     *  @dev   Funds were returned.\n     *  @param amount_ The amount of funds returned.\n     */\n    event FundsReturned(uint256 amount_);\n\n    /**\n     *  @dev   The loan was initialized.\n     *  @param borrower_    The address of the borrower.\n     *  @param assets_      Array of asset addresses.\n     *                          [0]: collateralAsset,\n     *                          [1]: fundsAsset.\n     *  @param termDetails_ Array of loan parameters:\n     *                          [0]: gracePeriod,\n     *                          [1]: paymentInterval,\n     *                          [2]: payments,\n     *  @param amounts_     Requested amounts:\n     *                          [0]: collateralRequired,\n     *                          [1]: principalRequested,\n     *                          [2]: endingPrincipal.\n     *  @param rates_       Fee parameters:\n     *                          [0]: interestRate,\n     *                          [1]: earlyFeeRate,\n     *                          [2]: lateFeeRate,\n     *                          [3]: lateInterestPremium.\n     */\n    event Initialized(address indexed borrower_, address[2] assets_, uint256[3] termDetails_, uint256[3] amounts_, uint256[4] rates_);\n\n    /**\n     *  @dev   Lender was accepted, and set to a new account.\n     *  @param lender_ The address of the new lender.\n     */\n    event LenderAccepted(address indexed lender_);\n\n    /**\n     *  @dev   Loan was repaid early and closed.\n     *  @param principalPaid_ The portion of the total amount that went towards principal.\n     *  @param interestPaid_  The portion of the total amount that went towards interest fees.\n     */\n    event LoanClosed(uint256 principalPaid_, uint256 interestPaid_);\n\n    /**\n     *  @dev   A refinance was proposed.\n     *  @param refinanceCommitment_ The hash of the refinancer and calls proposed.\n     *  @param refinancer_          The address that will execute the refinance.\n     *  @param calls_               The individual calls for the refinancer contract.\n     */\n    event NewTermsAccepted(bytes32 refinanceCommitment_, address refinancer_, bytes[] calls_);\n\n    /**\n     *  @dev   A refinance was proposed.\n     *  @param refinanceCommitment_ The hash of the refinancer and calls proposed.\n     *  @param refinancer_          The address that will execute the refinance.\n     *  @param calls_               The individual calls for the refinancer contract.\n     */\n    event NewTermsProposed(bytes32 refinanceCommitment_, address refinancer_, bytes[] calls_);\n\n    /**\n     *  @dev   Payments were made.\n     *  @param principalPaid_ The portion of the total amount that went towards principal.\n     *  @param interestPaid_  The portion of the total amount that went towards interest fees.\n     */\n    event PaymentMade(uint256 principalPaid_, uint256 interestPaid_);\n\n    /**\n     *  @dev   Pending borrower was set.\n     *  @param pendingBorrower_ Address that can accept the borrower role.\n     */\n    event PendingBorrowerSet(address pendingBorrower_);\n\n    /**\n     *  @dev   Pending lender was set.\n     *  @param pendingLender_ Address that can accept the lender role.\n     */\n    event PendingLenderSet(address pendingLender_);\n\n    /**\n     *  @dev   The loan was in default and funds and collateral was repossessed by the lender.\n     *  @param collateralRepossessed_ The amount of collateral asset repossessed.\n     *  @param fundsRepossessed_      The amount of funds asset repossessed.\n     *  @param destination_           The recipient of the collateral and funds, if any.\n     */\n    event Repossessed(uint256 collateralRepossessed_, uint256 fundsRepossessed_, address indexed destination_);\n\n    /**\n     *  @dev   Some token (neither fundsAsset nor collateralAsset) was removed from the loan.\n     *  @param token_       The address of the token contract.\n     *  @param amount_      The amount of token remove from the loan.\n     *  @param destination_ The recipient of the token.\n     */\n    event Skimmed(address indexed token_, uint256 amount_, address indexed destination_);\n\n}\n\n/// @title MapleLoan implements a primitive loan with additional functionality, and is intended to be proxied.\ninterface IMapleLoan is IMapleProxied, IMapleLoanEvents {\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     *  @dev The borrower of the loan, responsible for repayments.\n     */\n    function borrower() external view returns (address borrower_);\n\n    /**\n     *  @dev The amount of funds that have yet to be claimed by the lender.\n     */\n    function claimableFunds() external view returns (uint256 claimableFunds_);\n\n    /**\n     *  @dev The amount of collateral posted against outstanding (drawn down) principal.\n     */\n    function collateral() external view returns (uint256 collateral_);\n\n    /**\n     *  @dev The address of the asset deposited by the borrower as collateral, if needed.\n     */\n    function collateralAsset() external view returns (address collateralAsset_);\n\n    /**\n     *  @dev The amount of collateral required if all of the principal required is drawn down.\n     */\n    function collateralRequired() external view returns (uint256 collateralRequired_);\n\n    /**\n     *  @dev The amount of funds that have yet to be drawn down by the borrower.\n     */\n    function drawableFunds() external view returns (uint256 drawableFunds_);\n\n    /**\n     *  @dev The rate charged at early payments.\n     *       This value should be configured so that it is less expensive to close a loan with more than one payment remaining, but\n     *       more expensive to close it if on the last payment.\n     */\n    function earlyFeeRate() external view returns (uint256 earlyFeeRate_);\n\n    /**\n     *  @dev The portion of principal to not be paid down as part of payment installments, which would need to be paid back upon final payment.\n     *       If endingPrincipal = principal, loan is interest-only.\n     */\n    function endingPrincipal() external view returns (uint256 endingPrincipal_);\n\n    /**\n     *  @dev The asset deposited by the lender to fund the loan.\n     */\n    function fundsAsset() external view returns (address fundsAsset_);\n\n    /**\n     *  @dev The amount of time the borrower has, after a payment is due, to make a payment before being in default.\n     */\n    function gracePeriod() external view returns (uint256 gracePeriod_);\n\n    /**\n     *  @dev The annualized interest rate (APR), in units of 1e18, (i.e. 1% is 0.01e18).\n     */\n    function interestRate() external view returns (uint256 interestRate_);\n\n    /**\n     *  @dev The rate charged at late payments.\n     */\n    function lateFeeRate() external view returns (uint256 lateFeeRate_);\n\n    /**\n     *  @dev The premium over the regular interest rate applied when paying late.\n     */\n    function lateInterestPremium() external view returns (uint256 lateInterestPremium_);\n\n    /**\n     *  @dev The lender of the Loan.\n     */\n    function lender() external view returns (address lender_);\n\n    /**\n     *  @dev The timestamp due date of the next payment.\n     */\n    function nextPaymentDueDate() external view returns (uint256 nextPaymentDueDate_);\n\n    /**\n     *  @dev The specified time between loan payments.\n     */\n    function paymentInterval() external view returns (uint256 paymentInterval_);\n\n    /**\n     *  @dev The number of payment installments remaining for the loan.\n     */\n    function paymentsRemaining() external view returns (uint256 paymentsRemaining_);\n\n    /**\n     *  @dev The address of the pending borrower.\n     */\n    function pendingBorrower() external view returns (address pendingBorrower_);\n\n    /**\n     *  @dev The address of the pending lender.\n     */\n    function pendingLender() external view returns (address pendingLender_);\n\n    /**\n     *  @dev The amount of principal owed (initially, the requested amount), which needs to be paid back.\n     */\n    function principal() external view returns (uint256 principal_);\n\n    /**\n     *  @dev The initial principal amount requested by the borrower.\n     */\n    function principalRequested() external view returns (uint256 principalRequested_);\n\n    /**\n     *  @dev The factory address that deployed this contract (necessary for PoolV1 integration).\n     */\n    function superFactory() external view returns (address superFactory_);\n\n    /********************************/\n    /*** State Changing Functions ***/\n    /********************************/\n\n    /**\n     *  @dev Accept the borrower role, must be called by pendingBorrower.\n     */\n    function acceptBorrower() external;\n\n    /**\n     *  @dev Accept the lender role, must be called by pendingLender.\n     */\n    function acceptLender() external;\n\n    /**\n     *  @dev   Accept the proposed terms ans trigger refinance execution\n     *  @param refinancer_ The address of the refinancer contract.\n     *  @param calls_      The encoded arguments to be passed to refinancer.\n     *  @param amount_     An amount to pull from the caller, if any.\n     */\n    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external;\n\n    /**\n     *  @dev   Claim funds that have been paid (principal, interest, and late fees).\n     *  @param amount_      The amount to be claimed.\n     *  @param destination_ The address to send the funds.\n     */\n    function claimFunds(uint256 amount_, address destination_) external;\n\n    /**\n     *  @dev    Repay all principal and fees and close a loan.\n     *  @param  amount_    An amount to pull from the caller, if any.\n     *  @return principal_ The portion of the amount paid paying back principal.\n     *  @return interest_  The portion of the amount paid paying interest fees.\n     */\n    function closeLoan(uint256 amount_) external returns (uint256 principal_, uint256 interest_);\n\n    /**\n     *  @dev    Draw down funds from the loan.\n     *  @param  amount_           The amount to draw down.\n     *  @param  destination_      The address to send the funds.\n     *  @return collateralPosted_ The amount of additional collateral posted, if any.\n     */\n    function drawdownFunds(uint256 amount_, address destination_) external returns (uint256 collateralPosted_);\n\n    /**\n     *  @dev    Lend funds to the loan/borrower.\n     *  @param  lender_    The address to be registered as the lender.\n     *  @param  amount_    An amount to pull from the caller, if any.\n     *  @return fundsLent_ The amount funded.\n     */\n    function fundLoan(address lender_, uint256 amount_) external returns (uint256 fundsLent_);\n\n    /**\n     *  @dev    Make a payment to the loan.\n     *  @param  amount_    An amount to pull from the caller, if any.\n     *  @return principal_ The portion of the amount paid paying back principal.\n     *  @return interest_  The portion of the amount paid paying interest fees.\n     */\n    function makePayment(uint256 amount_) external returns (uint256 principal_, uint256 interest_);\n\n    /**\n     *  @dev    Post collateral to the loan.\n     *  @param  amount_           An amount to pull from the caller, if any.\n     *  @return collateralPosted_ The amount posted.\n     */\n    function postCollateral(uint256 amount_) external returns (uint256 collateralPosted_);\n\n    /**\n     *  @dev   Propose new terms for refinance\n     *  @param refinancer_ The address of the refinancer contract.\n     *  @param calls_      The encoded arguments to be passed to refinancer.\n     */\n    function proposeNewTerms(address refinancer_, bytes[] calldata calls_) external;\n\n    /**\n     *  @dev   Remove collateral from the loan (opposite of posting collateral).\n     *  @param amount_      The amount removed.\n     *  @param destination_ The destination to send the removed collateral.\n     */\n    function removeCollateral(uint256 amount_, address destination_) external;\n\n    /**\n     *  @dev    Return funds to the loan (opposite of drawing down).\n     *  @param  amount_        An amount to pull from the caller, if any.\n     *  @return fundsReturned_ The amount returned.\n     */\n    function returnFunds(uint256 amount_) external returns (uint256 fundsReturned_);\n\n    /**\n     *  @dev    Repossess collateral, and any funds, for a loan in default.\n     *  @param  destination_           The address where the collateral and funds asset is to be sent, if any.\n     *  @return collateralRepossessed_ The amount of collateral asset repossessed.\n     *  @return fundsRepossessed_      The amount of funds asset repossessed.\n     */\n    function repossess(address destination_) external returns (uint256 collateralRepossessed_, uint256 fundsRepossessed_);\n\n    /**\n     *  @dev   Set the pendingBorrower to a new account.\n     *  @param pendingBorrower_ The address of the new pendingBorrower.\n     */\n    function setPendingBorrower(address pendingBorrower_) external;\n\n    /**\n     *  @dev   Set the pendingLender to a new account.\n     *  @param pendingLender_ The address of the new pendingLender.\n     */\n    function setPendingLender(address pendingLender_) external;\n\n    /**\n     *  @dev    Remove some token (neither fundsAsset nor collateralAsset) from the loan.\n     *  @param  token_       The address of the token contract.\n     *  @param  destination_ The recipient of the token.\n     *  @return skimmed_     The amount of token removed from the loan.\n     */\n    function skim(address token_, address destination_) external returns (uint256 skimmed_);\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /**\n     *  @dev    Returns the excess collateral that can be removed.\n     *  @return excessCollateral_ The excess collateral that can be removed, if any.\n     */\n    function excessCollateral() external view returns (uint256 excessCollateral_);\n\n    /**\n     *  @dev    Get the additional collateral to be posted to drawdown some amount.\n     *  @param  drawdown_             The amount desired to be drawn down.\n     *  @return additionalCollateral_ The additional collateral that must be posted, if any.\n     */\n    function getAdditionalCollateralRequiredFor(uint256 drawdown_) external view returns (uint256 additionalCollateral_);\n\n    /**\n     *  @dev    Get the breakdown of the total payment needed to satisfy an early repayment.\n     *  @return totalPrincipalAmount_ The portion of the total amount that will go towards principal.\n     *  @return totalInterestFees_    The portion of the total amount that will go towards interest fees.\n     */\n    function getEarlyPaymentBreakdown() external view returns (\n        uint256 totalPrincipalAmount_,\n        uint256 totalInterestFees_\n    );\n\n    /**\n     *  @dev    Get the breakdown of the total payment needed to satisfy `numberOfPayments` payment installments.\n     *  @return totalPrincipalAmount_ The portion of the total amount that will go towards principal.\n     *  @return totalInterestFees_    The portion of the total amount that will go towards interest fees.\n     */\n    function getNextPaymentBreakdown() external view returns (\n        uint256 totalPrincipalAmount_,\n        uint256 totalInterestFees_\n    );\n\n    /**\n     *  @dev    Returns whether the protocol is paused.\n     *  @return paused_ A boolean indicating if protocol is paused.\n     */\n    function isProtocolPaused() external view returns (bool paused_);\n\n}\n\nabstract contract SlotManipulatable {\n\n    function _getReferenceTypeSlot(bytes32 slot_, bytes32 key_) internal pure returns (bytes32 value_) {\n        return keccak256(abi.encodePacked(key_, slot_));\n    }\n\n    function _getSlotValue(bytes32 slot_) internal view returns (bytes32 value_) {\n        assembly {\n            value_ := sload(slot_)\n        }\n    }\n\n    function _setSlotValue(bytes32 slot_, bytes32 value_) internal {\n        assembly {\n            sstore(slot_, value_)\n        }\n    }\n\n}\n\n/// @title An implementation that is to be proxied, will need ProxiedInternals.\nabstract contract ProxiedInternals is SlotManipulatable {\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.factory') - 1`.\n    bytes32 private constant FACTORY_SLOT = bytes32(0x7a45a402e4cb6e08ebc196f20f66d5d30e67285a2a8aa80503fa409e727a4af1);\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 private constant IMPLEMENTATION_SLOT = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    /// @dev Delegatecalls to a migrator contract to manipulate storage during an initialization or migration.\n    function _migrate(address migrator_, bytes calldata arguments_) internal virtual returns (bool success_) {\n        uint256 size;\n\n        assembly {\n            size := extcodesize(migrator_)\n        }\n\n        if (size == uint256(0)) return false;\n\n        ( success_, ) = migrator_.delegatecall(arguments_);\n    }\n\n    /// @dev Sets the factory address in storage.\n    function _setFactory(address factory_) internal virtual returns (bool success_) {\n        _setSlotValue(FACTORY_SLOT, bytes32(uint256(uint160(factory_))));\n        return true;\n    }\n\n    /// @dev Sets the implementation address in storage.\n    function _setImplementation(address implementation_) internal virtual returns (bool success_) {\n        _setSlotValue(IMPLEMENTATION_SLOT, bytes32(uint256(uint160(implementation_))));\n        return true;\n    }\n\n    /// @dev Returns the factory address.\n    function _factory() internal view virtual returns (address factory_) {\n        return address(uint160(uint256(_getSlotValue(FACTORY_SLOT))));\n    }\n\n    /// @dev Returns the implementation address.\n    function _implementation() internal view virtual returns (address implementation_) {\n        return address(uint160(uint256(_getSlotValue(IMPLEMENTATION_SLOT))));\n    }\n\n}\n\n/// @title A Maple implementation that is to be proxied, will need MapleProxiedInternals.\nabstract contract MapleProxiedInternals is ProxiedInternals {}\n\n/// @title MapleLoanInternals defines the storage layout and internal logic of MapleLoan.\nabstract contract MapleLoanInternals is MapleProxiedInternals {\n\n    uint256 private constant SCALED_ONE = uint256(10 ** 18);\n\n    // Roles\n    address internal _borrower;         // The address of the borrower.\n    address internal _lender;           // The address of the lender.\n    address internal _pendingBorrower;  // The address of the pendingBorrower, the only address that can accept the borrower role.\n    address internal _pendingLender;    // The address of the pendingLender, the only address that can accept the lender role.\n\n    // Assets\n    address internal _collateralAsset;  // The address of the asset used as collateral.\n    address internal _fundsAsset;       // The address of the asset used as funds.\n\n    // Loan Term Parameters\n    uint256 internal _gracePeriod;      // The number of seconds a payment can be late.\n    uint256 internal _paymentInterval;  // The number of seconds between payments.\n\n    // Rates\n    uint256 internal _interestRate;         // The annualized interest rate of the loan.\n    uint256 internal _earlyFeeRate;         // The fee rate for prematurely closing loans.\n    uint256 internal _lateFeeRate;          // The fee rate for late payments.\n    uint256 internal _lateInterestPremium;  // The amount to increase the interest rate by for late payments.\n\n    // Requested Amounts\n    uint256 internal _collateralRequired;  // The collateral the borrower is expected to put up to draw down all _principalRequested.\n    uint256 internal _principalRequested;  // The funds the borrowers wants to borrow.\n    uint256 internal _endingPrincipal;     // The principal to remain at end of loan.\n\n    // State\n    uint256 internal _drawableFunds;       // The amount of funds that can be drawn down.\n    uint256 internal _claimableFunds;      // The amount of funds that the lender can claim (principal repayments, interest, etc).\n    uint256 internal _collateral;          // The amount of collateral, in collateral asset, that is currently posted.\n    uint256 internal _nextPaymentDueDate;  // The timestamp of due date of next payment.\n    uint256 internal _paymentsRemaining;   // The number of payments remaining.\n    uint256 internal _principal;           // The amount of principal yet to be paid down.\n\n    // Refinance\n    bytes32 internal _refinanceCommitment;\n\n    /**********************************/\n    /*** Internal General Functions ***/\n    /**********************************/\n\n    /// @dev Clears all state variables to end a loan, but keep borrower and lender withdrawal functionality intact.\n    function _clearLoanAccounting() internal {\n        _gracePeriod     = uint256(0);\n        _paymentInterval = uint256(0);\n\n        _interestRate        = uint256(0);\n        _earlyFeeRate        = uint256(0);\n        _lateFeeRate         = uint256(0);\n        _lateInterestPremium = uint256(0);\n\n        _endingPrincipal = uint256(0);\n\n        _nextPaymentDueDate = uint256(0);\n        _paymentsRemaining  = uint256(0);\n        _principal          = uint256(0);\n    }\n\n    /**\n     *  @dev   Initializes the loan.\n     *  @param borrower_    The address of the borrower.\n     *  @param assets_      Array of asset addresses.\n     *                          [0]: collateralAsset,\n     *                          [1]: fundsAsset.\n     *  @param termDetails_ Array of loan parameters:\n     *                          [0]: gracePeriod,\n     *                          [1]: paymentInterval,\n     *                          [2]: payments,\n     *  @param amounts_     Requested amounts:\n     *                          [0]: collateralRequired,\n     *                          [1]: principalRequested,\n     *                          [2]: endingPrincipal.\n     *  @param rates_       Fee parameters:\n     *                          [0]: interestRate,\n     *                          [1]: earlyFeeRate,\n     *                          [2]: lateFeeRate,\n     *                          [3]: lateInterestPremium.\n     */\n    function _initialize(\n        address borrower_,\n        address[2] memory assets_,\n        uint256[3] memory termDetails_,\n        uint256[3] memory amounts_,\n        uint256[4] memory rates_\n    )\n        internal\n    {\n        // Principal requested needs to be non-zero (see `_getCollateralRequiredFor` math).\n        require(amounts_[1] > uint256(0), \"MLI:I:INVALID_PRINCIPAL\");\n\n        // Ending principal needs to be less than or equal to principal requested.\n        require(amounts_[2] <= amounts_[1], \"MLI:I:INVALID_ENDING_PRINCIPAL\");\n\n        require((_borrower = borrower_) != address(0), \"MLI:I:INVALID_BORROWER\");\n\n        _collateralAsset = assets_[0];\n        _fundsAsset      = assets_[1];\n\n        _gracePeriod       = termDetails_[0];\n        _paymentInterval   = termDetails_[1];\n        _paymentsRemaining = termDetails_[2];\n\n        _collateralRequired = amounts_[0];\n        _principalRequested = amounts_[1];\n        _endingPrincipal    = amounts_[2];\n\n        _interestRate        = rates_[0];\n        _earlyFeeRate        = rates_[1];\n        _lateFeeRate         = rates_[2];\n        _lateInterestPremium = rates_[3];\n    }\n\n    /**************************************/\n    /*** Internal Borrow-side Functions ***/\n    /**************************************/\n\n    /// @dev Prematurely ends a loan by making all remaining payments.\n    function _closeLoan() internal returns (uint256 principal_, uint256 interest_) {\n        require(block.timestamp <= _nextPaymentDueDate, \"MLI:CL:PAYMENT_IS_LATE\");\n\n        ( principal_, interest_ ) = _getEarlyPaymentBreakdown();\n\n        uint256 totalPaid = principal_ + interest_;\n\n        // The drawable funds are increased by the extra funds in the contract, minus the total needed for payment.\n        _drawableFunds = _drawableFunds + _getUnaccountedAmount(_fundsAsset) - totalPaid;\n\n        _claimableFunds += totalPaid;\n\n        _clearLoanAccounting();\n    }\n\n    /// @dev Sends `amount_` of `_drawableFunds` to `destination_`.\n    function _drawdownFunds(uint256 amount_, address destination_) internal {\n        _drawableFunds -= amount_;\n\n        require(ERC20Helper.transfer(_fundsAsset, destination_, amount_), \"MLI:DF:TRANSFER_FAILED\");\n        require(_isCollateralMaintained(),                                \"MLI:DF:INSUFFICIENT_COLLATERAL\");\n    }\n\n    /// @dev Makes a payment to progress the loan closer to maturity.\n    function _makePayment() internal returns (uint256 principal_, uint256 interest_) {\n        ( principal_, interest_ ) = _getNextPaymentBreakdown();\n\n        uint256 totalPaid = principal_ + interest_;\n\n        // The drawable funds are increased by the extra funds in the contract, minus the total needed for payment.\n        // NOTE: This line will revert if not enough funds were added for the full payment amount.\n        _drawableFunds = (_drawableFunds + _getUnaccountedAmount(_fundsAsset)) - totalPaid;\n\n        _claimableFunds += totalPaid;\n\n        uint256 paymentsRemaining = _paymentsRemaining;\n\n        if (paymentsRemaining == uint256(1)) {\n            _clearLoanAccounting();  // Assumes `_getNextPaymentBreakdown` returns a `principal_` that is `_principal`.\n        } else {\n            _nextPaymentDueDate += _paymentInterval;\n            _principal          -= principal_;\n            _paymentsRemaining   = paymentsRemaining - uint256(1);\n        }\n    }\n\n    /// @dev Registers the delivery of an amount of collateral to be posted.\n    function _postCollateral() internal returns (uint256 collateralPosted_) {\n        _collateral += (collateralPosted_ = _getUnaccountedAmount(_collateralAsset));\n    }\n\n    /// @dev Sets refinance commitment given refinance operations.\n    function _proposeNewTerms(address refinancer_, bytes[] calldata calls_) internal returns (bytes32 proposedRefinanceCommitment_) {\n        // NOTE: There is no way to invalidate the `refinanceCommitment` (i.e. bytes32(0)) without explicitly setting it if `calls_.length` is 0.\n        return _refinanceCommitment =\n            calls_.length > uint256(0)\n                ? _getRefinanceCommitment(refinancer_, calls_)\n                : bytes32(0);\n    }\n\n    /// @dev Sends `amount_` of `_collateral` to `destination_`.\n    function _removeCollateral(uint256 amount_, address destination_) internal {\n        _collateral -= amount_;\n\n        require(ERC20Helper.transfer(_collateralAsset, destination_, amount_), \"MLI:RC:TRANSFER_FAILED\");\n        require(_isCollateralMaintained(),                                     \"MLI:RC:INSUFFICIENT_COLLATERAL\");\n    }\n\n    /// @dev Registers the delivery of an amount of funds to be returned as `_drawableFunds`.\n    function _returnFunds() internal returns (uint256 fundsReturned_) {\n        _drawableFunds += (fundsReturned_ = _getUnaccountedAmount(_fundsAsset));\n    }\n\n    /************************************/\n    /*** Internal Lend-side Functions ***/\n    /************************************/\n\n    /// @dev Processes refinance operations.\n    function _acceptNewTerms(address refinancer_, bytes[] calldata calls_) internal returns (bytes32 acceptedRefinanceCommitment_) {\n        // NOTE: A zero refinancer address and/or empty calls array will never (probabilistically) match a refinance commitment in storage.\n        require(_refinanceCommitment == (acceptedRefinanceCommitment_ = _getRefinanceCommitment(refinancer_, calls_)), \"MLI:ANT:COMMITMENT_MISMATCH\");\n\n        require(refinancer_.code.length != uint256(0), \"MLI:ANT:INVALID_REFINANCER\");\n\n        // Clear refinance commitment to prevent implications of re-acceptance of another call to `_acceptNewTerms`.\n        _refinanceCommitment = bytes32(0);\n\n        uint256 callCount = calls_.length;\n\n        for (uint256 i; i < callCount; ++i) {\n            ( bool success, ) = refinancer_.delegatecall(calls_[i]);\n            require(success, \"MLI:ANT:FAILED\");\n        }\n\n        // Ensure that collateral is maintained after changes made.\n        require(_isCollateralMaintained(), \"MLI:ANT:INSUFFICIENT_COLLATERAL\");\n    }\n\n    /// @dev Sends `amount_` of `_claimableFunds` to `destination_`.\n    ///      If `amount_` is higher than `_claimableFunds` the transaction will underflow and revert.\n    function _claimFunds(uint256 amount_, address destination_) internal {\n        _claimableFunds -= amount_;\n\n        require(ERC20Helper.transfer(_fundsAsset, destination_, amount_), \"MLI:CF:TRANSFER_FAILED\");\n    }\n\n    /// @dev Fund the loan and kick off the repayment requirements.\n    function _fundLoan(address lender_) internal returns (uint256 fundsLent_) {\n        uint256 paymentsRemaining = _paymentsRemaining;\n\n        // Can only fund loan if there are payments remaining (as defined by the initialization) and no payment is due yet (as set by a funding).\n        require((_nextPaymentDueDate == uint256(0)) && (paymentsRemaining != uint256(0)), \"MLI:FL:LOAN_ACTIVE\");\n\n        uint256 paymentInterval = _paymentInterval;\n\n        // NOTE: Don't need to check if lender_ is nonzero or valid, since it is done implicitly in calls to `lender_` below.\n        _lender = lender_;\n\n        _nextPaymentDueDate = block.timestamp + paymentInterval;\n\n        // Amount funded and principal are as requested.\n        fundsLent_ = _principal = _principalRequested;\n\n        address fundsAsset = _fundsAsset;\n\n        // Cannot under-fund loan, but over-funding results in additional funds left unaccounted for.\n        require(_getUnaccountedAmount(fundsAsset) >= fundsLent_, \"MLI:FL:WRONG_FUND_AMOUNT\");\n\n        IMapleGlobalsLike globals = IMapleGlobalsLike(IMapleProxyFactoryLike(_factory()).mapleGlobals());\n\n        // Transfer the annualized treasury fee, if any, to the Maple treasury, and decrement drawable funds.\n        uint256 treasuryFee = (fundsLent_ * globals.treasuryFee() * paymentInterval * paymentsRemaining) / uint256(365 days * 10_000);\n\n        // Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.\n        uint256 delegateFee = (fundsLent_ * globals.investorFee() * paymentInterval * paymentsRemaining) / uint256(365 days * 10_000);\n\n        // Drawable funds is the amount funded, minus any fees.\n        _drawableFunds = fundsLent_ - treasuryFee - delegateFee;\n\n        require(\n            treasuryFee == uint256(0) || ERC20Helper.transfer(fundsAsset, globals.mapleTreasury(), treasuryFee),\n            \"MLI:FL:T_TRANSFER_FAILED\"\n        );\n\n        require(\n            delegateFee == uint256(0) || ERC20Helper.transfer(fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),\n            \"MLI:FL:PD_TRANSFER_FAILED\"\n        );\n    }\n\n    /// @dev Reset all state variables in order to release funds and collateral of a loan in default.\n    function _repossess(address destination_) internal returns (uint256 collateralRepossessed_, uint256 fundsRepossessed_) {\n        uint256 nextPaymentDueDate = _nextPaymentDueDate;\n\n        require(\n            nextPaymentDueDate != uint256(0) && (block.timestamp > nextPaymentDueDate + _gracePeriod),\n            \"MLI:R:NOT_IN_DEFAULT\"\n        );\n\n        _clearLoanAccounting();\n\n        // Uniquely in `_repossess`, stop accounting for all funds so that they can be swept.\n        _collateral     = uint256(0);\n        _claimableFunds = uint256(0);\n        _drawableFunds  = uint256(0);\n\n        address collateralAsset = _collateralAsset;\n\n        // Either there is no collateral to repossess, or the transfer of the collateral succeeds.\n        require(\n            (collateralRepossessed_ = _getUnaccountedAmount(collateralAsset)) == uint256(0) ||\n            ERC20Helper.transfer(collateralAsset, destination_, collateralRepossessed_),\n            \"MLI:R:C_TRANSFER_FAILED\"\n        );\n\n        address fundsAsset = _fundsAsset;\n\n        // Either there are no funds to repossess, or the transfer of the funds succeeds.\n        require(\n            (fundsRepossessed_ = _getUnaccountedAmount(fundsAsset)) == uint256(0) ||\n            ERC20Helper.transfer(fundsAsset, destination_, fundsRepossessed_),\n            \"MLI:R:F_TRANSFER_FAILED\"\n        );\n    }\n\n    /*******************************/\n    /*** Internal View Functions ***/\n    /*******************************/\n\n    /// @dev Returns whether the amount of collateral posted is commensurate with the amount of drawn down (outstanding) principal.\n    function _isCollateralMaintained() internal view returns (bool isMaintained_) {\n        return _collateral >= _getCollateralRequiredFor(_principal, _drawableFunds, _principalRequested, _collateralRequired);\n    }\n\n    /// @dev Get principal and interest breakdown for paying off the entire loan early.\n    function _getEarlyPaymentBreakdown() internal view returns (uint256 principal_, uint256 interest_) {\n        interest_ = ((principal_ = _principal) * _earlyFeeRate) / SCALED_ONE;\n    }\n\n    /// @dev Get principal and interest breakdown for next standard payment.\n    function _getNextPaymentBreakdown() internal view returns (uint256 principal_, uint256 interest_) {\n        ( principal_, interest_ ) = _getPaymentBreakdown(\n            block.timestamp,\n            _nextPaymentDueDate,\n            _paymentInterval,\n            _principal,\n            _endingPrincipal,\n            _paymentsRemaining,\n            _interestRate,\n            _lateFeeRate,\n            _lateInterestPremium\n        );\n    }\n\n    /// @dev Returns the amount of an `asset_` that this contract owns, which is not currently accounted for by its state variables.\n    function _getUnaccountedAmount(address asset_) internal view virtual returns (uint256 unaccountedAmount_) {\n        return IERC20Like(asset_).balanceOf(address(this))\n            - (asset_ == _collateralAsset ? _collateral : uint256(0))                   // `_collateral` is `_collateralAsset` accounted for.\n            - (asset_ == _fundsAsset ? _claimableFunds + _drawableFunds : uint256(0));  // `_claimableFunds` and `_drawableFunds` are `_fundsAsset` accounted for.\n    }\n\n    /*******************************/\n    /*** Internal Pure Functions ***/\n    /*******************************/\n\n    /// @dev Returns the total collateral to be posted for some drawn down (outstanding) principal and overall collateral ratio requirement.\n    function _getCollateralRequiredFor(\n        uint256 principal_,\n        uint256 drawableFunds_,\n        uint256 principalRequested_,\n        uint256 collateralRequired_\n    )\n        internal pure returns (uint256 collateral_)\n    {\n        // Where (collateral / outstandingPrincipal) should be greater or equal to (collateralRequired / principalRequested).\n        // NOTE: principalRequested_ cannot be 0, which is reasonable, since it means this was never a loan.\n        return principal_ <= drawableFunds_ ? uint256(0) : (collateralRequired_ * (principal_ - drawableFunds_)) / principalRequested_;\n    }\n\n    /// @dev Returns principal and interest portions of a payment instalment, given generic, stateless loan parameters.\n    function _getInstallment(uint256 principal_, uint256 endingPrincipal_, uint256 interestRate_, uint256 paymentInterval_, uint256 totalPayments_)\n        internal pure virtual returns (uint256 principalAmount_, uint256 interestAmount_)\n    {\n        /*************************************************************************************************\\\n         *                             |                                                                 *\n         * A = installment amount      |      /                         \\     /           R           \\  *\n         * P = principal remaining     |     |  /                 \\      |   | ----------------------- | *\n         * R = interest rate           | A = | | P * ( 1 + R ) ^ N | - E | * |   /             \\       | *\n         * N = payments remaining      |     |  \\                 /      |   |  | ( 1 + R ) ^ N | - 1  | *\n         * E = ending principal target |      \\                         /     \\  \\             /      /  *\n         *                             |                                                                 *\n         *                             |---------------------------------------------------------------- *\n         *                                                                                               *\n         * - Where R           is `periodicRate`                                                         *\n         * - Where (1 + R) ^ N is `raisedRate`                                                           *\n         * - Both of these rates are scaled by 1e18 (e.g., 12% => 0.12 * 10 ** 18)                       *\n        \\*************************************************************************************************/\n\n        uint256 periodicRate = _getPeriodicInterestRate(interestRate_, paymentInterval_);\n        uint256 raisedRate   = _scaledExponent(SCALED_ONE + periodicRate, totalPayments_, SCALED_ONE);\n\n        // NOTE: If a lack of precision in `_scaledExponent` results in a `raisedRate` smaller than one, assume it to be one and simplify the equation.\n        if (raisedRate <= SCALED_ONE) return ((principal_ - endingPrincipal_) / totalPayments_, uint256(0));\n\n        uint256 total = ((((principal_ * raisedRate) / SCALED_ONE) - endingPrincipal_) * periodicRate) / (raisedRate - SCALED_ONE);\n\n        interestAmount_  = _getInterest(principal_, interestRate_, paymentInterval_);\n        principalAmount_ = total >= interestAmount_ ? total - interestAmount_ : uint256(0);\n    }\n\n    /// @dev Returns an amount by applying an annualized and scaled interest rate, to a principal, over an interval of time.\n    function _getInterest(uint256 principal_, uint256 interestRate_, uint256 interval_) internal pure virtual returns (uint256 interest_) {\n        return (principal_ * _getPeriodicInterestRate(interestRate_, interval_)) / SCALED_ONE;\n    }\n\n    /// @dev Returns total principal and interest portion of a number of payments, given generic, stateless loan parameters and loan state.\n    function _getPaymentBreakdown(\n        uint256 currentTime_,\n        uint256 nextPaymentDueDate_,\n        uint256 paymentInterval_,\n        uint256 principal_,\n        uint256 endingPrincipal_,\n        uint256 paymentsRemaining_,\n        uint256 interestRate_,\n        uint256 lateFeeRate_,\n        uint256 lateInterestPremium_\n    )\n        internal pure virtual\n        returns (uint256 principalAmount_, uint256 interestAmount_)\n    {\n        ( principalAmount_, interestAmount_ ) = _getInstallment(\n            principal_,\n            endingPrincipal_,\n            interestRate_,\n            paymentInterval_,\n            paymentsRemaining_\n        );\n\n        principalAmount_ = paymentsRemaining_ == uint256(1) ? principal_ : principalAmount_;\n\n        if (currentTime_ > nextPaymentDueDate_) {\n            uint256 daysLate = (((currentTime_ - nextPaymentDueDate_ - 1) / 1 days) + 1) * 1 days;\n\n            interestAmount_ += _getInterest(principal_, interestRate_ + lateInterestPremium_, daysLate);\n            interestAmount_ += (lateFeeRate_ * principal_) / SCALED_ONE;\n        }\n    }\n\n    /// @dev Returns the interest rate over an interval, given an annualized interest rate.\n    function _getPeriodicInterestRate(uint256 interestRate_, uint256 interval_) internal pure virtual returns (uint256 periodicInterestRate_) {\n        return (interestRate_ * interval_) / uint256(365 days);\n    }\n\n    /// @dev Returns refinance commitment given refinance parameters.\n    function _getRefinanceCommitment(address refinancer_, bytes[] calldata calls_) internal pure returns (bytes32 refinanceCommitment_) {\n        return keccak256(abi.encode(refinancer_, calls_));\n    }\n\n    /**\n     *  @dev Returns exponentiation of a scaled base value.\n     *\n     *       Walk through example:\n     *       LINE  |  base_          |  exponent_  |  one_  |  result_\n     *             |  3_00           |  18         |  1_00  |  0_00\n     *        A    |  3_00           |  18         |  1_00  |  1_00\n     *        B    |  3_00           |  9          |  1_00  |  1_00\n     *        C    |  9_00           |  9          |  1_00  |  1_00\n     *        D    |  9_00           |  9          |  1_00  |  9_00\n     *        B    |  9_00           |  4          |  1_00  |  9_00\n     *        C    |  81_00          |  4          |  1_00  |  9_00\n     *        B    |  81_00          |  2          |  1_00  |  9_00\n     *        C    |  6_561_00       |  2          |  1_00  |  9_00\n     *        B    |  6_561_00       |  1          |  1_00  |  9_00\n     *        C    |  43_046_721_00  |  1          |  1_00  |  9_00\n     *        D    |  43_046_721_00  |  1          |  1_00  |  387_420_489_00\n     *        B    |  43_046_721_00  |  0          |  1_00  |  387_420_489_00\n     *\n     * Another implementation of this algorithm can be found in Dapphub's DSMath contract:\n     * https://github.com/dapphub/ds-math/blob/ce67c0fa9f8262ecd3d76b9e4c026cda6045e96c/src/math.sol#L77\n     */\n    function _scaledExponent(uint256 base_, uint256 exponent_, uint256 one_) internal pure returns (uint256 result_) {\n        // If exponent_ is odd, set result_ to base_, else set to one_.\n        result_ = exponent_ & uint256(1) != uint256(0) ? base_ : one_;          // A\n\n        // Divide exponent_ by 2 (overwriting itself) and proceed if not zero.\n        while ((exponent_ >>= uint256(1)) != uint256(0)) {                      // B\n            base_ = (base_ * base_) / one_;                                     // C\n\n            // If exponent_ is even, go back to top.\n            if (exponent_ & uint256(1) == uint256(0)) continue;\n\n            // If exponent_ is odd, multiply result_ is multiplied by base_.\n            result_ = (result_ * base_) / one_;                                 // D\n        }\n    }\n\n}\n\n/// @title MapleLoan implements a primitive loan with additional functionality, and is intended to be proxied.\ncontract MapleLoan is IMapleLoan, MapleLoanInternals {\n\n    modifier whenProtocolNotPaused() {\n        require(!isProtocolPaused(), \"ML:PROTOCOL_PAUSED\");\n        _;\n    }\n\n    /********************************/\n    /*** Administrative Functions ***/\n    /********************************/\n\n    function migrate(address migrator_, bytes calldata arguments_) external override {\n        require(msg.sender == _factory(),        \"ML:M:NOT_FACTORY\");\n        require(_migrate(migrator_, arguments_), \"ML:M:FAILED\");\n    }\n\n    function setImplementation(address newImplementation_) external override {\n        require(msg.sender == _factory(),               \"ML:SI:NOT_FACTORY\");\n        require(_setImplementation(newImplementation_), \"ML:SI:FAILED\");\n    }\n\n    function upgrade(uint256 toVersion_, bytes calldata arguments_) external override {\n        require(msg.sender == _borrower, \"ML:U:NOT_BORROWER\");\n\n        emit Upgraded(toVersion_, arguments_);\n\n        IMapleProxyFactoryLike(_factory()).upgradeInstance(toVersion_, arguments_);\n    }\n\n    /************************/\n    /*** Borrow Functions ***/\n    /************************/\n\n    function acceptBorrower() external override {\n        require(msg.sender == _pendingBorrower, \"ML:AB:NOT_PENDING_BORROWER\");\n\n        _pendingBorrower = address(0);\n\n        emit BorrowerAccepted(_borrower = msg.sender);\n    }\n\n    function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {\n        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.\n        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:CL:TRANSFER_FROM_FAILED\");\n\n        // If the caller is not the borrower, require that the transferred amount be sufficient to close the loan without touching `_drawableFunds`.\n        if (msg.sender != _borrower) {\n            ( principal_, interest_ ) = _getEarlyPaymentBreakdown();\n            require(_getUnaccountedAmount(_fundsAsset) >= principal_ + interest_, \"ML:CL:CANNOT_USE_DRAWABLE\");\n        }\n\n        ( principal_, interest_ ) = _closeLoan();\n\n        emit LoanClosed(principal_, interest_);\n    }\n\n    function drawdownFunds(uint256 amount_, address destination_) external override whenProtocolNotPaused returns (uint256 collateralPosted_) {\n        require(msg.sender == _borrower, \"ML:DF:NOT_BORROWER\");\n\n        emit FundsDrawnDown(amount_, destination_);\n\n        // Post additional collateral required to facilitate this drawdown, if needed.\n        uint256 additionalCollateralRequired = getAdditionalCollateralRequiredFor(amount_);\n\n        if (additionalCollateralRequired > uint256(0)) {\n            // Determine collateral currently unaccounted for.\n            uint256 unaccountedCollateral = _getUnaccountedAmount(_collateralAsset);\n\n            // Post required collateral, specifying then amount lacking as the optional amount to be transferred from.\n            collateralPosted_ = postCollateral(\n                additionalCollateralRequired > unaccountedCollateral ? additionalCollateralRequired - unaccountedCollateral : uint256(0)\n            );\n        }\n\n        _drawdownFunds(amount_, destination_);\n    }\n\n    function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {\n        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.\n        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:MP:TRANSFER_FROM_FAILED\");\n\n        // If the caller is not the borrower, require that the transferred amount be sufficient to make a payment without touching `_drawableFunds`.\n        if (msg.sender != _borrower) {\n            ( principal_, interest_ ) = _getNextPaymentBreakdown();\n            require(_getUnaccountedAmount(_fundsAsset) >= principal_ + interest_, \"ML:MP:CANNOT_USE_DRAWABLE\");\n        }\n\n        ( principal_, interest_ ) = _makePayment();\n\n        emit PaymentMade(principal_, interest_);\n    }\n\n    function postCollateral(uint256 amount_) public override whenProtocolNotPaused returns (uint256 collateralPosted_) {\n        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.\n        require(\n            amount_ == uint256(0) || ERC20Helper.transferFrom(_collateralAsset, msg.sender, address(this), amount_),\n            \"ML:PC:TRANSFER_FROM_FAILED\"\n        );\n\n        emit CollateralPosted(collateralPosted_ = _postCollateral());\n    }\n\n    function proposeNewTerms(address refinancer_, bytes[] calldata calls_) external override whenProtocolNotPaused {\n        require(msg.sender == _borrower, \"ML:PNT:NOT_BORROWER\");\n\n        emit NewTermsProposed(_proposeNewTerms(refinancer_, calls_), refinancer_, calls_);\n    }\n\n    function removeCollateral(uint256 amount_, address destination_) external override whenProtocolNotPaused {\n        require(msg.sender == _borrower, \"ML:RC:NOT_BORROWER\");\n\n        emit CollateralRemoved(amount_, destination_);\n\n        _removeCollateral(amount_, destination_);\n    }\n\n    function returnFunds(uint256 amount_) external override whenProtocolNotPaused returns (uint256 fundsReturned_) {\n        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.\n        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:RF:TRANSFER_FROM_FAILED\");\n\n        emit FundsReturned(fundsReturned_ = _returnFunds());\n    }\n\n    function setPendingBorrower(address pendingBorrower_) external override {\n        require(msg.sender == _borrower, \"ML:SPB:NOT_BORROWER\");\n\n        emit PendingBorrowerSet(_pendingBorrower = pendingBorrower_);\n    }\n\n    /**********************/\n    /*** Lend Functions ***/\n    /**********************/\n\n    function acceptLender() external override {\n        require(msg.sender == _pendingLender, \"ML:AL:NOT_PENDING_LENDER\");\n\n        _pendingLender = address(0);\n\n        emit LenderAccepted(_lender = msg.sender);\n    }\n\n    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external override whenProtocolNotPaused {\n        address lenderAddress = _lender;\n\n        require(msg.sender == lenderAddress, \"ML:ANT:NOT_LENDER\");\n\n        address fundsAssetAddress = _fundsAsset;\n\n        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.\n        require(amount_ == uint256(0) || ERC20Helper.transferFrom(fundsAssetAddress, msg.sender, address(this), amount_), \"ML:ACT:TRANSFER_FROM_FAILED\");\n\n        emit NewTermsAccepted(_acceptNewTerms(refinancer_, calls_), refinancer_, calls_);\n\n        uint256 extra = _getUnaccountedAmount(fundsAssetAddress);\n\n        // NOTE: This block ensures unaccounted funds (pre-existing or due to over-funding) gets redirected to the lender.\n        if (extra > uint256(0)) {\n            emit FundsRedirected(extra, lenderAddress);\n            require(ERC20Helper.transfer(fundsAssetAddress, lenderAddress, extra), \"ML:ANT:TRANSFER_FAILED\");\n        }\n    }\n\n    function claimFunds(uint256 amount_, address destination_) external override whenProtocolNotPaused {\n        require(msg.sender == _lender, \"ML:CF:NOT_LENDER\");\n\n        emit FundsClaimed(amount_, destination_);\n\n        _claimFunds(amount_, destination_);\n    }\n\n    function fundLoan(address lender_, uint256 amount_) external override whenProtocolNotPaused returns (uint256 fundsLent_) {\n        address fundsAssetAddress = _fundsAsset;\n\n        // The amount specified is an optional amount to be transferred from the caller, as a convenience for EOAs.\n        require(amount_ == uint256(0) || ERC20Helper.transferFrom(fundsAssetAddress, msg.sender, address(this), amount_), \"ML:FL:TRANSFER_FROM_FAILED\");\n\n        // If the loan is not active, fund it.\n        if (_nextPaymentDueDate == uint256(0)) {\n            // NOTE: `_nextPaymentDueDate` emitted in event is updated by `_fundLoan`.\n            emit Funded(lender_, fundsLent_ = _fundLoan(lender_), _nextPaymentDueDate);\n        }\n\n        uint256 extra         = _getUnaccountedAmount(fundsAssetAddress);\n        address lenderAddress = _lender;\n\n        // NOTE: This block is not only a stopgap solution to allow a LiquidityLockerV1 to send funds to a DebtLocker, while maintaining PoolV1 accounting,\n        //       but also ensures unaccounted funds (pre-existing or due to over-funding) gets redirected to the lender.\n        if (extra > uint256(0)) {\n            emit FundsRedirected(extra, lenderAddress);\n            require(ERC20Helper.transfer(fundsAssetAddress, lenderAddress, extra), \"ML:FL:TRANSFER_FAILED\");\n        }\n    }\n\n    function repossess(address destination_) external override whenProtocolNotPaused returns (uint256 collateralRepossessed_, uint256 fundsRepossessed_) {\n        require(msg.sender == _lender, \"ML:R:NOT_LENDER\");\n\n        ( collateralRepossessed_, fundsRepossessed_ ) = _repossess(destination_);\n\n        emit Repossessed(collateralRepossessed_, fundsRepossessed_, destination_);\n    }\n\n    function setPendingLender(address pendingLender_) external override {\n        require(msg.sender == _lender, \"ML:SPL:NOT_LENDER\");\n\n        emit PendingLenderSet(_pendingLender = pendingLender_);\n    }\n\n    /*******************************/\n    /*** Miscellaneous Functions ***/\n    /*******************************/\n\n    function skim(address token_, address destination_) external override whenProtocolNotPaused returns (uint256 skimmed_) {\n        require((msg.sender == _borrower) || (msg.sender == _lender),    \"L:S:NO_AUTH\");\n        require((token_ != _fundsAsset) && (token_ != _collateralAsset), \"L:S:INVALID_TOKEN\");\n\n        emit Skimmed(token_, skimmed_ = IERC20Like(token_).balanceOf(address(this)), destination_);\n\n        require(ERC20Helper.transfer(token_, destination_, skimmed_), \"L:S:TRANSFER_FAILED\");\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    function getAdditionalCollateralRequiredFor(uint256 drawdown_) public view override returns (uint256 collateral_) {\n        // Determine the collateral needed in the contract for a reduced drawable funds amount.\n        uint256 collateralNeeded  = _getCollateralRequiredFor(_principal, _drawableFunds - drawdown_, _principalRequested, _collateralRequired);\n        uint256 currentCollateral = _collateral;\n\n        return collateralNeeded > currentCollateral ? collateralNeeded - currentCollateral : uint256(0);\n    }\n\n    function getEarlyPaymentBreakdown() external view override returns (uint256 principal_, uint256 interest_) {\n        ( principal_, interest_ ) = _getEarlyPaymentBreakdown();\n    }\n\n    function getNextPaymentBreakdown() external view override returns (uint256 principal_, uint256 interest_) {\n        ( principal_, interest_ ) = _getNextPaymentBreakdown();\n    }\n\n    function isProtocolPaused() public view override returns (bool paused_) {\n        return IMapleGlobalsLike(IMapleProxyFactoryLike(_factory()).mapleGlobals()).protocolPaused();\n    }\n\n    /****************************/\n    /*** State View Functions ***/\n    /****************************/\n\n    function borrower() external view override returns (address borrower_) {\n        return _borrower;\n    }\n\n    function claimableFunds() external view override returns (uint256 claimableFunds_) {\n        return _claimableFunds;\n    }\n\n    function collateral() external view override returns (uint256 collateral_) {\n        return _collateral;\n    }\n\n    function collateralAsset() external view override returns (address collateralAsset_) {\n        return _collateralAsset;\n    }\n\n    function collateralRequired() external view override returns (uint256 collateralRequired_) {\n        return _collateralRequired;\n    }\n\n    function drawableFunds() external view override returns (uint256 drawableFunds_) {\n        return _drawableFunds;\n    }\n\n    function earlyFeeRate() external view override returns (uint256 earlyFeeRate_) {\n        return _earlyFeeRate;\n    }\n\n    function endingPrincipal() external view override returns (uint256 endingPrincipal_) {\n        return _endingPrincipal;\n    }\n\n    function excessCollateral() external view override returns (uint256 excessCollateral_) {\n        uint256 collateralNeeded  = _getCollateralRequiredFor(_principal, _drawableFunds, _principalRequested, _collateralRequired);\n        uint256 currentCollateral = _collateral;\n\n        return currentCollateral > collateralNeeded ? currentCollateral - collateralNeeded : uint256(0);\n    }\n\n    function factory() external view override returns (address factory_) {\n        return _factory();\n    }\n\n    function fundsAsset() external view override returns (address fundsAsset_) {\n        return _fundsAsset;\n    }\n\n    function gracePeriod() external view override returns (uint256 gracePeriod_) {\n        return _gracePeriod;\n    }\n\n    function implementation() external view override returns (address implementation_) {\n        return _implementation();\n    }\n\n    function interestRate() external view override returns (uint256 interestRate_) {\n        return _interestRate;\n    }\n\n    function lateFeeRate() external view override returns (uint256 lateFeeRate_) {\n        return _lateFeeRate;\n    }\n\n    function lateInterestPremium() external view override returns (uint256 lateInterestPremium_) {\n        return _lateInterestPremium;\n    }\n\n    function lender() external view override returns (address lender_) {\n        return _lender;\n    }\n\n    function nextPaymentDueDate() external view override returns (uint256 nextPaymentDueDate_) {\n        return _nextPaymentDueDate;\n    }\n\n    function paymentInterval() external view override returns (uint256 paymentInterval_) {\n        return _paymentInterval;\n    }\n\n    function paymentsRemaining() external view override returns (uint256 paymentsRemaining_) {\n        return _paymentsRemaining;\n    }\n\n    function pendingBorrower() external view override returns (address pendingBorrower_) {\n        return _pendingBorrower;\n    }\n\n    function pendingLender() external view override returns (address pendingLender_) {\n        return _pendingLender;\n    }\n\n    function principalRequested() external view override returns (uint256 principalRequested_) {\n        return _principalRequested;\n    }\n\n    function principal() external view override returns (uint256 principal_) {\n        return _principal;\n    }\n\n    // NOTE: This is needed for `fundLoan` call from PoolV1.\n    function superFactory() external view override returns (address superFactory_) {\n        return _factory();\n    }\n\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","abi"]}},"metadata":{"bytecodeHash":"none"}}}