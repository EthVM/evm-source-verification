{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/SmartOne.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.7.4;\r\n\r\ncontract SmartOne {\r\n    using SafeMath for uint256;\r\n\r\n    address payable private owner; // Smart Contract Owner (Who deploys)\r\n    address payable private adminAddress; // Project manager\r\n\r\n    uint256 public PAYMENT_FACTOR = 1000;\r\n    uint256 private constant DIVIDER = 1000;\r\n\r\n    uint256 private constant SIGN_UP_AMOUNT = 0.016 ether;\r\n    uint256 private constant ACTIVATE_AMOUNT = 0.016 ether;\r\n\r\n    uint256 private constant USERS_PER_POOL = 4;\r\n    uint256 private constant POOL_NUMBER = 5;\r\n\r\n    address[4][] public pool = [\r\n        [address(0), address(0), address(0), address(0)],\r\n        [address(0), address(0), address(0), address(0)],\r\n        [address(0), address(0), address(0), address(0)],\r\n        [address(0), address(0), address(0), address(0)],\r\n        [address(0), address(0), address(0), address(0)]\r\n    ];\r\n\r\n    uint256[] userPayments = [0.016 ether, 0.032 ether, 0.064 ether, 0.16 ether, 0.32 ether];\r\n    uint256[] adminPayments = [0.016 ether, 0.032 ether, 0.064 ether, 0.16 ether, 0.32 ether];\r\n        \r\n    struct User {\r\n        bool signedUp;\r\n        bool active;\r\n    }\r\n\r\n    mapping(address => User) internal users;\r\n\r\n    event SignUp(address indexed user, uint256 amount);\r\n    event ActivePool(address indexed user, uint256 amount);\r\n    event UpgradeUser(address indexed user, uint256 amount, uint256 pool);\r\n\r\n    constructor() {\r\n        owner = payable(msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function isUserSignedUp(address user) internal view returns (bool) {\r\n        return (users[user].signedUp == true);\r\n    }\r\n\r\n    function isUserActive(address user) internal view returns (bool) {\r\n        return (users[user].active == true);\r\n    }\r\n\r\n    // Main functions\r\n    function joinMe() external payable {\r\n        require(!isContract(msg.sender) && msg.sender == tx.origin);\r\n        require(!isUserSignedUp(msg.sender), \"User is already registered\");\r\n        require(!isUserActive(msg.sender), \"User is already active\");\r\n        require(msg.value >= 1e8, \"Zero amount\");\r\n        require(\r\n            msg.value >= SIGN_UP_AMOUNT.add(ACTIVATE_AMOUNT).mul(PAYMENT_FACTOR).div(DIVIDER),\r\n            \"Deposit is below minimum amount\"\r\n        );\r\n\r\n        User storage user = users[msg.sender];\r\n\r\n        if (user.signedUp == false && user.active == false) {\r\n            payable(adminAddress).transfer(SIGN_UP_AMOUNT);\r\n\r\n            user.signedUp = true;\r\n            user.active = true;\r\n            addUserPool(msg.sender);\r\n\r\n            emit SignUp(msg.sender, SIGN_UP_AMOUNT);\r\n            emit ActivePool(msg.sender, ACTIVATE_AMOUNT);\r\n        }\r\n    }\r\n\r\n    function signUp() external payable {\r\n        require(!isContract(msg.sender) && msg.sender == tx.origin);\r\n        require(!isUserSignedUp(msg.sender), \"User is already registered\");\r\n        require(msg.value >= 1e8, \"Zero amount\");\r\n        require(\r\n            msg.value >= SIGN_UP_AMOUNT.mul(PAYMENT_FACTOR).div(DIVIDER),\r\n            \"Deposit is below minimum amount\"\r\n        );\r\n\r\n        User storage user = users[msg.sender];\r\n\r\n        if (user.signedUp == false) {\r\n            payable(adminAddress).transfer(msg.value);\r\n            user.signedUp = true;\r\n            emit SignUp(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    function activatePool() external payable {\r\n        require(!isContract(msg.sender) && msg.sender == tx.origin);\r\n        require(isUserSignedUp(msg.sender), \"The user must be registered\");\r\n        require(!isUserActive(msg.sender), \"User is already active\");\r\n        require(msg.value >= 1e8, \"Zero amount\");\r\n        require(\r\n            msg.value >= ACTIVATE_AMOUNT.mul(PAYMENT_FACTOR).div(DIVIDER),\r\n            \"Deposit is below minimum amount\"\r\n        );\r\n\r\n        User storage user = users[msg.sender];\r\n\r\n        if (user.active == false) {\r\n            user.active = true;\r\n            addUserPool(msg.sender);\r\n            emit ActivePool(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    function systemPayment(uint256 n, address user) internal {\r\n        if (user != address(0)) {\r\n            User storage userData = users[user];\r\n            \r\n            if(n == 4){\r\n                userData.active = false;\r\n            }\r\n\r\n            if(address(this).balance > userPayments[n]){\r\n                // User payment\r\n                payable(user).transfer(userPayments[n]);\r\n                emit UpgradeUser(user, userPayments[n], n);\r\n            }\r\n\r\n            if(address(this).balance > adminPayments[n]){\r\n                // Admin payment\r\n                payable(adminAddress).transfer(adminPayments[n]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addUserPool(address user) internal {\r\n        address[4][] memory memoryPool = pool;\r\n\r\n        // Primer usuario\r\n        address firstUser = address(0);\r\n        uint256 emptySpace = 9;\r\n\r\n        // Buscar el ultimo espacio vacio en el pool 1\r\n        for (uint256 j = 0; j < USERS_PER_POOL; j++) {\r\n            if (pool[0][j] == address(0)) {\r\n                emptySpace = j;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (emptySpace != 9) {\r\n            pool[0][emptySpace] = user;\r\n        } else {\r\n            // Desplazar\r\n            for (uint256 n = 0; n < POOL_NUMBER; n++) {\r\n                // Si es el primer pool liberar el ultimo espacio\r\n                if (n == 0) {\r\n                    pool[n][0] = memoryPool[n][1];\r\n                    pool[n][1] = memoryPool[n][2];\r\n                    pool[n][2] = memoryPool[n][3];\r\n                    pool[n][3] = user;\r\n                    user = address(0);\r\n                } else {\r\n                    if (user == address(0) && firstUser == address(0)) break;\r\n\r\n                    // Buscar ultimo espacio vacio en el pool\r\n                    uint256 emptySpace2 = 9;\r\n\r\n                    for (uint256 k = 0; k < USERS_PER_POOL; k++) {\r\n                        if (pool[n][k] == address(0)) {\r\n                            emptySpace2 = k;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    // Si existe un espacio libre usarlo, sino desplazar\r\n                    if (emptySpace2 != 9) {\r\n                        pool[n][emptySpace2] = firstUser;\r\n                        systemPayment(n - 1, firstUser);\r\n                        firstUser = address(0);\r\n                    } else {\r\n                        pool[n][0] = memoryPool[n][1];\r\n                        pool[n][1] = memoryPool[n][2];\r\n                        pool[n][2] = memoryPool[n][3];\r\n                        pool[n][3] = firstUser;\r\n                        systemPayment(n - 1, firstUser);\r\n                        firstUser = address(0);\r\n                    }\r\n                }\r\n\r\n                if (memoryPool[n][3] != address(0) || n == 4) {\r\n                    firstUser = memoryPool[n][0];\r\n                } \r\n                    \r\n            }\r\n\r\n            if(firstUser != address(0)){\r\n                systemPayment(4, firstUser);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setPaymentFactor(uint256 percent) public onlyOwner returns (uint256){\r\n        PAYMENT_FACTOR = percent;\r\n        return PAYMENT_FACTOR.div(DIVIDER);\r\n    }\r\n   \r\n    \r\n    function setAdmin(address user) public onlyOwner returns(bool){\r\n        adminAddress = payable(user);\r\n        return true;\r\n    } \r\n\r\n    function withDrawFounds(uint256 amount) external payable onlyOwner {\r\n        if (address(this).balance > amount) \r\n        {\r\n            payable(adminAddress).transfer(amount);\r\n        }\r\n    }\r\n\r\n    function getPaymentFactor() public  view returns (uint256)\r\n    {\r\n        return PAYMENT_FACTOR.div(DIVIDER);\r\n    }\r\n\r\n    function getPool() public  view returns (address[4][] memory)\r\n    {\r\n        return pool;\r\n    }\r\n\r\n    function getUserData(address _user) public view returns (bool signedUp, bool active)\r\n    {\r\n        User storage user = users[_user];\r\n        return (user.signedUp, user.active);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}\r\n"
    }
  }
}