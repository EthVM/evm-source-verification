{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":1},"remappings":[],"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}},"sources":{"@solv/v2-offering-market-core/contracts/OfferingMarketCore.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@solv/v2-solidity-utils/contracts/misc/Constants.sol\";\nimport \"@solv/v2-solidity-utils/contracts/access/AdminControl.sol\";\nimport \"@solv/v2-solidity-utils/contracts/openzeppelin/math/SafeMathUpgradeable.sol\";\nimport \"@solv/v2-solidity-utils/contracts/openzeppelin/utils/EnumerableSetUpgradeable.sol\";\nimport \"@solv/v2-solidity-utils/contracts/math/SafeMathUpgradeable128.sol\";\nimport \"@solv/v2-solidity-utils/contracts/helpers/VNFTTransferHelper.sol\";\nimport \"@solv/v2-solidity-utils/contracts/helpers/ERC20TransferHelper.sol\";\nimport \"@solv/v2-solidity-utils/contracts/openzeppelin/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@solv/v2-solver/contracts/interface/ISolver.sol\";\nimport \"./PriceManager.sol\";\n\nabstract contract OfferingMarketCore is\n    PriceManager,\n    AdminControl,\n    ReentrancyGuardUpgradeable\n{\n    using SafeMathUpgradeable for uint256;\n    using SafeMathUpgradeable128 for uint128;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    event AddMarket(\n        address indexed voucher,\n        Constants.VoucherType voucherType,\n        address asset,\n        uint8 decimals,\n        uint16 feeRate,\n        bool onlyManangerOffer\n    );\n\n    event RemoveMarket(address indexed voucher);\n\n    event Offer(\n        address indexed voucher,\n        address indexed issuer,\n        Offering offering\n    );\n\n    event Remove(\n        address indexed issuer,\n        uint24 indexed offeringId,\n        address voucher,\n        uint128 total,\n        uint128 sold\n    );\n\n    event FixedPriceSet(\n        address indexed voucher,\n        uint24 indexed offeringId,\n        uint8 priceType,\n        uint128 lastPrice\n    );\n\n    event DecliningPriceSet(\n        address indexed voucher,\n        uint24 indexed offeringId,\n        uint128 highest,\n        uint128 lowest,\n        uint32 duration,\n        uint32 interval\n    );\n\n    event Traded(\n        address indexed buyer,\n        uint24 indexed offeringId,\n        address indexed voucher,\n        uint256 voucherId,\n        uint24 tradeId,\n        uint32 tradeTime,\n        address currency,\n        uint8 priceType,\n        uint128 price,\n        uint128 tradedUnits,\n        uint256 tradedAmount,\n        uint128 fee\n    );\n\n    event SetCurrency(address indexed currency, bool enable);\n\n    event WithdrawFee(address voucher, uint256 reduceAmount);\n\n    event NewSolver(ISolver oldSolver, ISolver newSolver);\n\n    struct Market {\n        Constants.VoucherType voucherType;\n        address voucherPool;\n        address asset;\n        uint8 decimals;\n        uint16 feeRate;\n        bool onlyManangerOffer;\n        bool isValid;\n    }\n\n    struct Offering {\n        uint24 offeringId;\n        uint32 startTime;\n        uint32 endTime;\n        PriceManager.PriceType priceType;\n        uint128 totalUnits;\n        uint128 units;\n        uint128 min;\n        uint128 max;\n        address voucher;\n        address currency;\n        address issuer;\n        bool useAllowList;\n        bool isValid;\n    }\n\n    //key: offeringId\n    mapping(uint24 => Offering) public offerings;\n\n    //key: voucher\n    mapping(address => Market) public markets;\n\n    EnumerableSetUpgradeable.AddressSet internal _currencies;\n    EnumerableSetUpgradeable.AddressSet internal _vouchers;\n\n    //voucher => offeringId\n    mapping(address => EnumerableSetUpgradeable.UintSet)\n        internal _voucherOfferings;\n\n    mapping(address => EnumerableSetUpgradeable.AddressSet)\n        internal _allowAddresses;\n\n    // managers with authorities to set allow addresses of a voucher market and offer offering\n    mapping(address => EnumerableSetUpgradeable.AddressSet)\n        internal _voucherManagers;\n\n    // records of user purchased units from an order\n    mapping(uint24 => mapping(address => uint128)) internal _tradeRecords;\n\n    ISolver public solver;\n    uint24 public nextOfferingId;\n    uint24 public nextTradeId;\n\n    modifier onlyVoucherManager(address voucher_) {\n        require(\n            msg.sender == admin ||\n                _voucherManagers[voucher_].contains(msg.sender),\n            \"only manager\"\n        );\n        _;\n    }\n\n    function _mintVoucher(uint24 oferingId, uint128 units)\n        internal\n        virtual\n        returns (uint256 voucherId);\n\n    function _refund(uint24 offeringId, uint128 units) internal virtual;\n\n    function isSupportVoucherType(Constants.VoucherType voucherType)\n        public\n        virtual\n        returns (bool);\n\n    function initialize(ISolver solver_) external initializer {\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        AdminControl.__AdminControl_init(msg.sender);\n        nextOfferingId = 1;\n        nextTradeId = 1;\n        setSolver(solver_);\n    }\n\n    function _offer(\n        address voucher_,\n        address currency_,\n        uint128 units_,\n        uint128 min_,\n        uint128 max_,\n        uint32 startTime_,\n        uint32 endTime_,\n        bool useAllowList_,\n        PriceManager.PriceType priceType_,\n        bytes memory priceData_\n    ) internal nonReentrant returns (uint24 offeringId) {\n        require(\n            voucher_ != address(0) && currency_ != address(0),\n            \"address cannot be 0\"\n        );\n        Market memory market = markets[voucher_];\n        require(market.isValid, \"unsupported voucher\");\n        require(_currencies.contains(currency_), \"unsupported currency\");\n        require(endTime_ > startTime_, \"endTime less than startTime\");\n\n        if (market.onlyManangerOffer) {\n            require(\n                _voucherManagers[voucher_].contains(msg.sender),\n                \"only manager\"\n            );\n        }\n\n        if (max_ > 0) {\n            require(min_ <= max_, \"min > max\");\n        }\n\n        uint256 err = solver.operationAllowed(\n            \"Offer\",\n            abi.encode(\n                voucher_,\n                msg.sender,\n                currency_,\n                units_,\n                min_,\n                max_,\n                startTime_,\n                endTime_,\n                useAllowList_,\n                priceType_,\n                priceData_\n            )\n        );\n        require(err == 0, \"solver not allowed\");\n\n        offeringId = _generateNextofferingId();\n\n        offerings[offeringId] = Offering({\n            offeringId: offeringId,\n            startTime: startTime_,\n            endTime: endTime_,\n            priceType: priceType_,\n            totalUnits: units_,\n            units: units_,\n            min: min_,\n            max: max_,\n            currency: currency_,\n            issuer: msg.sender,\n            voucher: voucher_,\n            useAllowList: useAllowList_,\n            isValid: true\n        });\n\n        Offering memory offering = offerings[offeringId];\n\n        _setPrice(offering, priceType_, priceData_);\n\n        solver.operationVerify(\n            \"Offer\",\n            abi.encode(offering.voucher, offering.offeringId)\n        );\n        emit Offer(offering.voucher, offering.issuer, offering);\n\n        return offeringId;\n    }\n\n    function _setPrice(\n        Offering memory offering_,\n        PriceManager.PriceType priceType_,\n        bytes memory priceData_\n    ) internal {\n        if (priceType_ == PriceManager.PriceType.FIXED) {\n            uint128 price = abi.decode(priceData_, (uint128));\n            PriceManager.setFixedPrice(offering_.offeringId, price);\n\n            emit FixedPriceSet(\n                offering_.voucher,\n                offering_.offeringId,\n                uint8(priceType_),\n                price\n            );\n        } else {\n            (\n                uint128 highest,\n                uint128 lowest,\n                uint32 duration,\n                uint32 interval\n            ) = abi.decode(priceData_, (uint128, uint128, uint32, uint32));\n            PriceManager.setDecliningPrice(\n                offering_.offeringId,\n                offering_.startTime,\n                highest,\n                lowest,\n                duration,\n                interval\n            );\n\n            emit DecliningPriceSet(\n                offering_.voucher,\n                offering_.offeringId,\n                highest,\n                lowest,\n                duration,\n                interval\n            );\n        }\n    }\n\n    function buy(uint24 offeringId_, uint128 units_)\n        external\n        payable\n        virtual\n        nonReentrant\n        returns (uint256 amount_, uint128 fee_)\n    {\n        address buyer = msg.sender;\n        uint128 price = getPrice(offeringId_);\n        Offering storage offering = offerings[offeringId_];\n        require(offering.isValid, \"invalid offering\");\n\n        Market memory market = markets[offering.voucher];\n        require(market.isValid, \"invalid market\");\n        amount_ = uint256(units_).mul(uint256(price)).div(\n            uint256(10**market.decimals)\n        );\n\n        if (\n            offering.currency == Constants.ETH_ADDRESS &&\n            offering.priceType == PriceType.DECLIINING_BY_TIME &&\n            amount_ != msg.value\n        ) {\n            amount_ = msg.value;\n            uint256 units256 = amount_.mul(uint256(10**market.decimals)).div(\n                uint256(price)\n            );\n            require(units256 <= uint128(-1), \"exceeds uint128 max\");\n            units_ = uint128(units256);\n        }\n\n        fee_ = _getFee(offering.voucher, amount_);\n\n        uint256 err = solver.operationAllowed(\n            \"Buy\",\n            abi.encode(\n                offering.voucher,\n                offeringId_,\n                buyer,\n                amount_,\n                units_,\n                price\n            )\n        );\n        require(err == 0, \"Solver: not allowed\");\n\n        BuyParameter memory buyParameter = BuyParameter({\n            buyer: buyer,\n            amount: amount_,\n            units: units_,\n            price: price,\n            fee: fee_\n        });\n        _buy(offering, buyParameter);\n        return (amount_, fee_);\n    }\n\n    struct BuyLocalVar {\n        uint256 transferInAmount;\n        uint256 transferOutAmount;\n    }\n\n    struct BuyParameter {\n        address buyer;\n        uint256 amount;\n        uint128 units;\n        uint128 price;\n        uint128 fee;\n    }\n\n    function _buy(Offering storage offering_, BuyParameter memory parameter_)\n        internal\n    {\n        require(offering_.isValid, \"offering invalid\");\n        require(offering_.units > 0, \"sold out\");\n        require(\n            block.timestamp >= offering_.startTime &&\n                block.timestamp <= offering_.endTime,\n            \"not offering time\"\n        );\n        if (offering_.useAllowList) {\n            require(\n                _allowAddresses[offering_.voucher].contains(parameter_.buyer),\n                \"not in allow list\"\n            );\n        }\n        if (offering_.units >= offering_.min) {\n            require(parameter_.units >= offering_.min, \"min amount not met\");\n        }\n        if (offering_.max > 0) {\n            uint128 purchased = _tradeRecords[offering_.offeringId][\n                parameter_.buyer\n            ].add(parameter_.units);\n            require(purchased <= offering_.max, \"exceeds purchase limit\");\n            _tradeRecords[offering_.offeringId][parameter_.buyer] = purchased;\n        }\n\n        offering_.units = offering_.units.sub(\n            parameter_.units,\n            \"insufficient units for sale\"\n        );\n        BuyLocalVar memory vars;\n\n        vars.transferInAmount = parameter_.amount;\n        vars.transferOutAmount = parameter_.amount.sub(\n            parameter_.fee,\n            \"fee exceeds amount\"\n        );\n\n        uint256 voucherId = _transferAsset(\n            offering_,\n            parameter_.buyer,\n            vars.transferInAmount,\n            parameter_.units,\n            vars.transferOutAmount\n        );\n\n        solver.operationVerify(\n            \"Buy\",\n            abi.encode(\n                offering_.offeringId,\n                parameter_.buyer,\n                parameter_.amount,\n                parameter_.units,\n                parameter_.fee\n            )\n        );\n\n        emit Traded(\n            parameter_.buyer,\n            offering_.offeringId,\n            offering_.voucher,\n            voucherId,\n            _generateNextTradeId(),\n            uint32(block.timestamp),\n            offering_.currency,\n            uint8(offering_.priceType),\n            parameter_.price,\n            parameter_.units,\n            parameter_.amount,\n            parameter_.fee\n        );\n    }\n\n    function _transferAsset(\n        Offering memory offering_,\n        address buyer_,\n        uint256 transferInAmount_,\n        uint128 transferOutUnits_,\n        uint256 transferOutAmount_\n    ) internal returns (uint256 voucherId) {\n        ERC20TransferHelper.doTransferIn(\n            offering_.currency,\n            buyer_,\n            transferInAmount_\n        );\n\n        voucherId = _mintVoucher(offering_.offeringId, transferOutUnits_);\n\n        VNFTTransferHelper.doTransferOut(offering_.voucher, buyer_, voucherId);\n\n        ERC20TransferHelper.doTransferOut(\n            offering_.currency,\n            payable(offering_.issuer),\n            transferOutAmount_\n        );\n    }\n\n    function purchasedUnits(uint24 offeringId_, address buyer_)\n        external\n        view\n        returns (uint128)\n    {\n        return _tradeRecords[offeringId_][buyer_];\n    }\n\n    function remove(uint24 offeringId_) external virtual nonReentrant {\n        Offering memory offering = offerings[offeringId_];\n        require(offering.isValid, \"invalid offering\");\n        require(offering.issuer == msg.sender, \"only issuer\");\n        require(\n            block.timestamp < offering.startTime ||\n                block.timestamp > offering.endTime,\n            \"offering processing\"\n        );\n\n        uint256 err = solver.operationAllowed(\n            \"Remove\",\n            abi.encode(offering.voucher, offering.offeringId, offering.issuer)\n        );\n        require(err == 0, \"Solver: not allowed\");\n\n        _refund(offeringId_, offering.units);\n\n        emit Remove(\n            offering.issuer,\n            offering.offeringId,\n            offering.voucher,\n            offering.totalUnits,\n            offering.totalUnits - offering.units\n        );\n        delete offerings[offeringId_];\n    }\n\n    function _getFee(address voucher_, uint256 amount)\n        internal\n        view\n        returns (uint128)\n    {\n        Market storage market = markets[voucher_];\n\n        uint256 fee = amount.mul(uint256(market.feeRate)).div(\n            uint256(Constants.FULL_PERCENTAGE)\n        );\n        require(fee <= uint128(-1), \"Fee: exceeds uint128 max\");\n        return uint128(fee);\n    }\n\n    function getPrice(uint24 offeringId_)\n        public\n        view\n        virtual\n        returns (uint128)\n    {\n        return\n            PriceManager.price(offerings[offeringId_].priceType, offeringId_);\n    }\n\n    function totalOfferingsOfvoucher(address voucher_)\n        external\n        view\n        virtual\n        returns (uint256)\n    {\n        return _voucherOfferings[voucher_].length();\n    }\n\n    function offeringIdOfvoucherByIndex(address voucher_, uint256 index_)\n        external\n        view\n        virtual\n        returns (uint256)\n    {\n        return _voucherOfferings[voucher_].at(index_);\n    }\n\n    function _generateNextofferingId() internal returns (uint24) {\n        return nextOfferingId++;\n    }\n\n    function _generateNextTradeId() internal returns (uint24) {\n        return nextTradeId++;\n    }\n\n    function addMarket(\n        address voucher_,\n        address voucherPool_,\n        Constants.VoucherType voucherType_,\n        address asset_,\n        uint8 decimals_,\n        uint16 feeRate_,\n        bool onlyManangerOffer_\n    ) external onlyAdmin {\n        if (_vouchers.contains(voucher_)) {\n            revert(\"already added\");\n        }\n        require(isSupportVoucherType(voucherType_), \"unsupported voucher type\");\n        require(feeRate_ <= Constants.FULL_PERCENTAGE, \"invalid fee rate\");\n        markets[voucher_].voucherPool = voucherPool_;\n        markets[voucher_].isValid = true;\n        markets[voucher_].decimals = decimals_;\n        markets[voucher_].feeRate = feeRate_;\n        markets[voucher_].voucherType = voucherType_;\n        markets[voucher_].asset = asset_;\n        markets[voucher_].onlyManangerOffer = onlyManangerOffer_;\n\n        _vouchers.add(voucher_);\n\n        emit AddMarket(\n            voucher_,\n            voucherType_,\n            asset_,\n            decimals_,\n            feeRate_,\n            onlyManangerOffer_\n        );\n    }\n\n    function removeMarket(address voucher_) external onlyAdmin {\n        _vouchers.remove(voucher_);\n        delete markets[voucher_];\n        emit RemoveMarket(voucher_);\n    }\n\n    function setCurrency(address currency_, bool enable_) external onlyAdmin {\n        if (enable_) {\n            _currencies.add(currency_);\n        } else {\n            _currencies.remove(currency_);\n        }\n        emit SetCurrency(currency_, enable_);\n    }\n\n    function withdrawFee(address currency_, uint256 reduceAmount_)\n        external\n        onlyAdmin\n    {\n        ERC20TransferHelper.doTransferOut(\n            currency_,\n            payable(admin),\n            reduceAmount_\n        );\n        emit WithdrawFee(currency_, reduceAmount_);\n    }\n\n    function addAllowAddress(\n        address voucher_,\n        address[] calldata addresses_,\n        bool resetExisting_\n    ) external onlyVoucherManager(voucher_) {\n        require(markets[voucher_].isValid, \"unsupported voucher\");\n        EnumerableSetUpgradeable.AddressSet storage set = _allowAddresses[\n            voucher_\n        ];\n\n        if (resetExisting_) {\n            while (set.length() != 0) {\n                set.remove(set.at(0));\n            }\n        }\n\n        for (uint256 i = 0; i < addresses_.length; i++) {\n            set.add(addresses_[i]);\n        }\n    }\n\n    function removeAllowAddress(address voucher_, address[] calldata addresses_)\n        external\n        onlyVoucherManager(voucher_)\n    {\n        require(markets[voucher_].isValid, \"unsupported voucher\");\n        EnumerableSetUpgradeable.AddressSet storage set = _allowAddresses[\n            voucher_\n        ];\n        for (uint256 i = 0; i < addresses_.length; i++) {\n            set.remove(addresses_[i]);\n        }\n    }\n\n    function isBuyerAllowed(address voucher_, address buyer_)\n        external\n        view\n        returns (bool)\n    {\n        return _allowAddresses[voucher_].contains(buyer_);\n    }\n\n    function setVoucherManager(\n        address voucher_,\n        address[] calldata managers_,\n        bool resetExisting_\n    ) external onlyAdmin {\n        require(markets[voucher_].isValid, \"unsupported voucher\");\n        EnumerableSetUpgradeable.AddressSet storage set = _voucherManagers[\n            voucher_\n        ];\n        if (resetExisting_) {\n            while (set.length() != 0) {\n                set.remove(set.at(0));\n            }\n        }\n\n        for (uint256 i = 0; i < managers_.length; i++) {\n            set.add(managers_[i]);\n        }\n    }\n\n    function voucherManagers(address voucher_)\n        external\n        view\n        returns (address[] memory managers_)\n    {\n        managers_ = new address[](_voucherManagers[voucher_].length());\n        for (uint256 i = 0; i < _voucherManagers[voucher_].length(); i++) {\n            managers_[i] = _voucherManagers[voucher_].at(i);\n        }\n    }\n\n    function setSolver(ISolver newSolver_) public virtual onlyAdmin {\n        ISolver oldSolver = solver;\n        require(newSolver_.isSolver(), \"invalid solver\");\n        solver = newSolver_;\n\n        emit NewSolver(oldSolver, newSolver_);\n    }\n}\n"},"@solv/v2-offering-market-core/contracts/PriceManager.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ncontract PriceManager {\n    enum PriceType {\n        FIXED,\n        DECLIINING_BY_TIME\n    }\n\n    struct DecliningPrice {\n        uint128 highest; //起始价格\n        uint128 lowest; //最终价格\n        uint32 startTime;\n        uint32 duration; //持续时间\n        uint32 interval; //降价周期\n    }\n\n    //saleId => DecliningPrice\n    mapping(uint24 => DecliningPrice) internal decliningPrices;\n    mapping(uint24 => uint128) internal fixedPrices;\n\n    function price(PriceType priceType_, uint24 offeringId_)\n        internal\n        view\n        returns (uint128)\n    {\n        if (priceType_ == PriceType.FIXED) {\n            return fixedPrices[offeringId_];\n        }\n\n        if (priceType_ == PriceType.DECLIINING_BY_TIME) {\n            DecliningPrice storage price_ = decliningPrices[offeringId_];\n            if (block.timestamp >= price_.startTime + price_.duration) {\n                return price_.lowest;\n            }\n            if (block.timestamp <= price_.startTime) {\n                return price_.highest;\n            }\n\n            uint256 lastPrice = price_.highest -\n                ((block.timestamp - price_.startTime) / price_.interval) *\n                (((price_.highest - price_.lowest) / price_.duration) *\n                    price_.interval);\n            uint256 price256 = lastPrice < price_.lowest\n                ? price_.lowest\n                : lastPrice;\n            require(price256 <= uint128(-1), \"price: exceeds uint128 max\");\n\n            return uint128(price256);\n        }\n\n        revert(\"unsupported priceType\");\n    }\n\n    function setFixedPrice(uint24 offeringId_, uint128 price_) internal {\n        fixedPrices[offeringId_] = price_;\n    }\n\n    function setDecliningPrice(\n        uint24 offeringId_,\n        uint32 startTime_,\n        uint128 highest_,\n        uint128 lowest_,\n        uint32 duration_,\n        uint32 interval_\n    ) internal {\n        require(highest_ > lowest_, \"highest must greater than lowest\");\n        require(duration_ >= interval_, \"duration must greater than interval\");\n        decliningPrices[offeringId_].startTime = startTime_;\n        decliningPrices[offeringId_].highest = highest_;\n        decliningPrices[offeringId_].lowest = lowest_;\n        decliningPrices[offeringId_].duration = duration_;\n        decliningPrices[offeringId_].interval = interval_;\n    }\n\n    function getDecliningPrice(uint24 offeringId_)\n        external\n        view\n        returns (\n            uint128 highest,\n            uint128 lowest,\n            uint32 startTime,\n            uint32 duration,\n            uint32 interval\n        )\n    {\n        DecliningPrice storage decliningPrice = decliningPrices[offeringId_];\n        return (\n            decliningPrice.highest,\n            decliningPrice.lowest,\n            decliningPrice.startTime,\n            decliningPrice.duration,\n            decliningPrice.interval\n        );\n    }\n\n    function getFixedPrice(uint24 offeringId_) external view returns (uint128) {\n        return fixedPrices[offeringId_];\n    }\n}\n"},"@solv/v2-solidity-utils/contracts/access/AdminControl.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../openzeppelin/utils/ContextUpgradeable.sol\";\nimport \"../openzeppelin/proxy/Initializable.sol\";\n\nabstract contract AdminControl is Initializable, ContextUpgradeable {\n\n    event NewAdmin(address oldAdmin, address newAdmin);\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    address public admin;\n    address public pendingAdmin;\n\n    modifier onlyAdmin() {\n        require(_msgSender() == admin, \"only admin\");\n        _;\n    }\n\n    function __AdminControl_init(address admin_) internal initializer {\n        admin = admin_;\n    }\n\n    function setPendingAdmin(address newPendingAdmin_) external virtual onlyAdmin {\n        emit NewPendingAdmin(pendingAdmin, newPendingAdmin_);\n        pendingAdmin = newPendingAdmin_;        \n    }\n\n    function acceptAdmin() external virtual {\n        require(_msgSender() == pendingAdmin, \"only pending admin\");\n        emit NewAdmin(admin, pendingAdmin);\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n}"},"@solv/v2-solidity-utils/contracts/helpers/ERC20TransferHelper.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\nimport \"../misc/Constants.sol\";\n\ninterface ERC20Interface {\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary ERC20TransferHelper {\n    function doTransferIn(\n        address underlying,\n        address from,\n        uint256 amount\n    ) internal returns (uint256) {\n        if (underlying == Constants.ETH_ADDRESS) {\n            // Sanity checks\n            require(tx.origin == from || msg.sender == from, \"sender mismatch\");\n            require(msg.value == amount, \"value mismatch\");\n\n            return amount;\n        } else {\n            require(msg.value == 0, \"don't support msg.value\");\n            uint256 balanceBefore = ERC20Interface(underlying).balanceOf(\n                address(this)\n            );\n            (bool success, bytes memory data) = underlying.call(\n                abi.encodeWithSelector(\n                    ERC20Interface.transferFrom.selector,\n                    from,\n                    address(this),\n                    amount\n                )\n            );\n            require(\n                success && (data.length == 0 || abi.decode(data, (bool))),\n                \"STF\"\n            );\n\n            // Calculate the amount that was *actually* transferred\n            uint256 balanceAfter = ERC20Interface(underlying).balanceOf(\n                address(this)\n            );\n            require(\n                balanceAfter >= balanceBefore,\n                \"TOKEN_TRANSFER_IN_OVERFLOW\"\n            );\n            return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n        }\n    }\n\n    function doTransferOut(\n        address underlying,\n        address payable to,\n        uint256 amount\n    ) internal {\n        if (underlying == Constants.ETH_ADDRESS) {\n            (bool success, ) = to.call{value: amount}(new bytes(0));\n            require(success, \"STE\");\n        } else {\n            (bool success, bytes memory data) = underlying.call(\n                abi.encodeWithSelector(\n                    ERC20Interface.transfer.selector,\n                    to,\n                    amount\n                )\n            );\n            require(\n                success && (data.length == 0 || abi.decode(data, (bool))),\n                \"ST\"\n            );\n        }\n    }\n\n    function getCashPrior(address underlying_) internal view returns (uint256) {\n        if (underlying_ == Constants.ETH_ADDRESS) {\n            uint256 startingBalance = sub(address(this).balance, msg.value);\n            return startingBalance;\n        } else {\n            ERC20Interface token = ERC20Interface(underlying_);\n            return token.balanceOf(address(this));\n        }\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n}\n"},"@solv/v2-solidity-utils/contracts/helpers/VNFTTransferHelper.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface ERC721Interface {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\ninterface VNFTInterface {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 units\n    ) external returns (uint256 newTokenId);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 units,\n        bytes calldata data\n    ) external returns (uint256 newTokenId);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 targetTokenId,\n        uint256 units\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 targetTokenId,\n        uint256 units,\n        bytes calldata data\n    ) external;\n}\n\nlibrary VNFTTransferHelper {\n    function doTransferIn(\n        address underlying,\n        address from,\n        uint256 tokenId\n    ) internal {\n        ERC721Interface token = ERC721Interface(underlying);\n        token.transferFrom(from, address(this), tokenId);\n    }\n\n    function doTransferOut(\n        address underlying,\n        address to,\n        uint256 tokenId\n    ) internal {\n        ERC721Interface token = ERC721Interface(underlying);\n        token.transferFrom(address(this), to, tokenId);\n    }\n\n    function doTransferIn(\n        address underlying,\n        address from,\n        uint256 tokenId,\n        uint256 units\n    ) internal {\n        VNFTInterface token = VNFTInterface(underlying);\n        token.safeTransferFrom(from, address(this), tokenId, units, \"\");\n    }\n\n    function doTransferOut(\n        address underlying,\n        address to,\n        uint256 tokenId,\n        uint256 units\n    ) internal returns (uint256 newTokenId) {\n        VNFTInterface token = VNFTInterface(underlying);\n        newTokenId = token.safeTransferFrom(\n            address(this),\n            to,\n            tokenId,\n            units,\n            \"\"\n        );\n    }\n\n    function doTransferOut(\n        address underlying,\n        address to,\n        uint256 tokenId,\n        uint256 targetTokenId,\n        uint256 units\n    ) internal {\n        VNFTInterface token = VNFTInterface(underlying);\n        token.safeTransferFrom(\n            address(this),\n            to,\n            tokenId,\n            targetTokenId,\n            units,\n            \"\"\n        );\n    }\n}\n"},"@solv/v2-solidity-utils/contracts/math/SafeMathUpgradeable128.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable128 {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint128 a, uint128 b) internal pure returns (bool, uint128) {\n        uint128 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint128 a, uint128 b) internal pure returns (bool, uint128) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint128 a, uint128 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint128 a, uint128 b) internal pure returns (bool, uint128) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint128 a, uint128 b) internal pure returns (bool, uint128) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\n        uint128 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\n        if (a == 0) return 0;\n        uint128 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint128 a, uint128 b) internal pure returns (uint128) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"},"@solv/v2-solidity-utils/contracts/misc/Constants.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nlibrary Constants {\n    enum ClaimType {\n        LINEAR,\n        ONE_TIME,\n        STAGED\n    }\n\n    enum VoucherType {\n        STANDARD_VESTING,\n        FLEXIBLE_DATE_VESTING,\n        BOUNDING\n    }\n\n    uint32 internal constant FULL_PERCENTAGE = 10000;\n    address internal constant ETH_ADDRESS =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n}\n"},"@solv/v2-solidity-utils/contracts/openzeppelin/math/SafeMathUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"},"@solv/v2-solidity-utils/contracts/openzeppelin/proxy/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"},"@solv/v2-solidity-utils/contracts/openzeppelin/utils/AddressUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"@solv/v2-solidity-utils/contracts/openzeppelin/utils/ContextUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"},"@solv/v2-solidity-utils/contracts/openzeppelin/utils/EnumerableSetUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"},"@solv/v2-solidity-utils/contracts/openzeppelin/utils/ReentrancyGuardUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"},"@solv/v2-solver/contracts/interface/ISolver.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface ISolver {\n\n    event SetOperationPaused (\n        address product,\n        string operation,\n        bool setPaused\n    );\n\n\n    function isSolver() external pure returns (bool);\n\n    function setOperationPaused(address product_, string calldata operation_, bool setPaused_) external;\n\n    function operationAllowed(string calldata operation_, bytes calldata data_) external returns (uint256);\n\n    function operationVerify(string calldata operation_, bytes calldata data_) external returns (uint256);\n    \n}"},"contracts/InitialVestingOfferingMarket.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@solv/v2-offering-market-core/contracts/OfferingMarketCore.sol\";\n\ninterface IStandardVestingVoucher {\n    function mint(\n        uint64 term_,\n        uint256 amount_,\n        uint64[] calldata maturities_,\n        uint32[] calldata percentages_,\n        string memory originalInvestor_\n    ) external returns (uint256 slot, uint256 voucherId);\n}\n\ninterface IFlexibleDateVestingVoucher {\n    function mint(\n        address issuer_,\n        uint8 claimType_,\n        uint64 latestClaimVestingTime_,\n        uint64[] calldata terms_,\n        uint32[] calldata percentages_,\n        uint256 vestingAmount_\n    ) external returns (uint256 slot, uint256 tokenId);\n}\n\ninterface IERC20 {\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract InitialVestingOfferingMarket is OfferingMarketCore {\n    enum TimeType {\n        LATEST_START_TIME,\n        ON_BUY,\n        UNDECIDED\n    }\n\n    struct MintParameter {\n        Constants.ClaimType claimType;\n        uint64 latestStartTime;\n        TimeType timeType;\n        uint64[] terms;\n        uint32[] percentages;\n    }\n\n    //key: offeringId\n    mapping(uint24 => MintParameter) internal _mintParameters;\n\n    function mintParameters(uint24 offeringId_)\n        external\n        view\n        returns (MintParameter memory)\n    {\n        return _mintParameters[offeringId_];\n    }\n\n    function offer(\n        address voucher_,\n        address currency_,\n        uint128 units_,\n        uint128 min_,\n        uint128 max_,\n        uint32 startTime_,\n        uint32 endTime_,\n        bool useAllowList_,\n        PriceManager.PriceType priceType_,\n        bytes calldata priceData_,\n        MintParameter calldata mintParameter_\n    ) external returns (uint24 offeringId) {\n        Market memory market = markets[voucher_];\n\n        if (mintParameter_.timeType == TimeType.UNDECIDED) {\n            require(\n                market.voucherType ==\n                    Constants.VoucherType.FLEXIBLE_DATE_VESTING,\n                \"invalid time type\"\n            );\n        }\n\n        require(\n            mintParameter_.terms.length == mintParameter_.percentages.length,\n            \"invalid terms and percentages\"\n        );\n        // latestStartTime should not be later than 2100/01/01 00:00:00\n        require(mintParameter_.latestStartTime < 4102416000, \"latest start time too late\");\n        // number of stages should not be more than 50\n        require(mintParameter_.percentages.length <= 50, \"too many stages\");\n\n        uint256 sumOfPercentages = 0;\n        for (uint256 i = 0; i < mintParameter_.percentages.length; i++) {\n            // value of each term should not be larger than 10 years\n            require(mintParameter_.terms[i] <= 315360000, \"term value too large\");\n            // value of each percentage should not be larger than 10000\n            require(mintParameter_.percentages[i] <= Constants.FULL_PERCENTAGE, \"percentage value too large\");\n            sumOfPercentages += mintParameter_.percentages[i];\n        }\n        require(\n            sumOfPercentages == Constants.FULL_PERCENTAGE,\n            \"not full percentage\"\n        );\n\n        require(\n            (mintParameter_.claimType == Constants.ClaimType.LINEAR &&\n                mintParameter_.percentages.length == 1) ||\n                (mintParameter_.claimType == Constants.ClaimType.ONE_TIME &&\n                    mintParameter_.percentages.length == 1) ||\n                (mintParameter_.claimType == Constants.ClaimType.STAGED &&\n                    mintParameter_.percentages.length > 1),\n            \"invalid params\"\n        );\n\n        ERC20TransferHelper.doTransferIn(market.asset, msg.sender, units_);\n\n        offeringId = OfferingMarketCore._offer(\n            voucher_,\n            currency_,\n            units_,\n            min_,\n            max_,\n            startTime_,\n            endTime_,\n            useAllowList_,\n            priceType_,\n            priceData_\n        );\n        _mintParameters[offeringId] = mintParameter_;\n    }\n\n    function _mintVoucher(uint24 offeringId_, uint128 units_)\n        internal\n        virtual\n        override\n        returns (uint256 voucherId)\n    {\n        Offering memory offering = offerings[offeringId_];\n        MintParameter memory parameter = _mintParameters[offeringId_];\n        IERC20(markets[offering.voucher].asset).approve(\n            markets[offering.voucher].voucherPool,\n            units_\n        );\n        if (parameter.timeType != TimeType.UNDECIDED) {\n            uint64 term;\n            uint64[] memory maturities = new uint64[](parameter.terms.length);\n            IStandardVestingVoucher vestingVoucher = IStandardVestingVoucher(\n                offering.voucher\n            );\n            uint64 startTime = parameter.timeType == TimeType.LATEST_START_TIME\n                ? parameter.latestStartTime\n                : uint64(block.timestamp);\n\n            // The values of `startTime` and `terms` are read from storage, and their values have been\n            // checked before stored when offering a new IVO, so there is no need here to check the \n            // overflow of the value of `term` and `maturities`.\n            for (uint256 i = 0; i < parameter.terms.length; i++) {\n                term += parameter.terms[i];\n                maturities[i] = startTime + term;\n            }\n\n            if (parameter.claimType == Constants.ClaimType.STAGED) {\n                //standard vesting voucher: staged term should be not included terms[0]\n                term -= parameter.terms[0];\n            } else if (parameter.claimType == Constants.ClaimType.ONE_TIME) {\n                //standard vesting voucher: one-time term should be 0\n                term = 0;\n            }\n\n            (, voucherId) = vestingVoucher.mint(\n                term,\n                units_,\n                maturities,\n                parameter.percentages,\n                \"IVO\"\n            );\n        } else {\n            IFlexibleDateVestingVoucher offeringVoucher = IFlexibleDateVestingVoucher(\n                    offering.voucher\n                );\n            (, voucherId) = offeringVoucher.mint(\n                offering.issuer,\n                uint8(parameter.claimType),\n                parameter.latestStartTime,\n                parameter.terms,\n                parameter.percentages,\n                units_\n            );\n        }\n    }\n\n    function _refund(uint24 offeringId_, uint128 units_)\n        internal\n        virtual\n        override\n    {\n        ERC20TransferHelper.doTransferOut(\n            markets[offerings[offeringId_].voucher].asset,\n            payable(offerings[offeringId_].issuer),\n            units_\n        );\n    }\n\n    function isSupportVoucherType(Constants.VoucherType voucherType_)\n        public\n        pure\n        override\n        returns (bool)\n    {\n        return (voucherType_ == Constants.VoucherType.FLEXIBLE_DATE_VESTING ||\n            voucherType_ == Constants.VoucherType.STANDARD_VESTING);\n    }\n}\n"}}}