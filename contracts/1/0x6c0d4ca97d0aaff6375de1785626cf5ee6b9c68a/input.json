{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ArcxLiquidationWsteth.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nlibrary SafeMath {\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, 'SafeMath: addition overflow');\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, 'SafeMath: subtraction overflow');\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, 'SafeMath: multiplication overflow');\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, 'SafeMath: division by zero');\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, 'SafeMath: modulo by zero');\n  }\n\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IWeth is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint amount) external;\n}\n\ninterface IWstEth is IERC20{\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n    function stETH() external view returns (IERC20);\n}\n\n\ninterface IUniswapV2Pair{\n\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\nlibrary Math {\n    using SafeMath for uint256;\n\n    // ============ Library Functions ============\n\n    /*\n     * Return target * (numerator / denominator).\n     */\n    function getPartial(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return target.mul(numerator).div(denominator);\n    }\n\n    function to128(\n        uint256 number\n    )\n        internal\n        pure\n        returns (uint128)\n    {\n        uint128 result = uint128(number);\n        require(\n            result == number,\n            \"Math: Unsafe cast to uint128\"\n        );\n        return result;\n    }\n\n    function min(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function max(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a > b ? a : b;\n    }\n}\n\nlibrary Decimal {\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    uint256 constant BASE = 10**18;\n\n    // ============ Structs ============\n\n    struct D256 {\n        uint256 value;\n    }\n\n    // ============ Functions ============\n\n    function one()\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: BASE });\n    }\n\n    function onePlus(\n        D256 memory d\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: d.value.add(BASE) });\n    }\n\n    function mul(\n        uint256 target,\n        D256 memory d\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(target, d.value, BASE);\n    }\n\n    function mul(\n        D256 memory d1,\n        D256 memory d2\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return Decimal.D256({ value: Math.getPartial(d1.value, d2.value, BASE) });\n    }\n\n    function div(\n        uint256 target,\n        D256 memory d\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(target, BASE, d.value);\n    }\n\n    function add(\n        D256 memory d,\n        uint256 amount\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: d.value.add(amount) });\n    }\n\n    function sub(\n        D256 memory d,\n        uint256 amount\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: d.value.sub(amount) });\n    }\n\n}\n\ninterface IStructs{\n    enum Operation {\n        Open,\n        Borrow,\n        Repay,\n        Liquidate,\n        TransferOwnership\n    }\n\n    struct Principal {\n        bool sign; // true if positive\n        uint256 value;\n    }\n\n    struct Position {\n        address owner;\n        Principal collateralAmount;\n        Principal borrowedAmount;\n    }\n\n    struct OperationParams {\n        uint256 id;\n        uint256 amountOne;\n        uint256 amountTwo;\n        address addressOne;\n    }\n\n}\n\ninterface IOracle is IStructs{\n     function fetchCurrentPrice()\n        external\n        view\n        returns (Decimal.D256 memory);\n}\n\ninterface IarcxPool is IStructs{\n\n    function operateAction(\n        Operation operation,\n        OperationParams memory params\n    ) external ;\n\n    function getCurrentOracle() external view returns(address);\n\n    function calculateLiquidationPrice(Decimal.D256 memory currentPrice) external view returns(Decimal.D256 memory);\n\n    function calculateCollateralDelta(\n        Principal memory parSupply,\n        uint256 borrowedAmount,\n        Decimal.D256 memory price\n    )\n        external\n        view\n        returns (Principal memory);\n\n    function getPosition(uint256 position) external view returns (Position memory);\n\n    function getFees()\n    external\n    view\n    returns (\n        Decimal.D256 memory _liquidationUserFee,\n        Decimal.D256 memory _liquidationArcRatio\n    );\n}\n\ninterface ICurvePool {\n\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\n\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256); \n    // i = 1 to send, j = 0 to receive, \n}\n\ncontract ArcxLiquidations is IStructs {\n    \n    using SafeMath for uint256;\n    using Math for uint256;\n\n    IUniswapV2Pair stablexPair = IUniswapV2Pair(address(0x1BccE9E2Fd56E8311508764519d28E6ec22D4a47));\n\n    IUniswapV2Pair ethUsdcPair = IUniswapV2Pair(address(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc));\n\n    IarcxPool arcxPool = IarcxPool(address(0xC466Ec062D554BEB42f1766488F7345261C63616));\n\n    IERC20 stablex = IERC20(address(0xcD91538B91B4ba7797D39a2f66E63810b50A33d0));\n\n    IERC20 usdc = IERC20(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48));\n\n    IWstEth wsteth = IWstEth(address(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0));\n\n    IWeth weth = IWeth(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\n    \n    ICurvePool curvePool = ICurvePool(address(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022));\n\n    address owner;\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    fallback() external payable {\n        \n    }\n    \n    receive() external payable {\n        \n    }\n\n    function uniswapV2Call(address pair, uint256 amount0Out, uint256 amount1Out, bytes memory data) external {\n\n        if(msg.sender != address(stablexPair)){\n            return;\n        }\n\n        (uint256 amount, uint256 amountUSDC, uint256 position) = abi.decode(data, (uint256, uint256, uint256));\n\n        OperationParams memory params = OperationParams({\n            id: position,\n            amountOne: 1,\n            amountTwo: 1,\n            addressOne: address(0)\n        });\n\n        arcxPool.operateAction(Operation.Liquidate, params);\n\n        require(wsteth.balanceOf(address(this)) > 0, \"!no collateral received\");\n\n        // unwraps wsteth\n        uint256 stethBalance = wsteth.unwrap(wsteth.balanceOf(address(this)));\n        // get amountOut for steth on curve\n        uint256 ethAmountOut = curvePool.get_dy(1, 0, stethBalance);\n        // swap steth for eth on curve\n        curvePool.exchange(1, 0, stethBalance, ethAmountOut);\n\n        (uint256 _amount0Out, uint256 _amount1Out) = ethUsdcPair.token0() == address(weth)?\n            (uint256(0), amountUSDC):(amountUSDC, uint256(0));\n\n        (uint256 reserve0, uint256 reserve1, ) = ethUsdcPair.getReserves();\n\n        (uint256 reserveIn, uint256 reserveOut) = ethUsdcPair.token0() == address(weth)? \n        (reserve0, reserve1) : (reserve1, reserve0); \n        \n        uint256 wethAmount = getAmountIn(amountUSDC, reserveIn, reserveOut);\n\n        weth.deposit{value: wethAmount}();\n\n        bytes memory empty;\n\n        weth.transfer(address(ethUsdcPair), wethAmount);\n\n        ethUsdcPair.swap(_amount0Out, _amount1Out, address(this), empty);\n\n        usdc.transfer(msg.sender, amountUSDC);\n        \n    }\n\n    function withdrawErc20(address token) external {\n\n        require(msg.sender == owner, \"!owner\");\n        \n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\n        \n    }\n    \n    function withdraw() external {\n        \n        require(msg.sender == owner, \"!owner\");\n        \n        payable(msg.sender).transfer(address(this).balance);\n        \n    }\n\n\n    function getAmountOfStableXNeeded(uint256 posIndex) public view returns(uint256 borrowToLiquidate){\n\n        Decimal.D256 memory currentPrice = IOracle(arcxPool.getCurrentOracle()).fetchCurrentPrice();\n\n        Decimal.D256 memory liquidationPrice = arcxPool.calculateLiquidationPrice(currentPrice);\n\n        Position memory position = arcxPool.getPosition(posIndex);\n\n        Principal memory collateralDelta = arcxPool.calculateCollateralDelta(\n            position.collateralAmount,\n            position.borrowedAmount.value,\n            liquidationPrice\n        );\n\n        (Decimal.D256 memory liquidateUserFees, Decimal.D256 memory liquidateArcxFees) = arcxPool.getFees();\n\n        collateralDelta.value = Decimal.mul(\n            collateralDelta.value,\n            Decimal.add(\n                liquidateUserFees,\n                Decimal.one().value\n            )\n        );\n\n\n        borrowToLiquidate = Decimal.mul(\n            collateralDelta.value,\n            liquidationPrice\n        );\n\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) private returns (uint amountIn) {\n        require(amountOut > 0, 'ArcxLiquidation: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'ArcxLiquidation: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n\n    function run(uint256 posIndex) external {\n\n        require(msg.sender == owner, \"!owner\");\n\n        uint256 amount = getAmountOfStableXNeeded(posIndex);\n\n        (uint256 amount0Out, uint256 amount1Out) = stablexPair.token0() == address(stablex)?\n            (amount, uint256(0)):(uint256(0), amount);\n\n        (uint256 reserve0, uint256 reserve1, ) = stablexPair.getReserves();\n\n        (uint256 reserveIn, uint256 reserveOut) = stablexPair.token0() == address(stablex)? \n        (reserve1, reserve0) : (reserve0, reserve1); \n\n        uint256 amountIn = getAmountIn(amount, reserveIn, reserveOut);\n\n        bytes memory data = abi.encode(amount, amountIn, posIndex);\n\n        stablexPair.swap(amount0Out, amount1Out, address(this), data);\n\n    }\n\n\n}\n\n"}}}