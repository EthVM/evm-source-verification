{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/TattooMoneyV1toV2SWAP.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.7;\n\n// TattooMoney.io TattooMoney Token SWAP Contract\n//\n// USE ONLY OWN WALLET (Metamask, TrustWallet, Trezor, Ledger...)\n// DO NOT DO DIRECT SEND OR FROM EXCHANGES OR ANY SERVICES\n//\n// Use ONLY ETH network, ERC20 TAT2 tokens (Not Binance/Tron/whatever!)\n//\n// Set approval to contract address before using swap!\n//\n// DO NOT SEND ANY TOKENS DIRECTLY - THEY WILL BE GONE FOREVER!\n//\n// Use swap function!\n\nimport \"./interfaces.sol\";\n\ncontract TattooMoneyV1toV2SWAP {\n\n    // addresses of tokens\n    address public immutable newtat2;\n    uint8 public constant newtat2decimals = 18;\n    address public immutable oldtat2;\n    uint8 public constant oldtat2decimals = 6;\n\n    address public owner;\n    address public newOwner;\n\n    string constant ERR_TRANSFER = \"Token transfer failed\";\n\n    event Swapped(address indexed sender, uint256 indexed amount, uint256 indexed newamount);\n    event Tokens(uint256 indexed amount);\n    event Burned(uint256 indexed amount);\n\n    /**\n    Contract constructor\n    @param _owner adddress of contract owner\n    @param _oldtat2 adddress of old contract\n    @param _newtat2 adddress of new contract\n     */\n\n    constructor(\n        address _owner,\n        address _oldtat2,\n        address _newtat2\n    ) {\n        owner = _owner;\n        oldtat2 = _oldtat2;\n        newtat2 = _newtat2;\n\n        /**\n        mainnet:\n        oldTAT2=0x960773318c1aeab5da6605c49266165af56435fa; // Old Token SmartContract\n        newTAT2=0xb487d0328b109e302b9d817b6f46Cbd738eA08C2;  // new Token SmartContract\n        */\n    }\n\n    /**\n    Get NEW TAT2, use approve/transferFrom\n    @param amount number of old TAT2\n    */\n    function swap(uint256 amount) external {\n        uint8 decimals = newtat2decimals - oldtat2decimals;\n        uint256 newamount = amount * (10 ** decimals);\n        require(\n            INterfaces(oldtat2).transferFrom(msg.sender, address(this), amount),\n            ERR_TRANSFER\n        );\n        require(\n            INterfaces(newtat2).transfer(msg.sender, newamount),\n            ERR_TRANSFER\n        );\n        emit Swapped(msg.sender, amount, newamount);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only for contract Owner\");\n        _;\n    }\n\n    /// Let's burn OLD tokens\n    function burn() external onlyOwner {\n      uint256 amt = INterfaces(oldtat2).balanceOf(address(this));\n      emit Tokens(amt);\n      require(\n          INterfaces(oldtat2).transfer(address(0), amt),\n          ERR_TRANSFER\n      );\n      emit Burned(amt);\n    }\n\n    /// we can recover any ERC20\n    function recoverErc20(address token) external onlyOwner {\n        uint256 amt = INterfaces(token).balanceOf(address(this));\n        if (amt > 0) {\n            INterfacesNoR(token).transfer(owner, amt); // use broken ERC20 to ignore return value\n        }\n    }\n\n    /// be preapared for everything, ETH recovery\n    function recoverEth() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    function changeOwner(address _newOwner) external onlyOwner {\n        newOwner = _newOwner;\n    }\n\n    function acceptOwnership() external {\n        require(\n            msg.sender != address(0) && msg.sender == newOwner,\n            \"Only NewOwner\"\n        );\n        newOwner = address(0);\n        owner = msg.sender;\n    }\n}\n\n// by Patrick\n"},"contracts/interfaces.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n// Interfaces for contract interaction\ninterface INterfaces {\n    function balanceOf(address) external returns (uint256);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n}\n\n// For tokens that do not return true on transfers eg. USDT\ninterface INterfacesNoR {\n    function transfer(address, uint256) external;\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external;\n}\n"}}}