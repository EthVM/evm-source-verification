{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"comp.sol":{"content":"\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\ninterface TokenInterface {\n    function approve(address, uint256) external;\n    function transfer(address, uint) external;\n    function transferFrom(address, address, uint) external;\n    function deposit() external payable;\n    function withdraw(uint) external;\n    function balanceOf(address) external view returns (uint);\n    function decimals() external view returns (uint);\n}\n\ninterface MemoryInterface {\n    function getUint(uint id) external returns (uint num);\n    function setUint(uint id, uint val) external;\n}\n\ninterface InstaMapping {\n    function cTokenMapping(address) external view returns (address);\n    function gemJoinMapping(bytes32) external view returns (address);\n}\n\ninterface AccountInterface {\n    function enable(address) external;\n    function disable(address) external;\n    function isAuth(address) external view returns (bool);\n}\n\n\n// File contracts/mainnet/common/stores.sol\n\nabstract contract Stores {\n\n  /**\n   * @dev Return ethereum address\n   */\n  address constant internal ethAddr = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  /**\n   * @dev Return Wrapped ETH address\n   */\n  address constant internal wethAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n  /**\n   * @dev Return memory variable address\n   */\n  MemoryInterface constant internal instaMemory = MemoryInterface(0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F);\n\n  /**\n   * @dev Return InstaDApp Mapping Addresses\n   */\n  InstaMapping constant internal instaMapping = InstaMapping(0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88);\n\n  /**\n   * @dev Get Uint value from InstaMemory Contract.\n   */\n  function getUint(uint getId, uint val) internal returns (uint returnVal) {\n    returnVal = getId == 0 ? val : instaMemory.getUint(getId);\n  }\n\n  /**\n  * @dev Set Uint value in InstaMemory Contract.\n  */\n  function setUint(uint setId, uint val) virtual internal {\n    if (setId != 0) instaMemory.setUint(setId, val);\n  }\n\n}\n\n\n// File @openzeppelin/contracts/math/SafeMath.sol@v3.4.1\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n// File contracts/mainnet/common/math.sol\n\ncontract DSMath {\n  uint constant WAD = 10 ** 18;\n  uint constant RAY = 10 ** 27;\n\n  function add(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.add(x, y);\n  }\n\n  function sub(uint x, uint y) internal virtual pure returns (uint z) {\n    z = SafeMath.sub(x, y);\n  }\n\n  function mul(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.mul(x, y);\n  }\n\n  function div(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.div(x, y);\n  }\n\n  function wmul(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.add(SafeMath.mul(x, y), WAD / 2) / WAD;\n  }\n\n  function wdiv(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.add(SafeMath.mul(x, WAD), y / 2) / y;\n  }\n\n  function rdiv(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.add(SafeMath.mul(x, RAY), y / 2) / y;\n  }\n\n  function rmul(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.add(SafeMath.mul(x, y), RAY / 2) / RAY;\n  }\n\n  function toInt(uint x) internal pure returns (int y) {\n    y = int(x);\n    require(y >= 0, \"int-overflow\");\n  }\n\n  function toRad(uint wad) internal pure returns (uint rad) {\n    rad = mul(wad, 10 ** 27);\n  }\n\n}\n\n\n// File contracts/mainnet/common/basic.sol\n\n\nabstract contract Basic is DSMath, Stores {\n\n    function convert18ToDec(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = (_amt / 10 ** (18 - _dec));\n    }\n\n    function convertTo18(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = mul(_amt, 10 ** (18 - _dec));\n    }\n\n    function getTokenBal(TokenInterface token) internal view returns(uint _amt) {\n        _amt = address(token) == ethAddr ? address(this).balance : token.balanceOf(address(this));\n    }\n\n    function getTokensDec(TokenInterface buyAddr, TokenInterface sellAddr) internal view returns(uint buyDec, uint sellDec) {\n        buyDec = address(buyAddr) == ethAddr ?  18 : buyAddr.decimals();\n        sellDec = address(sellAddr) == ethAddr ?  18 : sellAddr.decimals();\n    }\n\n    function encodeEvent(string memory eventName, bytes memory eventParam) internal pure returns (bytes memory) {\n        return abi.encode(eventName, eventParam);\n    }\n\n    function changeEthAddress(address buy, address sell) internal pure returns(TokenInterface _buy, TokenInterface _sell){\n        _buy = buy == ethAddr ? TokenInterface(wethAddr) : TokenInterface(buy);\n        _sell = sell == ethAddr ? TokenInterface(wethAddr) : TokenInterface(sell);\n    }\n\n    function convertEthToWeth(bool isEth, TokenInterface token, uint amount) internal {\n        if(isEth) token.deposit{value: amount}();\n    }\n\n    function convertWethToEth(bool isEth, TokenInterface token, uint amount) internal {\n       if(isEth) {\n            token.approve(address(token), amount);\n            token.withdraw(amount);\n        }\n    }\n}\n\n\n// File contracts/mainnet/connectors/COMP/interface.sol\n\ninterface ComptrollerInterface {\n    function claimComp(address holder) external;\n    function claimComp(address holder, address[] calldata) external;\n    function claimComp(address[] calldata holders, address[] calldata cTokens, bool borrowers, bool suppliers) external;\n}\n\ninterface COMPInterface {\n    function delegate(address delegatee) external;\n    function delegates(address) external view returns(address);\n}\n\ninterface CompoundMappingInterface {\n    function cTokenMapping(string calldata tokenId) external view returns (address);\n    function getMapping(string calldata tokenId) external view returns (address, address);\n}\n\n\n// File contracts/mainnet/connectors/COMP/helpers.sol\n\n\nabstract contract Helpers is DSMath, Basic {\n    /**\n     * @dev Compound Comptroller\n     */\n    ComptrollerInterface internal constant troller = ComptrollerInterface(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n\n    /**\n     * @dev COMP Token\n     */\n    COMPInterface internal constant compToken = COMPInterface(0xc00e94Cb662C3520282E6f5717214004A7f26888);\n\n    /**\n     * @dev Compound Mapping\n     */\n    CompoundMappingInterface internal constant compMapping = CompoundMappingInterface(0xA8F9D4aA7319C54C04404765117ddBf9448E2082);\n\n    function getMergedCTokens(\n        string[] calldata supplyIds,\n        string[] calldata borrowIds\n    ) internal view returns (address[] memory ctokens, bool isBorrow, bool isSupply) {\n        uint _supplyLen = supplyIds.length;\n        uint _borrowLen = borrowIds.length;\n        uint _totalLen = add(_supplyLen, _borrowLen);\n        ctokens = new address[](_totalLen);\n\n        if(_supplyLen > 0) {\n            isSupply = true;\n            for (uint i = 0; i < _supplyLen; i++) {\n                (address token, address cToken) = compMapping.getMapping(supplyIds[i]);\n                require(token != address(0) && cToken != address(0), \"invalid token/ctoken address\");\n\n                ctokens[i] = cToken;\n            }\n        }\n\n        if(_borrowLen > 0) {\n            isBorrow = true;\n            for (uint i = 0; i < _borrowLen; i++) {\n                (address token, address cToken) = compMapping.getMapping(borrowIds[i]);\n                require(token != address(0) && cToken != address(0), \"invalid token/ctoken address\");\n\n                ctokens[_supplyLen + i] = cToken;\n            }\n        }\n    }\n}\n\n\n// File contracts/mainnet/connectors/COMP/events.sol\n\ncontract Events {\n    event LogClaimedComp(uint256 compAmt, uint256 setId);\n    event LogDelegate(address delegatee);\n}\n\n\n// File contracts/mainnet/connectors/COMP/main.sol\n\n\nabstract contract CompResolver is Events, Helpers {\n\n    /**\n     * @dev Claim Accrued COMP Token.\n     * @notice Claim Accrued COMP Token.\n     * @param setId ID stores the amount of COMP claimed.\n    */\n    function ClaimComp(uint256 setId) external payable {\n        TokenInterface _compToken = TokenInterface(address(compToken));\n        uint intialBal = _compToken.balanceOf(address(this));\n        troller.claimComp(address(this));\n        uint finalBal = _compToken.balanceOf(address(this));\n        uint amt = sub(finalBal, intialBal);\n\n        setUint(setId, amt);\n\n        emit LogClaimedComp(amt, setId);\n    }\n\n    /**\n     * @dev Claim Accrued COMP Token.\n     * @notice Claim Accrued COMP Token.\n     * @param tokenIds Array of supplied and borrowed token IDs.\n     * @param setId ID stores the amount of COMP claimed.\n    */\n    function ClaimCompTwo(string[] calldata tokenIds, uint256 setId) external payable {\n        uint _len = tokenIds.length;\n        address[] memory ctokens = new address[](_len);\n        for (uint i = 0; i < _len; i++) {\n            (address token, address cToken) = compMapping.getMapping(tokenIds[i]);\n            require(token != address(0) && cToken != address(0), \"invalid token/ctoken address\");\n\n            ctokens[i] = cToken;\n        }\n\n        TokenInterface _compToken = TokenInterface(address(compToken));\n        uint intialBal = _compToken.balanceOf(address(this));\n        troller.claimComp(address(this), ctokens);\n        uint finalBal = _compToken.balanceOf(address(this));\n        uint amt = sub(finalBal, intialBal);\n\n        setUint(setId, amt);\n\n        emit LogClaimedComp(amt, setId);\n    }\n\n    /**\n     * @dev Claim Accrued COMP Token.\n     * @notice Claim Accrued COMP Token.\n     * @param supplyTokenIds Array of supplied tokenIds.\n     * @param borrowTokenIds Array of borrowed tokenIds.\n     * @param setId ID stores the amount of COMP claimed.\n    */\n    function ClaimCompThree(string[] calldata supplyTokenIds, string[] calldata borrowTokenIds, uint256 setId) external payable {\n      (address[] memory ctokens, bool isBorrow, bool isSupply) = getMergedCTokens(supplyTokenIds, borrowTokenIds);\n\n        address[] memory holders = new address[](1);\n        holders[0] = address(this);\n\n        TokenInterface _compToken = TokenInterface(address(compToken));\n        uint intialBal = _compToken.balanceOf(address(this));\n        troller.claimComp(holders, ctokens, isBorrow, isSupply);\n        uint finalBal = _compToken.balanceOf(address(this));\n        uint amt = sub(finalBal, intialBal);\n\n        setUint(setId, amt);\n\n        emit LogClaimedComp(amt, setId);\n    }\n\n    /**\n     * @dev Delegate votes.\n     * @notice Delegate votes.\n     * @param delegatee The address to delegate the votes to.\n    */\n    function delegate(address delegatee) external payable {\n        require(compToken.delegates(address(this)) != delegatee, \"Already delegated to same delegatee.\");\n\n        compToken.delegate(delegatee);\n\n        emit LogDelegate(delegatee);\n    }\n}\n\ncontract ConnectCOMP is CompResolver {\n    /**\n     * @dev Connector ID and Type.\n     */\n    function connectorID() public pure returns(uint _type, uint _id) {\n        (_type, _id) = (1, 91);\n    }\n\n    string public constant name = \"COMP-v1.1\";\n}\n"}}}