{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/AssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\nimport './Outcome.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport './interfaces/IAssetHolder.sol';\n\n/**\n * @dev An implementation of the IAssetHolder interface. The AssetHolder contract escrows ETH or tokens against state channels. It allows assets to be internally accounted for, and ultimately prepared for transfer from one channel to other channel and/or external destinations, as well as for guarantees to be claimed. Note there is no deposit function and the _transferAsset function is unimplemented; inheriting contracts should implement these functions in a manner appropriate to the asset type (e.g. ETH or ERC20 tokens).\n */\ncontract AssetHolder is IAssetHolder {\n    using SafeMath for uint256;\n\n    address public AdjudicatorAddress;\n\n    mapping(bytes32 => uint256) public holdings;\n\n    mapping(bytes32 => bytes32) public assetOutcomeHashes;\n\n    // **************\n    // External methods\n    // **************\n\n    /**\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     * @param indices Array with each entry denoting the index of a destination to transfer funds to.\n     */\n    function transfer(\n        bytes32 fromChannelId,\n        bytes calldata allocationBytes,\n        uint256[] memory indices\n    ) external override {\n        // checks\n        _requireIncreasingIndices(indices);\n        _requireCorrectAllocationHash(fromChannelId, allocationBytes);\n        // effects and interactions\n        _transfer(fromChannelId, allocationBytes, indices);\n    }\n\n    /**\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. Checks against the storage in this contract.\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. Checks against the storage in this contract.\n     * @param channelId Unique identifier for a state channel.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     */\n    function transferAll(bytes32 channelId, bytes calldata allocationBytes) external {\n        // checks\n        _requireCorrectAllocationHash(channelId, allocationBytes);\n        // effects and interactions\n        _transfer(channelId, allocationBytes, new uint256[](0));\n    }\n\n    /**\n     * @notice Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\n     * @dev Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\n     * @param guaranteeBytes The abi.encode of Outcome.Guarantee\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\n     * @param destination External destination or channel to transfer funds *to*.\n     */\n    function claim(\n        bytes32 guarantorChannelId,\n        bytes calldata guaranteeBytes,\n        bytes calldata allocationBytes,\n        bytes32 destination\n    ) external {\n        // checks\n        _requireCorrectGuaranteeHash(guarantorChannelId, guaranteeBytes);\n        Outcome.Guarantee memory guarantee = abi.decode(guaranteeBytes, (Outcome.Guarantee));\n        _requireCorrectAllocationHash(guarantee.targetChannelId, allocationBytes);\n        // effects and interactions\n        _claim(guarantorChannelId, guarantee, allocationBytes, destination);\n    }\n\n    /**\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\n     * @param guaranteeBytes The abi.encode of Outcome.Guarantee\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\n     */\n    function claimAll(\n        bytes32 guarantorChannelId,\n        bytes calldata guaranteeBytes,\n        bytes calldata allocationBytes\n    ) external override {\n        // checks\n        _requireCorrectGuaranteeHash(guarantorChannelId, guaranteeBytes);\n        Outcome.Guarantee memory guarantee = abi.decode(guaranteeBytes, (Outcome.Guarantee));\n        _requireCorrectAllocationHash(guarantee.targetChannelId, allocationBytes);\n        // effects and interactions\n        _claimAll(guarantorChannelId, guarantee, allocationBytes);\n    }\n\n    // **************\n    // Permissioned methods\n    // **************\n\n    modifier AdjudicatorOnly {\n        require(msg.sender == AdjudicatorAddress, 'Only NitroAdjudicator authorized');\n        _;\n    }\n\n    /**\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned.\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned.\n     * @param channelId Unique identifier for a state channel.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     */\n    function transferAllAdjudicatorOnly(bytes32 channelId, bytes calldata allocationBytes)\n        external\n        virtual\n        AdjudicatorOnly\n    {\n        // no checks\n        //\n        // effects and interactions\n        _transfer(channelId, allocationBytes, new uint256[](0));\n    }\n\n    /**\n     * @notice Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping.\n     * @dev Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping.\n     * @param channelId Unique identifier for a state channel.\n     * @param assetOutcomeHash The keccak256 of the abi.encode of the Outcome.\n     */\n    function setAssetOutcomeHash(bytes32 channelId, bytes32 assetOutcomeHash)\n        external\n        AdjudicatorOnly\n    {\n        _setAssetOutcomeHash(channelId, assetOutcomeHash);\n    }\n\n    // **************\n    // Internal methods\n    // **************\n\n    function _computeNewAllocation(\n        uint256 initialHoldings,\n        Outcome.AllocationItem[] memory allocation,\n        uint256[] memory indices\n    )\n        internal\n        pure\n        returns (\n            Outcome.AllocationItem[] memory newAllocation,\n            bool safeToDelete,\n            uint256[] memory payouts,\n            uint256 totalPayouts\n        )\n    {\n        // `indices == []` means \"pay out to all\"\n        // Note: by initializing payouts to be an array of fixed length, its entries are initialized to be `0`\n        payouts = new uint256[](indices.length > 0 ? indices.length : allocation.length);\n        totalPayouts = 0;\n        newAllocation = new Outcome.AllocationItem[](allocation.length);\n        safeToDelete = true; // switched to false if there is an item remaining with amount > 0\n        uint256 surplus = initialHoldings; // virtual funds available during calculation\n        uint256 k = 0; // indexes the `indices` array\n\n        // loop over allocations and decrease surplus\n        for (uint256 i = 0; i < allocation.length; i++) {\n            // copy destination part\n            newAllocation[i].destination = allocation[i].destination;\n            // compute new amount part\n            uint256 affordsForDestination = min(allocation[i].amount, surplus);\n            if ((indices.length == 0) || ((k < indices.length) && (indices[k] == i))) {\n                // found a match\n                // reduce the current allocationItem.amount\n                newAllocation[i].amount = allocation[i].amount - affordsForDestination;\n                // increase the relevant payout\n                payouts[k] = affordsForDestination;\n                totalPayouts += affordsForDestination;\n                // move on to the next supplied index\n                ++k;\n            } else {\n                newAllocation[i].amount = allocation[i].amount;\n            }\n            if (newAllocation[i].amount != 0) safeToDelete = false;\n            // decrease surplus by the current amount if possible, else surplus goes to zero\n            surplus -= affordsForDestination;\n        }\n    }\n\n    /**\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries. Does not check allocationBytes against on chain storage.\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries. Does not check allocationBytes against on chain storage.\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     * @param indices Array with each entry denoting the index of a destination to transfer funds to. Should be in increasing order.\n     */\n    function _transfer(\n        bytes32 fromChannelId,\n        bytes memory allocationBytes,\n        uint256[] memory indices\n    ) internal {\n        Outcome.AllocationItem[] memory allocation = abi.decode(\n            allocationBytes,\n            (Outcome.AllocationItem[])\n        );\n        uint256 initialHoldings = holdings[fromChannelId];\n\n        (\n            Outcome.AllocationItem[] memory newAllocation,\n            bool safeToDelete,\n            uint256[] memory payouts,\n            uint256 totalPayouts\n        ) = _computeNewAllocation(initialHoldings, allocation, indices);\n\n        // *******\n        // EFFECTS\n        // *******\n\n        holdings[fromChannelId] = initialHoldings.sub(totalPayouts); // expect gas rebate if this is set to 0\n\n        if (safeToDelete) {\n            delete assetOutcomeHashes[fromChannelId];\n        } else {\n            assetOutcomeHashes[fromChannelId] = keccak256(\n                abi.encode(\n                    Outcome.AssetOutcome(\n                        uint8(Outcome.AssetOutcomeType.Allocation),\n                        abi.encode(newAllocation)\n                    )\n                )\n            );\n        }\n\n        // *******\n        // INTERACTIONS\n        // *******\n\n        for (uint256 j = 0; j < payouts.length; j++) {\n            if (payouts[j] > 0) {\n                bytes32 destination = allocation[indices.length > 0 ? indices[j] : j].destination;\n                // storage updated BEFORE external contracts called (prevent reentrancy attacks)\n                if (_isExternalDestination(destination)) {\n                    _transferAsset(_bytes32ToAddress(destination), payouts[j]);\n                } else {\n                    holdings[destination] += payouts[j];\n                }\n                // Event emitted\n                emit AssetTransferred(fromChannelId, destination, payouts[j]);\n            }\n        }\n    }\n\n    /**\n     * @notice Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel.  Does not check allocationBytes or guarantee against on chain storage.\n     * @dev Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel.  Does not check allocationBytes or guarantee against on chain storage.\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\n     * @param guarantee The guarantee\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\n     * @param destination External destination or channel to transfer funds *to*.\n     */\n    function _claim(\n        bytes32 guarantorChannelId,\n        Outcome.Guarantee memory guarantee,\n        bytes memory allocationBytes,\n        bytes32 destination\n    ) internal {\n        Outcome.AllocationItem[] memory allocation = abi.decode(\n            allocationBytes,\n            (Outcome.AllocationItem[])\n        );\n        uint256 balance = holdings[guarantorChannelId];\n        uint256 affordsForDestination;\n        uint256 residualAllocationAmount;\n        uint256 i; // indexes target allocations\n\n        for (uint256 j = 0; j < guarantee.destinations.length; j++) {\n            if (balance == 0) {\n                revert('_claim : guarantorChannel affords 0 for destination');\n            }\n            // for each destination in the guarantee,\n            // find the first corresponding allocationItem in the target allocation\n            bytes32 guaranteeDestination = guarantee.destinations[j];\n            for (i = 0; i < allocation.length; i++) {\n                if (allocation[i].destination == guaranteeDestination) {\n                    // decrease balance\n                    uint256 _amount = allocation[i].amount;\n                    if (balance < _amount) {\n                        if (guaranteeDestination == destination) {\n                            affordsForDestination = balance;\n                            residualAllocationAmount = _amount - balance;\n                            break;\n                            // i will point to index that should be modified or removed in the target outcome\n                        }\n                        balance = 0; // this isn't used after we break\n                    } else {\n                        if (guaranteeDestination == destination) {\n                            affordsForDestination = _amount;\n                            residualAllocationAmount = 0;\n                            break;\n                            // i will point to index that should be modified or removed in the target outcome\n                        }\n                        balance = balance.sub(_amount); // this isn't used after we break\n                    }\n                    break;\n                }\n            }\n            if (affordsForDestination > 0) {\n                // stop lopping as soon as we found the destination in both outcomes such that we can pay something out\n                break;\n            }\n        }\n\n        require(affordsForDestination > 0, '_claim | guarantor affords 0 for destination');\n\n        // effects\n        holdings[guarantorChannelId] -= affordsForDestination;\n\n        // construct new outcome for target\n        if (residualAllocationAmount > 0) {\n            // new allocation identical save for a single entry\n            Outcome.AllocationItem[] memory newAllocation = new Outcome.AllocationItem[](\n                allocation.length\n            );\n            for (uint256 k = 0; k < allocation.length; k++) {\n                newAllocation[k] = allocation[k];\n                if (k == i) {\n                    newAllocation[k].amount = residualAllocationAmount;\n                    break;\n                }\n            }\n            assetOutcomeHashes[guarantee.targetChannelId] = keccak256(\n                abi.encode(\n                    Outcome.AssetOutcome(\n                        uint8(Outcome.AssetOutcomeType.Allocation),\n                        abi.encode(newAllocation)\n                    )\n                )\n            );\n        }\n\n        if (residualAllocationAmount == 0) {\n            // We want to splice a shorter outcome\n            if (allocation.length == 1) {\n                // special case there are no allocations left in the target's outcome\n                delete assetOutcomeHashes[guarantee.targetChannelId];\n                delete assetOutcomeHashes[guarantorChannelId];\n            } else {\n                Outcome.AllocationItem[] memory splicedAllocation = new Outcome.AllocationItem[](\n                    allocation.length - 1\n                );\n                for (uint256 k = 0; k < i; k++) {\n                    splicedAllocation[k] = allocation[k];\n                }\n                for (uint256 k = i + 1; k < allocation.length; k++) {\n                    splicedAllocation[k - 1] = allocation[k];\n                }\n                assetOutcomeHashes[guarantee.targetChannelId] = keccak256(\n                    abi.encode(\n                        Outcome.AssetOutcome(\n                            uint8(Outcome.AssetOutcomeType.Allocation),\n                            abi.encode(splicedAllocation)\n                        )\n                    )\n                );\n            }\n        }\n\n        // storage updated BEFORE external contracts called (prevent reentrancy attacks)\n        if (_isExternalDestination(destination)) {\n            _transferAsset(_bytes32ToAddress(destination), affordsForDestination);\n        } else {\n            holdings[destination] += affordsForDestination;\n        }\n        // Event emitted\n        emit AssetTransferred(guarantorChannelId, destination, affordsForDestination);\n    }\n\n    /**\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Does not check allocationBytes or guarantee against on chain storage.\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Does not check allocationBytes or guarantee against on chain storage.\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\n     * @param guarantee The guarantee\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\n     */\n    function _claimAll(\n        bytes32 guarantorChannelId,\n        Outcome.Guarantee memory guarantee,\n        bytes memory allocationBytes\n    ) internal {\n        uint256 balance = holdings[guarantorChannelId];\n\n        Outcome.AllocationItem[] memory allocation = abi.decode(\n            allocationBytes,\n            (Outcome.AllocationItem[])\n        ); // this remains constant length\n\n        uint256[] memory payouts = new uint256[](allocation.length);\n        uint256 newAllocationLength = allocation.length;\n\n        // first increase payouts according to guarantee\n        for (uint256 i = 0; i < guarantee.destinations.length; i++) {\n            if (balance == 0) {\n                break;\n            }\n            // for each destination in the guarantee\n            bytes32 _destination = guarantee.destinations[i];\n            for (uint256 j = 0; j < allocation.length; j++) {\n                if (balance == 0) {\n                    break;\n                }\n                if (_destination == allocation[j].destination) {\n                    // find amount allocated to that destination (if it exists in channel alllocation)\n                    uint256 _amount = allocation[j].amount;\n                    if (_amount > 0) {\n                        if (balance >= _amount) {\n                            balance = balance.sub(_amount);\n                            allocation[j].amount = 0; // subtract _amount;\n                            newAllocationLength = newAllocationLength.sub(1);\n                            payouts[j] += _amount;\n                            break;\n                        } else {\n                            allocation[j].amount = _amount.sub(balance);\n                            payouts[j] += balance;\n                            balance = 0;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // next, increase payouts according to original allocation order\n        // this block only has an effect if balance > 0\n        for (uint256 j = 0; j < allocation.length; j++) {\n            // for each entry in the target channel's outcome\n            if (balance == 0) {\n                break;\n            }\n            uint256 _amount = allocation[j].amount;\n            if (_amount > 0) {\n                if (balance >= _amount) {\n                    balance = balance.sub(_amount);\n                    allocation[j].amount = 0; // subtract _amount;\n                    newAllocationLength = newAllocationLength.sub(1);\n                    payouts[j] += _amount;\n                } else {\n                    allocation[j].amount = _amount.sub(balance);\n                    payouts[j] += balance;\n                    balance = 0;\n                }\n            }\n        }\n\n        // EFFECTS\n        holdings[guarantorChannelId] = balance;\n\n        // at this point have payouts array of uint256s, each corresponding to original destinations\n        // and allocations has some zero amounts which we want to prune\n        Outcome.AllocationItem[] memory newAllocation;\n        if (newAllocationLength > 0) {\n            newAllocation = new Outcome.AllocationItem[](newAllocationLength);\n        }\n\n        uint256 k = 0;\n        for (uint256 j = 0; j < allocation.length; j++) {\n            // for each destination in the target channel's allocation\n            if (allocation[j].amount > 0) {\n                newAllocation[k] = allocation[j];\n                k++;\n            }\n        }\n        assert(k == newAllocationLength);\n\n        if (newAllocationLength > 0) {\n            // store hash\n            assetOutcomeHashes[guarantee.targetChannelId] = keccak256(\n                abi.encode(\n                    Outcome.AssetOutcome(\n                        uint8(Outcome.AssetOutcomeType.Allocation),\n                        abi.encode(newAllocation)\n                    )\n                )\n            );\n        } else {\n            delete assetOutcomeHashes[guarantorChannelId];\n            delete assetOutcomeHashes[guarantee.targetChannelId];\n        }\n\n        // INTERACTIONS\n        for (uint256 j = 0; j < allocation.length; j++) {\n            // for each destination in the target channel's allocation\n            if (payouts[j] > 0) {\n                if (_isExternalDestination(allocation[j].destination)) {\n                    _transferAsset(_bytes32ToAddress(allocation[j].destination), payouts[j]);\n                } else {\n                    holdings[allocation[j].destination] += payouts[j];\n                }\n                emit AssetTransferred(guarantorChannelId, allocation[j].destination, payouts[j]);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping\n     * @dev Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping\n     * @param channelId Unique identifier for a state channel.\n     * @param assetOutcomeHash The keccak256 of the abi.encode of the Outcome.\n     */\n    function _setAssetOutcomeHash(bytes32 channelId, bytes32 assetOutcomeHash) internal {\n        require(assetOutcomeHashes[channelId] == bytes32(0), 'Outcome hash already exists');\n        assetOutcomeHashes[channelId] = assetOutcomeHash;\n    }\n\n    /**\n     * @notice Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\n     * @dev Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\n     * @param destination ethereum address to be credited.\n     * @param amount Quantity of assets to be transferred.\n     */\n    function _transferAsset(address payable destination, uint256 amount) internal virtual {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Checks if a given destination is external (and can therefore have assets transferred to it) or not.\n     * @dev Checks if a given destination is external (and can therefore have assets transferred to it) or not.\n     * @param destination Destination to be checked.\n     * @return True if the destination is external, false otherwise.\n     */\n    function _isExternalDestination(bytes32 destination) internal pure returns (bool) {\n        return uint96(bytes12(destination)) == 0;\n    }\n\n    /**\n     * @notice Converts an ethereum address to a nitro external destination.\n     * @dev Converts an ethereum address to a nitro external destination.\n     * @param participant The address to be converted.\n     * @return The input address left-padded with zeros.\n     */\n    function _addressToBytes32(address participant) internal pure returns (bytes32) {\n        return bytes32(uint256(participant));\n    }\n\n    /**\n     * @notice Converts a nitro destination to an ethereum address.\n     * @dev Converts a nitro destination to an ethereum address.\n     * @param destination The destination to be converted.\n     * @return The rightmost 160 bits of the input string.\n     */\n    function _bytes32ToAddress(bytes32 destination) internal pure returns (address payable) {\n        return address(uint160(uint256(destination)));\n    }\n\n    // **************\n    // Requirers\n    // **************\n\n    function _requireCorrectAllocationHash(bytes32 channelId, bytes memory allocationBytes)\n        internal\n        view\n    {\n        require(\n            assetOutcomeHashes[channelId] ==\n                keccak256(\n                    abi.encode(\n                        Outcome.AssetOutcome(\n                            uint8(Outcome.AssetOutcomeType.Allocation),\n                            allocationBytes\n                        )\n                    )\n                ),\n            'AssetHolder | submitted allocationBytes data does not match stored assetOutcomeHash'\n        );\n    }\n\n    function _requireCorrectGuaranteeHash(bytes32 guarantorChannelId, bytes memory guaranteeBytes)\n        internal\n        view\n    {\n        require(\n            assetOutcomeHashes[guarantorChannelId] ==\n                keccak256(\n                    abi.encode(\n                        Outcome.AssetOutcome(\n                            uint8(Outcome.AssetOutcomeType.Guarantee),\n                            guaranteeBytes\n                        )\n                    )\n                ),\n            'AssetHolder | submitted guaranteeBytes data does not match stored assetOutcomeHash'\n        );\n    }\n\n    function _requireIncreasingIndices(uint256[] memory indices) internal pure {\n        for (uint256 i = 0; i < indices.length - 1; i++) {\n            require(indices[i] < indices[i + 1], 'Indices must be sorted');\n        }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? b : a;\n    }\n}\n"
    },
    "contracts/ETHAssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\nimport './AssetHolder.sol';\n\n/**\n * @dev Ther ETHAssetHolder contract extends the AssetHolder contract, and adds the following functionality: it allows ETH to be escrowed against a state channelId and to be transferred to external destinations.\n */\ncontract ETHAssetHolder is AssetHolder {\n    using SafeMath for uint256;\n\n    /**\n     * @notice Constructor function storing the AdjudicatorAddress.\n     * @dev Constructor function storing the AdjudicatorAddress.\n     * @param _AdjudicatorAddress Address of an Adjudicator  contract, supplied at deploy-time.\n     */\n    constructor(address _AdjudicatorAddress) {\n        AdjudicatorAddress = _AdjudicatorAddress;\n    }\n\n    /**\n     * @notice Deposit ETH against a given destination.\n     * @dev Deposit ETH against a given destination.\n     * @param destination ChannelId to be credited.\n     * @param expectedHeld The number of wei the depositor believes are _already_ escrowed against the channelId.\n     * @param amount The intended number of wei to be deposited.\n     */\n    function deposit(\n        bytes32 destination,\n        uint256 expectedHeld,\n        uint256 amount\n    ) external payable {\n        require(!_isExternalDestination(destination), 'Cannot deposit to external destination');\n        require(msg.value == amount, 'Insufficient ETH for ETH deposit');\n        uint256 amountDeposited;\n        // this allows participants to reduce the wait between deposits, while protecting them from losing funds by depositing too early. Specifically it protects against the scenario:\n        // 1. Participant A deposits\n        // 2. Participant B sees A's deposit, which means it is now safe for them to deposit\n        // 3. Participant B submits their deposit\n        // 4. The chain re-orgs, leaving B's deposit in the chain but not A's\n        require(\n            holdings[destination] >= expectedHeld,\n            'Deposit | holdings[destination] is less than expected'\n        );\n        require(\n            holdings[destination] < expectedHeld.add(amount),\n            'Deposit | holdings[destination] already meets or exceeds expectedHeld + amount'\n        );\n\n        // The depositor wishes to increase the holdings against channelId to amount + expectedHeld\n        // The depositor need only deposit (at most) amount + (expectedHeld - holdings) (the term in parentheses is non-positive)\n\n        amountDeposited = expectedHeld.add(amount).sub(holdings[destination]); // strictly positive\n        // require successful deposit before updating holdings (protect against reentrancy)\n\n        holdings[destination] = holdings[destination].add(amountDeposited);\n        emit Deposited(destination, amountDeposited, holdings[destination]);\n\n        // refund whatever wasn't deposited.\n        uint256 refund = amount.sub(amountDeposited);\n        (bool success, ) = msg.sender.call{value: refund}(''); //solhint-disable-line avoid-low-level-calls\n        require(success, 'Could not refund excess funds');\n    }\n\n    /**\n     * @notice Transfers the given number of wei to a supplied ethereum address.\n     * @dev Transfers the given number of wei to a supplied ethereum address.\n     * @param destination Ethereum address to be credited.\n     * @param amount Quantity of wei to be transferred.\n     */\n    function _transferAsset(address payable destination, uint256 amount) internal override {\n        (bool success, ) = destination.call{value: amount}(''); //solhint-disable-line avoid-low-level-calls\n        require(success, 'Could not transfer ETH');\n    }\n}\n"
    },
    "contracts/Outcome.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nlibrary Outcome {\n    //An outcome is an array of OutcomeItems\n    // Outcome = OutcomeItem[]\n    // OutcomeItem = (AssetHolderAddress, AssetOutcome)\n    // AssetOutcome = (AssetOutcomeType, Allocation | Guarantee)\n    // Allocation = AllocationItem[]\n    // AllocationItem = (Destination, Amount)\n    // Guarantee = (ChannelAddress, Destination[])\n    // Destination = ChannelAddress | ExternalDestination\n\n    struct OutcomeItem {\n        address assetHolderAddress;\n        bytes assetOutcomeBytes; // abi.encode(AssetOutcome)\n    }\n\n    enum AssetOutcomeType {Allocation, Guarantee}\n\n    struct AssetOutcome {\n        uint8 assetOutcomeType; // AssetOutcomeType.Allocation or AssetOutcomeType.Guarantee\n        bytes allocationOrGuaranteeBytes; // abi.encode(AllocationItem[]) or abi.encode(Guarantee), depending on OutcomeType\n    }\n\n    // reserve Allocation to refer to AllocationItem[]\n    struct AllocationItem {\n        bytes32 destination;\n        uint256 amount;\n    }\n\n    struct Guarantee {\n        bytes32 targetChannelId;\n        bytes32[] destinations;\n    }\n}\n"
    },
    "contracts/interfaces/IAssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev The IAssetHolder interface calls for functions that allow assets to be transferred from one channel to other channel and/or external destinations, as well as for guarantees to be claimed.\n */\ninterface IAssetHolder {\n    /**\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     * @param indices Array with each entry denoting the index of a destination to transfer funds to.\n     */\n    function transfer(\n        bytes32 fromChannelId,\n        bytes calldata allocationBytes,\n        uint256[] memory indices\n    ) external;\n\n    /**\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel.\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel.\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\n     * @param guaranteeBytes The abi.encode of Outcome.Guarantee\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\n     */\n    function claimAll(\n        bytes32 guarantorChannelId,\n        bytes calldata guaranteeBytes,\n        bytes calldata allocationBytes\n    ) external;\n\n    /**\n     * @dev Indicates that `amountDeposited` has been deposited into `destination`.\n     * @param destination The channel being deposited into.\n     * @param amountDeposited The amount being deposited.\n     * @param destinationHoldings The new holdings for `destination`.\n     */\n    event Deposited(\n        bytes32 indexed destination,\n        uint256 amountDeposited,\n        uint256 destinationHoldings\n    );\n\n    /**\n     * @dev Indicates that `amount` assets have been transferred (internally or externally) to the destination denoted by `destination`.\n     * @param channelId The channelId of the funds being withdrawn.\n     * @param destination An internal destination (channelId) of external destination (padded ethereum address)\n     * @param amount Number of assets transferred (wei or tokens).\n     */\n    event AssetTransferred(bytes32 indexed channelId, bytes32 indexed destination, uint256 amount);\n}\n"
    }
  }
}