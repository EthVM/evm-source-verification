{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"UniswapAdapterWithOneStable.sol":{"content":"// hevm: flattened sources of src/uni.sol\npragma solidity >0.4.13 >=0.4.23 >=0.5.12 >=0.5.0 <0.6.0 >=0.5.10 <0.6.0 >=0.5.12 <0.6.0;\n\n////// src/IERC20.sol\n/* pragma solidity ^0.5.0; */\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function mint(address account, uint256 amount) external;\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n////// src/base.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \"./IERC20.sol\"; */\n\ninterface IAdapter {\n    function calc(\n        address gem,\n        uint256 acc,\n        uint256 factor\n    ) external view returns (uint256);\n}\n\ninterface IGemForRewardChecker {\n    function check(address gem) external view returns (bool);\n}\n\n////// src/safeMath.sol\n/* pragma solidity ^0.5.0; */\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n}\n\n////// src/uni.sol\n/* pragma solidity ^0.5.0; */\n\n/* import \"./base.sol\"; */\n/* import \"./safeMath.sol\"; */\n\ninterface UniswapV2PairLike {\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n}\n\ncontract UniswapAdapterForStables is IAdapter {\n    using SafeMath for uint256;\n\n    struct TokenPair {\n        address t0;\n        address t1;\n        uint256 r0;\n        uint256 r1;\n        uint256 usdPrec;\n    }\n\n    function calc(\n        address gem,\n        uint256 value,\n        uint256 factor\n    ) external view returns (uint256) {\n        (uint112 _reserve0, uint112 _reserve1, ) = UniswapV2PairLike(gem).getReserves();\n\n        TokenPair memory tokenPair;\n        tokenPair.usdPrec = 10**6;\n\n        tokenPair.t0 = UniswapV2PairLike(gem).token0();\n        tokenPair.t1 = UniswapV2PairLike(gem).token1();\n\n        tokenPair.r0 = uint256(_reserve0).mul(tokenPair.usdPrec).div(\n            uint256(10)**IERC20(tokenPair.t0).decimals()\n        );\n        tokenPair.r1 = uint256(_reserve1).mul(tokenPair.usdPrec).div(\n            uint256(10)**IERC20(tokenPair.t1).decimals()\n        );\n\n        uint256 totalValue = tokenPair.r0.min(tokenPair.r1).mul(2); //total value in uni's reserves for stables only\n\n        uint256 supply = UniswapV2PairLike(gem).totalSupply();\n\n        return value.mul(totalValue).mul(factor).mul(1e18).div(supply.mul(tokenPair.usdPrec));\n    }\n}\n\ncontract UniswapAdapterWithOneStable is IAdapter {\n    using SafeMath for uint256;\n\n    struct LocalVars {\n        address t0;\n        address t1;\n        uint256 totalValue;\n        uint256 supply;\n        uint256 usdPrec;\n    }\n\n    address public deployer;\n    address public buck;\n\n    constructor() public {\n        deployer = msg.sender;\n    }\n\n    function setup(address _buck) public {\n        require(deployer == msg.sender);\n        buck = _buck;\n        deployer = address(0);\n    }\n\n    function calc(\n        address gem,\n        uint256 value,\n        uint256 factor\n    ) external view returns (uint256) {\n        (uint112 _reserve0, uint112 _reserve1, ) = UniswapV2PairLike(gem).getReserves();\n\n        LocalVars memory loc;\n        loc.t0 = UniswapV2PairLike(gem).token0();\n        loc.t1 = UniswapV2PairLike(gem).token1();\n        loc.usdPrec = 10**6;\n\n        if (buck == loc.t0) {\n            loc.totalValue = uint256(_reserve0).mul(loc.usdPrec).div(\n                uint256(10)**IERC20(loc.t0).decimals()\n            );\n        } else if (buck == loc.t1) {\n            loc.totalValue = uint256(_reserve1).mul(loc.usdPrec).div(\n                uint256(10)**IERC20(loc.t1).decimals()\n            );\n        } else {\n            require(false, \"gem w/o buck\");\n        }\n\n        loc.supply = UniswapV2PairLike(gem).totalSupply();\n\n        return\n            value.mul(loc.totalValue).mul(2).mul(factor).mul(1e18).div(\n                loc.supply.mul(loc.usdPrec)\n            );\n    }\n}\n\ncontract UniForRewardCheckerBase {\n    mapping(address => bool) public tokens;\n\n    function check(address gem) external {\n        address t0 = UniswapV2PairLike(gem).token0();\n        address t1 = UniswapV2PairLike(gem).token1();\n\n        require(tokens[t0] && tokens[t1], \"non-approved-stable\");\n    }\n}\n\ncontract UniForRewardCheckerMainnet is UniForRewardCheckerBase {\n    constructor(address usdfl, address gov) public {\n        tokens[usdfl] = true;\n        tokens[gov] = true;\n        tokens[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = true; //usdc\n        tokens[0xdAC17F958D2ee523a2206206994597C13D831ec7] = true; //usdt\n        tokens[0x6B175474E89094C44Da98b954EedeAC495271d0F] = true; //dai\n        tokens[0x674C6Ad92Fd080e4004b2312b45f796a192D27a0] = true; //usdn\n    }\n}\n\ncontract UniForRewardCheckerKovan is UniForRewardCheckerBase {\n    constructor(address usdfl, address gov) public {\n        tokens[usdfl] = true;\n        tokens[gov] = true;\n        tokens[0xe22da380ee6B445bb8273C81944ADEB6E8450422] = true; //usdc\n        tokens[0x13512979ADE267AB5100878E2e0f485B568328a4] = true; //usdt\n        tokens[0xFf795577d9AC8bD7D90Ee22b6C1703490b6512FD] = true; //dai\n        tokens[0x5f99471D242d04C42a990A33e8233f5B48F89C43] = true; //usdn\n    }\n}\n\ncontract UniForRewardCheckerRinkeby is UniForRewardCheckerBase {\n    constructor(address usdfl, address gov) public {\n        tokens[usdfl] = true;\n        tokens[gov] = true;\n        tokens[0x4DBCdF9B62e891a7cec5A2568C3F4FAF9E8Abe2b] = true; //usdc\n        tokens[0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02] = true; //usdt\n        tokens[0x97833b01a73733065684A851Fd1E91D7951b5fD8] = true; //dai\n        tokens[0x033C5b4A8E1b8A2f3b5A7451a9defD561028a8C5] = true; //usdn\n    }\n}\n"}}}