{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"SporoRabbit.sol":{"content":"// File: contracts/lib/States.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\n\r\nlibrary States {\r\n    int8 constant Annihilated = -128;\r\n    int8 constant Unminted = -1;\r\n    int8 constant Unopened = 1;\r\n    int8 constant Alive = 10;\r\n    int8 constant Ethereal = 20;\r\n    int8 constant Lost = 127;\r\n}\r\n\r\nlibrary Phase {    \r\n    uint8 constant Disabled = 1;\r\n    uint8 constant Registration = 2;\r\n    uint8 constant PrivatePresale = 3;\r\n    uint8 constant PublicPresale = 4;\r\n    uint8 constant Released = 5;\r\n    uint8 constant Closed = 6;\r\n}\r\n\r\n// File: contracts/lib/Utils.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract OwnableDelegateProxy {}\r\n\r\ncontract ProxyRegistry {\r\n    mapping(address => OwnableDelegateProxy) public proxies;\r\n}\r\n\r\nlibrary Utils {\r\n\r\n    function isOpenSeaProxy(address proxy, address _owner, address operator) internal view returns (bool){\r\n        // Whitelist OpenSea proxy contract for easy trading.\r\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxy);\r\n        if (address(proxyRegistry.proxies(_owner)) == operator) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // slither-disable-next-line assembly \r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function toString(int8 value) internal pure returns (string memory) {\r\n        return toString(uint(int(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/Interfaces.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IERC165 {\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\ninterface IERC721 is IERC165 {\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address operator);\r\n\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IERC721Enumerable is IERC721 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index)\r\n        external\r\n        view\r\n        returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: contracts/lib/ERC721.sol\r\n\r\n\r\n\r\n/********************\r\n* @modified code provided by Squeebo *\r\n********************/\r\n\r\n\r\n\r\n\r\n\r\nabstract contract ERC721 is IERC165, IERC721, IERC721Metadata {\r\n    string private _name;\r\n    string private _symbol;\r\n    address[] internal _owners;\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(IERC165)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            interfaceId == type(IERC165).interfaceId;\r\n    }\r\n\r\n    function balanceOf(address owner)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            owner != address(0),\r\n            \"410\"\r\n        );\r\n\r\n        uint256 count = 0;\r\n        uint256 length = _owners.length;\r\n        for (uint256 i = 0; i < length; ++i) {\r\n            if (owner == _owners[i]) ++count;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        address owner = _owners[tokenId];\r\n        require(\r\n            owner != address(0),\r\n            \"404\"\r\n        );\r\n        return owner;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"420\");\r\n\r\n        require(\r\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\r\n            \"900\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \"404\"\r\n        );\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved)\r\n        external\r\n        virtual\r\n        override\r\n    {\r\n        require(operator != msg.sender, \"950\");\r\n        _operatorApprovals[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        require(\r\n            _isApprovedOrOwner(msg.sender, tokenId),\r\n            \"911\"\r\n        );\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            _isApprovedOrOwner(msg.sender, tokenId),\r\n            \"911\"\r\n        );\r\n        _safeTransfer(from, to, tokenId, data);\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(from, to, tokenId, data),\r\n            \"420\"\r\n        );\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return tokenId < _owners.length && _owners[tokenId] != address(0);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \"404\"\r\n        );\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner ||\r\n            getApproved(tokenId) == spender ||\r\n            isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, _data),\r\n            \"420\"\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"800\");\r\n        require(!_exists(tokenId), \"920\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n        _owners.push(to);\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n        _approve(address(0), tokenId);\r\n        _owners[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(\r\n            ERC721.ownerOf(tokenId) == from,\r\n            \"910\"\r\n        );\r\n        require(to != address(0), \"810\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        _approve(address(0), tokenId);\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (Utils.isContract(to)) {\r\n            // slither-disable-next-line unused-return \r\n            try \r\n                // slither-disable-next-line variable-scope \r\n                IERC721Receiver(to).onERC721Received(msg.sender, from,tokenId,_data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;       \r\n            // slither-disable-next-line variable-scope          \r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"420\");\r\n                } else {\r\n                    // slither-disable-next-line assembly \r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // slither-disable-next-line dead-code \r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: contracts/lib/ERC721Enumerable.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n/********************\r\n * @modified code provided by Squeebo *\r\n ********************/\r\n\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n    mapping(address => uint256[]) internal _balances;\r\n\r\n    function balanceOf(address owner)\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC721, IERC721)\r\n        returns (uint256)\r\n    {\r\n        require(owner != address(0), \"800\");\r\n        return _balances[owner].length;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(IERC165, ERC721)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC721Enumerable).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256 tokenId)\r\n    {\r\n        require(index < ERC721.balanceOf(owner), \"404\");\r\n        return _balances[owner][index];\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _owners.length - 1;\r\n    }\r\n\r\n    function tokenByIndex(uint256 index)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(index < _owners.length, \"404\");\r\n        return index;\r\n    }\r\n\r\n    //internal - costs 20k\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override {\r\n        address zero = address(0);\r\n        if (from != zero || to == zero) {\r\n            //find this token and remove it\r\n            uint256 length = _balances[from].length;\r\n            for (uint256 i; i < length; ++i) {\r\n                if (_balances[from][i] == tokenId) {\r\n                    _balances[from][i] = _balances[from][length - 1];\r\n                    _balances[from].pop();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (to != zero) _balances[to].push(tokenId);\r\n    }\r\n}\r\n\r\n// File: contracts/v1/DimmCityV1Base.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nabstract contract DimmCityV1Base is ERC721Enumerable {\r\n    uint256 private _tokenIdCounter;\r\n    uint8 public MaxPack;\r\n    uint8 public ReleasePhase;\r\n    bool EnforceRoyality;\r\n    uint256 public MaxSupply;\r\n    address public WithdrawalAddress;\r\n    address public ProxyRegistryAddress;\r\n    string public MetaDataUri;\r\n    mapping(uint256 => int8) private _states;\r\n    mapping(address => uint8) private _presaleList;\r\n    mapping(int8 => mapping(int8 => uint256)) _costs;\r\n    mapping(address => bool) public Admins;\r\n    mapping(address => bool) public Markets;\r\n\r\n    event ReleasePhaseChanged(uint8 indexed state);\r\n    event StateChanged(\r\n        address indexed sender,\r\n        uint256 indexed tokenId,\r\n        int8 indexed state\r\n    );\r\n\r\n    constructor(\r\n        string memory releaseName,\r\n        string memory releaseSymbol,\r\n        string memory relativeUri,\r\n        uint256 packCost,\r\n        uint256 resurrectionCost,\r\n        uint256 restorationCost\r\n    ) ERC721(releaseName, releaseSymbol) {\r\n        MetaDataUri = string(\r\n            abi.encodePacked(\r\n                \"https://sporosnft.io/api/v1\",\r\n                relativeUri\r\n            )\r\n        );\r\n        _tokenIdCounter = 1;\r\n        _owners.push(address(0));\r\n\r\n        MaxPack = 10;\r\n        WithdrawalAddress = msg.sender;\r\n        Admins[msg.sender] = true;\r\n        MaxSupply = 3000;\r\n        ReleasePhase = Phase.Registration;\r\n        //EnforceRoyality = true;\r\n        ProxyRegistryAddress = address(\r\n            0x000a5409ec958c83c3f309868babaca7c86dcb077c1\r\n        );\r\n\r\n        _costs[States.Unminted][States.Unopened] = packCost;\r\n        _costs[States.Lost][States.Alive] = restorationCost;\r\n        _costs[States.Ethereal][States.Alive] = resurrectionCost;\r\n    }\r\n\r\n    modifier nonZero(address input) {\r\n        require(input != address(0), \"800\");\r\n        _;\r\n    }\r\n\r\n    //#region Admin\r\n\r\n    modifier onlyAdmins() {\r\n        require(isAdmin(msg.sender), \"900\");\r\n        _;\r\n    }\r\n\r\n    function isAdmin(address admin) internal view returns (bool) {\r\n        return Admins[admin];\r\n    }\r\n\r\n    function removeAdmin(address admin)\r\n        external\r\n        virtual\r\n        nonZero(admin)\r\n        onlyAdmins\r\n    {\r\n        require(admin != msg.sender, \"940\");\r\n        delete Admins[admin];\r\n    }\r\n\r\n    function addAdmin(address newAdmin)\r\n        external\r\n        virtual\r\n        nonZero(newAdmin)\r\n        onlyAdmins\r\n    {\r\n        require(!isAdmin(newAdmin), \"930\");\r\n        Admins[newAdmin] = true;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return WithdrawalAddress;\r\n    }\r\n\r\n    function addMarket(address newMarket)\r\n        external\r\n        virtual\r\n        nonZero(newMarket)\r\n        onlyAdmins\r\n    {\r\n        Markets[newMarket] = true;\r\n    }\r\n\r\n    function removeMarket(address market)\r\n        external\r\n        virtual\r\n        nonZero(market)\r\n        onlyAdmins\r\n    {\r\n        delete Markets[market];\r\n    }\r\n\r\n    //#endregion\r\n\r\n    function setWithdawalAddress(address newAddress)\r\n        external\r\n        nonZero(newAddress)\r\n        onlyAdmins\r\n    {\r\n        WithdrawalAddress = newAddress;\r\n    }\r\n\r\n    function setMaxSupply(uint256 supply) external onlyAdmins {\r\n        require(supply >= _owners.length, \"510\");\r\n        MaxSupply = supply;\r\n    }\r\n\r\n    function setMaxPack(uint8 perPack) external onlyAdmins {\r\n        MaxPack = perPack;\r\n    }\r\n\r\n    function setGuard(bool enabled) external onlyAdmins {\r\n        EnforceRoyality = enabled;\r\n    }\r\n\r\n    function setMetaDataUri(string memory baseURI) external onlyAdmins {\r\n        MetaDataUri = baseURI;\r\n    }\r\n\r\n    function setProxyRegistryAddress(address proxyAddress) external onlyAdmins {\r\n        ProxyRegistryAddress = proxyAddress;\r\n    }\r\n\r\n    function getUserCredits(address wallet)\r\n        external\r\n        view\r\n        returns (uint8 credits)\r\n    {\r\n        require(msg.sender == wallet || isAdmin(msg.sender), \"900\");\r\n        return _presaleList[wallet];\r\n    }\r\n\r\n    //ToDo bulk set states\r\n\r\n    function bulkUpdateCredits(\r\n        address[] calldata list,\r\n        uint8[] calldata credits\r\n    ) external onlyAdmins {\r\n        require(list.length == credits.length, \"520\");\r\n\r\n        for (uint256 i = 0; i < list.length; i++) {\r\n            _presaleList[list[i]] = credits[i];\r\n        }\r\n    }\r\n\r\n    function getPackCost() external view returns (uint256) {\r\n        return _costs[States.Unminted][States.Unopened];\r\n    }\r\n\r\n    function setStateCost(\r\n        int8 from,\r\n        int8 to,\r\n        uint256 cost\r\n    ) external onlyAdmins {\r\n        _costs[from][to] = cost;\r\n    }\r\n\r\n    function setReleasePhase(uint8 state) external onlyAdmins {\r\n        ReleasePhase = state;\r\n        emit ReleasePhaseChanged(ReleasePhase);\r\n    }\r\n\r\n    function getState(uint256 tokenId) external view returns (int8) {\r\n        require(_exists(tokenId), \"404\");\r\n        return _states[tokenId];\r\n    }\r\n\r\n    function setState(uint256 tokenId, int8 state)\r\n        public\r\n        payable\r\n        returns (int8)\r\n    {\r\n        require(state != States.Unopened, \"915\");\r\n        if (!isAdmin(msg.sender)) {\r\n            require(ownerOf(tokenId) == msg.sender, \"910\");\r\n            require(msg.value >= _costs[_states[tokenId]][state], \"200\");\r\n            require(\r\n                _states[tokenId] >= States.Unopened && state > States.Unopened,\r\n                \"915\"\r\n            );\r\n        }\r\n        _states[tokenId] = state;\r\n        emit StateChanged(msg.sender, tokenId, state);\r\n        return state;\r\n    }\r\n\r\n    function burn(uint256 tokenId) external onlyAdmins {\r\n        _burn(tokenId);\r\n        setState(tokenId, States.Annihilated);\r\n    }\r\n\r\n    function buyPack(\r\n        address to,\r\n        uint8 numberOfTokens,\r\n        bool openNow\r\n    ) external payable virtual {\r\n        require(\r\n            ReleasePhase >= Phase.PrivatePresale && ReleasePhase < Phase.Closed,\r\n            \"000\"\r\n        );\r\n        require(numberOfTokens > 0 && numberOfTokens <= MaxPack, \"500\");\r\n\r\n        uint256 currentId = _owners.length;\r\n        require((currentId + numberOfTokens) <= MaxSupply, \"400\");\r\n\r\n        bool admin = isAdmin(msg.sender);\r\n        require(\r\n            admin ||\r\n                msg.value >=\r\n                (_costs[States.Unminted][States.Unopened] * numberOfTokens),\r\n            \"200\"\r\n        );\r\n        require(\r\n            admin ||\r\n                ReleasePhase >= Phase.PublicPresale ||\r\n                numberOfTokens <= _presaleList[msg.sender],\r\n            \"100\"\r\n        );\r\n\r\n        if (to == address(0)) to = msg.sender;\r\n\r\n        int8 initialState = States.Unopened;\r\n        if (ReleasePhase >= Phase.Released && openNow)\r\n            initialState = States.Alive;\r\n\r\n        for (uint8 i = 0; i < numberOfTokens; i++) {\r\n            _states[currentId] = initialState;\r\n\r\n            if (!admin && _presaleList[msg.sender] > 0)\r\n                _presaleList[msg.sender] = _presaleList[msg.sender] - 1;\r\n\r\n            _safeMint(to, currentId);\r\n            currentId++;\r\n        }\r\n        delete currentId;\r\n        delete admin;\r\n    }\r\n\r\n    function openPack(uint256[] calldata tokens) external payable virtual {\r\n        require(ReleasePhase >= Phase.Released, \"001\");\r\n        require(\r\n            msg.value >=\r\n                (_costs[States.Unopened][States.Alive] * tokens.length),\r\n            \"200\"\r\n        );\r\n\r\n        for (uint256 index = 0; index < tokens.length; index++) {\r\n            uint256 tokenId = tokens[index];\r\n            if (\r\n                _states[tokenId] == States.Unopened &&\r\n                msg.sender == ownerOf(tokenId)\r\n            ) {\r\n                _states[tokenId] = States.Alive;\r\n            }\r\n            delete tokenId;\r\n        }\r\n    }\r\n\r\n    function sendPack(address to, uint8 numberOfTokens)\r\n        external\r\n        onlyAdmins\r\n        nonZero(to)\r\n    {\r\n        require(numberOfTokens > 0, \"410\");\r\n\r\n        uint256 currentId = _owners.length;\r\n        require(currentId + numberOfTokens <= MaxSupply, \"400\");\r\n        for (uint8 i = 0; i < numberOfTokens; i++) {\r\n            _states[currentId] = States.Unopened;\r\n            _safeMint(to, currentId);\r\n            currentId++;\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override(ERC721Enumerable) {\r\n        if (to != address(0) && from != address(0) && !allowTransfer(from)) {\r\n            _states[tokenId] = States.Lost;\r\n            emit StateChanged(msg.sender, tokenId, States.Lost);\r\n        }\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address operator)\r\n        public\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        if (\r\n            ProxyRegistryAddress != address(0) &&\r\n            Utils.isOpenSeaProxy(ProxyRegistryAddress, _owner, operator)\r\n        ) return true;\r\n\r\n        return super.isApprovedForAll(_owner, operator);\r\n    }\r\n\r\n    function allowTransfer(address _owner) internal view returns (bool) {\r\n        if (!EnforceRoyality) return true;\r\n\r\n        bool result = (isAdmin(msg.sender) || Markets[msg.sender]);\r\n\r\n        if (!result && ProxyRegistryAddress == address(0)) return false;\r\n\r\n        if (\r\n            !result &&\r\n            Utils.isOpenSeaProxy(ProxyRegistryAddress, _owner, msg.sender)\r\n        ) {\r\n            return true;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function contractURI() public view returns (string memory) {\r\n        return string(abi.encodePacked(MetaDataUri, \"/contract.json\"));\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (string memory)\r\n    {\r\n        require(_exists(tokenId), \"404\");\r\n\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    MetaDataUri,\r\n                    \"/\",\r\n                    Utils.toString(tokenId),\r\n                    \".json?s=\",\r\n                    Utils.toString(_states[tokenId])\r\n                )\r\n            );\r\n    }\r\n\r\n    function withdraw() external nonZero(WithdrawalAddress) onlyAdmins {\r\n        require(isAdmin(WithdrawalAddress), \"910\");\r\n        (bool sent, ) = WithdrawalAddress.call{value: address(this).balance}(\r\n            \"\"\r\n        );\r\n\r\n        require(sent, \"999\");\r\n        delete sent;\r\n    }\r\n}\r\n\r\n// File: contracts/v1/SporoRabbit.sol\r\n\r\n\r\n\r\n\r\n\r\ncontract SporoRabbit is DimmCityV1Base {\r\n    constructor()\r\n     DimmCityV1Base(\r\n            \"Sporos\",\r\n            \"D.C.S1R1\",\r\n            \"/sporos/s1r1\",\r\n            0.04 ether, \r\n            0.005 ether,\r\n            0.005 ether\r\n        )\r\n    {        \r\n    }\r\n}"}}}