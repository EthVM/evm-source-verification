{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "details": {
        "constantOptimizer": true,
        "cse": true,
        "deduplicate": true,
        "jumpdestRemover": true,
        "orderLiterals": true,
        "peephole": true,
        "yul": false
      },
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}\n"
    },
    "contracts/TerraformsData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ToString.sol\";\nimport \"./Base64.sol\";\nimport \"./TerraformsDataInterfaces.sol\";\nimport \"./TerraformsDataStorage.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @author xaltgeist\n/// @title Token data and tokenURI generation for the Terraforms contract\n/// @dev Terraforms data is generated on-demand; Terraforms are not stored\ncontract TerraformsData is TerraformsDataStorage, Ownable {\n\n    /// @dev Parameters used to generate tokenURI\n    struct tokenURIContext {\n        ITerraformsSVG.SVGParams p; // Parameters for SVG contract\n        ITerraformsSVG.AnimParams a; // Parameters to generate CSS animation\n        string name;\n        string svgMain; // Main body of the tokenURI SVG\n        string animations; // SVG animation keyframes\n        string script; // SVG javascript\n        string imageURI; // \"image\" attribute source \n        string animationURI; // \"animation_url\" source\n        string activation; // Token activation\n        string mode; // Terrain, Daydream, Terraform\n    }\n\n    /// @dev A token's status\n    enum Status {\n        Terrain, \n        Daydream, \n        Terraformed, \n        OriginDaydream, \n        OriginTerraformed\n    }\n\n    // Interfaces\n    ITerraformsSVG terraformsSVG;\n    ITerraformsZones terraformsZones;\n    ITerraformsCharacters terraformsCharacters;\n    IPerlinNoise perlinNoise;\n    ITerraformsResource resource;\n    uint immutable INIT_TIME;\n    uint constant MAX_SUPPLY = 11_104;\n    uint constant MAX_LEVEL_DIMS = 48;\n    uint public constant TOKEN_DIMS = 32;\n    int public constant STEP = 6619;\n    string animationURL = 'https://tokens.mathcastles.xyz/terraforms/token-html/';\n    string imageURL;\n    string public resourceName;\n    address public resourceAddress;\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * CONSTRUCTOR, FALLBACKS\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n    constructor (\n        address _terraformsSVGAddress, // Assembles SVG\n        address _perlinNoiseAddress, // Generates terrain\n        address _terraformsZonesAddress, // Manages zone info\n        address _terraformsCharsAddress // Manages character info\n    ) \n    Ownable()\n    {\n        terraformsSVG = ITerraformsSVG(_terraformsSVGAddress); \n        perlinNoise = IPerlinNoise(_perlinNoiseAddress); \n        terraformsZones = ITerraformsZones(_terraformsZonesAddress);\n        terraformsCharacters = ITerraformsCharacters(_terraformsCharsAddress);\n        INIT_TIME = block.timestamp; // Baseline for structure movement\n        resourceName = \"???\"; // Initial resource name\n    }\n\n    // SVG returned by TokenURI prior to token reveal\n    string public prerevealSVG = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><svg shape-rendering=\"crispEdges\" viewBox=\"0 0 280 280\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:svg=\"http://www.w3.org/2000/svg\"><rect class=\"bg\" fill=\"#161616\" x=\"0\" y=\"0\" width=\"280\" height=\"280\"/><path class=\"y\" stroke=\"#fff\" d=\"m 132.5,126.5 h 2 m 2,0 h 1 m -8,1 h 1 m 3,0 h 1 m 3,0 h 1 m 7,0 h 1 m 3,0 h 2 m -25,1 h 2 m 1,0 h 1 m 3,0 h 1 m 14,0 h 2 m -23,1 h 1 m 2,0 h 1 m 3,0 h 1 m 1,0 h 4 m 1,0 h 4 m 2,0 h 2 m -21,1 h 1 m 3,0 h 2 m 17,0 h 1 m -26,1 h 1 m 4,0 h 1 m 14,0 h 1 m 3,0 h 2 m -22,1 h 1 m 1,0 h 5 m 5,0 h 1 m 1,0 h 1 m 2,0 h 1 m 2,0 h 1 m -24,1 h 1 m 1,0 h 1 m 1,0 h 1 m 2,0 h 1 m 1,0 h 1 m 3,0 h 1 m 1,0 h 1 m 2,0 h 1 m 1,0 h 1 m -19,1 h 1 m 1,0 h 1 m 2,0 h 1 m 2,0 h 1 m 2,0 h 1 m 1,0 h 1 m 2,0 h 1 m 2,0 h 1 m 2,0 h 2 m -24,1 h 1 m 2,0 h 5 m 4,0 h 4 m 3,0 h 1 m 1,0 h 2 m -23,1 h 1 m 18,0 h 1 m -23,1 h 1 m 1,0 h 1 m 3,0 h 1 m 3,0 h 1 m 5,0 h 1 m 4,0 h 1 m -19,1 h 4 m 2,0 h 2 m 5,0 h 1 m 3,0 h 1 m 2,0 h 1 m -23,1 h 3 m 3,0 h 3 m 1,0 h 1 m 2,0 h 1 m 1,0 h 1 m 2,0 h 1 m 2,0 h 2 m -23,1 h 2 m 1,0 h 1 m 2,0 h 2 m 2,0 h 1 m 1,0 h 1 m 3,0 h 3 m 2,0 h 1 m -17,1 h 8 m 1,0 h 2 m 1,0 h 1 m 1,0 h 1 m -9,1 h 1 m -10,1 h 2 m 1,0 h 2 m 8,0 h 5 m -16,1 h 1 m 1,0 h 2 m 6,0 h 4 m -7,1 h 2 m -7,1 h 1 m 2,0 h 2 m 5,0 h 1 m 1,0 h 2 m -16,1 h 4 m 1,0 h 2 m 1,0 h 3 m 2,0 h 1 m -7,1 h 2 m 1,0 h 2 m -6,1 h 1 m 1,0 h 1 m 2,0 h 1 m -6,1 h 1 m 2,0 h 3 m -7,1 h 1 m 3,0 h 1 m -6,1 h 1 m 3,0 h 2 m -6,1 h 1 m 1,0 h 1 m 1,0 h 1 m 0,-27 h 1 m 2,0 h 1 m -2,1 h 1 m -2,5 h 1 m -17,5 h 1 m 0,1 h 1 m 16,1 h 1 m -13,2 h 1 m 8,0 h 1 m -10,2 h 1 m 0,1 h 1 m 11,2 h 1 m 1,-20 h 1 m -11,1 h 1 m -2,2 h 1 m 4,0 h 1 m -15,3 h 1 m 10,1 h 1 m -1,12 h 1 m -1,3 h 1 m -2,5 h 1 m 1,0 h 1 m 1,-26 h 1 m -11,1 h 1 m 14,2 h 1 m -10,4 h 1 m -9,2 h 1 m 2,1 h 1 m 9,1 h 1 m -10,1 h 1 m 14,1 h 1 m -15,8 h 1 m 6,1 h 1 m -5,1 h 1 m 6,-18 h 1 m -9,19 h 1\"/><path class=\"x\" stroke=\"#fff\" d=\"m 135.5,123.5 h 1 m 7,0 h 1 m 4,0 h 1 m -18,1 h 2 m 3,0 h 1 m 2,0 h 1 m 3,0 h 1 m -16,1 h 1 m 3,0 h 1 m 3,0 h 1 m 3,0 h 1 m 7,0 h 1 m -20,1 h 1 m 17,0 h 1 m -15,1 h 9 m 2,0 h 1 m 7,0 h 1 m -27,1 h 2 m 2,0 h 3 m 2,0 h 1 m 6,0 h 1 m 2,0 h 2 m 3,0 h 2 m -25,1 h 1 m 1,0 h 2 m 3,0 h 1 m 1,0 h 2 m 3,0 h 4 m 2,0 h 2 m -20,1 h 1 m 2,0 h 2 m 1,0 h 1 m 1,0 h 1 m 3,0 h 1 m 1,0 h 1 m 1,0 h 1 m 2,0 h 1 m -21,1 h 1 m 3,0 h 2 m 1,0 h 1 m 1,0 h 1 m 3,0 h 1 m 1,0 h 1 m 1,0 h 1 m 2,0 h 1 m -21,1 h 1 m 4,0 h 4 m 4,0 h 1 m 1,0 h 1 m 1,0 h 1 m 2,0 h 1 m -23,1 h 1 m 1,0 h 1 m 5,0 h 3 m 4,0 h 4 m 3,0 h 1 m -23,1 h 1 m 1,0 h 1 m 3,0 h 1 m -7,1 h 1 m 1,0 h 2 m 2,0 h 1 m 4,0 h 1 m 3,0 h 1 m 4,0 h 2 m 2,0 h 2 m -26,1 h 1 m 2,0 h 3 m 1,0 h 1 m 3,0 h 1 m 4,0 h 1 m 2,0 h 2 m 2,0 h 2 m -24,1 h 1 m 2,0 h 2 m 1,0 h 4 m 1,0 h 1 m 1,0 h 1 m 2,0 h 4 m -19,1 h 2 m 4,0 h 1 m 1,0 h 7 m 2,0 h 1 m -19,1 h 2 m 5,0 h 1 m 4,0 h 1 m 3,0 h 3 m -15,2 h 3 m 7,0 h 4 m -12,1 h 3 m 4,0 h 4 m -16,1 h 1 m 9,0 h 1 m -10,1 h 1 m 1,0 h 2 m 4,0 h 2 m 4,0 h 1 m 2,0 h 1 m -18,1 h 3 m 5,0 h 2 m 1,0 h 1 m 2,0 h 1 m 1,0 h 2 m -8,1 h 3 m -7,1 h 6 m -7,1 h 2 m 4,0 h 1 m -7,1 h 1 m 4,0 h 2 m -6,1 h 5 m -4,-27 h 1 m 3,1 h 1 m 7,0 h 1 m -6,1 h 1 m -1,2 h 1 m 7,0 h 1 m -19,1 h 1 m 2,0 h 1 m -2,1 h 1 m -5,6 h 1 m 16,1 h 1 m -1,1 h 2 m -15,2 h 1 m -4,3 h 1 m 6,-19 h 1 m 7,2 h 1 m -20,5 h 1 m 8,2 h 1 m -9,5 h 1 m 5,1 h 1 m -2,3 h 1 m 4,4 h 1 m 4,0 h 1 m -7,1 h 1 m 3,-19 h 1 m -10,2 h 1 m 10,1 h 1 m 3,4 h 1 m -8,2 h 1 m 5,0 h 1 m -16,1 h 1 m 9,0 h 1 m -5,2 h 1 m -10,4 h 1 m -3,-5 h 1\"/><style>   @keyframes cf{0%{stroke: #303030;}10%{stroke: #0974f8;}20%{stroke: #fe81dd;}30%{stroke: #ff9000;}40%{stroke: #006e15;}50%{stroke: #fe81dd;}60%{stroke: #fbd81c;}70%{stroke: #608a1a;}80%{stroke: #202020;}90%{stroke: #e4e6f2;}}       .bg{animation:bg .05s .025s steps(1) infinite;} @keyframes bg{0%{fill: #161616;}50%{fill: #171717;}}   .x{animation: fr .3s steps(1) infinite,m2 .7s steps(2) infinite, cf 1s steps(1) infinite alternate;}   .y{animation: fr .3s .15s steps(1) infinite,m2 1s steps(3) infinite,cf 1s steps(1) infinite alternate;}   @keyframes m2{0%{transform: translate(0%, 0%)}50%{transform: translate(0%, -3%)}}   @keyframes fr {0%{opacity: 0;}50%{opacity: 1.0;}};} </style></svg>';\n\n    fallback() external payable {}\n    receive() external payable {}\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * PUBLIC: TOKEN DATA\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n    /// @notice A placeholder tokenURI endpoint while tokens are not revealed\n    /// @param tokenId The token ID\n    /// @return A base64 encoded JSON string\n    function prerevealURI(uint tokenId) public view returns (string memory) {\n        return string(\n            abi.encodePacked(\n                'data:application/json;base64,', \n                Base64.encode(\n                    abi.encodePacked(\n                        '{\"name\":\"Terraform #',\n                        ToString.toString(tokenId), \n                        '\",\"description\": \"Terraforms by Mathcastles. Onchain land art from a dynamically generated, onchain 3D world.\"',\n                        ',\"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(\n                            abi.encodePacked(prerevealSVG)\n                        ),\n                        '\"}'\n                    )\n                )\n            )\n        );\n    }\n\n    /// @notice Returns a token's tokenURI\n    /// @param tokenId The token ID\n    /// @param status The token's status\n    /// @param placement Placement of token on level/tile before rotation\n    /// @param seed Seed used to rotate initial token placement\n    /// @param decay Amount of decay affecting the superstructure\n    /// @param canvas The canvas data of a (dreaming) token\n    /// @return result A base64 encoded JSON string\n    function tokenURI(\n        uint tokenId,\n        uint status,\n        uint placement, \n        uint seed, \n        uint decay, \n        uint[] memory canvas\n    ) \n        public \n        view \n        returns (string memory result) \n    {\n        tokenURIContext memory ctx; // Track local variables\n\n        ctx.p = svgParameters( // Generate parameters for creating SVG\n            status,\n            placement, \n            seed, \n            decay, \n            canvas\n        );\n\n        ctx.a = animationParameters(placement, seed); // Generate anim params\n\n        // If there is no external URL for animation or image, we are returning\n        // an SVG from the contract, so generate the SVG\n        // SVG is returned in sections, so we can assemble static and animated\n        // images\n        if (bytes(animationURL).length == 0 || bytes(imageURL).length == 0){\n            (\n                ctx.svgMain, \n                ctx.animations,\n                ctx.script\n            ) = terraformsSVG.makeSVG(ctx.p, ctx.a);\n        }\n        \n        // If there is no external animation URL, return an animated SVG\n        if (bytes(animationURL).length == 0){\n            ctx.animationURI = string(\n                abi.encodePacked(\n                    ', \"animation_url\":\"data:text/html;charset=utf-8,<html><head><meta charset=\\'UTF-8\\'><style>html,body,svg{margin:0;padding:0; height:100%;text-align:center;}</style></head><body>',\n                    ctx.svgMain, \n                    ctx.animations,\n                    '</style>',\n                    ctx.script,\n                    '</svg></body></html>\"'\n                )\n            );\n        } else { // Otherwise, include the external URL with the tokenId\n            ctx.animationURI = string(\n                abi.encodePacked(\n                    ', \"animation_url\":\"',\n                    animationURL, \n                    ToString.toString(tokenId),\n                    '\"'\n                )\n            );\n        }\n\n        // If there is no external image URL, return an SVG w/o animation or JS    \n       if (bytes(imageURL).length == 0){\n            ctx.imageURI = string(\n                abi.encodePacked(\n                    '}], \"image\": \"data:image/svg+xml;base64,',\n                    Base64.encode(\n                        abi.encodePacked(ctx.svgMain,'</style></svg>')\n                    ),\n                    '\"'\n                )\n            );\n        } else { // Otherwise, include the external URL with the tokenId\n            ctx.imageURI = string(\n                abi.encodePacked(\n                    '}], \"image\":\"',\n                    imageURL, \n                    ToString.toString(tokenId),\n                    '\"'\n                )\n            );\n        }\n\n        // Determine the token's activation\n        if (ctx.a.activation == ITerraformsSVG.Activation.Plague) {\n            ctx.activation = \"Plague\";\n        } else if (ctx.a.duration == durations[0]){\n            ctx.activation = \"Hyper\";\n        } else if (ctx.a.duration == durations[1]) {\n            ctx.activation = \"Pulse\";\n        } else {\n            ctx.activation = \"Flow\";\n        }\n\n        // Determine the token's status\n        if (ctx.p.status == 0) {\n            ctx.mode = \"Terrain\";\n        } else if (ctx.p.status == 1) {\n            ctx.mode = \"Daydream\";\n        } else if (ctx.p.status == 2) {\n            ctx.mode = \"Terraform\";\n        } else if (ctx.p.status == 3) {\n            ctx.mode = \"Origin Daydream\";\n        } else {\n            ctx.mode = \"Origin Terraform\";\n        }\n\n        ctx.name = string(\n            abi.encodePacked(\n                'Level ',\n                ToString.toString(ctx.p.level + 1),\n                ' at {',\n                ToString.toString(\n                    ctx.p.tile % levelDimensions[ctx.p.level]\n                ),\n                ', ',\n                ToString.toString(\n                    ctx.p.tile / levelDimensions[ctx.p.level]\n                ),\n                '}'\n            )\n        );\n\n        // Generate tokenURI string\n        result = string(\n            abi.encodePacked(\n                'data:application/json;base64,', \n                Base64.encode(\n                    abi.encodePacked(\n                        '{\"name\":\"',\n                        ctx.name,\n                        '\",\"description\": \"Terraforms by Mathcastles. Onchain land art from a dynamically generated, onchain 3D world.\"',\n                        ctx.animationURI,\n                        ', \"aspect_ratio\":0.6929, \"attributes\": [{\"trait_type\":\"Level\",\"value\":',\n                        ToString.toString(ctx.p.level + 1),\n                        '},{\"trait_type\":\"X Coordinate\",\"value\":\"',\n                        ToString.toString(\n                            ctx.p.tile % levelDimensions[ctx.p.level]\n                        ),\n                        '\"},{\"trait_type\":\"Y Coordinate\",\"value\":\"',\n                        ToString.toString(\n                            ctx.p.tile / levelDimensions[ctx.p.level]\n                        ),\n                        '\"},{\"trait_type\":\"Mode\",\"value\":\"',\n                        ctx.mode,\n                        '\"},{\"trait_type\":\"Zone\",\"value\":\"',\n                        ctx.p.zoneName,\n                        '\"},{\"trait_type\":\"Biome\",\"value\":\"',\n                        ToString.toString(ctx.p.charsIndex),\n                        '\"},{\"trait_type\":\"Chroma\",\"value\":\"',\n                        ctx.activation,\n                         '\"},{\"trait_type\":\"',\n                        resourceName,\n                         '\",\"value\":',\n                        ToString.toString(ctx.p.resourceLvl),         \n                        ctx.imageURI,\n                        '}'\n                    )\n                )\n            )\n        );\n    }\n\n    /// @notice Returns an SVG of a token\n    /// @param status The token's status\n    /// @param placement Placement of token on level/tile before rotation\n    /// @param seed Seed used to rotate initial token placement\n    /// @param decay Amount of decay affecting the superstructure\n    /// @param canvas The canvas data of a (dreaming) token\n    /// @return A plaintext SVG string\n    function tokenSVG(\n        uint status,\n        uint placement, \n        uint seed, \n        uint decay, \n        uint[] memory canvas\n    ) \n        public \n        view \n        returns (string memory) \n    {\n        // Generate parameters for SVG\n        ITerraformsSVG.SVGParams memory p = svgParameters(\n            status,\n            placement, \n            seed, \n            decay, \n            canvas\n        );\n\n        // Generate parameters for animation\n        ITerraformsSVG.AnimParams memory a = animationParameters(\n            placement, \n            seed\n        );\n\n        // SVG is in sections, so we can assemble static and animated images\n        (\n            string memory svgMain, \n            string memory animations,\n            string memory script\n        ) = terraformsSVG.makeSVG(p, a);\n\n        return string(\n            abi.encodePacked\n            (svgMain, \n            animations, \n            '</style>',\n            script,\n            '</svg>')); \n    }\n\n    /// @notice Returns HTML with the token's SVG as plaintext\n    /// @param status The token's status\n    /// @param placement Placement of token on level/tile before rotation\n    /// @param seed Seed used to rotate initial token placement\n    /// @param decay Amount of decay affecting the superstructure\n    /// @param canvas The canvas data of a (dreaming) token\n    /// @return A plaintext HTML string\n    function tokenHTML(\n        uint status,\n        uint placement, \n        uint seed, \n        uint decay, \n        uint[] memory canvas\n    ) \n        public \n        view \n        returns (string memory) \n    {\n        ITerraformsSVG.SVGParams memory p = svgParameters(\n            status,\n            placement, \n            seed, \n            decay, \n            canvas\n        );\n\n        ITerraformsSVG.AnimParams memory a = animationParameters(\n            placement, \n            seed\n        );\n\n        (\n            string memory svgMain, \n            string memory animations,\n            string memory script\n        ) = terraformsSVG.makeSVG(p, a);\n\n        // Wrap the SVG in HTML tags\n        return string(\n            abi.encodePacked(\n                \"<html><head><meta charset='UTF-8'><style>html,body,svg{margin:0;padding:0; height:100%;text-align:center;}</style></head><body>\",\n                svgMain,\n                animations,\n                '</style>',\n                script,\n                \"</svg></body></html>\"\n            )\n        );\n    }\n\n    /// @notice Returns the characters of a token\n    /// @param status The token's status\n    /// @param placement Placement of token on level/tile before rotation\n    /// @param seed Seed used to rotate initial token placement\n    /// @param decay Amount of decay affecting the superstructure\n    /// @param canvas The canvas data of a (dreaming) token\n    /// @return result A 2D array of characters (strings)\n    function tokenCharacters(\n        uint status,\n        uint placement, \n        uint seed, \n        uint decay, \n        uint[] memory canvas\n    ) \n        public \n        view \n        returns (string[32][32] memory result) \n    {\n        // Get the token's character set\n        (string[9] memory chars, , , ) = characterSet(placement, seed);\n\n        // Get the token's heightmap (values correspond to character indices)\n        uint[32][32] memory indices = tokenHeightmapIndices(\n            status,\n            placement, \n            seed, \n            decay, \n            canvas\n        );\n\n        // Translate the indices to characters. If the index is 9, it represents\n        // the background, so we put a space instead\n        for (uint y; y < TOKEN_DIMS; y++) {\n    \t    for (uint x; x < TOKEN_DIMS; x++) {\n                result[y][x] = indices[y][x] < 9 ? chars[indices[y][x]] : \" \";\n    \t    }\n    \t}\n\n    \treturn result;\n    }\n\n    /// @notice Returns the numbers used to create a token's topography\n    /// @dev Values are positions in 3D space. Not applicable to dreaming tokens\n    /// @param placement Placement of token on level/tile before rotation\n    /// @param seed Value used to rotate initial token placement\n    /// @param decay Amount of decay affecting the superstructure\n    /// @return result A 2D array of ints\n    function tokenTerrain(uint placement, uint seed, uint decay) \n        public \n        view \n        returns (int[32][32] memory result) \n    {\n        // The step is the increment in the noise space between each element\n        // of the token\n        int step = STEP;\n\n        // If the structure has decayed for more than 100 years, the step sizes\n        // become larger, causing the token surface to collapse inward\n        if (decay > 100) { \n            step += int(decay - 99) * 100;\n        }\n        \n        // Determine the level and tile on which the token is located\n        (uint level, uint tile) = levelAndTile(placement, seed);\n        \n        // Obtain the XYZ origin for the token\n        int initX = xOrigin(level, tile, seed);\n        int yPos = yOrigin(level, tile, seed);\n        int zPos = zOrigin(level, tile, seed, decay, block.timestamp);\n        int xPos;\n\n        // Populate 2D array\n    \tfor (uint y; y < TOKEN_DIMS; y++) {\n    \t    xPos = initX; // Reset X for row alignment on each iteration\n    \t    for (uint x; x < TOKEN_DIMS; x++) {\n    \t    \tresult[y][x] = perlinNoise.noise3d(xPos, yPos, zPos);\n    \t    \txPos += step;\n    \t    }\n            yPos += step;\n    \t}\n    \treturn result;\n    }\n\n    /// @notice Returns a 2D array of indices into a char array\n    /// @param status The token's status\n    /// @param placement The placement of token on level/tile before rotation\n    /// @param seed Value used to rotate initial token placement\n    /// @param decay Amount of decay affecting the superstructure\n    /// @param canvas The canvas data of a (dreaming) token\n    /// @return result A 2D array of uints to index into a char array\n    function tokenHeightmapIndices(\n        uint status,\n        uint placement, \n        uint seed, \n        uint decay, \n        uint[] memory canvas\n    ) \n        public \n        view \n        returns (uint[32][32] memory result) \n    {\n        // If the token is in terrain mode, generate terrain\n        if (Status(status) == Status.Terrain){\n            int[32][32] memory values = tokenTerrain(placement, seed, decay);\n\n            // Convert terrain values to heightmap indices\n            for (uint y; y < TOKEN_DIMS; y++) {\n                for (uint x; x < TOKEN_DIMS; x++) {\n                    result[y][x] = heightmapIndexFromTerrainValue(values[y][x]);\n                }\n            }\n        } else if (canvas.length == 16){ // If token is terraformed, draw it\n            uint digits;\n            uint counter;\n             // Iterate through canvas data\n            for (uint rowPair; rowPair < 16; rowPair++){\n                // Canvas data is from left to right, so we need to reverse\n                // the integers so we can isolate (modulo) the leftmost digits\n                digits = reverseUint(canvas[rowPair]);\n                for (uint digit; digit < 64; digit++){ // Read 64 digits\n                    result[counter / 32][counter % 32] = digits % 10;\n                    digits = digits / 10; // Shift down one digit\n                    counter += 1;\n                }\n            }\n        }\n        return result;\n    }\n\n    /// @notice Returns the XYZ origins of a level in 3D space\n    /// @param level The level of the superstructure\n    /// @param tile The token's tile placement\n    /// @param seed Value used to rotate initial token placement\n    /// @param decay Amount of decay affecting the superstructure\n    /// @param timestamp The time queried (structure floats and decays in time)\n    /// @return Three ints representing the level's XYZ origins in 3D space\n    function tileOrigin(\n        uint level, \n        uint tile, \n        uint seed, \n        uint decay, \n        uint timestamp\n    )\n        public\n        view\n        returns (int, int, int)\n    {\n        return (\n            xOrigin(level, tile, seed),\n            yOrigin(level, tile, seed),\n            zOrigin(level, tile, seed, decay, timestamp)\n        );\n    }\n\n    /// @notice Returns the x origin of a token in 3D space\n    /// @param level The level of the superstructure\n    /// @param tile The token's tile placement\n    /// @param seed Value used to rotate initial token placement\n    /// @return A uint representing the tile's x origin in 3D space\n    function xOrigin(uint level, uint tile, uint seed) \n        public \n        view \n        returns (int)\n    {\n        // Determine the dimensions (edge length) of the level\n        uint dimensions = levelDimensions[level];\n\n        // A token's x origin is measured in token lengths (STEP * TOKEN_DIMS)\n        // multiplied by a pseudorandom offset (seed), and then placed on the\n        // appropriate x coordinate on a level (tile % dimensions).\n        // Tiles are centered by adding (MAX_LEVEL_DIMS - dimensions) / 2\n        return STEP * int(TOKEN_DIMS) * int(\n            seed + // This is a pseudorandom value to offset the structure\n            (\n                (MAX_LEVEL_DIMS - dimensions) / 2 + // This centers the levels\n                (tile % dimensions) // This gets the x coordinate on the level\n            )\n        );\n    }\n    \n    /// @notice Returns the y origin of a token in 3D space \n    /// @param level The level of the superstructure\n    /// @param tile The token's tile placement\n    /// @param seed Value used to rotate initial token placement\n    /// @return An int representing the tile's y origin in 3D space\n    function yOrigin(uint level, uint tile, uint seed) \n        public \n        view \n        returns (int)\n    {\n        // A token's y origin is measured in token lengths (STEP * TOKEN_DIMS)\n        // multiplied by a pseudorandom offset (seed), and then placed on the\n        // appropriate y coordinate on a level (tile / dimensions).\n        // Tiles are centered by adding (MAX_LEVEL_DIMS - dimensions) / 2\n        uint dimensions = levelDimensions[level];\n        return STEP * int(TOKEN_DIMS) * int(\n            seed +\n            (\n                (MAX_LEVEL_DIMS - dimensions) / 2 +\n                (tile / dimensions)\n            )\n        );\n    }\n\n    /// @notice Returns the z origin of a token in 3D space\n    /// @param level The level of the superstructure\n    /// @param tile The token's tile placement\n    /// @param seed Value used to rotate initial token placement\n    /// @param decay Amount of decay affecting the superstructure\n    /// @param timestamp The time queried (structure floats and decays in time)\n    /// @return An int representing the tile's z origin in 3D space\n    function zOrigin(\n        uint level, \n        uint tile, \n        uint seed, \n        uint decay, \n        uint timestamp\n    ) \n        public \n        view \n        returns (int)\n    {\n        int zDecay;\n\n        // Check if structure is decaying\n        if (decay > 0) {\n            // If decay is less than 100 years, structure is collapsing\n            if (decay <= 100){ \n                zDecay = (STEP / 100) * int(decay);\n            } else {\n                // Otherwise it has collapsed, and only the oscillation remains\n                return zOscillation(level, decay, timestamp);\n            }\n        }\n\n        return (\n            int(\n                (   // Provide a gap of 7 TOKEN_DIMS between layers\n                    (level + 1) * 7 + seed // Add seed for pseudorandom offset\n                ) * TOKEN_DIMS\n            // Create level topography: 3/4 * TOKEN_DIMS * elevation\n            ) + (24 * tokenElevation(level, tile, seed))\n        ) * \n        (STEP - zDecay) + // Reduce stepsize by amount of decay (collapse)\n        zOscillation(level, decay, timestamp); // Add structure oscillation\n    }\n\n    /// @notice Changes a token's elevation on a level according to its zone\n    /// @param level The level of the superstructure\n    /// @param tile The token's tile placement\n    /// @param seed Value used to rotate initial token placement\n    /// @return A signed integer in range +-4\n    function tokenElevation(uint level, uint tile, uint seed) \n        public \n        view \n        returns (int) \n    {   \n        // Elevation is determined by the token's position on the level\n        // Elevation ranges from 4 (for heightmap index 0) to -4 (index 8)\n        return 4 - int(\n            heightmapIndexFromTerrainValue(\n                perlinPlacement(level, tile, seed, 1)\n            )\n        );\n    }\n\n    /// @notice Returns a token's zone, including its name and color scheme\n    /// @param placement The placement of token on level/tile before rotation\n    /// @param seed Value used to rotate initial token placement\n    /// @return An array of hexadecimal strings and a string\n    function tokenZone(uint placement, uint seed) \n        public\n        view\n        returns (string[10] memory, string memory)\n    {\n        // Get level and tile from placement and seed\n        (uint level, uint tile) =  levelAndTile(placement, seed);\n\n        // Get perlin noise value for token's location on level\n        int perlin = perlinPlacement(level, tile, seed, 1);\n\n        // Determine zone from token's position\n        (\n            string[10] memory colors, \n            string memory name\n        ) = terraformsZones.tokenZone(\n            zoneStartingIndex[level] + \n            heightmapIndexFromTerrainValue(perlin) % zonesOnLevel[level]\n        );\n\n        return (colors, name);\n    }\n\n    /// @notice Returns a token's character set\n    /// @param placement The placement of token on level/tile before rotation\n    /// @param seed Value used to rotate initial token placement\n    /// @return charset An array of strings\n    /// @return font The index of the token's font\n    /// @return fontsize The token's font size\n    /// @return index The index of the character set in the storage array\n    function characterSet(uint placement, uint seed) \n        public \n        view \n        returns (\n            string[9] memory charset,\n            uint font, \n            uint fontsize,\n            uint index\n        )\n    {\n        // Characters are determined by level, so obtain it\n        (uint level, ) = levelAndTile(placement, seed);\n\n        // Pseudorandomly select placement into level's character distribution\n        uint rand = uint(\n            keccak256(abi.encodePacked(placement, seed, \"chars\"))\n        ) % 100;\n\n        // Character distributions are weighted per level. \n        // Iterate through  until the sum exceeds our random placement\n        for (uint i; i < 9; i++){\n            index += charsetWeights[level][i];\n            if (rand < index) {\n                index = charsetIndices[i] + rand % charsetLengths[i];\n                (charset, font) = terraformsCharacters.characterSet(index);\n                fontsize = charsetFontsizes[index]; // Fontsize for these chars\n                return (charset, font, fontsize, index);\n            }\n        }\n    }\n\n    /// @notice Determines a token's level and its position on the level\n    /// @param placement The placement of token on level/tile before rotation\n    /// @param seed Value used to rotate initial token placement\n    /// @return level The token's level number\n    /// @return tile The token's tile number\n    function levelAndTile(uint placement, uint seed) \n        public \n        view \n        returns (uint level, uint tile) \n    {\n        // Rotate a token's placement by pseudorandom seed value\n        uint rotated = rotatePlacement(placement, seed);\n        uint cur;\n        uint last;\n\n        // Determine level and tile from rotated placement by summing the tiles\n        // on each level until we find the level it's on\n        for (uint levelIndex; levelIndex < 20; levelIndex++){\n            cur += levelDimensions[levelIndex] ** 2;\n            if (rotated < cur){ // Found the level\n                // The tile is the rotated placement minus the placement of the\n                // first tile on the level\n                (level, tile) = (levelIndex, rotated - last);\n                return (level, tile);\n            }\n            last = cur; // track the last sum so we can find tile placement\n        }\n    }\n\n    /// @notice Returns the position on the z axis of a 2D level\n    /// @dev Z offset cycles over a two year period\n    /// @dev Intensity of the offset increases farther from center levels\n    /// @param level The level of the superstructure\n    /// @param decay Amount of decay affecting the superstructure\n    /// @param timestamp The time queried (structure floats and decays in time)\n    /// @return result An int representing the altitude of the level\n    function zOscillation(uint level, uint decay, uint timestamp) \n        public \n        view \n        returns (int result) \n    {\n        int increment = 6; // base Z oscillation\n        int levelIntensifier; // levels at ends move a greater distance\n        int daysInCycle = 3650; // cycles every 10 years\n        int locationInCycle = int( // current day mod length of cycle\n            ((timestamp - INIT_TIME) / (1 days)) % uint(daysInCycle)\n        );\n\n        // if we're in the first half, the structure is floating up\n        if (locationInCycle < daysInCycle/2){\n            if (level > 9) { // top half moves faster when going up\n                // intensifier will be 5% per level away from center\n                levelIntensifier = int(level - 9); \n            }\n        } else { // if we are in the last half we are floating down\n            increment *= -1; // change direction to downward\n            locationInCycle -= daysInCycle/2; // subtract 1/2 for simpler math\n            if (level < 9){ // bottom half moves faster when going down\n                levelIntensifier = int(9 - level); \n            }\n        } \n\n        // Structure pivots at 1/4 and 3/4 through the cycle\n        result = daysInCycle/4 - locationInCycle;\n        if (result < 0){ // take absolute val of distance from pivot\n            result *= -1;\n        }\n\n        // Z position is distance from pivot point multiplied by increment\n        result = (daysInCycle/4 - result) * increment;\n\n        // Add an intensifier based on distance from center\n        // Multiply and then divide by 20 since we can't do floating pt math\n        result += (result * levelIntensifier)/20;\n\n        // Dampen the result according to the level of decay\n        result = result / int(decay + 1);\n        \n        return result;\n    }\n\n    /// @notice Determines the amount of resource present on a token\n    /// @dev Queries external contract for amount, if address is present\n    /// @param placement The placement of token on level/tile before rotation\n    /// @param seed Value used to rotate initial token placement\n    /// @return An unsigned integer\n    function resourceLevel(uint placement, uint seed) \n        public \n        view\n        returns (uint) \n    {\n        // Resource level is determined by the token's location\n        (uint level, uint tile) = levelAndTile(placement, seed);\n\n        // Check if we are using an external source for resource values\n        if (resourceAddress == address(0)) { // If not, use perlin noise\n            int p = perlinPlacement(level, tile, seed, 3);\n            p = p < 0 ? -p : p; // Take absolute value\n            p = 54_000 - p; // Subtract from 54_000 (a high perlin value)\n            p = p < 0 ? -p : p; // Take absolute value again\n            return uint(p);\n        } else { // Otherwise, call that contract\n            return ITerraformsResource(resourceAddress).amount(\n                rotatePlacement(placement, seed)\n            );\n        }\n    }\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * PUBLIC: ADMINISTRATIVE\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n    /// @notice Sets external URL for token animations\n    /// @dev If set to the empty string, onchain animation will be used\n    /// @param url is the base URL for token animations\n    function setAnimationURL(string memory url) public onlyOwner {\n        animationURL = url;\n    }\n\n    /// @notice Sets external URL for token animations\n    /// @dev If set to the empty string, onchain image will be used\n    /// @param url is the base URL for token images\n    function setImageURL(string memory url) public onlyOwner {\n        imageURL = url;\n    }\n\n    /// @notice Sets resource name\n    /// @param name The resource name\n    function setResourceName(string memory name) public onlyOwner {\n        resourceName = name;\n    }\n\n    /// @notice Sets resource contract address\n    /// @param contractAddress The resource contract address\n    function setResourceAddress(address contractAddress) public onlyOwner {\n        resourceAddress = contractAddress;\n    }\n\n    /// @notice Transfers the contract balance to the owner\n    function withdraw() public onlyOwner {\n        (bool success, ) = owner().call{value: address(this).balance}(\"\");\n        require(success);\n    }\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * INTERNAL: TOKEN DATA HELPERS\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n    /// @notice Returns a perlin noise value for a token\n    /// @param level The level of the superstructure\n    /// @param tile The token's tile placement\n    /// @param seed Value used to rotate initial token placement\n    /// @param scale Multiplier for step size\n    /// @return An int representing a height value\n    function perlinPlacement(uint level, uint tile, uint seed, int scale) \n        internal \n        view \n        returns (int)\n    {\n        // Stretch/shrink the step size to the size of the token's level\n        int stepsize = (STEP * int(TOKEN_DIMS)) / int(levelDimensions[level]);\n\n        // The reference XY is set as the center of the current level\n        // i.e. STEP*TOKEN_DIMS (a token width) * MAX_LEVEL_DIMS/2 (level midpt)\n        // + STEP*14 (the midpoint of the middle token) + 6619/2\n        // + 6619/2 (halfway through the middle step)\n        int refXY = STEP * \n            (14 + int(seed + MAX_LEVEL_DIMS/2) * int(TOKEN_DIMS)) +\n            3309;\n        \n        int result = perlinNoise.noise3d(\n            refXY + int(tile % levelDimensions[level]) * stepsize * scale, // x\n            refXY + int(tile / levelDimensions[level]) * stepsize * scale, // y\n            int((level+1) * TOKEN_DIMS * 2 + (seed*TOKEN_DIMS)) * STEP * scale // z\n        );\n\n        return result;\n    }\n\n    /// @notice Converts a numeric value into an index into a char array \n    /// @dev Converts terrain values into characters\n    /// @param terrainValue An int from perlin noise\n    /// @return An integer to index into a character array\n    function heightmapIndexFromTerrainValue(int256 terrainValue) \n        internal \n        view \n        returns (uint) \n    {\n        // Iterate through the topography array until we find an elem less than\n        // value\n        for (uint i; i < 8; i++) {\n            if (terrainValue > topography[i]) {\n                return i;\n            }\n        }\n        return 8; // if we fall through, return 8 (the lowest height value)\n    }\n\n    /// @notice Determines the direction of a tokens' resource animation\n    /// @dev Direction oscillates from 0-5 over a 10 day period\n    /// @return result an integer from 0 to 5 inclusive\n    function resourceDirection() internal view returns (int result) {\n        uint base = (block.timestamp % (10 days)) / (1 days);\n        int oscillator = 5 - int(base); // Pivot around 5 day point\n        result = oscillator < 0 ? -oscillator : oscillator; // absolute value\n    }\n    \n    /// @notice Returns a 2D array of characters\n    /// @param indices A 2D array of indices into a character array\n    /// @param chars A character array\n    /// @return result A 2D array of characters (strings)\n    function charsFromHeighmapIndices(\n        uint[32][32] memory indices, \n        string[9] memory chars\n    ) \n        internal \n        pure \n        returns (string[32][32] memory result) \n    {\n        // Translate heightmap indices to characters. Each heightmap index\n        // corresponds to an index into a character array. If the index is 9,\n        // it indicates the background, so return a space.\n    \tfor (uint y; y < TOKEN_DIMS; y++) {\n    \t    for (uint x; x < TOKEN_DIMS; x++) {\n                result[y][x] = indices[y][x] < 9 ? chars[indices[y][x]] : \" \";\n    \t    }\n    \t}\n    \treturn result;\n    }\n\n    /// @notice Determines the animation style of a token  \n    /// @param placement The placement of token on level/tile before rotation\n    /// @param seed Value used to rotate initial token placement\n    /// @return An Animation enum representing the type of animation\n    function getActivation(uint placement, uint seed) \n        internal \n        pure \n        returns (ITerraformsSVG.Activation) \n    {\n        // Pseudorandom selection, \"activation\" is a nonce\n        uint activation = uint(\n            keccak256(abi.encodePacked(placement, seed, \"activation\"))\n        ) % 10_000;\n\n        // 0.1% are Plague, the rest are Cascade\n        if (activation >= 9_990){\n            return  ITerraformsSVG.Activation.Plague;\n        } else {\n            return  ITerraformsSVG.Activation.Cascade;\n        }\n    }\n\n    /// @notice Reverses an unsigned integer of up to 64 digits\n    /// @dev Digits past the 64th will be ignored\n    /// @param i The int to be reversed\n    /// @return result The reversed int\n    function reverseUint(uint i) internal pure returns (uint result) {\n        for (uint digit; digit < 64; digit++){\n            result = result * 10 + i % 10;\n            i = i / 10;\n        }\n\n        return result;        \n    }\n\n    /// @notice Determines the animation style of a token  \n    /// @param placement The placement of token on level/tile before rotation\n    /// @param seed Value used to rotate initial token placement\n    /// @return A uint representing the final rotated placement\n    function rotatePlacement(uint placement, uint seed)\n        internal \n        pure \n        returns (uint)\n    {\n        return (placement + seed) % MAX_SUPPLY;\n    }\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * INTERNAL: HELPERS FOR SVG ASSEMBLY\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n    /// @notice Returns the token's parameters to create the tokenURI and SVG\n    /// @param status The token's status\n    /// @param placement The placement of token on level/tile before rotation\n    /// @param seed Value used to rotate initial token placement\n    /// @param decay Amount of decay affecting the superstructure\n    /// @param canvas The canvas data of a (dreaming) token\n    /// @return p A SVGParams struct\n    function svgParameters(\n        uint status,\n        uint placement, \n        uint seed, \n        uint decay, \n        uint[] memory canvas\n    ) \n        internal \n        view \n        returns (ITerraformsSVG.SVGParams memory p) \n    {\n        p.status = status;\n        (p.level, p.tile) = levelAndTile(placement, seed);\n        p.resourceLvl = resourceLevel(placement, seed);\n        p.resourceDirection = uint(resourceDirection()); \n        (p.zoneColors, p.zoneName) = tokenZone(placement, seed);\n        (p.chars, p.font, p.fontSize, p.charsIndex) = characterSet(\n            placement, \n            seed\n        );\n        p.heightmapIndices = tokenHeightmapIndices(\n            status, \n            placement, \n            seed, \n            decay, \n            canvas\n        );\n        \n        return p;\n    }\n\n    /// @notice Determines CSS styles based on a token's animation type\n    /// @param placement The placement of token on level/tile before rotation\n    /// @param seed Value used to rotate initial token placement\n    /// @return a An AnimParams struct\n    function animationParameters(uint placement, uint seed) \n        internal \n        view \n        returns (ITerraformsSVG.AnimParams memory a) \n    {\n        // Use pseudorandom value for determining animation\n        uint sorter = uint(keccak256(abi.encodePacked(placement, seed)));\n        a.activation = getActivation(placement, seed);\n\n        // Baseline animation keyframes ('ms' is for string concatenation later)\n        a.easing = 'ms steps(1)';\n\n        if (a.activation == ITerraformsSVG.Activation.Plague) {\n            a.classesAnimated = 876543210; // All classes are animated\n            a.duration = 100 + (sorter % 400); // Speed from 100 to 500 ms\n            a.durationInc = a.duration; // Duration increases for each class\n            if (sorter % 2 == 0){ // Half of the animations are delayed by 2-4s\n                a.delay = 2000 + (sorter % 2000);\n                a.delayInc = a.delay;\n                a.bgDelay = a.delay * 11;\n            }\n            a.bgDuration = 50; // Backgrounds are animated at high speed\n            a.altColors = altColors[(sorter / 10) % 7]; // Alternate colors\n        } else { // If token activation is not plague, determine animation amt\n            if ((sorter / 1000) % 100 < 50){\n                a.classesAnimated = animatedClasses[2];\n            } else if ((sorter / 1000) % 100 < 80){\n                a.classesAnimated = animatedClasses[1];\n            } else {\n                a.classesAnimated = animatedClasses[0];\n            }\n            \n            // Determine animation speed\n            if (sorter % 100 < 60){\n                a.duration = durations[2];\n            } else if (sorter % 100 < 90) {\n                a.duration = durations[1];\n            } else {\n                a.duration = durations[0];\n            }\n            \n            // Determine animation rhythm\n            if ((sorter / 10_000) % 100 < 10){\n                a.delayInc = a.duration / 10;\n            } else {\n                if (a.classesAnimated > 100_000){\n                    a.delayInc = a.duration / 7;\n                } else if (a.classesAnimated > 10_000){\n                    a.delayInc = a.duration / 5;\n                } else {\n                    a.delayInc = a.duration / 4;\n                }\n            }\n            \n            // Use linear keyframes for all slow animations and for half of\n            // medium animations\n            if (\n                a.duration == durations[2] ||\n                (a.duration == durations[1] && (sorter / 100) % 100 >= 50)\n            ) {\n                a.easing = 'ms linear alternate both';\n            }\n\n            // Add a duration increment to 25% of tokens that are cascade\n            // and not fast animations\n            if(\n                a.activation == ITerraformsSVG.Activation.Cascade &&\n                sorter % 4 == 0 &&\n                a.duration != durations[0]\n            ) {\n                a.durationInc = a.duration / 5;\n            }\n        }\n\n        return a; \n    }\n}"
    },
    "contracts/TerraformsDataInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITerraformsSVG {\n    struct SVGParams {\n        uint[32][32] heightmapIndices;\n        uint level;\n        uint tile;\n        uint resourceLvl;\n        uint resourceDirection;\n        uint status;\n        uint font;\n        uint fontSize;\n        uint charsIndex;\n        string zoneName;\n        string[9] chars;\n        string[10] zoneColors;\n    }\n\n    struct AnimParams {\n        Activation activation; // Token's animation type\n        uint classesAnimated; // Classes animated\n        uint duration; // Base animation duration for first class\n        uint durationInc; // Duration increment for each class\n        uint delay; // Base delay for first class\n        uint delayInc; // Delay increment for each class\n        uint bgDuration; // Animation duration for background\n        uint bgDelay; // Delay for background\n        string easing; // Animation mode, e.g. steps(), linear, ease-in-out\n        string[2] altColors;\n    }\n\n    enum Activation {Cascade, Plague}\n    \n    function makeSVG(SVGParams memory, AnimParams memory) \n        external \n        view \n        returns (string memory, string memory, string memory);\n}\n\ninterface ITerraformsZones {\n    function tokenZone(uint index) \n        external \n        view \n        returns (string[10] memory, string memory);\n}\n\ninterface ITerraformsCharacters {\n    function characterSet(uint index) \n        external \n        view \n        returns (string[9] memory, uint);\n}\n\ninterface IPerlinNoise {\n    function noise3d(int256, int256, int256) external view returns (int256);\n}\n\ninterface ITerraformsResource {\n    function amount(uint) external view returns (uint);\n}"
    },
    "contracts/TerraformsDataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract TerraformsDataStorage {   \n    uint[9] charsetIndices = [0, 21, 43, 50, 59, 66, 73, 77, 83];\n    uint[9] charsetLengths = [21, 22, 7, 9, 7, 7, 4, 6, 9];\n\n    uint[3] durations = [300, 800, 8_000];\n\n    uint[3] animatedClasses = [7651,65432,7654321];\n\n    string[2][7] altColors = [\n        [\"#ffffff\",\"#202020\"],\n        [\"#b169ff\",\"#ff2436\"], \n        [\"#eb048d\",\"#05a98d\"],\n        [\"#0000ff\",\"#ffffff\"], \n        [\"#ff0000\",\"#ffffff\"], \n        [\"#eb8034\",\"#0000ff\"],\n        [\"#ffb8ff \",\"#202020\"]\n    ];\n\n    uint[20] public levelDimensions = [\n        4, \n        8, \n        8, \n        16, \n        16, \n        24, \n        24, \n        24, \n        16, \n        32, \n        32, \n        16, \n        48, \n        48, \n        24, \n        24, \n        16, \n        8, \n        8, \n        4\n    ]; \n    \n    int[8] public topography = [\n        int(18_000), \n        int(12_000), \n        int(4_000), \n        -4_000, \n        -12_000, \n        -20_000, \n        -22_000, \n        -26_000\n    ];\n\n    uint[20] zoneStartingIndex = [\n        74, \n        74, \n        74, \n        74, \n        71, \n        65, \n        60, \n        54, \n        51, \n        43, \n        36, \n        34, \n        25, \n        17, \n        8, \n        1, \n        0, \n        0, \n        0, \n        0\n    ];\n\n    uint[20] zonesOnLevel = [\n        1, \n        1, \n        1, \n        1, \n        3, \n        6, \n        5, \n        6, \n        3, \n        8, \n        7, \n        2, \n        9, \n        8, \n        9, \n        7, \n        1, \n        1, \n        1, \n        1\n    ];\n\n    uint[9][20] charsetWeights = [\n        [0, 50, 0, 0, 0, 0, 0, 0, 50], \n        [22, 11, 11, 11, 11, 11, 1, 11, 11], \n        [22, 11, 11, 11, 11, 11, 1, 11, 11], \n        [5, 0, 5, 90, 0, 0, 0, 0, 0], \n        [10, 3, 1, 5, 1, 2, 1, 0, 77], \n        [30, 55, 5, 5, 2, 2, 1, 0, 0], \n        [20, 18, 30, 20, 5, 5, 1, 1, 0], \n        [25, 32, 5, 5, 30, 2, 1, 0, 0], \n        [10, 3, 1, 5, 1, 2, 1, 0, 77], \n        [20, 20, 14, 14, 10, 10, 1, 1, 10], \n        [20, 20, 14, 14, 10, 10, 1, 1, 10], \n        [30, 55, 5, 5, 2, 2, 1, 0, 0], \n        [10, 20, 18, 25, 15, 10, 1, 1, 0], \n        [10, 30, 25, 18, 5, 10, 1, 1, 0], \n        [10, 30, 25, 18, 5, 10, 1, 1, 0], \n        [10, 20, 18, 25, 15, 10, 1, 1, 0], \n        [22, 11, 11, 11, 11, 11, 1, 11, 11], \n        [5, 5, 10, 5, 5, 14, 1, 5, 50], \n        [50, 25, 0, 0, 0, 0, 0, 0, 25], \n        [0, 100, 0, 0, 0, 0, 0, 0, 0]\n    ];       \n\n    uint[92] charsetFontsizes = [\n        27,\n        18,\n        18,\n        18,\n        26,\n        23,\n        23,\n        18,\n        22,\n        18,\n        18,\n        18,\n        22,\n        18,\n        17,\n        18,\n        18,\n        26,\n        14,\n        18,\n        20,\n        20,\n        22,\n        18,\n        13,\n        20,\n        22,\n        22,\n        22,\n        22,\n        20,\n        22,\n        15,\n        15,\n        18,\n        24,\n        23,\n        14,\n        18,\n        18,\n        16,\n        20,\n        25,\n        14,\n        15,\n        16,\n        12,\n        12,\n        12,\n        18,\n        15,\n        16,\n        16,\n        16,\n        11,\n        12,\n        15,\n        12,\n        14,\n        14,\n        16,\n        16,\n        13,\n        13,\n        14,\n        12,\n        13,\n        11,\n        12,\n        12,\n        10,\n        9,\n        9,\n        14,\n        11,\n        12,\n        14,\n        16,\n        12,\n        12,\n        12,\n        14,\n        14,\n        12,\n        14,\n        15,\n        17,\n        22,\n        17,\n        14,\n        14,\n        14\n    ];\n}"
    },
    "contracts/ToString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary ToString {\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT license\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    }
  }
}