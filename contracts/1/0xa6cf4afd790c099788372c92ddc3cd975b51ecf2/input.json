{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "XSwapProxyV1.sol": {
      "content": "// File: contracts/interface/IXPool.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IXPool {\r\n    // XPToken\r\n    event Approval(address indexed src, address indexed dst, uint256 amt);\r\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address whom) external view returns (uint256);\r\n\r\n    function allowance(address src, address dst)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address dst, uint256 amt) external returns (bool);\r\n\r\n    function transfer(address dst, uint256 amt) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 amt\r\n    ) external returns (bool);\r\n\r\n    // Swap\r\n    function swapExactAmountIn(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice\r\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\r\n\r\n    function swapExactAmountOut(\r\n        address tokenIn,\r\n        uint256 maxAmountIn,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPrice\r\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\r\n\r\n    // Referral\r\n    function swapExactAmountInRefer(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice,\r\n        address referrer\r\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\r\n\r\n    function swapExactAmountOutRefer(\r\n        address tokenIn,\r\n        uint256 maxAmountIn,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPrice,\r\n        address referrer\r\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\r\n\r\n    // Pool Data\r\n    function isBound(address token) external view returns (bool);\r\n\r\n    function getFinalTokens() external view returns (address[] memory tokens);\r\n\r\n    function getBalance(address token) external view returns (uint256);\r\n\r\n    function swapFee() external view returns (uint256);\r\n\r\n    function exitFee() external view returns (uint256);\r\n\r\n    function finalized() external view returns (uint256);\r\n\r\n    function controller() external view returns (uint256);\r\n\r\n    function xconfig() external view returns (uint256);\r\n\r\n    function getDenormalizedWeight(address) external view returns (uint256);\r\n\r\n    function getTotalDenormalizedWeight() external view returns (uint256);\r\n\r\n    function getVersion() external view returns (bytes32);\r\n\r\n    function calcInGivenOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 _swapFee\r\n    ) external pure returns (uint256 tokenAmountIn);\r\n\r\n    function calcOutGivenIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 _swapFee\r\n    ) external pure returns (uint256 tokenAmountOut);\r\n\r\n    // Pool Managment\r\n    function setController(address _controller) external;\r\n\r\n    function setExitFee(uint256 newFee) external;\r\n\r\n    function finalize(uint256 _swapFee) external;\r\n\r\n    function bind(address token, uint256 denorm) external;\r\n\r\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\r\n        external;\r\n\r\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\r\n        external;\r\n\r\n    function joinswapExternAmountIn(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        uint256 minPoolAmountOut\r\n    ) external returns (uint256 poolAmountOut);\r\n\r\n    function exitswapPoolAmountIn(\r\n        address tokenOut,\r\n        uint256 poolAmountIn,\r\n        uint256 minAmountOut\r\n    ) external returns (uint256 tokenAmountOut);\r\n\r\n    // Pool Governance\r\n    function updateSafu(address safu, uint256 fee) external;\r\n\r\n    function updateFarm(bool isFarm) external;\r\n}\r\n\r\n// File: contracts/interface/IXFactory.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\ninterface IXFactory {\r\n    function newXPool() external returns (IXPool);\r\n}\r\n\r\n// File: contracts/interface/IXConfig.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IXConfig {\r\n    function getCore() external view returns (address);\r\n\r\n    function getSAFU() external view returns (address);\r\n\r\n    function isFarmPool(address pool) external view returns (bool);\r\n\r\n    function getMaxExitFee() external view returns (uint256);\r\n\r\n    function getSafuFee() external view returns (uint256);\r\n\r\n    function getSwapProxy() external view returns (address);\r\n\r\n    function ethAddress() external pure returns (address);\r\n\r\n    function hasPool(address[] calldata tokens, uint256[] calldata denorms)\r\n        external\r\n        view\r\n        returns (bool exist, bytes32 sig);\r\n\r\n    // add by XSwapProxy\r\n    function addPoolSig(bytes32 sig) external;\r\n\r\n    // remove by XSwapProxy\r\n    function removePoolSig(bytes32 sig) external;\r\n}\r\n\r\n// File: contracts/interface/IERC20.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256 remaining);\r\n}\r\n\r\n// File: contracts/lib/XNum.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\nlibrary XNum {\r\n    uint256 public constant BONE = 10**18;\r\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\r\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\r\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\r\n\r\n    function btoi(uint256 a) internal pure returns (uint256) {\r\n        return a / BONE;\r\n    }\r\n\r\n    function bfloor(uint256 a) internal pure returns (uint256) {\r\n        return btoi(a) * BONE;\r\n    }\r\n\r\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        (uint256 c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c1 = c0 + (BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c2 = c1 / BONE;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint256 c0 = a * BONE;\r\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint256 c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint256 c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    // DSMath.wpow\r\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\r\n        uint256 z = n % 2 != 0 ? a : BONE;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\r\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\r\n    // of approximation of b^0.w\r\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\r\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\r\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\r\n\r\n        uint256 whole = bfloor(exp);\r\n        uint256 remain = bsub(exp, whole);\r\n\r\n        uint256 wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(\r\n        uint256 base,\r\n        uint256 exp,\r\n        uint256 precision\r\n    ) internal pure returns (uint256) {\r\n        // term 0:\r\n        uint256 a = exp;\r\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\r\n        uint256 term = BONE;\r\n        uint256 sum = term;\r\n        bool negative = false;\r\n\r\n        // term(k) = numer / denom\r\n        //         = (product(a - i + 1, i=1-->k) * x^k) / (k!)\r\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\r\n        // continue until term is less than precision\r\n        for (uint256 i = 1; term >= precision; i++) {\r\n            uint256 bigK = i * BONE;\r\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/Address.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n//https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/utils/Address.sol\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash =\r\n            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account)\r\n        internal\r\n        pure\r\n        returns (address payable)\r\n    {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount).gas(9100)(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/lib/SafeERC20.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n//https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ReentrancyGuard.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n//https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/utils/ReentrancyGuard.sol\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n *\r\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\r\n * metering changes introduced in the Istanbul hardfork.\r\n */\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor() internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// File: contracts/XSwapProxyV1.sol\r\n\r\npragma solidity 0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// WETH9\r\ninterface IWETH {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address, uint256) external returns (bool);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 amount) external;\r\n}\r\n\r\ncontract XSwapProxyV1 is ReentrancyGuard {\r\n    using XNum for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 public constant MAX = 2**256 - 1;\r\n    uint256 public constant BONE = 10**18;\r\n    uint256 public constant MIN_BOUND_TOKENS = 2;\r\n    uint256 public constant MAX_BOUND_TOKENS = 8;\r\n\r\n    uint256 public constant MIN_BATCH_SWAPS = 1;\r\n    uint256 public constant MAX_BATCH_SWAPS = 4;\r\n\r\n    // WETH9\r\n    IWETH weth;\r\n\r\n    IXConfig public xconfig;\r\n\r\n    constructor(address _weth, address _xconfig) public {\r\n        weth = IWETH(_weth);\r\n        xconfig = IXConfig(_xconfig);\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    // Batch Swap\r\n    struct Swap {\r\n        address pool;\r\n        uint256 tokenInParam; // tokenInAmount / maxAmountIn\r\n        uint256 tokenOutParam; // minAmountOut / tokenAmountOut\r\n        uint256 maxPrice;\r\n    }\r\n\r\n    function batchSwapExactIn(\r\n        Swap[] memory swaps,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 totalAmountIn,\r\n        uint256 minTotalAmountOut\r\n    ) public payable returns (uint256 totalAmountOut) {\r\n        return\r\n            batchSwapExactInRefer(\r\n                swaps,\r\n                tokenIn,\r\n                tokenOut,\r\n                totalAmountIn,\r\n                minTotalAmountOut,\r\n                address(0x0)\r\n            );\r\n    }\r\n\r\n    function batchSwapExactInRefer(\r\n        Swap[] memory swaps,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 totalAmountIn,\r\n        uint256 minTotalAmountOut,\r\n        address referrer\r\n    ) public payable nonReentrant returns (uint256 totalAmountOut) {\r\n        require(\r\n            swaps.length >= MIN_BATCH_SWAPS && swaps.length <= MAX_BATCH_SWAPS,\r\n            \"ERR_BATCH_COUNT\"\r\n        );\r\n\r\n        IERC20 TI = IERC20(tokenIn);\r\n        IERC20 TO = IERC20(tokenOut);\r\n\r\n        transferFromAllTo(TI, totalAmountIn, address(this));\r\n\r\n        uint256 actualTotalIn = 0;\r\n        for (uint256 i = 0; i < swaps.length; i++) {\r\n            Swap memory swap = swaps[i];\r\n            IXPool pool = IXPool(swap.pool);\r\n\r\n            if (TI.allowance(address(this), swap.pool) < totalAmountIn) {\r\n                TI.safeApprove(swap.pool, 0);\r\n                TI.safeApprove(swap.pool, MAX);\r\n            }\r\n\r\n            (uint256 tokenAmountOut, ) =\r\n                pool.swapExactAmountInRefer(\r\n                    tokenIn,\r\n                    swap.tokenInParam,\r\n                    tokenOut,\r\n                    swap.tokenOutParam,\r\n                    swap.maxPrice,\r\n                    referrer\r\n                );\r\n\r\n            actualTotalIn = actualTotalIn.badd(swap.tokenInParam);\r\n            totalAmountOut = tokenAmountOut.badd(totalAmountOut);\r\n        }\r\n        require(actualTotalIn <= totalAmountIn, \"ERR_ACTUAL_IN\");\r\n        require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\r\n\r\n        transferAll(TO, totalAmountOut);\r\n        transferAll(TI, getBalance(tokenIn));\r\n        return totalAmountOut;\r\n    }\r\n\r\n    function batchSwapExactOut(\r\n        Swap[] memory swaps,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 maxTotalAmountIn\r\n    ) public payable returns (uint256 totalAmountIn) {\r\n        return\r\n            batchSwapExactOutRefer(\r\n                swaps,\r\n                tokenIn,\r\n                tokenOut,\r\n                maxTotalAmountIn,\r\n                address(0x0)\r\n            );\r\n    }\r\n\r\n    function batchSwapExactOutRefer(\r\n        Swap[] memory swaps,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 maxTotalAmountIn,\r\n        address referrer\r\n    ) public payable nonReentrant returns (uint256 totalAmountIn) {\r\n        require(\r\n            swaps.length >= MIN_BATCH_SWAPS && swaps.length <= MAX_BATCH_SWAPS,\r\n            \"ERR_BATCH_COUNT\"\r\n        );\r\n\r\n        IERC20 TI = IERC20(tokenIn);\r\n        IERC20 TO = IERC20(tokenOut);\r\n\r\n        transferFromAllTo(TI, maxTotalAmountIn, address(this));\r\n\r\n        for (uint256 i = 0; i < swaps.length; i++) {\r\n            Swap memory swap = swaps[i];\r\n            IXPool pool = IXPool(swap.pool);\r\n\r\n            if (TI.allowance(address(this), swap.pool) < maxTotalAmountIn) {\r\n                TI.safeApprove(swap.pool, 0);\r\n                TI.safeApprove(swap.pool, MAX);\r\n            }\r\n\r\n            (uint256 tokenAmountIn, ) =\r\n                pool.swapExactAmountOutRefer(\r\n                    tokenIn,\r\n                    swap.tokenInParam,\r\n                    tokenOut,\r\n                    swap.tokenOutParam,\r\n                    swap.maxPrice,\r\n                    referrer\r\n                );\r\n            totalAmountIn = tokenAmountIn.badd(totalAmountIn);\r\n        }\r\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        transferAll(TO, getBalance(tokenOut));\r\n        transferAll(TI, getBalance(tokenIn));\r\n    }\r\n\r\n    // Multihop Swap\r\n    struct MSwap {\r\n        address pool;\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint256 swapAmount; // tokenInAmount / tokenOutAmount\r\n        uint256 limitReturnAmount; // minAmountOut / maxAmountIn\r\n        uint256 maxPrice;\r\n    }\r\n\r\n    function multihopBatchSwapExactIn(\r\n        MSwap[][] memory swapSequences,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 totalAmountIn,\r\n        uint256 minTotalAmountOut\r\n    ) public payable returns (uint256 totalAmountOut) {\r\n        return\r\n            multihopBatchSwapExactInRefer(\r\n                swapSequences,\r\n                tokenIn,\r\n                tokenOut,\r\n                totalAmountIn,\r\n                minTotalAmountOut,\r\n                address(0x0)\r\n            );\r\n    }\r\n\r\n    function multihopBatchSwapExactInRefer(\r\n        MSwap[][] memory swapSequences,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 totalAmountIn,\r\n        uint256 minTotalAmountOut,\r\n        address referrer\r\n    ) public payable nonReentrant returns (uint256 totalAmountOut) {\r\n        require(\r\n            swapSequences.length >= MIN_BATCH_SWAPS &&\r\n                swapSequences.length <= MAX_BATCH_SWAPS,\r\n            \"ERR_BATCH_COUNT\"\r\n        );\r\n\r\n        transferFromAllTo(IERC20(tokenIn), totalAmountIn, address(this));\r\n\r\n        uint256 actualTotalIn = 0;\r\n        for (uint256 i = 0; i < swapSequences.length; i++) {\r\n            require(tokenIn == swapSequences[i][0].tokenIn, \"ERR_NOT_MATCH\");\r\n            actualTotalIn = actualTotalIn.badd(swapSequences[i][0].swapAmount);\r\n\r\n            uint256 tokenAmountOut = 0;\r\n            for (uint256 k = 0; k < swapSequences[i].length; k++) {\r\n                MSwap memory swap = swapSequences[i][k];\r\n\r\n                IERC20 SwapTokenIn = IERC20(swap.tokenIn);\r\n                if (k == 1) {\r\n                    // Makes sure that on the second swap the output of the first was used\r\n                    // so there is not intermediate token leftover\r\n                    swap.swapAmount = tokenAmountOut;\r\n                }\r\n\r\n                IXPool pool = IXPool(swap.pool);\r\n                if (\r\n                    SwapTokenIn.allowance(address(this), swap.pool) <\r\n                    totalAmountIn\r\n                ) {\r\n                    SwapTokenIn.safeApprove(swap.pool, 0);\r\n                    SwapTokenIn.safeApprove(swap.pool, MAX);\r\n                }\r\n\r\n                (tokenAmountOut, ) = pool.swapExactAmountInRefer(\r\n                    swap.tokenIn,\r\n                    swap.swapAmount,\r\n                    swap.tokenOut,\r\n                    swap.limitReturnAmount,\r\n                    swap.maxPrice,\r\n                    referrer\r\n                );\r\n            }\r\n            // This takes the amountOut of the last swap\r\n            totalAmountOut = tokenAmountOut.badd(totalAmountOut);\r\n        }\r\n\r\n        require(actualTotalIn <= totalAmountIn, \"ERR_ACTUAL_IN\");\r\n        require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\r\n\r\n        transferAll(IERC20(tokenOut), totalAmountOut);\r\n        transferAll(IERC20(tokenIn), getBalance(tokenIn));\r\n    }\r\n\r\n    function multihopBatchSwapExactOut(\r\n        MSwap[][] memory swapSequences,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 maxTotalAmountIn\r\n    ) public payable returns (uint256 totalAmountIn) {\r\n        return\r\n            multihopBatchSwapExactOutRefer(\r\n                swapSequences,\r\n                tokenIn,\r\n                tokenOut,\r\n                maxTotalAmountIn,\r\n                address(0x0)\r\n            );\r\n    }\r\n\r\n    function multihopBatchSwapExactOutRefer(\r\n        MSwap[][] memory swapSequences,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 maxTotalAmountIn,\r\n        address referrer\r\n    ) public payable nonReentrant returns (uint256 totalAmountIn) {\r\n        require(\r\n            swapSequences.length >= MIN_BATCH_SWAPS &&\r\n                swapSequences.length <= MAX_BATCH_SWAPS,\r\n            \"ERR_BATCH_COUNT\"\r\n        );\r\n\r\n        transferFromAllTo(IERC20(tokenIn), maxTotalAmountIn, address(this));\r\n\r\n        for (uint256 i = 0; i < swapSequences.length; i++) {\r\n            require(tokenIn == swapSequences[i][0].tokenIn, \"ERR_NOT_MATCH\");\r\n\r\n            uint256 tokenAmountInFirstSwap;\r\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\r\n            if (swapSequences[i].length == 1) {\r\n                MSwap memory swap = swapSequences[i][0];\r\n                IERC20 SwapTokenIn = IERC20(swap.tokenIn);\r\n\r\n                IXPool pool = IXPool(swap.pool);\r\n                if (\r\n                    SwapTokenIn.allowance(address(this), swap.pool) <\r\n                    maxTotalAmountIn\r\n                ) {\r\n                    SwapTokenIn.safeApprove(swap.pool, 0);\r\n                    SwapTokenIn.safeApprove(swap.pool, MAX);\r\n                }\r\n\r\n                (tokenAmountInFirstSwap, ) = pool.swapExactAmountOutRefer(\r\n                    swap.tokenIn,\r\n                    swap.limitReturnAmount,\r\n                    swap.tokenOut,\r\n                    swap.swapAmount,\r\n                    swap.maxPrice,\r\n                    referrer\r\n                );\r\n            } else {\r\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\r\n                // of token C. But first we need to buy B with A so we can then buy C with B\r\n                // To get the exact amount of C we then first need to calculate how much B we'll need:\r\n                uint256 intermediateTokenAmount;\r\n                // This would be token B as described above\r\n                MSwap memory secondSwap = swapSequences[i][1];\r\n                IXPool poolSecondSwap = IXPool(secondSwap.pool);\r\n                intermediateTokenAmount = poolSecondSwap.calcInGivenOut(\r\n                    poolSecondSwap.getBalance(secondSwap.tokenIn),\r\n                    poolSecondSwap.getDenormalizedWeight(secondSwap.tokenIn),\r\n                    poolSecondSwap.getBalance(secondSwap.tokenOut),\r\n                    poolSecondSwap.getDenormalizedWeight(secondSwap.tokenOut),\r\n                    secondSwap.swapAmount,\r\n                    poolSecondSwap.swapFee()\r\n                );\r\n\r\n                //// Buy intermediateTokenAmount of token B with A in the first pool\r\n                MSwap memory firstSwap = swapSequences[i][0];\r\n                IERC20 FirstSwapTokenIn = IERC20(firstSwap.tokenIn);\r\n                IXPool poolFirstSwap = IXPool(firstSwap.pool);\r\n                if (\r\n                    FirstSwapTokenIn.allowance(address(this), firstSwap.pool) <\r\n                    MAX\r\n                ) {\r\n                    FirstSwapTokenIn.safeApprove(firstSwap.pool, 0);\r\n                    FirstSwapTokenIn.safeApprove(firstSwap.pool, MAX);\r\n                }\r\n\r\n                (tokenAmountInFirstSwap, ) = poolFirstSwap.swapExactAmountOut(\r\n                    firstSwap.tokenIn,\r\n                    firstSwap.limitReturnAmount,\r\n                    firstSwap.tokenOut,\r\n                    intermediateTokenAmount, // This is the amount of token B we need\r\n                    firstSwap.maxPrice\r\n                );\r\n\r\n                //// Buy the final amount of token C desired\r\n                IERC20 SecondSwapTokenIn = IERC20(secondSwap.tokenIn);\r\n                if (\r\n                    SecondSwapTokenIn.allowance(\r\n                        address(this),\r\n                        secondSwap.pool\r\n                    ) < MAX\r\n                ) {\r\n                    SecondSwapTokenIn.safeApprove(secondSwap.pool, 0);\r\n                    SecondSwapTokenIn.safeApprove(secondSwap.pool, MAX);\r\n                }\r\n\r\n                poolSecondSwap.swapExactAmountOut(\r\n                    secondSwap.tokenIn,\r\n                    secondSwap.limitReturnAmount,\r\n                    secondSwap.tokenOut,\r\n                    secondSwap.swapAmount,\r\n                    secondSwap.maxPrice\r\n                );\r\n            }\r\n            totalAmountIn = tokenAmountInFirstSwap.badd(totalAmountIn);\r\n        }\r\n\r\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        transferAll(IERC20(tokenOut), getBalance(tokenOut));\r\n        transferAll(IERC20(tokenIn), getBalance(tokenIn));\r\n    }\r\n\r\n    // Pool Management\r\n    function create(\r\n        address factoryAddress,\r\n        address[] calldata tokens,\r\n        uint256[] calldata balances,\r\n        uint256[] calldata denorms,\r\n        uint256 swapFee,\r\n        uint256 exitFee\r\n    ) external payable nonReentrant returns (address) {\r\n        require(tokens.length == balances.length, \"ERR_LENGTH_MISMATCH\");\r\n        require(tokens.length == denorms.length, \"ERR_LENGTH_MISMATCH\");\r\n        require(tokens.length >= MIN_BOUND_TOKENS, \"ERR_MIN_TOKENS\");\r\n        require(tokens.length <= MAX_BOUND_TOKENS, \"ERR_MAX_TOKENS\");\r\n\r\n        // check pool exist\r\n        (bool exist, bytes32 sig) = xconfig.hasPool(tokens, denorms);\r\n        require(!exist, \"ERR_POOL_EXISTS\");\r\n\r\n        // create new pool\r\n        IXPool pool = IXFactory(factoryAddress).newXPool();\r\n        bool hasETH = false;\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            if (\r\n                transferFromAllTo(IERC20(tokens[i]), balances[i], address(pool))\r\n            ) {\r\n                hasETH = true;\r\n                pool.bind(address(weth), denorms[i]);\r\n            } else {\r\n                pool.bind(tokens[i], denorms[i]);\r\n            }\r\n        }\r\n        require(msg.value == 0 || hasETH, \"ERR_INVALID_PAY\");\r\n        pool.setExitFee(exitFee);\r\n        pool.finalize(swapFee);\r\n\r\n        xconfig.addPoolSig(sig);\r\n        pool.transfer(msg.sender, pool.balanceOf(address(this)));\r\n\r\n        return address(pool);\r\n    }\r\n\r\n    function joinPool(\r\n        address poolAddress,\r\n        uint256 poolAmountOut,\r\n        uint256[] calldata maxAmountsIn\r\n    ) external payable nonReentrant {\r\n        IXPool pool = IXPool(poolAddress);\r\n\r\n        address[] memory tokens = pool.getFinalTokens();\r\n        require(maxAmountsIn.length == tokens.length, \"ERR_LENGTH_MISMATCH\");\r\n\r\n        bool hasEth = false;\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            if (msg.value > 0 && tokens[i] == address(weth)) {\r\n                transferFromAllAndApprove(\r\n                    xconfig.ethAddress(),\r\n                    maxAmountsIn[i],\r\n                    poolAddress\r\n                );\r\n                hasEth = true;\r\n            } else {\r\n                transferFromAllAndApprove(\r\n                    tokens[i],\r\n                    maxAmountsIn[i],\r\n                    poolAddress\r\n                );\r\n            }\r\n        }\r\n        require(msg.value == 0 || hasEth, \"ERR_INVALID_PAY\");\r\n        pool.joinPool(poolAmountOut, maxAmountsIn);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            if (hasEth) {\r\n                transferAll(\r\n                    IERC20(xconfig.ethAddress()),\r\n                    getBalance(xconfig.ethAddress())\r\n                );\r\n            } else {\r\n                transferAll(IERC20(tokens[i]), getBalance(tokens[i]));\r\n            }\r\n        }\r\n        pool.transfer(msg.sender, pool.balanceOf(address(this)));\r\n    }\r\n\r\n    function joinswapExternAmountIn(\r\n        address poolAddress,\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        uint256 minPoolAmountOut\r\n    ) external payable nonReentrant {\r\n        IXPool pool = IXPool(poolAddress);\r\n\r\n        bool hasEth = false;\r\n        if (transferFromAllAndApprove(tokenIn, tokenAmountIn, poolAddress)) {\r\n            hasEth = true;\r\n        }\r\n        require(msg.value == 0 || hasEth, \"ERR_INVALID_PAY\");\r\n\r\n        if (hasEth) {\r\n            uint256 poolAmountOut =\r\n                pool.joinswapExternAmountIn(\r\n                    address(weth),\r\n                    tokenAmountIn,\r\n                    minPoolAmountOut\r\n                );\r\n            pool.transfer(msg.sender, poolAmountOut);\r\n        } else {\r\n            uint256 poolAmountOut =\r\n                pool.joinswapExternAmountIn(\r\n                    tokenIn,\r\n                    tokenAmountIn,\r\n                    minPoolAmountOut\r\n                );\r\n            pool.transfer(msg.sender, poolAmountOut);\r\n        }\r\n    }\r\n\r\n    // Internal\r\n    function getBalance(address token) internal view returns (uint256) {\r\n        if (token == xconfig.ethAddress()) {\r\n            return weth.balanceOf(address(this));\r\n        }\r\n        return IERC20(token).balanceOf(address(this));\r\n    }\r\n\r\n    function transferAll(IERC20 token, uint256 amount) internal returns (bool) {\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n        if (address(token) == xconfig.ethAddress()) {\r\n            weth.withdraw(amount);\r\n            (bool xfer, ) = msg.sender.call.value(amount).gas(9100)(\"\");\r\n            require(xfer, \"ERR_ETH_FAILED\");\r\n        } else {\r\n            token.safeTransfer(msg.sender, amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transferFromAllTo(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        address to\r\n    ) internal returns (bool hasETH) {\r\n        hasETH = false;\r\n        if (address(token) == xconfig.ethAddress()) {\r\n            require(amount == msg.value, \"ERR_TOKEN_AMOUNT\");\r\n            weth.deposit.value(amount)();\r\n            weth.transfer(to, amount);\r\n            hasETH = true;\r\n        } else {\r\n            token.safeTransferFrom(msg.sender, to, amount);\r\n        }\r\n    }\r\n\r\n    function transferFromAllAndApprove(\r\n        address token,\r\n        uint256 amount,\r\n        address spender\r\n    ) internal returns (bool hasETH) {\r\n        hasETH = false;\r\n        if (token == xconfig.ethAddress()) {\r\n            require(amount == msg.value, \"ERR_TOKEN_AMOUNT\");\r\n            weth.deposit.value(amount)();\r\n            if (weth.allowance(address(this), spender) < amount) {\r\n                IERC20(address(weth)).safeApprove(spender, 0);\r\n                IERC20(address(weth)).safeApprove(spender, amount);\r\n            }\r\n            hasETH = true;\r\n        } else {\r\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\r\n            if (IERC20(token).allowance(address(this), spender) < amount) {\r\n                IERC20(token).safeApprove(spender, 0);\r\n                IERC20(token).safeApprove(spender, amount);\r\n            }\r\n        }\r\n    }\r\n}"
    }
  }
}