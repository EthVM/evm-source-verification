{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Aggregator.sol":{"content":"pragma solidity 0.4.24;\r\n\r\n/**\r\n* @dev A library for working with mutable byte buffers in Solidity.\r\n*\r\n* Byte buffers are mutable and expandable, and provide a variety of primitives\r\n* for writing to them. At any time you can fetch a bytes object containing the\r\n* current contents of the buffer. The bytes object should not be stored between\r\n* operations, as it may change due to resizing of the buffer.\r\n*/\r\nlibrary Buffer {\r\n  /**\r\n  * @dev Represents a mutable buffer. Buffers have a current value (buf) and\r\n  *      a capacity. The capacity may be longer than the current value, in\r\n  *      which case it can be extended without the need to allocate more memory.\r\n  */\r\n  struct buffer {\r\n    bytes buf;\r\n    uint capacity;\r\n  }\r\n\r\n  /**\r\n  * @dev Initializes a buffer with an initial capacity.\r\n  * @param buf The buffer to initialize.\r\n  * @param capacity The number of bytes of space to allocate the buffer.\r\n  * @return The buffer, for chaining.\r\n  */\r\n  function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\r\n    if (capacity % 32 != 0) {\r\n      capacity += 32 - (capacity % 32);\r\n    }\r\n    // Allocate space for the buffer data\r\n    buf.capacity = capacity;\r\n    assembly {let ptr := mload(0x40)\r\n      mstore(buf, ptr)\r\n      mstore(ptr, 0)\r\n      mstore(0x40, add(32, add(ptr, capacity)))\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Initializes a new buffer from an existing bytes object.\r\n  *      Changes to the buffer may mutate the original value.\r\n  * @param b The bytes object to initialize the buffer with.\r\n  * @return A new buffer.\r\n  */\r\n  function fromBytes(bytes memory b) internal pure returns(buffer memory) {\r\n    buffer memory buf;\r\n    buf.buf = b;\r\n    buf.capacity = b.length;\r\n    return buf;\r\n  }\r\n\r\n  function resize(buffer memory buf, uint capacity) private pure {\r\n    bytes memory oldbuf = buf.buf;\r\n    init(buf, capacity);\r\n    append(buf, oldbuf);\r\n  }\r\n\r\n  function max(uint a, uint b) private pure returns(uint) {\r\n    if (a > b) {\r\n      return a;\r\n    }\r\n    return b;\r\n  }\r\n\r\n  /**\r\n  * @dev Sets buffer length to 0.\r\n  * @param buf The buffer to truncate.\r\n  * @return The original buffer, for chaining..\r\n  */\r\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\r\n    assembly {\r\n      let bufptr := mload(buf)\r\n      mstore(bufptr, 0)\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The start offset to write to.\r\n  * @param data The data to append.\r\n  * @param len The number of bytes to copy.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\r\n    require(len <= data.length);\r\n\r\n    if (off + len > buf.capacity) {\r\n      resize(buf, max(buf.capacity, len + off) * 2);\r\n    }\r\n\r\n    uint dest;\r\n    uint src;\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Length of existing buffer data\r\n      let buflen := mload(bufptr)\r\n      // Start address = buffer address + offset + sizeof(buffer length)\r\n      dest := add(add(bufptr, 32), off)\r\n      // Update buffer length if we're extending it\r\n      if gt(add(len, off), buflen) {\r\n        mstore(bufptr, add(len, off))\r\n      }\r\n      src := add(data, 32)\r\n    }\r\n\r\n    // Copy word-length chunks while possible\r\n    for (; len >= 32; len -= 32) {\r\n      assembly {\r\n        mstore(dest, mload(src))\r\n      }\r\n      dest += 32;\r\n      src += 32;\r\n    }\r\n\r\n    // Copy remaining bytes\r\n    uint mask = 256 ** (32 - len) - 1;\r\n    assembly {\r\n      let srcpart := and(mload(src), not(mask))\r\n      let destpart := and(mload(dest), mask)\r\n      mstore(dest, or(destpart, srcpart))\r\n    }\r\n\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @param len The number of bytes to copy.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, data, len);\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, data, data.length);\r\n  }\r\n\r\n  /**\r\n  * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\r\n  *      capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The offset to write the byte at.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\r\n    if (off >= buf.capacity) {\r\n      resize(buf, buf.capacity * 2);\r\n    }\r\n\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Length of existing buffer data\r\n      let buflen := mload(bufptr)\r\n      // Address = buffer address + sizeof(buffer length) + off\r\n      let dest := add(add(bufptr, off), 32)\r\n      mstore8(dest, data)\r\n      // Update buffer length if we extended it\r\n      if eq(off, buflen) {\r\n        mstore(bufptr, add(buflen, 1))\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\r\n  *      capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\r\n    return writeUint8(buf, buf.buf.length, data);\r\n  }\r\n\r\n  /**\r\n  * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\r\n  *      exceed the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The offset to write at.\r\n  * @param data The data to append.\r\n  * @param len The number of bytes to write (left-aligned).\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\r\n    if (len + off > buf.capacity) {\r\n      resize(buf, (len + off) * 2);\r\n    }\r\n\r\n    uint mask = 256 ** len - 1;\r\n    // Right-align data\r\n    data = data >> (8 * (32 - len));\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Address = buffer address + sizeof(buffer length) + off + len\r\n      let dest := add(add(bufptr, off), len)\r\n      mstore(dest, or(and(mload(dest), not(mask)), data))\r\n      // Update buffer length if we extended it\r\n      if gt(add(off, len), mload(bufptr)) {\r\n        mstore(bufptr, add(off, len))\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\r\n  *      capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The offset to write at.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\r\n    return write(buf, off, bytes32(data), 20);\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chhaining.\r\n  */\r\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, bytes32(data), 20);\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, data, 32);\r\n  }\r\n\r\n  /**\r\n  * @dev Writes an integer to the buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The offset to write at.\r\n  * @param data The data to append.\r\n  * @param len The number of bytes to write (right-aligned).\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\r\n    if (len + off > buf.capacity) {\r\n      resize(buf, (len + off) * 2);\r\n    }\r\n\r\n    uint mask = 256 ** len - 1;\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Address = buffer address + off + sizeof(buffer length) + len\r\n      let dest := add(add(bufptr, off), len)\r\n      mstore(dest, or(and(mload(dest), not(mask)), data))\r\n      // Update buffer length if we extended it\r\n      if gt(add(off, len), mload(bufptr)) {\r\n        mstore(bufptr, add(off, len))\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n   * exceed the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param data The data to append.\r\n   * @return The original buffer.\r\n   */\r\n  function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\r\n    return writeInt(buf, buf.buf.length, data, len);\r\n  }\r\n}\r\n\r\nlibrary CBOR {\r\n  using Buffer for Buffer.buffer;\r\n\r\n  uint8 private constant MAJOR_TYPE_INT = 0;\r\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\r\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\r\n  uint8 private constant MAJOR_TYPE_STRING = 3;\r\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\r\n  uint8 private constant MAJOR_TYPE_MAP = 5;\r\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\r\n\r\n  function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\r\n    if(value <= 23) {\r\n      buf.appendUint8(uint8((major << 5) | value));\r\n    } else if(value <= 0xFF) {\r\n      buf.appendUint8(uint8((major << 5) | 24));\r\n      buf.appendInt(value, 1);\r\n    } else if(value <= 0xFFFF) {\r\n      buf.appendUint8(uint8((major << 5) | 25));\r\n      buf.appendInt(value, 2);\r\n    } else if(value <= 0xFFFFFFFF) {\r\n      buf.appendUint8(uint8((major << 5) | 26));\r\n      buf.appendInt(value, 4);\r\n    } else if(value <= 0xFFFFFFFFFFFFFFFF) {\r\n      buf.appendUint8(uint8((major << 5) | 27));\r\n      buf.appendInt(value, 8);\r\n    }\r\n  }\r\n\r\n  function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\r\n    buf.appendUint8(uint8((major << 5) | 31));\r\n  }\r\n\r\n  function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\r\n    encodeType(buf, MAJOR_TYPE_INT, value);\r\n  }\r\n\r\n  function encodeInt(Buffer.buffer memory buf, int value) internal pure {\r\n    if(value >= 0) {\r\n      encodeType(buf, MAJOR_TYPE_INT, uint(value));\r\n    } else {\r\n      encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\r\n    }\r\n  }\r\n\r\n  function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\r\n    encodeType(buf, MAJOR_TYPE_BYTES, value.length);\r\n    buf.append(value);\r\n  }\r\n\r\n  function encodeString(Buffer.buffer memory buf, string value) internal pure {\r\n    encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\r\n    buf.append(bytes(value));\r\n  }\r\n\r\n  function startArray(Buffer.buffer memory buf) internal pure {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\r\n  }\r\n\r\n  function startMap(Buffer.buffer memory buf) internal pure {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\r\n  }\r\n\r\n  function endSequence(Buffer.buffer memory buf) internal pure {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Library for common Chainlink functions\r\n * @dev Uses imported CBOR library for encoding to buffer\r\n */\r\nlibrary Chainlink {\r\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\r\n\r\n  using CBOR for Buffer.buffer;\r\n\r\n  struct Request {\r\n    bytes32 id;\r\n    address callbackAddress;\r\n    bytes4 callbackFunctionId;\r\n    uint256 nonce;\r\n    Buffer.buffer buf;\r\n  }\r\n\r\n  /**\r\n   * @notice Initializes a Chainlink request\r\n   * @dev Sets the ID, callback address, and callback function signature on the request\r\n   * @param self The uninitialized request\r\n   * @param _id The Job Specification ID\r\n   * @param _callbackAddress The callback address\r\n   * @param _callbackFunction The callback function signature\r\n   * @return The initialized request\r\n   */\r\n  function initialize(\r\n    Request memory self,\r\n    bytes32 _id,\r\n    address _callbackAddress,\r\n    bytes4 _callbackFunction\r\n  ) internal pure returns (Chainlink.Request memory) {\r\n    Buffer.init(self.buf, defaultBufferSize);\r\n    self.id = _id;\r\n    self.callbackAddress = _callbackAddress;\r\n    self.callbackFunctionId = _callbackFunction;\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\r\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\r\n   * @param self The initialized request\r\n   * @param _data The CBOR data\r\n   */\r\n  function setBuffer(Request memory self, bytes _data)\r\n    internal pure\r\n  {\r\n    Buffer.init(self.buf, _data.length);\r\n    Buffer.append(self.buf, _data);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a string value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _value The string value to add\r\n   */\r\n  function add(Request memory self, string _key, string _value)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.encodeString(_value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a bytes value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _value The bytes value to add\r\n   */\r\n  function addBytes(Request memory self, string _key, bytes _value)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.encodeBytes(_value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a int256 value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _value The int256 value to add\r\n   */\r\n  function addInt(Request memory self, string _key, int256 _value)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.encodeInt(_value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a uint256 value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _value The uint256 value to add\r\n   */\r\n  function addUint(Request memory self, string _key, uint256 _value)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.encodeUInt(_value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds an array of strings to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param _key The name of the key\r\n   * @param _values The array of string values to add\r\n   */\r\n  function addStringArray(Request memory self, string _key, string[] memory _values)\r\n    internal pure\r\n  {\r\n    self.buf.encodeString(_key);\r\n    self.buf.startArray();\r\n    for (uint256 i = 0; i < _values.length; i++) {\r\n      self.buf.encodeString(_values[i]);\r\n    }\r\n    self.buf.endSequence();\r\n  }\r\n}\r\n\r\ninterface ENSInterface {\r\n\r\n  // Logged when the owner of a node assigns a new owner to a subnode.\r\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n  // Logged when the owner of a node transfers ownership to a new account.\r\n  event Transfer(bytes32 indexed node, address owner);\r\n\r\n  // Logged when the resolver for a node changes.\r\n  event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n  // Logged when the TTL of a node changes\r\n  event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n  function setResolver(bytes32 node, address resolver) external;\r\n  function setOwner(bytes32 node, address owner) external;\r\n  function setTTL(bytes32 node, uint64 ttl) external;\r\n  function owner(bytes32 node) external view returns (address);\r\n  function resolver(bytes32 node) external view returns (address);\r\n  function ttl(bytes32 node) external view returns (uint64);\r\n\r\n}\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external returns (uint256 remaining);\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n  function balanceOf(address owner) external returns (uint256 balance);\r\n  function decimals() external returns (uint8 decimalPlaces);\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n  function name() external returns (string tokenName);\r\n  function symbol() external returns (string tokenSymbol);\r\n  function totalSupply() external returns (uint256 totalTokensIssued);\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n  function transferAndCall(address to, uint256 value, bytes data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n}\r\n\r\ninterface ChainlinkRequestInterface {\r\n  function oracleRequest(\r\n    address sender,\r\n    uint256 payment,\r\n    bytes32 id,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 version,\r\n    bytes data\r\n  ) external;\r\n\r\n  function cancelOracleRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration\r\n  ) external;\r\n}\r\n\r\ninterface PointerInterface {\r\n  function getAddress() external view returns (address);\r\n}\r\n\r\n\r\ncontract ENSResolver {\r\n  function addr(bytes32 node) public view returns (address);\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title The ChainlinkClient contract\r\n * @notice Contract writers can inherit this contract in order to create requests for the\r\n * Chainlink network\r\n */\r\ncontract ChainlinkClient {\r\n  using Chainlink for Chainlink.Request;\r\n  using SafeMath for uint256;\r\n\r\n  uint256 constant internal LINK = 10**18;\r\n  uint256 constant private AMOUNT_OVERRIDE = 0;\r\n  address constant private SENDER_OVERRIDE = 0x0;\r\n  uint256 constant private ARGS_VERSION = 1;\r\n  bytes32 constant private ENS_TOKEN_SUBNAME = keccak256(\"link\");\r\n  bytes32 constant private ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\r\n  address constant private LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\r\n\r\n  ENSInterface private ens;\r\n  bytes32 private ensNode;\r\n  LinkTokenInterface private link;\r\n  ChainlinkRequestInterface private oracle;\r\n  uint256 private requests = 1;\r\n  mapping(bytes32 => address) private pendingRequests;\r\n\r\n  event ChainlinkRequested(bytes32 indexed id);\r\n  event ChainlinkFulfilled(bytes32 indexed id);\r\n  event ChainlinkCancelled(bytes32 indexed id);\r\n\r\n  /**\r\n   * @notice Creates a request that can hold additional parameters\r\n   * @param _specId The Job Specification ID that the request will be created for\r\n   * @param _callbackAddress The callback address that the response will be sent to\r\n   * @param _callbackFunctionSignature The callback function signature to use for the callback address\r\n   * @return A Chainlink Request struct in memory\r\n   */\r\n  function buildChainlinkRequest(\r\n    bytes32 _specId,\r\n    address _callbackAddress,\r\n    bytes4 _callbackFunctionSignature\r\n  ) internal pure returns (Chainlink.Request memory) {\r\n    Chainlink.Request memory req;\r\n    return req.initialize(_specId, _callbackAddress, _callbackFunctionSignature);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the stored oracle address\r\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\r\n   * @param _req The initialized Chainlink Request\r\n   * @param _payment The amount of LINK to send for the request\r\n   * @return The request ID\r\n   */\r\n  function sendChainlinkRequest(Chainlink.Request memory _req, uint256 _payment)\r\n    internal\r\n    returns (bytes32)\r\n  {\r\n    return sendChainlinkRequestTo(oracle, _req, _payment);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the specified oracle address\r\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\r\n   * send LINK which creates a request on the target oracle contract.\r\n   * Emits ChainlinkRequested event.\r\n   * @param _oracle The address of the oracle for the request\r\n   * @param _req The initialized Chainlink Request\r\n   * @param _payment The amount of LINK to send for the request\r\n   * @return The request ID\r\n   */\r\n  function sendChainlinkRequestTo(address _oracle, Chainlink.Request memory _req, uint256 _payment)\r\n    internal\r\n    returns (bytes32 requestId)\r\n  {\r\n    requestId = keccak256(abi.encodePacked(this, requests));\r\n    _req.nonce = requests;\r\n    pendingRequests[requestId] = _oracle;\r\n    emit ChainlinkRequested(requestId);\r\n    require(link.transferAndCall(_oracle, _payment, encodeRequest(_req)), \"unable to transferAndCall to oracle\");\r\n    requests += 1;\r\n\r\n    return requestId;\r\n  }\r\n\r\n  /**\r\n   * @notice Allows a request to be cancelled if it has not been fulfilled\r\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\r\n   * Deletes the request from the `pendingRequests` mapping.\r\n   * Emits ChainlinkCancelled event.\r\n   * @param _requestId The request ID\r\n   * @param _payment The amount of LINK sent for the request\r\n   * @param _callbackFunc The callback function specified for the request\r\n   * @param _expiration The time of the expiration for the request\r\n   */\r\n  function cancelChainlinkRequest(\r\n    bytes32 _requestId,\r\n    uint256 _payment,\r\n    bytes4 _callbackFunc,\r\n    uint256 _expiration\r\n  )\r\n    internal\r\n  {\r\n    ChainlinkRequestInterface requested = ChainlinkRequestInterface(pendingRequests[_requestId]);\r\n    delete pendingRequests[_requestId];\r\n    emit ChainlinkCancelled(_requestId);\r\n    requested.cancelOracleRequest(_requestId, _payment, _callbackFunc, _expiration);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle address\r\n   * @param _oracle The address of the oracle contract\r\n   */\r\n  function setChainlinkOracle(address _oracle) internal {\r\n    oracle = ChainlinkRequestInterface(_oracle);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the LINK token address\r\n   * @param _link The address of the LINK token contract\r\n   */\r\n  function setChainlinkToken(address _link) internal {\r\n    link = LinkTokenInterface(_link);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the Chainlink token address for the public\r\n   * network as given by the Pointer contract\r\n   */\r\n  function setPublicChainlinkToken() internal {\r\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the stored address of the LINK token\r\n   * @return The address of the LINK token\r\n   */\r\n  function chainlinkTokenAddress()\r\n    internal\r\n    view\r\n    returns (address)\r\n  {\r\n    return address(link);\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the stored address of the oracle contract\r\n   * @return The address of the oracle contract\r\n   */\r\n  function chainlinkOracleAddress()\r\n    internal\r\n    view\r\n    returns (address)\r\n  {\r\n    return address(oracle);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows for a request which was created on another contract to be fulfilled\r\n   * on this contract\r\n   * @param _oracle The address of the oracle contract that will fulfill the request\r\n   * @param _requestId The request ID used for the response\r\n   */\r\n  function addChainlinkExternalRequest(address _oracle, bytes32 _requestId)\r\n    internal\r\n    notPendingRequest(_requestId)\r\n  {\r\n    pendingRequests[_requestId] = _oracle;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\r\n   * @dev Accounts for subnodes having different resolvers\r\n   * @param _ens The address of the ENS contract\r\n   * @param _node The ENS node hash\r\n   */\r\n  function useChainlinkWithENS(address _ens, bytes32 _node)\r\n    internal\r\n  {\r\n    ens = ENSInterface(_ens);\r\n    ensNode = _node;\r\n    bytes32 linkSubnode = keccak256(abi.encodePacked(ensNode, ENS_TOKEN_SUBNAME));\r\n    ENSResolver resolver = ENSResolver(ens.resolver(linkSubnode));\r\n    setChainlinkToken(resolver.addr(linkSubnode));\r\n    updateChainlinkOracleWithENS();\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle contract with the address resolved by ENS\r\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\r\n   */\r\n  function updateChainlinkOracleWithENS()\r\n    internal\r\n  {\r\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(ensNode, ENS_ORACLE_SUBNAME));\r\n    ENSResolver resolver = ENSResolver(ens.resolver(oracleSubnode));\r\n    setChainlinkOracle(resolver.addr(oracleSubnode));\r\n  }\r\n\r\n  /**\r\n   * @notice Encodes the request to be sent to the oracle contract\r\n   * @dev The Chainlink node expects values to be in order for the request to be picked up. Order of types\r\n   * will be validated in the oracle contract.\r\n   * @param _req The initialized Chainlink Request\r\n   * @return The bytes payload for the `transferAndCall` method\r\n   */\r\n  function encodeRequest(Chainlink.Request memory _req)\r\n    private\r\n    view\r\n    returns (bytes memory)\r\n  {\r\n    return abi.encodeWithSelector(\r\n      oracle.oracleRequest.selector,\r\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\r\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\r\n      _req.id,\r\n      _req.callbackAddress,\r\n      _req.callbackFunctionId,\r\n      _req.nonce,\r\n      ARGS_VERSION,\r\n      _req.buf.buf);\r\n  }\r\n\r\n  /**\r\n   * @notice Ensures that the fulfillment is valid for this contract\r\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\r\n   * @param _requestId The request ID for fulfillment\r\n   */\r\n  function validateChainlinkCallback(bytes32 _requestId)\r\n    internal\r\n    recordChainlinkFulfillment(_requestId)\r\n    // solhint-disable-next-line no-empty-blocks\r\n  {}\r\n\r\n  /**\r\n   * @dev Reverts if the sender is not the oracle of the request.\r\n   * Emits ChainlinkFulfilled event.\r\n   * @param _requestId The request ID for fulfillment\r\n   */\r\n  modifier recordChainlinkFulfillment(bytes32 _requestId) {\r\n    require(msg.sender == pendingRequests[_requestId], \"Source must be the oracle of the request\");\r\n    delete pendingRequests[_requestId];\r\n    emit ChainlinkFulfilled(_requestId);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if the request is already pending\r\n   * @param _requestId The request ID for fulfillment\r\n   */\r\n  modifier notPendingRequest(bytes32 _requestId) {\r\n    require(pendingRequests[_requestId] == address(0), \"Request is already pending\");\r\n    _;\r\n  }\r\n}\r\n\r\ninterface AggregatorInterface {\r\n  function latestAnswer() external view returns (int256);\r\n  function latestTimestamp() external view returns (uint256);\r\n  function latestRound() external view returns (uint256);\r\n  function getAnswer(uint256 roundId) external view returns (int256);\r\n  function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\r\n  event NewRound(uint256 indexed roundId, address indexed startedBy);\r\n}\r\n\r\nlibrary SignedSafeMath {\r\n\r\n  /**\r\n   * @dev Adds two int256s and makes sure the result doesn't overflow. Signed\r\n   * integers aren't supported by the SafeMath library, thus this method\r\n   * @param _a The first number to be added\r\n   * @param _a The second number to be added\r\n   */\r\n  function add(int256 _a, int256 _b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n  {\r\n    int256 c = _a + _b;\r\n    require((_b >= 0 && c >= _a) || (_b < 0 && c < _a), \"SignedSafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title An example Chainlink contract with aggregation\r\n * @notice Requesters can use this contract as a framework for creating\r\n * requests to multiple Chainlink nodes and running aggregation\r\n * as the contract receives answers.\r\n */\r\ncontract Aggregator is AggregatorInterface, ChainlinkClient, Ownable {\r\n  using SignedSafeMath for int256;\r\n\r\n  struct Answer {\r\n    uint128 minimumResponses;\r\n    uint128 maxResponses;\r\n    int256[] responses;\r\n  }\r\n\r\n  event ResponseReceived(int256 indexed response, uint256 indexed answerId, address indexed sender);\r\n\r\n  int256 private currentAnswerValue;\r\n  uint256 private updatedTimestampValue;\r\n  uint256 private latestCompletedAnswer;\r\n  uint128 public paymentAmount;\r\n  uint128 public minimumResponses;\r\n  bytes32[] public jobIds;\r\n  address[] public oracles;\r\n\r\n  uint256 private answerCounter = 1;\r\n  mapping(address => bool) public authorizedRequesters;\r\n  mapping(bytes32 => uint256) private requestAnswers;\r\n  mapping(uint256 => Answer) private answers;\r\n  mapping(uint256 => int256) private currentAnswers;\r\n  mapping(uint256 => uint256) private updatedTimestamps;\r\n\r\n  uint256 constant private MAX_ORACLE_COUNT = 45;\r\n\r\n  /**\r\n   * @notice Deploy with the address of the LINK token and arrays of matching\r\n   * length containing the addresses of the oracles and their corresponding\r\n   * Job IDs.\r\n   * @dev Sets the LinkToken address for the network, addresses of the oracles,\r\n   * and jobIds in storage.\r\n   * @param _link The address of the LINK token\r\n   * @param _paymentAmount the amount of LINK to be sent to each oracle for each request\r\n   * @param _minimumResponses the minimum number of responses\r\n   * before an answer will be calculated\r\n   * @param _oracles An array of oracle addresses\r\n   * @param _jobIds An array of Job IDs\r\n   */\r\n  constructor(\r\n    address _link,\r\n    uint128 _paymentAmount,\r\n    uint128 _minimumResponses,\r\n    address[] _oracles,\r\n    bytes32[] _jobIds\r\n  ) public Ownable() {\r\n    setChainlinkToken(_link);\r\n    updateRequestDetails(_paymentAmount, _minimumResponses, _oracles, _jobIds);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request for each oracle in the oracles array.\r\n   * @dev This example does not include request parameters. Reference any documentation\r\n   * associated with the Job IDs used to determine the required parameters per-request.\r\n   */\r\n  function requestRateUpdate()\r\n    external\r\n    ensureAuthorizedRequester()\r\n  {\r\n    Chainlink.Request memory request;\r\n    bytes32 requestId;\r\n    uint256 oraclePayment = paymentAmount;\r\n\r\n    for (uint i = 0; i < oracles.length; i++) {\r\n      request = buildChainlinkRequest(jobIds[i], this, this.chainlinkCallback.selector);\r\n      requestId = sendChainlinkRequestTo(oracles[i], request, oraclePayment);\r\n      requestAnswers[requestId] = answerCounter;\r\n    }\r\n    answers[answerCounter].minimumResponses = minimumResponses;\r\n    answers[answerCounter].maxResponses = uint128(oracles.length);\r\n    answerCounter = answerCounter.add(1);\r\n\r\n    emit NewRound(answerCounter, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Receives the answer from the Chainlink node.\r\n   * @dev This function can only be called by the oracle that received the request.\r\n   * @param _clRequestId The Chainlink request ID associated with the answer\r\n   * @param _response The answer provided by the Chainlink node\r\n   */\r\n  function chainlinkCallback(bytes32 _clRequestId, int256 _response)\r\n    external\r\n  {\r\n    validateChainlinkCallback(_clRequestId);\r\n\r\n    uint256 answerId = requestAnswers[_clRequestId];\r\n    delete requestAnswers[_clRequestId];\r\n\r\n    answers[answerId].responses.push(_response);\r\n    emit ResponseReceived(_response, answerId, msg.sender);\r\n    updateLatestAnswer(answerId);\r\n    deleteAnswer(answerId);\r\n  }\r\n\r\n  /**\r\n   * @notice Updates the arrays of oracles and jobIds with new values,\r\n   * overwriting the old values.\r\n   * @dev Arrays are validated to be equal length.\r\n   * @param _paymentAmount the amount of LINK to be sent to each oracle for each request\r\n   * @param _minimumResponses the minimum number of responses\r\n   * before an answer will be calculated\r\n   * @param _oracles An array of oracle addresses\r\n   * @param _jobIds An array of Job IDs\r\n   */\r\n  function updateRequestDetails(\r\n    uint128 _paymentAmount,\r\n    uint128 _minimumResponses,\r\n    address[] _oracles,\r\n    bytes32[] _jobIds\r\n  )\r\n    public\r\n    onlyOwner()\r\n    validateAnswerRequirements(_minimumResponses, _oracles, _jobIds)\r\n  {\r\n    paymentAmount = _paymentAmount;\r\n    minimumResponses = _minimumResponses;\r\n    jobIds = _jobIds;\r\n    oracles = _oracles;\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the owner of the contract to withdraw any LINK balance\r\n   * available on the contract.\r\n   * @dev The contract will need to have a LINK balance in order to create requests.\r\n   * @param _recipient The address to receive the LINK tokens\r\n   * @param _amount The amount of LINK to send from the contract\r\n   */\r\n  function transferLINK(address _recipient, uint256 _amount)\r\n    public\r\n    onlyOwner()\r\n  {\r\n    LinkTokenInterface linkToken = LinkTokenInterface(chainlinkTokenAddress());\r\n    require(linkToken.transfer(_recipient, _amount), \"LINK transfer failed\");\r\n  }\r\n\r\n  /**\r\n   * @notice Called by the owner to permission other addresses to generate new\r\n   * requests to oracles.\r\n   * @param _requester the address whose permissions are being set\r\n   * @param _allowed boolean that determines whether the requester is\r\n   * permissioned or not\r\n   */\r\n  function setAuthorization(address _requester, bool _allowed)\r\n    external\r\n    onlyOwner()\r\n  {\r\n    authorizedRequesters[_requester] = _allowed;\r\n  }\r\n\r\n  /**\r\n   * @notice Cancels an outstanding Chainlink request.\r\n   * The oracle contract requires the request ID and additional metadata to\r\n   * validate the cancellation. Only old answers can be cancelled.\r\n   * @param _requestId is the identifier for the chainlink request being cancelled\r\n   * @param _payment is the amount of LINK paid to the oracle for the request\r\n   * @param _expiration is the time when the request expires\r\n   */\r\n  function cancelRequest(\r\n    bytes32 _requestId,\r\n    uint256 _payment,\r\n    uint256 _expiration\r\n  )\r\n    external\r\n    ensureAuthorizedRequester()\r\n  {\r\n    uint256 answerId = requestAnswers[_requestId];\r\n    require(answerId < latestCompletedAnswer, \"Cannot modify an in-progress answer\");\r\n\r\n    delete requestAnswers[_requestId];\r\n    answers[answerId].responses.push(0);\r\n    deleteAnswer(answerId);\r\n\r\n    cancelChainlinkRequest(\r\n      _requestId,\r\n      _payment,\r\n      this.chainlinkCallback.selector,\r\n      _expiration\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Called by the owner to kill the contract. This transfers all LINK\r\n   * balance and ETH balance (if there is any) to the owner.\r\n   */\r\n  function destroy()\r\n    external\r\n    onlyOwner()\r\n  {\r\n    LinkTokenInterface linkToken = LinkTokenInterface(chainlinkTokenAddress());\r\n    transferLINK(owner, linkToken.balanceOf(address(this)));\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Performs aggregation of the answers received from the Chainlink nodes.\r\n   * Assumes that at least half the oracles are honest and so can't contol the\r\n   * middle of the ordered responses.\r\n   * @param _answerId The answer ID associated with the group of requests\r\n   */\r\n  function updateLatestAnswer(uint256 _answerId)\r\n    private\r\n    ensureMinResponsesReceived(_answerId)\r\n    ensureOnlyLatestAnswer(_answerId)\r\n  {\r\n    uint256 responseLength = answers[_answerId].responses.length;\r\n    uint256 middleIndex = responseLength.div(2);\r\n    int256 currentAnswerTemp;\r\n    if (responseLength % 2 == 0) {\r\n      int256 median1 = quickselect(answers[_answerId].responses, middleIndex);\r\n      int256 median2 = quickselect(answers[_answerId].responses, middleIndex.add(1)); // quickselect is 1 indexed\r\n      currentAnswerTemp = median1.add(median2) / 2; // signed integers are not supported by SafeMath\r\n    } else {\r\n      currentAnswerTemp = quickselect(answers[_answerId].responses, middleIndex.add(1)); // quickselect is 1 indexed\r\n    }\r\n    currentAnswerValue = currentAnswerTemp;\r\n    latestCompletedAnswer = _answerId;\r\n    updatedTimestampValue = now;\r\n    updatedTimestamps[_answerId] = now;\r\n    currentAnswers[_answerId] = currentAnswerTemp;\r\n    emit AnswerUpdated(currentAnswerTemp, _answerId, now);\r\n  }\r\n\r\n  /**\r\n   * @notice get the most recently reported answer\r\n   */\r\n  function latestAnswer()\r\n    external\r\n    view\r\n    returns (int256)\r\n  {\r\n    return currentAnswers[latestCompletedAnswer];\r\n  }\r\n\r\n  /**\r\n   * @notice get the last updated at block timestamp\r\n   */\r\n  function latestTimestamp()\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return updatedTimestamps[latestCompletedAnswer];\r\n  }\r\n\r\n  /**\r\n   * @notice get past rounds answers\r\n   * @param _roundId the answer number to retrieve the answer for\r\n   */\r\n  function getAnswer(uint256 _roundId)\r\n    external\r\n    view\r\n    returns (int256)\r\n  {\r\n    return currentAnswers[_roundId];\r\n  }\r\n\r\n  /**\r\n   * @notice get block timestamp when an answer was last updated\r\n   * @param _roundId the answer number to retrieve the updated timestamp for\r\n   */\r\n  function getTimestamp(uint256 _roundId)\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return updatedTimestamps[_roundId];\r\n  }\r\n\r\n  /**\r\n   * @notice get the latest completed round where the answer was updated\r\n   */\r\n  function latestRound() external view returns (uint256) {\r\n    return latestCompletedAnswer;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the kth value of the ordered array\r\n   * See: http://www.cs.yale.edu/homes/aspnes/pinewiki/QuickSelect.html\r\n   * @param _a The list of elements to pull from\r\n   * @param _k The index, 1 based, of the elements you want to pull from when ordered\r\n   */\r\n  function quickselect(int256[] memory _a, uint256 _k)\r\n    private\r\n    pure\r\n    returns (int256)\r\n  {\r\n    int256[] memory a = _a;\r\n    uint256 k = _k;\r\n    uint256 aLen = a.length;\r\n    int256[] memory a1 = new int256[](aLen);\r\n    int256[] memory a2 = new int256[](aLen);\r\n    uint256 a1Len;\r\n    uint256 a2Len;\r\n    int256 pivot;\r\n    uint256 i;\r\n\r\n    while (true) {\r\n      pivot = a[aLen.div(2)];\r\n      a1Len = 0;\r\n      a2Len = 0;\r\n      for (i = 0; i < aLen; i++) {\r\n        if (a[i] < pivot) {\r\n          a1[a1Len] = a[i];\r\n          a1Len++;\r\n        } else if (a[i] > pivot) {\r\n          a2[a2Len] = a[i];\r\n          a2Len++;\r\n        }\r\n      }\r\n      if (k <= a1Len) {\r\n        aLen = a1Len;\r\n        (a, a1) = swap(a, a1);\r\n      } else if (k > (aLen.sub(a2Len))) {\r\n        k = k.sub(aLen.sub(a2Len));\r\n        aLen = a2Len;\r\n        (a, a2) = swap(a, a2);\r\n      } else {\r\n        return pivot;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Swaps the pointers to two uint256 arrays in memory\r\n   * @param _a The pointer to the first in memory array\r\n   * @param _b The pointer to the second in memory array\r\n   */\r\n  function swap(int256[] memory _a, int256[] memory _b)\r\n    private\r\n    pure\r\n    returns(int256[] memory, int256[] memory)\r\n  {\r\n    return (_b, _a);\r\n  }\r\n\r\n  /**\r\n   * @dev Cleans up the answer record if all responses have been received.\r\n   * @param _answerId The identifier of the answer to be deleted\r\n   */\r\n  function deleteAnswer(uint256 _answerId)\r\n    private\r\n    ensureAllResponsesReceived(_answerId)\r\n  {\r\n    delete answers[_answerId];\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents taking an action if the minimum number of responses has not\r\n   * been received for an answer.\r\n   * @param _answerId The the identifier of the answer that keeps track of the responses.\r\n   */\r\n  modifier ensureMinResponsesReceived(uint256 _answerId) {\r\n    if (answers[_answerId].responses.length >= answers[_answerId].minimumResponses) {\r\n      _;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents taking an action if not all responses are received for an answer.\r\n   * @param _answerId The the identifier of the answer that keeps track of the responses.\r\n   */\r\n  modifier ensureAllResponsesReceived(uint256 _answerId) {\r\n    if (answers[_answerId].responses.length == answers[_answerId].maxResponses) {\r\n      _;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents taking an action if a newer answer has been recorded.\r\n   * @param _answerId The current answer's identifier.\r\n   * Answer IDs are in ascending order.\r\n   */\r\n  modifier ensureOnlyLatestAnswer(uint256 _answerId) {\r\n    if (latestCompletedAnswer <= _answerId) {\r\n      _;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Ensures corresponding number of oracles and jobs.\r\n   * @param _oracles The list of oracles.\r\n   * @param _jobIds The list of jobs.\r\n   */\r\n  modifier validateAnswerRequirements(\r\n    uint256 _minimumResponses,\r\n    address[] _oracles,\r\n    bytes32[] _jobIds\r\n  ) {\r\n    require(_oracles.length <= MAX_ORACLE_COUNT, \"cannot have more than 45 oracles\");\r\n    require(_oracles.length >= _minimumResponses, \"must have at least as many oracles as responses\");\r\n    require(_oracles.length == _jobIds.length, \"must have exactly as many oracles as job IDs\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if `msg.sender` is not authorized to make requests.\r\n   */\r\n  modifier ensureAuthorizedRequester() {\r\n    require(authorizedRequesters[msg.sender] || msg.sender == owner, \"Not an authorized address for creating requests\");\r\n    _;\r\n  }\r\n\r\n}"}}}