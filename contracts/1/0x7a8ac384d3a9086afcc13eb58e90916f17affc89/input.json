{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":999999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CompositeVaultMaster.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract CompositeVaultMaster {\r\n    address public governance;\r\n\r\n    address public valueToken = address(0x49E833337ECe7aFE375e44F4E3e8481029218E5c);\r\n\r\n    address public govVault = address(0xceC03a960Ea678A2B6EA350fe0DbD1807B22D875); // 14.0% profit from Value Vaults\r\n    address public insuranceFund = 0xb7b2Ea8A1198368f950834875047aA7294A2bDAa; // set to Governance Multisig at start\r\n    address public performanceReward = 0x7Be4D5A99c903C437EC77A20CB6d0688cBB73c7f; // set to deploy wallet at start\r\n\r\n    uint256 public govVaultProfitShareFee = 1400; // 14.0% | VIP-7 (https://yfv.finance/vip-vote/vip_7)\r\n    uint256 public gasFee = 50; // 0.5% at start and can be set by governance decision\r\n    uint256 public insuranceFee = 0; // 6% | VIP-10 (to compensate who lost during the exploit on Nov 14 2020)\r\n    uint256 public withdrawalProtectionFee = 0; // % of withdrawal go back to vault (for auto-compounding) to protect withdrawals\r\n\r\n    mapping(address => address) public bank;\r\n    mapping(address => bool) public isVault;\r\n    mapping(address => bool) public isController;\r\n    mapping(address => bool) public isStrategy;\r\n\r\n    mapping(address => uint) public slippage; // over 10000\r\n\r\n    constructor(address _valueToken) public {\r\n        if (_valueToken != address(0)) valueToken = _valueToken;\r\n        governance = msg.sender;\r\n    }\r\n\r\n    function setGovernance(address _governance) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        governance = _governance;\r\n    }\r\n\r\n    function setBank(address _vault, address _bank) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        bank[_vault] = _bank;\r\n    }\r\n\r\n    function addVault(address _vault) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        isVault[_vault] = true;\r\n    }\r\n\r\n    function removeVault(address _vault) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        isVault[_vault] = false;\r\n    }\r\n\r\n    function addController(address _controller) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        isController[_controller] = true;\r\n    }\r\n\r\n    function removeController(address _controller) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        isController[_controller] = true;\r\n    }\r\n\r\n    function addStrategy(address _strategy) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        isStrategy[_strategy] = true;\r\n    }\r\n\r\n    function removeStrategy(address _strategy) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        isStrategy[_strategy] = false;\r\n    }\r\n\r\n    function setGovVault(address _govVault) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        govVault = _govVault;\r\n    }\r\n\r\n    function setInsuranceFund(address _insuranceFund) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        insuranceFund = _insuranceFund;\r\n    }\r\n\r\n    function setPerformanceReward(address _performanceReward) public{\r\n        require(msg.sender == governance, \"!governance\");\r\n        performanceReward = _performanceReward;\r\n    }\r\n\r\n    function setGovVaultProfitShareFee(uint256 _govVaultProfitShareFee) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        require(_govVaultProfitShareFee <= 3000, \"_govVaultProfitShareFee over 30%\");\r\n        govVaultProfitShareFee = _govVaultProfitShareFee;\r\n    }\r\n\r\n    function setGasFee(uint256 _gasFee) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        require(_gasFee <= 500, \"_gasFee over 5%\");\r\n        gasFee = _gasFee;\r\n    }\r\n\r\n    function setInsuranceFee(uint256 _insuranceFee) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        require(_insuranceFee <= 2000, \"_insuranceFee over 20%\");\r\n        insuranceFee = _insuranceFee;\r\n    }\r\n\r\n    function setWithdrawalProtectionFee(uint256 _withdrawalProtectionFee) public {\r\n        require(msg.sender == governance, \"!governance\");\r\n        require(_withdrawalProtectionFee <= 100, \"_withdrawalProtectionFee over 1%\");\r\n        withdrawalProtectionFee = _withdrawalProtectionFee;\r\n    }\r\n\r\n    function setSlippage(address _token, uint _slippage) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        require(_slippage <= 1000, \">10%\");\r\n        slippage[_token] = _slippage;\r\n    }\r\n\r\n    function convertSlippage(address _input, address _output) view external returns (uint) {\r\n        uint _is = slippage[_input];\r\n        uint _os = slippage[_output];\r\n        return (_is > _os) ? _is : _os;\r\n    }\r\n\r\n    /**\r\n     * This function allows governance to take unsupported tokens out of the contract. This is in an effort to make someone whole, should they seriously mess up.\r\n     * There is no guarantee governance will vote to return these. It also allows for removal of airdropped tokens.\r\n     */\r\n    function governanceRecoverUnsupported(IERC20 _token, uint256 amount, address to) external {\r\n        require(msg.sender == governance, \"!governance\");\r\n        _token.transfer(to, amount);\r\n    }\r\n}"}}}