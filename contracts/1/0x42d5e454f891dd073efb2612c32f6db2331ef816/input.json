{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/CycleNFTX.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\n/**\n\nCycle through NFTX pools until you find the ID you want\n\nSee https://github.com/NFTX-project/x-contracts-private/blob/4650f3cae4c2d776ca45effba65513c9e6ec4b6b/contracts/NFTX.sol\n\n*/\n\npragma solidity ^0.8.0;\n\n\ninterface NFTXv7 {\n    function requestMint(uint256 vaultId, uint256[] memory nftIds) external payable;\n\n    // Burns a Meebit, gives you MEEBIT; see https://etherscan.io/tx/0x8d443e00c0a7b702b105cb1fbc4cafbd424a5cee756965007877a164203ee359\n    function mint(uint256 vaultId, uint256[] memory nftIds, uint256 d2Amount) external payable;\n\n    // Burns PUNK-BASIC, gives you a WPUNK; see https://etherscan.io/tx/0x7b30eabbcdad9a6827029ba6ffb8196fa1921f9960214b3ccc463b764b4a72ea\n    function redeem(uint256 vaultId, uint256 amount) external;\n\n\n}\n\ninterface xStore {\n    function xTokenAddress(uint256 vaultId) external view returns (address);\n    function nftAddress(uint256 vaultId) external view returns (address);\n}\n\ninterface IERC20 {\n    function transferFrom(address _from, address _to, uint256 amount) external payable;\n    function approve(address _spender, uint256 amount) external;\n}\n\ninterface IERC721 {\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n    function ownerOf(uint256 _tokenId) external view returns (address);\n    function approve(address _spender, uint256 _tokenId) external;\n}\n\ninterface ERC721TokenReceiver {\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}\n\n\ncontract CycleNFTX is ERC721TokenReceiver {\n\n    address owner;\n    NFTXv7 nftx = NFTXv7(0xAf93fCce0548D3124A5fC3045adAf1ddE4e8Bf7e);\n    xStore store = xStore(0xBe54738723cea167a76ad5421b50cAa49692E7B7);\n    uint256 currentTokenId;\n    uint256[] desiredIds;\n\n    constructor() {\n        // owner = _owner;\n    }\n\n    // modifier onlyOwner() {\n    //     require(msg.sender == owner, \"Not owner\");\n    //     _;\n    // }\n\n    /**\n     * Precondition: have PUNK-BASIC tokens in your wallet and approve contract for transfer\n     * This will revert with out-of-gas unless the proper token is found, so no need to return tokens to user\n     * Uses 3.15M gas to do 10 iterations\n     * Uses 332k gas to do 1 iteration\n     */\n    function cycle(uint256 vaultId, uint256[] memory _desiredIds, uint256 maxIterations, bool acceptAny) public {\n        address xToken = store.xTokenAddress(vaultId); // PUNK-BASIC\n        address nftAddress = store.nftAddress(vaultId); // WPUNKS\n        uint256[] memory currentTokenIds = new uint256[](1);\n        desiredIds = _desiredIds;\n        IERC20(xToken).transferFrom(msg.sender, address(this), 1 ether);\n        uint iterations = 0;\n        while(true) {\n            IERC20(xToken).approve(address(nftx), 1 ether);\n            nftx.redeem(vaultId, 1);\n            if(acceptAny || isDesired(currentTokenId)) {\n                IERC721(nftAddress).transferFrom(address(this), msg.sender, currentTokenId);\n                return;\n            }\n            iterations += 1;\n            if(iterations >= maxIterations) {\n                require(false, \"Hit maximum iterations\");\n            }\n            currentTokenIds[0] = currentTokenId;\n            IERC721(nftAddress).approve(address(nftx), currentTokenId);\n            nftx.mint(vaultId, currentTokenIds, 1);\n        }\n    }\n\n    function isDesired(uint256 _tokenId) internal view returns (bool) {\n        for(uint i = 0; i < desiredIds.length; i++) {\n            if(_tokenId == desiredIds[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) public override returns (bytes4) {\n        currentTokenId = _tokenId;\n        // TODO: hardcode this hash\n        return 0x150b7a02; //bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n\n}\n"}}}