{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"LotteryTwo.sol":{"content":"//\r\n//  _           _   _                    ___    ___\r\n// | |         | | | |                  |__ \\  / _ \\\r\n// | |     ___ | |_| |_ ___ _ __ _   _     ) || | | |\r\n// | |    / _ \\| __| __/ _ \\ '__| | | |   / / | | | |\r\n// | |___| (_) | |_| ||  __/ |  | |_| |  / /_ | |_| |\r\n// |______\\___/ \\__|\\__\\___|_|   \\__, | |____(_)___/\r\n//                                __/ |\r\n//                               |___/\r\n//\r\npragma solidity ^0.7.5;\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n//Keeps track of owner\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public  onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public  onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n//Interface for ERC20 tokens\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n//Interface for Uni V2 tokens\r\ninterface IUniswapV2ERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n//Interface for the Pepemon factory\r\n//Contains only the mint method\r\ninterface IPepemonFactory{\r\n    function mint(\r\n        address _to,\r\n        uint256 _id,\r\n        uint256 _quantity,\r\n        bytes memory _data\r\n    ) external;\r\n}\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract LotteryTwo is Ownable{\r\n\r\n    //Uni V2 Address for ppdex\r\n    address public UniV2Address;\r\n\r\n    //PPDEX address\r\n    address public PPDEX;\r\n\r\n    //pepemonFactory address\r\n    address public pepemonFactory;\r\n\r\n    //how long users have to wait before they can withdraw LP\r\n    //5760 blocks = 1 day\r\n    //40320 blocks = 1 week\r\n    //184320 block = 32 days\r\n    uint public blockTime;\r\n\r\n    //Block when users will be allowed to mint NFTs if they provided liq before this block\r\n    uint public stakingDeadline;\r\n\r\n    //how many PPDEX needed to stake for a normal NFT\r\n    uint public minPPDEX = 1000*10**17;\r\n\r\n    //how many PPDEX needed to stake for a golden NFT\r\n    uint public minPPDEXGolden = 1000*10**17;\r\n\r\n    //nft ids for minting\r\n    uint public normalID;\r\n    uint public goldenID;\r\n\r\n    using SafeMath for uint;\r\n\r\n    //events\r\n    event Redeemed(address indexed user, uint id);\r\n    event Staked(address indexed user, uint amount);\r\n    event Unstaked(address indexed user, uint amount);\r\n\r\n    /**\r\n     *  _UniV2Address => Uni V2 token address (should be 0x6B1455E27902CA89eE3ABB0673A8Aa9Ce1609952)\r\n     *  _PPDEX => PPDEX token address (should be 0xf1f508c7c9f0d1b15a76fba564eef2d956220cf7)\r\n     *  _pepemonFactory => pepemonFactory address (should be 0xcb6768a968440187157cfe13b67cac82ef6cc5a4)\r\n     *  _blockTime => Time a user must wait to mint a NFT (should be 208000 for 32 days)\r\n     */\r\n    constructor(address _UniV2Address, address _PPDEX, address _pepemonFactory, uint _blockTime)  {\r\n        UniV2Address = _UniV2Address;\r\n        PPDEX = _PPDEX;\r\n        pepemonFactory = _pepemonFactory;\r\n        blockTime = _blockTime;\r\n    }\r\n    //mapping that keeps track of last nft claim\r\n    mapping (address => uint) depositBlock;\r\n\r\n    //mapping that keeps track of how many LP tokens user deposited\r\n    mapping (address => uint ) LPBalance;\r\n\r\n    //mapping that keeps track of if a user is staking\r\n    mapping (address => bool) isStaking;\r\n\r\n    //mapping that keeps track of if a user is staking normal nft\r\n    mapping (address => bool) isStakingNormalNFT;\r\n\r\n    //Keeps track of if a user has minted a NFT;\r\n    mapping(address => mapping(uint => bool)) hasMinted;\r\n\r\n    //setter functions\r\n\r\n    //Sets Uni V2 Pair address\r\n    function setUniV2Address (address addr) public onlyOwner{\r\n        UniV2Address = addr;\r\n    }\r\n    //Sets PPDEX token address\r\n    function setPPDEX (address _PPDEX) public onlyOwner{\r\n        PPDEX = _PPDEX;\r\n    }\r\n    //Sets Pepemon Factory address\r\n    function setPepemonFactory (address _pepemonFactory) public onlyOwner{\r\n        pepemonFactory = _pepemonFactory;\r\n    }\r\n    //Sets the min number of PPDEX needed in liquidity to mint golden nfts\r\n    function setminPPDEXGolden (uint _minPPDEXGolden) public onlyOwner{\r\n        minPPDEXGolden = _minPPDEXGolden;\r\n    }\r\n    //Sets the min number of PPDEX needed in liquidity to mint normal nfts\r\n    function setminPPDEX (uint _minPPDEX) public onlyOwner{\r\n        minPPDEX = _minPPDEX;\r\n    }\r\n    //Updates NFT info - IDs + block\r\n    function updateNFT (uint _normalID, uint _goldenID) public onlyOwner{\r\n        normalID = _normalID;\r\n        goldenID = _goldenID;\r\n        stakingDeadline = block.number;\r\n    }\r\n    //Sets\r\n\r\n    //view LP functions\r\n\r\n    //Returns mininum amount of LP tokens needed to qualify for minting a normal NFT\r\n    //Notice a small fudge factor is added as it looks like uniswap sends a tiny amount of LP tokens to the zero address\r\n    function MinLPTokens() public view returns (uint){\r\n        //Get PPDEX in UniV2 address\r\n        uint totalPPDEX = IERC20(PPDEX).balanceOf(UniV2Address);\r\n        //Get Total LP tokens\r\n        uint totalLP = IUniswapV2ERC20(UniV2Address).totalSupply();\r\n        //subtract a small fudge factor\r\n        return (minPPDEX.mul(totalLP) / totalPPDEX).sub(10000);\r\n    }\r\n\r\n    //Returns min amount of LP tokens needed to qualify for golden NFT\r\n    //Notice a small fudge factor is added as it looks like uniswap sends a tiny amount of LP tokens to the zero address\r\n    function MinLPTokensGolden() public view returns (uint){\r\n        //Get PPDEX in UniV2 address\r\n        uint totalPPDEX = IERC20(PPDEX).balanceOf(UniV2Address);\r\n        //Get Total LP tokens\r\n        uint totalLP = IUniswapV2ERC20(UniV2Address).totalSupply();\r\n        //subtract a small fudge factor\r\n        return (minPPDEXGolden.mul(totalLP) / totalPPDEX).sub(10000);\r\n    }\r\n\r\n    //Converts LP token balances to PPDEX\r\n    function LPToPPDEX(uint lp) public view returns (uint){\r\n        //Get PPDEX in UniV2 address\r\n        uint totalPPDEX = IERC20(PPDEX).balanceOf(UniV2Address);\r\n        //Get Total LP tokens\r\n        uint totalLP = IUniswapV2ERC20(UniV2Address).totalSupply();\r\n        return (lp.mul(totalPPDEX)/totalLP);\r\n    }\r\n\r\n    //mapping functions\r\n\r\n    //Get the block num of the time the user staked\r\n    function getStakingStart(address addr) public view returns(uint){\r\n        return depositBlock[addr];\r\n    }\r\n\r\n    //Get the amount of LP tokens the address deposited\r\n    function getLPBalance(address addr) public view returns(uint){\r\n        return LPBalance[addr];\r\n    }\r\n\r\n    //Check if an address is staking.\r\n    function isUserStaking(address addr) public view returns (bool){\r\n        return isStaking[addr];\r\n    }\r\n\r\n    //Check if user has minted a NFT\r\n    function hasUserMinted(address addr, uint id) public view returns(bool){\r\n        return hasMinted[addr][id];\r\n    }\r\n\r\n    //Check if an address is staking for a normal or golden NFT\r\n    //True = user is staking for a normal NFT\r\n    //False = user is staking for a golden NFT (or the user is not staking at all)\r\n    function isUserStakingNormalNFT(address addr) public view returns (bool){\r\n        return isStakingNormalNFT[addr];\r\n    }\r\n\r\n    //staking functions\r\n    //Transfers liqudity worth 46.6 PPDEX from the user to stake\r\n    function stakeForNormalNFT() public {\r\n        //Make sure user is not already staking\r\n        require (!isStaking[msg.sender], \"Already staking\");\r\n\r\n        //Transfer liquidity worth 46.6 PPDEX to contract\r\n        IUniswapV2ERC20 lpToken = IUniswapV2ERC20(UniV2Address);\r\n        uint lpAmount = MinLPTokens();\r\n        require (lpToken.transferFrom(msg.sender, address(this), lpAmount), \"Token Transfer failed\");\r\n\r\n        //Update mappings\r\n        LPBalance[msg.sender] = lpAmount;\r\n        depositBlock[msg.sender] = block.number;\r\n        isStaking[msg.sender] = true;\r\n        isStakingNormalNFT[msg.sender]= true;\r\n        emit Staked(msg.sender, lpAmount);\r\n    }\r\n    //Transfers liquidity worth 150 PPDEX for user to get golden NFT\r\n    function stakeForGoldenNFT() public {\r\n        //Make sure user is not already staking\r\n        require (!isStaking[msg.sender], \"Already staking\");\r\n\r\n        //Transfer liquidity worth 150 ppdex to contract\r\n        IUniswapV2ERC20 lpToken = IUniswapV2ERC20(UniV2Address);\r\n        uint lpAmount = MinLPTokensGolden();\r\n        require (lpToken.transferFrom(msg.sender, address(this), lpAmount), \"Token Transfer failed\");\r\n\r\n        //Update mappings\r\n        LPBalance[msg.sender] = lpAmount;\r\n        depositBlock[msg.sender] = block.number;\r\n        isStaking[msg.sender] = true;\r\n        isStakingNormalNFT[msg.sender]= false;\r\n        emit Staked(msg.sender, lpAmount);\r\n    }\r\n    //Allow the user to withdraw\r\n    function withdrawLP() public{\r\n\r\n        IUniswapV2ERC20 lpToken = IUniswapV2ERC20(UniV2Address);\r\n\r\n        //LP tokens are locked for 32 days\r\n        require (depositBlock[msg.sender]+blockTime < block.number, \"Must wait 32 days to withdraw\");\r\n\r\n        //Update mappings\r\n        uint lpAmount = LPBalance[msg.sender];\r\n        LPBalance[msg.sender] = 0;\r\n        depositBlock[msg.sender] = 0;\r\n        isStaking[msg.sender] = false;\r\n        isStakingNormalNFT[msg.sender]= false;\r\n        //Send user his LP token balance\r\n        require (lpToken.transfer(msg.sender, lpAmount));\r\n        emit Unstaked(msg.sender, lpAmount);\r\n    }\r\n\r\n    //Allow the user to mint a NFT\r\n    function mintNFT() public {\r\n\r\n        //Make sure user is staking\r\n        require (isStaking[msg.sender], \"User isn't staking\");\r\n\r\n        //Make sure enough time has passed\r\n        require (block.number > stakingDeadline, \"Please wait longer\");\r\n\r\n        //Make sure user deposited before deadline\r\n        require (depositBlock[msg.sender] < stakingDeadline, \"You did not stake before the deadline\");\r\n\r\n        //Make sure user did not already mint a nft\r\n        require ((hasMinted[msg.sender][normalID]  == false)&& (hasMinted[msg.sender][goldenID])== false, \"You have already minted a NFT\");\r\n\r\n        IPepemonFactory factory = IPepemonFactory(pepemonFactory);\r\n\r\n        //Send user 1 normal nft or 1 golden nft, depending on how much he staked\r\n        if (isStakingNormalNFT[msg.sender]){\r\n            factory.mint(msg.sender, normalID, 1, \"\");\r\n            hasMinted[msg.sender][normalID] = true;\r\n            emit Redeemed(msg.sender, normalID);\r\n        }\r\n        else{\r\n            factory.mint(msg.sender, goldenID, 1, \"\");\r\n            hasMinted[msg.sender][goldenID] = true;\r\n            emit Redeemed(msg.sender, goldenID);\r\n        }\r\n    }\r\n\r\n}"}}}