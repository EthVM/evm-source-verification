{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Erc20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\ninterface Erc20\r\n{\r\n    function symbol() view external returns (string memory _symbol);\r\n    function decimals() view external returns (uint8 _decimals);\r\n    \r\n    function balanceOf(address _owner) \r\n        view\r\n        external\r\n        returns (uint256 _balance);\r\n        \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    function transfer(address _to, uint256 _amount) \r\n        external\r\n        returns (bool _success);\r\n    function transferFrom(address _from, address _to, uint256 _amount)\r\n        external\r\n        returns (bool _success);\r\n\r\n    function approve(address _spender, uint256 _amount) \r\n        external\r\n        returns (bool _success);\r\n}"},"contracts/ILiquidityEstablisher.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n// This code is the property of the Aardbanq DAO.\r\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\r\n// It is the author's wish that this code should be open sourced under the MIT license, but the final \r\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \r\n// distributed.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\npragma solidity >=0.7.0;\r\n\r\ninterface ILiquidityEstablisher\r\n{\r\n    function isLiquidityEstablishedOrExpired()\r\n        external\r\n        view\r\n        returns (bool _isEstablishedOrExpired);\r\n}"},"contracts/IPricer.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n// This code is the property of the Aardbanq DAO.\r\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\r\n// It is the author's wish that this code should be open sourced under the MIT license, but the final \r\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \r\n// distributed.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\npragma solidity >=0.7.0;\r\n\r\ninterface IPricer\r\n{\r\n    function currentPrice()\r\n        view\r\n        external\r\n        returns (uint256 _currentPrice);\r\n}"},"contracts/IUniswapV2Factory.sol":{"content":"pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}"},"contracts/IUniswapV2Pair.sol":{"content":"pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}"},"contracts/IUniswapV2Router01.sol":{"content":"pragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}"},"contracts/IUniswapV2Router02.sol":{"content":"pragma solidity >=0.6.2;\r\n\r\nimport './IUniswapV2Router01.sol';\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}"},"contracts/InitialLiquidityOffering.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n// This code is the property of the Aardbanq DAO.\r\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\r\n// It is the author's wish that this code should be open sourced under the MIT license, but the final \r\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \r\n// distributed.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\npragma solidity >=0.7.0;\r\nimport \"./Minter.sol\";\r\nimport \"./Erc20.sol\";\r\nimport \"./IUniswapV2Router02.sol\";\r\nimport \"./IUniswapV2Factory.sol\";\r\nimport \"./IUniswapV2Pair.sol\";\r\nimport \"./IPricer.sol\";\r\nimport \"./SafeMathTyped.sol\";\r\nimport \"./ILiquidityEstablisher.sol\";\r\n\r\n/// @notice A contract to offer initial liquidity purchase and an reward.\r\ncontract InitialLiquidityOffering is ILiquidityEstablisher\r\n{\r\n    /// @notice The time in unix (seconds) timestamp that the offer closes.\r\n    uint64 public offerCloseTime;\r\n    /// @notice The address funds are sent to.\r\n    address public treasury;\r\n    /// @notice The token that is offered.\r\n    Erc20 public tokenOffer;\r\n    /// @notice The time in unix (seconds) timestamp that the liquidity may be claimed.\r\n    uint64 public liquidityReleaseTime;\r\n    /// @notice The token liquidity will be established with.\r\n    Erc20 public liquidityToken;\r\n    /// @notice Flag to indicate if liquidity has been established.\r\n    bool public isLiquidityEstablished;\r\n    /// @notice The minter of the token on offer.\r\n    Minter public minter;\r\n    /// @notice The uniswap router used to establish liquidity.\r\n    IUniswapV2Router02 public uniswapRouter;\r\n    /// @notice The ICO used to establish the price at which liquidity will be established.\r\n    IPricer public pricer;\r\n    /// @notice The maximum liquidity (priced in liquidityToken) up for sale.\r\n    uint256 public maxLiquidityAllowed;\r\n    /// @notice The total liquidity sold so far.\r\n    uint256 public totalLiquidityProvided;\r\n\r\n    /// @notice The total liquidity provided by each address (priced in liquidityToken).\r\n    mapping(address => uint256) public liquidityBalances;\r\n\r\n    /// @notice Constructs an initial liquidity token offering.\r\n    /// @param _offerCloseTime The time in unix (seconds) timestamp that the offer closes.\r\n    /// @param _tokenOffer The token on offer.\r\n    /// @param _liquidityReleaseTime The time in unix (secods) timestamp that the liquidity will be released.\r\n    /// @param _liquidityToken The token liquidity will be sold in. (like DAI)\r\n    /// @param _minter The minter that can mint _tokenOffer tokens.\r\n    /// @param _uniswapRouter The uniswap router to use.\r\n    /// @param _maxLiquidityAllowed The maximum liquidity (priced in _liquidityToken) on sale.\r\n    constructor (uint64 _offerCloseTime, address _treasury, Erc20 _tokenOffer, uint64 _liquidityReleaseTime, Erc20 _liquidityToken, \r\n        Minter _minter, IUniswapV2Router02 _uniswapRouter, uint256 _maxLiquidityAllowed)\r\n    {\r\n        offerCloseTime = _offerCloseTime;\r\n        treasury = _treasury;\r\n        tokenOffer = _tokenOffer;\r\n        liquidityReleaseTime = _liquidityReleaseTime;\r\n        liquidityToken = _liquidityToken;\r\n        minter = _minter;\r\n        uniswapRouter = _uniswapRouter;\r\n        maxLiquidityAllowed = _maxLiquidityAllowed;\r\n    }\r\n\r\n    /// @notice Returns true if either liquidity has been established or the ILO has been closed for more than 7 days. False otherwise.\r\n    /// @return _isEstablishedOrExpired True if either liquidity has been established or the ILO has been closed for more than 7 days. False otherwise.\r\n    function isLiquidityEstablishedOrExpired()\r\n        external\r\n        override\r\n        view\r\n        returns (bool _isEstablishedOrExpired)\r\n    {\r\n        return isLiquidityEstablished || (offerCloseTime + 7 days <= block.timestamp); \r\n    }\r\n\r\n    /// @notice Set the ICO address to use to establish the price of the token on offer.\r\n    function setPricer(IPricer _pricer) \r\n        external\r\n    {\r\n        require(address(pricer) == address(0), \"ABQICO/pricer-already-set\");\r\n        pricer = _pricer;\r\n    }\r\n\r\n    /// @notice Event emitted when liquidity was provided.\r\n    /// @param to The address that provided the liquidity.\r\n    /// @param amount The amount of liquidity (priced in liquidityToken) that was provided.\r\n    event LiquidityOfferReceipt(address to, uint256 amount);\r\n    /// @notice Provide liquidity. Liquidity is paid for from the msg.sender.\r\n    /// @param _target The address that will own and receive the liquidity pool tokens and reward.\r\n    /// @param _amount The amount of liquidity to offer (priced in liquidityToken).\r\n    function provideLiquidity(address _target, uint256 _amount)\r\n        external\r\n    {\r\n        require(offerCloseTime >= block.timestamp && maxLiquidityAllowed > totalLiquidityProvided, \"ABQILO/offer-closed\");\r\n\r\n        // CG: ensure only whole token amounts have no values in the last 18 places\r\n        _amount = (_amount / 1 ether) * 1 ether;\r\n        require(_amount >= 1 ether, \"ABQILO/amount-too-small\");\r\n\r\n        // CG: ensure amounts don't go above max allowed\r\n        uint256 amountLeft = SafeMathTyped.sub256(maxLiquidityAllowed, totalLiquidityProvided);\r\n        if (_amount > amountLeft)\r\n        {\r\n            _amount = amountLeft;\r\n        }\r\n\r\n        // CG: transfer funds\r\n        bool couldTransfer = liquidityToken.transferFrom(msg.sender, address(this), _amount);\r\n        require(couldTransfer, \"ABQILO/could-not-transfer\");\r\n\r\n        // CG: account for funds\r\n        totalLiquidityProvided = SafeMathTyped.add256(totalLiquidityProvided, _amount);\r\n        liquidityBalances[_target] = SafeMathTyped.add256(liquidityBalances[_target], _amount);\r\n\r\n        emit LiquidityOfferReceipt(_target, _amount);\r\n    }\r\n\r\n    /// @notice Event emitted when liquidity is established.\r\n    /// @param liquidityAssetAmount The amount of liquidityToken that was contributed.\r\n    /// @param offerTokenAmount The amount of the token on offer that was added as liquidity.\r\n    /// @param liquidityTokenAmount The amount of liquidity pool tokens that was minted.\r\n    event LiquidityEstablishment(uint256 liquidityAssetAmount, uint256 offerTokenAmount, uint256 liquidityTokenAmount);\r\n    /// @notice Establish liquidity if the sale period ended or the liquidity sale has been sold out.\r\n    function establishLiquidity()\r\n        external\r\n    {\r\n        require(offerCloseTime < block.timestamp || maxLiquidityAllowed == totalLiquidityProvided, \"ABQILO/offer-still-open\");\r\n        require(!isLiquidityEstablished, \"ABQILO/liquidity-already-established\");\r\n\r\n        if (totalLiquidityProvided > 0)\r\n        {\r\n            uint256 currentPrice = pricer.currentPrice();\r\n            if (currentPrice > 10 ether)\r\n            {\r\n                // CG: in the event the ICO was sold out.\r\n                currentPrice = 10 ether;\r\n            }\r\n            uint256 totalOfferProvided = SafeMathTyped.mul256(totalLiquidityProvided / currentPrice, 1 ether);\r\n            minter.mint(address(this), totalOfferProvided);\r\n\r\n            bool isOfferApproved = tokenOffer.approve(address(uniswapRouter), totalOfferProvided);\r\n            require(isOfferApproved, \"ABQICO/could-not-approve-offer\");\r\n            bool isLiquidityApproved = liquidityToken.approve(address(uniswapRouter), totalLiquidityProvided);\r\n            require(isLiquidityApproved, \"ABQICO/could-not-approve-liquidity\");\r\n\r\n            (, , uint256 liquidityTokensCount) = uniswapRouter.addLiquidity(address(liquidityToken), address(tokenOffer), totalLiquidityProvided, totalOfferProvided, 0, 0, address(this), block.timestamp);\r\n\r\n            IUniswapV2Factory factory = IUniswapV2Factory(uniswapRouter.factory());\r\n            IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(address(tokenOffer), address(liquidityToken)));\r\n            require(address(pair) != address(0), \"ABQILO/pair-not-created\");\r\n            bool couldSendDaoShare = pair.transfer(treasury, liquidityTokensCount / 2);\r\n            require(couldSendDaoShare, \"ABQILO/could-not-send\");\r\n\r\n            emit LiquidityEstablishment(totalLiquidityProvided, totalOfferProvided, liquidityTokensCount);\r\n        }\r\n\r\n        isLiquidityEstablished = true;\r\n    }\r\n\r\n    /// @notice Event emitted when liquidity pool tokens are claimed.\r\n    /// @param to The address the claim was for.\r\n    /// @param amount The amount of liquidity pool tokens that was claimed.\r\n    /// @param reward The reward (in the token on offer) that was also claimed.\r\n    event Claim(address to, uint256 amount, uint256 reward);\r\n    /// @notice Claim liquidity pool tokens and the reward after liquidity has been released.\r\n    /// @param _for The address to release the liquidity pool tokens and the reward for.\r\n    function claim(address _for)\r\n        external\r\n    {\r\n        require(liquidityReleaseTime <= block.timestamp, \"ABQILO/liquidity-locked\");\r\n        require(isLiquidityEstablished, \"ABQILO/liquidity-not-established\");\r\n\r\n        // CG: we can divide be 1 ether since we made sure values does not include any values in the last 18 decimals. See the provideLiquidity token.\r\n        uint256 claimShareFull = liquidityBalances[_for];\r\n        if (claimShareFull == 0)\r\n        {\r\n            return;\r\n        }\r\n        uint256 claimShare = (claimShareFull / 1 ether);\r\n        uint256 claimPool = (totalLiquidityProvided / 1 ether);\r\n\r\n        // CG: remove claim share from accounts\r\n        totalLiquidityProvided = SafeMathTyped.sub256(totalLiquidityProvided, claimShareFull);\r\n        liquidityBalances[_for] = 0;\r\n\r\n        // CG: get uniswap pair\r\n        IUniswapV2Factory factory = IUniswapV2Factory(uniswapRouter.factory());\r\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(address(tokenOffer), address(liquidityToken)));\r\n        require(address(pair) != address(0), \"ABQILO/pair-not-created\");\r\n        uint256 pairBalance = pair.balanceOf(address(this));\r\n\r\n        // CG: transfer claim\r\n        uint256 claimTotal = SafeMathTyped.mul256(pairBalance, claimShare) / claimPool;\r\n        bool couldTransfer = pair.transfer(_for, claimTotal);\r\n        require(couldTransfer, \"ABQILO/could-not-transfer\");\r\n\r\n        // CG: mint reward: 25% of original contribution as reward tokens.\r\n        uint256 reward = SafeMathTyped.mul256(claimShareFull, 25) / 100;\r\n        minter.mint(_for, reward);\r\n\r\n        emit Claim(_for, claimTotal, reward);\r\n    }\r\n}"},"contracts/Minter.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n// This code is the property of the Aardbanq DAO.\r\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\r\n// It is the author's wish that this code should be open sourced under the MIT license, but the final \r\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \r\n// distributed.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\npragma solidity >=0.7.0;\r\n\r\ninterface Minter\r\n{\r\n    function mint(address _target, uint256 _amount) external;\r\n}"},"contracts/SafeMathTyped.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMathTyped {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"uint256 overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"Can't divide by 0\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"uint256 underflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"uint256 overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"Can't mod by 0\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the greater of two numbers\r\n    */\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the lesser of two numbers\r\n    */\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n}"}}}