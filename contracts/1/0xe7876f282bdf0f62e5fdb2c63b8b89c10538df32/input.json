{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Pile.sol":{"content":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/borrower/pile.sol\npragma solidity >=0.4.23 >=0.5.15 <0.6.0;\n\n////// lib/tinlake-auth/lib/ds-note/src/note.sol\n/// note.sol -- the `note' modifier, for logging calls as events\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint256           wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        _;\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n    }\n}\n\n////// lib/tinlake-auth/src/auth.sol\n// Copyright (C) Centrifuge 2020, based on MakerDAO dss https://github.com/makerdao/dss\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.5.15 <0.6.0; */\n\n/* import \"ds-note/note.sol\"; */\n\ncontract Auth is DSNote {\n    mapping (address => uint) public wards;\n    function rely(address usr) public auth note { wards[usr] = 1; }\n    function deny(address usr) public auth note { wards[usr] = 0; }\n    modifier auth { require(wards[msg.sender] == 1); _; }\n}\n\n////// lib/tinlake-math/src/math.sol\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.5.15 <0.6.0; */\n\ncontract Math {\n    uint256 constant ONE = 10 ** 27;\n\n    function safeAdd(uint x, uint y) public pure returns (uint z) {\n        require((z = x + y) >= x, \"safe-add-failed\");\n    }\n\n    function safeSub(uint x, uint y) public pure returns (uint z) {\n        require((z = x - y) <= x, \"safe-sub-failed\");\n    }\n\n    function safeMul(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"safe-mul-failed\");\n    }\n\n    function safeDiv(uint x, uint y) public pure returns (uint z) {\n        z = x / y;\n    }\n\n    function rmul(uint x, uint y) public pure returns (uint z) {\n        z = safeMul(x, y) / ONE;\n    }\n\n    function rdiv(uint x, uint y) public pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        z = safeAdd(safeMul(x, ONE), y / 2) / y;\n    }\n\n    function rdivup(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        // always rounds up\n        z = safeAdd(safeMul(x, ONE), safeSub(y, 1)) / y;\n    }\n\n\n}\n\n////// lib/tinlake-math/src/interest.sol\n// Copyright (C) 2018 Rain <rainbreak@riseup.net> and Centrifuge, referencing MakerDAO dss => https://github.com/makerdao/dss/blob/master/src/pot.sol\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.5.15 <0.6.0; */\n\n/* import \"./math.sol\"; */\n\ncontract Interest is Math {\n    // @notice This function provides compounding in seconds\n    // @param chi Accumulated interest rate over time\n    // @param ratePerSecond Interest rate accumulation per second in RAD(10ˆ27)\n    // @param lastUpdated When the interest rate was last updated\n    // @param pie Total sum of all amounts accumulating under one interest rate, divided by that rate\n    // @return The new accumulated rate, as well as the difference between the debt calculated with the old and new accumulated rates.\n    function compounding(uint chi, uint ratePerSecond, uint lastUpdated, uint pie) public view returns (uint, uint) {\n        require(block.timestamp >= lastUpdated, \"tinlake-math/invalid-timestamp\");\n        require(chi != 0);\n        // instead of a interestBearingAmount we use a accumulated interest rate index (chi)\n        uint updatedChi = _chargeInterest(chi ,ratePerSecond, lastUpdated, block.timestamp);\n        return (updatedChi, safeSub(rmul(updatedChi, pie), rmul(chi, pie)));\n    }\n\n    // @notice This function charge interest on a interestBearingAmount\n    // @param interestBearingAmount is the interest bearing amount\n    // @param ratePerSecond Interest rate accumulation per second in RAD(10ˆ27)\n    // @param lastUpdated last time the interest has been charged\n    // @return interestBearingAmount + interest\n    function chargeInterest(uint interestBearingAmount, uint ratePerSecond, uint lastUpdated) public view returns (uint) {\n        if (block.timestamp >= lastUpdated) {\n            interestBearingAmount = _chargeInterest(interestBearingAmount, ratePerSecond, lastUpdated, block.timestamp);\n        }\n        return interestBearingAmount;\n    }\n\n    function _chargeInterest(uint interestBearingAmount, uint ratePerSecond, uint lastUpdated, uint current) internal pure returns (uint) {\n        return rmul(rpow(ratePerSecond, current - lastUpdated, ONE), interestBearingAmount);\n    }\n\n\n    // convert pie to debt/savings amount\n    function toAmount(uint chi, uint pie) public pure returns (uint) {\n        return rmul(pie, chi);\n    }\n\n    // convert debt/savings amount to pie\n    function toPie(uint chi, uint amount) public pure returns (uint) {\n        return rdivup(amount, chi);\n    }\n\n    function rpow(uint x, uint n, uint base) public pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                let xx := mul(x, x)\n                if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                let xxRound := add(xx, half)\n                if lt(xxRound, xx) { revert(0,0) }\n                x := div(xxRound, base)\n                if mod(n,2) {\n                    let zx := mul(z, x)\n                    if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                    let zxRound := add(zx, half)\n                    if lt(zxRound, zx) { revert(0,0) }\n                    z := div(zxRound, base)\n                }\n            }\n            }\n        }\n    }\n}\n\n////// src/borrower/pile.sol\n// Copyright (C) 2018  Rain <rainbreak@riseup.net>, Centrifuge\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.5.15 <0.6.0; */\n\n/* import \"ds-note/note.sol\"; */\n/* import \"tinlake-math/interest.sol\"; */\n/* import \"tinlake-auth/auth.sol\"; */\n\n// ## Interest Group based Pile\n// The following is one implementation of a debt module. It keeps track of different buckets of interest rates and is optimized for many loans per interest bucket. It keeps track of interest\n// rate accumulators (chi values) for all interest rate categories. It calculates debt each\n// loan according to its interest rate category and pie value.\ncontract Pile is DSNote, Auth, Interest {\n    // --- Data ---\n\n    /// stores all needed information of an interest rate group\n    struct Rate {\n        uint   pie;                 // Total debt of all loans with this rate\n        uint   chi;                 // Accumulated rates\n        uint   ratePerSecond;       // Accumulation per second\n        uint48 lastUpdated;         // Last time the rate was accumulated\n        uint   fixedRate;           // fixed rate applied to each loan of the group\n    }\n\n    /// Interest Rate Groups are identified by a `uint` and stored in a mapping\n    mapping (uint => Rate) public rates;\n\n    /// mapping of all loan debts\n    /// the debt is stored as pie\n    /// pie is defined as pie = debt/chi therefore debt = pie * chi\n    /// where chi is the accumulated interest rate index over time\n    mapping (uint => uint) public pie;\n    /// loan => rate\n    mapping (uint => uint) public loanRates;\n\n\n    /// total debt of all ongoing loans\n    uint public total;\n\n    constructor() public {\n        wards[msg.sender] = 1;\n        /// pre-definition for loans without interest rates\n        rates[0].chi = ONE;\n        rates[0].ratePerSecond = ONE;\n    }\n\n     // --- Public Debt Methods  ---\n    /// increases the debt of a loan by a currencyAmount\n    /// a change of the loan debt updates the rate debt and total debt\n    function incDebt(uint loan, uint currencyAmount) external auth note { \n        uint rate = loanRates[loan];\n        require(now == rates[rate].lastUpdated, \"rate-group-not-updated\");\n        currencyAmount = safeAdd(currencyAmount, rmul(currencyAmount, rates[rate].fixedRate));\n        uint pieAmount = toPie(rates[rate].chi, currencyAmount);\n\n        pie[loan] = safeAdd(pie[loan], pieAmount);\n        rates[rate].pie = safeAdd(rates[rate].pie, pieAmount);\n        total = safeAdd(total, currencyAmount);\n    }\n\n    /// decrease the loan's debt by a currencyAmount\n    /// a change of the loan debt updates the rate debt and total debt\n    function decDebt(uint loan, uint currencyAmount) external auth note {\n        uint rate = loanRates[loan];\n        require(now == rates[rate].lastUpdated, \"rate-group-not-updated\");\n        uint pieAmount = toPie(rates[rate].chi, currencyAmount);\n\n        pie[loan] = safeSub(pie[loan], pieAmount);\n        rates[rate].pie = safeSub(rates[rate].pie, pieAmount);\n\n        if (currencyAmount > total) {\n            total = 0;\n            return;\n        }\n\n        total = safeSub(total, currencyAmount);\n    }\n\n    /// returns the current debt based on actual block.timestamp (now)\n    function debt(uint loan) external view returns (uint) {\n        uint rate_ = loanRates[loan];\n        uint chi_ = rates[rate_].chi;\n        if (now >= rates[rate_].lastUpdated) {\n            chi_ = chargeInterest(rates[rate_].chi, rates[rate_].ratePerSecond, rates[rate_].lastUpdated);\n        }\n        return toAmount(chi_, pie[loan]);\n    }\n\n    /// returns the total debt of a interest rate group\n    function rateDebt(uint rate) external view returns (uint) {\n        uint chi_ = rates[rate].chi;\n        uint pie_ = rates[rate].pie;\n\n        if (now >= rates[rate].lastUpdated) {\n            chi_ = chargeInterest(rates[rate].chi, rates[rate].ratePerSecond, rates[rate].lastUpdated);\n        }\n        return toAmount(chi_, pie_);\n    }\n\n    // --- Interest Rate Group Implementation ---\n\n    // set rate loanRates for a loan\n    function setRate(uint loan, uint rate) external auth note {\n        require(pie[loan] == 0, \"non-zero-debt\");\n        // rate category has to be initiated\n        require(rates[rate].chi != 0, \"rate-group-not-set\");\n        loanRates[loan] = rate;\n    }\n\n    // change rate loanRates for a loan\n    function changeRate(uint loan, uint newRate) external auth note {\n        require(rates[newRate].chi != 0, \"rate-group-not-set\");\n        uint currentRate = loanRates[loan];\n        drip(currentRate);\n        drip(newRate);\n        uint pie_ = pie[loan];\n        uint debt_ = toAmount(rates[currentRate].chi, pie_);\n        rates[currentRate].pie = safeSub(rates[currentRate].pie, pie_);\n        pie[loan] = toPie(rates[newRate].chi, debt_);\n        rates[newRate].pie = safeAdd(rates[newRate].pie, pie[loan]);\n        loanRates[loan] = newRate;\n    }\n\n    // set/change the interest rate of a rate category\n    function file(bytes32 what, uint rate, uint value) external auth note {\n        if (what == \"rate\") {\n            require(value != 0, \"rate-per-second-can-not-be-0\");\n            if (rates[rate].chi == 0) {\n                rates[rate].chi = ONE;\n                rates[rate].lastUpdated = uint48(now);\n            } else {\n                drip(rate);\n            } \n            rates[rate].ratePerSecond = value;\n        } else if (what == \"fixedRate\") {\n            rates[rate].fixedRate = value;\n        } else revert(\"unknown parameter\");\n    }\n\n    // accrue needs to be called before any debt amounts are modified by an external component\n    function accrue(uint loan) external {\n        drip(loanRates[loan]);\n    }\n\n    // drip updates the chi of the rate category by compounding the interest and\n    // updates the total debt\n    function drip(uint rate) public {        \n        if (now >= rates[rate].lastUpdated) {\n            (uint chi, uint deltaInterest) = compounding(rates[rate].chi, rates[rate].ratePerSecond, rates[rate].lastUpdated, rates[rate].pie);\n            rates[rate].chi = chi;\n            rates[rate].lastUpdated = uint48(now);\n            total = safeAdd(total, deltaInterest);\n        }\n    }\n}\n"}}}