{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "LOAD.sol": {
      "content": "\n// File: contracts/load2.sol\n\npragma solidity >=0.4.23 <0.6.0;\n\n\n    library SafeMath {\n        /**\n        * @dev Returns the addition of two unsigned integers, reverting on\n        * overflow.\n        *\n        * Counterpart to Solidity's `+` operator.\n        *\n        * Requirements:\n        * - Addition cannot overflow.\n        */\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\n            uint256 c = a + b;\n            require(c >= a, \"SafeMath: addition overflow\");\n\n            return c;\n        }\n\n        /**\n        * @dev Returns the subtraction of two unsigned integers, reverting on\n        * overflow (when the result is negative).\n        *\n        * Counterpart to Solidity's `-` operator.\n        *\n        * Requirements:\n        * - Subtraction cannot overflow.\n        */\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n            require(b <= a, \"SafeMath: subtraction overflow\");\n            uint256 c = a - b;\n\n            return c;\n        }\n\n        /**\n        * @dev Returns the multiplication of two unsigned integers, reverting on\n        * overflow.\n        *\n        * Counterpart to Solidity's `*` operator.\n        *\n        * Requirements:\n        * - Multiplication cannot overflow.\n        */\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n            if (a == 0) {\n                return 0;\n            }\n\n            uint256 c = a * b;\n            require(c / a == b, \"SafeMath: multiplication overflow\");\n\n            return c;\n        }\n\n        /**\n        * @dev Returns the integer division of two unsigned integers. Reverts on\n        * division by zero. The result is rounded towards zero.\n        *\n        * Counterpart to Solidity's `/` operator. Note: this function uses a\n        * `revert` opcode (which leaves remaining gas untouched) while Solidity\n        * uses an invalid opcode to revert (consuming all remaining gas).\n        *\n        * Requirements:\n        * - The divisor cannot be zero.\n        */\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\n            // Solidity only automatically asserts when dividing by 0\n            require(b > 0, \"SafeMath: division by zero\");\n            uint256 c = a / b;\n            // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n            return c;\n        }\n\n        /**\n        * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n        * Reverts when dividing by zero.\n        *\n        * Counterpart to Solidity's `%` operator. This function uses a `revert`\n        * opcode (which leaves remaining gas untouched) while Solidity uses an\n        * invalid opcode to revert (consuming all remaining gas).\n        *\n        * Requirements:\n        * - The divisor cannot be zero.\n        */\n        function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n            require(b != 0, \"SafeMath: modulo by zero\");\n            return a % b;\n        }\n    }\n\n\n    interface IERC20 {\n        /**\n        * @dev Returns the amount of tokens in existence.\n        */\n        function totalSupply() external view returns (uint256);\n\n        /**\n        * @dev Returns the amount of tokens owned by `account`.\n        */\n        function balanceOf(address account) external view returns (uint256);\n\n        /**\n        * @dev Moves `amount` tokens from the caller's account to `recipient`.\n        *\n        * Returns a boolean value indicating whether the operation succeeded.\n        *\n        * Emits a `Transfer` event.\n        */\n        function transfer(address recipient, uint256 amount) external returns (bool);\n\n        /**\n        * @dev Returns the remaining number of tokens that `spender` will be\n        * allowed to spend on behalf of `owner` through `transferFrom`. This is\n        * zero by default.\n        *\n        * This value changes when `approve` or `transferFrom` are called.\n        */\n        function allowance(address owner, address spender) external view returns (uint256);\n\n        /**\n        * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n        *\n        * Returns a boolean value indicating whether the operation succeeded.\n        *\n        * > Beware that changing an allowance with this method brings the risk\n        * that someone may use both the old and the new allowance by unfortunate\n        * transaction ordering. One possible solution to mitigate this race\n        * condition is to first reduce the spender's allowance to 0 and set the\n        * desired value afterwards:\n        * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        *\n        * Emits an `Approval` event.\n        */\n        function approve(address spender, uint256 amount) external returns (bool);\n\n        /**\n        * @dev Moves `amount` tokens from `sender` to `recipient` using the\n        * allowance mechanism. `amount` is then deducted from the caller's\n        * allowance.\n        *\n        * Returns a boolean value indicating whether the operation succeeded.\n        *\n        * Emits a `Transfer` event.\n        */\n        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n        /**\n        * @dev Emitted when `value` tokens are moved from one account (`from`) to\n        * another (`to`).\n        *\n        * Note that `value` may be zero.\n        */\n        event Transfer(address indexed from, address indexed to, uint256 value);\n\n        /**\n        * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n        * a call to `approve`. `value` is the new allowance.\n        */\n        event Approval(address indexed owner, address indexed spender, uint256 value);\n    }\n\n\n\n\n    /**\n    * @title Initializable\n    *\n    * @dev Helper contract to support initializer functions. To use it, replace\n    * the constructor with a function that has the `initializer` modifier.\n    * WARNING: Unlike constructors, initializer functions must be manually\n    * invoked. This applies both to deploying an Initializable contract, as well\n    * as extending an Initializable contract via inheritance.\n    * WARNING: When used with inheritance, manual care must be taken to not invoke\n    * a parent initializer twice, or ensure that all initializers are idempotent,\n    * because this is not dealt with automatically as with constructors.\n    */\n    contract Initializable {\n\n        /**\n        * @dev Indicates that the contract has been initialized.\n        */\n        bool private initialized;\n\n        /**\n        * @dev Indicates that the contract is in the process of being initialized.\n        */\n        bool private initializing;\n\n        /**\n        * @dev Modifier to use in the initializer function of a contract.\n        */\n        modifier initializer() {\n            require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n            bool isTopLevelCall = !initializing;\n            if (isTopLevelCall) {\n                initializing = true;\n                initialized = true;\n            }\n\n            _;\n\n            if (isTopLevelCall) {\n                initializing = false;\n            }\n        }\n\n        /// @dev Returns true if and only if the function is running in the constructor\n        function isConstructor() private view returns (bool) {\n            // extcodesize checks the size of the code stored in an address, and\n            // address returns the current address. Since the code is still not\n            // deployed when running a constructor, any checks on its code size will\n            // yield zero, making it an effective way to detect if a contract is\n            // under construction or not.\n            address self = address(this);\n            uint256 cs;\n            assembly {cs := extcodesize(self)}\n            return cs == 0;\n        }\n\n        // Reserved storage space to allow for layout changes in the future.\n        uint256[50] private ______gap;\n    }\n\n\n    contract ERC20 is Initializable, IERC20 {\n        using SafeMath for uint256;\n\n\n        mapping(address => uint256) private _balances;\n\n        mapping(address => mapping(address => uint256)) private _allowances;\n\n        uint256 private _totalSupply;\n\n        string public  name;\n        string public  symbol;\n        uint256 public decimals;\n\n        function initialize() initializer public {\n            name = \"LOAD\";\n            symbol = \"LOAD\";\n            decimals = 8;\n            _totalSupply = 10000000 * 10 ** decimals;\n            _balances[0x264Db6A72f7144933FF700416CAD98816A6e0261] = 200000 * 10 ** decimals;\n            _balances[address(this)] = _totalSupply.sub(_balances[0x264Db6A72f7144933FF700416CAD98816A6e0261]);\n            emit Transfer(address(0), 0x264Db6A72f7144933FF700416CAD98816A6e0261, _balances[0x264Db6A72f7144933FF700416CAD98816A6e0261]);\n            emit Transfer(address(0), address(this), _balances[address(this)]);\n        }\n\n        function receiveLoad(uint amount) internal;\n        /**\n        * @dev See `IERC20.totalSupply`.\n        */\n        function totalSupply() public view returns (uint256) {\n            return _totalSupply;\n        }\n\n        /**\n        * @dev See `IERC20.balanceOf`.\n        */\n        function balanceOf(address account) public view returns (uint256) {\n            return _balances[account];\n        }\n\n        /**\n        * @dev See `IERC20.transfer`.\n        *\n        * Requirements:\n        *\n        * - `recipient` cannot be the zero address.\n        * - the caller must have a balance of at least `amount`.\n        */\n        function transfer(address recipient, uint256 amount) public returns (bool) {\n            _transfer(msg.sender, recipient, amount);\n\n            return true;\n        }\n\n        /**\n        * @dev See `IERC20.allowance`.\n        */\n        function allowance(address owner, address spender) public view returns (uint256) {\n            return _allowances[owner][spender];\n        }\n\n        /**\n        * @dev See `IERC20.approve`.\n        *\n        * Requirements:\n        *\n        * - `spender` cannot be the zero address.\n        */\n        function approve(address spender, uint256 value) public returns (bool) {\n            _approve(msg.sender, spender, value);\n            return true;\n        }\n\n        /**\n        * @dev See `IERC20.transferFrom`.\n        *\n        * Emits an `Approval` event indicating the updated allowance. This is not\n        * required by the EIP. See the note at the beginning of `ERC20`;\n        *\n        * Requirements:\n        * - `sender` and `recipient` cannot be the zero address.\n        * - `sender` must have a balance of at least `value`.\n        * - the caller must have allowance for `sender`'s tokens of at least\n        * `amount`.\n        */\n        function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n            _transfer(sender, recipient, amount);\n            _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n            return true;\n        }\n\n\n\n        /**\n        * @dev Moves tokens `amount` from `sender` to `recipient`.\n        *\n        * This is internal function is equivalent to `transfer`, and can be used to\n        * e.g. implement automatic token fees, slashing mechanisms, etc.\n        *\n        * Emits a `Transfer` event.\n        *\n        * Requirements:\n        *\n        * - `sender` cannot be the zero address.\n        * - `recipient` cannot be the zero address.\n        * - `sender` must have a balance of at least `amount`.\n        */\n        function _transfer(address sender, address recipient, uint256 amount) internal {\n            require(sender != address(0), \"ERC20: transfer from the zero address\");\n            require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n            _balances[sender] = _balances[sender].sub(amount);\n            _balances[recipient] = _balances[recipient].add(amount);\n            if (recipient == address(this)) {\n                receiveLoad(amount);\n            }\n\n            emit Transfer(sender, recipient, amount);\n        }\n\n\n\n\n        /**\n        * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n        *\n        * This is internal function is equivalent to `approve`, and can be used to\n        * e.g. set automatic allowances for certain subsystems, etc.\n        *\n        * Emits an `Approval` event.\n        *\n        * Requirements:\n        *\n        * - `owner` cannot be the zero address.\n        * - `spender` cannot be the zero address.\n        */\n        function _approve(address owner, address spender, uint256 value) internal {\n            require(owner != address(0), \"ERC20: approve from the zero address\");\n            require(spender != address(0), \"ERC20: approve to the zero address\");\n\n            _allowances[owner][spender] = value;\n            emit Approval(owner, spender, value);\n        }\n\n\n    }\n\n    contract Owned is Initializable {\n        address public owner;\n        address public newOwner;\n\n        event OwnershipTransferred(address indexed _from, address indexed _to);\n\n\n        function initialize() initializer public {\n            owner = msg.sender;\n        }\n\n        modifier onlyOwner {\n            require(msg.sender == owner);\n            _;\n        }\n\n        function transferOwnership(address _newOwner) public onlyOwner {\n            newOwner = _newOwner;\n        }\n        \n        function acceptOwnership() public {\n            require(msg.sender == newOwner);\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            newOwner = address(0);\n        }\n\n    }\n\n\n    library Roles {\n        struct Role {\n            mapping(address => bool) bearer;\n        }\n\n        /**\n        * @dev Give an account access to this role.\n        */\n        function add(Role storage role, address account) internal {\n            require(!has(role, account), \"Roles: account already has role\");\n            role.bearer[account] = true;\n        }\n\n        /**\n        * @dev Remove an account's access to this role.\n        */\n        function remove(Role storage role, address account) internal {\n            require(has(role, account), \"Roles: account does not have role\");\n            role.bearer[account] = false;\n        }\n\n        /**\n        * @dev Check if an account has this role.\n        * @return bool\n        */\n        function has(Role storage role, address account) internal view returns (bool) {\n            require(account != address(0), \"Roles: account is the zero address\");\n            return role.bearer[account];\n        }\n    }\n\n    contract WhitelistCfoRole is Initializable, Owned {\n        using Roles for Roles.Role;\n\n        event WhitelistCfoAdded(address indexed account);\n        event WhitelistCfoRemoved(address indexed account);\n\n        Roles.Role private _whitelistCfos;\n\n\n        function initialize() initializer public {\n            _addWhitelistCfo(0x264Db6A72f7144933FF700416CAD98816A6e0261);\n            _addWhitelistCfo(0x28125957Cb2d6AC5d7ca1b06C122Afdd7974A1c5);\n            _addWhitelistCfo(0xDCbd4AC767827A859e4c1a48269B650303B57f30);\n            _addWhitelistCfo(0x116a0Bd45575719711804276B6D92226017d37b9);\n            _addWhitelistCfo(0x77D1577D9b312D6ff831E95F1D72D92359E5d89c);\n        }\n\n        modifier onlyWhitelistCfo() {\n            require(isWhitelistCfo(msg.sender), \"WhitelistCfoRole: caller does not have the WhitelistCfo role\");\n            _;\n        }\n\n        function isWhitelistCfo(address account) public view returns (bool) {\n            return _whitelistCfos.has(account);\n        }\n\n        function addWhitelistCfo(address account) public onlyOwner {\n            _addWhitelistCfo(account);\n        }\n\n        function removeWhitelistCfo(address account) public onlyOwner {\n            _removeWhitelistCfo(account);\n        }\n\n\n        function _addWhitelistCfo(address account) internal {\n            _whitelistCfos.add(account);\n            emit WhitelistCfoAdded(account);\n        }\n\n        function _removeWhitelistCfo(address account) internal {\n            _whitelistCfos.remove(account);\n            emit WhitelistCfoRemoved(account);\n        }\n    }\n\n\n    contract LOAD is Initializable, ERC20, WhitelistCfoRole {\n\n        using SafeMath for uint;\n\n\n        struct Lock {\n            uint load_amount;\n            uint unlock_date;\n        }\n\n        uint firstDay;\n\n        uint  ethManager;\n        ///\n        struct LoadChange {\n            bool ischange;\n            uint amount;\n        }\n        //    uint users;//all users\n        mapping(address => bool) isLocking;\n\n        uint private floor_amount;\n        uint private exchanged;\n        uint private load_lock;\n\n        uint private load_price;\n        uint private eth_unit;\n\n        uint lockdays;\n        uint divdDuration;\n\n\n        mapping(string => address) manager;\n\n\n        mapping(address => Lock)  locks;\n\n\n        mapping(address => uint) user_load_divs_total;\n        mapping(address => uint) user_eth_divs_total;\n\n\n        mapping(uint => LoadChange) public loadDaily;\n        mapping(uint => uint) public ethDaily;\n        mapping(address => uint) public userDivdDate;\n        mapping(address => mapping(uint => LoadChange)) loadChanges;\n\n\n        function initialize() initializer public {\n            ERC20.initialize();\n            Owned.initialize();\n            WhitelistCfoRole.initialize();\n            addInit();\n\n            load_price = 1500000000000000;\n            eth_unit = 1500000000000000;\n\n            floor_amount =45000000000000;// 45000000000000;\n            firstDay = now;\n            lockdays = 3 days;\n            divdDuration = 1 days;\n        }\n\n\n        function addInit() private {\n            manager[\"Founder\"] = 0x264Db6A72f7144933FF700416CAD98816A6e0261;\n            manager[\"Dev\"] = 0x28125957Cb2d6AC5d7ca1b06C122Afdd7974A1c5;\n            manager[\"Julie\"] = 0xDCbd4AC767827A859e4c1a48269B650303B57f30;\n            manager[\"Ant\"] = 0x116a0Bd45575719711804276B6D92226017d37b9;\n            manager[\"Prince\"] = 0x4018D4838dA267896670AB777a802ea1c0229a16;\n            manager[\"Tree\"] = 0x8ef45fd3F2e4591866f1A17AafeACac61A7812c7;\n            manager[\"CryptoGirl\"] = 0x77B5D2DE66A18310B778a5c48D5Abe7d2A6D661D;\n            manager[\"IP_PCS\"] = 0xf40e89F1e52A6b5e71B0e18365d539F5E424306f;\n            manager[\"Fee\"] = 0x77D1577D9b312D6ff831E95F1D72D92359E5d89c;\n            manager[\"UNI\"] = 0x6166760a83bEF57958394ec2eEd00845b4Cf5a08;\n            manager[\"A\"] = 0x4E1FE0409C2845C1Bde8fcbE21ac6889311c8aB5;\n\n        }\n\n        function changeAddress(string nickname, address newaddress) external onlyOwner {\n            manager[nickname] = newaddress;\n        }\n\n        function isContract(address addr) internal view returns (bool) {\n            uint256 size;\n            assembly {size := extcodesize(addr)}\n            return size > 0;\n        }\n\n        function receiveEth() public payable {\n            require(!isContract(msg.sender), \"Should not be contract address\");\n            require(msg.value > 0, \"Can't Zero\");\n            require(exchanged < 180000000000000, \"The exchange is over\");\n            require(mosteth() >= msg.value, \"Not so much\");\n            uint coin;\n\n            coin = exchangeload(msg.value);\n            exchanged = exchanged.add(coin);\n            uint level = exchanged.div(floor_amount).add(1);\n            load_lock = load_lock.add(coin);\n\n            locks[msg.sender].unlock_date = now + lockdays;\n            locks[msg.sender].load_amount = locks[msg.sender].load_amount.add(coin);\n\n            uint today = now.div(divdDuration).add(1);\n            uint ethvalue = msg.value.mul(level).div(10);\n            loadDaily[today].amount = load_lock;\n            loadDaily[today].ischange = true;\n            ethDaily[today] = ethDaily[today].add(ethvalue);\n            ethManager = ethManager.add(msg.value.sub(ethvalue));\n            loadChanges[msg.sender][today].ischange = true;\n            loadChanges[msg.sender][today].amount = locks[msg.sender].load_amount;\n\n            if (userDivdDate[msg.sender] == 0) {\n                userDivdDate[msg.sender] = now.div(divdDuration);\n            }\n            addGuess(coin);\n            if(!isLocking[msg.sender]){\n                isLocking[msg.sender] = true;\n                users ++;\n            }\n        }\n\n        function() external payable {\n            receiveEth();\n        }\n\n\n        function checkredeemable() public view returns (uint amount) {\n            if (now > locks[msg.sender].unlock_date) {\n                return locks[msg.sender].load_amount;\n            } else {\n                return 0;\n            }\n        }\n\n\n        function ethsharediv() external onlyWhitelistCfo {\n\n            uint ethpercentten = ethManager.div(10);\n            //10 percent\n            uint256 ethshare = (ethManager.sub(ethpercentten)).div(100);\n\n            address(uint160(manager[\"UNI\"])).transfer(ethpercentten);\n\n            address(uint160(manager[\"Founder\"])).transfer(ethshare.mul(23));\n            address(uint160(manager[\"Dev\"])).transfer(ethshare.mul(30));\n            address(uint160(manager[\"Julie\"])).transfer(ethshare.mul(20));\n            address(uint160(manager[\"Ant\"])).transfer(ethshare.mul(2));\n            address(uint160(manager[\"Prince\"])).transfer(ethshare.mul(5));\n            address(uint160(manager[\"Max\"])).transfer(ethshare.mul(8));\n            address(uint160(manager[\"Soco\"])).transfer(ethshare.mul(2));\n            address(uint160(manager[\"Tree\"])).transfer(ethshare.mul(4));\n            address(uint160(manager[\"Zero\"])).transfer(ethshare.mul(2));\n            address(uint160(manager[\"SK\"])).transfer(ethshare.mul(1));\n            address(uint160(manager[\"IP_PCS\"])).transfer(ethshare.mul(1));\n            address(uint160(manager[\"Green_Wolf\"])).transfer(ethshare.mul(2));\n            ethManager = 0;\n\n            uint bonus = getBonus(block.timestamp.div(divdDuration));\n            uint share = bonus.mul(5).div(100);\n            uint dy = block.timestamp.div(divdDuration).sub(adminSharedDate.div(divdDuration));\n            uint totalShare = share.mul(dy);\n            uint loadshare = totalShare.mul(90).div(100).div(100);\n            adminSharedDate = block.timestamp;\n            _transfer(address(this),manager[\"UNI\"],totalShare.div(10));\n            _transfer(address(this),manager[\"Founder\"],loadshare.mul(23));\n            _transfer(address(this),manager[\"Dev\"],loadshare.mul(30));\n            _transfer(address(this),manager[\"Julie\"],loadshare.mul(20));\n            _transfer(address(this),manager[\"Ant\"],loadshare.mul(2));\n            _transfer(address(this),manager[\"Prince\"],loadshare.mul(5));\n            _transfer(address(this),manager[\"Max\"],loadshare.mul(8));\n            _transfer(address(this),manager[\"Soco\"],loadshare.mul(2));\n            _transfer(address(this),manager[\"Tree\"],loadshare.mul(4));\n            _transfer(address(this),manager[\"Zero\"],loadshare.mul(2));\n            _transfer(address(this),manager[\"SK\"],loadshare.mul(1));\n            _transfer(address(this),manager[\"IP_PCS\"],loadshare.mul(1));\n            _transfer(address(this),manager[\"Green_Wolf\"],loadshare.mul(2));\n        }\n\n        function receiveLoad(uint amount) internal {\n            lockload(amount);\n        }\n\n        function lockload(uint amount) internal {\n            uint today = now.div(divdDuration).add(1);\n            locks[msg.sender].load_amount = locks[msg.sender].load_amount.add(amount);\n            locks[msg.sender].unlock_date = now + lockdays;\n            load_lock = load_lock.add(amount);\n\n\n            loadDaily[today].amount = load_lock;\n            loadDaily[today].ischange = true;\n            loadChanges[msg.sender][today].ischange = true;\n            loadChanges[msg.sender][today].amount = locks[msg.sender].load_amount;\n\n\n            if (userDivdDate[msg.sender] == 0) {\n                userDivdDate[msg.sender] = now.div(divdDuration);\n            }\n     \n            addGuess(amount);\n\n            if(!isLocking[msg.sender]){\n                isLocking[msg.sender] = true;\n                users ++;\n            }\n        }\n\n\n        function redeem() external {\n            require(locks[msg.sender].unlock_date < now, \"locking\");\n            uint today = now.div(divdDuration).add(1);\n            uint total = locks[msg.sender].load_amount;\n            load_lock = load_lock.sub(total);\n            locks[msg.sender].load_amount = 0;\n            loadDaily[today].amount = load_lock;\n            loadDaily[today].ischange = true;\n            loadChanges[msg.sender][today].ischange = true;\n            loadChanges[msg.sender][today].amount = 0;\n            isLocking[msg.sender] = false;\n            checkMigrate();\n            if(lastGuessValueToday[msg.sender] == 0){ \n                \n            }else\n            //today first time \n            if(guessCount[msg.sender] == 1 && userGuess[msg.sender][today] !=0 ){\n                oneDay[today][userGuess[msg.sender][today]] =  oneDay[today][userGuess[msg.sender][today]].sub(total);\n            }else {\n                if(userGuess[msg.sender][today] !=0){\n                    //today guessed \n                    twoDays[today][userLastGuessYsd(msg.sender)][lastGuessValueToday[msg.sender]] = twoDays[today][userLastGuessYsd(msg.sender)][lastGuessValueToday[msg.sender]].sub(total);\n                }else{\n                    //today not guessed\n                    twoDays[today][lastGuessValueToday[msg.sender]][lastGuessValueToday[msg.sender]] =twoDays[today][lastGuessValueToday[msg.sender]][lastGuessValueToday[msg.sender]].sub(total);\n                }\n            }\n          \n            if( lastGuessValueToday[msg.sender] != 0){\n                if(guessTotalUsers[lastGuessValueToday[msg.sender]] > 0){\n                    guessTotalUsers[lastGuessValueToday[msg.sender]]--;\n                }\n                userGuess[msg.sender][today] = 0;\n                lastGuessValueToday[msg.sender] = 0;\n            }\n    \n            if(lastGuessValueToday[msg.sender] != 0){\n                guessReduce[today][lastGuessValueToday[msg.sender]]++;\n            }\n            _transfer(address(this), msg.sender, total);\n            if(users >0) {\n                users--;\n            }\n        }\n\n\n        function mosteth() internal view returns (uint mount){\n            uint256 unit_eth = 15000000;\n            uint256 level = exchanged.div(floor_amount).add(1);\n            uint256 remain = level.mul(floor_amount).sub(exchanged);\n            mount = remain.mul(unit_eth.mul(level));\n            level++;\n            for (uint i = level; i <= 4; i++) {\n                mount = mount.add(i.mul(unit_eth).mul(floor_amount));\n            }\n            return mount;\n        }\n\n\n        function exchangeload(uint amounteth) internal returns (uint mount){\n            uint256 unit_eth = 15000000;\n            uint256 level = exchanged.div(floor_amount).add(1);\n            uint256 remain = level.mul(floor_amount).sub(exchanged);\n            if (amounteth > remain.mul(unit_eth.mul(level))) {\n                mount = remain;\n                amounteth = amounteth.sub(remain.mul(unit_eth.mul(level)));\n                level++;\n                load_price = eth_unit.mul(level);\n                for (uint i = level; i <= 4; i++) {\n                    if (amounteth > (unit_eth.mul(i)).mul(floor_amount)) {\n                        mount = mount.add(floor_amount);\n                        amounteth = amounteth.sub(unit_eth.mul(i).mul(floor_amount));\n                    } else {\n                        mount = mount.add(amounteth.div(unit_eth.mul(i)));\n                        break;\n                    }\n                }\n            } else {\n                mount = amounteth.div(unit_eth.mul(level));\n            }\n            return mount;\n\n        }\n\n        function get(uint index) public view returns (uint) {\n            if (index == 1) {\n                return load_price;\n            } else if (index == 2) {\n                return locks[msg.sender].load_amount;\n            } else if (index == 3) {\n                return locks[msg.sender].unlock_date;\n            } else if (index == 6) {\n                return user_load_divs_total[msg.sender];\n            } else if (index == 7) {\n                return user_eth_divs_total[msg.sender];\n            } else if (index == 26) {\n                return exchanged;\n            } else if (index == 29) {\n                return load_price.add(eth_unit);\n            }else if(index == 30) {\n                return load_lock;\n            }else if(index == 31) {\n                return users;\n            }\n        }\n\n\n        function getBonus(uint day) private view returns (uint){\n            uint bonus;\n            uint begin = 200000000000000;\n            uint sang = day.sub(firstDay.div(divdDuration)).div(180);\n            if (sang > 5) {\n                sang = 5;\n            }\n            bonus = begin.div(2 ** sang).div(180);\n            return bonus;\n        }\n\n\n        function getDivdEth() public view returns (uint){\n            uint divAmount;\n            if (userDivdDate[msg.sender] == 0) {\n                return 0;\n            }\n            uint userLockTemp;\n            uint allLockTemp;\n            for (uint j = userDivdDate[msg.sender] + 1; j <= now.div(divdDuration); j++) {\n                if (loadDaily[j].ischange) {\n                    if (loadChanges[msg.sender][j].ischange) {\n                        userLockTemp = loadChanges[msg.sender][j].amount;\n                        if (userLockTemp == 0) {\n                            continue;\n                        }\n                    }\n                    allLockTemp = loadDaily[j].amount;\n                }\n\n                if (ethDaily[j] == 0) {\n                    continue;\n                }\n                divAmount = divAmount.add(ethDaily[j].mul(userLockTemp).div(allLockTemp));\n            }\n            return divAmount;\n        }\n\n\n        function withdraw() external {\n            uint load =getDivdLoad();\n            uint eth = getDivdEth();\n            require(load > 0 || eth > 0, \"no award \");\n            uint today = now.div(divdDuration).add(1);\n            loadDaily[today].amount = load_lock;\n            loadDaily[today].ischange = true;\n            loadChanges[msg.sender][today].ischange = true;\n            loadChanges[msg.sender][today].amount = locks[msg.sender].load_amount;\n            userDivdDate[msg.sender] = setResultLastDay;\n            user_load_divs_total[msg.sender] = user_load_divs_total[msg.sender].add(load);\n            user_eth_divs_total[msg.sender] = user_eth_divs_total[msg.sender].add(eth);\n            _transfer(address(this), msg.sender, load);\n            address(uint160(msg.sender)).transfer(eth);\n            if(!v2first[msg.sender]){\n                v2first[msg.sender] = true;\n            }\n        }\n\n\n\n        mapping(uint => uint) public target;\n        mapping(address => mapping(uint => uint8)) public userGuess; // 1:up    2:down  3.draw   0:default\n        mapping(uint => mapping(uint8 => mapping(uint8 => uint))) public twoDays;\n        mapping(uint => mapping(uint8 => uint)) public oneDay;\n        mapping(uint8 =>uint) public guessTotalUsers;    \n        mapping(address => uint8) public lastGuessValueToday;\n        mapping(uint => bool) public migrate;\n        mapping(address => uint) public guessCount; \n        uint public adminSharedDate;\n        uint public users; //all locked users\n        mapping(uint => mapping(uint8 => uint)) public guessReduce;\n        mapping(address => uint) public lastDateGuess;\n        uint public setResultLastDay;\n        uint public firstDayV2;\n        bool public v2Inited;\n        address public guessAdmin;\n        mapping(address=>bool) public v2first;\n        \n        function initV2() external  {\n            require(v2Inited == false,\"had\");\n            v2Inited = true;\n            adminSharedDate = block.timestamp;\n            firstDayV2 = block.timestamp;\n            managerAddr();\n            \n        }\n\n        function setGuessAdmin(address _account) external onlyOwner {\n            guessAdmin = _account;\n        }\n\n        function guess(uint8 _value) external {\n            require(_value == 1 || _value == 2, \"Can only be one or two\");\n            uint today = block.timestamp.div(divdDuration).add(1);\n            require(userGuess[msg.sender][today] == 0, \"You have guessed today\");\n            require(locks[msg.sender].load_amount > 0,\"no laod\");\n            require(_value != lastGuessValueToday[msg.sender],\"the same value,needn't \");\n        \n            checkMigrate();\n            if (lastGuessValueToday[msg.sender] != 0) {\n                twoDays[today][lastGuessValueToday[msg.sender]][_value] = twoDays[today][lastGuessValueToday[msg.sender]][_value].add(locks[msg.sender].load_amount);\n                twoDays[today][lastGuessValueToday[msg.sender]][lastGuessValueToday[msg.sender]] =  twoDays[today][lastGuessValueToday[msg.sender]][lastGuessValueToday[msg.sender]].sub(locks[msg.sender].load_amount);\n                guessTotalUsers[_value] = guessTotalUsers[_value].add(1); //guesser counter\n                guessTotalUsers[oppositeValue(_value)] = guessTotalUsers[oppositeValue(_value)].sub(1);\n            } else {\n                oneDay[today][_value] = oneDay[today][_value].add(locks[msg.sender].load_amount);\n                guessTotalUsers[_value] = guessTotalUsers[_value].add(1);\n            }\n            userGuess[msg.sender][today] = _value;\n            lastGuessValueToday[msg.sender] = _value;\n            guessCount[msg.sender]++;\n            lastDateGuess[msg.sender] = block.timestamp;\n        }\n\n        function oppositeValue(uint8 _v) private pure returns (uint8){\n            return _v ==1 ?2:1;\n        }\n\n        function addGuess(uint coin) private {\n            uint today = block.timestamp.div(divdDuration).add(1);\n            checkMigrate();\n            if(lastGuessValueToday[msg.sender] == 0){  \n                //do nothing \n            }else\n            //today first time \n            if(guessCount[msg.sender] == 1 && userGuess[msg.sender][today] !=0 ){\n                oneDay[today][userGuess[msg.sender][today]] =  oneDay[today][userGuess[msg.sender][today]].add(coin);\n            }else {\n                if(userGuess[msg.sender][today] !=0){\n                    //today guessed ,\n                    twoDays[today][userLastGuessYsd(msg.sender)][lastGuessValueToday[msg.sender]] = twoDays[today][userLastGuessYsd(msg.sender)][lastGuessValueToday[msg.sender]].add(coin);\n                }else{\n                    //today not guessed\n                    twoDays[today][lastGuessValueToday[msg.sender]][lastGuessValueToday[msg.sender]] =twoDays[today][lastGuessValueToday[msg.sender]][lastGuessValueToday[msg.sender]].add(coin);\n                }\n            }\n                \n        }\n        \n        function checkMigrate() private {\n            uint today = block.timestamp.div(divdDuration).add(1);\n            if(!migrate[today]){\n                migrate[today] = true;\n                uint lastMigrate = lastMigrateDay();\n                twoDays[today][1][1] = twoDays[lastMigrate][2][1].add(twoDays[lastMigrate][1][1].add(oneDay[lastMigrate][1]));\n                twoDays[today][2][2] = twoDays[lastMigrate][2][2].add(twoDays[lastMigrate][1][2].add(oneDay[lastMigrate][2]));\n            }\n        }\n    \n        function userGuess(uint _day) public view returns (uint8) {\n            return userGuess[msg.sender][_day];\n        }\n\n        function lastMigrateDay() public view returns (uint){\n            uint ysd = block.timestamp.div(divdDuration);\n            for(uint i= ysd;i>=firstDayV2.div(divdDuration);i--){\n                if(migrate[i]){\n                    return i;\n                }\n            }\n            return 0;\n        }\n\n        function lastMigrateDayFromDay(uint _day) public view returns (uint){\n            for(uint i= _day;i>=firstDayV2.div(divdDuration);i--){\n                if(migrate[i]){\n                    return i;\n                }\n            }\n            return 0;\n        }\n    \n\n        function userLastGuessYsd(address account) public view returns (uint8) {\n            uint ysd = block.timestamp.div(divdDuration);\n            return userLastGuessFromDay(account,ysd);\n        }\n    \n    \n        function userLastGuessFromDay(address account,uint day) public view returns (uint8) {\n            for(uint i = day;i>=firstDayV2.div(divdDuration);i--){\n                if(userGuess[account][i] !=0){\n                    return userGuess[account][i];\n                }\n            }\n            return 0;\n        }\n\n        function setResult(uint _value, uint _day) external onlyAdmin{\n            checkMigrate();\n            if (_day == 0) {\n                require(target[block.timestamp.div(divdDuration)-1] != 0 || firstDayV2.div(divdDuration) + 1== block.timestamp.div(divdDuration),\"yesterday is not ok\");\n                target[block.timestamp.div(divdDuration)] = _value;\n                setResultLastDay = block.timestamp.div(divdDuration);\n            } else {\n                require(target[_day.div(divdDuration) -1] != 0 || firstDayV2.div(divdDuration) + 1 == _day.div(divdDuration),\"the last day is not ok\");\n                target[_day.div(divdDuration)] = _value;\n                setResultLastDay = _day.div(divdDuration);\n            }\n            \n        }\n\n        function guessByDay(uint _day) public view returns (uint8) {\n            if (target[_day] > target[_day - 1]) {\n                return 1;\n                //up\n            } else if (target[_day] < target[_day - 1]) {\n                return 2;\n                //down\n            } else {\n                return 3;\n                //draw\n            }\n        }\n\n\n         function getDivdLoad() public view returns (uint) {\n             if(userDivdDate[msg.sender] == 0){\n                 return 0;\n             }else {\n                 uint v1 = getDivdLoadV1();\n                 uint fd = userDivdDate[msg.sender] +1 > firstDayV2.div(divdDuration) ? userDivdDate[msg.sender]+1 : firstDayV2.div(divdDuration)+1;\n                 uint v2 = getDivdLoadV2(fd);\n                 return (v1.add(v2));\n             }\n         }\n \n        function getDivdLoadV2(uint fd) private view returns (uint) {\n            uint userLockTemp;\n            uint allLockTemp;\n            uint8 resUser;\n            uint8 resUserYes;\n            uint lastMigrateDayTemp;\n            if (userDivdDate[msg.sender] == 0) {\n                return 0;\n            }\n     \n            for (uint k = fd; k > firstDay.div(divdDuration); k--) { //todo fd-1\n                if (loadDaily[k].ischange) {\n                    if (loadChanges[msg.sender][k].ischange) {\n                        userLockTemp = loadChanges[msg.sender][k].amount;\n                        if (userLockTemp == 0) {\n                            continue;\n                        }\n                    }\n                    allLockTemp = loadDaily[k].amount;\n                }\n            }\n            \n            if(userLockTemp == 0){\n                return 0;\n            }  \n            \n            resUser = userLastGuessFromDay(msg.sender,fd-1);\n            resUserYes = userLastGuessFromDay(msg.sender,fd-2);\n            lastMigrateDayTemp = lastMigrateDayFromDay(fd-1);\n            \n            uint8[2] memory resU;\n            uint[4] memory paramU;\n            resU[0] = resUser;\n            resU[1] = resUserYes;\n            paramU[0] = fd;\n            paramU[1] = userLockTemp;\n            paramU[2] = allLockTemp;\n            paramU[3] = lastMigrateDayTemp;\n            return   loopLoadDivd(resU,paramU);\n        }\n        \n        \n        function loopLoadDivd(uint8[2] memory v,uint[4] memory param) private view returns (uint){\n            uint divAmount;\n            if(!v2first[msg.sender] && userDivdDate[msg.sender] >= firstDayV2.div(divdDuration)){\n                param[0] = param[0]+1;\n            }\n              for (uint dayg = param[0]; dayg <= setResultLastDay; dayg++) {\n                if (loadDaily[dayg - 1].ischange) {\n                    if (loadChanges[msg.sender][dayg - 1].ischange) {\n                        param[1] = loadChanges[msg.sender][dayg - 1].amount;\n                        if (param[1] == 0) {\n                            continue;\n                        }\n                    }\n                    param[2] = loadDaily[dayg - 1].amount;\n                }\n\n                if(param[1] == 0 || param[2] == 0){\n                    continue;\n                }\n                \n                uint bonus = getBonus(dayg);\n                uint8 res = guessByDay(dayg);\n                if(userGuess[msg.sender][dayg-1] != 0){\n                    v[0] = userGuess[msg.sender][dayg-1];\n                }\n                if(userGuess[msg.sender][dayg-2] != 0){\n                    v[1] =userGuess[msg.sender][dayg-2];\n                }\n                \n                if(migrate[dayg-1]){\n                    param[3] = dayg-1;\n                }\n                \n                if (res == 3 || (oneDay[dayg-1][res] == 0 && twoDays[param[3]][1][res] == 0 && twoDays[param[3]][2][res] == 0)) {//average &wrong\n                    divAmount = divAmount.add(bonus.mul(param[1]).mul(95).div(100).div(param[2]));\n                } else if (v[0] != res) {\n                    //wrong\n                    divAmount = divAmount.add(bonus.mul(param[1]).mul(2375).div(10000).div(param[2]));\n                }\n                else {\n                    //right\n                    divAmount = divAmount.add(bonus.mul(param[1]).mul(2375).div(10000).div(param[2]));//zero\n                    \n                    if (twoDays[param[3]][guessByDay(dayg - 1)][res] == 0) {\n                        //no  two days winer\n                        divAmount = divAmount.add(bonus.mul(param[1]).mul(7126).div(10000).div(oneDay[dayg - 1][res].add(twoDays[param[3]][1][res].add(twoDays[param[3]][2][res]))));\n                    } else {\n                        //win twice\n                        if (v[0] == res && v[1] == guessByDay(dayg - 1)) {\n                                divAmount = divAmount.add(bonus.mul(param[1]).mul(2138).div(10000).div(twoDays[param[3]][guessByDay(dayg - 1)][res]));\n                                divAmount = divAmount.add(bonus.mul(param[1]).mul(4988).div(10000).div(oneDay[dayg - 1][res].add(twoDays[param[3]][1][res].add(twoDays[param[3]][2][res]))));\n                            }else{\n                                divAmount = divAmount.add(bonus.mul(param[1]).mul(4988).div(10000).div(oneDay[dayg - 1][res].add(twoDays[param[3]][1][res].add(twoDays[param[3]][2][res]))));\n                            }\n                    }\n                }\n            }\n            return divAmount;\n        }\n\n\n        function getDivdLoadV1()private view  returns (uint) {\n            uint bonus;\n            uint divAmount;\n            uint userLockTemp;\n            uint allLockTemp;\n            if(userDivdDate[msg.sender]==0){\n                return 0;\n            }\n            for(uint j=userDivdDate[msg.sender]+1;j<=firstDayV2.div(divdDuration);j++){\n                if(loadDaily[j].ischange){\n                    if(loadChanges[msg.sender][j].ischange ){\n                        userLockTemp = loadChanges[msg.sender][j].amount;\n                        if(userLockTemp ==0){\n                            continue;\n                        }\n                    }\n                    allLockTemp = loadDaily[j].amount;\n                }\n                bonus = getBonus(j);\n                divAmount = divAmount.add(bonus.mul(userLockTemp).div(allLockTemp));\n            }\n            return divAmount;\n    \n        }\n\n\n        function setUsers(uint _amount) public onlyOwner{\n            users = _amount;\n        }\n    \n        function tenDays() public view returns (uint,uint,uint,uint,uint,uint,uint,uint,uint,uint){\n            uint today = block.timestamp.div(divdDuration);\n            return (target[today],target[today-1],target[today-2],target[today-3],target[today-4],target[today-5],target[today-6],target[today-7],target[today-8],target[today-9]);\n        }\n    \n        function userTenDays() public view returns (uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8,uint8){\n            uint today = block.timestamp.div(divdDuration);\n            return (userLastGuessFromDay(msg.sender,today),\n                userLastGuessFromDay(msg.sender,today-1),\n                userLastGuessFromDay(msg.sender,today-2),\n                userLastGuessFromDay(msg.sender,today-3),\n                userLastGuessFromDay(msg.sender,today-4),\n                userLastGuessFromDay(msg.sender,today-5),\n                userLastGuessFromDay(msg.sender,today-6),\n                userLastGuessFromDay(msg.sender,today-7),\n                userLastGuessFromDay(msg.sender,today-8),\n                userLastGuessFromDay(msg.sender,today-9));\n        }\n    \n        function userTenDaysResult() public view returns (uint[10] memory) {\n            uint today = block.timestamp.div(divdDuration);\n            uint[10] memory v;\n            for(uint i=0;i<10;i++){\n                if(target[today-i] == 0 ){\n                    v[i] = 0;//no result \n                }else {\n                    if(guessByDay(today - i) == userLastGuessFromDay(msg.sender,today -1 -i)){\n                        v[i] = 1;\n                    }else{\n                        if(userLastGuessFromDay(msg.sender,today -1 -i) == 0){\n                            v[i] =0;\n                        }else if(guessByDay(today - i) == 3){\n                              v[i] =1;\n                        }else {\n                            v[i] = 2;\n                        }\n                    }\n                }\n            }\n            return v;\n        }\n    \n        function getAll() public view returns (uint,uint,uint,uint,uint,uint,uint,uint,uint,uint) {\n            uint today = block.timestamp.div(divdDuration).add(1);\n            uint upPercent;\n            uint up = guessTotalUsers[1].sub(guessReduce[today][1]);\n            uint down = guessTotalUsers[2].sub(guessReduce[today][2]);\n            if(up+down >0) {\n                upPercent = up.mul(100).div(up.add(down));\n            }\n            return (load_price,locks[msg.sender].load_amount,locks[msg.sender].unlock_date,user_load_divs_total[msg.sender],user_eth_divs_total[msg.sender],\n                exchanged,load_price.add(eth_unit),load_lock,users,upPercent);\n                    \n        }\n        \n        function managerAddr() private {\n            manager[\"Max\"] = 0x6b148EDF8A534a44A4Ee3058a9F422AeEB918120;\n            manager[\"Soco\"] = 0x7b2c77e13a88081004D0474A29F03338b20F6259;\n            manager[\"Zero\"] = 0x4E1FE0409C2845C1Bde8fcbE21ac6889311c8aB5;\n            manager[\"SK\"] = 0x7E73f65fBcCFAb198BB912d0Db7d70c5fF0c5370;\n            manager[\"Green_Wolf\"] = 0x907f63FEF27EEd047bdd7f55BA39C81DdE9763aB;\n        }\n        \n\n \n     modifier onlyAdmin() {\n         require(msg.sender == guessAdmin,\"not admin\");\n         _;\n     }\n     \n     \n}\n"
    }
  }
}