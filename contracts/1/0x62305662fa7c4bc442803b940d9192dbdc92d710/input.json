{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 0
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "UniswapV2SwapHelper.sol": {
      "content": "// Sources flattened with hardhat v2.6.4 https://hardhat.org\r\n\r\n// File contracts/DAOStackInterfaces.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0;\r\n\r\ninterface Avatar {\r\n\tfunction nativeToken() external view returns (address);\r\n\r\n\tfunction nativeReputation() external view returns (address);\r\n\r\n\tfunction owner() external view returns (address);\r\n}\r\n\r\ninterface Controller {\r\n\tevent RegisterScheme(address indexed _sender, address indexed _scheme);\r\n\tevent UnregisterScheme(address indexed _sender, address indexed _scheme);\r\n\r\n\tfunction genericCall(\r\n\t\taddress _contract,\r\n\t\tbytes calldata _data,\r\n\t\taddress _avatar,\r\n\t\tuint256 _value\r\n\t) external returns (bool, bytes memory);\r\n\r\n\tfunction avatar() external view returns (address);\r\n\r\n\tfunction unregisterScheme(address _scheme, address _avatar)\r\n\t\texternal\r\n\t\treturns (bool);\r\n\r\n\tfunction unregisterSelf(address _avatar) external returns (bool);\r\n\r\n\tfunction registerScheme(\r\n\t\taddress _scheme,\r\n\t\tbytes32 _paramsHash,\r\n\t\tbytes4 _permissions,\r\n\t\taddress _avatar\r\n\t) external returns (bool);\r\n\r\n\tfunction isSchemeRegistered(address _scheme, address _avatar)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (bool);\r\n\r\n\tfunction getSchemePermissions(address _scheme, address _avatar)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (bytes4);\r\n\r\n\tfunction addGlobalConstraint(\r\n\t\taddress _constraint,\r\n\t\tbytes32 _paramHash,\r\n\t\taddress _avatar\r\n\t) external returns (bool);\r\n\r\n\tfunction mintTokens(\r\n\t\tuint256 _amount,\r\n\t\taddress _beneficiary,\r\n\t\taddress _avatar\r\n\t) external returns (bool);\r\n\r\n\tfunction externalTokenTransfer(\r\n\t\taddress _token,\r\n\t\taddress _recipient,\r\n\t\tuint256 _amount,\r\n\t\taddress _avatar\r\n\t) external returns (bool);\r\n\r\n\tfunction sendEther(\r\n\t\tuint256 _amountInWei,\r\n\t\taddress payable _to,\r\n\t\taddress _avatar\r\n\t) external returns (bool);\r\n}\r\n\r\ninterface GlobalConstraintInterface {\r\n\tenum CallPhase {\r\n\t\tPre,\r\n\t\tPost,\r\n\t\tPreAndPost\r\n\t}\r\n\r\n\tfunction pre(\r\n\t\taddress _scheme,\r\n\t\tbytes32 _params,\r\n\t\tbytes32 _method\r\n\t) external returns (bool);\r\n\r\n\t/**\r\n\t * @dev when return if this globalConstraints is pre, post or both.\r\n\t * @return CallPhase enum indication  Pre, Post or PreAndPost.\r\n\t */\r\n\tfunction when() external returns (CallPhase);\r\n}\r\n\r\ninterface ReputationInterface {\r\n\tfunction balanceOf(address _user) external view returns (uint256);\r\n\r\n\tfunction balanceOfAt(address _user, uint256 _blockNumber)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\tfunction getVotes(address _user) external view returns (uint256);\r\n\r\n\tfunction getVotesAt(\r\n\t\taddress _user,\r\n\t\tbool _global,\r\n\t\tuint256 _blockNumber\r\n\t) external view returns (uint256);\r\n\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\tfunction totalSupplyAt(uint256 _blockNumber)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\tfunction delegateOf(address _user) external returns (address);\r\n}\r\n\r\ninterface SchemeRegistrar {\r\n\tfunction proposeScheme(\r\n\t\tAvatar _avatar,\r\n\t\taddress _scheme,\r\n\t\tbytes32 _parametersHash,\r\n\t\tbytes4 _permissions,\r\n\t\tstring memory _descriptionHash\r\n\t) external returns (bytes32);\r\n\r\n\tevent NewSchemeProposal(\r\n\t\taddress indexed _avatar,\r\n\t\tbytes32 indexed _proposalId,\r\n\t\taddress indexed _intVoteInterface,\r\n\t\taddress _scheme,\r\n\t\tbytes32 _parametersHash,\r\n\t\tbytes4 _permissions,\r\n\t\tstring _descriptionHash\r\n\t);\r\n}\r\n\r\ninterface IntVoteInterface {\r\n\tevent NewProposal(\r\n\t\tbytes32 indexed _proposalId,\r\n\t\taddress indexed _organization,\r\n\t\tuint256 _numOfChoices,\r\n\t\taddress _proposer,\r\n\t\tbytes32 _paramsHash\r\n\t);\r\n\r\n\tevent ExecuteProposal(\r\n\t\tbytes32 indexed _proposalId,\r\n\t\taddress indexed _organization,\r\n\t\tuint256 _decision,\r\n\t\tuint256 _totalReputation\r\n\t);\r\n\r\n\tevent VoteProposal(\r\n\t\tbytes32 indexed _proposalId,\r\n\t\taddress indexed _organization,\r\n\t\taddress indexed _voter,\r\n\t\tuint256 _vote,\r\n\t\tuint256 _reputation\r\n\t);\r\n\r\n\tevent CancelProposal(\r\n\t\tbytes32 indexed _proposalId,\r\n\t\taddress indexed _organization\r\n\t);\r\n\tevent CancelVoting(\r\n\t\tbytes32 indexed _proposalId,\r\n\t\taddress indexed _organization,\r\n\t\taddress indexed _voter\r\n\t);\r\n\r\n\t/**\r\n\t * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being\r\n\t * generated by calculating keccak256 of a incremented counter.\r\n\t * @param _numOfChoices number of voting choices\r\n\t * @param _proposalParameters defines the parameters of the voting machine used for this proposal\r\n\t * @param _proposer address\r\n\t * @param _organization address - if this address is zero the msg.sender will be used as the organization address.\r\n\t * @return proposal's id.\r\n\t */\r\n\tfunction propose(\r\n\t\tuint256 _numOfChoices,\r\n\t\tbytes32 _proposalParameters,\r\n\t\taddress _proposer,\r\n\t\taddress _organization\r\n\t) external returns (bytes32);\r\n\r\n\tfunction vote(\r\n\t\tbytes32 _proposalId,\r\n\t\tuint256 _vote,\r\n\t\tuint256 _rep,\r\n\t\taddress _voter\r\n\t) external returns (bool);\r\n\r\n\tfunction cancelVote(bytes32 _proposalId) external;\r\n\r\n\tfunction getNumberOfChoices(bytes32 _proposalId)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\tfunction isVotable(bytes32 _proposalId) external view returns (bool);\r\n\r\n\t/**\r\n\t * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.\r\n\t * @param _proposalId the ID of the proposal\r\n\t * @param _choice the index in the\r\n\t * @return voted reputation for the given choice\r\n\t */\r\n\tfunction voteStatus(bytes32 _proposalId, uint256 _choice)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\t/**\r\n\t * @dev isAbstainAllow returns if the voting machine allow abstain (0)\r\n\t * @return bool true or false\r\n\t */\r\n\tfunction isAbstainAllow() external pure returns (bool);\r\n\r\n\t/**\r\n     * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.\r\n     * @return min - minimum number of choices\r\n               max - maximum number of choices\r\n     */\r\n\tfunction getAllowedRangeOfChoices()\r\n\t\texternal\r\n\t\tpure\r\n\t\treturns (uint256 min, uint256 max);\r\n}\r\n\r\n\r\n// File contracts/utils/DataTypes.sol\r\n\r\n\r\nlibrary DataTypes {\r\n\t// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n\tstruct ReserveData {\r\n\t\t//stores the reserve configuration\r\n\t\tReserveConfigurationMap configuration;\r\n\t\t//the liquidity index. Expressed in ray\r\n\t\tuint128 liquidityIndex;\r\n\t\t//variable borrow index. Expressed in ray\r\n\t\tuint128 variableBorrowIndex;\r\n\t\t//the current supply rate. Expressed in ray\r\n\t\tuint128 currentLiquidityRate;\r\n\t\t//the current variable borrow rate. Expressed in ray\r\n\t\tuint128 currentVariableBorrowRate;\r\n\t\t//the current stable borrow rate. Expressed in ray\r\n\t\tuint128 currentStableBorrowRate;\r\n\t\tuint40 lastUpdateTimestamp;\r\n\t\t//tokens addresses\r\n\t\taddress aTokenAddress;\r\n\t\taddress stableDebtTokenAddress;\r\n\t\taddress variableDebtTokenAddress;\r\n\t\t//address of the interest rate strategy\r\n\t\taddress interestRateStrategyAddress;\r\n\t\t//the id of the reserve. Represents the position in the list of the active reserves\r\n\t\tuint8 id;\r\n\t}\r\n\r\n\tstruct ReserveConfigurationMap {\r\n\t\t//bit 0-15: LTV\r\n\t\t//bit 16-31: Liq. threshold\r\n\t\t//bit 32-47: Liq. bonus\r\n\t\t//bit 48-55: Decimals\r\n\t\t//bit 56: Reserve is active\r\n\t\t//bit 57: reserve is frozen\r\n\t\t//bit 58: borrowing is enabled\r\n\t\t//bit 59: stable rate borrowing enabled\r\n\t\t//bit 60-63: reserved\r\n\t\t//bit 64-79: reserve factor\r\n\t\tuint256 data;\r\n\t}\r\n\tenum InterestRateMode { NONE, STABLE, VARIABLE }\r\n}\r\n\r\n\r\n// File contracts/Interfaces.sol\r\n\r\n\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface ERC20 {\r\n\tfunction balanceOf(address addr) external view returns (uint256);\r\n\r\n\tfunction transfer(address to, uint256 amount) external returns (bool);\r\n\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\tfunction decimals() external view returns (uint8);\r\n\r\n\tfunction mint(address to, uint256 mintAmount) external returns (uint256);\r\n\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\tfunction allowance(address owner, address spender)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n\r\n\tfunction transferFrom(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) external returns (bool);\r\n\r\n\tfunction name() external view returns (string memory);\r\n\r\n\tfunction symbol() external view returns (string memory);\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 amount);\r\n\tevent Transfer(\r\n\t\taddress indexed from,\r\n\t\taddress indexed to,\r\n\t\tuint256 amount,\r\n\t\tbytes data\r\n\t);\r\n}\r\n\r\ninterface cERC20 is ERC20 {\r\n\tfunction mint(uint256 mintAmount) external returns (uint256);\r\n\r\n\tfunction redeemUnderlying(uint256 mintAmount) external returns (uint256);\r\n\r\n\tfunction redeem(uint256 mintAmount) external returns (uint256);\r\n\r\n\tfunction exchangeRateCurrent() external returns (uint256);\r\n\r\n\tfunction exchangeRateStored() external view returns (uint256);\r\n\r\n\tfunction underlying() external returns (address);\r\n}\r\n\r\ninterface IGoodDollar is ERC20 {\r\n\tfunction getFees(uint256 value) external view returns (uint256, bool);\r\n\r\n\tfunction burn(uint256 amount) external;\r\n\r\n\tfunction burnFrom(address account, uint256 amount) external;\r\n\r\n\tfunction renounceMinter() external;\r\n\r\n\tfunction addMinter(address minter) external;\r\n\r\n\tfunction isMinter(address minter) external view returns (bool);\r\n\r\n\tfunction transferAndCall(\r\n\t\taddress to,\r\n\t\tuint256 value,\r\n\t\tbytes calldata data\r\n\t) external returns (bool);\r\n\r\n\tfunction formula() external view returns (address);\r\n}\r\n\r\ninterface IERC2917 is ERC20 {\r\n\t/// @dev This emit when interests amount per block is changed by the owner of the contract.\r\n\t/// It emits with the old interests amount and the new interests amount.\r\n\tevent InterestRatePerBlockChanged(uint256 oldValue, uint256 newValue);\r\n\r\n\t/// @dev This emit when a users' productivity has changed\r\n\t/// It emits with the user's address and the the value after the change.\r\n\tevent ProductivityIncreased(address indexed user, uint256 value);\r\n\r\n\t/// @dev This emit when a users' productivity has changed\r\n\t/// It emits with the user's address and the the value after the change.\r\n\tevent ProductivityDecreased(address indexed user, uint256 value);\r\n\r\n\t/// @dev Return the current contract's interests rate per block.\r\n\t/// @return The amount of interests currently producing per each block.\r\n\tfunction interestsPerBlock() external view returns (uint256);\r\n\r\n\t/// @notice Change the current contract's interests rate.\r\n\t/// @dev Note the best practice will be restrict the gross product provider's contract address to call this.\r\n\t/// @return The true/fase to notice that the value has successfully changed or not, when it succeed, it will emite the InterestRatePerBlockChanged event.\r\n\tfunction changeInterestRatePerBlock(uint256 value) external returns (bool);\r\n\r\n\t/// @notice It will get the productivity of given user.\r\n\t/// @dev it will return 0 if user has no productivity proved in the contract.\r\n\t/// @return user's productivity and overall productivity.\r\n\tfunction getProductivity(address user)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256, uint256);\r\n\r\n\t/// @notice increase a user's productivity.\r\n\t/// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\r\n\t/// @return true to confirm that the productivity added success.\r\n\tfunction increaseProductivity(address user, uint256 value)\r\n\t\texternal\r\n\t\treturns (bool);\r\n\r\n\t/// @notice decrease a user's productivity.\r\n\t/// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\r\n\t/// @return true to confirm that the productivity removed success.\r\n\tfunction decreaseProductivity(address user, uint256 value)\r\n\t\texternal\r\n\t\treturns (bool);\r\n\r\n\t/// @notice take() will return the interests that callee will get at current block height.\r\n\t/// @dev it will always calculated by block.number, so it will change when block height changes.\r\n\t/// @return amount of the interests that user are able to mint() at current block height.\r\n\tfunction take() external view returns (uint256);\r\n\r\n\t/// @notice similar to take(), but with the block height joined to calculate return.\r\n\t/// @dev for instance, it returns (_amount, _block), which means at block height _block, the callee has accumulated _amount of interests.\r\n\t/// @return amount of interests and the block height.\r\n\tfunction takeWithBlock() external view returns (uint256, uint256);\r\n\r\n\t/// @notice mint the avaiable interests to callee.\r\n\t/// @dev once it mint, the amount of interests will transfer to callee's address.\r\n\t/// @return the amount of interests minted.\r\n\tfunction mint() external returns (uint256);\r\n}\r\n\r\ninterface Staking {\r\n\tstruct Staker {\r\n\t\t// The staked DAI amount\r\n\t\tuint256 stakedDAI;\r\n\t\t// The latest block number which the\r\n\t\t// staker has staked tokens\r\n\t\tuint256 lastStake;\r\n\t}\r\n\r\n\tfunction stakeDAI(uint256 amount) external;\r\n\r\n\tfunction withdrawStake() external;\r\n\r\n\tfunction stakers(address staker) external view returns (Staker memory);\r\n}\r\n\r\ninterface Uniswap {\r\n\tfunction swapExactETHForTokens(\r\n\t\tuint256 amountOutMin,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint256 deadline\r\n\t) external payable returns (uint256[] memory amounts);\r\n\r\n\tfunction swapExactTokensForETH(\r\n\t\tuint256 amountIn,\r\n\t\tuint256 amountOutMin,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint256 deadline\r\n\t) external returns (uint256[] memory amounts);\r\n\r\n\tfunction swapExactTokensForTokens(\r\n\t\tuint256 amountIn,\r\n\t\tuint256 amountOutMin,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint256 deadline\r\n\t) external returns (uint256[] memory amounts);\r\n\r\n\tfunction WETH() external pure returns (address);\r\n\r\n\tfunction factory() external pure returns (address);\r\n\r\n\tfunction quote(\r\n\t\tuint256 amountA,\r\n\t\tuint256 reserveA,\r\n\t\tuint256 reserveB\r\n\t) external pure returns (uint256 amountB);\r\n\r\n\tfunction getAmountIn(\r\n\t\tuint256 amountOut,\r\n\t\tuint256 reserveIn,\r\n\t\tuint256 reserveOut\r\n\t) external pure returns (uint256 amountIn);\r\n\r\n\tfunction getAmountOut(\r\n\t\tuint256 amountI,\r\n\t\tuint256 reserveIn,\r\n\t\tuint256 reserveOut\r\n\t) external pure returns (uint256 amountOut);\r\n\r\n\tfunction getAmountsOut(uint256 amountIn, address[] memory path)\r\n\t\texternal\r\n\t\tpure\r\n\t\treturns (uint256[] memory amounts);\r\n}\r\n\r\ninterface UniswapFactory {\r\n\tfunction getPair(address tokenA, address tokenB)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (address);\r\n}\r\n\r\ninterface UniswapPair {\r\n\tfunction getReserves()\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint112 reserve0,\r\n\t\t\tuint112 reserve1,\r\n\t\t\tuint32 blockTimestampLast\r\n\t\t);\r\n\r\n\tfunction kLast() external view returns (uint256);\r\n\r\n\tfunction token0() external view returns (address);\r\n\r\n\tfunction token1() external view returns (address);\r\n\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\tfunction balanceOf(address owner) external view returns (uint256);\r\n}\r\n\r\ninterface Reserve {\r\n\tfunction buy(\r\n\t\taddress _buyWith,\r\n\t\tuint256 _tokenAmount,\r\n\t\tuint256 _minReturn\r\n\t) external returns (uint256);\r\n}\r\n\r\ninterface IIdentity {\r\n\tfunction isWhitelisted(address user) external view returns (bool);\r\n\r\n\tfunction addWhitelistedWithDID(address account, string memory did) external;\r\n\r\n\tfunction removeWhitelisted(address account) external;\r\n\r\n\tfunction addIdentityAdmin(address account) external returns (bool);\r\n\r\n\tfunction setAvatar(address _avatar) external;\r\n\r\n\tfunction isIdentityAdmin(address account) external view returns (bool);\r\n\r\n\tfunction owner() external view returns (address);\r\n\r\n\tevent WhitelistedAdded(address user);\r\n}\r\n\r\ninterface IUBIScheme {\r\n\tfunction currentDay() external view returns (uint256);\r\n\r\n\tfunction periodStart() external view returns (uint256);\r\n\r\n\tfunction hasClaimed(address claimer) external view returns (bool);\r\n}\r\n\r\ninterface IFirstClaimPool {\r\n\tfunction awardUser(address user) external returns (uint256);\r\n\r\n\tfunction claimAmount() external view returns (uint256);\r\n}\r\n\r\ninterface ProxyAdmin {\r\n\tfunction getProxyImplementation(address proxy)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (address);\r\n\r\n\tfunction getProxyAdmin(address proxy) external view returns (address);\r\n\r\n\tfunction upgrade(address proxy, address implementation) external;\r\n\r\n\tfunction owner() external view returns (address);\r\n\r\n\tfunction transferOwnership(address newOwner) external;\r\n}\r\n\r\n/**\r\n * @dev Interface for chainlink oracles to obtain price datas\r\n */\r\ninterface AggregatorV3Interface {\r\n\tfunction decimals() external view returns (uint8);\r\n\r\n\tfunction description() external view returns (string memory);\r\n\r\n\tfunction version() external view returns (uint256);\r\n\r\n\t// getRoundData and latestRoundData should both raise \"No data present\"\r\n\t// if they do not have data to report, instead of returning unset values\r\n\t// which could be misinterpreted as actual reported values.\r\n\tfunction getRoundData(uint80 _roundId)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint80 roundId,\r\n\t\t\tint256 answer,\r\n\t\t\tuint256 startedAt,\r\n\t\t\tuint256 updatedAt,\r\n\t\t\tuint80 answeredInRound\r\n\t\t);\r\n\r\n\tfunction latestAnswer() external view returns (int256);\r\n}\r\n\r\n/**\r\n\t@dev interface for AAVE lending Pool\r\n */\r\ninterface ILendingPool {\r\n\t/**\r\n\t * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n\t * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n\t * @param asset The address of the underlying asset to deposit\r\n\t * @param amount The amount to be deposited\r\n\t * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n\t *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n\t *   is a different wallet\r\n\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n\t *   0 if the action is executed directly by the user, without any middle-man\r\n\t **/\r\n\tfunction deposit(\r\n\t\taddress asset,\r\n\t\tuint256 amount,\r\n\t\taddress onBehalfOf,\r\n\t\tuint16 referralCode\r\n\t) external;\r\n\r\n\t/**\r\n\t * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n\t * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n\t * @param asset The address of the underlying asset to withdraw\r\n\t * @param amount The underlying amount to be withdrawn\r\n\t *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n\t * @param to Address that will receive the underlying, same as msg.sender if the user\r\n\t *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n\t *   different wallet\r\n\t * @return The final amount withdrawn\r\n\t **/\r\n\tfunction withdraw(\r\n\t\taddress asset,\r\n\t\tuint256 amount,\r\n\t\taddress to\r\n\t) external returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Returns the state and configuration of the reserve\r\n\t * @param asset The address of the underlying asset of the reserve\r\n\t * @return The state of the reserve\r\n\t **/\r\n\tfunction getReserveData(address asset)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (DataTypes.ReserveData memory);\r\n}\r\n\r\ninterface IDonationStaking {\r\n\tfunction stakeDonations() external payable;\r\n}\r\n\r\ninterface INameService {\r\n\tfunction getAddress(string memory _name) external view returns (address);\r\n}\r\n\r\ninterface IAaveIncentivesController {\r\n\t/**\r\n\t * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\r\n\t * @param amount Amount of rewards to claim\r\n\t * @param to Address that will be receiving the rewards\r\n\t * @return Rewards claimed\r\n\t **/\r\n\tfunction claimRewards(\r\n\t\taddress[] calldata assets,\r\n\t\tuint256 amount,\r\n\t\taddress to\r\n\t) external returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Returns the total of rewards of an user, already accrued + not yet accrued\r\n\t * @param user The address of the user\r\n\t * @return The rewards\r\n\t **/\r\n\tfunction getRewardsBalance(address[] calldata assets, address user)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256);\r\n}\r\n\r\ninterface IGoodStaking {\r\n\tfunction collectUBIInterest(address recipient)\r\n\t\texternal\r\n\t\treturns (\r\n\t\t\tuint256,\r\n\t\t\tuint256,\r\n\t\t\tuint256\r\n\t\t);\r\n\r\n\tfunction iToken() external view returns (address);\r\n\r\n\tfunction currentGains(\r\n\t\tbool _returnTokenBalanceInUSD,\r\n\t\tbool _returnTokenGainsInUSD\r\n\t)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint256,\r\n\t\t\tuint256,\r\n\t\t\tuint256,\r\n\t\t\tuint256,\r\n\t\t\tuint256\r\n\t\t);\r\n\r\n\tfunction getRewardEarned(address user) external view returns (uint256);\r\n\r\n\tfunction getGasCostForInterestTransfer() external view returns (uint256);\r\n\r\n\tfunction rewardsMinted(\r\n\t\taddress user,\r\n\t\tuint256 rewardsPerBlock,\r\n\t\tuint256 blockStart,\r\n\t\tuint256 blockEnd\r\n\t) external returns (uint256);\r\n}\r\n\r\ninterface IHasRouter {\r\n\tfunction getRouter() external view returns (Uniswap);\r\n}\r\n\r\ninterface IAdminWallet {\r\n\tfunction addAdmins(address payable[] memory _admins) external;\r\n\r\n\tfunction removeAdmins(address[] memory _admins) external;\r\n\r\n\tfunction owner() external view returns (address);\r\n\r\n\tfunction transferOwnership(address _owner) external;\r\n}\r\n\r\n\r\n// File contracts/utils/DAOContract.sol\r\n\r\n\r\n\r\n\r\n/**\r\n@title Simple contract that keeps DAO contracts registery\r\n*/\r\n\r\ncontract DAOContract {\r\n\tController public dao;\r\n\r\n\taddress public avatar;\r\n\r\n\tINameService public nameService;\r\n\r\n\tfunction _onlyAvatar() internal view {\r\n\t\trequire(\r\n\t\t\taddress(dao.avatar()) == msg.sender,\r\n\t\t\t\"only avatar can call this method\"\r\n\t\t);\r\n\t}\r\n\r\n\tfunction setDAO(INameService _ns) internal {\r\n\t\tnameService = _ns;\r\n\t\tupdateAvatar();\r\n\t}\r\n\r\n\tfunction updateAvatar() public {\r\n\t\tdao = Controller(nameService.getAddress(\"CONTROLLER\"));\r\n\t\tavatar = dao.avatar();\r\n\t}\r\n\r\n\tfunction nativeToken() public view returns (IGoodDollar) {\r\n\t\treturn IGoodDollar(nameService.getAddress(\"GOODDOLLAR\"));\r\n\t}\r\n\r\n\tuint256[50] private gap;\r\n}\r\n\r\n\r\n// File contracts/staking/UniswapV2SwapHelper.sol\r\n\r\n\r\n\r\n\r\nlibrary UniswapV2SwapHelper {\r\n\t/**\r\n\t *@dev Helper to calculate percentage out of token liquidity in pool that is safe to exchange against sandwich attack.\r\n\t * also checks if token->eth has better safe limit, so perhaps doing tokenA->eth->tokenB is better than tokenA->tokenB\r\n\t * in that case it could be that eth->tokenB can be attacked because we dont know if eth received for tokenA->eth is less than _maxPercentage of the liquidity in\r\n\t * eth->tokenB. In our use case it is always eth->dai so either it will be safe or very minimal\r\n\t *@param _inToken address of token we are swapping\r\n\t *@param _outToken address of swap result token\r\n\t *@param _inTokenAmount amount of in token required to swap\r\n\t *@param _maxLiquidityPercentageSwap max percentage of liquidity to swap to token\r\n\t * when swapping tokens and this value is out of 100000 so for example if you want to set it to 0.3 you need set it to 300\r\n\t */\r\n\tfunction maxSafeTokenAmount(\r\n\t\tIHasRouter _iHasRouter,\r\n\t\taddress _inToken,\r\n\t\taddress _outToken,\r\n\t\tuint256 _inTokenAmount,\r\n\t\tuint256 _maxLiquidityPercentageSwap\r\n\t) public view returns (uint256 safeAmount) {\r\n\t\tUniswap uniswap = _iHasRouter.getRouter();\r\n\t\taddress wETH = uniswap.WETH();\r\n\t\t_inToken = _inToken == address(0x0) ? wETH : _inToken;\r\n\t\t_outToken = _outToken == address(0x0) ? wETH : _outToken;\r\n\t\tUniswapPair pair = UniswapPair(\r\n\t\t\tUniswapFactory(uniswap.factory()).getPair(_inToken, _outToken)\r\n\t\t);\r\n\t\t(uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\r\n\t\tuint112 reserve = reserve0;\r\n\t\tif (_inToken == pair.token1()) {\r\n\t\t\treserve = reserve1;\r\n\t\t}\r\n\r\n\t\tsafeAmount = (reserve * _maxLiquidityPercentageSwap) / 100000;\r\n\r\n\t\treturn safeAmount < _inTokenAmount ? safeAmount : _inTokenAmount;\r\n\t}\r\n\r\n\t/**\r\n\t@dev Helper to swap tokens in the Uniswap\r\n\t*@param _path the buy path\r\n\t*@param _tokenAmount token amount to swap\r\n\t*@param _minTokenReturn minimum token amount to get in swap transaction\r\n\t*@param _receiver receiver of tokens after swap transaction\r\n    *\r\n\t */\r\n\tfunction swap(\r\n\t\tIHasRouter _iHasRouter,\r\n\t\taddress[] memory _path,\r\n\t\tuint256 _tokenAmount,\r\n\t\tuint256 _minTokenReturn,\r\n\t\taddress _receiver\r\n\t) internal returns (uint256 swapResult) {\r\n\t\tUniswap uniswapContract = _iHasRouter.getRouter();\r\n\t\tuint256[] memory result;\r\n\r\n\t\tif (_path[0] == address(0x0)) {\r\n\t\t\t_path[0] = uniswapContract.WETH();\r\n\t\t\tresult = uniswapContract.swapExactETHForTokens{ value: _tokenAmount }(\r\n\t\t\t\t_minTokenReturn,\r\n\t\t\t\t_path,\r\n\t\t\t\t_receiver,\r\n\t\t\t\tblock.timestamp\r\n\t\t\t);\r\n\t\t} else if (_path[_path.length - 1] == address(0x0)) {\r\n\t\t\t_path[_path.length - 1] = uniswapContract.WETH();\r\n\t\t\tresult = uniswapContract.swapExactTokensForETH(\r\n\t\t\t\t_tokenAmount,\r\n\t\t\t\t_minTokenReturn,\r\n\t\t\t\t_path,\r\n\t\t\t\t_receiver,\r\n\t\t\t\tblock.timestamp\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tresult = uniswapContract.swapExactTokensForTokens(\r\n\t\t\t\t_tokenAmount,\r\n\t\t\t\t_minTokenReturn,\r\n\t\t\t\t_path,\r\n\t\t\t\t_receiver,\r\n\t\t\t\tblock.timestamp\r\n\t\t\t);\r\n\t\t}\r\n\t\treturn result[result.length - 1];\r\n\t}\r\n}"
    }
  }
}