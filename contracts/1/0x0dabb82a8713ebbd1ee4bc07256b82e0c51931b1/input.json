{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "genesisSale.sol": {
      "content": "// SPDX-License-Identifier: NO-LICENSE\npragma solidity <=0.7.4;\n\nabstract contract ReentrancyGuard {\n\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\nlibrary SafeMath {\n    \n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b > 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n}\n\n\ninterface IGenesisSale {\n\n    function purchase(address _reciever) external payable returns(bool); \n\n    function allocate(uint256 _tokens, address _user, uint256 _method) external returns(bool);\n\n    function reduceAllocation(uint256 _tokens, address _user) external returns(bool);\n\n    function fetchPurchaseHistory(address _user) external view returns(uint256[] memory, uint256[] memory);\n\n    function revokeOwnership(address _newOwner) external returns(bool);\n\n    function claim() external returns(bool);\n\n    function whitelist(address _user) external returns(bool);\n\n    function updateCap(uint256 _minCap, uint256 _maxCap) external returns(bool);\n\n    function lockDistribution(bool _state) external returns(bool);\n\n    function updateGovernor(address _newGovernor) external returns(bool);\n\n    function updateContract(address _contract) external returns(bool);\n\n    function updateEthSource(address _ethSource) external returns(bool);\n\n    function updateEthWallet(address _newEthWallet) external returns(bool);\n\n    function updateOrgWallet(address _newOrgWallet) external returns(bool);\n\n    function updatePresalePrice(uint256 _newPrice) external returns(bool);\n\n    function drain(address _to, uint256 _amount) external returns(bool);\n\n}\n\ninterface IERC20 {\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n}\n\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\ninterface IWhiteListOracle {\n\n    function whitelist(address _user) external returns(bool);\n\n    function blacklist(address _user) external returns(bool);\n\n    function transferGovernor(address _newGovernor) external returns(bool);\n\n    function whitelisted(address _user) external view returns(bool);\n\n}\n\ncontract GenesisSale is ReentrancyGuard {\n    \n    address public organisation;\n    address payable public ethWallet;\n    address public governor;\n    address public admin;\n\n    address public edgexContract;\n    address public ethPriceSource;\n    address public whitelistOracle;\n\n    uint256 public presalePrice;   // $1 = 100000000 - 8 precision\n\n    uint256 public maxCap;\n    uint256 public minCap;\n    \n    bool public locked;\n    \n    struct History{\n        uint256[] timestamps;\n        uint256[] amounts;\n        uint256[] paymentMethod;\n        uint256[] price;\n    }\n    \n    mapping(address => uint256) public allocated;\n    mapping(address => uint256) public purchased;\n    mapping(address => History) private history;\n\n    event Purchase(address indexed to, uint256 amount);\n    event UpdatePrice(uint256 _price);\n    event UpdateGovernor(address indexed _governor);\n    event RevokeOwnership(address indexed _newOwner);\n    /**\n     * contract address of edgex token & price oracle to be passed as an argument to constructor\n    */\n    \n    constructor(\n        address _ethWallet, \n        address _organisation,\n        address _governor,\n        address _admin,\n        address _ethSource,\n        address _whitelistOracle,\n        address _edgexContract,\n        uint256 _presalePrice\n        )\n    {\n        organisation = _organisation;\n        ethWallet = payable(_ethWallet);\n        governor = _governor;\n        whitelistOracle = _whitelistOracle;\n        admin = _admin;\n        edgexContract = _edgexContract;\n        ethPriceSource = _ethSource;\n        presalePrice = _presalePrice;\n    }\n    \n\n    modifier onlyAdmin(){\n        require(msg.sender == admin,\"Caller not admin\");\n        _;\n    }\n    \n    modifier onlyGovernor(){\n        require(msg.sender == governor, \"Caller not Governor\");\n        _;\n    }\n\n    modifier isZero(address _address){\n        require(_address != address(0),\"Invalid Address\");\n        _;\n    }\n\n    function isWhitelisted(address _user) public virtual view returns(bool){\n        return IWhiteListOracle(whitelistOracle).whitelisted(_user);\n    }\n    \n    function purchase(address _reciever) public  payable nonReentrant returns(bool){\n        uint256 tokens = calculate(msg.value);\n        require(tokens >= minCap,\"ValueError\");\n        require(tokens <= maxCap,\"ValueError\");\n        require(isWhitelisted(_reciever),\"Address not verified\");\n        purchased[_reciever] = SafeMath.add(purchased[_reciever],tokens);\n        if(locked){\n            allocated[_reciever] = SafeMath.add(allocated[_reciever],tokens);\n            ethWallet.transfer(msg.value);\n        }\n        else{\n            IERC20(edgexContract).transfer( _reciever,tokens);\n            IERC20(edgexContract).transfer(\n                organisation,\n                SafeMath.div(tokens,100)\n            );\n            ethWallet.transfer(msg.value);\n        }\n        History storage h = history[_reciever];\n        h.timestamps.push(block.timestamp);\n        h.amounts.push(tokens);\n        h.price.push(presalePrice);\n        emit Purchase(_reciever,tokens);\n        return true;\n    }\n    \n    /**\n     * Used for calculate the amount of tokens purchased\n     * returns an uint256 which is 18 decimals of precision\n     * Equivalent amount of EDGX Tokens to be transferred.\n    */\n    \n    function calculate(uint256 _amount) private view returns(uint256){\n        uint256 value = uint256(fetchEthPrice());\n                value = SafeMath.mul(_amount,value);\n        uint256 tokens = SafeMath.div(value,presalePrice);\n        return tokens;\n    }\n    \n    /**\n     * Used to allocated tokens for purchase through other methods\n     * Send the amount to be allocated as 18 decimals\n    */\n    \n    function allocate(uint256 _tokens,address _user, uint256 _method) public onlyGovernor nonReentrant returns(bool){\n        require(_tokens >= minCap,\"ValueError\");\n        require(_tokens <= maxCap,\"ValueError\");\n        if(locked){\n          allocated[_user] = SafeMath.add(allocated[_user],_tokens);\n          purchased[_user] = SafeMath.add(purchased[_user],_tokens);\n        }\n        else { \n            IERC20(edgexContract).transfer(_user,_tokens);\n            IERC20(edgexContract).transfer(\n                organisation,\n                SafeMath.div(_tokens,100)\n            );\n        }\n        History storage h = history[_user];\n        h.timestamps.push(block.timestamp);\n        h.amounts.push(_tokens);\n        h.price.push(presalePrice);\n        h.paymentMethod.push(_method);\n        emit Purchase(_user,_tokens);\n        return true;\n    }\n    \n    /**\n     * Reduce allocated tokens of an user from the user\"s allocated value\n    */\n    \n    function reduceAllocation(uint256 _tokens, address _user) public onlyAdmin returns(bool){\n        allocated[_user] = SafeMath.sub(allocated[_user],_tokens);\n        return true;\n    }\n    \n    /**\n     * Used to transfer pre-sale tokens for other payment options\n    */\n    \n    function fetchPurchaseHistory(address _user) \n        public view \n        returns(\n            uint256[] memory _timestamp, \n            uint256[] memory _amounts\n        )\n    {\n        History storage h = history[_user];\n        return(h.timestamps,h.amounts);\n    }\n    \n\n     /**\n        @dev changing the admin of the oracle\n        Warning : Admin can add governor, remove governor\n                  and can update price.\n     */\n\n    function revokeOwnership(address _newOwner) public onlyAdmin isZero(_newOwner) returns(bool){\n        admin = payable(_newOwner);\n        emit RevokeOwnership(_newOwner);\n        return true;\n    }\n    \n    /**\n     * @dev withdraw the tokens from the contract by the user \n    */\n    \n    function claim() public nonReentrant returns(bool){\n        require(!locked, \"Sale Locked\");\n        require(allocated[msg.sender]>0, \"No Tokens Allocated\");\n        uint256 transferAmount = allocated[msg.sender];\n        allocated[msg.sender] = 0;\n        IERC20(edgexContract).transfer(msg.sender,transferAmount);\n        IERC20(edgexContract).transfer(\n            organisation,\n            SafeMath.div(transferAmount,100)\n            );\n        return true;\n    } \n\n    /**\n     * @dev fetches the price of Ethereum from chainlink oracle \n     */\n\n    function fetchEthPrice() public view returns (int) {\n        (\n            uint80 roundID, \n            int price,\n            uint startedAt,\n            uint timeStamp,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(ethPriceSource).latestRoundData();\n        return price;\n    }\n    \n    /**\n      * @dev update the max and min cap\n     */\n    function updateCap(uint256 _minCap, uint256 _maxCap) public onlyGovernor returns(bool){\n        maxCap = _maxCap;\n        minCap = _minCap;\n        return false;\n    }\n\n    function lockDistribution(bool _state) public onlyGovernor returns(bool){\n        locked = _state;\n        return true;\n    }\n    \n    function updateGovernor(address _newGovernor) public onlyGovernor isZero(_newGovernor) returns(bool){\n        governor = _newGovernor;\n        emit UpdateGovernor(_newGovernor);\n        return true;\n    }\n\n\n    function updateContract(address _contract) public onlyAdmin isZero(_contract) returns(bool){\n        edgexContract = _contract;\n        return true;\n    }\n\n    function updateEthSource(address _ethSource) public onlyAdmin isZero(_ethSource) returns(bool){\n        ethPriceSource = _ethSource;\n        return true;\n    }\n    \n    function updateEthWallet(address _newEthWallet) public onlyAdmin isZero(_newEthWallet) returns(bool){\n        ethWallet = payable(_newEthWallet);\n        return true;\n    }\n    \n    function updateOrgWallet(address _newOrgWallet) public onlyAdmin isZero(_newOrgWallet) returns(bool){\n        organisation = _newOrgWallet;\n        return true;\n    }\n    \n    function updatePresalePrice(uint256 _newPrice) public onlyAdmin returns(bool){\n        presalePrice = _newPrice;\n        emit UpdatePrice(_newPrice);\n        return true;\n    }\n\n    function updateWhiteListOracle(address _newOracle) public onlyAdmin isZero(_newOracle) returns(bool){\n        whitelistOracle = _newOracle;\n        return true;\n    }\n    \n    function drain(address _to, uint256 _amount) public onlyAdmin isZero(_to) returns(bool){\n        IERC20(edgexContract).transfer(_to,_amount);\n        return true;\n    }\n\n}\n"
    }
  }
}