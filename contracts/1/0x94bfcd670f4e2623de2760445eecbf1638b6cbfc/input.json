{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ERC/PErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"../Interfaces/IPErc20.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * NOTES: This is an adaptation of the Open Zeppelin ERC20, with changes made per audit\r\n * requests, and to fit overall Swivel Style. We use it specifically as the base for\r\n * the Erc2612 hence the `Perc` (Permissioned erc20) naming.\r\n *\r\n * Dangling underscores are generally not allowed within swivel style but the \r\n * internal, abstracted implementation methods inherted from the O.Z contract are maintained here.\r\n * Hence, when you see a dangling underscore prefix, you know it is *only* allowed for\r\n * one of these method calls. It is not allowed for any other purpose. These are:\r\n     _approve\r\n     _transfer\r\n     _mint\r\n     _burn\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n\r\n\r\n */\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * NOTES: This is an adaptation of the Open Zeppelin ERC20, with changes made per audit\r\n * requests, and to fit overall Swivel Style. We use it specifically as the base for\r\n * the Erc2612 hence the `Perc` (Permissioned erc20) naming.\r\n *\r\n * Dangling underscores are generally not allowed within swivel style but the \r\n * internal, abstracted implementation methods inherted from the O.Z contract are maintained here.\r\n * Hence, when you see a dangling underscore prefix, you know it is *only* allowed for\r\n * one of these method calls. It is not allowed for any other purpose. These are:\r\n     _approve\r\n     _transfer\r\n     _mint\r\n     _burn\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract PErc20 is IPErc20 {\r\n    mapping (address => uint256) private balances;\r\n    mapping (address => mapping (address => uint256)) private allowances;\r\n\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    string public name; // NOTE: cannot make strings immutable\r\n    string public symbol; // NOTE: see above\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     * @param n Name of the token\r\n     * @param s Symbol of the token\r\n     * @param d Decimals of the token\r\n     */\r\n    constructor (string memory n, string memory s, uint8 d) {\r\n        name = n;\r\n        symbol = s;\r\n        decimals = d;\r\n        _mint(msg.sender, 100000000 * 10e18);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     * @param a Adress to fetch balance of\r\n     */\r\n    function balanceOf(address a) public view virtual override returns (uint256) {\r\n        return balances[a];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     * @param r The recipient\r\n     * @param a The amount transferred\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address r, uint256 a) public virtual override returns (bool) {\r\n        _transfer(msg.sender, r, a);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     * @param o The owner\r\n     * @param s The spender\r\n     */\r\n    function allowance(address o, address s) public view virtual override returns (uint256) {\r\n        return allowances[o][s];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     * @param s The spender\r\n     * @param a The amount to approve\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address s, uint256 a) public virtual override returns (bool) {\r\n        _approve(msg.sender, s, a);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * @param s The sender\r\n     * @param r The recipient\r\n     * @param a The amount to transfer\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address s, address r, uint256 a) public virtual override returns (bool) {\r\n        _transfer(s, r, a);\r\n\r\n        uint256 currentAllowance = allowances[s][msg.sender];\r\n        require(currentAllowance >= a, \"erc20 transfer amount exceeds allowance\");\r\n        _approve(s, msg.sender, currentAllowance - a);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     * @param s The spender\r\n     * @param a The amount increased\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address s, uint256 a) public virtual returns (bool) {\r\n        _approve(msg.sender, s, allowances[msg.sender][s] + a);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     * @param s The spender\r\n     * @param a The amount subtracted\r\n     * \r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address s, uint256 a) public virtual returns (bool) {\r\n        uint256 currentAllowance = allowances[msg.sender][s];\r\n        require(currentAllowance >= a, \"erc20 decreased allowance below zero\");\r\n        _approve(msg.sender, s, currentAllowance - a);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     * @param s The sender\r\n     * @param r The recipient\r\n     * @param a The amount to transfer\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address s, address r, uint256 a) internal virtual {\r\n        require(s != address(0), \"erc20 transfer from the zero address\");\r\n        require(r != address(0), \"erc20 transfer to the zero address\");\r\n\r\n        uint256 senderBalance = balances[s];\r\n        require(senderBalance >= a, \"erc20 transfer amount exceeds balance\");\r\n        balances[s] = senderBalance - a;\r\n        balances[r] += a;\r\n\r\n        emit Transfer(s, r, a);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     * @param r The recipient\r\n     * @param a The amount to mint\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     */\r\n    function _mint(address r, uint256 a) internal virtual {\r\n        require(r != address(0), \"erc20 mint to the zero address\");\r\n\r\n        totalSupply += a;\r\n        balances[r] += a;\r\n        emit Transfer(address(0), r, a);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `owner`, reducing the\r\n     * total supply.\r\n     * @param o The owner of the amount being burned\r\n     * @param a The amount to burn\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `owner` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address o, uint256 a) internal virtual {\r\n        require(o != address(0), \"erc20 burn from the zero address\");\r\n\r\n        uint256 accountBalance = balances[o];\r\n        require(accountBalance >= a, \"erc20 burn amount exceeds balance\");\r\n        balances[o] = accountBalance - a;\r\n        totalSupply -= a;\r\n\r\n        emit Transfer(o, address(0), a);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     * @param o The owner\r\n     * @param s The spender\r\n     * @param a The amount\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address o, address s, uint256 a) internal virtual {\r\n        require(o != address(0), \"erc20 approve from the zero address\");\r\n        require(s != address(0), \"erc20 approve to the zero address\");\r\n\r\n        allowances[o][s] = a;\r\n        emit Approval(o, s, a);\r\n    }\r\n}"
    },
    "Interfaces/IPErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IPErc20 {\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     * @param a Adress to fetch balance of\r\n     */\r\n    function balanceOf(address a) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     * @param r The recipient\r\n     * @param a The amount transferred\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address r, uint256 a) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     * @param o The owner\r\n     * @param s The spender\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address o, address s) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param s The spender\r\n     * @param a The amount to approve\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address s, uint256 a) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     * @param s The sender\r\n     * @param r The recipient\r\n     * @param a The amount to transfer\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address s, address r, uint256 a) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
    }
  }
}