{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"GamingChickNest.sol":{"content":"// File: @openzeppelin\\contracts\\utils\\Strings.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: contracts\\OwnableContract.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract OwnableContract {\r\n    address public owner;\r\n    address public pendingOwner;\r\n    address public admin;\r\n    address public dev;\r\n\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n    event NewDev(address oldDev, address newDev);\r\n    event NewOwner(address oldOwner, address newOwner);\r\n    event NewPendingOwner(address oldPendingOwner, address newPendingOwner);\r\n\r\n    constructor(){\r\n        owner = msg.sender;\r\n        admin = msg.sender;\r\n        dev   = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner,\"onlyOwner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPendingOwner {\r\n        require(msg.sender == pendingOwner,\"onlyPendingOwner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin || msg.sender == owner,\"onlyAdmin\");\r\n        _;\r\n    } \r\n\r\n    modifier onlyDev {\r\n        require(msg.sender == dev  || msg.sender == owner,\"onlyDev\");\r\n        _;\r\n    } \r\n    \r\n    function transferOwnership(address _pendingOwner) public onlyOwner {\r\n        emit NewPendingOwner(pendingOwner, _pendingOwner);\r\n        pendingOwner = _pendingOwner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit NewOwner(owner, address(0));\r\n        emit NewAdmin(admin, address(0));\r\n        emit NewPendingOwner(pendingOwner, address(0));\r\n\r\n        owner = address(0);\r\n        pendingOwner = address(0);\r\n        admin = address(0);\r\n    }\r\n    \r\n    function acceptOwner() public onlyPendingOwner {\r\n        emit NewOwner(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n\r\n        address newPendingOwner = address(0);\r\n        emit NewPendingOwner(pendingOwner, newPendingOwner);\r\n        pendingOwner = newPendingOwner;\r\n    }    \r\n    \r\n    function setAdmin(address newAdmin) public onlyOwner {\r\n        emit NewAdmin(admin, newAdmin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    function setDev(address newDev) public onlyOwner {\r\n        emit NewDev(dev, newDev);\r\n        dev = newDev;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts\\GamingChickNest.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\ninterface HeadPortrait721Interface{\r\n\r\n    struct Attribute{\r\n        uint32 background;\r\n        uint32 skinColor;\r\n        uint32 clothes;\r\n        uint32 hatBack;\r\n        uint32 beak;\r\n        uint32 hatFront;\r\n        uint32 eyes;\r\n        uint32 front;\r\n        uint256 reserve;\r\n    }\r\n    \r\n    function mint(address user, uint256 tokenId, Attribute memory attribute) external;\r\n}\r\n\r\ncontract GamingChickNest is OwnableContract{\r\n\r\n    using Strings for uint256;\r\n\r\n    address public headPortrait721;\r\n\r\n    address public signer1;\r\n    address public signer2;\r\n\r\n    uint16 public tokenId = 1006;\r\n    \r\n    uint256 public aleadyClaimCount = 0;\r\n    uint256 public maxClaimCount = 20;\r\n\r\n    bool public isUseTokenIdRandom = true;\r\n\r\n    uint32[] public clothes = [1000100,1000200,1000300,1000400,1000500,1011100,1011200,1011300,1011400,1011500,1012100,1012200,1012300,1012400,1012500,1013100,1013200,1013300,1013400,1013500,1014100,1014200,1014300,1014400,1014500,1015100,1015200,1015300,1015400,1015500,1021100,1021200,1021300,1021400,1021500,1022100,1022200,1022300,1022400,1022500,1023100,1023200,1023300,1023400,1023500,1024100,1024200,1024300,1024400,1024500,1025100,1025200,1025300,1025400,1025500,1031100,1031200,1031300,1031400,1031500,1041100,1041200,1041300,1041400,1041500,1042100,1042200,1042300,1042400,1042500,1043100,1043200,1043300,1043400,1043500,1044100,1044200,1044300,1044400,1044500,1045100,1045200,1045300,1045400,1045500,1051100,1051200,1051300,1051400,1051500,1052100,1052200,1052300,1052400,1052500,1053100,1053200,1053300,1053400,1053500,1054100,1054200,1054300,1054400,1054500,1055100,1055200,1055300,1055400,1055500,1061100,1061200,1061300,1061400,1061500,1062100,1062200,1062300,1062400,1062500,1063100,1063200,1063300,1063400,1063500,1064100,1064200,1064300,1064400,1064500,1065100,1065200,1065300,1065400,1065500,1071100,1071200,1071300,1071400,1071500,1072100,1072200,1072300,1072400,1072500,1073100,1073200,1073300,1073400,1073500,1074100,1074200,1074300,1074400,1074500,1075100,1075200,1075300,1075400,1075500,1081100,1081200,1081300,1081400,1081500,1082100,1082200,1082300,1082400,1082500,1083100,1083200,1083300,1083400,1083500,1084100,1084200,1084300,1084400,1084500,1085100,1085200,1085300,1085400,1085500,1091100,1091200,1091300,1091400,1091500,1092100,1092200,1092300,1092400,1092500,1093100,1093200,1093300,1093400,1093500,1094100,1094200,1094300,1094400,1094500,1095100,1095200,1095300,1095400,1095500,1101100,1101200,1101300,1101400,1101500,1102100,1102200,1102300,1102400,1102500,1103100,1103200,1103300,1103400,1103500,1104100,1104200,1104300,1104400,1104500,1105100,1105200,1105300,1105400,1105500,1111101,1111201,1111301,1111401,1111501,1112101,1112201,1112301,1112401,1112501,1113101,1113201,1113301,1113401,1113501,1114101,1114201,1114301,1114401,1114501,1115101,1115201,1115301,1115401,1115501,1121100,1121200,1121300,1121400,1121500,1122100,1122200,1122300,1122400,1122500,1123100,1123200,1123300,1123400,1123500,1124100,1124200,1124300,1124400,1124500,1125100,1125200,1125300,1125400,1125500,1131100,1131200,1131300,1131400,1131500,1132100,1132200,1132300,1132400,1132500,1133100,1133200,1133300,1133400,1133500,1134100,1134200,1134300,1134400,1134500,1135100,1135200,1135300,1135400,1135500,1141100,1141200,1141300,1141400,1141500,1142100,1142200,1142300,1142400,1142500,1143100,1143200,1143300,1143400,1143500,1144100,1144200,1144300,1144400,1144500,1145100,1145200,1145300,1145400,1145500];\r\n\r\n    mapping(uint256 => bool) public claimedOrderId;\r\n\r\n    uint8 public partColorCount = 5;\r\n    uint8 public skinColorCount = 5;\r\n\r\n    uint32[] public bgs = [1,2,3,4,5,6];\r\n\r\n    mapping(uint32 => uint32) public rarityProbabilityTotalMap;\r\n    mapping(uint32 => uint32[]) public rareNumberMap;\r\n    mapping(uint32 => uint32[]) public probabilityMap;\r\n\r\n    // ****************** FRONT ******************\r\n    uint32[] public frontArray = [702,703,704,705];\r\n    mapping(uint32 => uint32) public specialFrontMap;\r\n    mapping(uint32 => bool) public skinColorAndPartColorFrontMap;\r\n    // ****************** FRONT END ******************\r\n\r\n    // ****************** HAT FRONT ******************\r\n    uint32[] public hatFrontArray = [501,502,503,504,505,506,507,508,509,510,511,512,513];\r\n    mapping(uint32 => bool) public skinColorAndPartColorHatFrontMap;\r\n    mapping(uint32 => bool) public onlyPartColorHatFrontMap;\r\n    // ****************** HAT FRONT END ******************\r\n\r\n    // ****************** HAT BACK ******************\r\n    mapping(uint32 => bool) public skinColorAndPartColorHatBackMap;\r\n    // ****************** HAT BACK END ******************\r\n\r\n    // ****************** Head = SkinColor ******************\r\n    uint32[] public skinColorArray = [301];\r\n    // ****************** Head = SkinColor END ******************\r\n\r\n    // ****************** BEAK ******************\r\n    uint32[] public beakArray = [401,402,403,404,405,407,410,411,412];\r\n    mapping(uint32 => bool) public isDependentHatFront;\r\n    mapping(uint32 => bool) public skinColorAndPartColorBeakMap;\r\n    // ****************** BEAK END ******************\r\n\r\n    // ****************** EYES ******************\r\n    uint32[] public eyesArray = [601,602,603,604,605,606,608,609,610,611,613,614,616,618];\r\n    mapping(uint32 => bool) public skinColorAndPartColorEyesMap;\r\n    // ****************** EYES END ******************\r\n\r\n    event Claim(uint256 orderId, uint256 tokenId, address user);\r\n    event AleadyClaim(uint256 orderId, uint256 tokenId, address user);\r\n\r\n    constructor(address _headPortrait721){\r\n        headPortrait721 = _headPortrait721;\r\n        signer1 = address(0xd5F6cfca09240650Af7c4E46E7337cDA495fDfd7);\r\n        signer2 = signer1;\r\n\r\n        rarityProbabilityTotalMap[0] = 50;\r\n        rarityProbabilityTotalMap[4] = 80;\r\n        rarityProbabilityTotalMap[6] = 100;\r\n\r\n        rareNumberMap[0] = [7,8,9,10];\r\n        rareNumberMap[4] = [406,408,409];\r\n        rareNumberMap[6] = [607,612,615,617];\r\n\r\n        probabilityMap[0] = [50,200,600,1000];\r\n        probabilityMap[4] = [50,550,1000];\r\n        probabilityMap[6] = [250,450,650,1000];\r\n\r\n        specialFrontMap[111] = 701;\r\n\r\n        skinColorAndPartColorFrontMap[703] = true;\r\n\r\n        skinColorAndPartColorHatFrontMap[510] = true;\r\n\r\n        skinColorAndPartColorHatBackMap[205] = true;\r\n\r\n        onlyPartColorHatFrontMap[504] = true;\r\n        onlyPartColorHatFrontMap[507] = true;\r\n        onlyPartColorHatFrontMap[509] = true;\r\n        onlyPartColorHatFrontMap[513] = true;\r\n\r\n        isDependentHatFront[501] = true;\r\n        isDependentHatFront[502] = true;\r\n        isDependentHatFront[503] = true;\r\n        isDependentHatFront[505] = true;\r\n        isDependentHatFront[506] = true;\r\n        isDependentHatFront[508] = true;\r\n        isDependentHatFront[510] = true;\r\n        isDependentHatFront[511] = true;\r\n        isDependentHatFront[512] = true;\r\n        isDependentHatFront[703] = true;\r\n\r\n        skinColorAndPartColorBeakMap[401] = true;\r\n        skinColorAndPartColorBeakMap[403] = true;\r\n        skinColorAndPartColorBeakMap[404] = true;\r\n\r\n        skinColorAndPartColorEyesMap[615] = true;\r\n        skinColorAndPartColorEyesMap[617] = true;\r\n    }\r\n\r\n    function updateTokenId(uint16 _tokenId) public onlyAdmin{\r\n        tokenId = _tokenId;\r\n    }\r\n\r\n    function updateMaxClaimCount(uint256 _maxClaimCount) public onlyAdmin{\r\n        maxClaimCount = _maxClaimCount;\r\n    }\r\n\r\n    function initClothes(uint32[] memory _clothes) public onlyAdmin{\r\n        clothes = _clothes;\r\n    }\r\n\r\n    function updateClothes(uint32 _clothes) public onlyAdmin{\r\n        clothes.push(_clothes);\r\n    }\r\n\r\n    function updateIsUseTokenIdRandom(bool _isUseTokenIdRandom) public onlyAdmin{\r\n        isUseTokenIdRandom = _isUseTokenIdRandom;\r\n    }\r\n\r\n    function setSigner1(address _signer) public onlyOwner{\r\n        signer1 = _signer;\r\n    }\r\n\r\n    function setSigner2(address _signer) public onlyOwner{\r\n        signer2 = _signer;\r\n    }\r\n\r\n    function updateHeadPortrait721(address _headPortrait721) public onlyAdmin{\r\n        headPortrait721 = _headPortrait721;\r\n    }\r\n\r\n    function getOrderIdIsClaim(uint256[] memory orderId) public view returns(uint256[] memory){\r\n        uint256[] memory unconfirmedOrderId = new uint256[](orderId.length);\r\n        uint256 count = 0;\r\n        for(uint256 i=0; i<orderId.length; i++){\r\n            if(!claimedOrderId[orderId[i]]){\r\n                unconfirmedOrderId[count] = orderId[i];\r\n                count++;\r\n            }\r\n        }\r\n        return unconfirmedOrderId;\r\n    }\r\n\r\n    function batchClaim(uint256[] memory orderId, uint256[] memory tokenIds, bytes[] memory signature) public{\r\n        require(aleadyClaimCount + orderId.length <= maxClaimCount, \"Maximum claims exceeded.\");\r\n        require(orderId.length == tokenIds.length, \"orderId length should eq floatAmount length\");\r\n        require(orderId.length == signature.length, \"orderId length should eq signature length\");\r\n        for(uint256 i=0; i<orderId.length; i++){\r\n            claim(orderId[i], tokenIds[i], signature[i]);\r\n        }\r\n    }\r\n\r\n    function claim(uint256 orderId, uint256 _tokenId, bytes memory signature) internal{\r\n        if(claimedOrderId[orderId]){\r\n            emit AleadyClaim(orderId, tokenId, msg.sender);\r\n            return;\r\n        }\r\n    \r\n        bytes32 hash1 = keccak256(abi.encode(address(this), msg.sender, orderId, _tokenId));\r\n\r\n        bytes32 hash2 = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash1));\r\n\r\n        address _signer = recover(hash2, signature);\r\n        require(_signer == signer1 || _signer == signer2, \"invalid signer\");\r\n\r\n        uint256 nftTokenId;\r\n        if(_tokenId == 0){\r\n            nftTokenId = tokenId;\r\n            tokenId++;\r\n        }else{\r\n            require(0 < _tokenId && _tokenId <= 1000, \"_tokenId is error.\");\r\n            nftTokenId = _tokenId;\r\n        }\r\n\r\n        HeadPortrait721Interface.Attribute memory attribute = getAttributes(nftTokenId);\r\n        HeadPortrait721Interface headPortrait721Interface = HeadPortrait721Interface(headPortrait721);\r\n        headPortrait721Interface.mint(msg.sender, nftTokenId, attribute);\r\n\r\n        claimedOrderId[orderId] = true;\r\n\r\n        emit Claim(orderId, nftTokenId, msg.sender);\r\n\r\n        aleadyClaimCount++;\r\n    }\r\n\r\n    function claimOfAdmin(address user, uint256 _tokenId) public onlyAdmin{\r\n        require(_tokenId <= 1000, \"_tokenId is error.\");\r\n        HeadPortrait721Interface.Attribute memory attribute = getAttributes(_tokenId);\r\n        HeadPortrait721Interface headPortrait721Interface = HeadPortrait721Interface(headPortrait721);\r\n        headPortrait721Interface.mint(user, _tokenId, attribute);\r\n\r\n        emit Claim(0, tokenId, user);\r\n    }\r\n\r\n    function updatePartColorCount(uint8 _partColorCount) public onlyAdmin{\r\n        partColorCount = _partColorCount;\r\n    }\r\n\r\n    function updateSkinColorCount(uint8 _skinColorCount) public onlyAdmin{\r\n        skinColorCount = _skinColorCount;\r\n    }\r\n\r\n    function updateRarityProbabilityTotalMap(uint32 a, uint32 b) public onlyAdmin{\r\n        rarityProbabilityTotalMap[a] = b;\r\n    }\r\n\r\n    function updateRareNumberMap(uint32 a, uint32[] memory b) public onlyAdmin{\r\n        rareNumberMap[a] = b;\r\n    }\r\n\r\n    function updateProbabilityMap(uint32 a, uint32[] memory b) public onlyAdmin{\r\n        probabilityMap[a] = b;\r\n    }\r\n\r\n    function updateArray(uint8 index, uint32[] memory data) public onlyAdmin{\r\n        if(index == 1){\r\n            bgs = data;\r\n        }else if(index == 2){\r\n            frontArray = data;\r\n        }else if(index == 3){\r\n            hatFrontArray = data;\r\n        }else if(index == 4){\r\n            skinColorArray = data;\r\n        }else if(index == 5){\r\n            beakArray = data;\r\n        }else if(index == 6){\r\n            eyesArray = data;\r\n        }\r\n    }\r\n\r\n    function updateSpecialFrontMap(uint32 a, uint32 b) public onlyAdmin{\r\n        specialFrontMap[a] = b;\r\n    }\r\n\r\n    function updateMap(uint8 index, uint32 a, bool b) public onlyAdmin{\r\n        if(index == 1){\r\n            skinColorAndPartColorFrontMap[a] = b;\r\n        }else if(index == 2){\r\n            skinColorAndPartColorHatFrontMap[a] = b;\r\n        }else if(index == 3){\r\n            isDependentHatFront[a] = b;\r\n        }else if(index == 4){\r\n            skinColorAndPartColorBeakMap[a] = b;\r\n        }else if(index == 5){\r\n            skinColorAndPartColorEyesMap[a] = b;\r\n        }\r\n    }\r\n\r\n    function getAttributes(uint256 _tokenId) public view returns(HeadPortrait721Interface.Attribute memory attribute){\r\n        uint256 random = getRandom(_tokenId);\r\n\r\n        // background\r\n        uint256 backgroundRarity = rarityProbabilityTotalMap[0];\r\n        random = uint256(keccak256(abi.encode(random, 1)));\r\n        uint256 bgsRandom = random % 1000;\r\n        if(backgroundRarity != 0 && bgsRandom < backgroundRarity){\r\n            random = uint256(keccak256(abi.encode(random, 2)));\r\n            uint256 bgsIndex2 = random % 1000;\r\n            for(uint256 i=0; i<probabilityMap[0].length; i++){\r\n                if(bgsIndex2 < probabilityMap[0][i]){\r\n                    attribute.background = rareNumberMap[0][i];\r\n                    break;\r\n                }\r\n            }\r\n        }else{\r\n            random = uint256(keccak256(abi.encode(random, 3)));\r\n            uint256 bgsIndex2 = random % bgs.length;\r\n            attribute.background = bgs[uint32(bgsIndex2)];\r\n        }\r\n\r\n        // Clothes = Body\r\n        random = uint256(keccak256(abi.encode(random, 4)));\r\n        uint256 clothesIndex = random % clothes.length;\r\n        uint32 _clothes = clothes[uint32(clothesIndex)];\r\n        attribute.clothes = _clothes;\r\n\r\n        // 1113501 desc\r\n        uint32 one = _clothes % 10;                 // 1 hatFront、hatBack || Front\r\n        uint32 three = _clothes / 100 % 10;         // 5 head = skincolor\r\n        uint32 four = _clothes / 1000 % 10;         // 3 part color\r\n\r\n        // Head = SkinColor\r\n        random = uint256(keccak256(abi.encode(random, 11)));\r\n        attribute.skinColor = skinColorArray[uint32(random % skinColorArray.length)] * 10000 + three * 100;\r\n\r\n        if(one == 0){\r\n            random = uint256(keccak256(abi.encode(random, 5)));\r\n            uint256 frontOrHatFront = random % 2;\r\n            if(frontOrHatFront == 0){ // FRONT\r\n                random = uint256(keccak256(abi.encode(random, 6)));\r\n                if(skinColorAndPartColorFrontMap[frontArray[random % frontArray.length]]){\r\n                    attribute.front = frontArray[uint32(random % frontArray.length)] * 100000 + uint32(random % partColorCount + 1) * 10000 + three * 1000;\r\n                }else{\r\n                    attribute.front = frontArray[uint32(random % frontArray.length)] * 100000 + uint32(random % partColorCount + 1) * 10000;\r\n                }\r\n            }else{ // HATFRONT\r\n                random = uint256(keccak256(abi.encode(random, 8)));\r\n                uint256 hatFrontIndex = random % hatFrontArray.length;\r\n                random = uint256(keccak256(abi.encode(random, 9)));\r\n                uint256 partIndex = random % partColorCount + 1;\r\n                if(skinColorAndPartColorHatFrontMap[hatFrontArray[uint32(hatFrontIndex)]]){\r\n                    random = uint256(keccak256(abi.encode(random, 10)));\r\n                    uint256 skinIndex = random % skinColorCount + 1;\r\n                    attribute.hatFront = hatFrontArray[uint32(hatFrontIndex)] * 10000 + uint32(partIndex) * 1000 + uint32(skinIndex) * 100;\r\n                }else{\r\n                    if(onlyPartColorHatFrontMap[hatFrontArray[uint32(hatFrontIndex)]]){\r\n                        attribute.hatFront = hatFrontArray[uint32(hatFrontIndex)] * 10000 + uint32(partIndex) * 1000;\r\n                    }else{\r\n                        attribute.hatFront = hatFrontArray[uint32(hatFrontIndex)] * 10000 + uint32(partIndex) * 100;\r\n                    }\r\n                }\r\n                // 501\r\n                uint32 _one = hatFrontArray[hatFrontIndex] % 10;         // 1   \r\n                uint32 _two = hatFrontArray[hatFrontIndex] / 10 % 10;    // 0\r\n                if(skinColorAndPartColorHatBackMap[2 * 100 + _two * 10 + _one]){\r\n                    attribute.hatBack = 2 * 1000000 + _two * 100000 + _one * 10000 + uint32(partIndex) * 1000 + (attribute.hatFront / 100 % 10) * 100;\r\n                }else{\r\n                    attribute.hatBack = 2 * 1000000 + _two * 100000 + _one * 10000 + uint32(partIndex) * 1000;\r\n                }\r\n            }\r\n        }else{\r\n            uint32 _key = (_clothes / 1000000 % 10) * 100 + (_clothes / 100000 % 10) * 10 + (_clothes / 10000 % 10);\r\n            if(specialFrontMap[_key] != 0){\r\n                attribute.front = specialFrontMap[_key] * 100000 + four * 10000 + _key;\r\n            }else{\r\n                random = uint256(keccak256(abi.encode(random, 6)));\r\n                uint256 frontIndex = random % frontArray.length;\r\n                random = uint256(keccak256(abi.encode(random, 7)));\r\n                uint256 partIndex = random % partColorCount + 1;\r\n                if(skinColorAndPartColorFrontMap[frontArray[frontIndex]]){\r\n                    attribute.front = frontArray[uint32(frontIndex)] * 100000 + uint32(partIndex) * 10000 + three * 1000;\r\n                }else{\r\n                    attribute.front = frontArray[uint32(frontIndex)] * 100000 + uint32(partIndex) * 10000;\r\n                }\r\n            }\r\n        }\r\n        // BEAK\r\n        uint32 key = 0;\r\n        uint32 hatFrontOrFrontLastThird = 0;\r\n        if(attribute.hatFront != 0){\r\n            hatFrontOrFrontLastThird = attribute.hatFront / 100 % 10;\r\n            key = (attribute.hatFront / 1000000 % 10) * 100 + (attribute.hatFront / 100000 % 10) * 10 + (attribute.hatFront / 10000 % 10);\r\n        }else{\r\n            if(skinColorAndPartColorFrontMap[attribute.front / 100000]){\r\n                hatFrontOrFrontLastThird = attribute.front / 1000 % 10;\r\n                key = (attribute.front / 10000000 % 10) * 100 + (attribute.front / 1000000 % 10) * 10 + (attribute.front / 100000 % 10);\r\n            }\r\n        }\r\n\r\n        uint256 beakRarity = rarityProbabilityTotalMap[4];\r\n        random = uint256(keccak256(abi.encode(random, 12)));\r\n        if(beakRarity != 0 && (random % 1000) < backgroundRarity){\r\n            random = uint256(keccak256(abi.encode(random, 13)));\r\n            uint32 beakTopThree = 0;\r\n            for(uint256 i=0; i<probabilityMap[4].length; i++){\r\n                if((random % 1000) < probabilityMap[4][i]){\r\n                    beakTopThree = rareNumberMap[4][i];\r\n                    break;\r\n                }\r\n            }\r\n            if(skinColorAndPartColorBeakMap[beakTopThree]){\r\n                if((attribute.hatFront != 0 || attribute.front != 0) && isDependentHatFront[key]){\r\n                    attribute.beak = beakTopThree * 10000 + hatFrontOrFrontLastThird * 1000 + three * 100;\r\n                }else{\r\n                    random = uint256(keccak256(abi.encode(random, 14)));\r\n                    attribute.beak = beakTopThree * 10000 + uint32(random % partColorCount + 1) * 1000 + three * 100;\r\n                }\r\n            }else{\r\n                if((attribute.hatFront != 0 || attribute.front != 0) && isDependentHatFront[key]){\r\n                    attribute.beak = beakTopThree * 10000 + hatFrontOrFrontLastThird * 1000;\r\n                }else{\r\n                    random = uint256(keccak256(abi.encode(random, 14)));\r\n                    attribute.beak = beakTopThree * 10000 + uint32(random % partColorCount + 1) * 1000;\r\n                }\r\n            }\r\n        }else{\r\n            random = uint256(keccak256(abi.encode(random, 15)));\r\n            uint32 beakNumber = beakArray[uint32(random % beakArray.length)];\r\n            if(skinColorAndPartColorBeakMap[beakNumber]){\r\n                if((attribute.hatFront != 0 || attribute.front != 0) && isDependentHatFront[key]){\r\n                    attribute.beak = beakNumber * 10000 + hatFrontOrFrontLastThird * 1000 + three * 100;\r\n                }else{\r\n                    random = uint256(keccak256(abi.encode(random, 16)));\r\n                    attribute.beak = beakNumber * 10000 + uint32(random % partColorCount + 1) * 1000 + three * 100;\r\n                }\r\n            }else{\r\n                if((attribute.hatFront != 0 || attribute.front != 0) && isDependentHatFront[key]){\r\n                    attribute.beak = beakNumber * 10000 + hatFrontOrFrontLastThird * 1000;\r\n                }else{\r\n                    random = uint256(keccak256(abi.encode(random, 16)));\r\n                    attribute.beak = beakNumber * 10000 + uint32(random % partColorCount + 1) * 1000;\r\n                }\r\n            }\r\n        }\r\n        // EYES\r\n        uint256 eyesRarity = rarityProbabilityTotalMap[6];\r\n        random = uint256(keccak256(abi.encode(random, 17)));\r\n        if(eyesRarity != 0 && (random % 1000) < backgroundRarity){\r\n            random = uint256(keccak256(abi.encode(random, 18)));\r\n            uint32 eyesTopThree = 0;\r\n            for(uint256 i=0; i<probabilityMap[6].length; i++){\r\n                if((random % 1000) < probabilityMap[6][i]){\r\n                    eyesTopThree = rareNumberMap[6][i];\r\n                    if((eyesTopThree == 607 && ((attribute.hatFront / 10000) == 503 || (attribute.hatFront / 10000) == 513 || (attribute.hatFront / 10000) == 505 || (attribute.hatFront / 10000) == 504))){\r\n                        continue;\r\n                    }else if((eyesTopThree == 617 && ((attribute.hatFront / 10000) == 504 || (attribute.hatFront / 10000) == 513 || (attribute.hatFront / 10000) == 507 || (attribute.front / 100000) == 702 || (attribute.front / 100000) == 703))){\r\n                        eyesTopThree = 612;\r\n                        break;\r\n                    }else{\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if(skinColorAndPartColorEyesMap[eyesTopThree]){\r\n                random = uint256(keccak256(abi.encode(random, 19)));\r\n                attribute.eyes = uint32(eyesTopThree) * 10000 + uint32(random % partColorCount + 1) * 1000 + three * 100;\r\n            }else{\r\n                attribute.eyes = uint32(eyesTopThree) * 10000 + three * 100;\r\n            }\r\n        }else{\r\n            random = uint256(keccak256(abi.encode(random, 20)));\r\n            uint256 eyesIndex = random % eyesArray.length;\r\n            if(skinColorAndPartColorEyesMap[eyesArray[uint32(eyesIndex)]]){\r\n                random = uint256(keccak256(abi.encode(random, 21)));\r\n                attribute.eyes = eyesArray[uint32(eyesIndex)] * 10000 + uint32(random % partColorCount + 1) * 1000 + three * 100;\r\n            }else{\r\n                attribute.eyes = eyesArray[uint32(eyesIndex)] * 10000 + three * 100;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getRandom(uint256 _tokenId) public view returns(uint256){\r\n        uint256 random;\r\n        if(isUseTokenIdRandom){\r\n            random = uint256(keccak256(abi.encodePacked(_tokenId)));\r\n        }else{\r\n            random = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.coinbase))) + block.timestamp + _tokenId;\r\n        }\r\n        return random;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        return recover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\r\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n}"}}}