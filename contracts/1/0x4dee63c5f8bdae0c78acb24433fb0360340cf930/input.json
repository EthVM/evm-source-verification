{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"NFTMarketplace.sol":{"content":"pragma solidity 0.6.2;\r\n\r\n\r\n\r\n/**\r\n * @dev The contract has an owner address, and provides basic authorization control whitch\r\n * simplifies the implementation of user permissions. This contract is based on the source code at:\r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\r\n */\r\ncontract Ownable\r\n{\r\n\r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string public constant NOT_CURRENT_OWNER = \"018001\";\r\n  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = \"018002\";\r\n\r\n  /**\r\n   * @dev Current owner address.\r\n   */\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev An event which is triggered when the owner is changed.\r\n   * @param previousOwner The address of the previous owner.\r\n   * @param newOwner The address of the new owner.\r\n   */\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The constructor sets the original `owner` of the contract to the sender account.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner()\r\n  {\r\n    require(msg.sender == owner, NOT_CURRENT_OWNER);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(\r\n    address _newOwner\r\n  )\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Math operations with safety checks that throw on error. This contract is based on the\r\n * source code at:\r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol.\r\n */\r\nlibrary SafeMath\r\n{\r\n  /**\r\n   * List of revert message codes. Implementing dApp should handle showing the correct message.\r\n   * Based on 0xcert framework error codes.\r\n   */\r\n  string constant OVERFLOW = \"008001\";\r\n  string constant SUBTRAHEND_GREATER_THEN_MINUEND = \"008002\";\r\n  string constant DIVISION_BY_ZERO = \"008003\";\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, reverts on overflow.\r\n   * @param _factor1 Factor number.\r\n   * @param _factor2 Factor number.\r\n   * @return product The product of the two factors.\r\n   */\r\n  function mul(\r\n    uint256 _factor1,\r\n    uint256 _factor2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 product)\r\n  {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_factor1 == 0)\r\n    {\r\n      return 0;\r\n    }\r\n\r\n    product = _factor1 * _factor2;\r\n    require(product / _factor1 == _factor2, OVERFLOW);\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient, reverts on division by zero.\r\n   * @param _dividend Dividend number.\r\n   * @param _divisor Divisor number.\r\n   * @return quotient The quotient.\r\n   */\r\n  function div(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 quotient)\r\n  {\r\n    // Solidity automatically asserts when dividing by 0, using all gas.\r\n    require(_divisor > 0, DIVISION_BY_ZERO);\r\n    quotient = _dividend / _divisor;\r\n    // assert(_dividend == _divisor * quotient + _dividend % _divisor); // There is no case in which this doesn't hold.\r\n  }\r\n\r\n  /**\r\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   * @param _minuend Minuend number.\r\n   * @param _subtrahend Subtrahend number.\r\n   * @return difference Difference.\r\n   */\r\n  function sub(\r\n    uint256 _minuend,\r\n    uint256 _subtrahend\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 difference)\r\n  {\r\n    require(_subtrahend <= _minuend, SUBTRAHEND_GREATER_THEN_MINUEND);\r\n    difference = _minuend - _subtrahend;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, reverts on overflow.\r\n   * @param _addend1 Number.\r\n   * @param _addend2 Number.\r\n   * @return sum Sum.\r\n   */\r\n  function add(\r\n    uint256 _addend1,\r\n    uint256 _addend2\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 sum)\r\n  {\r\n    sum = _addend1 + _addend2;\r\n    require(sum >= _addend1, OVERFLOW);\r\n  }\r\n\r\n  /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo), reverts when\r\n    * dividing by zero.\r\n    * @param _dividend Number.\r\n    * @param _divisor Number.\r\n    * @return remainder Remainder.\r\n    */\r\n  function mod(\r\n    uint256 _dividend,\r\n    uint256 _divisor\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256 remainder)\r\n  {\r\n    require(_divisor != 0, DIVISION_BY_ZERO);\r\n    remainder = _dividend % _divisor;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @dev signature of external (deployed) contract (ERC20 token)\r\n * only methods we will use, needed for us to communicate with CYTR token (which is ERC20)\r\n */\r\ncontract ERC20Token {\r\n \r\n    function totalSupply() external view returns (uint256){}\r\n    function balanceOf(address account) external view returns (uint256){}\r\n    function allowance(address owner, address spender) external view returns (uint256){}\r\n    function transfer(address recipient, uint256 amount) external returns (bool){}\r\n    function approve(address spender, uint256 amount) external returns (bool){}\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool){}\r\n    function decimals()  external view returns (uint8){}\r\n  \r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev signature of external (deployed) contract for NFT publishing (ERC721)\r\n * only methods we will use, needed for us to communicate with Cyclops token (which is ERC721)\r\n */\r\ncontract CyclopsTokens {\r\n    \r\n \r\n \r\n function mint(address _to, uint256 _tokenId, string calldata _uri) external {}\r\n \r\n function ownerOf(uint256 _tokenId) external view returns (address) {}\r\n function burn(uint256 _tokenId) external {}\r\n \r\n function tokenURI(uint256 _tokenId) external  view returns(string memory) {}\r\n    \r\n}\r\n\r\ncontract NFTMarketplace is\r\n  Ownable\r\n{\r\n    using SafeMath for uint256;    \r\n    \r\n     modifier onlyPriceManager() {\r\n      require(\r\n          msg.sender == price_manager,\r\n          \"only price manager can call this function\"\r\n          );\r\n          _;\r\n    }\r\n    \r\n    modifier onlyOwnerOrPriceManager() {\r\n      require(\r\n          msg.sender == price_manager || msg.sender == owner,\r\n          \"only price manager or owner can call this function\"\r\n          );\r\n          _;\r\n    }\r\n \r\n    /**\r\n    * @dev not bullet-proof check, but additional measure, actually we require specific (contract) address,\r\n    * which is key (see onlyBankContract)\r\n    */\r\n    function isContract(address _addr) internal view returns (bool){\r\n      uint32 size;\r\n      assembly {\r\n          size := extcodesize(_addr)\r\n      }\r\n    \r\n      return (size > 0);\r\n    }\r\n\r\n    modifier notContract(){\r\n      require(\r\n          (!isContract(msg.sender)),\r\n          \"external contracts are not allowed\"\r\n          );\r\n          _;\r\n    }\r\n\r\n \r\n    \r\n  //external NFT publishing contract\r\n  CyclopsTokens nftContract;\r\n  ERC20Token token; //CYTR\r\n  \r\n  //hard code address of external contract (NFT), as it can't be redeployed in production\r\n  //what could be redeployed - NFTBank contract -  and we can link new NFT bank \r\n  //with special method in CyclopsTokens\r\n  address nftContractAddress = 0xd6d778d86Ddf225e3c02C45D6C6e8Eb3497B452A; //NFT contract (Cyclops)\r\n  address paymentTokenAddress = 0xBD05CeE8741100010D8E93048a80Ed77645ac7bf; //payment token (ERC20, CYTR)\r\n  \r\n  address price_manager = 0x0000000000000000000000000000000000000000;\r\n  \r\n  bool internal_prices = true;\r\n  uint256 price_curve = 5; //5%\r\n  \r\n  uint32 constant BAD_NFT_PROFILE_ID = 9999999;\r\n  uint256 constant BAD_PRICE = 0;\r\n  string constant BAD_URL = '';\r\n  uint32 constant UNLIMITED = 9999999;\r\n  \r\n  /**\r\n   * @dev 'database' to store profiles of NFTs\r\n   */\r\n  struct NFTProfile{\r\n      uint32 id;\r\n      uint256 price; //in CYTR, i.e. 1,678 CYTR last 18 digits are decimals\r\n      uint256 sell_price; //in CYTR i.e. 1,678 CYTR last 18 digits are decimals\r\n      string url;\r\n      uint32 limit;\r\n  }\r\n  \r\n  NFTProfile[] public nftProfiles;\r\n  \r\n  uint256 next_token_id = 10;\r\n\r\n   /**\r\n   * @dev Events\r\n   */\r\n    //buy from us\r\n    event Minted(uint32 profileID, uint256 tokenId, address wallet, uint256 cytrAmount, uint256 priceAtMoment);\r\n    \r\n    //intermediate event for support of broken buy (CYTR transferred but NFT was not minted) \r\n    // - for manual resolution from admin panel\r\n    event GotCYTRForNFT(uint32 profileID, address wallet, uint256 cytrAmount, uint256 priceAtMoment);\r\n    \r\n    //intermediate event for support of broken sell (CYTR transferred back NFT was not burned) \r\n    // - for manual resolution from admin panel\r\n    event SendCYTRForNFT(uint32 profileID, address wallet, uint256 cytrAmount, uint256 buybackPriceAtMoment);\r\n    \r\n    //buy back from user\r\n    event Burned(uint32 profileID, uint256 tokenId, address wallet, uint256 cytrAmount, uint256 buybackPriceAtMoment);\r\n    \r\n    //admin events - CYTR tokens/ether deposit/withdrawal\r\n    event TokensDeposited(uint256 amount, address wallet);\r\n    event FinneyDeposited(uint256 amount, address wallet);\r\n    event Withdrawn(uint256 amount, address wallet);\r\n    event TokensWithdrawn(uint256 amount, address wallet);\r\n    event AdminMinted(uint32 profileID, uint256 tokenId, address wallet, uint256 curPrice); \r\n    event AdminBurned(uint256 _tokenId,uint32 tokenProfileId, uint256 curSellPrice); \r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n     price_manager = owner;\r\n     nftContract = CyclopsTokens(nftContractAddress);   //NFT minting interface\r\n     token = ERC20Token(paymentTokenAddress);           //CYTR interface\r\n  }\r\n    \r\n    function setPriceManagerRight(address newPriceManager) external onlyOwner{\r\n          price_manager = newPriceManager;\r\n    }\r\n      \r\n    \r\n    function getPriceManager() public view returns(address){\r\n        return price_manager;\r\n    }\r\n\r\n    function setInternalPriceCurve() external onlyOwnerOrPriceManager{\r\n          internal_prices = true;\r\n    }\r\n    \r\n    function setExternalPriceCurve() external onlyOwnerOrPriceManager{\r\n          internal_prices = false;\r\n    }\r\n      \r\n    function isPriceCurveInternal() public view returns(bool){\r\n        return internal_prices;\r\n    }\r\n      \r\n    function setPriceCurve(uint256 new_curve) external onlyOwnerOrPriceManager{\r\n          price_curve = new_curve;\r\n    }\r\n      \r\n    \r\n    function getPriceCurve() public view returns(uint256){\r\n        return price_curve;\r\n    }\r\n    \r\n    \r\n    /**\r\n    * @dev setter/getter for ERC20 linked to exchange (current) smartcontract\r\n    */\r\n    function setPaymentToken(address newERC20Contract) external onlyOwner returns(bool){\r\n    \r\n        paymentTokenAddress = newERC20Contract;\r\n        token = ERC20Token(paymentTokenAddress);\r\n    }\r\n    \r\n    \r\n    function getPaymentToken() external view returns(address){\r\n        return paymentTokenAddress;\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n    * @dev setter/getter for NFT publisher linked to 'marketplace' smartcontract\r\n    */\r\n    function setNFTContract(address newNFTContract) external onlyOwner returns(bool){\r\n    \r\n        nftContractAddress = newNFTContract;\r\n        nftContract = CyclopsTokens(nftContractAddress);\r\n    }\r\n    \r\n    \r\n    function getNFTContract() external view returns(address){\r\n        return nftContractAddress;\r\n    }\r\n\r\n\r\n\r\n  /**\r\n   * @dev getter for next_token_id\r\n   */\r\n  function getNextTokenId() external  view returns (uint256){\r\n      return next_token_id;\r\n  }\r\n  \r\n   /**\r\n   * @dev setter for next_token_id\r\n   */\r\n  function setNextTokenId(uint32 setId) external onlyOwnerOrPriceManager (){\r\n      next_token_id = setId;\r\n  }\r\n  \r\n  /**\r\n   * @dev adds 'record' to 'database'\r\n   * @param id, unique id of profiles\r\n   * @param price, price of NFT assets which will be generated based on profile\r\n   * @param sell_price, when we will buy out from owner (burn)\r\n   * @param url, url of NFT assets which will be generated based on profile\r\n   */\r\n  function addNFTProfile(uint32 id, uint256 price, uint256 sell_price, string calldata url, uint32 limit) external onlyOwnerOrPriceManager {\r\n      NFTProfile memory temp = NFTProfile(id,price,sell_price,url, limit);\r\n      nftProfiles.push(temp);\r\n  }\r\n  \r\n  \r\n  \r\n  /**\r\n   * @dev removes 'record' to 'database'\r\n   * @param id (profile id)\r\n   *\r\n   */\r\n  function removeNFTProfileAtId(uint32 id) external onlyOwnerOrPriceManager {\r\n     for (uint32 i = 0; i < nftProfiles.length; i++){\r\n          if (nftProfiles[i].id == id){\r\n              removeNFTProfileAtIndex(i);      \r\n              return;\r\n          }\r\n     }\r\n  }\r\n  \r\n  \r\n  \r\n  /**\r\n   * @dev removes 'record' to 'database'\r\n   * @param index, record number (from 0)\r\n   *\r\n   */\r\n  function removeNFTProfileAtIndex(uint32 index) internal {\r\n     if (index >= nftProfiles.length) return;\r\n     if (index == nftProfiles.length -1){\r\n         nftProfiles.pop();\r\n     } else {\r\n         for (uint i = index; i < nftProfiles.length-1; i++){\r\n             nftProfiles[i] = nftProfiles[i+1];\r\n         }\r\n         nftProfiles.pop();\r\n     }\r\n  }\r\n  \r\n  \r\n  \r\n  /**\r\n   * @dev replaces 'record' in the 'database'\r\n   * @param id, unique id of profile\r\n   * @param price, price of NFT assets which will be generated based on profile\r\n   * @param sell_price, sell price (back to owner) of NFT assets when owner sell to us (and we burn)\r\n   * @param url, url of NFT assets which will be generated based on profile\r\n   */\r\n  function replaceNFTProfileAtId(uint32 id, uint256 price, uint256 sell_price, string calldata url, uint32 limit) external onlyOwnerOrPriceManager {\r\n     for (uint i = 0; i < nftProfiles.length; i++){\r\n          if (nftProfiles[i].id == id){\r\n              nftProfiles[i].price = price;\r\n              nftProfiles[i].sell_price = sell_price;\r\n              nftProfiles[i].url = url;\r\n              nftProfiles[i].limit = limit;\r\n              return;\r\n          }\r\n     }\r\n  }\r\n  \r\n  \r\n  /**\r\n   * @dev replaces 'record' in the 'database'\r\n   * @param atIndex, at which row of array to make replacement\r\n   * @param id, unique id of profiles\r\n   * @param price, price of NFT assets which will be generated based on profile\r\n   * @param sell_price, sell price (back to owner) of NFT assets when owner sell to us (and we burn)\r\n   * @param url, url of NFT assets which will be generated based on profile\r\n   */\r\n  function replaceNFTProfileAtIndex(uint32 atIndex, uint32 id, uint256 price, uint256 sell_price, string calldata url, uint32 limit) external onlyOwnerOrPriceManager  {\r\n     nftProfiles[atIndex].id = id;\r\n     nftProfiles[atIndex].price = price;\r\n     nftProfiles[atIndex].sell_price = sell_price;\r\n     nftProfiles[atIndex].url = url;\r\n     nftProfiles[atIndex].limit = limit;\r\n  }\r\n  \r\n    /**\r\n   * @dev return array of strings is not supported by solidity, we return ids & prices\r\n   */\r\n  function viewNFTProfilesPrices() external view returns( uint32[] memory, uint256[] memory, uint256[] memory){\r\n      uint32[] memory ids = new uint32[](nftProfiles.length);\r\n      uint256[] memory prices = new uint256[](nftProfiles.length);\r\n      uint256[] memory sell_prices = new uint256[](nftProfiles.length);\r\n      for (uint i = 0; i < nftProfiles.length; i++){\r\n          ids[i] = nftProfiles[i].id;\r\n          prices[i] = nftProfiles[i].price;\r\n          sell_prices[i] = nftProfiles[i].sell_price;\r\n      }\r\n      return (ids, prices, sell_prices);\r\n  }\r\n  \r\n  \r\n   /**\r\n   * @dev return price, sell_price & url for profile by id\r\n   */\r\n  function viewNFTProfileDetails(uint32 id) external view returns(uint256, uint256, string memory, uint32){\r\n     for (uint i = 0; i < nftProfiles.length; i++){\r\n          if (nftProfiles[i].id == id){\r\n              return (nftProfiles[i].price, nftProfiles[i].sell_price, nftProfiles[i].url, nftProfiles[i].limit);     \r\n          }\r\n     }\r\n     return (BAD_PRICE, BAD_PRICE, BAD_URL, UNLIMITED);\r\n  }\r\n  \r\n  /**\r\n   * @dev get price by id from 'database'\r\n   * @param id, unique id of profiles\r\n   */\r\n  function getPriceById(uint32 id) public  view returns (uint256){\r\n      for (uint i = 0; i < nftProfiles.length; i++){\r\n          if (nftProfiles[i].id == id){\r\n              return nftProfiles[i].price;\r\n          }\r\n      }\r\n      return BAD_PRICE;\r\n  }\r\n  \r\n  \r\n \r\n  \r\n  /**\r\n   * @dev get sell price by id from 'database'\r\n   * @param id, unique id of profiles\r\n   */\r\n  function getSellPriceById(uint32 id) public  view returns (uint256){\r\n      for (uint i = 0; i < nftProfiles.length; i++){\r\n          if (nftProfiles[i].id == id){\r\n              return nftProfiles[i].sell_price;\r\n          }\r\n      }\r\n      return BAD_PRICE;\r\n  }\r\n  \r\n   /**\r\n   * @dev set new price for asset (profile of NFT), price for which customer can buy\r\n   * @param id, unique id of profiles\r\n   */\r\n  function setPriceById(uint32 id, uint256 new_price) external onlyOwnerOrPriceManager{\r\n      for (uint i = 0; i < nftProfiles.length; i++){\r\n          if (nftProfiles[i].id == id){\r\n              nftProfiles[i].price = new_price;\r\n              return;\r\n          }\r\n      }\r\n  }\r\n  \r\n   /**\r\n   * @dev set new sell (buy back) price for asset (profile of NFT), \r\n   * price for which customer can sell to us\r\n   * @param id, unique id of profiles\r\n   */\r\n  function setSellPriceById(uint32 id, uint256 new_price) external onlyOwnerOrPriceManager{\r\n      for (uint i = 0; i < nftProfiles.length; i++){\r\n          if (nftProfiles[i].id == id){\r\n              nftProfiles[i].sell_price = new_price;\r\n              return;\r\n          }\r\n      }\r\n  }\r\n  \r\n  // for optimization, funciton to update both prices\r\n  function updatePricesById(uint32 id, uint256 new_price, uint256 new_sell_price) external onlyOwnerOrPriceManager{\r\n      for (uint i = 0; i < nftProfiles.length; i++){\r\n          if (nftProfiles[i].id == id){\r\n              nftProfiles[i].price = new_price;\r\n              nftProfiles[i].sell_price = new_sell_price;\r\n              return;\r\n          }\r\n      }\r\n  }\r\n  \r\n \r\n  \r\n  /**\r\n   * @dev get url by id from 'database'\r\n   * @param id, unique id of profiles\r\n   */ \r\n  function  getUrlById(uint32 id) public view returns (string memory){\r\n      for (uint i = 0; i < nftProfiles.length; i++){\r\n          if (nftProfiles[i].id == id){\r\n              return nftProfiles[i].url;\r\n          }\r\n      }\r\n      return BAD_URL;\r\n  }\r\n  \r\n  function  getLimitById(uint32 id) public view returns (uint32){\r\n      for (uint i = 0; i < nftProfiles.length; i++){\r\n          if (nftProfiles[i].id == id){\r\n             return nftProfiles[i].limit;\r\n          }\r\n      }\r\n      return UNLIMITED;\r\n  }\r\n  \r\n   \r\n  /**\r\n   * @dev accepts payment only in CYTR(!) for mint NFT & calls external contract\r\n   * it is public function, i.e called by buyer via dApp\r\n   * buyer selects profile (profileID), provides own wallet address (_to)\r\n   * and dApp provides available _tokenId (for flexibility its calculation is not automatic on \r\n   * smart contract level, but it is possible to implement) - > nftContract.totalSupply()+1\r\n   * why not recommended: outsite of smart contract with multiple simultaneous customers we can \r\n   * instanteneusly on level of backend determinte next free id.\r\n   * on CyclopsTokens smartcontract level it can be only calculated correctly after mint transaction is confirmed\r\n   * here utility function is implemented which is used by backend ,getNextTokenId()\r\n   * it is also possible to use setNextTokenId function (by owner) to reset token id if needed\r\n   * normal use is dApp requests next token id (tid = getNextTokenId()) and after that\r\n   * calls publicMint(profile, to, tid)\r\n   * it allows different dApps use different token ids areas\r\n   * like   dapp1: tid = getNextTokenId() + 10000\r\n   *        dapp2: tid = getNextTokenId() + 20000\r\n   */\r\n  function buyNFT(          //'buy' == mint NFT token function, provides NFT token in exchange of CYTR    \r\n    uint32 profileID,       //id of NFT profile\r\n    uint256 cytrAmount,     //amount of CYTR we check it is equal to price, amount in real form i.e. 18 decimals\r\n    address _to,            //where to deliver \r\n    uint256 _tokenId        //with which id NFT will be generated\r\n  ) \r\n    external \r\n    notContract \r\n    returns (uint256)\r\n  {\r\n    require (getLimitById(profileID) > 0,\"limit is over\");\r\n    \r\n    uint256 curPrice = getPriceById(profileID);\r\n    require(curPrice != BAD_PRICE, \"price for NFT profile not found\");\r\n    require(cytrAmount > 0, \"You need to provide some CYTR\"); //it is already in 'real' form, i.e. with decimals\r\n    \r\n    require(cytrAmount == curPrice); //correct work (i.e. dApp calculated price correctly)\r\n    \r\n    uint256 token_bal = token.balanceOf(msg.sender); //how much CYTR buyer has\r\n    \r\n    require(token_bal >= cytrAmount, \"Check the CYTR balance on your wallet\"); //is it enough\r\n    \r\n    uint256 allowance = token.allowance(msg.sender, address(this));\r\n    \r\n    require(allowance >= cytrAmount, \"Check the CYTR allowance\"); //is allowance provided\r\n    \r\n    require(isFreeTokenId(_tokenId), \"token id is is occupied\"); //adjust on calling party\r\n\r\n    //ensure we revert in case of failure\r\n    try token.transferFrom(msg.sender, address(this), cytrAmount) { // get CYTR from buyer\r\n        emit GotCYTRForNFT(profileID, msg.sender, cytrAmount, curPrice);\r\n    } catch {\r\n        require(false,\"CYTR transfer failed\");\r\n        return 0; \r\n    }\r\n  \r\n   \r\n    //external contract mint\r\n    try nftContract.mint(_to,_tokenId, getUrlById(profileID)){\r\n        next_token_id++;\r\n        //we should have event pairs GotCYTRForNFT - Minted if all good\r\n        emit Minted(profileID, _tokenId, msg.sender, cytrAmount, curPrice); \r\n    } catch {\r\n        //return payment by using require..it should revert transaction \r\n        require(false,\"mint failed\");\r\n    }\r\n    \r\n    for (uint i = 0; i < nftProfiles.length; i++){\r\n      if (nftProfiles[i].id == profileID){\r\n          if (nftProfiles[i].limit != UNLIMITED) nftProfiles[i].limit--;\r\n      }\r\n    }\r\n    \r\n    if (internal_prices){ //if we manage price curve internally\r\n        for (uint i = 0; i < nftProfiles.length; i++){\r\n          if (nftProfiles[i].id == profileID){\r\n              uint256 change = nftProfiles[i].price.div(100).mul(price_curve);\r\n              nftProfiles[i].price = nftProfiles[i].price.add(change);\r\n              change = nftProfiles[i].sell_price.div(100).mul(price_curve);\r\n              nftProfiles[i].sell_price = nftProfiles[i].sell_price.add(change);\r\n          }\r\n      }\r\n    }\r\n \r\n    //return _tokenId; //success, return generated tokenId, works only if called by contract, i.e. not our case\r\n  }\r\n\r\n /**\r\n   * @dev method allows collectible owner to sell it back for sell price\r\n   * collectible is burned, amount of sell price returned to owner of collectible\r\n   * tokenId -> tokenProfileId -> sell price\r\n   */\r\n  function sellNFTBack(uint256 _tokenId) external notContract returns(uint256){ //'sell' == burn, burns and returns CYTR to user\r\n        require(nftContract.ownerOf(_tokenId) == msg.sender, \"it is not your NFT\");\r\n        uint32 tokenProfileId = getProfileIdByTokenId(_tokenId);\r\n        require(tokenProfileId != BAD_NFT_PROFILE_ID, \"NFT profile ID not found\");\r\n        uint256 sellPrice = getSellPriceById(tokenProfileId); \r\n        require(sellPrice != BAD_PRICE, \"NFT price not found\");\r\n        \r\n        require(token.balanceOf(msg.sender) > sellPrice, \"unsufficient CYTR on contract\");\r\n        \r\n        try nftContract.burn(_tokenId) {\r\n            emit Burned(tokenProfileId, _tokenId, msg.sender, sellPrice, sellPrice); \r\n        } catch {\r\n        //ensure error will be send (false, i.e. require is never fulfilled, error send)\r\n            require (false, \"NFT burn failed\");\r\n        }\r\n      \r\n        //ensure we revert in case of failure\r\n        try token.transfer(msg.sender,  sellPrice) { // send CYTR to seller\r\n            //just continue if all good..\r\n            emit SendCYTRForNFT(tokenProfileId, msg.sender, sellPrice, sellPrice);\r\n        } catch {\r\n            require(false,\"CYTR transfer failed\");\r\n            return 0; \r\n        }\r\n        \r\n        for (uint i = 0; i < nftProfiles.length; i++){\r\n          if (nftProfiles[i].id == tokenProfileId){\r\n              if (nftProfiles[i].limit != UNLIMITED) nftProfiles[i].limit++;\r\n          }\r\n        }\r\n       \r\n        if (internal_prices){ //if we manage price curve internally\r\n            for (uint i = 0; i < nftProfiles.length; i++){\r\n              if (nftProfiles[i].id == tokenProfileId){\r\n                  uint256 change = nftProfiles[i].price.div(100).mul(price_curve);\r\n                  nftProfiles[i].price = nftProfiles[i].price.sub(change);\r\n                  change = nftProfiles[i].sell_price.div(100).mul(price_curve);\r\n                  nftProfiles[i].sell_price = nftProfiles[i].sell_price.sub(change);\r\n              }\r\n            }\r\n        }\r\n  }\r\n  \r\n  \r\n  function adminMint(       //mint for free as admin\r\n    uint32 profileID,       //id of NFT profile\r\n    address _to,            //where to deliver \r\n    uint256 _tokenId        //with which id NFT will be generated\r\n  ) \r\n    external \r\n    onlyOwnerOrPriceManager\r\n    returns (uint256)\r\n  {\r\n    uint256 curPrice = getPriceById(profileID);\r\n    require(curPrice != BAD_PRICE, \"price for NFT profile not found\");\r\n    require(isFreeTokenId(_tokenId), \"token id is is occupied\");\r\n  \r\n\r\n    \r\n    //external contract mint\r\n    try nftContract.mint(_to,_tokenId, getUrlById(profileID)){\r\n        next_token_id++;\r\n        //we should have event pairs GotCYTRForNFT - Minted if all good\r\n        emit AdminMinted(profileID, _tokenId, _to, curPrice); \r\n    } catch {\r\n        //return payment by using require..it should revert transaction \r\n        require(false,\"mint failed\");\r\n    }\r\n    \r\n    return _tokenId; //success, return generated tokenId (works if called by another contract)\r\n  }\r\n\r\n  \r\n  \r\n  function adminBurn(uint256 _tokenId) external  onlyOwnerOrPriceManager returns(uint256){  //burn as admin, without CYTR move\r\n\r\n        uint32 tokenProfileId = getProfileIdByTokenId(_tokenId);\r\n        //require(tokenProfileId != BAD_NFT_PROFILE_ID, \"NFT profile ID not found\");\r\n        //in admin mode we do not require it\r\n        uint256 sellPrice = getSellPriceById(tokenProfileId); \r\n        //require(sellPrice != BAD_PRICE, \"NFT price not found\");\r\n        //in admin mode we do not require it\r\n        \r\n        try nftContract.burn(_tokenId) {\r\n            emit AdminBurned(_tokenId, tokenProfileId, sellPrice); \r\n        } catch {\r\n        //ensure error will be send (false, i.e. require is never fulfilled, error send)\r\n            require (false, \"NFT burn failed\");\r\n        }\r\n      \r\n  }\r\n  \r\n  \r\n  function getProfileIdByTokenId(uint256 tokenId) public view returns(uint32){\r\n      string memory url = BAD_URL;\r\n      try nftContract.tokenURI(tokenId) {\r\n        url = nftContract.tokenURI(tokenId);\r\n        return getProfileIdbyUrl(url);\r\n      } catch {\r\n        return BAD_NFT_PROFILE_ID;\r\n      }\r\n     \r\n  }\r\n  \r\n  function getProfileIdbyUrl(string memory url) public  view returns (uint32){\r\n      for (uint i = 0; i < nftProfiles.length; i++){\r\n          if (keccak256(bytes(nftProfiles[i].url)) == keccak256(bytes(url))){\r\n              return nftProfiles[i].id;\r\n          }\r\n      }\r\n      return BAD_NFT_PROFILE_ID;\r\n  }\r\n  \r\n \r\n  \r\n  function isFreeTokenId(uint256 tokenId) public view returns (bool){\r\n      try nftContract.tokenURI(tokenId) { \r\n          //if we can run this successfully it means token id is not free -> false\r\n          return false;\r\n      } catch {\r\n          return true; //if we errored getting url by tokenId, it is free -> true\r\n      }\r\n  }\r\n  \r\n  \r\n  function getTokenPriceByTokenId(uint256 tokenId) public view returns(uint256){\r\n      string memory url = BAD_URL;\r\n      try nftContract.tokenURI(tokenId) {\r\n        url = nftContract.tokenURI(tokenId);\r\n        uint32 profileId = getProfileIdbyUrl(url);\r\n        if (profileId == BAD_NFT_PROFILE_ID){\r\n            return BAD_NFT_PROFILE_ID;\r\n        } else {\r\n            return getSellPriceById(profileId);\r\n        }\r\n      } catch {\r\n        return BAD_NFT_PROFILE_ID;\r\n      }\r\n     \r\n  }\r\n  \r\n  \r\n    /**\r\n    * @dev - six functions below are for owner to check balance and\r\n    * deposit/withdraw eth/tokens to exchange contract\r\n    */\r\n    /**\r\n    * @dev returns contract balance, in wei\r\n    */\r\n    \r\n    function getContractBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    /**\r\n    * @dev returns contract tokens balance\r\n    */\r\n    function getContractTokensBalance() external view returns (uint256) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n    \r\n    \r\n    function withdraw(address payable sendTo, uint256 amount) external onlyOwner {\r\n        require(address(this).balance >= amount, \"unsufficient funds\");\r\n        bool success = false;\r\n        // ** sendTo.transfer(amount);**\r\n        (success, ) = sendTo.call.value(amount)(\"\");\r\n        require(success, \"Transfer failed.\");\r\n        // ** end **\r\n        emit Withdrawn(amount, sendTo); //in wei\r\n    }\r\n    \r\n    \r\n    //deposit ether (amount in finney for control is provided as input paramenter)\r\n    function deposit(uint256 amount) payable external onlyOwner { \r\n        require(amount*(1 finney) == msg.value,\"please provide value in finney\");\r\n        emit FinneyDeposited(amount, owner); //in finney\r\n    }\r\n    \r\n    \r\n    // tokens with decimals, already converted on frontend\r\n    function depositTokens(uint256 amount) external onlyOwner {\r\n        require(amount > 0, \"You need to deposit at least some tokens\");\r\n        uint256 allowance = token.allowance(msg.sender, address(this));\r\n        require(allowance >= amount, \"Check the token allowance\");\r\n        token.transferFrom(msg.sender, address(this), amount);\r\n    \r\n        emit TokensDeposited(amount, owner);\r\n    }\r\n    \r\n    \r\n    // tokens with decimals, already converted on frontend\r\n    function withdrawTokens(address to_wallet, uint256 realAmountTokens) external onlyOwner {\r\n            \r\n        require(realAmountTokens > 0, \"You need to withdraw at least some tokens\");\r\n      \r\n        uint256 contractTokenBalance = token.balanceOf(address(this));\r\n    \r\n        require(contractTokenBalance > realAmountTokens, \"unsufficient funds\");\r\n    \r\n         //ensure we revert in case of failure\r\n        try token.transfer(to_wallet, realAmountTokens) {\r\n            emit TokensWithdrawn(realAmountTokens, to_wallet); //in real representation\r\n        } catch {\r\n            require(false,\"tokens transfer failed\");\r\n    \r\n        }\r\n    \r\n    }\r\n        \r\n    \r\n    \r\n}"}}}