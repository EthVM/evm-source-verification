{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/new_yBXTBService2.sol":{"content":"// SPDX-License-Identifier: MIT\n// ----------------------------------------------------------------------------\n// yBXTB Service contract\n// ----------------------------------------------------------------------------\npragma solidity ^0.7.4;\n\n// ----------------------------------------------------------------------------\n// Safe maths\n// ----------------------------------------------------------------------------\nlibrary SafeMath {\n    function addSafe(uint _a, uint _b) internal pure returns (uint c) {\n        c = _a + _b;\n        require(c >= _a);\n    }\n    function subSafe(uint _a, uint _b) internal pure returns (uint c) {\n        require(_b <= _a, \"Insufficient balance\");\n        c = _a - _b;\n    }\n    function mulSafe(uint _a, uint _b) internal pure returns (uint c) {\n        c = _a * _b;\n        require(_a == 0 || c / _a == _b);\n    }\n    function divSafe(uint _a, uint _b) internal pure returns (uint c) {\n        require(_b > 0);\n        c = _a / _b;\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n// ----------------------------------------------------------------------------\n// For BXTB Interface\ninterface ERC20Interface {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address _tokenOwner) external view returns (uint);\n    function allowance(address _tokenOwner, address _spender) external view returns (uint);\n    function transfer(address _to, uint _amount) external returns (bool);\n    function approve(address _spender, uint _amount) external returns (bool);\n    function transferFrom(address _from, address _to, uint _amount) external returns (bool);\n}\n\n// ----------------------------------------------------------------------------\n// Contract function to receive approval and execute function in one call\n// ----------------------------------------------------------------------------\ninterface ApproveAndCallFallBack {\n    function receiveApproval(address _tokenOwner, uint256 _amount, address _tokenContract, bytes memory _data) external;\n}\n\ninterface SettlementInterface {\n    function disburseCommissions(bool _disburseBackstop) external;\n}\n\n\n// For USDT Interface\n// Changed 'constant' to 'view' for compiler 0.5.4\ninterface ERC20_USDT {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address who) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function transfer(address to, uint value) external;\n    function approve(address spender, uint value) external;\n    function transferFrom(address from, address to, uint value) external;\n}\n\n\n// ----------------------------------------------------------------------------\n// Owned contract\n// ----------------------------------------------------------------------------\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n        emit OwnershipTransferred(owner, newOwner);\n    }\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n}\n\n\n// ----------------------------------------------------------------------------\n// yBXTB Service Contract\n// ----------------------------------------------------------------------------\ncontract YieldTokenService is ApproveAndCallFallBack, SettlementInterface, Owned {\n    using SafeMath for uint;\n\n    address public constant USDTContract = 0xdAC17F958D2ee523a2206206994597C13D831ec7;      // USDT contract\n    address public constant BXTBContract = 0x7bA9caa5D19002618F1D93e691490377361D5E60;      // BXTB contract\n    address public constant yieldTokenContract = 0x39dCCA7984B22cCB0347DeEAeEaaEE6e6Ce9ba9F;     // yBXTB contract\n    address public constant CHIPContract = 0x73F737dE96cF8987CA2C4C1FDC5134688BB2e10f;      // CHIP contract\n\n    address public bxtbFoundation = 0x616143B2e9ADC2F48c9Ad4C30162e0782297f06f;\n    address public recoveryAdmin;\n    address public settlementAdmin;\n    address public backstopAdmin;\n\n    uint public totalPoolUSDTCollateral;\n    uint public totalPoolBXTB;\n\n    uint public totalPoolCHIPBackStop;\n    uint public totalPoolCHIPBackStopAvailable;\n\n    uint public totalPoolCHIPCommissions;\n    uint public totalPoolCHIPCommissionsAvailable;\n\n    uint public totalSupplyYieldToken;\n    uint public outstandingYieldToken;\n\n    uint public totalSupplyCHIP;\n    uint public outstandingCHIP;\n\n    uint public constant decimals = 6;\n    uint public collateralizationRatio;\n\n    uint public bxtbTokenRatio;\n\n    bool public allowStaking;\n    bool public allowCommissions;\n\n    constructor() {\n        bxtbTokenRatio = 100;           // 100%\n        collateralizationRatio = 100;   // 100%\n\n        allowStaking = true;\n        allowCommissions = false;\n    }\n\n    event TotalSupplyYieldTokenChanged(uint _amount);                   // Load YieldToken supply\n    event TotalSupplyCHIPChanged(uint _amount);                         // Load CHIP supply\n    event OutstandingSupplyChanged();                                   // Change in YieldToken & CHIP in circulation\n    event ChangeBxtbTokenRatio(uint _amount);                           // Token ratio changed\n    event CommissionReceived(address indexed _sender, uint _amount);    // Commissions received\n    event CommissionsDisbursed(uint _amount);\n    event BackstopDisbursed(uint _amount);\n    event BackstopAdjusted(bool _refunded, uint _amount);\n\n\n    function receiveApproval(address _tokenOwner, uint256 _amount, address _tokenContract, bytes memory _data) public override {\n        // Prevent ERC20 short address attack\n        // _data length is not fixed\n        require((msg.data.length == (6 * 32) + 4) && (_data.length == 1), \"Input length error\");\n\n        require(msg.sender == yieldTokenContract ||\n        msg.sender == CHIPContract ||\n        msg.sender == BXTBContract, \"Unknown caller\");\n\n        // Mode 0x10: Normal deposit\n        // Mode 0xF0: Load reserve tokens\n        uint8 mode = uint8(_data[0]);\n        require(mode == 0x10 || mode == 0xE0 || mode == 0xF0, \"Mode not accepted\");\n\n        if(mode == 0x10) {\n            // Normal deposits for Stake and Redeem\n            // Sanity check\n            require(totalSupplyYieldToken == totalSupplyCHIP, \"Supply imbalance\");\n            uint wildChip;\n\n            // Credit to caller\n            if(msg.sender == BXTBContract) {\n                // Stake\n                // Staking paused by admin\n                require(allowStaking == true, \"Staking is paused\");\n\n                // Get allowance\n                uint allowanceUsdt = ERC20_USDT(USDTContract).allowance(_tokenOwner, address(this));\n                uint allowanceBxtb = _amount;\n\n                // Enforce token staking ratio\n                if(bxtbTokenRatio == 100) {  // 100 percent\n                    // Get minimum common size. Size must be the same\n                    if(allowanceUsdt <= allowanceBxtb) allowanceBxtb = allowanceUsdt;\n                    else allowanceUsdt = allowanceBxtb;\n                }\n                else {\n                    if(bxtbTokenRatio > 0) {\n                        uint allowanceBxtbExpected = allowanceUsdt.mulSafe(bxtbTokenRatio).divSafe(100);\n                        if(allowanceBxtb >= allowanceBxtbExpected) allowanceBxtb = allowanceBxtbExpected;  // Sufficient BXTB\n                        else allowanceUsdt = allowanceBxtb.mulSafe(100).divSafe(bxtbTokenRatio);  // Reduce USDT due to insufficient BXTB\n                    }\n                    else allowanceBxtb = 0;  // Prevent divide-by-zero errors\n                }\n\n                // Issue YieldToken 'n' CHIP\n                require(allowanceUsdt > 0, \"Zero stake\");\n\n                // How many YieldToken are in reserve?\n                uint remainderYieldToken = totalSupplyYieldToken.subSafe(outstandingYieldToken);\n                // If not enough YieldToken. Reject transaction\n                require((allowanceUsdt <= remainderYieldToken) && (remainderYieldToken > 0), \"Staking size exceeded\");\n\n                // Accept USDT\n                ERC20_USDT(USDTContract).transferFrom(_tokenOwner, address(this), allowanceUsdt);\n\n                // For every USDT stake, issue 1 CHIP and 1 YieldToken\n                // Update pool counter\n                totalPoolUSDTCollateral = totalPoolUSDTCollateral.addSafe(allowanceUsdt);\n\n                // Send out event for change in outstanding supply\n                emit OutstandingSupplyChanged();\n\n                // Accept BXTB\n                if(allowanceBxtb > 0) {\n                    ERC20Interface(BXTBContract).transferFrom(_tokenOwner, address(this), allowanceBxtb);\n                    totalPoolBXTB = totalPoolBXTB.addSafe(allowanceBxtb);\n                }\n\n                // Issue YieldToken and CHIP, and update outstanding tokens\n                // outstandingYieldToken and outstandingCHIP must be synchronized at all cost!\n                outstandingYieldToken = outstandingYieldToken.addSafe(allowanceUsdt);\n                outstandingCHIP = outstandingCHIP.addSafe(allowanceUsdt);\n\n                ERC20Interface(yieldTokenContract).transfer(_tokenOwner, allowanceUsdt);\n                ERC20Interface(CHIPContract).transfer(_tokenOwner, allowanceUsdt);\n\n                // Calculate collat ratio\n                wildChip = outstandingCHIP.subSafe(totalPoolCHIPBackStop);\n                if(wildChip > 0) collateralizationRatio = totalPoolUSDTCollateral.mulSafe(100).divSafe(wildChip);  // In percent\n                else collateralizationRatio = 100;\n            }\n            else if(msg.sender == CHIPContract) {\n                // Redeem\n                // Get allowance\n                uint allowanceYieldToken = ERC20Interface(yieldTokenContract).allowance(_tokenOwner, address(this));\n                uint allowanceCHIP = _amount;\n\n                uint allowanceSize;\n                // Get minimum common size. Size must be the same\n                if(allowanceYieldToken <= allowanceCHIP) allowanceSize = allowanceYieldToken;\n                else allowanceSize = allowanceCHIP;\n\n                // Redeem YieldToken and CHIP tokens\n                require(allowanceSize > 0, \"Zero redeem\");\n\n                // Can't redeem more than outstanding CHIP\n                require((allowanceSize <= outstandingCHIP) && (outstandingCHIP > 0), \"Redemption size exceeded\");\n\n                // Accept YieldToken and CHIP\n                ERC20Interface(yieldTokenContract).transferFrom(_tokenOwner, address(this), allowanceSize);\n                ERC20Interface(CHIPContract).transferFrom(_tokenOwner, address(this), allowanceSize);\n\n                // Take YieldToken and CHIP out of circulation\n                // outstandingYieldToken and outstandingCHIP must be synchronized at all cost\n                outstandingYieldToken = outstandingYieldToken.subSafe(allowanceSize);\n                outstandingCHIP = outstandingCHIP.subSafe(allowanceSize);\n\n                // Emit event for change in outstanding supply\n                emit OutstandingSupplyChanged();\n\n                // Pay out equivalent amount of USDT, and send BXTB to Foundation\n                uint shareOfBxtb;\n\n                if(outstandingCHIP > 0) {\n                    // Update pool counters\n                    totalPoolUSDTCollateral = totalPoolUSDTCollateral.subSafe(allowanceSize);\n                    // Send back collateral\n                    ERC20_USDT(USDTContract).transfer(_tokenOwner, allowanceSize);\n\n                    // Enforce token redemption ratio\n                    if(bxtbTokenRatio == 100) shareOfBxtb = allowanceSize;  // 100 percent\n                    else shareOfBxtb = allowanceSize.mulSafe(bxtbTokenRatio).divSafe(100);\n\n                    // Can't take out more BXTB than exists\n                    if(shareOfBxtb > totalPoolBXTB) shareOfBxtb = totalPoolBXTB;\n\n                    // Update counters\n                    totalPoolBXTB = totalPoolBXTB.subSafe(shareOfBxtb);\n                    // Send BXTB to foundation\n                    ERC20Interface(BXTBContract).transfer(bxtbFoundation, shareOfBxtb);\n\n                    // Calculate collat ratio\n                    wildChip = outstandingCHIP.subSafe(totalPoolCHIPBackStop);\n                    if(wildChip > 0) collateralizationRatio = totalPoolUSDTCollateral.mulSafe(100).divSafe(wildChip);  // In percent\n                    else collateralizationRatio = 100;\n                }\n                else {\n                    // Last redeemer: Disburse everything\n                    // In case contract accumulates more than expected, this clears out the account\n                    // Hard resets USDT counter. No more outstanding CHIP and YieldTokens\n                    outstandingCHIP = 0;\n                    outstandingYieldToken = 0;\n\n                    // Pay out USDT\n                    totalPoolUSDTCollateral = 0;\n                    uint residualValue = ERC20_USDT(USDTContract).balanceOf(address(this));\n                    ERC20_USDT(USDTContract).transfer(_tokenOwner, residualValue);\n\n                    // Hard reset BXTB counters\n                    totalPoolBXTB = 0;\n                    // Send BXTB to foundation\n                    shareOfBxtb = ERC20Interface(BXTBContract).balanceOf(address(this));\n                    ERC20Interface(BXTBContract).transfer(bxtbFoundation, shareOfBxtb);\n\n                    // Calculate collat ratio\n                    collateralizationRatio = 100;\n                }\n            }\n            else revert(\"Unknown stake/redeem token\");\n        }\n        else if(mode == 0xE0) {\n            // Pay commissions\n            require(msg.sender == CHIPContract, \"Only CHIP accepted\");\n            payCommission(_tokenOwner);\n        }\n        else if(mode == 0xF0) {\n            // Load reserve tokens\n            // Only contract owner can load it\n            require((_tokenOwner == owner) && (owner != address(0)), \"Caller must be owner\");\n            // Check allowance\n            require(_amount > 0, \"Zero deposit\");\n\n            // YieldToken and CHIP reserve must be equal prior to staking commencement\n            if(msg.sender == yieldTokenContract) {\n                // Retrieve tokens\n                ERC20Interface(yieldTokenContract).transferFrom(_tokenOwner, address(this), _amount);\n                // Update total supply\n                totalSupplyYieldToken = totalSupplyYieldToken.addSafe(_amount);\n                // Emit event\n                emit TotalSupplyYieldTokenChanged(totalSupplyYieldToken);\n            }\n            else if(msg.sender == CHIPContract) {\n                // Retrieve tokens\n                ERC20Interface(CHIPContract).transferFrom(_tokenOwner, address(this), _amount);\n                // Update total supply\n                totalSupplyCHIP = totalSupplyCHIP.addSafe(_amount);\n                // Emit event\n                emit TotalSupplyCHIPChanged(totalSupplyCHIP);\n            }\n            else revert(\"Unknown reserve token\");\n        }\n    }\n\n    // Pay commission\n    function payCommission(address _sender) internal {\n        require(allowCommissions == true, \"Commissions paused\");\n\n        uint allowanceCHIP = ERC20Interface(CHIPContract).allowance(_sender, address(this));\n        require(allowanceCHIP > 0, \"Zero commission\");\n\n        if(outstandingYieldToken > 0) {\n            // Distribute commission to unit holders\n            // Accept the deposit\n            ERC20Interface(CHIPContract).transferFrom(_sender, address(this), allowanceCHIP);\n            // Send to comission pools\n            distributeToPools(allowanceCHIP);\n            // Log event\n            emit CommissionReceived(_sender, allowanceCHIP);\n        }\n        else {\n            // This code should be unreachable\n            // No more unit holders\n            address recipient;\n            if(owner != address(0)) recipient = owner;  // Send to contract owner\n            else if(settlementAdmin != address(0)) recipient = settlementAdmin;  // If no contract owner, send to Settlement Admin\n            else if(bxtbFoundation != address(0)) recipient = bxtbFoundation;  // If no contract owner, send to BXTB Foundation\n            else revert(\"No recipients\");  // No foundation, decline commission\n\n            // Accept the deposit\n            ERC20Interface(CHIPContract).transferFrom(_sender, recipient, allowanceCHIP);\n            // Log event\n            emit CommissionReceived(_sender, allowanceCHIP);\n        }\n    }\n\n    function distributeToPools(uint _amount) internal {\n        require(outstandingYieldToken > 0, \"No more unit holders\");\n\n        uint backstopShortfall;\n        uint backstopTarget = totalPoolUSDTCollateral.divSafe(10);  // Target backstop to be 10% of collateral\n\n        // Over collateralize coin up to 10% (100% collateral + 10% backstop)\n        if(totalPoolCHIPBackStop < backstopTarget) backstopShortfall = backstopTarget.subSafe(totalPoolCHIPBackStop);\n\n        // Share commission between internal totalPools\n        if(backstopShortfall > 0) {\n            // Send portion to backstop pool\n            uint allocateBackstop = _amount.divSafe(6);  // 1/6th goes to backstop pool\n\n            if(allocateBackstop > backstopShortfall) allocateBackstop = backstopShortfall;  // Limit reached\n\n            uint allocateCommission = _amount.subSafe(allocateBackstop);\n\n            // Send to pools\n            totalPoolCHIPBackStop = totalPoolCHIPBackStop.addSafe(allocateBackstop);                    // Cumulative amount deposited\n            totalPoolCHIPBackStopAvailable = totalPoolCHIPBackStopAvailable.addSafe(allocateBackstop);  // Current balance in contract\n\n            totalPoolCHIPCommissions = totalPoolCHIPCommissions.addSafe(allocateCommission);                    // Cumulative amount deposited\n            totalPoolCHIPCommissionsAvailable = totalPoolCHIPCommissionsAvailable.addSafe(allocateCommission);  // Current balance in contract\n        }\n        else {\n            // Send all to commissions pool\n            totalPoolCHIPCommissions = totalPoolCHIPCommissions.addSafe(_amount);                       // Cumulative amount deposited\n            totalPoolCHIPCommissionsAvailable = totalPoolCHIPCommissionsAvailable.addSafe(_amount);     // Current balance in contract\n        }\n\n        // Calculate collat ratio\n        uint wildChip = outstandingCHIP.subSafe(totalPoolCHIPBackStop);\n        if(wildChip > 0) collateralizationRatio = totalPoolUSDTCollateral.mulSafe(100).divSafe(wildChip);  // In percent\n        else collateralizationRatio = 100;\n    }\n\n    // Perform settlement\n    function disburseCommissions(bool _disburseBackstop) external override {\n        require((msg.sender == yieldTokenContract) ||\n        (msg.sender == settlementAdmin) ||\n            (msg.sender == owner) , \"Caller not authorized\");\n\n        require(settlementAdmin != address(0), \"Settlement Admin address error\");\n\n        // How much funds to disburse?\n        uint withdrawAmount = totalPoolCHIPCommissionsAvailable;\n        totalPoolCHIPCommissionsAvailable = 0;\n        // Pay out to settlementAdmin account\n        ERC20Interface(CHIPContract).transfer(settlementAdmin, withdrawAmount);\n        emit CommissionsDisbursed(withdrawAmount);\n\n        // Send out the backstop balance too\n        if(_disburseBackstop == true) {\n            require(backstopAdmin != address(0), \"Backstop Admin address error\");\n\n            // How much to pay out?\n            withdrawAmount = totalPoolCHIPBackStopAvailable;\n            totalPoolCHIPBackStopAvailable = 0;\n            // Disburse backstop CHIPs to backstop Admin\n            ERC20Interface(CHIPContract).transfer(backstopAdmin, withdrawAmount);\n            emit BackstopDisbursed(withdrawAmount);\n        }\n    }\n\n    // Send out backstop balance\n    function disburseBackstop() external {\n        require((msg.sender == backstopAdmin) || (msg.sender == owner), \"Caller not authorized\");\n        require(backstopAdmin != address(0), \"Backstop Admin address error\");\n\n        // How much to pay out?\n        uint withdrawAmount = totalPoolCHIPBackStopAvailable;\n        totalPoolCHIPBackStopAvailable = 0;\n        // Disburse backstop CHIPs to backstop Admin\n        ERC20Interface(CHIPContract).transfer(backstopAdmin, withdrawAmount);\n        emit BackstopDisbursed(withdrawAmount);\n    }\n\n    // Update collat ratio after refunding backstop to CHIP or yBXTB holders\n    function adjustBackstop(bool _refunded, uint _amount) external {\n        require((msg.sender == backstopAdmin) || (msg.sender == owner), \"Caller not authorized\");\n\n        if(_refunded == true) totalPoolCHIPBackStop = totalPoolCHIPBackStop.subSafe(_amount);  // Back out refunded amount\n        else totalPoolCHIPBackStop = totalPoolCHIPBackStop.addSafe(_amount);  // Add more. This is used to fix user errors\n\n        // Recalculate collateralization ratio\n        uint wildChip = outstandingCHIP.subSafe(totalPoolCHIPBackStop);\n        if(wildChip > 0) collateralizationRatio = totalPoolUSDTCollateral.mulSafe(100).divSafe(wildChip);  // In percent\n        else collateralizationRatio = 100;\n\n        emit BackstopAdjusted(_refunded, _amount);\n    }\n\n    // Change Recovery Admin for lost coins\n    function changeRecoveryAdmin(address _newAddress) external {\n        require(msg.data.length == 32 + 4, \"Address error\");  // Prevent input error\n        require((msg.sender == recoveryAdmin) || (msg.sender == owner), \"Caller not authorized\");\n        recoveryAdmin = _newAddress;\n    }\n\n    // Change Settlement Admin for daily settlements\n    function changeSettlementAdmin(address _newAddress) external {\n        require(msg.data.length == 32 + 4, \"Address error\");  // Prevent input error\n        require((msg.sender == settlementAdmin) || (msg.sender == owner), \"Caller not authorized\");\n        settlementAdmin = _newAddress;\n    }\n\n    // Change Backstop Admin for managing backstop balance\n    function changeBackstopAdmin(address _newAddress) external {\n        require(msg.data.length == 32 + 4, \"Address error\");  // Prevent input error\n        require((msg.sender == backstopAdmin) || (msg.sender == owner), \"Caller not authorized\");\n        backstopAdmin = _newAddress;\n    }\n\n    // Change BXBT Foundation Address\n    function changeBxtbFoundation(address _newAddress) external {\n        require(msg.data.length == 32 + 4, \"Address error\");  // Prevent input error\n        require(msg.sender == bxtbFoundation, \"Caller not authorized\");\n        bxtbFoundation = _newAddress;\n    }\n\n    // Change BXTB-to-USDT ratio for staking, and BXTB-to-YieldToken ratio redemption\n    function changebxtbTokenRatio(uint _newRatio) external {\n        require(msg.sender == bxtbFoundation, \"Caller not authorized\");\n        bxtbTokenRatio = _newRatio;\n        emit ChangeBxtbTokenRatio(_newRatio);\n    }\n\n    function setAllowStaking(bool _allow) external onlyOwner {\n        allowStaking = _allow;\n    }\n\n    function setAllowCommissions(bool _allow) external onlyOwner {\n        allowCommissions = _allow;\n    }\n\n    // Retrieve lost coins (USDT, BXTB, YieldToken, CHIP)\n    // If coins are accidentally sent to the contract, calling this function will recover them\n    function recoverLostCoins(uint _amount, address _fromTokenContract, address _recoveryAddress) external {\n        require(msg.data.length == (3 * 32) + 4, \"Input length error\");\n\n        bool hasAdmin;\n        if(recoveryAdmin != address(0)) {\n            if(msg.sender == recoveryAdmin) {\n                hasAdmin = true;\n            }\n            else if(_fromTokenContract == BXTBContract) {\n                // But also let foundation call for BXTB\n                if(bxtbFoundation != address(0)) {\n                    if(msg.sender != bxtbFoundation) revert(\"Caller must be admin\");\n                }\n                else revert(\"Caller must be admin\");\n            }\n            else revert(\"Caller must be admin\");\n        }\n\n        if(_fromTokenContract == USDTContract) recoverLostUSDT(_amount, _fromTokenContract, _recoveryAddress, msg.sender, hasAdmin);\n        else if(_fromTokenContract == BXTBContract) recoverLostBXTB(_amount, _fromTokenContract, _recoveryAddress, msg.sender, hasAdmin);\n        else recoverLostERC20(_amount, _fromTokenContract, _recoveryAddress, msg.sender, hasAdmin);\n    }\n\n    function recoverLostUSDT(uint _amount, address _fromTokenContract, address _recoveryAddress, address _sender, bool _hasAdmin) internal {\n        uint amountAdmin;\n        uint amountOwner;\n        uint amountRecoveryAddress;\n        uint amountSender;\n\n        uint sweepAmount;\n        uint recoverAmount;\n\n        // How much is lost in this contract?\n        sweepAmount = ERC20_USDT(_fromTokenContract).balanceOf(address(this));\n        if(sweepAmount > totalPoolUSDTCollateral) {\n            sweepAmount = sweepAmount.subSafe(totalPoolUSDTCollateral);\n\n            // Retrieve amount\n            if(_amount <= sweepAmount) {\n                recoverAmount = _amount.mulSafe(3).divSafe(4);\n                sweepAmount = sweepAmount.subSafe(recoverAmount);\n            }\n\n            if(_hasAdmin) {\n                // Send 1/4 + swept up amounts to admin\n                amountAdmin = sweepAmount;\n\n                // Send 3/4 to recovery address or admin\n                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\n                else amountAdmin = amountAdmin.addSafe(recoverAmount);\n            }\n            else {\n                // Send 1/4 fees + swept up amounts to: Owner\n                amountOwner = sweepAmount;\n\n                // Send 3/4 balance to: Recovery address, Sender\n                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\n                else amountSender = recoverAmount;\n            }\n\n            if(amountAdmin > 0) ERC20_USDT(_fromTokenContract).transfer(recoveryAdmin, amountAdmin);\n            if(amountOwner > 0) ERC20_USDT(_fromTokenContract).transfer(owner, amountOwner);\n            if(amountRecoveryAddress > 0) ERC20_USDT(_fromTokenContract).transfer(_recoveryAddress, amountRecoveryAddress);\n            if(amountSender > 0) ERC20_USDT(_fromTokenContract).transfer(_sender, amountSender);\n        }\n    }\n\n    function recoverLostBXTB(uint _amount, address _fromTokenContract, address _recoveryAddress, address _sender, bool _hasAdmin) internal {\n        uint amountAdmin;\n        uint amountFoundation;\n        uint amountRecoveryAddress;\n        uint amountSender;\n\n        uint sweepAmount;\n        uint recoverAmount;\n\n        // How much is lost in this contract?\n        sweepAmount = ERC20Interface(_fromTokenContract).balanceOf(address(this));\n        if(sweepAmount > totalPoolBXTB) {\n            sweepAmount = sweepAmount.subSafe(totalPoolBXTB);\n\n            // Retrieve amount\n            if(_amount <= sweepAmount) {\n                recoverAmount = _amount.mulSafe(3).divSafe(4);\n                sweepAmount = sweepAmount.subSafe(recoverAmount);\n            }\n\n            if(_hasAdmin) {\n                // Send 1/4 fees + swept up amounts to: BXTB foundation, Admin\n                if(bxtbFoundation != address(0)) amountFoundation = sweepAmount;\n                else amountAdmin = sweepAmount;\n                // Send 3/4 balance to: Recovery address, Admin\n                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\n                else amountAdmin = amountAdmin.addSafe(recoverAmount);\n            }\n            else {\n                // Send 1/4 fees + swept up amounts to: BXTB foundation, Recovery address, Sender\n                if(bxtbFoundation != address(0)) amountFoundation = sweepAmount;\n                else if(_recoveryAddress != address(0)) amountRecoveryAddress = sweepAmount;\n                else amountSender = sweepAmount;\n\n                // Send 3/4 balance to: Recovery address, Sender\n                if(_recoveryAddress != address(0)) amountRecoveryAddress = amountRecoveryAddress.addSafe(recoverAmount);\n                else amountSender = amountSender.addSafe(recoverAmount);\n            }\n\n            if(amountAdmin > 0) ERC20Interface(_fromTokenContract).transfer(recoveryAdmin, amountAdmin);\n            if(amountFoundation > 0) ERC20Interface(_fromTokenContract).transfer(bxtbFoundation, amountFoundation);\n            if(amountRecoveryAddress > 0) ERC20Interface(_fromTokenContract).transfer(_recoveryAddress, amountRecoveryAddress);\n            if(amountSender > 0) ERC20Interface(_fromTokenContract).transfer(_sender, amountSender);\n        }\n    }\n\n    function recoverLostERC20(uint _amount, address _fromTokenContract, address _recoveryAddress, address _sender, bool _hasAdmin) internal {\n        uint amountAdmin;\n        uint amountOwner;\n        uint amountRecoveryAddress;\n        uint amountSender;\n\n        uint sweepAmount;\n        uint recoverAmount;\n        uint poolSize;\n\n        // How much is lost in this contract?\n        sweepAmount = ERC20Interface(_fromTokenContract).balanceOf(address(this));\n\n        if(_fromTokenContract == yieldTokenContract) poolSize = outstandingYieldToken;\n        else if(_fromTokenContract == CHIPContract) poolSize = outstandingCHIP;\n        else poolSize = 0;\n\n        if(sweepAmount > poolSize) {\n            sweepAmount = sweepAmount.subSafe(poolSize);\n\n            // Retrieve amount\n            if(_amount <= sweepAmount) {\n                recoverAmount = _amount.mulSafe(3).divSafe(4);\n                sweepAmount = sweepAmount.subSafe(recoverAmount);\n            }\n\n            if(_hasAdmin) {\n                // Send 1/4 fees + swept up amounts to: Admin\n                amountAdmin = sweepAmount;\n\n                // Send 3/4 balance to: Recovery address, Admin\n                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\n                else amountAdmin = amountAdmin.addSafe(recoverAmount);\n            }\n            else {\n                // Send 1/4 fees + swept up amounts to: Owner\n                amountOwner = sweepAmount;\n\n                // Send 3/4 balance to: Recovery address, Sender\n                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\n                else amountSender = recoverAmount;\n            }\n\n            if(amountAdmin > 0) ERC20Interface(_fromTokenContract).transfer(recoveryAdmin, amountAdmin);\n            if(amountOwner > 0) ERC20Interface(_fromTokenContract).transfer(owner, amountOwner);\n            if(amountRecoveryAddress > 0) ERC20Interface(_fromTokenContract).transfer(_recoveryAddress, amountRecoveryAddress);\n            if(amountSender > 0) ERC20Interface(_fromTokenContract).transfer(_sender, amountSender);\n        }\n    }\n\n}"}}}