{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/staking/StakingProxy.sol":{"content":"// SPDX-License-Identifier: Apache 2.0\n\n/*\n\n  Original work Copyright 2019 ZeroEx Intl.\n  Modified work Copyright 2020 Rigo Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nimport \"./libs/LibSafeDowncast.sol\";\nimport \"./immutable/MixinStorage.sol\";\nimport \"./immutable/MixinConstants.sol\";\nimport \"./interfaces/IStorageInit.sol\";\nimport \"./interfaces/IStakingProxy.sol\";\n\n\n/// #dev The RigoBlock Staking contract.\ncontract StakingProxy is\n    IStakingProxy,\n    MixinStorage,\n    MixinConstants\n{\n    using LibSafeDowncast for uint256;\n\n    /// @dev Constructor.\n    /// @param _stakingContract Staking contract to delegate calls to.\n    constructor(address _stakingContract)\n        MixinStorage()\n    {\n        // Deployer address must be authorized in order to call `init`\n        _addAuthorizedAddress(msg.sender);\n\n        // Attach the staking contract and initialize state\n        _attachStakingContract(_stakingContract);\n\n        // Remove the sender as an authorized address\n        _removeAuthorizedAddressAtIndex(msg.sender, 0);\n    }\n\n    /// @dev Delegates calls to the staking contract, if it is set.\n    fallback()\n        external\n    {\n        // Sanity check that we have a staking contract to call\n        address stakingContract_ = stakingContract;\n        if (stakingContract_ == NIL_ADDRESS) {\n            LibRichErrors.rrevert(\n                LibStakingRichErrors.ProxyDestinationCannotBeNilError()\n            );\n        }\n\n        // Call the staking contract with the provided calldata.\n        (bool success, bytes memory returnData) = stakingContract_.delegatecall(msg.data);\n\n        // Revert on failure or return on success.\n        assembly {\n            switch success\n            case 0 {\n                revert(add(0x20, returnData), mload(returnData))\n            }\n            default {\n                return(add(0x20, returnData), mload(returnData))\n            }\n        }\n    }\n\n    /// @dev Attach a staking contract; future calls will be delegated to the staking contract.\n    /// Note that this is callable only by an authorized address.\n    /// @param _stakingContract Address of staking contract.\n    function attachStakingContract(address _stakingContract)\n        external\n        override\n        onlyAuthorized\n    {\n        _attachStakingContract(_stakingContract);\n    }\n\n    /// @dev Detach the current staking contract.\n    /// Note that this is callable only by an authorized address.\n    function detachStakingContract()\n        external\n        override\n        onlyAuthorized\n    {\n        stakingContract = NIL_ADDRESS;\n        emit StakingContractDetachedFromProxy();\n    }\n\n    /// @dev Batch executes a series of calls to the staking contract.\n    /// @param data An array of data that encodes a sequence of functions to\n    ///             call in the staking contracts.\n    function batchExecute(bytes[] calldata data)\n        external\n        returns (bytes[] memory batchReturnData)\n    {\n        // Initialize commonly used variables.\n        bool success;\n        bytes memory returnData;\n        uint256 dataLength = data.length;\n        batchReturnData = new bytes[](dataLength);\n        address staking = stakingContract;\n\n        // Ensure that a staking contract has been attached to the proxy.\n        if (staking == NIL_ADDRESS) {\n            LibRichErrors.rrevert(\n                LibStakingRichErrors.ProxyDestinationCannotBeNilError()\n            );\n        }\n\n        // Execute all of the calls encoded in the provided calldata.\n        for (uint256 i = 0; i != dataLength; i++) {\n            // Call the staking contract with the provided calldata.\n            (success, returnData) = staking.delegatecall(data[i]);\n\n            // Revert on failure.\n            if (!success) {\n                assembly {\n                    revert(add(0x20, returnData), mload(returnData))\n                }\n            }\n\n            // Add the returndata to the batch returndata.\n            batchReturnData[i] = returnData;\n        }\n\n        return batchReturnData;\n    }\n\n    /// @dev Asserts that an epoch is between 5 and 90 days long.\n    //       Asserts that 0 < cobb douglas alpha value <= 1.\n    //       Asserts that a stake weight is <= 100%.\n    //       Asserts that pools allow >= 1 maker.\n    //       Asserts that all addresses are initialized.\n    function assertValidStorageParams()\n        public\n        view\n        override\n    {\n        // Epoch length must be between 5 and 90 days long\n        uint256 _epochDurationInSeconds = epochDurationInSeconds;\n        if (_epochDurationInSeconds < 5 days || _epochDurationInSeconds > 90 days) {\n            LibRichErrors.rrevert(\n                LibStakingRichErrors.InvalidParamValueError(\n                    LibStakingRichErrors.InvalidParamValueErrorCodes.InvalidEpochDuration\n            ));\n        }\n\n        // Alpha must be 0 < x <= 1\n        uint32 _cobbDouglasAlphaDenominator = cobbDouglasAlphaDenominator;\n        if (cobbDouglasAlphaNumerator > _cobbDouglasAlphaDenominator || _cobbDouglasAlphaDenominator == 0) {\n            LibRichErrors.rrevert(\n                LibStakingRichErrors.InvalidParamValueError(\n                    LibStakingRichErrors.InvalidParamValueErrorCodes.InvalidCobbDouglasAlpha\n            ));\n        }\n\n        // Weight of delegated stake must be <= 100%\n        if (rewardDelegatedStakeWeight > PPM_DENOMINATOR) {\n            LibRichErrors.rrevert(\n                LibStakingRichErrors.InvalidParamValueError(\n                    LibStakingRichErrors.InvalidParamValueErrorCodes.InvalidRewardDelegatedStakeWeight\n            ));\n        }\n\n        // Minimum stake must be > 1\n        if (minimumPoolStake < 2) {\n            LibRichErrors.rrevert(\n                LibStakingRichErrors.InvalidParamValueError(\n                    LibStakingRichErrors.InvalidParamValueErrorCodes.InvalidMinimumPoolStake\n            ));\n        }\n    }\n\n    /// @dev Attach a staking contract; future calls will be delegated to the staking contract.\n    /// @param _stakingContract Address of staking contract.\n    function _attachStakingContract(address _stakingContract)\n        internal\n    {\n        // Attach the staking contract\n        stakingContract = _stakingContract;\n        emit StakingContractAttachedToProxy(_stakingContract);\n\n        // Call `init()` on the staking contract to initialize storage.\n        (bool didInitSucceed, bytes memory initReturnData) = stakingContract.delegatecall(\n            abi.encodeWithSelector(IStorageInit(0).init.selector)\n        );\n\n        if (!didInitSucceed) {\n            assembly {\n                revert(add(initReturnData, 0x20), mload(initReturnData))\n            }\n        }\n\n        // Assert initialized storage values are valid\n        assertValidStorageParams();\n    }\n}\n"},"localhost/staking/immutable/MixinConstants.sol":{"content":"/*\n\n  Original work Copyright 2019 ZeroEx Intl.\n  Modified work Copyright 2020 Rigo Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity >=0.5.9 <0.8.0;\n\n\nabstract contract MixinConstants {\n\n    // 100% in parts-per-million.\n    uint32 constant internal PPM_DENOMINATOR = 10**6;\n\n    bytes32 constant internal NIL_POOL_ID = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    address constant internal NIL_ADDRESS = 0x0000000000000000000000000000000000000000;\n\n    uint256 constant internal MIN_TOKEN_VALUE = 10**18;\n}\n"},"localhost/staking/immutable/MixinStorage.sol":{"content":"/*\n\n  Original work Copyright 2019 ZeroEx Intl.\n  Modified work Copyright 2020 Rigo Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity >=0.5.9 <0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./MixinConstants.sol\";\nimport \"../../utils/0xUtils/LibRichErrors.sol\";\nimport \"../../utils/0xUtils/Authorizable.sol\";\nimport \"../interfaces/IGrgVault.sol\";\nimport \"../interfaces/IStructs.sol\";\nimport \"../libs/LibStakingRichErrors.sol\";\n\n\n// solhint-disable max-states-count, no-empty-blocks\nabstract contract MixinStorage is\n    Authorizable\n{\n    // address of staking contract\n    address public stakingContract;\n\n    // mapping from StakeStatus to global stored balance\n    // NOTE: only Status.DELEGATED is used to access this mapping, but this format\n    // is used for extensibility\n    mapping (uint8 => IStructs.StoredBalance) internal _globalStakeByStatus;\n\n    // mapping from StakeStatus to address of staker to stored balance\n    mapping (uint8 => mapping (address => IStructs.StoredBalance)) internal _ownerStakeByStatus;\n\n    // Mapping from Owner to Pool Id to Amount Delegated\n    mapping (address => mapping (bytes32 => IStructs.StoredBalance)) internal _delegatedStakeToPoolByOwner;\n\n    // Mapping from Pool Id to Amount Delegated\n    mapping (bytes32 => IStructs.StoredBalance) internal _delegatedStakeByPoolId;\n\n    /// @dev Mapping from RigoBlock pool subaccount to pool Id of rigoblock pool\n    /// @dev 0 RigoBlock pool subaccount address.\n    /// @return 0 The pool ID.\n    mapping (address => bytes32) public poolIdByRbPoolAccount;\n\n    // mapping from Pool Id to Pool\n    mapping (bytes32 => IStructs.Pool) internal _poolById;\n\n    /// @dev mapping from pool ID to reward balance of members\n    /// @dev 0 Pool ID.\n    /// @return 0 The total reward balance of members in this pool.\n    mapping (bytes32 => uint256) public rewardsByPoolId;\n\n    // The current epoch.\n    uint256 public currentEpoch;\n\n    // The current epoch start time.\n    uint256 public currentEpochStartTimeInSeconds;\n\n    // mapping from Pool Id to Epoch to Reward Ratio\n    mapping (bytes32 => mapping (uint256 => IStructs.Fraction)) internal _cumulativeRewardsByPool;\n\n    // mapping from Pool Id to Epoch\n    mapping (bytes32 => uint256) internal _cumulativeRewardsByPoolLastStored;\n\n    /// @dev Registered RigoBlock Proof_of_Performance contracts, capable of paying protocol fees.\n    /// @dev 0 The address to check.\n    /// @return 0 Whether the address is a registered proof_of_performance.\n    mapping (address => bool) public validPops;\n\n    /* Tweakable parameters */\n\n    // Minimum seconds between epochs.\n    uint256 public epochDurationInSeconds;\n\n    // How much delegated stake is weighted vs operator stake, in ppm.\n    uint32 public rewardDelegatedStakeWeight;\n\n    // Minimum amount of stake required in a pool to collect rewards.\n    uint256 public minimumPoolStake;\n\n    // Numerator for cobb douglas alpha factor.\n    uint32 public cobbDouglasAlphaNumerator;\n\n    // Denominator for cobb douglas alpha factor.\n    uint32 public cobbDouglasAlphaDenominator;\n\n    /* State for finalization */\n\n    /// @dev Stats for each pool that generated fees with sufficient stake to earn rewards.\n    ///      See `_minimumPoolStake` in `MixinParams`.\n    /// @dev 0 Pool ID.\n    /// @dev 1 Epoch number.\n    /// @return 0 Pool fee stats.\n    mapping (bytes32 => mapping (uint256 => IStructs.PoolStats)) public poolStatsByEpoch;\n\n    /// @dev Aggregated stats across all pools that generated fees with sufficient stake to earn rewards.\n    ///      See `_minimumPoolStake` in MixinParams.\n    /// @dev 0 Epoch number.\n    /// @return 0 Reward computation stats.\n    mapping (uint256 => IStructs.AggregatedStats) public aggregatedStatsByEpoch;\n\n    /// @dev The GRG balance of this contract that is reserved for pool reward payouts.\n    uint256 public grgReservedForPoolRewards;\n}\n"},"localhost/staking/interfaces/IGrgVault.sol":{"content":"/*\n\n  Original work Copyright 2019 ZeroEx Intl.\n  Modified work Copyright 2020 Rigo Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity >=0.5.9 <0.8.0;\n\n\ninterface IGrgVault {\n\n    /// @dev Emmitted whenever a StakingProxy is set in a vault.\n    event StakingProxySet(address stakingProxyAddress);\n\n    /// @dev Emitted when the Staking contract is put into Catastrophic Failure Mode\n    /// @param sender Address of sender (`msg.sender`)\n    event InCatastrophicFailureMode(address sender);\n\n    /// @dev Emitted when Grg Tokens are deposited into the vault.\n    /// @param staker of Grg Tokens.\n    /// @param amount of Grg Tokens deposited.\n    event Deposit(\n        address indexed staker,\n        uint256 amount\n    );\n\n    /// @dev Emitted when Grg Tokens are withdrawn from the vault.\n    /// @param staker of Grg Tokens.\n    /// @param amount of Grg Tokens withdrawn.\n    event Withdraw(\n        address indexed staker,\n        uint256 amount\n    );\n\n    /// @dev Emitted whenever the GRG AssetProxy is set.\n    event GrgProxySet(address grgProxyAddress);\n\n    /// @dev Sets the address of the StakingProxy contract.\n    /// Note that only the contract staker can call this function.\n    /// @param _stakingProxyAddress Address of Staking proxy contract.\n    function setStakingProxy(address _stakingProxyAddress)\n        external;\n\n    /// @dev Vault enters into Catastrophic Failure Mode.\n    /// *** WARNING - ONCE IN CATOSTROPHIC FAILURE MODE, YOU CAN NEVER GO BACK! ***\n    /// Note that only the contract staker can call this function.\n    function enterCatastrophicFailure()\n        external;\n\n    /// @dev Sets the Grg proxy.\n    /// Note that only the contract staker can call this.\n    /// Note that this can only be called when *not* in Catastrophic Failure mode.\n    /// @param grgProxyAddress Address of the RigoBlock Grg Proxy.\n    function setGrgProxy(address grgProxyAddress)\n        external;\n\n    /// @dev Deposit an `amount` of Grg Tokens from `staker` into the vault.\n    /// Note that only the Staking contract can call this.\n    /// Note that this can only be called when *not* in Catastrophic Failure mode.\n    /// @param staker of Grg Tokens.\n    /// @param amount of Grg Tokens to deposit.\n    function depositFrom(address staker, uint256 amount)\n        external;\n\n    /// @dev Withdraw an `amount` of Grg Tokens to `staker` from the vault.\n    /// Note that only the Staking contract can call this.\n    /// Note that this can only be called when *not* in Catastrophic Failure mode.\n    /// @param staker of Grg Tokens.\n    /// @param amount of Grg Tokens to withdraw.\n    function withdrawFrom(address staker, uint256 amount)\n        external;\n\n    /// @dev Withdraw ALL Grg Tokens to `staker` from the vault.\n    /// Note that this can only be called when *in* Catastrophic Failure mode.\n    /// @param staker of Grg Tokens.\n    function withdrawAllFrom(address staker)\n        external\n        returns (uint256);\n\n    /// @dev Returns the balance in Grg Tokens of the `staker`\n    /// @return Balance in Grg.\n    function balanceOf(address staker)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Returns the entire balance of Grg tokens in the vault.\n    function balanceOfGrgVault()\n        external\n        view\n        returns (uint256);\n}\n"},"localhost/staking/interfaces/IStakingProxy.sol":{"content":"/*\n\n  Original work Copyright 2019 ZeroEx Intl.\n  Modified work Copyright 2020 Rigo Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity >=0.5.9 <0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IStructs.sol\";\n\n\nabstract contract IStakingProxy {\n\n    /// @dev Emitted by StakingProxy when a staking contract is attached.\n    /// @param newStakingContractAddress Address of newly attached staking contract.\n    event StakingContractAttachedToProxy(\n        address newStakingContractAddress\n    );\n\n    /// @dev Emitted by StakingProxy when a staking contract is detached.\n    event StakingContractDetachedFromProxy();\n\n    /// @dev Attach a staking contract; future calls will be delegated to the staking contract.\n    /// Note that this is callable only by an authorized address.\n    /// @param _stakingContract Address of staking contract.\n    function attachStakingContract(address _stakingContract)\n        external\n        virtual;\n\n    /// @dev Detach the current staking contract.\n    /// Note that this is callable only by an authorized address.\n    function detachStakingContract()\n        external\n        virtual;\n\n    /// @dev Asserts that an epoch is between 5 and 30 days long.\n    //       Asserts that 0 < cobb douglas alpha value <= 1.\n    //       Asserts that a stake weight is <= 100%.\n    //       Asserts that pools allow >= 1 maker.\n    //       Asserts that all addresses are initialized.\n    function assertValidStorageParams()\n        external\n        view\n        virtual;\n}\n"},"localhost/staking/interfaces/IStorageInit.sol":{"content":"/*\n\n  Original work Copyright 2019 ZeroEx Intl.\n  Modified work Copyright 2020 Rigo Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity >=0.5.9 <0.8.0;\n\n\ninterface IStorageInit {\n\n    /// @dev Initialize storage owned by this contract.\n    function init()\n        external;\n}\n"},"localhost/staking/interfaces/IStructs.sol":{"content":"/*\n\n  Original work Copyright 2019 ZeroEx Intl.\n  Modified work Copyright 2020 Rigo Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity >=0.5.9 <0.8.0;\n\n\ninterface IStructs {\n\n    /// @dev Stats for a pool that earned rewards.\n    /// @param feesCollected Fees collected in ETH by this pool.\n    /// @param weightedStake Amount of weighted stake in the pool.\n    /// @param membersStake Amount of non-operator stake in the pool.\n    struct PoolStats {\n        uint256 feesCollected;\n        uint256 weightedStake;\n        uint256 membersStake;\n    }\n\n    /// @dev Holds stats aggregated across a set of pools.\n    /// @param rewardsAvailable Rewards (ETH) available to the epoch\n    ///        being finalized (the previous epoch). This is simply the balance\n    ///        of the contract at the end of the epoch.\n    /// @param numPoolsToFinalize The number of pools that have yet to be finalized through `finalizePools()`.\n    /// @param totalFeesCollected The total fees collected for the epoch being finalized.\n    /// @param totalWeightedStake The total fees collected for the epoch being finalized.\n    /// @param totalRewardsFinalized Amount of rewards that have been paid during finalization.\n    struct AggregatedStats {\n        uint256 rewardsAvailable;\n        uint256 numPoolsToFinalize;\n        uint256 totalFeesCollected;\n        uint256 totalWeightedStake;\n        uint256 totalRewardsFinalized;\n    }\n\n    /// @dev Encapsulates a balance for the current and next epochs.\n    /// Note that these balances may be stale if the current epoch\n    /// is greater than `currentEpoch`.\n    /// @param currentEpoch The current epoch\n    /// @param currentEpochBalance Balance in the current epoch.\n    /// @param nextEpochBalance Balance in `currentEpoch+1`.\n    struct StoredBalance {\n        uint64 currentEpoch;\n        uint96 currentEpochBalance;\n        uint96 nextEpochBalance;\n    }\n\n    /// @dev Statuses that stake can exist in.\n    ///      Any stake can be (re)delegated effective at the next epoch\n    ///      Undelegated stake can be withdrawn if it is available in both the current and next epoch\n    enum StakeStatus {\n        UNDELEGATED,\n        DELEGATED\n    }\n\n    /// @dev Info used to describe a status.\n    /// @param status Status of the stake.\n    /// @param poolId Unique Id of pool. This is set when status=DELEGATED.\n    struct StakeInfo {\n        StakeStatus status;\n        bytes32 poolId;\n    }\n\n    /// @dev Struct to represent a fraction.\n    /// @param numerator Numerator of fraction.\n    /// @param denominator Denominator of fraction.\n    struct Fraction {\n        uint256 numerator;\n        uint256 denominator;\n    }\n\n    /// @dev Holds the metadata for a staking pool.\n    /// @param operator Operator of the pool.\n    /// @param stakingPal Staking pal of the pool.\n    /// @param operatorShare Fraction of the total balance owned by the operator, in ppm.\n    /// @param stakingPalShare Fraction of the operator reward owned by the staking pal, in ppm.\n    struct Pool {\n        address operator;\n        address stakingPal;\n        uint32 operatorShare;\n        uint32 stakingPalShare;\n    }\n}\n"},"localhost/staking/libs/LibSafeDowncast.sol":{"content":"/*\n\n  Original work Copyright 2019 ZeroEx Intl.\n  Modified work Copyright 2020 Rigo Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity >=0.5.9 <0.8.0;\n\nimport \"../../utils/0xUtils/LibRichErrors.sol\";\nimport \"../../utils/0xUtils/LibSafeMathRichErrors.sol\";\n\n\nlibrary LibSafeDowncast {\n\n    /// @dev Safely downcasts to a uint96\n    /// Note that this reverts if the input value is too large.\n    function downcastToUint96(uint256 a)\n        internal\n        pure\n        returns (uint96 b)\n    {\n        b = uint96(a);\n        if (uint256(b) != a) {\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256DowncastError(\n                LibSafeMathRichErrors.DowncastErrorCodes.VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT96,\n                a\n            ));\n        }\n        return b;\n    }\n\n    /// @dev Safely downcasts to a uint64\n    /// Note that this reverts if the input value is too large.\n    function downcastToUint64(uint256 a)\n        internal\n        pure\n        returns (uint64 b)\n    {\n        b = uint64(a);\n        if (uint256(b) != a) {\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256DowncastError(\n                LibSafeMathRichErrors.DowncastErrorCodes.VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT64,\n                a\n            ));\n        }\n        return b;\n    }\n\n    /// @dev Safely downcasts to a uint32\n    /// Note that this reverts if the input value is too large.\n    function downcastToUint32(uint256 a)\n        internal\n        pure\n        returns (uint32 b)\n    {\n        b = uint32(a);\n        if (uint256(b) != a) {\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256DowncastError(\n                LibSafeMathRichErrors.DowncastErrorCodes.VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT32,\n                a\n            ));\n        }\n        return b;\n    }\n}\n"},"localhost/staking/libs/LibStakingRichErrors.sol":{"content":"/*\n\n  Original work Copyright 2019 ZeroEx Intl.\n  Modified work Copyright 2020 Rigo Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity >=0.5.9 <0.8.0;\n\nimport \"../../utils/0xUtils/LibRichErrors.sol\";\nimport \"../interfaces/IStructs.sol\";\n\n\nlibrary LibStakingRichErrors {\n\n    enum OperatorShareErrorCodes {\n        OperatorShareTooLarge,\n        CanOnlyDecreaseOperatorShare\n    }\n\n    enum InitializationErrorCodes {\n        MixinSchedulerAlreadyInitialized,\n        MixinParamsAlreadyInitialized\n    }\n\n    enum InvalidParamValueErrorCodes {\n        InvalidCobbDouglasAlpha,\n        InvalidRewardDelegatedStakeWeight,\n        InvalidMaximumMakersInPool,\n        InvalidMinimumPoolStake,\n        InvalidEpochDuration\n    }\n\n    enum PopManagerErrorCodes {\n        PopAlreadyRegistered,\n        PopNotRegistered\n    }\n\n    // bytes4(keccak256(\"OnlyCallableByPopError(address)\"))\n    bytes4 internal constant ONLY_CALLABLE_BY_POP_ERROR_SELECTOR =\n        0x61ecb802;\n\n    // bytes4(keccak256(\"PopManagerError(uint8,address)\"))\n    bytes4 internal constant POP_MANAGER_ERROR_SELECTOR =\n        0xb9588e43;\n\n    // bytes4(keccak256(\"InsufficientBalanceError(uint256,uint256)\"))\n    bytes4 internal constant INSUFFICIENT_BALANCE_ERROR_SELECTOR =\n        0x84c8b7c9;\n\n    // bytes4(keccak256(\"OnlyCallableByPoolOperatorError(address,bytes32)\"))\n    bytes4 internal constant ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR =\n        0x82ded785;\n\n    // bytes4(keccak256(\"BlockTimestampTooLowError(uint256,uint256)\"))\n    bytes4 internal constant BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR =\n        0xa6bcde47;\n\n    // bytes4(keccak256(\"OnlyCallableByStakingContractError(address)\"))\n    bytes4 internal constant ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR =\n        0xca1d07a2;\n\n    // bytes4(keccak256(\"OnlyCallableIfInCatastrophicFailureError()\"))\n    bytes internal constant ONLY_CALLABLE_IF_IN_CATASTROPHIC_FAILURE_ERROR =\n        hex\"3ef081cc\";\n\n    // bytes4(keccak256(\"OnlyCallableIfNotInCatastrophicFailureError()\"))\n    bytes internal constant ONLY_CALLABLE_IF_NOT_IN_CATASTROPHIC_FAILURE_ERROR =\n        hex\"7dd020ce\";\n\n    // bytes4(keccak256(\"OperatorShareError(uint8,bytes32,uint32)\"))\n    bytes4 internal constant OPERATOR_SHARE_ERROR_SELECTOR =\n        0x22df9597;\n\n    // bytes4(keccak256(\"PoolExistenceError(bytes32,bool)\"))\n    bytes4 internal constant POOL_EXISTENCE_ERROR_SELECTOR =\n        0x9ae94f01;\n\n    // bytes4(keccak256(\"ProxyDestinationCannotBeNilError()\"))\n    bytes internal constant PROXY_DESTINATION_CANNOT_BE_NIL_ERROR =\n        hex\"6eff8285\";\n\n    // bytes4(keccak256(\"InitializationError(uint8)\"))\n    bytes4 internal constant INITIALIZATION_ERROR_SELECTOR =\n        0x0b02d773;\n\n    // bytes4(keccak256(\"InvalidParamValueError(uint8)\"))\n    bytes4 internal constant INVALID_PARAM_VALUE_ERROR_SELECTOR =\n        0xfc45bd11;\n\n    // bytes4(keccak256(\"InvalidProtocolFeePaymentError(uint256,uint256)\"))\n    bytes4 internal constant INVALID_PROTOCOL_FEE_PAYMENT_ERROR_SELECTOR =\n        0x31d7a505;\n\n    // bytes4(keccak256(\"PreviousEpochNotFinalizedError(uint256,uint256)\"))\n    bytes4 internal constant PREVIOUS_EPOCH_NOT_FINALIZED_ERROR_SELECTOR =\n        0x614b800a;\n\n    // bytes4(keccak256(\"PoolNotFinalizedError(bytes32,uint256)\"))\n    bytes4 internal constant POOL_NOT_FINALIZED_ERROR_SELECTOR =\n        0x5caa0b05;\n\n    // solhint-disable func-name-mixedcase\n    function OnlyCallableByPopError(\n        address senderAddress\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            ONLY_CALLABLE_BY_POP_ERROR_SELECTOR,\n            senderAddress\n        );\n    }\n\n    function PopManagerError(\n        PopManagerErrorCodes errorCodes,\n        address popAddress\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            POP_MANAGER_ERROR_SELECTOR,\n            errorCodes,\n            popAddress\n        );\n    }\n\n    function InsufficientBalanceError(\n        uint256 amount,\n        uint256 balance\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            INSUFFICIENT_BALANCE_ERROR_SELECTOR,\n            amount,\n            balance\n        );\n    }\n\n    function OnlyCallableByPoolOperatorError(\n        address senderAddress,\n        bytes32 poolId\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            ONLY_CALLABLE_BY_POOL_OPERATOR_ERROR_SELECTOR,\n            senderAddress,\n            poolId\n        );\n    }\n\n    function BlockTimestampTooLowError(\n        uint256 epochEndTime,\n        uint256 currentBlockTimestamp\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            BLOCK_TIMESTAMP_TOO_LOW_ERROR_SELECTOR,\n            epochEndTime,\n            currentBlockTimestamp\n        );\n    }\n\n    function OnlyCallableByStakingContractError(\n        address senderAddress\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            ONLY_CALLABLE_BY_STAKING_CONTRACT_ERROR_SELECTOR,\n            senderAddress\n        );\n    }\n\n    function OnlyCallableIfInCatastrophicFailureError()\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return ONLY_CALLABLE_IF_IN_CATASTROPHIC_FAILURE_ERROR;\n    }\n\n    function OnlyCallableIfNotInCatastrophicFailureError()\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return ONLY_CALLABLE_IF_NOT_IN_CATASTROPHIC_FAILURE_ERROR;\n    }\n\n    function OperatorShareError(\n        OperatorShareErrorCodes errorCodes,\n        bytes32 poolId,\n        uint32 operatorShare\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            OPERATOR_SHARE_ERROR_SELECTOR,\n            errorCodes,\n            poolId,\n            operatorShare\n        );\n    }\n\n    function PoolExistenceError(\n        bytes32 poolId,\n        bool alreadyExists\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            POOL_EXISTENCE_ERROR_SELECTOR,\n            poolId,\n            alreadyExists\n        );\n    }\n\n    function InvalidProtocolFeePaymentError(\n        uint256 expectedProtocolFeePaid,\n        uint256 actualProtocolFeePaid\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            INVALID_PROTOCOL_FEE_PAYMENT_ERROR_SELECTOR,\n            expectedProtocolFeePaid,\n            actualProtocolFeePaid\n        );\n    }\n\n    function InitializationError(InitializationErrorCodes code)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            INITIALIZATION_ERROR_SELECTOR,\n            uint8(code)\n        );\n    }\n\n    function InvalidParamValueError(InvalidParamValueErrorCodes code)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            INVALID_PARAM_VALUE_ERROR_SELECTOR,\n            uint8(code)\n        );\n    }\n\n    function ProxyDestinationCannotBeNilError()\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return PROXY_DESTINATION_CANNOT_BE_NIL_ERROR;\n    }\n\n    function PreviousEpochNotFinalizedError(\n        uint256 unfinalizedEpoch,\n        uint256 unfinalizedPoolsRemaining\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            PREVIOUS_EPOCH_NOT_FINALIZED_ERROR_SELECTOR,\n            unfinalizedEpoch,\n            unfinalizedPoolsRemaining\n        );\n    }\n\n    function PoolNotFinalizedError(\n        bytes32 poolId,\n        uint256 epoch\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            POOL_NOT_FINALIZED_ERROR_SELECTOR,\n            poolId,\n            epoch\n        );\n    }\n}\n"},"localhost/utils/0xUtils/Authorizable.sol":{"content":"/*\n\n  Copyright 2019 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity >=0.5.9 <0.8.0;\n\nimport \"./interfaces/IAuthorizable.sol\";\nimport \"./LibAuthorizableRichErrors.sol\";\nimport \"./LibRichErrors.sol\";\nimport \"./Ownable.sol\";\n\n\n// solhint-disable no-empty-blocks\ncontract Authorizable is\n    Ownable,\n    IAuthorizable\n{\n    /// @dev Only authorized addresses can invoke functions with this modifier.\n    modifier onlyAuthorized {\n        _assertSenderIsAuthorized();\n        _;\n    }\n\n    /// @dev Whether an address is authorized to call privileged functions.\n    /// @dev 0 Address to query.\n    /// @return 0 Whether the address is authorized.\n    mapping (address => bool) public authorized;\n    /// @dev Whether an adderss is authorized to call privileged functions.\n    /// @dev 0 Index of authorized address.\n    /// @return 0 Authorized address.\n    address[] public authorities;\n\n    /// @dev Initializes the `owner` address.\n    constructor()\n        Ownable()\n    {}\n\n    /// @dev Authorizes an address.\n    /// @param target Address to authorize.\n    function addAuthorizedAddress(address target)\n        external\n        override\n        onlyOwner\n    {\n        _addAuthorizedAddress(target);\n    }\n\n    /// @dev Removes authorizion of an address.\n    /// @param target Address to remove authorization from.\n    function removeAuthorizedAddress(address target)\n        external\n        override\n        onlyOwner\n    {\n        if (!authorized[target]) {\n            LibRichErrors.rrevert(LibAuthorizableRichErrors.TargetNotAuthorizedError(target));\n        }\n        for (uint256 i = 0; i < authorities.length; i++) {\n            if (authorities[i] == target) {\n                _removeAuthorizedAddressAtIndex(target, i);\n                break;\n            }\n        }\n    }\n\n    /// @dev Removes authorizion of an address.\n    /// @param target Address to remove authorization from.\n    /// @param index Index of target in authorities array.\n    function removeAuthorizedAddressAtIndex(\n        address target,\n        uint256 index\n    )\n        external\n        override\n        onlyOwner\n    {\n        _removeAuthorizedAddressAtIndex(target, index);\n    }\n\n    /// @dev Gets all authorized addresses.\n    /// @return Array of authorized addresses.\n    function getAuthorizedAddresses()\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return authorities;\n    }\n\n    /// @dev Reverts if msg.sender is not authorized.\n    function _assertSenderIsAuthorized()\n        internal\n        view\n    {\n        if (!authorized[msg.sender]) {\n            LibRichErrors.rrevert(LibAuthorizableRichErrors.SenderNotAuthorizedError(msg.sender));\n        }\n    }\n\n    /// @dev Authorizes an address.\n    /// @param target Address to authorize.\n    function _addAuthorizedAddress(address target)\n        internal\n    {\n        // Ensure that the target is not the zero address.\n        if (target == address(0)) {\n            LibRichErrors.rrevert(LibAuthorizableRichErrors.ZeroCantBeAuthorizedError());\n        }\n\n        // Ensure that the target is not already authorized.\n        if (authorized[target]) {\n            LibRichErrors.rrevert(LibAuthorizableRichErrors.TargetAlreadyAuthorizedError(target));\n        }\n\n        authorized[target] = true;\n        authorities.push(target);\n        emit AuthorizedAddressAdded(target, msg.sender);\n    }\n\n    /// @dev Removes authorization of an address.\n    /// @param target Address to remove authorization from.\n    /// @param index Index of target in authorities array.\n    function _removeAuthorizedAddressAtIndex(\n        address target,\n        uint256 index\n    )\n        internal\n    {\n        if (!authorized[target]) {\n            LibRichErrors.rrevert(LibAuthorizableRichErrors.TargetNotAuthorizedError(target));\n        }\n        if (index >= authorities.length) {\n            LibRichErrors.rrevert(LibAuthorizableRichErrors.IndexOutOfBoundsError(\n                index,\n                authorities.length\n            ));\n        }\n        if (authorities[index] != target) {\n            LibRichErrors.rrevert(LibAuthorizableRichErrors.AuthorizedAddressMismatchError(\n                authorities[index],\n                target\n            ));\n        }\n\n        delete authorized[target];\n        authorities[index] = authorities[authorities.length - 1];\n        authorities.pop();\n        emit AuthorizedAddressRemoved(target, msg.sender);\n    }\n}\n"},"localhost/utils/0xUtils/LibAuthorizableRichErrors.sol":{"content":"/*\n  Copyright 2019 ZeroEx Intl.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\npragma solidity >=0.5.9 <0.8.0;\n\n\nlibrary LibAuthorizableRichErrors {\n\n    // bytes4(keccak256(\"AuthorizedAddressMismatchError(address,address)\"))\n    bytes4 internal constant AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR =\n        0x140a84db;\n\n    // bytes4(keccak256(\"IndexOutOfBoundsError(uint256,uint256)\"))\n    bytes4 internal constant INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR =\n        0xe9f83771;\n\n    // bytes4(keccak256(\"SenderNotAuthorizedError(address)\"))\n    bytes4 internal constant SENDER_NOT_AUTHORIZED_ERROR_SELECTOR =\n        0xb65a25b9;\n\n    // bytes4(keccak256(\"TargetAlreadyAuthorizedError(address)\"))\n    bytes4 internal constant TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR =\n        0xde16f1a0;\n\n    // bytes4(keccak256(\"TargetNotAuthorizedError(address)\"))\n    bytes4 internal constant TARGET_NOT_AUTHORIZED_ERROR_SELECTOR =\n        0xeb5108a2;\n\n    // bytes4(keccak256(\"ZeroCantBeAuthorizedError()\"))\n    bytes internal constant ZERO_CANT_BE_AUTHORIZED_ERROR_BYTES =\n        hex\"57654fe4\";\n\n    // solhint-disable func-name-mixedcase\n    function AuthorizedAddressMismatchError(\n        address authorized,\n        address target\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            AUTHORIZED_ADDRESS_MISMATCH_ERROR_SELECTOR,\n            authorized,\n            target\n        );\n    }\n\n    function IndexOutOfBoundsError(\n        uint256 index,\n        uint256 length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            INDEX_OUT_OF_BOUNDS_ERROR_SELECTOR,\n            index,\n            length\n        );\n    }\n\n    function SenderNotAuthorizedError(address sender)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            SENDER_NOT_AUTHORIZED_ERROR_SELECTOR,\n            sender\n        );\n    }\n\n    function TargetAlreadyAuthorizedError(address target)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            TARGET_ALREADY_AUTHORIZED_ERROR_SELECTOR,\n            target\n        );\n    }\n\n    function TargetNotAuthorizedError(address target)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            TARGET_NOT_AUTHORIZED_ERROR_SELECTOR,\n            target\n        );\n    }\n\n    function ZeroCantBeAuthorizedError()\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return ZERO_CANT_BE_AUTHORIZED_ERROR_BYTES;\n    }\n}\n"},"localhost/utils/0xUtils/LibOwnableRichErrors.sol":{"content":"pragma solidity >=0.5.9 <0.8.0;\n\n\nlibrary LibOwnableRichErrors {\n\n    // bytes4(keccak256(\"OnlyOwnerError(address,address)\"))\n    bytes4 internal constant ONLY_OWNER_ERROR_SELECTOR =\n        0x1de45ad1;\n\n    // bytes4(keccak256(\"TransferOwnerToZeroError()\"))\n    bytes internal constant TRANSFER_OWNER_TO_ZERO_ERROR_BYTES =\n        hex\"e69edc3e\";\n\n    // solhint-disable func-name-mixedcase\n    function OnlyOwnerError(\n        address sender,\n        address owner\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            ONLY_OWNER_ERROR_SELECTOR,\n            sender,\n            owner\n        );\n    }\n\n    function TransferOwnerToZeroError()\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return TRANSFER_OWNER_TO_ZERO_ERROR_BYTES;\n    }\n}\n"},"localhost/utils/0xUtils/LibRichErrors.sol":{"content":"/*\n\n  Copyright 2019 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\npragma solidity >=0.5.9 <0.8.0;\n\n\nlibrary LibRichErrors {\n\n    // bytes4(keccak256(\"Error(string)\"))\n    bytes4 internal constant STANDARD_ERROR_SELECTOR =\n        0x08c379a0;\n\n    // solhint-disable func-name-mixedcase\n    /// @dev ABI encode a standard, string revert error payload.\n    ///      This is the same payload that would be included by a `revert(string)`\n    ///      solidity statement. It has the function signature `Error(string)`.\n    /// @param message The error string.\n    /// @return The ABI encoded error.\n    function StandardError(\n        string memory message\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            STANDARD_ERROR_SELECTOR,\n            bytes(message)\n        );\n    }\n    // solhint-enable func-name-mixedcase\n\n    /// @dev Reverts an encoded rich revert reason `errorData`.\n    /// @param errorData ABI encoded error data.\n    function rrevert(bytes memory errorData)\n        internal\n        pure\n    {\n        assembly {\n            revert(add(errorData, 0x20), mload(errorData))\n        }\n    }\n}\n"},"localhost/utils/0xUtils/LibSafeMathRichErrors.sol":{"content":"pragma solidity >=0.5.4 <0.8.0;\n\n\nlibrary LibSafeMathRichErrors {\n\n    // bytes4(keccak256(\"Uint256BinOpError(uint8,uint256,uint256)\"))\n    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR =\n        0xe946c1bb;\n\n    // bytes4(keccak256(\"Uint256DowncastError(uint8,uint256)\"))\n    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR =\n        0xc996af7b;\n\n    enum BinOpErrorCodes {\n        ADDITION_OVERFLOW,\n        MULTIPLICATION_OVERFLOW,\n        SUBTRACTION_UNDERFLOW,\n        DIVISION_BY_ZERO\n    }\n\n    enum DowncastErrorCodes {\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT32,\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT64,\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT96\n    }\n\n    // solhint-disable func-name-mixedcase\n    function Uint256BinOpError(\n        BinOpErrorCodes errorCode,\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            UINT256_BINOP_ERROR_SELECTOR,\n            errorCode,\n            a,\n            b\n        );\n    }\n\n    function Uint256DowncastError(\n        DowncastErrorCodes errorCode,\n        uint256 a\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n            errorCode,\n            a\n        );\n    }\n}\n"},"localhost/utils/0xUtils/Ownable.sol":{"content":"/*\n  Copyright 2019 ZeroEx Intl.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\npragma solidity >=0.5.9 <0.8.0;\n\nimport \"./interfaces/IOwnable.sol\";\nimport \"./LibOwnableRichErrors.sol\";\nimport \"./LibRichErrors.sol\";\n\n\ncontract Ownable is\n    IOwnable\n{\n    /// @dev The owner of this contract.\n    /// @return 0 The owner address.\n    address public owner;\n\n    constructor ()\n    {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        _assertSenderIsOwner();\n        _;\n    }\n\n    /// @dev Change the owner of this contract.\n    /// @param newOwner New owner address.\n    function transferOwnership(address newOwner)\n        public\n        override\n        onlyOwner\n    {\n        if (newOwner == address(0)) {\n            LibRichErrors.rrevert(LibOwnableRichErrors.TransferOwnerToZeroError());\n        } else {\n            owner = newOwner;\n            emit OwnershipTransferred(msg.sender, newOwner);\n        }\n    }\n\n    function _assertSenderIsOwner()\n        internal\n        view\n    {\n        if (msg.sender != owner) {\n            LibRichErrors.rrevert(LibOwnableRichErrors.OnlyOwnerError(\n                msg.sender,\n                owner\n            ));\n        }\n    }\n}\n"},"localhost/utils/0xUtils/interfaces/IAuthorizable.sol":{"content":"/*\n  Copyright 2019 ZeroEx Intl.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\npragma solidity >=0.5.9 <0.8.0;\n\n\nabstract contract IAuthorizable {\n\n    // Event logged when a new address is authorized.\n    event AuthorizedAddressAdded(\n        address indexed target,\n        address indexed caller\n    );\n\n    // Event logged when a currently authorized address is unauthorized.\n    event AuthorizedAddressRemoved(\n        address indexed target,\n        address indexed caller\n    );\n\n    /// @dev Authorizes an address.\n    /// @param target Address to authorize.\n    function addAuthorizedAddress(address target)\n        external\n        virtual;\n\n    /// @dev Removes authorizion of an address.\n    /// @param target Address to remove authorization from.\n    function removeAuthorizedAddress(address target)\n        external\n        virtual;\n\n    /// @dev Removes authorizion of an address.\n    /// @param target Address to remove authorization from.\n    /// @param index Index of target in authorities array.\n    function removeAuthorizedAddressAtIndex(\n        address target,\n        uint256 index\n    )\n        external\n        virtual;\n\n    /// @dev Gets all authorized addresses.\n    /// @return Array of authorized addresses.\n    function getAuthorizedAddresses()\n        external\n        view\n        virtual\n        returns (address[] memory);\n}\n"},"localhost/utils/0xUtils/interfaces/IOwnable.sol":{"content":"/*\n  Copyright 2019 ZeroEx Intl.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\npragma solidity >=0.5.9 <0.8.0;\n\n\nabstract contract IOwnable {\n\n    /// @dev Emitted by Ownable when ownership is transferred.\n    /// @param previousOwner The previous owner of the contract.\n    /// @param newOwner The new owner of the contract.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @dev Transfers ownership of the contract to a new address.\n    /// @param newOwner The address that will become the owner.\n    function transferOwnership(address newOwner)\n        public\n        virtual;\n}\n"}}}