{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 256
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "NestBatchPlatform2.sol": {
      "content": "// Sources flattened with hardhat v2.6.5 https://hardhat.org\r\n\r\n// File contracts/libs/TransferHelper.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestBatchPriceView.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev This contract implemented the mining logic of nest\r\ninterface INestBatchPriceView {\r\n    \r\n    /// @dev Get the latest trigger price\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    function triggeredPrice(uint channelId, uint pairIndex) external view returns (uint blockNumber, uint price);\r\n\r\n    /// @dev Get the full information of latest trigger price\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    /// @return avgPrice Average price\r\n    /// @return sigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \r\n    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\r\n    ///         it means that the volatility has exceeded the range that can be expressed\r\n    function triggeredPriceInfo(uint channelId, uint pairIndex) external view returns (\r\n        uint blockNumber,\r\n        uint price,\r\n        uint avgPrice,\r\n        uint sigmaSQ\r\n    );\r\n\r\n    /// @dev Find the price at block number\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号\r\n    /// @param height Destination block number\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    function findPrice(\r\n        uint channelId, \r\n        uint pairIndex,\r\n        uint height\r\n    ) external view returns (uint blockNumber, uint price);\r\n\r\n    /// @dev Get the last (num) effective price\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号\r\n    /// @param count The number of prices that want to return\r\n    /// @return An array which length is num * 2, each two element expresses one price like blockNumber｜price\r\n    function lastPriceList(uint channelId, uint pairIndex, uint count) external view returns (uint[] memory);\r\n\r\n    /// @dev Returns lastPriceList and triggered price info\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号\r\n    /// @param count The number of prices that want to return\r\n    /// @return prices An array which length is num * 2, each two element expresses one price like blockNumber｜price\r\n    /// @return triggeredPriceBlockNumber The block number of triggered price\r\n    /// @return triggeredPriceValue The token triggered price. (1eth equivalent to (price) token)\r\n    /// @return triggeredAvgPrice Average price\r\n    /// @return triggeredSigmaSQ The square of the volatility (18 decimal places). The current implementation \r\n    /// assumes that the volatility cannot exceed 1. Correspondingly, when the return value is equal to \r\n    /// 999999999999996447, it means that the volatility has exceeded the range that can be expressed\r\n    function lastPriceListAndTriggeredPriceInfo(uint channelId, uint pairIndex, uint count) external view \r\n    returns (\r\n        uint[] memory prices,\r\n        uint triggeredPriceBlockNumber,\r\n        uint triggeredPriceValue,\r\n        uint triggeredAvgPrice,\r\n        uint triggeredSigmaSQ\r\n    );\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestBatchPrice2.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev This contract implemented the mining logic of nest\r\ninterface INestBatchPrice2 {\r\n\r\n    /// @dev Get the latest trigger price\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndices 报价对编号\r\n    /// @param payback 如果费用有多余的，则退回到此地址\r\n    /// @return prices 价格数组, i * 2 为第i个价格所在区块, i * 2 + 1 为第i个价格\r\n    function triggeredPrice(\r\n        uint channelId,\r\n        uint[] calldata pairIndices, \r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n\r\n    /// @dev Get the full information of latest trigger price\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndices 报价对编号\r\n    /// @param payback 如果费用有多余的，则退回到此地址\r\n    /// @return prices 价格数组, i * 4 为第i个价格所在区块, i * 4 + 1 为第i个价格, \r\n    ///         i * 4 + 2 为第i个平均价格, i * 4 + 3 为第i个波动率\r\n    function triggeredPriceInfo(\r\n        uint channelId, \r\n        uint[] calldata pairIndices,\r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n\r\n    /// @dev Find the price at block number\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndices 报价对编号\r\n    /// @param height Destination block number\r\n    /// @param payback 如果费用有多余的，则退回到此地址\r\n    /// @return prices 价格数组, i * 2 为第i个价格所在区块, i * 2 + 1 为第i个价格\r\n    function findPrice(\r\n        uint channelId,\r\n        uint[] calldata pairIndices, \r\n        uint height, \r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n\r\n    /// @dev Get the last (num) effective price\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndices 报价对编号\r\n    /// @param count The number of prices that want to return\r\n    /// @param payback 如果费用有多余的，则退回到此地址\r\n    /// @return prices 结果数组，第 i * count * 2 到 (i + 1) * count * 2 - 1为第i组报价对的价格结果\r\n    function lastPriceList(\r\n        uint channelId, \r\n        uint[] calldata pairIndices, \r\n        uint count, \r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n\r\n    /// @dev Returns lastPriceList and triggered price info\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndices 报价对编号\r\n    /// @param count The number of prices that want to return\r\n    /// @param payback 如果费用有多余的，则退回到此地址\r\n    /// @return prices 结果数组，第 i * (count * 2 + 4)到 (i + 1) * (count * 2 + 4)- 1为第i组报价对的价格结果\r\n    ///         其中前count * 2个为最新价格，后4个依次为：触发价格区块号，触发价格，平均价格，波动率\r\n    function lastPriceListAndTriggeredPriceInfo(\r\n        uint channelId, \r\n        uint[] calldata pairIndices,\r\n        uint count, \r\n        address payback\r\n    ) external payable returns (uint[] memory prices);\r\n}\r\n\r\n\r\n// File contracts/libs/IERC20.sol\r\n\r\n// MIT\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestBatchMining.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev This interface defines the mining methods for nest\r\ninterface INestBatchMining {\r\n    \r\n    /// @dev 开通报价通道\r\n    /// @param channelId 报价通道编号\r\n    /// @param token0 计价代币地址。0表示eth\r\n    /// @param unit token0的单位\r\n    /// @param reward 挖矿代币地址。0表示不挖矿\r\n    event Open(uint channelId, address token0, uint unit, address reward);\r\n\r\n    /// @dev Post event\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号\r\n    /// @param miner Address of miner\r\n    /// @param index Index of the price sheet\r\n    /// @param scale 报价规模\r\n    event Post(uint channelId, uint pairIndex, address miner, uint index, uint scale, uint price);\r\n\r\n    /* ========== Structures ========== */\r\n    \r\n    /// @dev Nest mining configuration structure\r\n    struct Config {\r\n        \r\n        // -- Public configuration\r\n        // The number of times the sheet assets have doubled. 4\r\n        uint8 maxBiteNestedLevel;\r\n        \r\n        // Price effective block interval. 20\r\n        uint16 priceEffectSpan;\r\n\r\n        // The amount of nest to pledge for each post (Unit: 1000). 100\r\n        uint16 pledgeNest;\r\n    }\r\n\r\n    /// @dev PriceSheetView structure\r\n    struct PriceSheetView {\r\n        \r\n        // Index of the price sheet\r\n        uint32 index;\r\n\r\n        // Address of miner\r\n        address miner;\r\n\r\n        // The block number of this price sheet packaged\r\n        uint32 height;\r\n\r\n        // The remain number of this price sheet\r\n        uint32 remainNum;\r\n\r\n        // The eth number which miner will got\r\n        uint32 ethNumBal;\r\n\r\n        // The eth number which equivalent to token's value which miner will got\r\n        uint32 tokenNumBal;\r\n\r\n        // The pledged number of nest in this sheet. (Unit: 1000nest)\r\n        uint24 nestNum1k;\r\n\r\n        // The level of this sheet. 0 expresses initial price sheet, a value greater than 0 expresses bite price sheet\r\n        uint8 level;\r\n\r\n        // Post fee shares, if there are many sheets in one block, this value is used to divide up mining value\r\n        uint8 shares;\r\n\r\n        // The token price. (1eth equivalent to (price) token)\r\n        uint152 price;\r\n    }\r\n\r\n    // 报价通道配置\r\n    struct ChannelConfig {\r\n        // 计价代币地址, 0表示eth\r\n        address token0;\r\n        // 计价代币单位\r\n        uint96 unit;\r\n\r\n        // 矿币地址如果和token0或者token1是一种币，可能导致挖矿资产被当成矿币挖走\r\n        // 出矿代币地址\r\n        address reward;\r\n        // 每个区块的标准出矿量\r\n        uint96 rewardPerBlock;\r\n\r\n        // 矿币总量\r\n        //uint96 vault;\r\n\r\n        // 管理地址\r\n        //address governance;\r\n        // 创世区块\r\n        //uint32 genesisBlock;\r\n        // Post fee(0.0001eth，DIMI_ETHER). 1000\r\n        uint16 postFeeUnit;\r\n        // Single query fee (0.0001 ether, DIMI_ETHER). 100\r\n        uint16 singleFee;\r\n        // 衰减系数，万分制。8000\r\n        uint16 reductionRate;\r\n\r\n        address[] tokens;\r\n    }\r\n\r\n    /// @dev 报价对视图\r\n    struct PairView {\r\n        // 报价代币地址\r\n        address target;\r\n        // 报价单数量\r\n        uint96 sheetCount;\r\n    }\r\n\r\n    /// @dev Price channel view\r\n    struct PriceChannelView {\r\n        \r\n        uint channelId;\r\n\r\n        // 计价代币地址, 0表示eth\r\n        address token0;\r\n        // 计价代币单位\r\n        uint96 unit;\r\n\r\n        // 矿币地址如果和token0或者token1是一种币，可能导致挖矿资产被当成矿币挖走\r\n        // 出矿代币地址\r\n        address reward;\r\n        // 每个区块的标准出矿量\r\n        uint96 rewardPerBlock;\r\n\r\n        // 矿币总量\r\n        uint128 vault;\r\n        // The information of mining fee\r\n        uint96 rewards;\r\n        // Post fee(0.0001eth，DIMI_ETHER). 1000\r\n        uint16 postFeeUnit;\r\n        // 报价对数量\r\n        uint16 count;\r\n\r\n        // 管理地址\r\n        address governance;\r\n        // 创世区块\r\n        uint32 genesisBlock;\r\n        // Single query fee (0.0001 ether, DIMI_ETHER). 100\r\n        uint16 singleFee;\r\n        // 衰减系数，万分制。8000\r\n        uint16 reductionRate;\r\n        \r\n        // 报价对信息\r\n        PairView[] pairs;\r\n    }\r\n\r\n    /* ========== Configuration ========== */\r\n\r\n    /// @dev Modify configuration\r\n    /// @param config Configuration object\r\n    function setConfig(Config calldata config) external;\r\n\r\n    /// @dev Get configuration\r\n    /// @return Configuration object\r\n    function getConfig() external view returns (Config memory);\r\n    \r\n    /// @dev 开通报价通道\r\n    /// @param config 报价通道配置\r\n    function open(ChannelConfig calldata config) external;\r\n\r\n    /// @dev 向报价通道注入矿币\r\n    /// @param channelId 报价通道\r\n    /// @param vault 注入矿币数量\r\n    function increase(uint channelId, uint128 vault) external payable;\r\n\r\n    /// @dev 从报价通道取出矿币\r\n    /// @param channelId 报价通道\r\n    /// @param vault 注入矿币数量\r\n    function decrease(uint channelId, uint128 vault) external;\r\n\r\n    /// @dev 获取报价通道信息\r\n    /// @param channelId 报价通道\r\n    /// @return 报价通道信息\r\n    function getChannelInfo(uint channelId) external view returns (PriceChannelView memory);\r\n\r\n    /// @dev 报价\r\n    /// @param channelId 报价通道id\r\n    /// @param scale 报价规模（token0，单位unit）\r\n    /// @param equivalents 价格数组，索引和报价对一一对应\r\n    function post(uint channelId, uint scale, uint[] calldata equivalents) external payable;\r\n\r\n    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\r\n    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号。吃单方向为拿走计价代币时，直接传报价对编号，吃单方向为拿走报价代币时，报价对编号加65536\r\n    /// @param index The position of the sheet in priceSheetList[token]\r\n    /// @param takeNum The amount of biting (in the unit of ETH), realAmount = takeNum * newTokenAmountPerEth\r\n    /// @param newEquivalent The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\r\n    function take(uint channelId, uint pairIndex, uint index, uint takeNum, uint newEquivalent) external payable;\r\n\r\n    /// @dev List sheets by page\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号\r\n    /// @param offset Skip previous (offset) records\r\n    /// @param count Return (count) records\r\n    /// @param order Order. 0 reverse order, non-0 positive order\r\n    /// @return List of price sheets\r\n    function list(\r\n        uint channelId, \r\n        uint pairIndex, \r\n        uint offset, \r\n        uint count, \r\n        uint order\r\n    ) external view returns (PriceSheetView[] memory);\r\n\r\n    /// @notice Close a batch of price sheets passed VERIFICATION-PHASE\r\n    /// @dev Empty sheets but in VERIFICATION-PHASE aren't allowed\r\n    /// @param channelId 报价通道编号\r\n    /// @param indices 报价单二维数组，外层对应通道号，内层对应报价单号，如果仅关闭后面的报价对，则前面的报价对数组传空数组\r\n    function close(uint channelId, uint[][] calldata indices) external;\r\n\r\n    /// @dev View the number of assets specified by the user\r\n    /// @param tokenAddress Destination token address\r\n    /// @param addr Destination address\r\n    /// @return Number of assets\r\n    function balanceOf(address tokenAddress, address addr) external view returns (uint);\r\n\r\n    /// @dev Withdraw assets\r\n    /// @param tokenAddress Destination token address\r\n    /// @param value The value to withdraw\r\n    function withdraw(address tokenAddress, uint value) external;\r\n\r\n    /// @dev Estimated mining amount\r\n    /// @param channelId 报价通道编号\r\n    /// @return Estimated mining amount\r\n    function estimate(uint channelId) external view returns (uint);\r\n\r\n    /// @dev Query the quantity of the target quotation\r\n    /// @param channelId 报价通道编号\r\n    /// @param index The index of the sheet\r\n    /// @return minedBlocks Mined block period from previous block\r\n    /// @return totalShares Total shares of sheets in the block\r\n    function getMinedBlocks(\r\n        uint channelId,\r\n        uint index\r\n    ) external view returns (uint minedBlocks, uint totalShares);\r\n\r\n    /// @dev The function returns eth rewards of specified ntoken\r\n    /// @param channelId 报价通道编号\r\n    function totalETHRewards(uint channelId) external view returns (uint);\r\n\r\n    /// @dev Pay\r\n    /// @param channelId 报价通道编号\r\n    /// @param to Address to receive\r\n    /// @param value Amount to receive\r\n    function pay(uint channelId, address to, uint value) external;\r\n\r\n    /// @dev 向DAO捐赠\r\n    /// @param channelId 报价通道\r\n    /// @param value Amount to receive\r\n    function donate(uint channelId, uint value) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestLedger.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev This interface defines the nest ledger methods\r\ninterface INestLedger {\r\n\r\n    /// @dev Application Flag Changed event\r\n    /// @param addr DAO application contract address\r\n    /// @param flag Authorization flag, 1 means authorization, 0 means cancel authorization\r\n    event ApplicationChanged(address addr, uint flag);\r\n    \r\n    /// @dev Set DAO application\r\n    /// @param addr DAO application contract address\r\n    /// @param flag Authorization flag, 1 means authorization, 0 means cancel authorization\r\n    function setApplication(address addr, uint flag) external;\r\n\r\n    /// @dev Check DAO application flag\r\n    /// @param addr DAO application contract address\r\n    /// @return Authorization flag, 1 means authorization, 0 means cancel authorization\r\n    function checkApplication(address addr) external view returns (uint);\r\n\r\n    /// @dev Add reward\r\n    /// @param channelId 报价通道\r\n    function addETHReward(uint channelId) external payable;\r\n\r\n    /// @dev The function returns eth rewards of specified ntoken\r\n    /// @param channelId 报价通道\r\n    function totalETHRewards(uint channelId) external view returns (uint);\r\n\r\n    /// @dev Pay\r\n    /// @param channelId 报价通道\r\n    /// @param tokenAddress Token address of receiving funds (0 means ETH)\r\n    /// @param to Address to receive\r\n    /// @param value Amount to receive\r\n    function pay(uint channelId, address tokenAddress, address to, uint value) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/INToken.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev ntoken interface\r\ninterface INToken {\r\n        \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /// @dev Mint \r\n    /// @param value The amount of NToken to add\r\n    function increaseTotal(uint256 value) external;\r\n\r\n    /// @notice The view of variables about minting \r\n    /// @dev The naming follows nest v3.0\r\n    /// @return createBlock The block number where the contract was created\r\n    /// @return recentlyUsedBlock The block number where the last minting went\r\n    function checkBlockInfo() external view returns(uint256 createBlock, uint256 recentlyUsedBlock);\r\n\r\n    /// @dev The ABI keeps unchanged with old NTokens, so as to support token-and-ntoken-mining\r\n    /// @return The address of bidder\r\n    function checkBidder() external view returns(address);\r\n    \r\n    /// @notice The view of totalSupply\r\n    /// @return The total supply of ntoken\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// @dev The view of balances\r\n    /// @param owner The address of an account\r\n    /// @return The balance of the account\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256); \r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestMapping.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n\r\n/// @dev The interface defines methods for nest builtin contract address mapping\r\ninterface INestMapping {\r\n\r\n    /// @dev Set the built-in contract address of the system\r\n    /// @param nestTokenAddress Address of nest token contract\r\n    /// @param nestNodeAddress Address of nest node contract\r\n    /// @param nestLedgerAddress INestLedger implementation contract address\r\n    /// @param nestMiningAddress INestMining implementation contract address for nest\r\n    /// @param ntokenMiningAddress INestMining implementation contract address for ntoken\r\n    /// @param nestPriceFacadeAddress INestPriceFacade implementation contract address\r\n    /// @param nestVoteAddress INestVote implementation contract address\r\n    /// @param nestQueryAddress INestQuery implementation contract address\r\n    /// @param nnIncomeAddress NNIncome contract address\r\n    /// @param nTokenControllerAddress INTokenController implementation contract address\r\n    function setBuiltinAddress(\r\n        address nestTokenAddress,\r\n        address nestNodeAddress,\r\n        address nestLedgerAddress,\r\n        address nestMiningAddress,\r\n        address ntokenMiningAddress,\r\n        address nestPriceFacadeAddress,\r\n        address nestVoteAddress,\r\n        address nestQueryAddress,\r\n        address nnIncomeAddress,\r\n        address nTokenControllerAddress\r\n    ) external;\r\n\r\n    /// @dev Get the built-in contract address of the system\r\n    /// @return nestTokenAddress Address of nest token contract\r\n    /// @return nestNodeAddress Address of nest node contract\r\n    /// @return nestLedgerAddress INestLedger implementation contract address\r\n    /// @return nestMiningAddress INestMining implementation contract address for nest\r\n    /// @return ntokenMiningAddress INestMining implementation contract address for ntoken\r\n    /// @return nestPriceFacadeAddress INestPriceFacade implementation contract address\r\n    /// @return nestVoteAddress INestVote implementation contract address\r\n    /// @return nestQueryAddress INestQuery implementation contract address\r\n    /// @return nnIncomeAddress NNIncome contract address\r\n    /// @return nTokenControllerAddress INTokenController implementation contract address\r\n    function getBuiltinAddress() external view returns (\r\n        address nestTokenAddress,\r\n        address nestNodeAddress,\r\n        address nestLedgerAddress,\r\n        address nestMiningAddress,\r\n        address ntokenMiningAddress,\r\n        address nestPriceFacadeAddress,\r\n        address nestVoteAddress,\r\n        address nestQueryAddress,\r\n        address nnIncomeAddress,\r\n        address nTokenControllerAddress\r\n    );\r\n\r\n    /// @dev Get address of nest token contract\r\n    /// @return Address of nest token contract\r\n    function getNestTokenAddress() external view returns (address);\r\n\r\n    /// @dev Get address of nest node contract\r\n    /// @return Address of nest node contract\r\n    function getNestNodeAddress() external view returns (address);\r\n\r\n    /// @dev Get INestLedger implementation contract address\r\n    /// @return INestLedger implementation contract address\r\n    function getNestLedgerAddress() external view returns (address);\r\n\r\n    /// @dev Get INestMining implementation contract address for nest\r\n    /// @return INestMining implementation contract address for nest\r\n    function getNestMiningAddress() external view returns (address);\r\n\r\n    /// @dev Get INestMining implementation contract address for ntoken\r\n    /// @return INestMining implementation contract address for ntoken\r\n    function getNTokenMiningAddress() external view returns (address);\r\n\r\n    /// @dev Get INestPriceFacade implementation contract address\r\n    /// @return INestPriceFacade implementation contract address\r\n    function getNestPriceFacadeAddress() external view returns (address);\r\n\r\n    /// @dev Get INestVote implementation contract address\r\n    /// @return INestVote implementation contract address\r\n    function getNestVoteAddress() external view returns (address);\r\n\r\n    /// @dev Get INestQuery implementation contract address\r\n    /// @return INestQuery implementation contract address\r\n    function getNestQueryAddress() external view returns (address);\r\n\r\n    /// @dev Get NNIncome contract address\r\n    /// @return NNIncome contract address\r\n    function getNnIncomeAddress() external view returns (address);\r\n\r\n    /// @dev Get INTokenController implementation contract address\r\n    /// @return INTokenController implementation contract address\r\n    function getNTokenControllerAddress() external view returns (address);\r\n\r\n    /// @dev Registered address. The address registered here is the address accepted by nest system\r\n    /// @param key The key\r\n    /// @param addr Destination address. 0 means to delete the registration information\r\n    function registerAddress(string memory key, address addr) external;\r\n\r\n    /// @dev Get registered address\r\n    /// @param key The key\r\n    /// @return Destination address. 0 means empty\r\n    function checkAddress(string memory key) external view returns (address);\r\n}\r\n\r\n\r\n// File contracts/interfaces/INestGovernance.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev This interface defines the governance methods\r\ninterface INestGovernance is INestMapping {\r\n\r\n    /// @dev Set governance authority\r\n    /// @param addr Destination address\r\n    /// @param flag Weight. 0 means to delete the governance permission of the target address. Weight is not \r\n    ///        implemented in the current system, only the difference between authorized and unauthorized. \r\n    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\r\n    function setGovernance(address addr, uint flag) external;\r\n\r\n    /// @dev Get governance rights\r\n    /// @param addr Destination address\r\n    /// @return Weight. 0 means to delete the governance permission of the target address. Weight is not \r\n    ///        implemented in the current system, only the difference between authorized and unauthorized. \r\n    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\r\n    function getGovernance(address addr) external view returns (uint);\r\n\r\n    /// @dev Check whether the target address has governance rights for the given target\r\n    /// @param addr Destination address\r\n    /// @param flag Permission weight. The permission of the target address must be greater than this weight \r\n    /// to pass the check\r\n    /// @return True indicates permission\r\n    function checkGovernance(address addr, uint flag) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/NestBase.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev Base contract of nest\r\ncontract NestBase {\r\n\r\n    // Address of nest token contract\r\n    address constant NEST_TOKEN_ADDRESS = 0x04abEdA201850aC0124161F037Efd70c74ddC74C;\r\n    \r\n    // Genesis block number of nest\r\n    // NEST token contract is created at block height 6913517. However, because the mining algorithm of nest1.0\r\n    // is different from that at present, a new mining algorithm is adopted from nest2.0. The new algorithm\r\n    // includes the attenuation logic according to the block. Therefore, it is necessary to trace the block\r\n    // where the nest begins to decay. According to the circulation when nest2.0 is online, the new mining\r\n    // algorithm is used to deduce and convert the nest, and the new algorithm is used to mine the nest2.0\r\n    // on-line flow, the actual block is 5120000\r\n    //uint constant NEST_GENESIS_BLOCK = 0;\r\n\r\n    /// @dev To support open-zeppelin/upgrades\r\n    /// @param nestGovernanceAddress INestGovernance implementation contract address\r\n    function initialize(address nestGovernanceAddress) public virtual {\r\n        require(_governance == address(0), \"NEST:!initialize\");\r\n        _governance = nestGovernanceAddress;\r\n    }\r\n\r\n    /// @dev INestGovernance implementation contract address\r\n    address public _governance;\r\n\r\n    /// @dev Rewritten in the implementation contract, for load other contract addresses. Call \r\n    ///      super.update(nestGovernanceAddress) when overriding, and override method without onlyGovernance\r\n    /// @param nestGovernanceAddress INestGovernance implementation contract address\r\n    function update(address nestGovernanceAddress) public virtual {\r\n\r\n        address governance = _governance;\r\n        require(governance == msg.sender || INestGovernance(governance).checkGovernance(msg.sender, 0), \"NEST:!gov\");\r\n        _governance = nestGovernanceAddress;\r\n    }\r\n\r\n    // /// @dev Migrate funds from current contract to NestLedger\r\n    // /// @param tokenAddress Destination token address.(0 means eth)\r\n    // /// @param value Migrate amount\r\n    // function migrate(address tokenAddress, uint value) external onlyGovernance {\r\n\r\n    //     address to = INestGovernance(_governance).getNestLedgerAddress();\r\n    //     if (tokenAddress == address(0)) {\r\n    //         INestLedger(to).addETHReward { value: value } (0);\r\n    //     } else {\r\n    //         TransferHelper.safeTransfer(tokenAddress, to, value);\r\n    //     }\r\n    // }\r\n\r\n    //---------modifier------------\r\n\r\n    modifier onlyGovernance() {\r\n        require(INestGovernance(_governance).checkGovernance(msg.sender, 0), \"NEST:!gov\");\r\n        _;\r\n    }\r\n\r\n    modifier noContract() {\r\n        require(msg.sender == tx.origin, \"NEST:!contract\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/NestBatchMining.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n/// @dev This contract implemented the mining logic of nest\r\ncontract NestBatchMining is NestBase, INestBatchMining {\r\n\r\n    /// @dev To support open-zeppelin/upgrades\r\n    /// @param nestGovernanceAddress INestGovernance implementation contract address\r\n    function initialize(address nestGovernanceAddress) public override {\r\n        super.initialize(nestGovernanceAddress);\r\n        // Placeholder in _accounts, the index of a real account must greater than 0\r\n        _accounts.push();\r\n    }\r\n\r\n    /// @dev Definitions for the price sheet, include the full information. \r\n    /// (use 256-bits, a storage unit in ethereum evm)\r\n    struct PriceSheet {\r\n        \r\n        // Index of miner account in _accounts. for this way, mapping an address(which need 160-bits) to a 32-bits \r\n        // integer, support 4 billion accounts\r\n        uint32 miner;\r\n\r\n        // The block number of this price sheet packaged\r\n        uint32 height;\r\n\r\n        // The remain number of this price sheet\r\n        uint32 remainNum;\r\n\r\n        // The eth number which miner will got\r\n        uint32 ethNumBal;\r\n\r\n        // The eth number which equivalent to token's value which miner will got\r\n        uint32 tokenNumBal;\r\n\r\n        // The pledged number of nest in this sheet. (Unit: 1000nest)\r\n        uint24 nestNum1k;\r\n\r\n        // The level of this sheet. 0 expresses initial price sheet, a value greater than 0 expresses bite price sheet\r\n        uint8 level;\r\n\r\n        // Post fee shares, if there are many sheets in one block, this value is used to divide up mining value\r\n        uint8 shares;\r\n\r\n        // Represent price as this way, may lose precision, the error less than 1/10^14\r\n        // price = priceFraction * 16 ^ priceExponent\r\n        uint56 priceFloat;\r\n    }\r\n\r\n    /// @dev Definitions for the price information\r\n    struct PriceInfo {\r\n\r\n        // Record the index of price sheet, for update price information from price sheet next time.\r\n        uint32 index;\r\n\r\n        // The block number of this price\r\n        uint32 height;\r\n\r\n        // The remain number of this price sheet\r\n        uint32 remainNum;\r\n\r\n        // Price, represent as float\r\n        // Represent price as this way, may lose precision, the error less than 1/10^14\r\n        uint56 priceFloat;\r\n\r\n        // Avg Price, represent as float\r\n        // Represent price as this way, may lose precision, the error less than 1/10^14\r\n        uint56 avgFloat;\r\n\r\n        // Square of price volatility, need divide by 2^48\r\n        uint48 sigmaSQ;\r\n    }\r\n\r\n    // 报价对\r\n    struct PricePair {\r\n        address target;\r\n        PriceInfo price;\r\n        PriceSheet[] sheets;    \r\n    }\r\n\r\n    /// @dev Price channel\r\n    struct PriceChannel {\r\n\r\n        // 计价代币地址, 0表示eth\r\n        address token0;\r\n        // 计价代币单位\r\n        uint96 unit;\r\n\r\n        // 出矿代币地址\r\n        address reward;        \r\n        // 每个区块的标准出矿量\r\n        uint96 rewardPerBlock;\r\n\r\n        // 矿币总量\r\n        uint128 vault;        \r\n        // The information of mining fee\r\n        uint96 rewards;\r\n        // Post fee(0.0001eth，DIMI_ETHER). 1000\r\n        uint16 postFeeUnit;\r\n        // 报价对数量\r\n        uint16 count;\r\n\r\n        // 管理地址\r\n        address governance;\r\n        // 创世区块\r\n        uint32 genesisBlock;\r\n        // Single query fee (0.0001 ether, DIMI_ETHER). 100\r\n        uint16 singleFee;\r\n        // 衰减系数，万分制。8000\r\n        uint16 reductionRate;\r\n        \r\n        // 报价对数组\r\n        PricePair[0xFFFF] pairs;\r\n    }\r\n\r\n    /// @dev Structure is used to represent a storage location. Storage variable can be used to avoid indexing \r\n    /// from mapping many times\r\n    struct UINT {\r\n        uint value;\r\n    }\r\n\r\n    /// @dev Account information\r\n    struct Account {\r\n        \r\n        // Address of account\r\n        address addr;\r\n\r\n        // Balances of mining account\r\n        // tokenAddress=>balance\r\n        mapping(address=>UINT) balances;\r\n    }\r\n\r\n    // Configuration\r\n    Config _config;\r\n\r\n    // Registered account information\r\n    Account[] _accounts;\r\n\r\n    // Mapping from address to index of account. address=>accountIndex\r\n    mapping(address=>uint) _accountMapping;\r\n\r\n    // 报价通道映射，通过此映射避免重复添加报价通道\r\n    //mapping(uint=>uint) _channelMapping;\r\n\r\n    // 报价通道\r\n    PriceChannel[] _channels;\r\n\r\n    // Unit of post fee. 0.0001 ether\r\n    uint constant DIMI_ETHER = 0.0001 ether;\r\n\r\n    // Ethereum average block time interval, 14 seconds\r\n    uint constant ETHEREUM_BLOCK_TIMESPAN = 14;\r\n\r\n    // Nest ore drawing attenuation interval. 2400000 blocks, about one year\r\n    uint constant NEST_REDUCTION_SPAN = 2400000;\r\n    // The decay limit of nest ore drawing becomes stable after exceeding this interval. \r\n    // 24 million blocks, about 10 years\r\n    uint constant NEST_REDUCTION_LIMIT = 24000000; //NEST_REDUCTION_SPAN * 10;\r\n    // Attenuation gradient array, each attenuation step value occupies 16 bits. The attenuation value is an integer\r\n    uint constant NEST_REDUCTION_STEPS = 0x280035004300530068008300A300CC010001400190;\r\n        // 0\r\n        // | (uint(400 / uint(1)) << (16 * 0))\r\n        // | (uint(400 * 8 / uint(10)) << (16 * 1))\r\n        // | (uint(400 * 8 * 8 / uint(10 * 10)) << (16 * 2))\r\n        // | (uint(400 * 8 * 8 * 8 / uint(10 * 10 * 10)) << (16 * 3))\r\n        // | (uint(400 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10)) << (16 * 4))\r\n        // | (uint(400 * 8 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10 * 10)) << (16 * 5))\r\n        // | (uint(400 * 8 * 8 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10 * 10 * 10)) << (16 * 6))\r\n        // | (uint(400 * 8 * 8 * 8 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10 * 10 * 10 * 10)) << (16 * 7))\r\n        // | (uint(400 * 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10 * 10 * 10 * 10 * 10)) << (16 * 8))\r\n        // | (uint(400 * 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10)) << (16 * 9))\r\n        // //| (uint(400 * 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10)) << (16 * 10));\r\n        // | (uint(40) << (16 * 10));\r\n\r\n    /* ========== Governance ========== */\r\n\r\n    /// @dev Modify configuration\r\n    /// @param config Configuration object\r\n    function setConfig(Config calldata config) external override onlyGovernance {\r\n        _config = config;\r\n    }\r\n\r\n    /// @dev Get configuration\r\n    /// @return Configuration object\r\n    function getConfig() external view override returns (Config memory) {\r\n        return _config;\r\n    }\r\n\r\n    /// @dev 开通报价通道\r\n    /// @param config 报价通道配置\r\n    function open(ChannelConfig calldata config) external override {\r\n\r\n        // 计价代币\r\n        address token0 = config.token0;\r\n        // 矿币\r\n        address reward = config.reward;\r\n\r\n        // 触发开通事件\r\n        emit Open(_channels.length, token0, config.unit, reward);\r\n        \r\n        PriceChannel storage channel = _channels.push();\r\n\r\n        // 计价代币\r\n        channel.token0 = token0;\r\n        // 计价代币单位\r\n        channel.unit = config.unit;\r\n\r\n        // 矿币\r\n        channel.reward = reward;\r\n        // 单位区块出矿币数量\r\n        channel.rewardPerBlock = config.rewardPerBlock;\r\n\r\n        channel.vault = uint128(0);\r\n        channel.rewards = uint96(0);\r\n        // Post fee(0.0001eth，DIMI_ETHER). 1000\r\n        channel.postFeeUnit = config.postFeeUnit;\r\n        channel.count = uint16(config.tokens.length);\r\n        \r\n        // 管理地址\r\n        channel.governance = msg.sender;\r\n        // 创世区块\r\n        channel.genesisBlock = uint32(block.number);\r\n        // Single query fee (0.0001 ether, DIMI_ETHER). 100\r\n        channel.singleFee = config.singleFee;\r\n        // 衰减系数，万分制。8000\r\n        channel.reductionRate = config.reductionRate;\r\n\r\n        // 遍历创建报价对\r\n        for (uint i = 0; i < config.tokens.length; ++i) {\r\n            require(token0 != config.tokens[i], \"NOM:token can't equal token0\");\r\n            for (uint j = 0; j < i; ++j) {\r\n                require(config.tokens[i] != config.tokens[j], \"NOM:token reiterated\");\r\n            }\r\n            channel.pairs[i].target = config.tokens[i];\r\n        }\r\n    }\r\n\r\n    /// @dev 添加报价代币，与计价代币形成新的报价对（暂不支持删除，请谨慎添加）\r\n    /// @param channelId 报价通道\r\n    /// @param target 目标代币地址\r\n    function addPair(uint channelId, address target) external {\r\n        PriceChannel storage channel = _channels[channelId];\r\n        require(channel.governance == msg.sender, \"NOM:not governance\");\r\n        require(channel.token0 != target, \"NOM:token can't equal token0\");\r\n        uint count = uint(channel.count);\r\n        for (uint j = 0; j < count; ++j) {\r\n            require(channel.pairs[j].target != target, \"NOM:token reiterated\");\r\n        }\r\n        channel.pairs[count].target = target;\r\n        ++channel.count;\r\n    }\r\n\r\n    /// @dev 向报价通道注入矿币\r\n    /// @param channelId 报价通道\r\n    /// @param vault 注入矿币数量\r\n    function increase(uint channelId, uint128 vault) external payable override {\r\n        PriceChannel storage channel = _channels[channelId];\r\n        address reward = channel.reward;\r\n        if (reward == address(0)) {\r\n            require(msg.value == uint(vault), \"NOM:vault error\");\r\n        } else {\r\n            TransferHelper.safeTransferFrom(reward, msg.sender, address(this), uint(vault));\r\n        }\r\n        channel.vault += vault;\r\n    }\r\n\r\n    /// @dev 从报价通道取出矿币\r\n    /// @param channelId 报价通道\r\n    /// @param vault 取出矿币数量\r\n    function decrease(uint channelId, uint128 vault) external override {\r\n        PriceChannel storage channel = _channels[channelId];\r\n        require(channel.governance == msg.sender, \"NOM:not governance\");\r\n        address reward = channel.reward;\r\n        channel.vault -= vault;\r\n        if (reward == address(0)) {\r\n            payable(msg.sender).transfer(uint(vault));\r\n        } else {\r\n            TransferHelper.safeTransfer(reward, msg.sender, uint(vault));\r\n        }\r\n    }\r\n\r\n    /// @dev 修改治理权限地址\r\n    /// @param channelId 报价通道\r\n    /// @param newGovernance 新治理权限地址\r\n    function changeGovernance(uint channelId, address newGovernance) external {\r\n        PriceChannel storage channel = _channels[channelId];\r\n        require(channel.governance == msg.sender, \"NOM:not governance\");\r\n        channel.governance = newGovernance;\r\n    }\r\n\r\n    /// @dev 获取报价通道信息\r\n    /// @param channelId 报价通道\r\n    /// @return 报价通道信息\r\n    function getChannelInfo(uint channelId) external view override returns (PriceChannelView memory) {\r\n        PriceChannel storage channel = _channels[channelId];\r\n\r\n        uint count = uint(channel.count);\r\n        PairView[] memory pairs = new PairView[](count);\r\n        for (uint i = 0; i < count; ++i) {\r\n            PricePair storage pair = channel.pairs[i];\r\n            pairs[i] = PairView(pair.target, uint96(pair.sheets.length));\r\n        }\r\n\r\n        return PriceChannelView (\r\n            channelId,\r\n\r\n            // 计价代币地址, 0表示eth\r\n            channel.token0,\r\n            // 计价代币单位\r\n            channel.unit,\r\n\r\n            // 矿币地址如果和token0或者token1是一种币，可能导致挖矿资产被当成矿币挖走\r\n            // 出矿代币地址\r\n            channel.reward,\r\n            // 每个区块的标准出矿量\r\n            channel.rewardPerBlock,\r\n\r\n            // 矿币总量\r\n            channel.vault,\r\n            // The information of mining fee\r\n            channel.rewards,\r\n            // Post fee(0.0001eth，DIMI_ETHER). 1000\r\n            channel.postFeeUnit,\r\n            // 报价对数量\r\n            channel.count,\r\n\r\n            // 管理地址\r\n            channel.governance,\r\n            // 创世区块\r\n            channel.genesisBlock,\r\n            // Single query fee (0.0001 ether, DIMI_ETHER). 100\r\n            channel.singleFee,\r\n            // 衰减系数，万分制。8000\r\n            channel.reductionRate,\r\n\r\n            pairs\r\n        );\r\n    }\r\n\r\n    /* ========== Mining ========== */\r\n\r\n    /// @dev 报价\r\n    /// @param channelId 报价通道id\r\n    /// @param scale 报价规模（token0，单位unit）\r\n    /// @param equivalents 价格数组，索引和报价对一一对应\r\n    function post(uint channelId, uint scale, uint[] calldata equivalents) external payable override {\r\n\r\n        // 0. 加载配置\r\n        Config memory config = _config;\r\n\r\n        // 1. Check arguments\r\n        require(scale == 1, \"NOM:!scale\");\r\n\r\n        // 2. Load price channel\r\n        PriceChannel storage channel = _channels[channelId];\r\n\r\n        // 3. Freeze assets\r\n        uint accountIndex = _addressIndex(msg.sender);\r\n        // Freeze token and nest\r\n        // Because of the use of floating-point representation(fraction * 16 ^ exponent), it may bring some precision \r\n        // loss After assets are frozen according to tokenAmountPerEth * ethNum, the part with poor accuracy may be \r\n        // lost when the assets are returned, It should be frozen according to decodeFloat(fraction, exponent) * ethNum\r\n        // However, considering that the loss is less than 1 / 10 ^ 14, the loss here is ignored, and the part of\r\n        // precision loss can be transferred out as system income in the future\r\n        mapping(address=>UINT) storage balances = _accounts[accountIndex].balances;\r\n\r\n        uint cn = uint(channel.count);\r\n        uint fee = msg.value;\r\n\r\n        // 冻结nest\r\n        fee = _freeze(balances, NEST_TOKEN_ADDRESS, cn * uint(config.pledgeNest) * 1000 ether, fee);\r\n    \r\n        // 冻结token0\r\n        fee = _freeze(balances, channel.token0, cn * uint(channel.unit) * scale, fee);\r\n\r\n        // 冻结token1\r\n        while (cn > 0) {\r\n            PricePair storage pair = channel.pairs[--cn];\r\n            uint equivalent = equivalents[cn];\r\n            require(equivalent > 0, \"NOM:!equivalent\");\r\n            fee = _freeze(balances, pair.target, scale * equivalent, fee);\r\n\r\n            // Calculate the price\r\n            // According to the current mechanism, the newly added sheet cannot take effect, so the calculated price\r\n            // is placed before the sheet is added, which can reduce unnecessary traversal\r\n            _stat(config, pair);\r\n            \r\n            // 6. Create token price sheet\r\n            emit Post(channelId, cn, msg.sender, pair.sheets.length, scale, equivalent);\r\n            // 只有0号报价对挖矿\r\n            _create(pair.sheets, accountIndex, uint32(scale), uint(config.pledgeNest), cn == 0 ? 1 : 0, equivalent);\r\n        }\r\n\r\n        // 4. Deposit fee\r\n        // 只有配置了报价佣金时才检查fee\r\n        uint postFeeUnit = uint(channel.postFeeUnit);\r\n        if (postFeeUnit > 0) {\r\n            require(fee >= postFeeUnit * DIMI_ETHER + tx.gasprice * 400000, \"NM:!fee\");\r\n        }\r\n        if (fee > 0) {\r\n            channel.rewards += _toUInt96(fee);\r\n        }\r\n    }\r\n\r\n    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\r\n    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号。吃单方向为拿走计价代币时，直接传报价对编号，吃单方向为拿走报价代币时，报价对编号加65536\r\n    /// @param index The position of the sheet in priceSheetList[token]\r\n    /// @param takeNum The amount of biting (in the unit of ETH), realAmount = takeNum * newTokenAmountPerEth\r\n    /// @param newEquivalent The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\r\n    function take(\r\n        uint channelId, \r\n        uint pairIndex, \r\n        uint index, \r\n        uint takeNum, \r\n        uint newEquivalent\r\n    ) external payable override {\r\n\r\n        Config memory config = _config;\r\n\r\n        // 1. Check arguments\r\n        require(takeNum > 0, \"NM:!takeNum\");\r\n        require(newEquivalent > 0, \"NM:!price\");\r\n\r\n        // 2. Load price sheet\r\n        PriceChannel storage channel = _channels[channelId];\r\n        PricePair storage pair = channel.pairs[pairIndex < 0x10000 ? pairIndex : pairIndex - 0x10000];\r\n        //PriceSheet[] storage sheets = pair.sheets;\r\n        PriceSheet memory sheet = pair.sheets[index];\r\n\r\n        // 3. Check state\r\n        //require(uint(sheet.remainNum) >= takeNum, \"NM:!remainNum\");\r\n        require(uint(sheet.height) + uint(config.priceEffectSpan) >= block.number, \"NM:!state\");\r\n        sheet.remainNum = uint32(uint(sheet.remainNum) - takeNum);\r\n\r\n        uint accountIndex = _addressIndex(msg.sender);\r\n        // Number of nest to be pledged\r\n        // sheet.ethNumBal + sheet.tokenNumBal is always two times to sheet.ethNum\r\n        uint needNest1k = (takeNum << 2) * uint(sheet.nestNum1k) / (uint(sheet.ethNumBal) + uint(sheet.tokenNumBal));\r\n\r\n        // 4. Calculate the number of eth, token and nest needed, and freeze them\r\n        uint needEthNum = takeNum;\r\n        uint level = uint(sheet.level);\r\n        if (level < 255) {\r\n            if (level < uint(config.maxBiteNestedLevel)) {\r\n                // Double scale sheet\r\n                needEthNum <<= 1;\r\n            }\r\n            ++level;\r\n        }\r\n\r\n        {\r\n            // Freeze nest and token\r\n            // 冻结资产：token0, token1, nest\r\n            mapping(address=>UINT) storage balances = _accounts[accountIndex].balances;\r\n            uint fee = msg.value;\r\n\r\n            // 当吃单方向为拿走计价代币时，直接传报价对编号，当吃单方向为拿走报价代币时，传报价对编号减65536\r\n            // pairIndex < 0x10000，吃单方向为拿走计价代币\r\n            if (pairIndex < 0x10000) {\r\n                // Update the bitten sheet\r\n                sheet.ethNumBal = uint32(uint(sheet.ethNumBal) - takeNum);\r\n                sheet.tokenNumBal = uint32(uint(sheet.tokenNumBal) + takeNum);\r\n                pair.sheets[index] = sheet;\r\n\r\n                // 冻结token0\r\n                fee = _freeze(balances, channel.token0, (needEthNum - takeNum) * uint(channel.unit), fee);\r\n                // 冻结token1\r\n                fee = _freeze(\r\n                    balances, \r\n                    pair.target, \r\n                    needEthNum * newEquivalent + _decodeFloat(sheet.priceFloat) * takeNum, \r\n                    fee\r\n                );\r\n            } \r\n            // pairIndex >= 0x10000，吃单方向为拿走报价代币\r\n            else {\r\n                pairIndex -= 0x10000;\r\n                // Update the bitten sheet\r\n                sheet.ethNumBal = uint32(uint(sheet.ethNumBal) + takeNum);\r\n                sheet.tokenNumBal = uint32(uint(sheet.tokenNumBal) - takeNum);\r\n                pair.sheets[index] = sheet;\r\n\r\n                // 冻结token0\r\n                fee = _freeze(balances, channel.token0, (needEthNum + takeNum) * uint(channel.unit), fee);\r\n                // 冻结token1\r\n                uint backTokenValue = _decodeFloat(sheet.priceFloat) * takeNum;\r\n                if (needEthNum * newEquivalent > backTokenValue) {\r\n                    fee = _freeze(balances, pair.target, needEthNum * newEquivalent - backTokenValue, fee);\r\n                } else {\r\n                    _unfreeze(balances, pair.target, backTokenValue - needEthNum * newEquivalent, msg.sender);\r\n                }\r\n            }\r\n                \r\n            // 冻结nest\r\n            fee = _freeze(balances, NEST_TOKEN_ADDRESS, needNest1k * 1000 ether, fee);\r\n\r\n            require(fee == 0, \"NOM:!fee\");\r\n        }\r\n            \r\n        // 5. Calculate the price\r\n        // According to the current mechanism, the newly added sheet cannot take effect, so the calculated price\r\n        // is placed before the sheet is added, which can reduce unnecessary traversal\r\n        _stat(config, pair);\r\n\r\n        // 6. Create price sheet\r\n        emit Post(channelId, pairIndex, msg.sender, pair.sheets.length, needEthNum, newEquivalent);\r\n        _create(pair.sheets, accountIndex, uint32(needEthNum), needNest1k, level << 8, newEquivalent);\r\n    }\r\n\r\n    /// @dev List sheets by page\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号\r\n    /// @param offset Skip previous (offset) records\r\n    /// @param count Return (count) records\r\n    /// @param order Order. 0 reverse order, non-0 positive order\r\n    /// @return List of price sheets\r\n    function list(\r\n        uint channelId,\r\n        uint pairIndex,\r\n        uint offset,\r\n        uint count,\r\n        uint order\r\n    ) external view override noContract returns (PriceSheetView[] memory) {\r\n\r\n        PriceSheet[] storage sheets = _channels[channelId].pairs[pairIndex].sheets;\r\n        PriceSheetView[] memory result = new PriceSheetView[](count);\r\n        uint length = sheets.length;\r\n        uint i = 0;\r\n\r\n        // Reverse order\r\n        if (order == 0) {\r\n\r\n            uint index = length - offset;\r\n            uint end = index > count ? index - count : 0;\r\n            while (index > end) {\r\n                --index;\r\n                result[i++] = _toPriceSheetView(sheets[index], index);\r\n            }\r\n        } \r\n        // Positive order\r\n        else {\r\n\r\n            uint index = offset;\r\n            uint end = index + count;\r\n            if (end > length) {\r\n                end = length;\r\n            }\r\n            while (index < end) {\r\n                result[i++] = _toPriceSheetView(sheets[index], index);\r\n                ++index;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /// @notice Close a batch of price sheets passed VERIFICATION-PHASE\r\n    /// @dev Empty sheets but in VERIFICATION-PHASE aren't allowed\r\n    /// @param channelId 报价通道编号\r\n    /// @param indices 报价单二维数组，外层对应通道号，内层对应报价单号，如果仅关闭后面的报价对，则前面的报价对数组传空数组\r\n    function close(uint channelId, uint[][] calldata indices) external override {\r\n        \r\n        Config memory config = _config;\r\n        PriceChannel storage channel = _channels[channelId];\r\n        \r\n        uint accountIndex = 0;\r\n        uint reward = 0;\r\n        uint nestNum1k = 0;\r\n        uint ethNum = 0;\r\n\r\n        // storage变量必须在定义时初始化，因此在此处赋值，但是由于accountIndex此时为0，此赋值没有意义\r\n        mapping(address=>UINT) storage balances = _accounts[0/*accountIndex*/].balances;\r\n        uint[3] memory vars = [\r\n            uint(channel.rewardPerBlock), \r\n            uint(channel.genesisBlock), \r\n            uint(channel.reductionRate)\r\n        ];\r\n\r\n        for (uint j = indices.length; j > 0;) {\r\n            PricePair storage pair = channel.pairs[--j];\r\n\r\n            ///////////////////////////////////////////////////////////////////////////////////////\r\n            //PriceSheet[] storage sheets = pair.sheets;\r\n\r\n            uint tokenValue = 0;\r\n\r\n            // 1. Traverse sheets\r\n            for (uint i = indices[j].length; i > 0;) {\r\n\r\n                // ---------------------------------------------------------------------------------\r\n                uint index = indices[j][--i];\r\n                PriceSheet memory sheet = pair.sheets[index];\r\n                //uint height = uint(sheet.height);\r\n                //uint minerIndex = uint(sheet.miner);\r\n                \r\n                // Batch closing quotation can only close sheet of the same user\r\n                if (accountIndex == 0) {\r\n                    // accountIndex == 0 means the first sheet, and the number of this sheet is taken\r\n                    accountIndex = uint(sheet.miner);\r\n                    balances = _accounts[accountIndex].balances;\r\n                } else {\r\n                    // accountIndex != 0 means that it is a follow-up sheet, and the miner number must be \r\n                    // consistent with the previous record\r\n                    require(accountIndex == uint(sheet.miner), \"NM:!miner\");\r\n                }\r\n\r\n                // Check the status of the price sheet to see if it has reached the effective block interval \r\n                // or has been finished\r\n                if (accountIndex > 0 && (uint(sheet.height) + uint(config.priceEffectSpan) < block.number)) {\r\n\r\n                    // 后面的通道不出矿，不需要出矿逻辑\r\n                    // 出矿按照第一个通道计算\r\n                    if (j == 0) {\r\n                        uint shares = uint(sheet.shares);\r\n                        // Mining logic\r\n                        // The price sheet which shares is zero doesn't mining\r\n                        if (shares > 0) {\r\n\r\n                            // Currently, mined represents the number of blocks has mined\r\n                            (uint mined, uint totalShares) = _calcMinedBlocks(pair.sheets, index, sheet);\r\n                            \r\n                            // 当开通者指定的rewardPerBlock非常大时，计算出矿可能会被截断，导致实际能够得到的出矿大大减少\r\n                            // 这种情况是不合理的，需要由开通者负责\r\n                            reward += (\r\n                                mined\r\n                                * shares\r\n                                * _reduction(uint(sheet.height) - vars[1], vars[2])\r\n                                * vars[0]\r\n                                / totalShares / 400\r\n                            );\r\n                        }\r\n                    }\r\n\r\n                    nestNum1k += uint(sheet.nestNum1k);\r\n                    ethNum += uint(sheet.ethNumBal);\r\n                    tokenValue += _decodeFloat(sheet.priceFloat) * uint(sheet.tokenNumBal);\r\n\r\n                    // Set sheet.miner to 0, express the sheet is closed\r\n                    sheet.miner = uint32(0);\r\n                    sheet.ethNumBal = uint32(0);\r\n                    sheet.tokenNumBal = uint32(0);\r\n                    pair.sheets[index] = sheet;\r\n                }\r\n\r\n                // ---------------------------------------------------------------------------------\r\n            }\r\n\r\n            _stat(config, pair);\r\n            ///////////////////////////////////////////////////////////////////////////////////////\r\n\r\n            // 解冻token1\r\n            _unfreeze(balances, pair.target, tokenValue, accountIndex);\r\n        }\r\n\r\n        // 解冻token0\r\n        _unfreeze(balances, channel.token0, ethNum * uint(channel.unit), accountIndex);\r\n        \r\n        // 解冻nest\r\n        _unfreeze(balances, NEST_TOKEN_ADDRESS, nestNum1k * 1000 ether, accountIndex);\r\n\r\n        uint vault = uint(channel.vault);\r\n        if (reward > vault) {\r\n            reward = vault;\r\n        }\r\n        // 记录每个通道矿币的数量，防止开通者不打币，直接用资金池内的资金\r\n        channel.vault = uint96(vault - reward);\r\n        \r\n        // 奖励矿币\r\n        _unfreeze(balances, channel.reward, reward, accountIndex);\r\n    }\r\n\r\n    /// @dev View the number of assets specified by the user\r\n    /// @param tokenAddress Destination token address\r\n    /// @param addr Destination address\r\n    /// @return Number of assets\r\n    function balanceOf(address tokenAddress, address addr) external view override returns (uint) {\r\n        return _accounts[_accountMapping[addr]].balances[tokenAddress].value;\r\n    }\r\n\r\n    /// @dev Withdraw assets\r\n    /// @param tokenAddress Destination token address\r\n    /// @param value The value to withdraw\r\n    function withdraw(address tokenAddress, uint value) external override {\r\n\r\n        // The user's locked nest and the mining pool's nest are stored together. When the nest is mined over,\r\n        // the problem of taking the locked nest as the ore drawing will appear\r\n        // As it will take a long time for nest to finish mining, this problem will not be considered for the time being\r\n        UINT storage balance = _accounts[_accountMapping[msg.sender]].balances[tokenAddress];\r\n        //uint balanceValue = balance.value;\r\n        //require(balanceValue >= value, \"NM:!balance\");\r\n        balance.value -= value;\r\n\r\n        TransferHelper.safeTransfer(tokenAddress, msg.sender, value);\r\n    }\r\n\r\n    /// @dev Estimated mining amount\r\n    /// @param channelId 报价通道编号\r\n    /// @return Estimated mining amount\r\n    function estimate(uint channelId) external view override returns (uint) {\r\n\r\n        PriceChannel storage channel = _channels[channelId];\r\n        PriceSheet[] storage sheets = channel.pairs[0].sheets;\r\n        uint index = sheets.length;\r\n        uint blocks = 10;\r\n        while (index > 0) {\r\n\r\n            PriceSheet memory sheet = sheets[--index];\r\n            if (uint(sheet.shares) > 0) {\r\n                blocks = block.number - uint(sheet.height);\r\n                break;\r\n            }\r\n        }\r\n\r\n        return \r\n            blocks\r\n            * uint(channel.rewardPerBlock) \r\n            * _reduction(block.number - uint(channel.genesisBlock), uint(channel.reductionRate))\r\n            / 400;\r\n    }\r\n\r\n    /// @dev Query the quantity of the target quotation\r\n    /// @param channelId 报价通道编号\r\n    /// @param index The index of the sheet\r\n    /// @return minedBlocks Mined block period from previous block\r\n    /// @return totalShares Total shares of sheets in the block\r\n    function getMinedBlocks(\r\n        uint channelId,\r\n        uint index\r\n    ) external view override returns (uint minedBlocks, uint totalShares) {\r\n\r\n        PriceSheet[] storage sheets = _channels[channelId].pairs[0].sheets;\r\n        PriceSheet memory sheet = sheets[index];\r\n\r\n        // The bite sheet or ntoken sheet doesn't mining\r\n        if (uint(sheet.shares) == 0) {\r\n            return (0, 0);\r\n        }\r\n\r\n        return _calcMinedBlocks(sheets, index, sheet);\r\n    }\r\n\r\n    /// @dev The function returns eth rewards of specified ntoken\r\n    /// @param channelId 报价通道编号\r\n    function totalETHRewards(uint channelId) external view override returns (uint) {\r\n        return uint(_channels[channelId].rewards);\r\n    }\r\n\r\n    /// @dev Pay\r\n    /// @param channelId 报价通道编号\r\n    /// @param to Address to receive\r\n    /// @param value Amount to receive\r\n    function pay(uint channelId, address to, uint value) external override {\r\n\r\n        PriceChannel storage channel = _channels[channelId];\r\n        require(channel.governance == msg.sender, \"NOM:!governance\");\r\n        channel.rewards -= _toUInt96(value);\r\n        // pay\r\n        payable(to).transfer(value);\r\n    }\r\n\r\n    /// @dev 向DAO捐赠\r\n    /// @param channelId 报价通道\r\n    /// @param value Amount to receive\r\n    function donate(uint channelId, uint value) external override {\r\n\r\n        PriceChannel storage channel = _channels[channelId];\r\n        require(channel.governance == msg.sender, \"NOM:!governance\");\r\n        channel.rewards -= _toUInt96(value);\r\n        INestLedger(INestMapping(_governance).getNestLedgerAddress()).addETHReward { value: value } (channelId);\r\n    }\r\n\r\n    /// @dev Gets the address corresponding to the given index number\r\n    /// @param index The index number of the specified address\r\n    /// @return The address corresponding to the given index number\r\n    function indexAddress(uint index) public view returns (address) {\r\n        return _accounts[index].addr;\r\n    }\r\n\r\n    /// @dev Gets the registration index number of the specified address\r\n    /// @param addr Destination address\r\n    /// @return 0 means nonexistent, non-0 means index number\r\n    function getAccountIndex(address addr) external view returns (uint) {\r\n        return _accountMapping[addr];\r\n    }\r\n\r\n    /// @dev Get the length of registered account array\r\n    /// @return The length of registered account array\r\n    function getAccountCount() external view returns (uint) {\r\n        return _accounts.length;\r\n    }\r\n\r\n    // Convert PriceSheet to PriceSheetView\r\n    function _toPriceSheetView(PriceSheet memory sheet, uint index) private view returns (PriceSheetView memory) {\r\n\r\n        return PriceSheetView(\r\n            // Index number\r\n            uint32(index),\r\n            // Miner address\r\n            indexAddress(sheet.miner),\r\n            // The block number of this price sheet packaged\r\n            sheet.height,\r\n            // The remain number of this price sheet\r\n            sheet.remainNum,\r\n            // The eth number which miner will got\r\n            sheet.ethNumBal,\r\n            // The eth number which equivalent to token's value which miner will got\r\n            sheet.tokenNumBal,\r\n            // The pledged number of nest in this sheet. (Unit: 1000nest)\r\n            sheet.nestNum1k,\r\n            // The level of this sheet. 0 expresses initial price sheet, a value greater than 0 expresses \r\n            // bite price sheet\r\n            sheet.level,\r\n            // Post fee shares\r\n            sheet.shares,\r\n            // Price\r\n            uint152(_decodeFloat(sheet.priceFloat))\r\n        );\r\n    }\r\n\r\n    // Create price sheet\r\n    function _create(\r\n        PriceSheet[] storage sheets,\r\n        uint accountIndex,\r\n        uint32 ethNum,\r\n        uint nestNum1k,\r\n        uint level_shares,\r\n        uint equivalent\r\n    ) private {\r\n\r\n        sheets.push(PriceSheet(\r\n            uint32(accountIndex),                       // uint32 miner;\r\n            uint32(block.number),                       // uint32 height;\r\n            ethNum,                                     // uint32 remainNum;\r\n            ethNum,                                     // uint32 ethNumBal;\r\n            ethNum,                                     // uint32 tokenNumBal;\r\n            uint24(nestNum1k),                          // uint32 nestNum1k;\r\n            uint8(level_shares >> 8),                   // uint8 level;\r\n            uint8(level_shares & 0xFF),\r\n            _encodeFloat(equivalent)\r\n        ));\r\n    }\r\n\r\n    // Calculate price, average price and volatility\r\n    function _stat(Config memory config, PricePair storage pair) private {\r\n        \r\n        PriceSheet[] storage sheets = pair.sheets;\r\n        // Load token price information\r\n        PriceInfo memory p0 = pair.price;\r\n\r\n        // Length of sheets\r\n        uint length = sheets.length;\r\n        // The index of the sheet to be processed in the sheet array\r\n        uint index = uint(p0.index);\r\n        // The latest block number for which the price has been calculated\r\n        uint prev = uint(p0.height);\r\n        // It's not necessary to load the price information in p0\r\n        // Eth count variable used to calculate price\r\n        uint totalEthNum = 0; \r\n        // Token count variable for price calculation\r\n        uint totalTokenValue = 0; \r\n        // Block number of current sheet\r\n        uint height = 0;\r\n\r\n        // Traverse the sheets to find the effective price\r\n        //uint effectBlock = block.number - uint(config.priceEffectSpan);\r\n        PriceSheet memory sheet;\r\n        for (; ; ++index) {\r\n\r\n            // Gas attack analysis, each post transaction, calculated according to post, needs to write\r\n            // at least one sheet and freeze two kinds of assets, which needs to consume at least 30000 gas,\r\n            // In addition to the basic cost of the transaction, at least 50000 gas is required.\r\n            // In addition, there are other reading and calculation operations. The gas consumed by each\r\n            // transaction is impossible less than 70000 gas, The attacker can accumulate up to 20 blocks\r\n            // of sheets to be generated. To ensure that the calculation can be completed in one block,\r\n            // it is necessary to ensure that the consumption of each price does not exceed 70000 / 20 = 3500 gas,\r\n            // According to the current logic, each calculation of a price needs to read a storage unit (800)\r\n            // and calculate the consumption, which can not reach the dangerous value of 3500, so the gas attack\r\n            // is not considered\r\n\r\n            // Traverse the sheets that has reached the effective interval from the current position\r\n            bool flag = index >= length\r\n                || (height = uint((sheet = sheets[index]).height)) + uint(config.priceEffectSpan) >= block.number;\r\n\r\n            // Not the same block (or flag is false), calculate the price and update it\r\n            if (flag || prev != height) {\r\n\r\n                // totalEthNum > 0 Can calculate the price\r\n                if (totalEthNum > 0) {\r\n\r\n                    // Calculate average price and Volatility\r\n                    // Calculation method of volatility of follow-up price\r\n                    uint tmp = _decodeFloat(p0.priceFloat);\r\n                    // New price\r\n                    uint price = totalTokenValue / totalEthNum;\r\n                    // Update price\r\n                    p0.remainNum = uint32(totalEthNum);\r\n                    p0.priceFloat = _encodeFloat(price);\r\n                    // Clear cumulative values\r\n                    totalEthNum = 0;\r\n                    totalTokenValue = 0;\r\n\r\n                    if (tmp > 0) {\r\n                        // Calculate average price\r\n                        // avgPrice[i + 1] = avgPrice[i] * 90% + price[i] * 10%\r\n                        p0.avgFloat = _encodeFloat((_decodeFloat(p0.avgFloat) * 9 + price) / 10);\r\n\r\n                        // When the accuracy of the token is very high or the value of the token relative to\r\n                        // eth is very low, the price may be very large, and there may be overflow problem,\r\n                        // it is not considered for the moment\r\n                        tmp = (price << 48) / tmp;\r\n                        if (tmp > 0x1000000000000) {\r\n                            tmp = tmp - 0x1000000000000;\r\n                        } else {\r\n                            tmp = 0x1000000000000 - tmp;\r\n                        }\r\n\r\n                        // earn = price[i] / price[i - 1] - 1;\r\n                        // seconds = time[i] - time[i - 1];\r\n                        // sigmaSQ[i + 1] = sigmaSQ[i] * 90% + (earn ^ 2 / seconds) * 10%\r\n                        tmp = (\r\n                            uint(p0.sigmaSQ) * 9 + \r\n                            // It is inevitable that prev greater than p0.height\r\n                            ((tmp * tmp / ETHEREUM_BLOCK_TIMESPAN / (prev - uint(p0.height))) >> 48)\r\n                        ) / 10;\r\n\r\n                        // The current implementation assumes that the volatility cannot exceed 1, and\r\n                        // corresponding to this, when the calculated value exceeds 1, expressed as 0xFFFFFFFFFFFF\r\n                        if (tmp > 0xFFFFFFFFFFFF) {\r\n                            tmp = 0xFFFFFFFFFFFF;\r\n                        }\r\n                        p0.sigmaSQ = uint48(tmp);\r\n                    }\r\n                    // The calculation methods of average price and volatility are different for first price\r\n                    else {\r\n                        // The average price is equal to the price\r\n                        //p0.avgTokenAmount = uint64(price);\r\n                        p0.avgFloat = p0.priceFloat;\r\n\r\n                        // The volatility is 0\r\n                        p0.sigmaSQ = uint48(0);\r\n                    }\r\n\r\n                    // Update price block number\r\n                    p0.height = uint32(prev);\r\n                }\r\n\r\n                // Move to new block number\r\n                prev = height;\r\n            }\r\n\r\n            if (flag) {\r\n                break;\r\n            }\r\n\r\n            // Cumulative price information\r\n            totalEthNum += uint(sheet.remainNum);\r\n            totalTokenValue += _decodeFloat(sheet.priceFloat) * uint(sheet.remainNum);\r\n        }\r\n\r\n        // Update price information\r\n        if (index > uint(p0.index)) {\r\n            p0.index = uint32(index);\r\n            pair.price = p0;\r\n        }\r\n    }\r\n\r\n    // Calculation number of blocks which mined\r\n    function _calcMinedBlocks(\r\n        PriceSheet[] storage sheets,\r\n        uint index,\r\n        PriceSheet memory sheet\r\n    ) private view returns (uint minedBlocks, uint totalShares) {\r\n\r\n        uint length = sheets.length;\r\n        uint height = uint(sheet.height);\r\n        totalShares = uint(sheet.shares);\r\n\r\n        // Backward looking for sheets in the same block\r\n        for (uint i = index; ++i < length && uint(sheets[i].height) == height;) {\r\n            \r\n            // Multiple sheets in the same block is a small probability event at present, so it can be ignored\r\n            // to read more than once, if there are always multiple sheets in the same block, it means that the\r\n            // sheets are very intensive, and the gas consumed here does not have a great impact\r\n            totalShares += uint(sheets[i].shares);\r\n        }\r\n\r\n        //i = index;\r\n        // Find sheets in the same block forward\r\n        uint prev = height;\r\n        while (index > 0 && uint(prev = sheets[--index].height) == height) {\r\n\r\n            // Multiple sheets in the same block is a small probability event at present, so it can be ignored \r\n            // to read more than once, if there are always multiple sheets in the same block, it means that the\r\n            // sheets are very intensive, and the gas consumed here does not have a great impact\r\n            totalShares += uint(sheets[index].shares);\r\n        }\r\n\r\n        if (index > 0 || height > prev) {\r\n            minedBlocks = height - prev;\r\n        } else {\r\n            minedBlocks = 10;\r\n        }\r\n    }\r\n\r\n    /// @dev freeze token\r\n    /// @param balances Balances ledger\r\n    /// @param tokenAddress Destination token address\r\n    /// @param tokenValue token amount\r\n    /// @param value 剩余的eth数量\r\n    function _freeze(\r\n        mapping(address=>UINT) storage balances, \r\n        address tokenAddress, \r\n        uint tokenValue,\r\n        uint value\r\n    ) private returns (uint) {\r\n        if (tokenAddress == address(0)) {\r\n            return value - tokenValue;\r\n        } else {\r\n            // Unfreeze nest\r\n            UINT storage balance = balances[tokenAddress];\r\n            uint balanceValue = balance.value;\r\n            if (balanceValue < tokenValue) {\r\n                balance.value = 0;\r\n                TransferHelper.safeTransferFrom(tokenAddress, msg.sender, address(this), tokenValue - balanceValue);\r\n            } else {\r\n                balance.value = balanceValue - tokenValue;\r\n            }\r\n            return value;\r\n        }\r\n    }\r\n\r\n    function _unfreeze(\r\n        mapping(address=>UINT) storage balances, \r\n        address tokenAddress, \r\n        uint tokenValue,\r\n        uint accountIndex\r\n    ) private {\r\n        if (tokenValue > 0) {\r\n            if (tokenAddress == address(0)) {\r\n                payable(indexAddress(accountIndex)).transfer(tokenValue);\r\n            } else {\r\n                balances[tokenAddress].value += tokenValue;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _unfreeze(\r\n        mapping(address=>UINT) storage balances, \r\n        address tokenAddress, \r\n        uint tokenValue,\r\n        address owner\r\n    ) private {\r\n        if (tokenValue > 0) {\r\n            if (tokenAddress == address(0)) {\r\n                payable(owner).transfer(tokenValue);\r\n            } else {\r\n                balances[tokenAddress].value += tokenValue;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Gets the index number of the specified address. If it does not exist, register\r\n    /// @param addr Destination address\r\n    /// @return The index number of the specified address\r\n    function _addressIndex(address addr) private returns (uint) {\r\n\r\n        uint index = _accountMapping[addr];\r\n        if (index == 0) {\r\n            // If it exceeds the maximum number that 32 bits can store, you can't continue to register a new account.\r\n            // If you need to support a new account, you need to update the contract\r\n            require((_accountMapping[addr] = index = _accounts.length) < 0x100000000, \"NM:!accounts\");\r\n            _accounts.push().addr = addr;\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    // // Calculation of attenuation gradient\r\n    // function _reduction(uint delta) private pure returns (uint) {\r\n\r\n    //     if (delta < NEST_REDUCTION_LIMIT) {\r\n    //         return (NEST_REDUCTION_STEPS >> ((delta / NEST_REDUCTION_SPAN) << 4)) & 0xFFFF;\r\n    //     }\r\n    //     return (NEST_REDUCTION_STEPS >> 160) & 0xFFFF;\r\n    // }\r\n\r\n    function _reduction(uint delta, uint reductionRate) private pure returns (uint) {\r\n        if (delta < NEST_REDUCTION_LIMIT) {\r\n            uint n = delta / NEST_REDUCTION_SPAN;\r\n            return 400 * reductionRate ** n / 10000 ** n;\r\n        }\r\n        return 400 * reductionRate ** 10 / 10000 ** 10;\r\n    }\r\n\r\n    /* ========== Tools and methods ========== */\r\n\r\n    /// @dev Encode the uint value as a floating-point representation in the form of fraction * 16 ^ exponent\r\n    /// @param value Destination uint value\r\n    /// @return float format\r\n    function _encodeFloat(uint value) private pure returns (uint56) {\r\n\r\n        uint exponent = 0; \r\n        while (value > 0x3FFFFFFFFFFFF) {\r\n            value >>= 4;\r\n            ++exponent;\r\n        }\r\n        return uint56((value << 6) | exponent);\r\n    }\r\n\r\n    /// @dev Decode the floating-point representation of fraction * 16 ^ exponent to uint\r\n    /// @param floatValue fraction value\r\n    /// @return decode format\r\n    function _decodeFloat(uint56 floatValue) private pure returns (uint) {\r\n        return (uint(floatValue) >> 6) << ((uint(floatValue) & 0x3F) << 2);\r\n    }\r\n\r\n    // 将uint转为uint96\r\n    function _toUInt96(uint value) internal pure returns (uint96) {\r\n        require(value < 1000000000000000000000000);\r\n        return uint96(value);\r\n    }\r\n\r\n    /* ========== 价格查询 ========== */\r\n    \r\n    /// @dev Get the latest trigger price\r\n    /// @param pair 报价对\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    function _triggeredPrice(PricePair storage pair) internal view returns (uint blockNumber, uint price) {\r\n\r\n        PriceInfo memory priceInfo = pair.price;\r\n\r\n        if (uint(priceInfo.remainNum) > 0) {\r\n            return (uint(priceInfo.height) + uint(_config.priceEffectSpan), _decodeFloat(priceInfo.priceFloat));\r\n        }\r\n        \r\n        return (0, 0);\r\n    }\r\n\r\n    /// @dev Get the full information of latest trigger price\r\n    /// @param pair 报价对\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    /// @return avgPrice Average price\r\n    /// @return sigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \r\n    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\r\n    ///         it means that the volatility has exceeded the range that can be expressed\r\n    function _triggeredPriceInfo(PricePair storage pair) internal view returns (\r\n        uint blockNumber,\r\n        uint price,\r\n        uint avgPrice,\r\n        uint sigmaSQ\r\n    ) {\r\n\r\n        PriceInfo memory priceInfo = pair.price;\r\n\r\n        if (uint(priceInfo.remainNum) > 0) {\r\n            return (\r\n                uint(priceInfo.height) + uint(_config.priceEffectSpan),\r\n                _decodeFloat(priceInfo.priceFloat),\r\n                _decodeFloat(priceInfo.avgFloat),\r\n                (uint(priceInfo.sigmaSQ) * 1 ether) >> 48\r\n            );\r\n        }\r\n\r\n        return (0, 0, 0, 0);\r\n    }\r\n\r\n    /// @dev Find the price at block number\r\n    /// @param pair 报价对\r\n    /// @param height Destination block number\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    function _findPrice(\r\n        PricePair storage pair,\r\n        uint height\r\n    ) internal view returns (uint blockNumber, uint price) {\r\n\r\n        PriceSheet[] storage sheets = pair.sheets;\r\n        uint priceEffectSpan = uint(_config.priceEffectSpan);\r\n\r\n        uint length = sheets.length;\r\n        uint index = 0;\r\n        uint sheetHeight;\r\n        height -= priceEffectSpan;\r\n        {\r\n            // If there is no sheet in this channel, length is 0, length - 1 will overflow,\r\n            uint right = length - 1;\r\n            uint left = 0;\r\n            // Find the index use Binary Search\r\n            while (left < right) {\r\n\r\n                index = (left + right) >> 1;\r\n                sheetHeight = uint(sheets[index].height);\r\n                if (height > sheetHeight) {\r\n                    left = ++index;\r\n                } else if (height < sheetHeight) {\r\n                    // When index = 0, this statement will have an underflow exception, which usually \r\n                    // indicates that the effective block height passed during the call is lower than \r\n                    // the block height of the first quotation\r\n                    right = --index;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Calculate price\r\n        uint totalEthNum = 0;\r\n        uint totalTokenValue = 0;\r\n        uint h = 0;\r\n        uint remainNum;\r\n        PriceSheet memory sheet;\r\n\r\n        // Find sheets forward\r\n        for (uint i = index; i < length;) {\r\n\r\n            sheet = sheets[i++];\r\n            sheetHeight = uint(sheet.height);\r\n            if (height < sheetHeight) {\r\n                break;\r\n            }\r\n            remainNum = uint(sheet.remainNum);\r\n            if (remainNum > 0) {\r\n                if (h == 0) {\r\n                    h = sheetHeight;\r\n                } else if (h != sheetHeight) {\r\n                    break;\r\n                }\r\n                totalEthNum += remainNum;\r\n                totalTokenValue += _decodeFloat(sheet.priceFloat) * remainNum;\r\n            }\r\n        }\r\n\r\n        // Find sheets backward\r\n        while (index > 0) {\r\n\r\n            sheet = sheets[--index];\r\n            remainNum = uint(sheet.remainNum);\r\n            if (remainNum > 0) {\r\n                sheetHeight = uint(sheet.height);\r\n                if (h == 0) {\r\n                    h = sheetHeight;\r\n                } else if (h != sheetHeight) {\r\n                    break;\r\n                }\r\n                totalEthNum += remainNum;\r\n                totalTokenValue += _decodeFloat(sheet.priceFloat) * remainNum;\r\n            }\r\n        }\r\n\r\n        if (totalEthNum > 0) {\r\n            return (h + priceEffectSpan, totalTokenValue / totalEthNum);\r\n        }\r\n        return (0, 0);\r\n    }\r\n\r\n    /// @dev Get the last (num) effective price\r\n    /// @param pair 报价对\r\n    /// @param count The number of prices that want to return\r\n    /// @return An array which length is num * 2, each two element expresses one price like blockNumber｜price\r\n    function _lastPriceList(PricePair storage pair, uint count) internal view returns (uint[] memory) {\r\n\r\n        PriceSheet[] storage sheets = pair.sheets;\r\n        PriceSheet memory sheet;\r\n        uint[] memory array = new uint[](count <<= 1);\r\n\r\n        uint priceEffectSpan = uint(_config.priceEffectSpan);\r\n        //uint h = block.number - priceEffectSpan;\r\n        uint index = sheets.length;\r\n        uint totalEthNum = 0;\r\n        uint totalTokenValue = 0;\r\n        uint height = 0;\r\n\r\n        for (uint i = 0; i < count;) {\r\n\r\n            bool flag = index == 0;\r\n            if (flag || height != uint((sheet = sheets[--index]).height)) {\r\n                if (totalEthNum > 0 && height + priceEffectSpan < block.number) {\r\n                    array[i++] = height + priceEffectSpan;\r\n                    array[i++] = totalTokenValue / totalEthNum;\r\n                }\r\n                if (flag) {\r\n                    break;\r\n                }\r\n                totalEthNum = 0;\r\n                totalTokenValue = 0;\r\n                height = uint(sheet.height);\r\n            }\r\n\r\n            uint remainNum = uint(sheet.remainNum);\r\n            totalEthNum += remainNum;\r\n            totalTokenValue += _decodeFloat(sheet.priceFloat) * remainNum;\r\n        }\r\n\r\n        return array;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/NestBatchPlatform2.sol\r\n\r\n// GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.6;\r\n// 支持pairIndex数组，可以一次性查询多个价格\r\n/// @dev This contract implemented the mining logic of nest\r\ncontract NestBatchPlatform2 is NestBatchMining, INestBatchPriceView, INestBatchPrice2 {\r\n\r\n    /* ========== INestBatchPriceView ========== */\r\n\r\n    /// @dev Get the latest trigger price\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    function triggeredPrice(uint channelId, uint pairIndex) external view override noContract returns (uint blockNumber, uint price) {\r\n        return _triggeredPrice(_channels[channelId].pairs[pairIndex]);\r\n    }\r\n\r\n    /// @dev Get the full information of latest trigger price\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    /// @return avgPrice Average price\r\n    /// @return sigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \r\n    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\r\n    ///         it means that the volatility has exceeded the range that can be expressed\r\n    function triggeredPriceInfo(uint channelId, uint pairIndex) external view override noContract returns (\r\n        uint blockNumber,\r\n        uint price,\r\n        uint avgPrice,\r\n        uint sigmaSQ\r\n    ) {\r\n        return _triggeredPriceInfo(_channels[channelId].pairs[pairIndex]);\r\n    }\r\n\r\n    /// @dev Find the price at block number\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号\r\n    /// @param height Destination block number\r\n    /// @return blockNumber The block number of price\r\n    /// @return price The token price. (1eth equivalent to (price) token)\r\n    function findPrice(\r\n        uint channelId,\r\n        uint pairIndex,\r\n        uint height\r\n    ) external view override noContract returns (uint blockNumber, uint price) {\r\n        return _findPrice(_channels[channelId].pairs[pairIndex], height);\r\n    }\r\n\r\n    // /// @dev Get the latest effective price\r\n    // /// @param channelId 报价通道编号\r\n    // /// @param pairIndex 报价对编号\r\n    // /// @return blockNumber The block number of price\r\n    // /// @return price The token price. (1eth equivalent to (price) token)\r\n    // function latestPrice(uint channelId, uint pairIndex) external view override noContract returns (uint blockNumber, uint price) {\r\n    //     return _latestPrice(_channels[channelId].pairs[pairIndex]);\r\n    // }\r\n\r\n    /// @dev Get the last (num) effective price\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号\r\n    /// @param count The number of prices that want to return\r\n    /// @return An array which length is num * 2, each two element expresses one price like blockNumber｜price\r\n    function lastPriceList(uint channelId, uint pairIndex, uint count) external view override noContract returns (uint[] memory) {\r\n        return _lastPriceList(_channels[channelId].pairs[pairIndex], count);\r\n    } \r\n\r\n    /// @dev Returns lastPriceList and triggered price info\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndex 报价对编号\r\n    /// @param count The number of prices that want to return\r\n    /// @return prices An array which length is num * 2, each two element expresses one price like blockNumber｜price\r\n    /// @return triggeredPriceBlockNumber The block number of triggered price\r\n    /// @return triggeredPriceValue The token triggered price. (1eth equivalent to (price) token)\r\n    /// @return triggeredAvgPrice Average price\r\n    /// @return triggeredSigmaSQ The square of the volatility (18 decimal places). The current implementation \r\n    /// assumes that the volatility cannot exceed 1. Correspondingly, when the return value is equal to \r\n    /// 999999999999996447, it means that the volatility has exceeded the range that can be expressed\r\n    function lastPriceListAndTriggeredPriceInfo(uint channelId, uint pairIndex, uint count) external view override noContract\r\n    returns (\r\n        uint[] memory prices,\r\n        uint triggeredPriceBlockNumber,\r\n        uint triggeredPriceValue,\r\n        uint triggeredAvgPrice,\r\n        uint triggeredSigmaSQ\r\n    ) {\r\n        //return _lastPriceListAndTriggeredPriceInfo(_channels[channelId].pairs[pairIndex], count);\r\n        PricePair storage pair = _channels[channelId].pairs[pairIndex];\r\n        prices = _lastPriceList(pair, count);\r\n        (\r\n            triggeredPriceBlockNumber, \r\n            triggeredPriceValue, \r\n            triggeredAvgPrice, \r\n            triggeredSigmaSQ\r\n        ) = _triggeredPriceInfo(pair);\r\n    }\r\n\r\n    /* ========== INestBatchPrice ========== */\r\n\r\n    /// @dev Get the latest trigger price\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndices 报价对编号\r\n    /// @param payback 如果费用有多余的，则退回到此地址\r\n    /// @return prices 价格数组, i * 2 为第i个价格所在区块, i * 2 + 1 为第i个价格\r\n    function triggeredPrice(\r\n        uint channelId,\r\n        uint[] calldata pairIndices, \r\n        address payback\r\n    ) external payable override returns (uint[] memory prices) {\r\n        PricePair[0xFFFF] storage pairs = _pay(channelId, payback).pairs;\r\n\r\n        uint n = pairIndices.length << 1;\r\n        prices = new uint[](n);\r\n        while (n > 0) {\r\n            n -= 2;\r\n            (prices[n], prices[n + 1]) = _triggeredPrice(pairs[pairIndices[n >> 1]]);\r\n        }\r\n    }\r\n\r\n    /// @dev Get the full information of latest trigger price\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndices 报价对编号\r\n    /// @param payback 如果费用有多余的，则退回到此地址\r\n    /// @return prices 价格数组, i * 4 为第i个价格所在区块, i * 4 + 1 为第i个价格, i * 4 + 2 为第i个平均价格, i * 4 + 3 为第i个波动率\r\n    function triggeredPriceInfo(\r\n        uint channelId, \r\n        uint[] calldata pairIndices,\r\n        address payback\r\n    ) external payable override returns (uint[] memory prices) {\r\n        PricePair[0xFFFF] storage pairs = _pay(channelId, payback).pairs;\r\n\r\n        uint n = pairIndices.length << 2;\r\n        prices = new uint[](n);\r\n        while (n > 0) {\r\n            n -= 4;\r\n            (prices[n], prices[n + 1], prices[n + 2], prices[n + 3]) = _triggeredPriceInfo(pairs[pairIndices[n >> 2]]);\r\n        }\r\n    }\r\n\r\n    /// @dev Find the price at block number\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndices 报价对编号\r\n    /// @param height Destination block number\r\n    /// @param payback 如果费用有多余的，则退回到此地址\r\n    /// @return prices 价格数组, i * 2 为第i个价格所在区块, i * 2 + 1 为第i个价格\r\n    function findPrice(\r\n        uint channelId,\r\n        uint[] calldata pairIndices, \r\n        uint height, \r\n        address payback\r\n    ) external payable override returns (uint[] memory prices) {\r\n        PricePair[0xFFFF] storage pairs = _pay(channelId, payback).pairs;\r\n\r\n        uint n = pairIndices.length << 1;\r\n        prices = new uint[](n);\r\n        while (n > 0) {\r\n            n -= 2;\r\n            (prices[n], prices[n + 1]) = _findPrice(pairs[pairIndices[n >> 1]], height);\r\n        }\r\n    }\r\n\r\n    // /// @dev Get the latest effective price\r\n    // /// @param channelId 报价通道编号\r\n    // /// @param pairIndices 报价对编号\r\n    // /// @param payback 如果费用有多余的，则退回到此地址\r\n    // /// @return prices 价格数组, i * 2 为第i个价格所在区块, i * 2 + 1 为第i个价格\r\n    // function latestPrice(\r\n    //     uint channelId, \r\n    //     uint[] calldata pairIndices, \r\n    //     address payback\r\n    // ) external payable override returns (uint[] memory prices) {\r\n    //     PricePair[0xFFFF] storage pairs = _pay(channelId, payback).pairs;\r\n\r\n    //     uint n = pairIndices.length << 1;\r\n    //     prices = new uint[](n);\r\n    //     while (n > 0) {\r\n    //         n -= 2;\r\n    //         (prices[n], prices[n + 1]) = _latestPrice(pairs[pairIndices[n >> 1]]);\r\n    //     }\r\n    // }\r\n\r\n    /// @dev Get the last (num) effective price\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndices 报价对编号\r\n    /// @param count The number of prices that want to return\r\n    /// @param payback 如果费用有多余的，则退回到此地址\r\n    /// @return prices 结果数组，第 i * count * 2 到 (i + 1) * count * 2 - 1为第i组报价对的价格结果\r\n    function lastPriceList(\r\n        uint channelId, \r\n        uint[] calldata pairIndices, \r\n        uint count, \r\n        address payback\r\n    ) external payable override returns (uint[] memory prices) {\r\n        PricePair[0xFFFF] storage pairs = _pay(channelId, payback).pairs;\r\n\r\n        uint row = count << 1;\r\n        uint n = pairIndices.length * row;\r\n        prices = new uint[](n);\r\n        while (n > 0) {\r\n            n -= row;\r\n            uint[] memory pi = _lastPriceList(pairs[pairIndices[n / row]], count);\r\n            for (uint i = 0; i < row; ++i) {\r\n                prices[n + i] = pi[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns lastPriceList and triggered price info\r\n    /// @param channelId 报价通道编号\r\n    /// @param pairIndices 报价对编号\r\n    /// @param count The number of prices that want to return\r\n    /// @param payback 如果费用有多余的，则退回到此地址\r\n    /// @return prices 结果数组，第 i * (count * 2 + 4)到 (i + 1) * (count * 2 + 4)- 1为第i组报价对的价格结果\r\n    ///         其中前count * 2个为最新价格，后4个依次为：触发价格区块号，触发价格，平均价格，波动率\r\n    function lastPriceListAndTriggeredPriceInfo(\r\n        uint channelId, \r\n        uint[] calldata pairIndices,\r\n        uint count, \r\n        address payback\r\n    ) external payable override returns (uint[] memory prices) {\r\n        PricePair[0xFFFF] storage pairs = _pay(channelId, payback).pairs;\r\n\r\n        uint row = (count << 1) + 4;\r\n        uint n = pairIndices.length * row;\r\n        prices = new uint[](n);\r\n        while (n > 0) {\r\n            n -= row;\r\n\r\n            PricePair storage pair = pairs[pairIndices[n / row]];\r\n            uint[] memory pi = _lastPriceList(pair, count);\r\n            for (uint i = 0; i + 4 < row; ++i) {\r\n                prices[n + i] = pi[i];\r\n            }\r\n            uint j = n + row - 4;\r\n            (\r\n                prices[j],\r\n                prices[j + 1],\r\n                prices[j + 2],\r\n                prices[j + 3]\r\n            ) = _triggeredPriceInfo(pair);\r\n        }\r\n    }\r\n\r\n    // Payment of transfer fee\r\n    function _pay(uint channelId, address payback) private returns (PriceChannel storage channel) {\r\n\r\n        channel = _channels[channelId];\r\n        uint fee = uint(channel.singleFee) * DIMI_ETHER;\r\n        if (msg.value > fee) {\r\n            payable(payback).transfer(msg.value - fee);\r\n            // TODO: BSC上采用的是老的gas计算策略，直接转账可能导致代理合约gas超出，要改用下面的方式转账\r\n            //TransferHelper.safeTransferETH(payback, msg.value - fee);\r\n        } else {\r\n            require(msg.value == fee, \"NOP:!fee\");\r\n        }\r\n\r\n        channel.rewards += _toUInt96(fee);\r\n    }\r\n}"
    }
  }
}