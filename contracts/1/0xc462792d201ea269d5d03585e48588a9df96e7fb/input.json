{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/CompShifter_flat.sol": {
      "content": "\n// File: localhost/utils/Address.sol\n\npragma solidity ^0.6.0;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: localhost/utils/SafeERC20.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     */\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function _callOptionalReturn(ERC20 token, bytes memory data) private {\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// File: localhost/DS/DSNote.sol\n\npragma solidity ^0.6.0;\n\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n\n// File: localhost/DS/DSAuthority.sol\n\npragma solidity ^0.6.0;\n\n\nabstract contract DSAuthority {\n    function canCall(address src, address dst, bytes4 sig) public virtual view returns (bool);\n}\n\n// File: localhost/DS/DSAuth.sol\n\npragma solidity ^0.6.0;\n\n\n\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority public authority;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_) public auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_) public auth {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n// File: localhost/DS/DSProxy.sol\n\npragma solidity ^0.6.0;\n\n\n\n\nabstract contract DSProxy is DSAuth, DSNote {\n    DSProxyCache public cache; // global cache for contracts\n\n    constructor(address _cacheAddr) public {\n        require(setCache(_cacheAddr));\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    // use the proxy to execute calldata _data on contract _code\n    function execute(bytes memory _code, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (address target, bytes32 response);\n\n    function execute(address _target, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (bytes32 response);\n\n    //set new cache\n    function setCache(address _cacheAddr) public virtual payable returns (bool);\n}\n\n\ncontract DSProxyCache {\n    mapping(bytes32 => address) cache;\n\n    function read(bytes memory _code) public view returns (address) {\n        bytes32 hash = keccak256(_code);\n        return cache[hash];\n    }\n\n    function write(bytes memory _code) public returns (address target) {\n        assembly {\n            target := create(0, add(_code, 0x20), mload(_code))\n            switch iszero(extcodesize(target))\n                case 1 {\n                    // throw if contract failed to deploy\n                    revert(0, 0)\n                }\n        }\n        bytes32 hash = keccak256(_code);\n        cache[hash] = target;\n    }\n}\n\n// File: localhost/DS/DSMath.sol\n\npragma solidity ^0.6.0;\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n// File: localhost/mcd/Discount.sol\n\npragma solidity ^0.6.0;\n\n\ncontract Discount {\n    address public owner;\n    mapping(address => CustomServiceFee) public serviceFees;\n\n    uint256 constant MAX_SERVICE_FEE = 400;\n\n    struct CustomServiceFee {\n        bool active;\n        uint256 amount;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function isCustomFeeSet(address _user) public view returns (bool) {\n        return serviceFees[_user].active;\n    }\n\n    function getCustomServiceFee(address _user) public view returns (uint256) {\n        return serviceFees[_user].amount;\n    }\n\n    function setServiceFee(address _user, uint256 _fee) public {\n        require(msg.sender == owner, \"Only owner\");\n        require(_fee >= MAX_SERVICE_FEE || _fee == 0);\n\n        serviceFees[_user] = CustomServiceFee({active: true, amount: _fee});\n    }\n\n    function disableServiceFee(address _user) public {\n        require(msg.sender == owner, \"Only owner\");\n\n        serviceFees[_user] = CustomServiceFee({active: false, amount: 0});\n    }\n}\n\n// File: localhost/interfaces/ComptrollerInterface.sol\n\npragma solidity ^0.6.0;\n\n\nabstract contract ComptrollerInterface {\n    function enterMarkets(address[] calldata cTokens) external virtual returns (uint256[] memory);\n\n    function exitMarket(address cToken) external virtual returns (uint256);\n\n    function getAssetsIn(address account) external virtual view returns (address[] memory);\n\n    function markets(address account) public virtual view returns (bool, uint256);\n\n    function getAccountLiquidity(address account) external virtual view returns (uint256, uint256, uint256);\n\n    function claimComp(address holder) virtual public;\n}\n\n// File: localhost/interfaces/ERC20.sol\n\npragma solidity ^0.6.0;\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    function decimals() external view returns (uint256 digits);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n// File: localhost/interfaces/CTokenInterface.sol\n\npragma solidity ^0.6.0;\n\n\nabstract contract CTokenInterface is ERC20 {\n    function mint(uint256 mintAmount) external virtual returns (uint256);\n\n    function mint() external virtual payable;\n\n    function accrueInterest() public virtual returns (uint);\n\n    function redeem(uint256 redeemTokens) external virtual returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\n\n    function borrow(uint256 borrowAmount) external virtual returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\n\n    function repayBorrow() external virtual payable;\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (uint256);\n\n    function repayBorrowBehalf(address borrower) external virtual payable;\n\n    function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral)\n        external virtual\n        returns (uint256);\n\n    function liquidateBorrow(address borrower, address cTokenCollateral) external virtual payable;\n\n    function exchangeRateCurrent() external virtual returns (uint256);\n\n    function supplyRatePerBlock() external virtual returns (uint256);\n\n    function borrowRatePerBlock() external virtual returns (uint256);\n\n    function totalReserves() external virtual returns (uint256);\n\n    function reserveFactorMantissa() external virtual returns (uint256);\n\n    function borrowBalanceCurrent(address account) external view virtual returns (uint256);\n\n    function totalBorrowsCurrent() external virtual returns (uint256);\n\n    function getCash() external virtual returns (uint256);\n\n    function balanceOfUnderlying(address owner) external virtual returns (uint256);\n\n    function underlying() external virtual returns (address);\n\n    function getAccountSnapshot(address account) external virtual view returns (uint, uint, uint, uint);\n}\n\n// File: localhost/interfaces/CompoundOracleInterface.sol\n\npragma solidity ^0.6.0;\n\nabstract contract CompoundOracleInterface {\n    function getUnderlyingPrice(address cToken) external view virtual returns (uint);\n}\n\n// File: localhost/interfaces/CEtherInterface.sol\n\npragma solidity ^0.6.0;\n\nabstract contract CEtherInterface {\n    function mint() external virtual payable;\n    function repayBorrow() external virtual payable;\n}\n\n// File: localhost/compound/helpers/CompoundSaverHelper.sol\n\npragma solidity ^0.6.0;\n\n\n\n\n\n\n\n\n\n/// @title Utlity functions for Compound contracts\ncontract CompoundSaverHelper is DSMath {\n\n    using SafeERC20 for ERC20;\n\n    address payable public constant WALLET_ADDR = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    address public constant COMPOUND_LOGGER = 0x3DD0CDf5fFA28C6847B4B276e2fD256046a44bb7;\n    address public constant COMPOUND_ORACLE = 0xDDc46a3B076aec7ab3Fc37420A8eDd2959764Ec4;\n\n    /// @notice Helper method to payback the Compound debt\n    /// @dev If amount is bigger it will repay the whole debt and send the extra to the _user\n    /// @param _amount Amount of tokens we want to repay\n    /// @param _cBorrowToken Ctoken address we are repaying\n    /// @param _borrowToken Token address we are repaying\n    /// @param _user Owner of the compound position we are paying back\n    function paybackDebt(uint _amount, address _cBorrowToken, address _borrowToken, address payable _user) internal {\n        uint wholeDebt = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(address(this));\n\n        if (_amount > wholeDebt) {\n            if (_borrowToken == ETH_ADDRESS) {\n                _user.transfer((_amount - wholeDebt));\n            } else {\n                ERC20(_borrowToken).safeTransfer(_user, (_amount - wholeDebt));\n            }\n\n            _amount = wholeDebt;\n        }\n\n        approveCToken(_borrowToken, _cBorrowToken);\n\n        if (_borrowToken == ETH_ADDRESS) {\n            CEtherInterface(_cBorrowToken).repayBorrow{value: _amount}();\n        } else {\n            require(CTokenInterface(_cBorrowToken).repayBorrow(_amount) == 0);\n        }\n    }\n\n    /// @notice Calculates the fee amount\n    /// @param _amount Amount that is converted\n    /// @param _user Actuall user addr not DSProxy\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\n    /// @return feeAmount The amount we took for the fee\n    function getFee(uint _amount, address _user, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\n        uint fee = SERVICE_FEE;\n\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\n\n        if (Discount(DISCOUNT_ADDR).isCustomFeeSet(_user)) {\n            fee = Discount(DISCOUNT_ADDR).getCustomServiceFee(_user);\n        }\n\n        feeAmount = (fee == 0) ? 0 : (_amount / fee);\n\n        if (_gasCost != 0) {\n            uint ethTokenPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cTokenAddr);\n            _gasCost = rmul(_gasCost, ethTokenPrice);\n\n            feeAmount = add(feeAmount, _gasCost);\n        }\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        if (tokenAddr == ETH_ADDRESS) {\n            WALLET_ADDR.transfer(feeAmount);\n        } else {\n            ERC20(tokenAddr).safeTransfer(WALLET_ADDR, feeAmount);\n        }\n    }\n\n    /// @notice Calculates the gas cost of transaction and send it to wallet\n    /// @param _amount Amount that is converted\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\n    /// @return feeAmount The amount we took for the fee\n    function getGasCost(uint _amount, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\n\n        if (_gasCost != 0) {\n            uint ethTokenPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cTokenAddr);\n            feeAmount = rmul(_gasCost, ethTokenPrice);\n        }\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        if (tokenAddr == ETH_ADDRESS) {\n            WALLET_ADDR.transfer(feeAmount);\n        } else {\n            ERC20(tokenAddr).safeTransfer(WALLET_ADDR, feeAmount);\n        }\n    }\n\n    /// @notice Enters the market for the collatera and borrow tokens\n    /// @param _cTokenAddrColl Collateral address we are entering the market in\n    /// @param _cTokenAddrBorrow Borrow address we are entering the market in\n    function enterMarket(address _cTokenAddrColl, address _cTokenAddrBorrow) internal {\n        address[] memory markets = new address[](2);\n        markets[0] = _cTokenAddrColl;\n        markets[1] = _cTokenAddrBorrow;\n\n        ComptrollerInterface(COMPTROLLER).enterMarkets(markets);\n    }\n\n    /// @notice Approves CToken contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _cTokenAddr Address which will gain the approval\n    function approveCToken(address _tokenAddr, address _cTokenAddr) internal {\n        if (_tokenAddr != ETH_ADDRESS) {\n            ERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\n        }\n    }\n\n    /// @notice Returns the underlying address of the cToken asset\n    /// @param _cTokenAddress cToken address\n    /// @return Token address of the cToken specified\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\n        if (_cTokenAddress == CETH_ADDRESS) {\n            return ETH_ADDRESS;\n        } else {\n            return CTokenInterface(_cTokenAddress).underlying();\n        }\n    }\n\n    /// @notice Returns the owner of the DSProxy that called the contract\n    function getUserAddress() internal view returns (address) {\n        DSProxy proxy = DSProxy(uint160(address(this)));\n\n        return proxy.owner();\n    }\n\n    /// @notice Returns the maximum amount of collateral available to withdraw\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cCollAddress Collateral we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. collateral amount in that token\n    function getMaxCollateral(address _cCollAddress, address _account) public returns (uint) {\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n        uint usersBalance = CTokenInterface(_cCollAddress).balanceOfUnderlying(_account);\n\n        if (liquidityInEth == 0) return usersBalance;\n\n        CTokenInterface(_cCollAddress).accrueInterest();\n\n        if (_cCollAddress == CETH_ADDRESS) {\n            if (liquidityInEth > usersBalance) return usersBalance;\n\n            return sub(liquidityInEth, (liquidityInEth / 100));\n        }\n\n        uint ethPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cCollAddress);\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\n\n        if (liquidityInToken > usersBalance) return usersBalance;\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }\n\n    /// @notice Returns the maximum amount of borrow amount available\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cBorrowAddress Borrow token we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. borrow amount in that token\n    function getMaxBorrow(address _cBorrowAddress, address _account) public returns (uint) {\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n\n        CTokenInterface(_cBorrowAddress).accrueInterest();\n\n        if (_cBorrowAddress == CETH_ADDRESS) return sub(liquidityInEth, (liquidityInEth / 100));\n\n        uint ethPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cBorrowAddress);\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }\n}\n\n// File: localhost/shifter/protocols/CompShifter.sol\n\npragma solidity ^0.6.0;\n\n\ncontract CompShifter is CompoundSaverHelper {\n\n    address public constant COMPTROLLER_ADDR = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    function getWholeDebt(uint _cdpId, address _joinAddr) public view virtual returns(uint loanAmount) {\n        return CTokenInterface(_joinAddr).borrowBalanceCurrent(msg.sender);\n    }\n\n    function close(\n        address _cCollAddr,\n        address _cBorrowAddr,\n        uint _collAmount,\n        uint _debtAmount\n    ) public {\n        address collAddr = getUnderlyingAddr(_cCollAddr);\n\n        // payback debt\n        paybackDebt(_debtAmount, _cBorrowAddr, getUnderlyingAddr(_cBorrowAddr), tx.origin);\n\n        // draw coll\n        if (CTokenInterface(_cBorrowAddr).borrowBalanceCurrent(address(this)) == 0) {\n            uint cTokenBalance = CTokenInterface(_cCollAddr).balanceOf(address(this));\n            require(CTokenInterface(_cCollAddr).redeem(cTokenBalance) == 0);\n        } else {\n            require(CTokenInterface(_cCollAddr).redeemUnderlying(_collAmount) == 0);\n        }\n\n        // Send back money to repay FL\n        if (collAddr == ETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(collAddr).transfer(msg.sender, ERC20(collAddr).balanceOf(address(this)));\n        }\n    }\n\n    function open(\n        address _cCollAddr,\n        address _cBorrowAddr,\n        uint _collAmount,\n        uint _debtAmount\n    ) public {\n\n        address collAddr = getUnderlyingAddr(_cCollAddr);\n        address borrowAddr = getUnderlyingAddr(_cBorrowAddr);\n\n        depositCompound(collAddr, _cCollAddr, _collAmount);\n\n        // draw debt\n        borrowCompound(_cBorrowAddr, _debtAmount);\n\n        // Send back money to repay FL\n        if (borrowAddr == ETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(borrowAddr).transfer(msg.sender, ERC20(borrowAddr).balanceOf(address(this)));\n        }\n    }\n\n    function depositCompound(address _tokenAddr, address _cTokenAddr, uint _amount) internal {\n        approveCToken(_tokenAddr, _cTokenAddr);\n\n        enterMarket(_cTokenAddr);\n\n        if (_tokenAddr != ETH_ADDRESS) {\n            require(CTokenInterface(_cTokenAddr).mint(_amount) == 0);\n        } else {\n            CEtherInterface(_cTokenAddr).mint{value: _amount}();\n        }\n    }\n\n    function borrowCompound(address _cTokenAddr, uint _amount) internal {\n        enterMarket(_cTokenAddr);\n\n        require(CTokenInterface(_cTokenAddr).borrow(_amount) == 0);\n    }\n\n    function enterMarket(address _cTokenAddr) public {\n        address[] memory markets = new address[](1);\n        markets[0] = _cTokenAddr;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n    }\n\n}\n"
    }
  }
}