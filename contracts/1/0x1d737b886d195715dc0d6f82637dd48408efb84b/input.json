{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Copy_ABDKMath64x64.sol": {
      "content": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.5.0 || ^0.6.0 || ^0.7.0;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /*\n   * Minimum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /*\n   * Maximum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromInt (int256 x) internal pure returns (int128) {\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n    return int128 (x << 64);\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n   * rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n  function toInt (int128 x) internal pure returns (int64) {\n    return int64 (x >> 64);\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromUInt (uint256 x) internal pure returns (int128) {\n    require (x <= 0x7FFFFFFFFFFFFFFF);\n    return int128 (x << 64);\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n   * number rounding down.  Revert on underflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n  function toUInt (int128 x) internal pure returns (uint64) {\n    require (x >= 0);\n    return uint64 (x >> 64);\n  }\n\n  /**\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n   * number rounding down.  Revert on overflow.\n   *\n   * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function from128x128 (int256 x) internal pure returns (int128) {\n    int256 result = x >> 64;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n   * number.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n  function to128x128 (int128 x) internal pure returns (int256) {\n    return int256 (x) << 64;\n  }\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add (int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) + y;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate x - y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sub (int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) - y;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate x * y rounding down.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function mul (int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) * y >> 64;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n   * number and y is signed 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n  function muli (int128 x, int256 y) internal pure returns (int256) {\n    if (x == MIN_64x64) {\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n        y <= 0x1000000000000000000000000000000000000000000000000);\n      return -y << 63;\n    } else {\n      bool negativeResult = false;\n      if (x < 0) {\n        x = -x;\n        negativeResult = true;\n      }\n      if (y < 0) {\n        y = -y; // We rely on overflow behavior here\n        negativeResult = !negativeResult;\n      }\n      uint256 absoluteResult = mulu (x, uint256 (y));\n      if (negativeResult) {\n        require (absoluteResult <=\n          0x8000000000000000000000000000000000000000000000000000000000000000);\n        return -int256 (absoluteResult); // We rely on overflow behavior here\n      } else {\n        require (absoluteResult <=\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int256 (absoluteResult);\n      }\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    if (y == 0) return 0;\n\n    require (x >= 0);\n\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n    uint256 hi = uint256 (x) * (y >> 128);\n\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n    hi <<= 64;\n\n    require (hi <=\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n    return hi + lo;\n  }\n\n  /**\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function div (int128 x, int128 y) internal pure returns (int128) {\n    require (y != 0);\n    int256 result = (int256 (x) << 64) / y;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divi (int256 x, int256 y) internal pure returns (int128) {\n    require (y != 0);\n\n    bool negativeResult = false;\n    if (x < 0) {\n      x = -x; // We rely on overflow behavior here\n      negativeResult = true;\n    }\n    if (y < 0) {\n      y = -y; // We rely on overflow behavior here\n      negativeResult = !negativeResult;\n    }\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n    if (negativeResult) {\n      require (absoluteResult <= 0x80000000000000000000000000000000);\n      return -int128 (absoluteResult); // We rely on overflow behavior here\n    } else {\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return int128 (absoluteResult); // We rely on overflow behavior here\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\n    require (y != 0);\n    uint128 result = divuu (x, y);\n    require (result <= uint128 (MAX_64x64));\n    return int128 (result);\n  }\n\n  /**\n   * Calculate -x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function neg (int128 x) internal pure returns (int128) {\n    require (x != MIN_64x64);\n    return -x;\n  }\n\n  /**\n   * Calculate |x|.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function abs (int128 x) internal pure returns (int128) {\n    require (x != MIN_64x64);\n    return x < 0 ? -x : x;\n  }\n\n  /**\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function inv (int128 x) internal pure returns (int128) {\n    require (x != 0);\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function avg (int128 x, int128 y) internal pure returns (int128) {\n    return int128 ((int256 (x) + int256 (y)) >> 1);\n  }\n\n  /**\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n   * Revert on overflow or in case x * y is negative.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\n    int256 m = int256 (x) * int256 (y);\n    require (m >= 0);\n    require (m <\n        0x4000000000000000000000000000000000000000000000000000000000000000);\n    return int128 (sqrtu (uint256 (m)));\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\n    bool negative = x < 0 && y & 1 == 1;\n\n    uint256 absX = uint128 (x < 0 ? -x : x);\n    uint256 absResult;\n    absResult = 0x100000000000000000000000000000000;\n\n    if (absX <= 0x10000000000000000) {\n      absX <<= 63;\n      while (y != 0) {\n        if (y & 0x1 != 0) {\n          absResult = absResult * absX >> 127;\n        }\n        absX = absX * absX >> 127;\n\n        if (y & 0x2 != 0) {\n          absResult = absResult * absX >> 127;\n        }\n        absX = absX * absX >> 127;\n\n        if (y & 0x4 != 0) {\n          absResult = absResult * absX >> 127;\n        }\n        absX = absX * absX >> 127;\n\n        if (y & 0x8 != 0) {\n          absResult = absResult * absX >> 127;\n        }\n        absX = absX * absX >> 127;\n\n        y >>= 4;\n      }\n\n      absResult >>= 64;\n    } else {\n      uint256 absXShift = 63;\n      if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\n      if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\n      if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\n      if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\n      if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\n      if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\n\n      uint256 resultShift = 0;\n      while (y != 0) {\n        require (absXShift < 64);\n\n        if (y & 0x1 != 0) {\n          absResult = absResult * absX >> 127;\n          resultShift += absXShift;\n          if (absResult > 0x100000000000000000000000000000000) {\n            absResult >>= 1;\n            resultShift += 1;\n          }\n        }\n        absX = absX * absX >> 127;\n        absXShift <<= 1;\n        if (absX >= 0x100000000000000000000000000000000) {\n            absX >>= 1;\n            absXShift += 1;\n        }\n\n        y >>= 1;\n      }\n\n      require (resultShift < 64);\n      absResult >>= 64 - resultShift;\n    }\n    int256 result = negative ? -int256 (absResult) : int256 (absResult);\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sqrt (int128 x) internal pure returns (int128) {\n    require (x >= 0);\n    return int128 (sqrtu (uint256 (x) << 64));\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function log_2 (int128 x) internal pure returns (int128) {\n    require (x > 0);\n\n    int256 msb = 0;\n    int256 xc = x;\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n    int256 result = msb - 64 << 64;\n    uint256 ux = uint256 (x) << uint256 (127 - msb);\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n      ux *= ux;\n      uint256 b = ux >> 255;\n      ux >>= 127 + b;\n      result += bit * int256 (b);\n    }\n\n    return int128 (result);\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function ln (int128 x) internal pure returns (int128) {\n    require (x > 0);\n\n    return int128 (\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\n  }\n\n  /**\n   * Calculate binary exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp_2 (int128 x) internal pure returns (int128) {\n    require (x < 0x400000000000000000); // Overflow\n\n    if (x < -0x400000000000000000) return 0; // Underflow\n\n    uint256 result = 0x80000000000000000000000000000000;\n\n    if (x & 0x8000000000000000 > 0)\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n    if (x & 0x4000000000000000 > 0)\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n    if (x & 0x2000000000000000 > 0)\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n    if (x & 0x1000000000000000 > 0)\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n    if (x & 0x800000000000000 > 0)\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n    if (x & 0x400000000000000 > 0)\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n    if (x & 0x200000000000000 > 0)\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n    if (x & 0x100000000000000 > 0)\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n    if (x & 0x80000000000000 > 0)\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n    if (x & 0x40000000000000 > 0)\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n    if (x & 0x20000000000000 > 0)\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n    if (x & 0x10000000000000 > 0)\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n    if (x & 0x8000000000000 > 0)\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n    if (x & 0x4000000000000 > 0)\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n    if (x & 0x2000000000000 > 0)\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n    if (x & 0x1000000000000 > 0)\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n    if (x & 0x800000000000 > 0)\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n    if (x & 0x400000000000 > 0)\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n    if (x & 0x200000000000 > 0)\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n    if (x & 0x100000000000 > 0)\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n    if (x & 0x80000000000 > 0)\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n    if (x & 0x40000000000 > 0)\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n    if (x & 0x20000000000 > 0)\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n    if (x & 0x10000000000 > 0)\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n    if (x & 0x8000000000 > 0)\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n    if (x & 0x4000000000 > 0)\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n    if (x & 0x2000000000 > 0)\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n    if (x & 0x1000000000 > 0)\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n    if (x & 0x800000000 > 0)\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n    if (x & 0x400000000 > 0)\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n    if (x & 0x200000000 > 0)\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n    if (x & 0x100000000 > 0)\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n    if (x & 0x80000000 > 0)\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n    if (x & 0x40000000 > 0)\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n    if (x & 0x20000000 > 0)\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n    if (x & 0x10000000 > 0)\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n    if (x & 0x8000000 > 0)\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n    if (x & 0x4000000 > 0)\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n    if (x & 0x2000000 > 0)\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n    if (x & 0x1000000 > 0)\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n    if (x & 0x800000 > 0)\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n    if (x & 0x400000 > 0)\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n    if (x & 0x200000 > 0)\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n    if (x & 0x100000 > 0)\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n    if (x & 0x80000 > 0)\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n    if (x & 0x40000 > 0)\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n    if (x & 0x20000 > 0)\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n    if (x & 0x10000 > 0)\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n    if (x & 0x8000 > 0)\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n    if (x & 0x4000 > 0)\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n    if (x & 0x2000 > 0)\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n    if (x & 0x1000 > 0)\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n    if (x & 0x800 > 0)\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n    if (x & 0x400 > 0)\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n    if (x & 0x200 > 0)\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n    if (x & 0x100 > 0)\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n    if (x & 0x80 > 0)\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n    if (x & 0x40 > 0)\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n    if (x & 0x20 > 0)\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n    if (x & 0x10 > 0)\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n    if (x & 0x8 > 0)\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n    if (x & 0x4 > 0)\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n    if (x & 0x2 > 0)\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n    if (x & 0x1 > 0)\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n\n    result >>= uint256 (63 - (x >> 64));\n    require (result <= uint256 (MAX_64x64));\n\n    return int128 (result);\n  }\n\n  /**\n   * Calculate natural exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp (int128 x) internal pure returns (int128) {\n    require (x < 0x400000000000000000); // Overflow\n\n    if (x < -0x400000000000000000) return 0; // Underflow\n\n    return exp_2 (\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n    require (y != 0);\n\n    uint256 result;\n\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n      result = (x << 64) / y;\n    else {\n      uint256 msb = 192;\n      uint256 xc = x >> 192;\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n      uint256 hi = result * (y >> 128);\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n      uint256 xh = x >> 192;\n      uint256 xl = x << 64;\n\n      if (xl < lo) xh -= 1;\n      xl -= lo; // We rely on overflow behavior here\n      lo = hi << 128;\n      if (xl < lo) xh -= 1;\n      xl -= lo; // We rely on overflow behavior here\n\n      assert (xh == hi >> 128);\n\n      result += xl / y;\n    }\n\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n    return uint128 (result);\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n   * number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n  function sqrtu (uint256 x) private pure returns (uint128) {\n    if (x == 0) return 0;\n    else {\n      uint256 xx = x;\n      uint256 r = 1;\n      if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n      if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n      if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n      if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n      if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n      if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n      if (xx >= 0x8) { r <<= 1; }\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1;\n      r = (r + x / r) >> 1; // Seven iterations should be enough\n      uint256 r1 = x / r;\n      return uint128 (r < r1 ? r : r1);\n    }\n  }\n}"
    },
    "Copy_Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\n\n/// @title All shared constants for the Notional system should be declared here.\nlibrary Constants {\n    // Return code for cTokens that represents no error\n    uint256 internal constant COMPOUND_RETURN_CODE_NO_ERROR = 0;\n    uint8 internal constant CETH_DECIMAL_PLACES = 8;\n\n    // Token precision used for all internal balances, TokenHandler library ensures that we\n    // limit the dust amount caused by precision mismatches\n    int256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\n\n    // ETH will be initialized as the first currency\n    uint256 internal constant ETH_CURRENCY_ID = 1;\n    uint8 internal constant ETH_DECIMAL_PLACES = 18;\n    int256 internal constant ETH_DECIMALS = 1e18;\n    // Used to prevent overflow when converting decimal places to decimal precision values via\n    // 10**decimalPlaces. This is a safe value for int256 and uint256 variables. We apply this\n    // constraint when storing decimal places in governance.\n    uint256 internal constant MAX_DECIMAL_PLACES = 36;\n\n    // Address of the reserve account\n    address internal constant RESERVE = address(0);\n    // NOTE: this address is hardcoded in the library, must update this on deployment\n    address constant NOTE_TOKEN_ADDRESS = 0xCFEAead4947f0705A14ec42aC3D44129E1Ef3eD5;\n\n    // Most significant bit\n    bytes32 internal constant MSB =\n        0x8000000000000000000000000000000000000000000000000000000000000000;\n\n    // Basis for percentages\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    // Max number of traded markets, also used as the maximum number of assets in a portfolio array\n    uint256 internal constant MAX_TRADED_MARKET_INDEX = 7;\n    // Max number of fCash assets in a bitmap, this is based on the gas costs of calculating free collateral\n    // for a bitmap portfolio\n    uint256 internal constant MAX_BITMAP_ASSETS = 20;\n    uint256 internal constant FIVE_MINUTES = 300;\n\n    // Internal date representations, note we use a 6/30/360 week/month/year convention here\n    uint256 internal constant DAY = 86400;\n    // We use six day weeks to ensure that all time references divide evenly\n    uint256 internal constant WEEK = DAY * 6;\n    uint256 internal constant MONTH = WEEK * 5;\n    uint256 internal constant QUARTER = MONTH * 3;\n    uint256 internal constant YEAR = QUARTER * 4;\n    \n    // These constants are used in DateTime.sol\n    uint256 internal constant DAYS_IN_WEEK = 6;\n    uint256 internal constant DAYS_IN_MONTH = 30;\n    uint256 internal constant DAYS_IN_QUARTER = 90;\n\n    // Offsets for each time chunk denominated in days\n    uint256 internal constant MAX_DAY_OFFSET = 90;\n    uint256 internal constant MAX_WEEK_OFFSET = 360;\n    uint256 internal constant MAX_MONTH_OFFSET = 2160;\n    uint256 internal constant MAX_QUARTER_OFFSET = 7650;\n\n    // Offsets for each time chunk denominated in bits\n    uint256 internal constant WEEK_BIT_OFFSET = 90;\n    uint256 internal constant MONTH_BIT_OFFSET = 135;\n    uint256 internal constant QUARTER_BIT_OFFSET = 195;\n\n    // This is a constant that represents the time period that all rates are normalized by, 360 days\n    uint256 internal constant IMPLIED_RATE_TIME = 360 * DAY;\n    // Number of decimal places that rates are stored in, equals 100%\n    int256 internal constant RATE_PRECISION = 1e9;\n    // One basis point in RATE_PRECISION terms\n    uint256 internal constant BASIS_POINT = uint256(RATE_PRECISION / 10000);\n    // Used to when calculating the amount to deleverage of a market when minting nTokens\n    uint256 internal constant DELEVERAGE_BUFFER = 300 * BASIS_POINT;\n    // Used for scaling cash group factors\n    uint256 internal constant FIVE_BASIS_POINTS = 5 * BASIS_POINT;\n    // Used for residual purchase incentive and cash withholding buffer\n    uint256 internal constant TEN_BASIS_POINTS = 10 * BASIS_POINT;\n\n    // This is the ABDK64x64 representation of RATE_PRECISION\n    // RATE_PRECISION_64x64 = ABDKMath64x64.fromUint(RATE_PRECISION)\n    int128 internal constant RATE_PRECISION_64x64 = 0x3b9aca000000000000000000;\n    int128 internal constant LOG_RATE_PRECISION_64x64 = 382276781265598821176;\n    // Limit the market proportion so that borrowing cannot hit extremely high interest rates\n    int256 internal constant MAX_MARKET_PROPORTION = RATE_PRECISION * 96 / 100;\n\n    uint8 internal constant FCASH_ASSET_TYPE = 1;\n    // Liquidity token asset types are 1 + marketIndex (where marketIndex is 1-indexed)\n    uint8 internal constant MIN_LIQUIDITY_TOKEN_INDEX = 2;\n    uint8 internal constant MAX_LIQUIDITY_TOKEN_INDEX = 8;\n\n    // Used for converting bool to bytes1, solidity does not have a native conversion\n    // method for this\n    bytes1 internal constant BOOL_FALSE = 0x00;\n    bytes1 internal constant BOOL_TRUE = 0x01;\n\n    // Account context flags\n    bytes1 internal constant HAS_ASSET_DEBT = 0x01;\n    bytes1 internal constant HAS_CASH_DEBT = 0x02;\n    bytes2 internal constant ACTIVE_IN_PORTFOLIO = 0x8000;\n    bytes2 internal constant ACTIVE_IN_BALANCES = 0x4000;\n    bytes2 internal constant UNMASK_FLAGS = 0x3FFF;\n    uint16 internal constant MAX_CURRENCIES = uint16(UNMASK_FLAGS);\n\n    // Equal to 100% of all deposit amounts for nToken liquidity across fCash markets.\n    int256 internal constant DEPOSIT_PERCENT_BASIS = 1e8;\n\n    // nToken Parameters: there are offsets in the nTokenParameters bytes6 variable returned\n    // in nTokenHandler. Each constant represents a position in the byte array.\n    uint8 internal constant LIQUIDATION_HAIRCUT_PERCENTAGE = 0;\n    uint8 internal constant CASH_WITHHOLDING_BUFFER = 1;\n    uint8 internal constant RESIDUAL_PURCHASE_TIME_BUFFER = 2;\n    uint8 internal constant PV_HAIRCUT_PERCENTAGE = 3;\n    uint8 internal constant RESIDUAL_PURCHASE_INCENTIVE = 4;\n\n    // Liquidation parameters\n    // Default percentage of collateral that a liquidator is allowed to liquidate, will be higher if the account\n    // requires more collateral to be liquidated\n    int256 internal constant DEFAULT_LIQUIDATION_PORTION = 40;\n    // Percentage of local liquidity token cash claim delivered to the liquidator for liquidating liquidity tokens\n    int256 internal constant TOKEN_REPO_INCENTIVE_PERCENT = 30;\n\n    // Pause Router liquidation enabled states\n    bytes1 internal constant LOCAL_CURRENCY_ENABLED = 0x01;\n    bytes1 internal constant COLLATERAL_CURRENCY_ENABLED = 0x02;\n    bytes1 internal constant LOCAL_FCASH_ENABLED = 0x04;\n    bytes1 internal constant CROSS_CURRENCY_FCASH_ENABLED = 0x08;\n}\n"
    },
    "Copy_SafeInt256.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\nimport \"./Copy_Constants.sol\";\nlibrary SafeInt256 {\n    int256 private constant _INT256_MIN = type(int256).min;\n\n    /// @dev Returns the multiplication of two signed integers, reverting on\n    /// overflow.\n\n    /// Counterpart to Solidity's `*` operator.\n\n    /// Requirements:\n\n    /// - Multiplication cannot overflow.\n\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\n        c = a * b;\n        if (a == -1) require (b == 0 || c / b == a);\n        else require (a == 0 || c / a == b);\n    }\n\n    /// @dev Returns the integer division of two signed integers. Reverts on\n    /// division by zero. The result is rounded towards zero.\n\n    /// Counterpart to Solidity's `/` operator. Note: this function uses a\n    /// `revert` opcode (which leaves remaining gas untouched) while Solidity\n    /// uses an invalid opcode to revert (consuming all remaining gas).\n\n    /// Requirements:\n\n    /// - The divisor cannot be zero.\n\n    function div(int256 a, int256 b) internal pure returns (int256 c) {\n        require(!(b == -1 && a == _INT256_MIN)); // dev: int256 div overflow\n        // NOTE: solidity will automatically revert on divide by zero\n        c = a / b;\n    }\n\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        //  taken from uniswap v3\n        require((z = x - y) <= x == (y >= 0));\n    }\n\n    function add(int256 x, int256 y) internal view returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    function neg(int256 x) internal pure returns (int256 y) {\n        return mul(-1, x);\n    }\n\n    function abs(int256 x) internal pure returns (int256) {\n        if (x < 0) return neg(x);\n        else return x;\n    }\n\n    function subNoNeg(int256 x, int256 y) internal pure returns (int256 z) {\n        z = sub(x, y);\n        require(z >= 0); // dev: int256 sub to negative\n\n        return z;\n    }\n\n    /// @dev Calculates x * RATE_PRECISION / y while checking overflows\n    function divInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\n        return div(mul(x, Constants.RATE_PRECISION), y);\n    }\n\n    /// @dev Calculates x * y / RATE_PRECISION while checking overflows\n    function mulInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\n        return div(mul(x, y), Constants.RATE_PRECISION);\n    }\n\n    function toUint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function toInt(uint256 x) internal pure returns (int256) {\n        require (x <= uint256(type(int256).max)); // dev: toInt overflow\n        return int256(x);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return x > y ? x : y;\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return x < y ? x : y;\n    }\n}\n"
    },
    "erc20.sol": {
      "content": "pragma solidity ^0.7.0;\r\ninterface ICERC20 {\r\n    function transfer(address dst, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);  \r\n}"
    },
    "notional.sol": {
      "content": "// SPDX-License-Identifier: GPL-v3\r\npragma solidity >=0.7.0;\r\npragma abicoder v2 ;\r\nimport \"./types.sol\";\r\n/// @notice Used as a wrapper for tokens that are interest bearing for an\r\n/// underlying token. Follows the cToken interface, however, can be adapted\r\n/// for other interest bearing tokens.\r\ninterface Notional {\r\n    function initializeMarkets(uint16 currencyId, bool isFirstInit) external;\r\n    function getMarket(uint16 currencyId,uint256 maturity,uint256 settlementDate)external view returns (MarketParameters memory);\r\n\r\n     /// @notice Returns the cash group along with the asset rate for convenience.\r\n    function getCashGroupAndAssetRate(uint16 currencyId) external  view returns (CashGroupSettings memory cashGroup, AssetRateParameters memory assetRate);\r\n\r\n    function batchBalanceAndTradeAction(address account, BalanceActionWithTrades[] calldata actions) external payable ;\r\n\r\n    /// @notice Returns account context\r\n    function getAccountContext(address account) external  view  returns (AccountContext memory);\r\n    \r\n\r\n     /// @notice Returns the asset settlement rate for a given maturity\r\n    function getSettlementRate(uint16 currencyId, uint40 maturity)  external   view   returns (AssetRateParameters memory) ;\r\n}\r\n"
    },
    "owner.sol": {
      "content": "pragma solidity ^0.7.0;\r\ncontract Owner {\r\n\r\n    address private owner;\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier isOwner() {\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public isOwner {\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}"
    },
    "sf.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"
    },
    "taoli.sol": {
      "content": "pragma solidity ^0.7.0;\r\npragma abicoder v2;\r\nimport \"./Copy_Constants.sol\";\r\nimport \"./Copy_ABDKMath64x64.sol\";\r\nimport \"./Copy_SafeInt256.sol\";\r\nimport \"./sf.sol\";\r\nimport \"./types.sol\";\r\nimport \"./notional.sol\";\r\nimport \"./owner.sol\";\r\nimport \"./erc20.sol\";\r\n\r\n\r\n\r\ncontract Taoli is Owner{\r\n    using SafeMath for uint256;\r\n    using SafeInt256 for int256;\r\n\r\n    int256 private constant ASSET_RATE_DECIMAL_DIFFERENCE = 1e10;\r\n    address public notional = 0xA5555198A78430623F23fE041b78F7Eb1240CBc5 ;\r\n    uint256 settlementPenalty = 50 * 5 * 1e5 ; //罚息利率   250 / 10000 *精度(1e9)\r\n\r\n    constructor(address notionalAddress) {\r\n        notional = notionalAddress ;\r\n    }\r\n\r\n\r\n    // function cons\r\n\r\n    /// @notice Converts an implied rate to an exchange rate given a time to maturity. The\r\n    /// formula is E = e^rt\r\n    function getExchangeRateFromImpliedRate(uint256 impliedRate, uint256 timeToMaturity)\r\n        public\r\n        view\r\n        returns (int256)\r\n    {\r\n        int128 expValue =\r\n            ABDKMath64x64.fromUInt(\r\n                impliedRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME)\r\n            );\r\n        int128 expValueScaled = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\r\n        int128 expResult = ABDKMath64x64.exp(expValueScaled);\r\n        int128 expResultScaled = ABDKMath64x64.mul(expResult, Constants.RATE_PRECISION_64x64);\r\n\r\n        return ABDKMath64x64.toInt(expResultScaled);\r\n    }\r\n\r\n\r\n   \r\n\r\n\r\n\r\n    /// @notice Returns a single market\r\n    function CallTest(\r\n        uint16 currencyId\r\n    )\r\n        external\r\n        view\r\n        returns (MarketParameters memory)\r\n    {   \r\n        Notional notionalContract = Notional(notional) ;\r\n        MarketParameters   memory market  = notionalContract.getMarket(currencyId,1,1) ;\r\n        return market;\r\n      \r\n    }\r\n\r\n    function RateTestCallTest( uint16 currencyId)   external  view  returns ( AssetRateParameters memory  )\r\n    {   \r\n        Notional notionalContract = Notional(notional) ;\r\n        CashGroupSettings memory cashGroup;\r\n        AssetRateParameters memory assetRate ;\r\n        (cashGroup,assetRate) = notionalContract.getCashGroupAndAssetRate(currencyId) ;\r\n        return assetRate;\r\n      \r\n    }\r\n\r\n    // 0xd8b934580fcE35a11B58C6D73aDeE468a2833fa8\r\n\r\n    \r\n\r\n    function CalculateTest( uint16 currencyId,int256 amountToSettleAsset)   external  view  returns (int256){\r\n        \r\n        Notional notionalContract = Notional(notional) ;\r\n        CashGroupSettings memory cashGroup;\r\n        AssetRateParameters memory assetRate ;\r\n        (cashGroup,assetRate) = notionalContract.getCashGroupAndAssetRate(currencyId) ;\r\n        MarketParameters   memory market  = notionalContract.getMarket(currencyId,1,1) ;\r\n        return calculatfcashByassestCash(amountToSettleAsset,market,assetRate);\r\n    }\r\n\r\n   \r\n    //计算罚息的fcash\r\n    function calculatfcashByassestCash(int256 amountToSettleAsset,MarketParameters memory market,AssetRateParameters memory assetRate)   public view returns (int256) {\r\n      \r\n        uint256 threeMonthMaturity = getThreeMatyrityOrSettlementDate(block.timestamp) ;\r\n        uint256 blockTime = block.timestamp ;\r\n       \r\n       //  uint256 oracleRate = calculateOracleRate(currencyId,threeMonthMaturity, blockTime);   这里不需要计算了 oracleRate就是我们call过来的oracleRate\r\n        uint256 oracleRate = market.oracleRate ;\r\n\r\n       \r\n        int256 exchangeRate = getExchangeRateFromImpliedRate(\r\n                oracleRate.add(settlementPenalty),\r\n                threeMonthMaturity.sub(blockTime)\r\n            );\r\n\r\n        // Amount to settle is positive, this returns the fCashAmount that the settler will\r\n        // receive as a positive number\r\n        return convertToUnderlying(amountToSettleAsset,assetRate.rate,assetRate.underlyingDecimals)\r\n                // Exchange rate converts from cash to fCash when multiplying\r\n                .mulInRatePrecision(exchangeRate);\r\n\r\n\r\n    }\r\n\r\n\r\n      \r\n\r\n    /// @notice Converts an internal asset cash value to its underlying token value.\r\n    /// @param assetRate exchange rate\r\n    /// @param assetBalance amount to convert to underlying\r\n    function convertToUnderlying(int256 assetBalance, int256 assetRate, int256 underlyingDecimals)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        // Calculation here represents:\r\n        // rate * balance * internalPrecision / rateDecimals * underlyingPrecision\r\n        int256 underlyingBalance = assetRate\r\n            .mul(assetBalance)\r\n            .div(ASSET_RATE_DECIMAL_DIFFERENCE)\r\n            .div(underlyingDecimals);\r\n\r\n        return underlyingBalance;\r\n    }\r\n\r\n    \r\n    function convertFromUnderlying(int256 underlyingBalance, int256 assetRate, int256 underlyingDecimals)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        // Calculation here represents:\r\n        // rateDecimals * balance * underlyingPrecision / rate * internalPrecision\r\n        int256 assetBalance = underlyingBalance\r\n            .mul(ASSET_RATE_DECIMAL_DIFFERENCE)\r\n            .mul(underlyingDecimals)\r\n            .div(assetRate);\r\n\r\n        return assetBalance;\r\n    }\r\n\r\n\r\n\r\n  //测试返回最终交易数组参数\r\n  /*\r\n  function settleCurrencyTest( uint16 currencyId,AccountList[] memory accountList)    external view returns( BalanceActionWithTrades[] memory ) {\r\n        // uint256 maturity = 1640736000 ; //2021-12-29 00:00:00\r\n        uint256 threeMonthMaturity = 1648512000 ; // 2022-03-29 00:00:00 \r\n        // uint256 settlementDate = threeMonthMaturity ; //\r\n\r\n        // require(block.timestamp >= maturity,\"NO NEED TO SETTLE \");\r\n        // require(block.timestamp < maturity + 3600,\"IT IS TOO LATE \");\r\n\r\n        Notional notionalContract = Notional(notional) ;\r\n\r\n         // uint16 currencyId,uint256 maturity,uint256 settlementDate\r\n        MarketParameters   memory market  = getMarketNoRevert(currencyId,threeMonthMaturity,threeMonthMaturity) ;\r\n\r\n        // if(market.oracleRate == 0){ //市场没有初始化 需要调用初始化\r\n        //     notionalContract.initializeMarkets(currencyId,false);\r\n        //     market  = notionalContract.getMarket(currencyId,threeMonthMaturity,threeMonthMaturity) ;\r\n        //     require(market.oracleRate > 0,\"market_oracleRate IS ZERO \");  \r\n        // }\r\n       \r\n\r\n        CashGroupSettings memory cashGroup;\r\n        AssetRateParameters memory assetRate ;\r\n          \r\n        (cashGroup,assetRate) = notionalContract.getCashGroupAndAssetRate(currencyId) ;\r\n        \r\n        AssetRateParameters memory settlementAssetRate = assetRate ; \r\n     \r\n        int256 lendAmount = 0 ;\r\n        uint256 tradeLength = 1 ;\r\n        for(uint256 i=0;i<accountList.length;i++){\r\n            // AccountContext memory accountContext = notionalContract.getAccountContext(accountList[i].account);\r\n            // if(accountContext.nextSettleTime != 1640736000){\r\n            //     // continue ; // 这个账号被别人结算过了  不用管了\r\n            // }\r\n            accountList[i].nextAssesCash =  settleAccount( accountList[i].fcash, accountList[i].cashAssestBalance,settlementAssetRate) ;\r\n            if ( accountList[i].nextAssesCash >= 0){\r\n                continue ;\r\n            }\r\n            accountList[i].nextFcash = calculatfcashByassestCash( accountList[i].nextAssesCash,market,assetRate);\r\n            lendAmount += accountList[i].nextFcash ;\r\n            tradeLength ++ ;\r\n            // trades[trades.length] = buildSettleCashDebt( accountList[i].account, int88(0)) ;  //组织setDebetTrade trades[0]给 borrow留着\r\n        }\r\n        lendAmount = lendAmount.abs() ;\r\n\r\n        require(tradeLength >= 2,\"NO ACCOUNT TO SETTLE \");\r\n        bytes32[] memory trades = new bytes32[](tradeLength);\r\n        tradeLength = 0 ;\r\n        trades[tradeLength] = buildBorrow(uint8(1), uint88(lendAmount), uint32(0)) ;\r\n\r\n        for(uint256 i=0;i<accountList.length;i++){\r\n            if ( accountList[i].nextAssesCash < 0){\r\n                tradeLength ++ ;\r\n                trades[tradeLength] = buildSettleCashDebt( accountList[i].account, int88(0));\r\n            }\r\n        }\r\n        \r\n        BalanceActionWithTrades[] memory actionList  = new  BalanceActionWithTrades[](1) ;\r\n       \r\n        // uint256 maxImpliedRate = 0 ; //0 为不限制\r\n\r\n        //组织 borrow 的 trade bytes32\r\n        BalanceActionWithTrades memory action = buildBalanceActionWithTrades(\r\n            DepositActionType.None,\r\n            currencyId, \r\n            0, \r\n            0, \r\n            false,\r\n            false,\r\n            trades\r\n        ) ;\r\n        actionList[0] = action ;\r\n        return actionList ;\r\n    }\r\n    */\r\n\r\n    //测试 返回用户清算列表\r\n    /*\r\n    function settleCurrencyTestA( uint16 currencyId,AccountList[] memory accountList)    external view returns(AccountList[] memory ) {\r\n        uint256 threeMonthMaturity = 1648512000 ; // 2022-03-29 00:00:00 \r\n\r\n        Notional notionalContract = Notional(notional) ;\r\n\r\n        MarketParameters   memory market  = getMarketNoRevert(currencyId,threeMonthMaturity,threeMonthMaturity) ;\r\n\r\n        CashGroupSettings memory cashGroup;\r\n        AssetRateParameters memory assetRate ;\r\n          \r\n        (cashGroup,assetRate) = notionalContract.getCashGroupAndAssetRate(currencyId) ;\r\n        \r\n        AssetRateParameters memory settlementAssetRate = assetRate ; \r\n     \r\n        int256 lendAmount = 0 ;\r\n        uint256 tradeLength = 1 ;\r\n        for(uint256 i=0;i<accountList.length;i++){\r\n            // AccountContext memory accountContext = notionalContract.getAccountContext(accountList[i].account);\r\n            // if(accountContext.nextSettleTime != 1640736000){\r\n            //     // continue ; // 这个账号被别人结算过了  不用管了\r\n            // }\r\n            accountList[i].nextAssesCash =  settleAccount( accountList[i].fcash, accountList[i].cashAssestBalance,settlementAssetRate) ;\r\n            if ( accountList[i].nextAssesCash >= 0){\r\n                continue ;\r\n            }\r\n            accountList[i].nextFcash = calculatfcashByassestCash( accountList[i].nextAssesCash,market,assetRate);\r\n            lendAmount += accountList[i].nextFcash ;\r\n            tradeLength ++ ;\r\n            // trades[trades.length] = buildSettleCashDebt( accountList[i].account, int88(0)) ;  //组织setDebetTrade trades[0]给 borrow留着\r\n        }\r\n        return accountList ;\r\n    }\r\n    */\r\n    function getThreeMatyrityOrSettlementDate(uint256 blockTime) public pure returns (uint256){\r\n        return  getReferenceTime(blockTime) + Constants.QUARTER;\r\n    }\r\n    \r\n    function getReferenceTime(uint256 blockTime) internal pure returns (uint256) {\r\n        require(blockTime >= Constants.QUARTER);\r\n        return blockTime - (blockTime % Constants.QUARTER);\r\n    }\r\n\r\n    function settleCurrency( uint16 currencyId,AccountList[] memory accountList,uint256 maturity)  isOwner external {\r\n        \r\n\r\n        require(block.timestamp >= maturity,\"NO NEED TO SETTLE \");\r\n        require(block.timestamp < maturity + 3600,\"IT IS TOO LATE \");\r\n        uint256 threeMonthMaturity = getThreeMatyrityOrSettlementDate(maturity) ; // 2022-03-29 00:00:00 \r\n        // uint256 settlementDate = threeMonthMaturity ; //\r\n\r\n        Notional notionalContract = Notional(notional) ;\r\n\r\n         // uint16 currencyId,uint256 maturity,uint256 settlementDate\r\n        MarketParameters   memory market  = getMarketNoRevert(currencyId,threeMonthMaturity,threeMonthMaturity) ;\r\n\r\n        if(market.oracleRate == 0){ //市场没有初始化 需要调用初始化\r\n            notionalContract.initializeMarkets(currencyId,false);\r\n            market  = notionalContract.getMarket(currencyId,threeMonthMaturity,threeMonthMaturity) ;\r\n            require(market.oracleRate > 0,\"market_oracleRate IS ZERO \");  \r\n        }\r\n       \r\n\r\n        CashGroupSettings memory cashGroup;\r\n        AssetRateParameters memory assetRate ;\r\n          \r\n        (cashGroup,assetRate) = notionalContract.getCashGroupAndAssetRate(currencyId) ;\r\n        //正式\r\n        AssetRateParameters memory settlementAssetRate = notionalContract.getSettlementRate(currencyId, uint40(maturity)) ; \r\n     \r\n        int256 lendAmount = 0 ;\r\n       \r\n        uint256 tradeLength = 1 ;\r\n        for(uint256 i=0;i<accountList.length;i++){\r\n            AccountContext memory accountContext = notionalContract.getAccountContext(accountList[i].account);\r\n            if(accountContext.nextSettleTime != maturity){\r\n                continue ; // 这个账号被别人结算过了  不用管了\r\n            }\r\n            accountList[i].nextAssesCash =  settleAccount( accountList[i].fcash, accountList[i].cashAssestBalance,settlementAssetRate) ;\r\n            if ( accountList[i].nextAssesCash >= 0){\r\n                continue ;\r\n            }\r\n            accountList[i].nextFcash = calculatfcashByassestCash( accountList[i].nextAssesCash,market,assetRate);\r\n            lendAmount += accountList[i].nextFcash ;\r\n            tradeLength ++ ;\r\n            // trades[trades.length] = buildSettleCashDebt( accountList[i].account, int88(0)) ;  //组织setDebetTrade trades[0]给 borrow留着\r\n        }\r\n        lendAmount = lendAmount.abs() ;\r\n        require(tradeLength >= 2,\"NO ACCOUNT TO SETTLE \");\r\n        bytes32[] memory trades = new bytes32[](tradeLength);\r\n        tradeLength = 0 ;\r\n        for(uint256 i=0;i<accountList.length;i++){\r\n            if ( accountList[i].nextAssesCash < 0){\r\n                trades[tradeLength] = buildSettleCashDebt( accountList[i].account, int88(0));\r\n                tradeLength ++ ;\r\n            }\r\n        }\r\n        trades[tradeLength] = buildBorrow(uint8(1), uint88(lendAmount), uint32(0)) ;\r\n        \r\n        BalanceActionWithTrades[] memory actionList  = new  BalanceActionWithTrades[](1) ;\r\n        \r\n\r\n        //组织 borrow 的 trade bytes32\r\n        BalanceActionWithTrades memory action = buildBalanceActionWithTrades(\r\n            DepositActionType.None,\r\n            currencyId, \r\n            0, \r\n            0, \r\n            false,\r\n            false,\r\n            trades\r\n        ) ;\r\n        actionList[0] = action ;\r\n        executeBatchBalanceAndTradeAction(actionList);\r\n    }\r\n\r\n    function settleAccount(int256 notional ,int256 cashBalanac, AssetRateParameters memory settlementAssetRate) public view returns (int256){\r\n        int256 fcash2assest  = convertFromUnderlying(notional, settlementAssetRate.rate,settlementAssetRate.underlyingDecimals);\r\n        return cashBalanac + fcash2assest ;\r\n    }\r\n\r\n    function buildBalanceActionWithTrades( \r\n        DepositActionType actionType,\r\n        uint16 currencyId,\r\n        uint256 depositActionAmount,\r\n        uint256 withdrawAmountInternalPrecision,\r\n        bool withdrawEntireCashBalance,\r\n        bool redeemToUnderlying,\r\n        bytes32[] memory trades\r\n    )\r\n    private pure returns (BalanceActionWithTrades memory)\r\n    {\r\n        return  BalanceActionWithTrades(\r\n            actionType,\r\n            currencyId,\r\n            depositActionAmount,\r\n            withdrawAmountInternalPrecision,\r\n            withdrawEntireCashBalance,\r\n            redeemToUnderlying,\r\n            trades   \r\n        );\r\n    }\r\n    function buildBorrow(uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate)private pure returns (bytes32 result){\r\n              /*\r\n        enum TradeActionType {\r\n        // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate, uint128 unused)\r\n         Borrow,\r\n        }\r\n        */ \r\n         bytes memory source  = abi.encodePacked(\r\n            uint8(TradeActionType.Borrow),\r\n            MarketIndex,\r\n            fCashAmount,\r\n            maxImpliedRate,\r\n            uint128(0)\r\n        ) ;\r\n        return  _bytesToBytes32(source) ;\r\n    }\r\n    function buildSettleCashDebt(address CounterpartyAddress, int88 fCashAmountToSettle)private pure returns (bytes32 result){\r\n        /*\r\n            enum TradeActionType {\r\n                // (uint8 TradeActionType, address CounterpartyAddress, int88 fCashAmountToSettle)\r\n                SettleCashDebt\r\n            }   \r\n        \r\n        */\r\n        bytes memory _source  = abi.encodePacked(\r\n            uint8(TradeActionType.SettleCashDebt),\r\n            CounterpartyAddress,\r\n            fCashAmountToSettle\r\n        );\r\n        return  _bytesToBytes32(_source) ;\r\n    }\r\n\r\n\r\n    function _bytesToBytes32(bytes memory source) private pure returns (bytes32 result) {\r\n        if (source.length == 0) {\r\n            return 0x0;\r\n        }\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n     }\r\n\r\n    function executeBatchBalanceAndTradeAction(BalanceActionWithTrades[] memory actions) isOwner  public  {\r\n        Notional notionalContract = Notional(notional) ;\r\n        notionalContract.batchBalanceAndTradeAction(address(this),actions);\r\n    }\r\n\r\n\r\n    /// @notice Returns a single market\r\n    function abiTest() external pure  returns (uint256,uint256,int256,uint256)\r\n    {   \r\n        \r\n         // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate, uint128 unused)\r\n       \r\n        bytes memory source  = abi.encodePacked(\r\n            uint8(5), //TradeActionType\r\n            uint8(1), //MarketIndex\r\n            uint88(382438474428624), //fCashAmount\r\n            uint32(250*1e6), //maxImpliedRate\r\n            uint128(3333) //uint128 unused\r\n        ) ;\r\n        bytes32  trade =  _bytesToBytes32(source) ;\r\n\r\n        uint256 tradeType = uint256(uint8(bytes1(trade)));\r\n        uint256 marketIndex = uint256(uint8(bytes1(trade << 8)));\r\n        int256 fCashAmount = int256(uint88(bytes11(trade << 16)));\r\n        uint256 rateLimit = uint256(uint32(bytes4(trade << 104)));\r\n        return (tradeType,marketIndex,fCashAmount,rateLimit);\r\n    }\r\n\r\n    function getMarketNoRevert(uint16 currencyId,uint256 maturity,uint256 settlementDate) public view   returns ( MarketParameters   memory market)\r\n    {   \r\n        \r\n         // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate, uint128 unused)\r\n        (bool ok,bytes memory returndata) =   address(notional).staticcall(abi.encodeWithSignature(\"getMarket(uint16,uint256,uint256)\",currencyId,maturity,settlementDate)) ;\r\n        MarketParameters   memory marke ;\r\n        if(ok){\r\n            ( market) =  abi.decode(returndata,(MarketParameters))  ;\r\n        }\r\n        return  market;\r\n       \r\n    }\r\n\r\n    function ERC20Transfer(address token,address to,uint256 amount) isOwner external {\r\n        ICERC20(token).transfer(to,amount);\r\n    }\r\n\r\n    function ERC20TransferFrom(address token,address to,uint256 amount) isOwner external {\r\n        ICERC20(token).transferFrom(address(this),to,amount);\r\n    }\r\n\r\n    function ETHTransfer() isOwner external {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n}"
    },
    "types.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\n\r\n\r\n\r\n/// @notice Different types of internal tokens\r\n///  - UnderlyingToken: underlying asset for a cToken (except for Ether)\r\n///  - cToken: Compound interest bearing token\r\n///  - cETH: Special handling for cETH tokens\r\n///  - Ether: the one and only\r\n///  - NonMintable: tokens that do not have an underlying (therefore not cTokens)\r\nenum TokenType {UnderlyingToken, cToken, cETH, Ether, NonMintable}\r\n\r\n/// @notice Specifies the different trade action types in the system. Each trade action type is\r\n/// encoded in a tightly packed bytes32 object. Trade action type is the first big endian byte of the\r\n/// 32 byte trade action object. The schemas for each trade action type are defined below.\r\nenum TradeActionType {\r\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 minImpliedRate, uint120 unused)\r\n    Lend,\r\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate, uint128 unused)\r\n    Borrow,\r\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 assetCashAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\r\n    AddLiquidity,\r\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 tokenAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\r\n    RemoveLiquidity,\r\n    // (uint8 TradeActionType, uint32 Maturity, int88 fCashResidualAmount, uint128 unused)\r\n    PurchaseNTokenResidual,\r\n    // (uint8 TradeActionType, address CounterpartyAddress, int88 fCashAmountToSettle)\r\n    SettleCashDebt\r\n}\r\n\r\n/// @notice Specifies different deposit actions that can occur during BalanceAction or BalanceActionWithTrades\r\nenum DepositActionType {\r\n    // No deposit action\r\n    None,\r\n    // Deposit asset cash, depositActionAmount is specified in asset cash external precision\r\n    DepositAsset,\r\n    // Deposit underlying tokens that are mintable to asset cash, depositActionAmount is specified in underlying token\r\n    // external precision\r\n    DepositUnderlying,\r\n    // Deposits specified asset cash external precision amount into an nToken and mints the corresponding amount of\r\n    // nTokens into the account\r\n    DepositAssetAndMintNToken,\r\n    // Deposits specified underlying in external precision, mints asset cash, and uses that asset cash to mint nTokens\r\n    DepositUnderlyingAndMintNToken,\r\n    // Redeems an nToken balance to asset cash. depositActionAmount is specified in nToken precision. Considered a deposit action\r\n    // because it deposits asset cash into an account. If there are fCash residuals that cannot be sold off, will revert.\r\n    RedeemNToken,\r\n    // Converts specified amount of asset cash balance already in Notional to nTokens. depositActionAmount is specified in\r\n    // Notional internal 8 decimal precision.\r\n    ConvertCashToNToken\r\n}\r\n\r\n/// @notice Used internally for PortfolioHandler state\r\nenum AssetStorageState {NoChange, Update, Delete, RevertIfStored}\r\n\r\n/****** Calldata objects ******/\r\n\r\n/// @notice Defines a balance action for batchAction\r\nstruct BalanceAction {\r\n    // Deposit action to take (if any)\r\n    DepositActionType actionType;\r\n    uint16 currencyId;\r\n    // Deposit action amount must correspond to the depositActionType, see documentation above.\r\n    uint256 depositActionAmount;\r\n    // Withdraw an amount of asset cash specified in Notional internal 8 decimal precision\r\n    uint256 withdrawAmountInternalPrecision;\r\n    // If set to true, will withdraw entire cash balance. Useful if there may be an unknown amount of asset cash\r\n    // residual left from trading.\r\n    bool withdrawEntireCashBalance;\r\n    // If set to true, will redeem asset cash to the underlying token on withdraw.\r\n    bool redeemToUnderlying;\r\n}\r\n\r\n\r\nstruct AccountList {\r\n    address account ;\r\n    int256 cashAssestBalance; // 账户余额 正数\r\n    int256 fcash; //  当前的欠款fcash  负数\r\n    int256 nextAssesCash; // 结算之后账余额  golang里传0 合约里算\r\n    int256 nextFcash; //  罚息后下季度的fcash  负数 golang里传0 合约里算\r\n}\r\n\r\n/// @notice Defines a balance action with a set of trades to do as well\r\nstruct BalanceActionWithTrades {\r\n    DepositActionType actionType;\r\n    uint16 currencyId;\r\n    uint256 depositActionAmount;\r\n    uint256 withdrawAmountInternalPrecision;\r\n    bool withdrawEntireCashBalance;\r\n    bool redeemToUnderlying;\r\n    // Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\r\n    bytes32[] trades;\r\n}\r\n\r\n/****** In memory objects ******/\r\n/// @notice Internal object that represents settled cash balances\r\nstruct SettleAmount {\r\n    uint256 currencyId;\r\n    int256 netCashChange;\r\n}\r\n\r\n/// @notice Internal object that represents a token\r\nstruct Token {\r\n    address tokenAddress;\r\n    bool hasTransferFee;\r\n    int256 decimals;\r\n    TokenType tokenType;\r\n    uint256 maxCollateralBalance;\r\n}\r\n\r\n/// @notice Internal object that represents an nToken portfolio\r\nstruct nTokenPortfolio {\r\n    CashGroupParameters cashGroup;\r\n    PortfolioState portfolioState;\r\n    int256 totalSupply;\r\n    int256 cashBalance;\r\n    uint256 lastInitializedTime;\r\n    bytes6 parameters;\r\n    address tokenAddress;\r\n}\r\n\r\n/// @notice Internal object used during liquidation\r\nstruct LiquidationFactors {\r\n    address account;\r\n    // Aggregate free collateral of the account denominated in ETH underlying, 8 decimal precision\r\n    int256 netETHValue;\r\n    // Amount of net local currency asset cash before haircuts and buffers available\r\n    int256 localAssetAvailable;\r\n    // Amount of net collateral currency asset cash before haircuts and buffers available\r\n    int256 collateralAssetAvailable;\r\n    // Haircut value of nToken holdings denominated in asset cash, will be local or collateral nTokens based\r\n    // on liquidation type\r\n    int256 nTokenHaircutAssetValue;\r\n    // nToken parameters for calculating liquidation amount\r\n    bytes6 nTokenParameters;\r\n    // ETH exchange rate from local currency to ETH\r\n    ETHRate localETHRate;\r\n    // ETH exchange rate from collateral currency to ETH\r\n    ETHRate collateralETHRate;\r\n    // Asset rate for the local currency, used in cross currency calculations to calculate local asset cash required\r\n    AssetRateParameters localAssetRate;\r\n    // Used during currency liquidations if the account has liquidity tokens\r\n    CashGroupParameters collateralCashGroup;\r\n    // Used during currency liquidations if it is only a calculation, defaults to false\r\n    bool isCalculation;\r\n}\r\n\r\n/// @notice Internal asset array portfolio state\r\nstruct PortfolioState {\r\n    // Array of currently stored assets\r\n    PortfolioAsset[] storedAssets;\r\n    // Array of new assets to add\r\n    PortfolioAsset[] newAssets;\r\n    uint256 lastNewAssetIndex;\r\n    // Holds the length of stored assets after accounting for deleted assets\r\n    uint256 storedAssetLength;\r\n}\r\n\r\n/// @notice In memory ETH exchange rate used during free collateral calculation.\r\nstruct ETHRate {\r\n    // The decimals (i.e. 10^rateDecimalPlaces) of the exchange rate, defined by the rate oracle\r\n    int256 rateDecimals;\r\n    // The exchange rate from base to ETH (if rate invert is required it is already done)\r\n    int256 rate;\r\n    // Amount of buffer as a multiple with a basis of 100 applied to negative balances.\r\n    int256 buffer;\r\n    // Amount of haircut as a multiple with a basis of 100 applied to positive balances\r\n    int256 haircut;\r\n    // Liquidation discount as a multiple with a basis of 100 applied to the exchange rate\r\n    // as an incentive given to liquidators.\r\n    int256 liquidationDiscount;\r\n}\r\n\r\n/// @notice Internal object used to handle balance state during a transaction\r\nstruct BalanceState {\r\n    uint16 currencyId;\r\n    // Cash balance stored in balance state at the beginning of the transaction\r\n    int256 storedCashBalance;\r\n    // nToken balance stored at the beginning of the transaction\r\n    int256 storedNTokenBalance;\r\n    // The net cash change as a result of asset settlement or trading\r\n    int256 netCashChange;\r\n    // Net asset transfers into or out of the account\r\n    int256 netAssetTransferInternalPrecision;\r\n    // Net token transfers into or out of the account\r\n    int256 netNTokenTransfer;\r\n    // Net token supply change from minting or redeeming\r\n    int256 netNTokenSupplyChange;\r\n    // The last time incentives were claimed for this currency\r\n    uint256 lastClaimTime;\r\n    // The last integral supply amount when tokens were claimed\r\n    uint256 lastClaimIntegralSupply;\r\n}\r\n\r\n/// @dev Asset rate used to convert between underlying cash and asset cash\r\nstruct AssetRateParameters {\r\n    // Address of the asset rate oracle\r\n    // AssetRateAdapter rateOracle;\r\n    // The exchange rate from base to quote (if invert is required it is already done)\r\n    int256 rate;\r\n    // The decimals of the underlying, the rate converts to the underlying decimals\r\n    int256 underlyingDecimals;\r\n}\r\n\r\n/// @dev Cash group when loaded into memory\r\nstruct CashGroupParameters {\r\n    uint16 currencyId;\r\n    uint256 maxMarketIndex;\r\n    AssetRateParameters assetRate;\r\n    bytes32 data;\r\n}\r\n\r\n/// @dev A portfolio asset when loaded in memory\r\nstruct PortfolioAsset {\r\n    // Asset currency id\r\n    uint256 currencyId;\r\n    uint256 maturity;\r\n    // Asset type, fCash or liquidity token.\r\n    uint256 assetType;\r\n    // fCash amount or liquidity token amount\r\n    int256 notional;\r\n    // Used for managing portfolio asset state\r\n    uint256 storageSlot;\r\n    // The state of the asset for when it is written to storage\r\n    AssetStorageState storageState;\r\n}\r\n\r\n\r\n\r\n/****** Storage objects ******/\r\n\r\n/// @dev Token object in storage:\r\n///  20 bytes for token address\r\n///  1 byte for hasTransferFee\r\n///  1 byte for tokenType\r\n///  1 byte for tokenDecimals\r\n///  9 bytes for maxCollateralBalance (may not always be set)\r\nstruct TokenStorage {\r\n    // Address of the token\r\n    address tokenAddress;\r\n    // Transfer fees will change token deposit behavior\r\n    bool hasTransferFee;\r\n    TokenType tokenType;\r\n    uint8 decimalPlaces;\r\n    // Upper limit on how much of this token the contract can hold at any time\r\n    uint72 maxCollateralBalance;\r\n}\r\n\r\n/// @dev Exchange rate object as it is represented in storage, total storage is 25 bytes.\r\nstruct ETHRateStorage {\r\n    // Address of the rate oracle\r\n    // AggregatorV2V3Interface rateOracle;\r\n    // The decimal places of precision that the rate oracle uses\r\n    uint8 rateDecimalPlaces;\r\n    // True of the exchange rate must be inverted\r\n    bool mustInvert;\r\n    // NOTE: both of these governance values are set with BUFFER_DECIMALS precision\r\n    // Amount of buffer to apply to the exchange rate for negative balances.\r\n    uint8 buffer;\r\n    // Amount of haircut to apply to the exchange rate for positive balances\r\n    uint8 haircut;\r\n    // Liquidation discount in percentage point terms, 106 means a 6% discount\r\n    uint8 liquidationDiscount;\r\n}\r\n\r\n/// @dev Asset rate oracle object as it is represented in storage, total storage is 21 bytes.\r\nstruct AssetRateStorage {\r\n    // Address of the rate oracle\r\n    // AssetRateAdapter rateOracle;\r\n    // The decimal places of the underlying asset\r\n    uint8 underlyingDecimalPlaces;\r\n}\r\n\r\n/// @dev Governance parameters for a cash group, total storage is 9 bytes + 7 bytes for liquidity token haircuts\r\n/// and 7 bytes for rate scalars, total of 23 bytes. Note that this is stored packed in the storage slot so there\r\n/// are no indexes stored for liquidityTokenHaircuts or rateScalars, maxMarketIndex is used instead to determine the\r\n/// length.\r\nstruct CashGroupSettings {\r\n    // Index of the AMMs on chain that will be made available. Idiosyncratic fCash\r\n    // that is dated less than the longest AMM will be tradable.\r\n    uint8 maxMarketIndex;\r\n    // Time window in 5 minute increments that the rate oracle will be averaged over\r\n    uint8 rateOracleTimeWindow5Min;\r\n    // Total fees per trade, specified in BPS\r\n    uint8 totalFeeBPS;\r\n    // Share of the fees given to the protocol, denominated in percentage\r\n    uint8 reserveFeeShare;\r\n    // Debt buffer specified in 5 BPS increments\r\n    uint8 debtBuffer5BPS;\r\n    // fCash haircut specified in 5 BPS increments\r\n    uint8 fCashHaircut5BPS;\r\n    // If an account has a negative cash balance, it can be settled by incurring debt at the 3 month market. This\r\n    // is the basis points for the penalty rate that will be added the current 3 month oracle rate.\r\n    uint8 settlementPenaltyRate5BPS;\r\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\r\n    uint8 liquidationfCashHaircut5BPS;\r\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\r\n    uint8 liquidationDebtBuffer5BPS;\r\n    // Liquidity token haircut applied to cash claims, specified as a percentage between 0 and 100\r\n    uint8[] liquidityTokenHaircuts;\r\n    // Rate scalar used to determine the slippage of the market\r\n    uint8[] rateScalars;\r\n}\r\n\r\n/// @dev Holds account level context information used to determine settlement and\r\n/// free collateral actions. Total storage is 28 bytes\r\nstruct AccountContext {\r\n    // Used to check when settlement must be triggered on an account\r\n    uint40 nextSettleTime;\r\n    // For lenders that never incur debt, we use this flag to skip the free collateral check.\r\n    bytes1 hasDebt;\r\n    // Length of the account's asset array\r\n    uint8 assetArrayLength;\r\n    // If this account has bitmaps set, this is the corresponding currency id\r\n    uint16 bitmapCurrencyId;\r\n    // 9 total active currencies possible (2 bytes each)\r\n    bytes18 activeCurrencies;\r\n}\r\n\r\n/// @dev Holds nToken context information mapped via the nToken address, total storage is\r\n/// 16 bytes\r\nstruct nTokenContext {\r\n    // Currency id that the nToken represents\r\n    uint16 currencyId;\r\n    // Annual incentive emission rate denominated in WHOLE TOKENS (multiply by \r\n    // INTERNAL_TOKEN_PRECISION to get the actual rate)\r\n    uint32 incentiveAnnualEmissionRate;\r\n    // The last block time at utc0 that the nToken was initialized at, zero if it\r\n    // has never been initialized\r\n    uint32 lastInitializedTime;\r\n    // Length of the asset array, refers to the number of liquidity tokens an nToken\r\n    // currently holds\r\n    uint8 assetArrayLength;\r\n    // Each byte is a specific nToken parameter\r\n    bytes5 nTokenParameters;\r\n}\r\n\r\n/// @dev Holds account balance information, total storage 32 bytes\r\nstruct BalanceStorage {\r\n    // Number of nTokens held by the account\r\n    uint80 nTokenBalance;\r\n    // Last time the account claimed their nTokens\r\n    uint32 lastClaimTime;\r\n    // The total integral supply of the nToken at the last claim time packed into\r\n    // 56 bits. There is some loss of precision here but it is acceptable\r\n    uint56 packedLastClaimIntegralSupply;\r\n    // Cash balance of the account\r\n    int88 cashBalance;\r\n}\r\n\r\n/// @dev Holds information about a settlement rate, total storage 25 bytes\r\nstruct SettlementRateStorage {\r\n    uint40 blockTime;\r\n    uint128 settlementRate;\r\n    uint8 underlyingDecimalPlaces;\r\n}\r\n\r\n/// @dev Holds information about a market, total storage is 42 bytes so this spans\r\n/// two storage words\r\nstruct MarketStorage {\r\n    // Total fCash in the market\r\n    uint80 totalfCash;\r\n    // Total asset cash in the market\r\n    uint80 totalAssetCash;\r\n    // Last annualized interest rate the market traded at\r\n    uint32 lastImpliedRate;\r\n    // Last recorded oracle rate for the market\r\n    uint32 oracleRate;\r\n    // Last time a trade was made\r\n    uint32 previousTradeTime;\r\n    // This is stored in slot + 1\r\n    uint80 totalLiquidity;\r\n}\r\n\r\n\r\n/// @dev Market object as represented in memory\r\nstruct MarketParameters {\r\n    bytes32 storageSlot;\r\n    uint256 maturity;\r\n    // Total amount of fCash available for purchase in the market.\r\n    int256 totalfCash;\r\n    // Total amount of cash available for purchase in the market.\r\n    int256 totalAssetCash;\r\n    // Total amount of liquidity tokens (representing a claim on liquidity) in the market.\r\n    int256 totalLiquidity;\r\n    // This is the previous annualized interest rate in RATE_PRECISION that the market traded\r\n    // at. This is used to calculate the rate anchor to smooth interest rates over time.\r\n    uint256 lastImpliedRate;\r\n    // Time lagged version of lastImpliedRate, used to value fCash assets at market rates while\r\n    // remaining resistent to flash loan attacks.\r\n    uint256 oracleRate;\r\n    // This is the timestamp of the previous trade\r\n    uint256 previousTradeTime;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nstruct ifCashStorage {\r\n    // Notional amount of fCash at the slot, limited to int128 to allow for\r\n    // future expansion\r\n    int128 notional;\r\n}\r\n\r\n/// @dev A single portfolio asset in storage, total storage of 19 bytes\r\nstruct PortfolioAssetStorage {\r\n    // Currency Id for the asset\r\n    uint16 currencyId;\r\n    // Maturity of the asset\r\n    uint40 maturity;\r\n    // Asset type (fCash or Liquidity Token marker)\r\n    uint8 assetType;\r\n    // Notional\r\n    int88 notional;\r\n}\r\n\r\n/// @dev nToken total supply factors for the nToken, includes factors related\r\n/// to claiming incentives, total storage 32 bytes\r\nstruct nTokenTotalSupplyStorage {\r\n    // Total supply of the nToken\r\n    uint96 totalSupply;\r\n    // Integral of the total supply used for calculating the average total supply\r\n    uint128 integralTotalSupply;\r\n    // Last timestamp the supply value changed, used for calculating the integralTotalSupply\r\n    uint32 lastSupplyChangeTime;\r\n}\r\n\r\n/// @dev Used in view methods to return account balances in a developer friendly manner\r\nstruct AccountBalance {\r\n    uint16 currencyId;\r\n    int256 cashBalance;\r\n    int256 nTokenBalance;\r\n    uint256 lastClaimTime;\r\n    uint256 lastClaimIntegralSupply;\r\n}\r\n\r\n\r\n\r\n\r\n"
    }
  }
}