{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Simulator.sol": {
      "content": "pragma solidity 0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface SimulatorInterface {\r\n  // ABIEncoderV2 uses an array of Calls for executing generic batch calls.\r\n  struct Call {\r\n    address to;\r\n    uint96 value;\r\n    bytes data;\r\n  }\r\n\r\n  struct ValueReplacement {\r\n      uint16 callIndex;\r\n      uint24 returnDataOffset;\r\n      bool perform;\r\n  }\r\n\r\n  struct DataReplacement {\r\n      uint16 callIndex;\r\n      uint24 returnDataOffset;\r\n      uint24 callDataOffset;\r\n  }\r\n\r\n  struct AdvancedCall {\r\n    address to;\r\n    uint96 value;\r\n    bytes data;\r\n    ValueReplacement replaceValue;\r\n    DataReplacement[] replaceData;\r\n  }\r\n\r\n  // ABIEncoderV2 uses an array of CallReturns for handling generic batch calls.\r\n  struct CallReturn {\r\n    bool ok;\r\n    bytes returnData;\r\n  }\r\n\r\n  struct AdvancedCallReturn {\r\n    bool ok;\r\n    bytes returnData;\r\n    uint96 callValue;\r\n    bytes callData;\r\n  }\r\n\r\n  function simulateActionWithAtomicBatchCalls(\r\n    Call[] calldata calls\r\n  ) external /* view */ returns (bool[] memory ok, bytes[] memory returnData);\r\n\r\n  function simulateAdvancedActionWithAtomicBatchCalls(\r\n    AdvancedCall[] calldata calls\r\n  ) external /* view */ returns (bool[] memory ok, bytes[] memory returnData);\r\n}\r\n\r\n\r\nlibrary Address {\r\n  function isContract(address account) internal view returns (bool) {\r\n    uint256 size;\r\n    assembly { size := extcodesize(account) }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n\r\ncontract Simulator is SimulatorInterface {\r\n  using Address for address;\r\n\r\n  bytes4 private _selfCallContext;\r\n\r\n  address private _owner;\r\n\r\n  constructor() public {\r\n    _owner = tx.origin;\r\n  }\r\n\r\n  function updateOwner(address owner) external {\r\n    require(msg.sender == _owner, \"Only owner may call this function.\");\r\n    _owner = owner;\r\n  }\r\n\r\n  function callAny(\r\n    Call memory targetCall\r\n  ) public returns (bool ok, bytes memory returnData) {\r\n      require(msg.sender == _owner, \"Only owner may call this function.\");\r\n      (ok, returnData) = targetCall.to.call.value(\r\n        uint256(targetCall.value)\r\n      )(targetCall.data);\r\n  }\r\n\r\n  function simulateActionWithAtomicBatchCalls(\r\n    Call[] memory calls\r\n  ) public /* view */ returns (bool[] memory ok, bytes[] memory returnData) {\r\n    // Ensure that each `to` address is a contract and is not this contract.\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      if (calls[i].value == 0) {\r\n        _ensureValidGenericCallTarget(calls[i].to);\r\n      }\r\n    }\r\n\r\n    // Specify length of returned values in order to work with them in memory.\r\n    ok = new bool[](calls.length);\r\n    returnData = new bytes[](calls.length);\r\n\r\n    // Set self-call context to call _simulateActionWithAtomicBatchCallsAtomic.\r\n    _selfCallContext = this.simulateActionWithAtomicBatchCalls.selector;\r\n\r\n    // Make the atomic self-call - if any call fails, calls that preceded it\r\n    // will be rolled back and calls that follow it will not be made.\r\n    (bool mustBeFalse, bytes memory rawCallResults) = address(this).call(\r\n      abi.encodeWithSelector(\r\n        this._simulateActionWithAtomicBatchCallsAtomic.selector, calls\r\n      )\r\n    );\r\n\r\n    // Note: this should never be the case, but check just to be extra safe.\r\n    if (mustBeFalse) {\r\n      revert(\"Simulation code must revert!\");\r\n    }\r\n\r\n    // Parse data returned from self-call into each call result and store / log.\r\n    CallReturn[] memory callResults = abi.decode(rawCallResults, (CallReturn[]));\r\n    for (uint256 i = 0; i < callResults.length; i++) {\r\n      // Set the status and the return data / revert reason from the call.\r\n      ok[i] = callResults[i].ok;\r\n      returnData[i] = callResults[i].returnData;\r\n\r\n      if (!callResults[i].ok) {\r\n        // exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function _simulateActionWithAtomicBatchCallsAtomic(\r\n    Call[] memory calls\r\n  ) public returns (CallReturn[] memory callResults) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.simulateActionWithAtomicBatchCalls.selector);\r\n\r\n    callResults = new CallReturn[](calls.length);\r\n\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      // Perform low-level call and set return values using result.\r\n      (bool ok, bytes memory returnData) = calls[i].to.call.value(\r\n        uint256(calls[i].value)\r\n      )(calls[i].data);\r\n      callResults[i] = CallReturn({ok: ok, returnData: returnData});\r\n      if (!ok) {\r\n        // Exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Wrap in length encoding and revert (provide bytes instead of a string).\r\n    bytes memory callResultsBytes = abi.encode(callResults);\r\n    assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\r\n  }\r\n\r\n  function simulateAdvancedActionWithAtomicBatchCalls(\r\n    AdvancedCall[] memory calls\r\n  ) public /* view */ returns (bool[] memory ok, bytes[] memory returnData) {\r\n    // Ensure that each `to` address is a contract and is not this contract.\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      if (calls[i].value == 0) {\r\n        _ensureValidGenericCallTarget(calls[i].to);\r\n      }\r\n    }\r\n\r\n    // Specify length of returned values in order to work with them in memory.\r\n    ok = new bool[](calls.length);\r\n    returnData = new bytes[](calls.length);\r\n\r\n    // Set self-call context to call _simulateActionWithAtomicBatchCallsAtomic.\r\n    _selfCallContext = this.simulateAdvancedActionWithAtomicBatchCalls.selector;\r\n\r\n    // Make the atomic self-call - if any call fails, calls that preceded it\r\n    // will be rolled back and calls that follow it will not be made.\r\n    (bool mustBeFalse, bytes memory rawCallResults) = address(this).call(\r\n      abi.encodeWithSelector(\r\n        this._simulateAdvancedActionWithAtomicBatchCallsAtomic.selector, calls\r\n      )\r\n    );\r\n\r\n    // Note: this should never be the case, but check just to be extra safe.\r\n    if (mustBeFalse) {\r\n      revert(\"Simulation code must revert!\");\r\n    }\r\n\r\n    // Parse data returned from self-call into each call result and store / log.\r\n    CallReturn[] memory callResults = abi.decode(rawCallResults, (CallReturn[]));\r\n    for (uint256 i = 0; i < callResults.length; i++) {\r\n      // Set the status and the return data / revert reason from the call.\r\n      ok[i] = callResults[i].ok;\r\n      returnData[i] = callResults[i].returnData;\r\n\r\n      if (!callResults[i].ok) {\r\n        // exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function _simulateAdvancedActionWithAtomicBatchCallsAtomic(\r\n    AdvancedCall[] memory calls\r\n  ) public returns (CallReturn[] memory callResults) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.simulateAdvancedActionWithAtomicBatchCalls.selector);\r\n\r\n    callResults = new CallReturn[](calls.length);\r\n\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      AdvancedCall memory a = calls[i];\r\n      uint256 callValue = uint256(a.value);\r\n      bytes memory callData = a.data;\r\n\r\n      // Note: this check could (should?) be performed prior to execution.\r\n      if (a.replaceValue.perform) {\r\n        if (i <= a.replaceValue.callIndex) {\r\n          revert(\"Cannot replace value using call that has not yet been performed.\");\r\n        }\r\n\r\n        uint256 returnOffset = a.replaceValue.returnDataOffset;\r\n        bytes memory resultsAtIndex = callResults[a.replaceValue.callIndex].returnData;\r\n\r\n        if (resultsAtIndex.length < returnOffset + 32) {\r\n          revert(\"Return values are too short to give back a value at supplied index.\");\r\n        }\r\n\r\n        // TODO: this can be made much more efficient via assembly\r\n        bytes memory valueData = new bytes(32);\r\n        for (uint256 k = 0; k < 32; k++) {\r\n            valueData[k] = resultsAtIndex[returnOffset + k];\r\n        }\r\n        callValue = abi.decode(valueData, (uint256));\r\n      }\r\n\r\n      for (uint256 j = 0; j < a.replaceData.length; j++) {\r\n        if (i <= a.replaceData[j].callIndex) {\r\n          revert(\"Cannot replace data using call that has not yet been performed.\");\r\n        }\r\n\r\n        uint256 callOffset = a.replaceData[j].callDataOffset;\r\n        uint256 returnOffset = a.replaceData[j].returnDataOffset;\r\n        bytes memory resultsAtIndex = callResults[a.replaceData[j].callIndex].returnData;\r\n\r\n        if (resultsAtIndex.length < returnOffset + 32) {\r\n          revert(\"Return values are too short to give back a value at supplied index.\");\r\n        }\r\n\r\n        for (uint256 k = 0; k < 32; k++) {\r\n            callData[callOffset + k] = resultsAtIndex[returnOffset + k];\r\n        }\r\n      }\r\n\r\n      // Perform low-level call and set return values using result.\r\n      (bool ok, bytes memory returnData) = a.to.call.value(callValue)(callData);\r\n      callResults[i] = CallReturn({ok: ok, returnData: returnData});\r\n      if (!ok) {\r\n        // Exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Wrap in length encoding and revert (provide bytes instead of a string).\r\n    bytes memory callResultsBytes = abi.encode(callResults);\r\n    assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\r\n  }\r\n\r\n  function _enforceSelfCallFrom(bytes4 selfCallContext) internal {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    if (msg.sender != address(this) || _selfCallContext != selfCallContext) {\r\n      revert(\"External accounts or unapproved internal functions cannot call this.\");\r\n    }\r\n\r\n    // Clear the self-call context.\r\n    delete _selfCallContext;\r\n  }\r\n\r\n  function _ensureValidGenericCallTarget(address to) internal view {\r\n    if (!to.isContract()) {\r\n      revert(\"Cannot call accounts with no code with no value.\");\r\n    }\r\n\r\n    if (to == address(this)) {\r\n      revert(\"Cannot call this contract.\");\r\n    }\r\n  }\r\n}"
    }
  }
}