{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MoondayPlusDAO.sol": {
      "content": "pragma solidity ^0.6.2;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// \r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    \r\n    \r\n    \r\n    \r\n    function calculateBurnFee(uint256 _amount) external view returns (uint256);\r\n    \r\n    \r\n    function mint(address account, uint256 amount) external;\r\n    \r\n    \r\n    function burn(address account, uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\ninterface Uniswapv2Pair {\r\n\r\n     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n \r\n\r\n}\r\n\r\n\r\n/**\r\n * @title MoonDayPlus DAO\r\n * @dev Made by SoliditySam and Grass, fuck bad mouths saying I didnt made OG tendies\r\n *\r\n * \r\n          ,\r\n       _/ \\_     *\r\n      <     >\r\n*      /.'.\\                    *\r\n             *    ,-----.,_           ,\r\n               .'`         '.       _/ \\_\r\n    ,         /              `\\    <     >\r\n  _/ \\_      |  ,.---.         \\    /.'.\\\r\n <     >     \\.'    _,'.---.    ;   `   `\r\n  /.'.\\           .'  (-(0)-)   ;\r\n  `   `          /     '---'    |  *\r\n                /    )          |             *\r\n     *         |  .-;           ;        ,\r\n               \\_/ |___,'      ;       _/ \\_ \r\n          ,  |`---.MOON|_       /     <     >\r\n *      _/ \\_ \\         `     /        /.'.\\\r\n       <     > '.          _,'         `   `\r\n MD+    /.'.\\    `'------'`     *   \r\n        `   `\r\n \r\n \r\n */\r\n\r\n// The DAO contract itself\r\ncontract MoondayPlusDAO {\r\n    \r\n        using SafeMath for uint256;\r\n\r\n    // The minimum debate period that a generic proposal can have\r\n       uint256 public minProposalDebatePeriod = 2 weeks;\r\n      \r\n       \r\n       // Period after which a proposal is closed\r\n       // (used in the case `executeProposal` fails because it throws)\r\n       uint256 public executeProposalPeriod = 10 days;\r\n       \r\n       \r\n       \r\n     \r\n\r\n\r\n       IERC20 public MoondayToken;\r\n\r\n       Uniswapv2Pair public MoondayTokenPair;\r\n\r\n\r\n       // Proposals to spend the DAO's ether\r\n       Proposal[] public proposals;\r\n      \r\n       // The unix time of the last time quorum was reached on a proposal\r\n       uint public lastTimeMinQuorumMet;\r\n\r\n      \r\n       // Map of addresses and proposal voted on by this address\r\n       mapping (address => uint[]) public votingRegister;\r\n\r\n\r\n\r\n        uint256 public V = 2 ether;\r\n        //median fixed\r\n        \r\n        uint256 public W = 40;\r\n        //40% of holders approx\r\n        \r\n        uint256 public B = 5;\r\n        //0.005% vote\r\n        \r\n        uint256 public C = 10;\r\n        //10* 0.005% vote\r\n     \r\n\r\n  \r\n       struct Proposal {\r\n           // The address where the `amount` will go to if the proposal is accepted\r\n           address recipient;\r\n           // A plain text description of the proposal\r\n           string description;\r\n           // A unix timestamp, denoting the end of the voting period\r\n           uint votingDeadline;\r\n           // True if the proposal's votes have yet to be counted, otherwise False\r\n           bool open;\r\n           // True if quorum has been reached, the votes have been counted, and\r\n           // the majority said yes\r\n           bool proposalPassed;\r\n           // A hash to check validity of a proposal\r\n           bytes32 proposalHash;\r\n           // Number of Tokens in favor of the proposal\r\n           uint yea;\r\n           // Number of Tokens opposed to the proposal\r\n           uint nay;\r\n           // Simple mapping to check if a shareholder has voted for it\r\n           mapping (address => bool) votedYes;\r\n           // Simple mapping to check if a shareholder has voted against it\r\n           mapping (address => bool) votedNo;\r\n           // Address of the shareholder who created the proposal\r\n           address creator;\r\n       }\r\n\r\n\r\n\r\n       event ProposalAdded(\r\n            uint indexed proposalID,\r\n            address recipient,\r\n            string description\r\n           );\r\n        event Voted(uint indexed proposalID, bool position, address indexed voter);\r\n        event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\r\n       \r\n\r\n    // Modifier that allows only shareholders to vote and create new proposals\r\n    modifier onlyTokenholders {\r\n        if (MoondayToken.balanceOf(msg.sender) == 0) revert();\r\n            _;\r\n    }\r\n\r\n    constructor  (\r\n        \r\n        IERC20 _moontoken,\r\n        Uniswapv2Pair _MoondayTokenPair\r\n    ) public  {\r\n\r\n        MoondayToken = _moontoken;\r\n\r\n        MoondayTokenPair = _MoondayTokenPair;\r\n\r\n       \r\n        lastTimeMinQuorumMet = block.timestamp;\r\n        \r\n        proposals.push(); // avoids a proposal with ID 0 because it is used\r\n\r\n        \r\n    }\r\n\r\n\r\n    receive() payable external {\r\n       //we should get ether there but I doubt\r\n       revert();\r\n    }\r\n\r\n    function newProposal(\r\n        address _recipient,\r\n        string calldata _description,\r\n        bytes calldata _transactionData,\r\n        uint64 _debatingPeriod\r\n    ) onlyTokenholders payable external returns (uint _proposalID) {\r\n\r\n        if (_debatingPeriod < minProposalDebatePeriod\r\n            || _debatingPeriod > 8 weeks\r\n            || msg.sender == address(this) //to prevent a 51% attacker to convert the ether into deposit\r\n            )\r\n                revert(\"error in debating periods\");\r\n\r\n        uint256 received = determineAm().mul(C);\r\n\r\n\t\t\r\n\t    \r\n\t    MoondayToken.burn(msg.sender, received);\r\n\t    \r\n      \r\n       \r\n        \r\n       \r\n        Proposal memory p;\r\n        p.recipient = _recipient;\r\n        p.description = _description;\r\n        p.proposalHash = keccak256(abi.encodePacked(_recipient, _transactionData));\r\n        p.votingDeadline = block.timestamp.add( _debatingPeriod );\r\n        p.open = true;\r\n        //p.proposalPassed = False; // that's default\r\n        p.creator = msg.sender;\r\n        proposals.push(p);\r\n        _proposalID = proposals.length;\r\n       \r\n\r\n        emit ProposalAdded(\r\n            _proposalID,\r\n            _recipient,\r\n            _description\r\n        );\r\n    }\r\n\r\n    function checkProposalCode(\r\n        uint _proposalID,\r\n        address _recipient,\r\n        bytes calldata _transactionData\r\n    ) view external returns (bool _codeChecksOut) {\r\n        Proposal memory p = proposals[_proposalID];\r\n        return p.proposalHash == keccak256(abi.encodePacked(_recipient, _transactionData));\r\n    }\r\n\r\n    function vote(uint _proposalID, bool _supportsProposal) external {\r\n        \r\n        \r\n        //burn md+\r\n        \r\n        uint256 received = determineAm();\r\n\r\n\t\t\r\n\t    \r\n\t    MoondayToken.burn(msg.sender, received);\r\n\t    \r\n\t    \r\n\r\n        Proposal storage p = proposals[_proposalID];\r\n\r\n        if (block.timestamp >= p.votingDeadline) {\r\n            revert();\r\n        }\r\n\r\n        if (p.votedYes[msg.sender]) {\r\n            revert();\r\n        }\r\n\r\n        if (p.votedNo[msg.sender]) {\r\n            revert();\r\n        }\r\n        \r\n\r\n        if (_supportsProposal) {\r\n            p.yea += 1;\r\n            p.votedYes[msg.sender] = true;\r\n        } else {\r\n            p.nay += 1;\r\n            p.votedNo[msg.sender] = true;\r\n        }\r\n\r\n        votingRegister[msg.sender].push(_proposalID);\r\n        emit Voted(_proposalID, _supportsProposal, msg.sender);\r\n    }\r\n\r\n\r\n\r\n\r\n    function executeProposal(\r\n        uint _proposalID,\r\n        bytes calldata _transactionData\r\n    )  external payable  returns (bool _success) {\r\n\r\n        Proposal storage p = proposals[_proposalID];\r\n\r\n        // If we are over deadline and waiting period, assert proposal is closed\r\n        if (p.open && block.timestamp > p.votingDeadline.add(executeProposalPeriod)) {\r\n            p.open = false;\r\n            return false;\r\n        }\r\n\r\n        // Check if the proposal can be executed\r\n        if (block.timestamp < p.votingDeadline  // has the voting deadline arrived?\r\n            // Have the votes been counted?\r\n            || !p.open\r\n            || p.proposalPassed // anyone trying to call us recursively?\r\n            // Does the transaction code match the proposal?\r\n            || p.proposalHash != keccak256(abi.encodePacked(p.recipient, _transactionData))\r\n            )\r\n                revert();\r\n\r\n        \r\n        \r\n         // If we are over deadline and waiting period, assert proposal is closed\r\n        if (p.open && now > p.votingDeadline.add(executeProposalPeriod)) {\r\n            p.open = false;\r\n            return false;\r\n        }\r\n        \r\n        \r\n       \r\n        uint quorum = p.yea;\r\n\r\n\r\n\r\n\r\n        // Execute result\r\n        if (quorum >= minQuorum() && p.yea > p.nay) {\r\n            // we are setting this here before the CALL() value transfer to\r\n            // assure that in the case of a malicious recipient contract trying\r\n            // to call executeProposal() recursively money can't be transferred\r\n            // multiple times out of the DAO\r\n            \r\n            \r\n            lastTimeMinQuorumMet = block.timestamp;\r\n            \r\n            \r\n            p.proposalPassed = true;\r\n\r\n            // this call is as generic as any transaction. It sends all gas and\r\n            // can do everything a transaction can do. It can be used to reenter\r\n            // the DAO. The `p.proposalPassed` variable prevents the call from \r\n            // reaching this line again\r\n            (bool success, ) = p.recipient.call.value(msg.value)(_transactionData);\r\n            require(success,\"big fuckup\");\r\n\r\n            \r\n        }\r\n\r\n        p.open = false;\r\n\r\n        // Initiate event\r\n        emit ProposalTallied(_proposalID, _success, quorum);\r\n        return true;\r\n    }\r\n\r\n\r\n \r\n   \r\n    //admin like dao functions change median ETH :(\r\n     function changeMedianV(uint256 _V) external {\r\n        \r\n        require(msg.sender == address(this));\r\n         \r\n        V = _V;\r\n     }\r\n     \r\n    //admin like dao functions change % of holders\r\n     function changeHoldersW(uint256 _W) external {\r\n        \r\n        require(msg.sender == address(this));\r\n         \r\n        W = _W;\r\n     }\r\n\r\n\r\n    //admin like dao functions change % burn vote\r\n     function changeVoteB(uint256 _B) external {\r\n        \r\n        require(msg.sender == address(this));\r\n         \r\n        B = _B;\r\n     }\r\n     \r\n     //admin like dao functions change % burn vote multiplier for proposal\r\n     function changeVoteC(uint256 _C) external {\r\n        \r\n        require(msg.sender == address(this));\r\n         \r\n        C = _C;\r\n     }\r\n\r\n\r\n\r\n     //admin like dao functions change minProposalDebatePeriod\r\n     function changeMinProposalDebatePeriod(uint256 _minProposalDebatePeriod) external {\r\n        \r\n        require(msg.sender == address(this));\r\n         \r\n        minProposalDebatePeriod = _minProposalDebatePeriod;\r\n     }\r\n\r\n\r\n    //admin like dao functions change executeProposalPeriod\r\n     function changeexecuteProposalPeriod(uint256 _executeProposalPeriod) external {\r\n        \r\n        require(msg.sender == address(this));\r\n         \r\n        executeProposalPeriod = _executeProposalPeriod;\r\n     }\r\n     \r\n     \r\n\r\n\r\n\r\n \r\n\r\n    function minQuorum() public view returns (uint _minQuorum) {\r\n        (uint256 reserve0,uint256 reserve1,) = MoondayTokenPair.getReserves();\r\n   \r\n        uint256 R = ((MoondayToken.totalSupply().div( (V.mul((reserve1.div(reserve0)))))).mul(W)).div(100);\r\n        \r\n        return R;\r\n    }\r\n    \r\n    \r\n     function determineAm() public view returns (uint _amount) {\r\n        uint256 burn = (MoondayToken.totalSupply().mul(B)).div(100000);\r\n        \r\n        return burn;\r\n    }\r\n\r\n\r\n \r\n\r\n    function numberOfProposals() view external returns (uint _numberOfProposals) {\r\n        // Don't count index 0. It's used by getOrModifyBlocked() and exists from start\r\n        return proposals.length - 1;\r\n    }\r\n\r\n  \r\n}"
    }
  }
}