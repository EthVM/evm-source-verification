{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "DigitalMarketProxy.sol": {
      "content": "pragma solidity ^0.5.11;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface Token {\r\n    function totalSupply() external returns (uint256 supply);\r\n    function balanceOf(address owner) external returns (uint balance);\r\n    function balanceOfUsers(address token, address user) external returns (uint balance);\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external returns (uint256 remaining);\r\n    function receiveApproval(address _spender, uint256 _amount, address _reciver) external returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _amount) external  returns (bool success);\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function safeAdd(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, \"Safe Math Error-Add!\");\r\n    }\r\n    function safeSub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a, \"Safe Math Error-Sub!\");\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"Safe Math Error-Mul!\");\r\n    }\r\n    function safeDiv(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0, \"Safe Math Error-Div!\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract Ownabling { \r\n    address public owner;\r\n    address public newOwner;\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Only Admin can call this\");\r\n        _;\r\n    }\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"Sender isn't the new Owner\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ninterface TradeTrackerInterface { \r\n    function tradeComplete(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, address _get, address _give, uint _takerFee, uint _makerRebate) external;\r\n}\r\n\r\ncontract DigitalMarketStorage is Ownabling{\r\n    //------------------------------------------------------------------------\r\n    // 0. Logic Contracts \r\n    //------------------------------------------------------------------------\r\n    uint public funcN;\r\n    mapping(bytes4 => address) public funDelegates;\r\n    \r\n    //------------------------------------------------------------------------\r\n    // 1. Dex interface \r\n    //------------------------------------------------------------------------\r\n    address public accountModifiers; \r\n\taddress public tradeTracker;\r\n\tuint public fee = 1; \r\n\tuint public feeRate = 5; // Net Fees percentage is [0.2%] 1/5\r\n\t\r\n\tmapping (address => bool)\tpublic blacklist;\r\n\tmapping (address => mapping (address => uint))\tpublic tokens; \r\n\t\r\n\tmapping(address=>uint) public platformVolume;\r\n\tmapping(address=>uint) public platformFees;\r\n\tmapping(address=>uint) public distributedFees;\r\n\t\r\n\tmapping(address=>mapping(address=>uint)) public tradersVolume;\r\n\tmapping(address=>mapping(address=>uint)) public tradersDistributed;\r\n\tmapping (address => mapping (bytes32 => uint)) public orderFills;\r\n\t\r\n\tmapping(address=>uint) public platformVolumeRatd;\r\n\tmapping(address=>mapping(address=>uint)) public tradersVolumeRated;\r\n\t\r\n\taddress public successor;\r\n\taddress public predecessor;\r\n\tbool public deprecated;\r\n\tbool public paused;\r\n\tuint public version;\r\n\r\n\t// Logging events\r\n\tevent Cancel(address indexed tokenGet, uint256 amountGet, address indexed tokenGive, uint256 amountGive, uint256 expires, uint256 nonce, address indexed user); \r\n\tevent Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address indexed get, address indexed give, uint nonce);\r\n\tevent Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance);\r\n\tevent Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance);\r\n\tevent FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\r\n\t\r\n\tmodifier deprecable() {\r\n        require(!deprecated, \"Contract is deprecated\");\r\n        _;\r\n    }\r\n    // for security purpose we may use this to stop somefunctions for a short period of time \r\n    modifier pausable() {\r\n        require(!paused, \"Platform is temporary paused!\");\r\n        _;\r\n    }\r\n\t//------------------------------------------------------------------------\r\n\t// 2. Protocol interface \r\n\t//------------------------------------------------------------------------\r\n\taddress public protocolAddress;\r\n    bool public protocolConnected = false; \r\n    \r\n    event ChangeProtocol(address indexed oldProtocol, address indexed newProtocol); \r\n    event Distribuation(address indexed token, uint total, uint indexed level, uint indexed round); \r\n    \r\n    modifier onlyProtocol() {\r\n        require(msg.sender == protocolAddress, \"Only Protocol can call this\");\r\n        _;\r\n    }\r\n    modifier protocolConnection() {\r\n        require(protocolConnected == true, \"connected protocol is needed\"); \r\n        _;\r\n    }\r\n    \r\n\t\r\n}\r\n\r\ncontract DigitalMarketProxy is DigitalMarketStorage{\r\n    // every called functions of premissoned delegates must be added first\r\n    function addFunctions(address _delegate, bytes4 _function, string memory _signiture) public onlyOwner{\r\n        require(funDelegates[_function] == address(0), \"Function is already exist!\" );\r\n        funDelegates[_function]= _delegate; \r\n        funcN++;\r\n        emit FunctionUpdate(_function, address(0), _delegate, string(_signiture));\r\n    }\r\n    \r\n    function updateFunctions(address _delegate, bytes4 _function) public onlyOwner{\r\n        require(funDelegates[_function] != address(0), \"Function Not found!\" );\r\n        require(funDelegates[_function] == _delegate, \"Function doesn't match delegate!\" );\r\n        funDelegates[_function]= address(0); \r\n        funcN--;\r\n        emit FunctionUpdate(_function, _delegate, address(0), string('Function disabled'));\r\n    }\r\n    \r\n    function  () external payable {\r\n        address delegate = funDelegates[msg.sig];\r\n        require(delegate != address(0), \"Delegate does not exist.\");\r\n        \r\n        assembly {\r\n          let ptr := mload(0x40)\r\n          // (1) copy incoming call data\r\n          calldatacopy(ptr, 0, calldatasize)\r\n          \r\n          // (2) forward call to logic contract\r\n          let result := delegatecall(gas, delegate, ptr, calldatasize, 0, 0)\r\n          let size := returndatasize\r\n          \r\n          // (3) retrieve return data\r\n          returndatacopy(ptr, 0, size)\r\n          \r\n          // (4) forward return data back to caller\r\n          switch result\r\n          case 0 {revert(ptr, size)}\r\n          default {return (ptr, size)}\r\n        } \r\n    }\r\n    \r\n    function balanceOfUsers(address token, address user) public view returns (uint balance) {\r\n        return tokens[token][user];\r\n    }\r\n      \r\n    function balanceOfFillOrders(address userAdd, bytes32 msgHash) public view returns (uint balance) {\r\n        return orderFills[userAdd][msgHash];\r\n    }\r\n    \r\n    \r\n}\r\n\r\ncontract DigitalMarketDexSetupLogic is DigitalMarketStorage{\r\n    function DigitalTrading(uint _fee, uint _feeRate, address _predecessor) public onlyOwner {\r\n        require(_fee>0, \"fee must be greater than 0\");\r\n        require(_feeRate>0, \"fee rate must be greater than 0\");\r\n        fee = _fee;\r\n        feeRate= _feeRate;\r\n        predecessor = _predecessor;\r\n        deprecated = false;\r\n        paused = false;\r\n        if (predecessor != address(0)) {\r\n          version = DigitalMarketStorage(predecessor).version() + 1; \r\n        } else {\r\n          version = 1;\r\n        }\r\n    }\r\n    \r\n    function deprecate(bool _deprecated, address _successor) public onlyOwner  { \r\n        deprecated = _deprecated;\r\n        successor = _successor;\r\n    }\r\n    \r\n    function pause(bool _paused) public onlyOwner  { \r\n        paused = _paused;\r\n    }\r\n    \r\n    function addToBlacklist(address _wallet) public onlyOwner  { \r\n        require(blacklist[_wallet] != true, \"wallet is already blacklisted\");\r\n        blacklist[_wallet] = true;\r\n    }\r\n    \r\n    function removeFromBlacklist(address _wallet) public onlyOwner  { \r\n        require(blacklist[_wallet] == true, \"wallet is not blacklisted\");\r\n        blacklist[_wallet] = false; \r\n    }\r\n    \r\n    function changeAccountModifiers(address _accountModifiers) public onlyOwner {\r\n        accountModifiers = _accountModifiers;\r\n    }\r\n    \r\n    function changeTradeTracker(address _tradeTracker)  public onlyOwner{\r\n        tradeTracker = _tradeTracker;\r\n    }\r\n    \r\n}\r\n\r\ncontract DigitalMarketDexLogic is DigitalMarketStorage{\r\n    \r\n    function deposit() public payable deprecable {\r\n        require(!paused, \"Platform is temporary paused!\");\r\n        require(msg.value>0, \"amount must be greater than zero!\");\r\n        require(blacklist[msg.sender] != true, \"address is blacklisted!\");\r\n        \r\n        tokens[address(0)][msg.sender] = SafeMath.safeAdd(tokens[address(0)][msg.sender], msg.value);\r\n        emit Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]); \r\n    }\r\n\r\n    function withdraw(uint256 _amount) public pausable{\r\n        require(tokens[address(0)][msg.sender] >= _amount, \"insufecint balance\");\r\n        require(blacklist[msg.sender] != true, \"address is blacklisted!\");\r\n        require(_amount>0, \"amount must be greater than zero!\");\r\n        \r\n        tokens[address(0)][msg.sender] = SafeMath.safeSub(tokens[address(0)][msg.sender], _amount);\r\n        if (!msg.sender.send(_amount)) {\r\n            revert(\"Transfer has failed\");\r\n        }\r\n        emit Withdraw(address(0), msg.sender, _amount, tokens[address(0)][msg.sender]);\r\n    }\r\n  \r\n    function receiveApproval(address _spender, uint _amount, address _reciver) public payable deprecable {\r\n        address spender = _spender;\r\n        address tokenAdd = msg.sender;\r\n        require(_reciver == address(this), \"approve is not recieved!\");\r\n        require(!paused, \"Platform is temporary paused!\");\r\n        require(blacklist[_spender] != true, \"address is blacklisted!\");\r\n        require(_amount>0, \"amount must be greater than zero!\");\r\n        \r\n        if (!Token(tokenAdd).transferFrom(spender, address(this), _amount)) {\r\n          revert(\"Transfer has failed\");\r\n        }\r\n        \r\n        tokens[tokenAdd][spender] = SafeMath.safeAdd(tokens[tokenAdd][spender], _amount);\r\n        emit Deposit(tokenAdd, spender, _amount, tokens[tokenAdd][spender]);\r\n    }\r\n\r\n    function withdrawToken(address _token, uint256 _amount) public pausable{\r\n        require(_token != address(0), \"Can't withdraw ETH by this Function\");\r\n        require(tokens[_token][msg.sender] >= _amount, \"insuficient balance!\");\r\n        require(blacklist[msg.sender] != true, \"address is blacklisted!\");\r\n        require(_amount>0, \"amount must be greater than zero!\");\r\n        \r\n        tokens[_token][msg.sender] = SafeMath.safeSub(tokens[_token][msg.sender], _amount);\r\n        if (!Token(_token).transfer(msg.sender, _amount)) {\r\n          revert(\"Transfer has failed\");\r\n        }\r\n        emit Withdraw(_token, msg.sender, _amount, tokens[_token][msg.sender]);\r\n    }\r\n    \r\n    function checkGiver(address _giver, bytes32 _h, bytes memory signature) private pure returns (bool){\r\n        address signer = recoverSigner(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _h)), signature);\r\n        if(signer == _giver){ return true;} else {return false;}\r\n        \r\n    }\r\n    \r\n    function tradeMultiTransaction(address[] memory _giver, uint[] memory _gAmount, address[] memory _gToken, uint[] memory _tAmount, address[] memory _tToken,  uint[] memory _expires, uint[] memory _nonce, uint[] memory _amount, bytes memory signature, bytes memory signature2, bytes memory signature3) public protocolConnection {\r\n      require(!paused, \"Platform is temporary paused!\");\r\n      for(uint i = 0; i<_giver.length; i++){\r\n            if(i==0){\r\n               tradeMulti(_giver[i], msg.sender, _gAmount[i], _gToken[i], _tAmount[i], _tToken[i], _expires[i], _nonce[i], _amount[i], signature);\r\n            } else if(i==1){\r\n                tradeMulti(_giver[i], msg.sender, _gAmount[i], _gToken[i], _tAmount[i], _tToken[i], _expires[i], _nonce[i], _amount[i], signature2);\r\n            } else if(i==2){\r\n                tradeMulti(_giver[i], msg.sender, _gAmount[i], _gToken[i], _tAmount[i], _tToken[i], _expires[i], _nonce[i], _amount[i], signature3);\r\n            } \r\n       }\r\n    }\r\n    \r\n    function tradeMulti\r\n\t        (address _giver, address _taker, uint _gAmount, address _gToken,\r\n\t        uint _tAmount, address _tToken,  uint _expires, uint _nonce, uint _amount,\r\n\t        bytes memory signature) \r\n\t        private\r\n            {\r\n      \r\n      bytes32 h = keccak256(abi.encodePacked(this, _gToken, _gAmount, _tToken, _tAmount, _expires, _nonce)); \r\n     \r\n      require(checkGiver(_giver, h, signature)==true, \"correct giver not found!\"); \r\n      require(tokens[_gToken][_giver] >= (_gAmount - orderFills[_giver][h]), \"Giver insuficient balance!\"); \r\n      require(SafeMath.safeAdd(orderFills[_giver][h], _amount) <= _gAmount, \"order amount isn't enough!\");\r\n\t  require(tokens[_tToken][_taker] >=  (SafeMath.safeMul(_tAmount, _amount) / _gAmount), \"Takeer insuficient balance\"); \r\n\t  require(block.number < _expires, \"Open order has expired!\"); \r\n\t  \r\n\t  // call and do the exchange  \r\n      tradeBalances(_tToken, (SafeMath.safeMul(_tAmount, _amount) / _gAmount), _gToken, _amount, _giver, _taker);\r\n\t  orderFills[_giver][h] = SafeMath.safeAdd(orderFills[_giver][h], _amount);\r\n\t  \r\n\t  // update volume information [for protocol purpose]\r\n\t  platformVolume[_gToken] = SafeMath.safeAdd(platformVolume[_gToken], _amount);\r\n\t  tradersVolume[_gToken][_giver] = SafeMath.safeAdd(tradersVolume[_gToken][_giver], _amount);\r\n\t  tradersVolume[_tToken][msg.sender] = SafeMath.safeAdd(tradersVolume[_tToken][msg.sender], (SafeMath.safeMul(_tAmount, _amount) / _gAmount));\r\n\t  platformVolume[_tToken] = SafeMath.safeAdd(platformVolume[_tToken], (SafeMath.safeMul(_tAmount, _amount) / _gAmount));\r\n\t  \r\n\t  if(_gToken == address(0)){ // for converting rate purpose \r\n\t      tradersVolumeRated[_tToken][msg.sender] = SafeMath.safeAdd(tradersVolumeRated[_tToken][msg.sender], _amount);\r\n\t      platformVolumeRatd[_tToken] = SafeMath.safeAdd(platformVolumeRatd[_tToken], _amount); // _gAmount\r\n\t  } else {\r\n\t      tradersVolumeRated[_gToken][_giver] = SafeMath.safeAdd(tradersVolumeRated[_gToken][_giver], (SafeMath.safeMul(_tAmount, _amount) / _gAmount));\r\n\t      platformVolumeRatd[_gToken] = SafeMath.safeAdd(platformVolumeRatd[_gToken], (SafeMath.safeMul(_tAmount, _amount) / _gAmount)); \r\n\t  }\r\n\t  \r\n\t  emit Trade(_gToken, _gAmount, _tToken, _tAmount, _giver, _taker, _nonce);\r\n\t  \r\n    }\r\n    \r\n\t\r\n\tfunction trade\r\n\t        (address _giver, uint _gAmount, address _gToken,\r\n\t        uint _tAmount, address _tToken,  uint _expires, uint _nonce, uint _amount,\r\n\t        bytes memory signature) \r\n\t        public protocolConnection\r\n            {\r\n      require(!paused, \"Platform is temporary paused!\"); \r\n      bytes32 h = keccak256(abi.encodePacked(this, _gToken, _gAmount, _tToken, _tAmount, _expires, _nonce)); \r\n      address signer = recoverSigner(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", h)), signature);\r\n      \r\n      require (signer == _giver, \"Order signiture Error\");\r\n      require(tokens[_gToken][_giver] >= (_gAmount - orderFills[_giver][h]), \"Giver insuficient balance!\"); \r\n      require(SafeMath.safeAdd(orderFills[_giver][h], _amount) <= _gAmount, \"order amount isn't enough!\");\r\n\t  require(tokens[_tToken][msg.sender] >=  (SafeMath.safeMul(_tAmount, _amount) / _gAmount), \"Taker insuficient balance\"); \r\n\t  require(block.number < _expires, \"Open order has expired!\"); \r\n\t  \r\n\t  // call and do the exchange  \r\n      tradeBalances(_tToken, (SafeMath.safeMul(_tAmount, _amount) / _gAmount), _gToken, _amount, _giver, msg.sender);\r\n\t  orderFills[_giver][h] = SafeMath.safeAdd(orderFills[_giver][h], _amount);\r\n\t  \r\n\t  // update volume information [for protocol purpose]\r\n\t  platformVolume[_gToken] = SafeMath.safeAdd(platformVolume[_gToken], _amount);\r\n\t  tradersVolume[_gToken][_giver] = SafeMath.safeAdd(tradersVolume[_gToken][_giver], _amount);\r\n\t  tradersVolume[_tToken][msg.sender] = SafeMath.safeAdd(tradersVolume[_tToken][msg.sender], (SafeMath.safeMul(_tAmount, _amount) / _gAmount));\r\n\t  platformVolume[_tToken] = SafeMath.safeAdd(platformVolume[_tToken], (SafeMath.safeMul(_tAmount, _amount) / _gAmount)); \r\n\t  \r\n\t  if(_gToken == address(0)){ // for converting rate purpose \r\n\t      tradersVolumeRated[_tToken][msg.sender] = SafeMath.safeAdd(tradersVolumeRated[_tToken][msg.sender], _amount);\r\n\t      platformVolumeRatd[_tToken] = SafeMath.safeAdd(platformVolumeRatd[_tToken], _amount); \r\n\t  } else {\r\n\t      tradersVolumeRated[_gToken][_giver] = SafeMath.safeAdd(tradersVolumeRated[_gToken][_giver], (SafeMath.safeMul(_tAmount, _amount) / _gAmount));\r\n\t      platformVolumeRatd[_gToken] = SafeMath.safeAdd(platformVolumeRatd[_gToken], (SafeMath.safeMul(_tAmount, _amount) / _gAmount)); \r\n\t  }\r\n\t  \r\n\t  emit Trade(_gToken, _gAmount, _tToken, _tAmount, _giver, msg.sender, _nonce);\r\n\t}\r\n    \r\n    function tradeBalances(address _tToken, uint _tAmount, address _gToken, uint _gAmount,\r\n            address _giver, address _caller\r\n            ) private {\r\n     // Calucate the amount for each one\r\n\t  uint gNet = SafeMath.safeSub(_gAmount, SafeMath.safeDiv(_gAmount, (100/fee)) / feeRate);\r\n\t  uint tNet = SafeMath.safeSub(_tAmount, SafeMath.safeDiv(_tAmount, (100/fee)) / feeRate);// (100/(fee/1)))) / feeRate; \r\n\t  // Transfering the amount Between users\r\n\t  //Giver\r\n\t  tokens[_gToken][_giver] = SafeMath.safeSub(tokens[_gToken][_giver], _gAmount); // All amount\r\n\t  tokens[_tToken][_giver] = SafeMath.safeAdd(tokens[_tToken][_giver], tNet); // Net amount of tNet\r\n\t  // Taker\r\n\t  tokens[_tToken][_caller] = SafeMath.safeSub(tokens[_tToken][_caller], _tAmount); // All amount\r\n\t  tokens[_gToken][_caller] = SafeMath.safeAdd(tokens[_gToken][_caller], gNet); // Net amount of gAmount\r\n\t  // Fee\r\n\t  tokens[_gToken][protocolAddress] = SafeMath.safeAdd(tokens[_gToken][protocolAddress], SafeMath.safeDiv(_gAmount, (100/fee))/ feeRate); // feeAccount\r\n\t  tokens[_tToken][protocolAddress] = SafeMath.safeAdd(tokens[_tToken][protocolAddress], SafeMath.safeDiv(_tAmount, (100/fee))/ feeRate); // feeAccount\r\n\t  \r\n\t  platformFees[_gToken] = SafeMath.safeAdd(platformFees[_gToken], SafeMath.safeDiv(_gAmount, (100/fee))/ feeRate);\r\n\t  platformFees[_tToken] = SafeMath.safeAdd(platformFees[_tToken], SafeMath.safeDiv(_tAmount, (100/fee))/ feeRate);\r\n\t  \r\n\t  if (tradeTracker != address(0)) {\r\n        TradeTrackerInterface(tradeTracker).tradeComplete(_tToken, _tAmount, _gToken, _gAmount, _giver, _caller, SafeMath.safeDiv(_tAmount, 100), 0); \r\n      }\r\n\t}\r\n\t\r\n\tfunction cancelOrder\r\n\t        (address _giver, uint _gAmount, address _gToken, uint _tAmount, address _tToken,  \r\n\t        uint _expires, uint _nonce, uint _amount,  bytes memory signature)  public  \r\n\t        {\r\n         require(!paused, \"Platform is temporary paused!\");\r\n         bytes32 h = keccak256(abi.encodePacked(this, _gToken, _gAmount, _tToken, _tAmount, _expires, _nonce)); \r\n         address signer = recoverSigner(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", h)), signature);\r\n         \r\n         require (signer == _giver, \"Order signiture Error!\");\r\n         require (_giver == msg.sender, \"user not premissoned!\");\r\n         uint FilledBefore = orderFills[_giver][h];\r\n         //orderFills[_giver][h] = SafeMath.safeAdd(orderFills[_giver][h], (_amount - FilledBefore));\r\n         orderFills[_giver][h] = _gAmount; // 100% of amount and prevent Java Bignumbers Errors \r\n         emit Cancel(_gToken, _gAmount, _tToken, _tAmount, _expires, _nonce, msg.sender);\r\n    }\r\n    \r\n    // Signitures \r\n    function splitSignature(bytes memory sig) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\r\n        require(sig.length == 65, \"Signiture Error!\");\r\n        assembly {\r\n            // first 32 bytes, after the length prefix.\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes.\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes).\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n        return (v, r, s);\r\n    }\r\n    \r\n    function recoverSigner(bytes32 message, bytes memory sig) internal pure returns (address) {\r\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\r\n        return ecrecover(message, v, r, s);\r\n    }\r\n    \r\n}\r\n\r\ncontract DigitalMarketProtocolLogic is DigitalMarketStorage{\r\n    \r\n    function setUpProtocol(address _protocol) public onlyOwner{\r\n        require(protocolAddress == address(0), \"Protocol is already set\"); \r\n        protocolAddress = _protocol;\r\n        protocolConnected = true; \r\n    }\r\n    \r\n    function changeProtocol(address _newProtocol, address[] memory _tokens) public onlyOwner{\r\n        require(protocolAddress != address(0),\"protocol is not set yet\");\r\n        //require(protocolAddress == msg.sender,\"Only protocol!\");\r\n        // Moving Fees balance to the new Protcol \r\n        uint ETHamount = tokens[address(0)][protocolAddress];\r\n        uint tokenAmount;\r\n        \r\n        tokens[address(0)][_newProtocol] = SafeMath.safeAdd(tokens[address(0)][_newProtocol], ETHamount);\r\n        tokens[address(0)][protocolAddress] = SafeMath.safeSub(tokens[address(0)][protocolAddress], ETHamount);\r\n          \r\n        for(uint i=0; i<_tokens.length; i++){\r\n            tokenAmount = tokens[_tokens[i]][protocolAddress];\r\n            tokens[_tokens[i]][_newProtocol] = SafeMath.safeAdd(tokens[_tokens[i]][_newProtocol], tokenAmount);\r\n            tokens[_tokens[i]][protocolAddress] = SafeMath.safeSub(tokens[_tokens[i]][protocolAddress], tokenAmount);\r\n        }\r\n        address oldProtocol = protocolAddress; \r\n        protocolAddress = _newProtocol; \r\n        emit ChangeProtocol(oldProtocol, _newProtocol); \r\n    }\r\n    \r\n    function distributeFeesPool(address[] memory _tokens, address[] memory _benficiaries, \r\n        uint[] memory _amounts\r\n    ) public onlyProtocol{\r\n        //require(!paused, \"Platform is temporary paused!\");\r\n        require(_benficiaries.length == _tokens.length, \"inputs not matched!\");\r\n        require(_benficiaries.length == _amounts.length, \"inputs not matched2!\");\r\n        \r\n        // Do Distribuation \r\n        for(uint i=0; i<_benficiaries.length; i++){\r\n            tokens[_tokens[i]][_benficiaries[i]] = SafeMath.safeAdd(tokens[_tokens[i]][_benficiaries[i]], _amounts[i]);\r\n            tokens[_tokens[i]][protocolAddress] = SafeMath.safeSub(tokens[_tokens[i]][protocolAddress], _amounts[i]);\r\n            tradersDistributed[_tokens[i]][_benficiaries[i]] = SafeMath.safeAdd(tradersDistributed[_tokens[i]][_benficiaries[i]], _amounts[i]);\r\n            \r\n            distributedFees[_tokens[i]] = SafeMath.safeAdd(distributedFees[_tokens[i]], _amounts[i]);\r\n            emit Distribuation(_tokens[i], _amounts[i], 1, 1); \r\n        }\r\n    }\r\n    \r\n    \r\n}"
    }
  }
}