{"language":"Solidity","settings":{"evmVersion":"london","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":999999},"remappings":[],"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}},"sources":{"contracts/interfaces/IChickenNoodle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IChickenNoodle {\n    // struct to store each token's traits\n    struct ChickenNoodleTraits {\n        bool minted;\n        bool isChicken;\n        uint8 backgrounds;\n        uint8 snakeBodies;\n        uint8 mouthAccessories;\n        uint8 pupils;\n        uint8 bodyAccessories;\n        uint8 hats;\n        uint8 tier;\n    }\n\n    function MAX_TOKENS() external view returns (uint256);\n\n    function PAID_TOKENS() external view returns (uint256);\n\n    function tokenTraits(uint256 tokenId)\n        external\n        view\n        returns (ChickenNoodleTraits memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address tokenOwner) external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function mint(address to, uint16 tokenId) external;\n\n    function finalize(\n        uint16 tokenId,\n        ChickenNoodleTraits memory traits,\n        address thief\n    ) external;\n}\n"},"contracts/interfaces/IFarm.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './IChickenNoodle.sol';\n\ninterface IFarm {\n    struct Stake {\n        uint16 tokenId;\n        uint80 value;\n        address owner;\n    }\n\n    struct PagingData {\n        address tokenOwner;\n        uint16 limit;\n        uint16 page;\n    }\n\n    function totalChickenStaked() external view returns (uint16);\n\n    function MINIMUM_TO_EXIT() external view returns (uint256);\n\n    function MAX_TIER_SCORE() external view returns (uint8);\n\n    function MAXIMUM_GLOBAL_EGG() external view returns (uint256);\n\n    function DAILY_GEN0_EGG_RATE() external view returns (uint256);\n\n    function DAILY_GEN1_EGG_RATE() external view returns (uint256);\n\n    function eggPerTierScore() external view returns (uint256);\n\n    function totalEggEarned() external view returns (uint256);\n\n    function lastClaimTimestamp() external view returns (uint256);\n\n    function denIndices(uint16 tokenId) external view returns (uint16);\n\n    function chickenNoodle() external view returns (IChickenNoodle);\n\n    function isChicken(uint16 tokenId) external view returns (bool);\n\n    function tierScoreForNoodle(uint16 tokenId) external view returns (uint8);\n\n    function randomNoodleOwner(uint256 seed) external view returns (address);\n}\n"},"contracts/libraries/FarmLookupLibrary.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../interfaces/IFarm.sol';\n\nlibrary FarmLookupLibrary {\n    struct Counters {\n        uint256 skipCounter;\n        uint256 counter;\n    }\n\n    function getTotalStaked(\n        address farmAddress,\n        mapping(uint8 => IFarm.Stake[]) storage den\n    )\n        public\n        view\n        returns (\n            uint16 chickens,\n            uint16 noodles,\n            uint16 tier5Noodles,\n            uint16 tier4Noodles,\n            uint16 tier3Noodles,\n            uint16 tier2Noodles,\n            uint16 tier1Noodles\n        )\n    {\n        IFarm farm = IFarm(farmAddress);\n\n        chickens = farm.totalChickenStaked();\n\n        tier5Noodles = uint16(den[farm.MAX_TIER_SCORE()].length);\n        tier4Noodles = uint16(den[farm.MAX_TIER_SCORE() - 1].length);\n        tier3Noodles = uint16(den[farm.MAX_TIER_SCORE() - 2].length);\n        tier2Noodles = uint16(den[farm.MAX_TIER_SCORE() - 3].length);\n        tier1Noodles = uint16(den[farm.MAX_TIER_SCORE() - 4].length);\n\n        noodles =\n            tier5Noodles +\n            tier4Noodles +\n            tier3Noodles +\n            tier2Noodles +\n            tier1Noodles;\n    }\n\n    function getStakedBalanceOf(\n        address farmAddress,\n        address tokenOwner,\n        mapping(uint16 => IFarm.Stake) storage henHouse,\n        mapping(uint8 => IFarm.Stake[]) storage den,\n        mapping(uint16 => uint16) storage denIndices\n    )\n        public\n        view\n        returns (\n            uint16 chickens,\n            uint16 noodles,\n            uint16 tier5Noodles,\n            uint16 tier4Noodles,\n            uint16 tier3Noodles,\n            uint16 tier2Noodles,\n            uint16 tier1Noodles\n        )\n    {\n        IFarm farm = IFarm(farmAddress);\n\n        uint16 supply = uint16(farm.chickenNoodle().totalSupply());\n\n        for (uint16 tokenId = 1; tokenId <= supply; tokenId++) {\n            if (farm.chickenNoodle().ownerOf(tokenId) != address(this)) {\n                continue;\n            }\n\n            if (farm.isChicken(tokenId)) {\n                if (henHouse[tokenId].owner == tokenOwner) {\n                    chickens++;\n                }\n            } else {\n                uint8 tierScore = farm.tierScoreForNoodle(tokenId);\n\n                if (den[tierScore][denIndices[tokenId]].owner == tokenOwner) {\n                    if (tierScore == 8) {\n                        tier5Noodles++;\n                    } else if (tierScore == 7) {\n                        tier4Noodles++;\n                    } else if (tierScore == 6) {\n                        tier3Noodles++;\n                    } else if (tierScore == 5) {\n                        tier2Noodles++;\n                    } else if (tierScore == 4) {\n                        tier1Noodles++;\n                    }\n                }\n            }\n        }\n\n        noodles =\n            tier5Noodles +\n            tier4Noodles +\n            tier3Noodles +\n            tier2Noodles +\n            tier1Noodles;\n    }\n\n    function getStakedChickensForOwner(\n        address farmAddress,\n        IFarm.PagingData memory data,\n        mapping(uint16 => IFarm.Stake) storage henHouse,\n        mapping(uint8 => IFarm.Stake[]) storage den,\n        mapping(uint16 => uint16) storage denIndices\n    )\n        public\n        view\n        returns (\n            uint16[] memory tokens,\n            uint256[] memory timeTellUnlock,\n            uint256[] memory earnedEgg\n        )\n    {\n        IFarm farm = IFarm(farmAddress);\n\n        (uint16 tokensOwned, , , , , , ) = getStakedBalanceOf(\n            farmAddress,\n            data.tokenOwner,\n            henHouse,\n            den,\n            denIndices\n        );\n\n        (uint256 tokensSize, uint256 pageStart) = _paging(\n            tokensOwned,\n            data.limit,\n            data.page\n        );\n\n        tokens = new uint16[](tokensSize);\n        timeTellUnlock = new uint256[](tokensSize);\n        earnedEgg = new uint256[](tokensSize);\n\n        Counters memory counters;\n\n        uint16 supply = uint16(farm.chickenNoodle().totalSupply());\n\n        for (\n            uint16 tokenId = 1;\n            tokenId <= supply && counters.counter < tokens.length;\n            tokenId++\n        ) {\n            if (farm.chickenNoodle().ownerOf(tokenId) != address(this)) {\n                continue;\n            }\n\n            if (\n                farm.isChicken(tokenId) &&\n                henHouse[tokenId].owner == data.tokenOwner\n            ) {\n                IFarm.Stake memory stake = henHouse[tokenId];\n\n                if (counters.skipCounter < pageStart) {\n                    counters.skipCounter++;\n                    continue;\n                }\n\n                tokens[counters.counter] = tokenId;\n                timeTellUnlock[counters.counter] = block.timestamp -\n                    stake.value <\n                    farm.MINIMUM_TO_EXIT()\n                    ? farm.MINIMUM_TO_EXIT() - (block.timestamp - stake.value)\n                    : 0;\n\n                if (farm.totalEggEarned() < farm.MAXIMUM_GLOBAL_EGG()) {\n                    earnedEgg[counters.counter] =\n                        ((block.timestamp - stake.value) *\n                            (\n                                tokenId <= farm.chickenNoodle().PAID_TOKENS()\n                                    ? farm.DAILY_GEN0_EGG_RATE()\n                                    : farm.DAILY_GEN1_EGG_RATE()\n                            )) /\n                        1 days;\n                } else if (stake.value > farm.lastClaimTimestamp()) {\n                    earnedEgg[counters.counter] = 0; // $EGG production stopped already\n                } else {\n                    earnedEgg[counters.counter] =\n                        ((farm.lastClaimTimestamp() - stake.value) *\n                            (\n                                tokenId <= farm.chickenNoodle().PAID_TOKENS()\n                                    ? farm.DAILY_GEN0_EGG_RATE()\n                                    : farm.DAILY_GEN1_EGG_RATE()\n                            )) /\n                        1 days; // stop earning additional $EGG if it's all been earned\n                }\n\n                counters.counter++;\n            }\n        }\n    }\n\n    function getStakedNoodlesForOwner(\n        address farmAddress,\n        IFarm.PagingData memory data,\n        mapping(uint16 => IFarm.Stake) storage henHouse,\n        mapping(uint8 => IFarm.Stake[]) storage den,\n        mapping(uint16 => uint16) storage denIndices\n    )\n        public\n        view\n        returns (\n            uint16[] memory tokens,\n            uint8[] memory tier,\n            uint256[] memory taxedEgg\n        )\n    {\n        IFarm farm = IFarm(farmAddress);\n\n        (, uint16 tokensOwned, , , , , ) = getStakedBalanceOf(\n            farmAddress,\n            data.tokenOwner,\n            henHouse,\n            den,\n            denIndices\n        );\n\n        (uint256 tokensSize, uint256 pageStart) = _paging(\n            tokensOwned,\n            data.limit,\n            data.page\n        );\n\n        tokens = new uint16[](tokensSize);\n        tier = new uint8[](tokensSize);\n        taxedEgg = new uint256[](tokensSize);\n\n        Counters memory counters;\n\n        uint16 supply = uint16(farm.chickenNoodle().totalSupply());\n\n        for (\n            uint16 tokenId = 1;\n            tokenId <= supply && counters.counter < tokens.length;\n            tokenId++\n        ) {\n            if (farm.chickenNoodle().ownerOf(tokenId) != address(this)) {\n                continue;\n            }\n\n            if (!farm.isChicken(tokenId)) {\n                uint8 tierScore = farm.tierScoreForNoodle(tokenId);\n\n                IFarm.Stake memory stake = den[tierScore][denIndices[tokenId]];\n\n                if (stake.owner == data.tokenOwner) {\n                    if (counters.skipCounter < pageStart) {\n                        counters.skipCounter++;\n                        continue;\n                    }\n\n                    tokens[counters.counter] = tokenId;\n                    tier[counters.counter] = tierScore - 3;\n                    taxedEgg[counters.counter] =\n                        (tierScore) *\n                        (farm.eggPerTierScore() - stake.value);\n                    counters.counter++;\n                }\n            }\n        }\n    }\n\n    function _paging(\n        uint16 tokensOwned,\n        uint16 limit,\n        uint16 page\n    ) private pure returns (uint256 tokensSize, uint256 pageStart) {\n        pageStart = limit * page;\n        uint256 pageEnd = limit * (page + 1);\n        tokensSize = tokensOwned >= pageEnd\n            ? limit\n            : (tokensOwned > pageStart ? tokensOwned - pageStart : 0);\n    }\n}\n"}}}