{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/lao.sol": {
      "content": "pragma solidity ^0.7.0;\n// SPDX-License-Identifier: MIT\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    bool private _notEntered;\n\n    constructor () {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\n /*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract WETH {\n    string public name     = \"Wrapped Ether\";\n    string public symbol   = \"WETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n    receive() external payable {\n        deposit();\n    }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad, \"not enough WETH to withdraw\");\n        require(address(this).balance >= wad, \"not enough ETH in the contract\");\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad, \"insufficient fund\");\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad, \"not allowed to transfer from\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n\ncontract LAO is ReentrancyGuard, Ownable {\n    using SafeMath for uint256;\n\n    /***************\n    GLOBAL CONSTANTS\n    ***************/\n    uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\n    uint256 public proposalDeposit; // default = 10 ETH (~$1,000 worth of ETH at contract deployment)\n    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\n    uint256 public processingReward; // default = 0.1 - amount of ETH to give to whoever processes a proposal\n    uint256 public summoningTime; // needed to determine the current period\n\n    address public depositToken; // deposit token contract reference; default = wETH\n    /******\n     AdminFee - LAO exclusive, add on to original Moloch\n     *********/\n    uint256 constant paymentPeriod = 90 days; //90 days; - 1 day is for test only!\n    uint256 public lastPaymentTime; //this will set as 'now' in construtor = summoningTime;\n    address public laoFundAddress; //This field MUST be set in constructor or set to default to summoner here.\n    uint256 public adminFeeDenominator = 200; //initial denominator\n   \n    // HARD-CODED LIMITS\n    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations\n    // with periods or shares, yet big enough to not limit reasonable use cases.\n    uint256 constant MAX_VOTING_PERIOD_LENGTH = 10**18; // maximum length of voting period\n    uint256 constant MAX_GRACE_PERIOD_LENGTH = 10**18; // maximum length of grace period\n    uint256 constant MAX_DILUTION_BOUND = 10**18; // maximum dilution bound\n    uint256 constant MAX_NUMBER_OF_SHARES_AND_LOOT = 10**18; // maximum number of shares that can be minted\n    uint256 constant MAX_TOKEN_WHITELIST_COUNT = 200; // maximum number of whitelisted tokens, default is 400\n    uint256 constant MAX_TOKEN_GUILDBANK_COUNT = 100; // maximum number of tokens with non-zero balance in guildbank, default is 200\n\n    // ***************\n    // EVENTS\n    // ***************\n    event SummonComplete(address indexed summoner, address[] tokens, uint256 summoningTime, uint256 periodDuration, uint256 votingPeriodLength, uint256 gracePeriodLength, uint256 proposalDeposit, uint256 dilutionBound, uint256 processingReward);\n    event SubmitProposal(address indexed applicant, uint256 sharesRequested, uint256 lootRequested, uint256 tributeOffered, address tributeToken, uint256 paymentRequested, address paymentToken, string details, bool[6] flags, uint256 proposalId, address indexed delegateKey, address indexed memberAddress);\n    event SponsorProposal(address indexed delegateKey, address indexed memberAddress, uint256 proposalId, uint256 proposalIndex, uint256 startingPeriod);\n    event SubmitVote(uint256 proposalId, uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\n    event ProcessProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\n    event ProcessWhitelistProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\n    event ProcessGuildKickProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn, uint256 lootToBurn);\n    event TokensCollected(address indexed token, uint256 amountToCollect);\n    event CancelProposal(uint256 indexed proposalId, address applicantAddress);\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\n    event Withdraw(address indexed memberAddress, address token, uint256 amount);\n\n    // *******************\n    // INTERNAL ACCOUNTING\n    // *******************\n    uint256 public proposalCount = 0; // total proposals submitted\n    uint256 public totalShares = 0; // total shares across all members\n    uint256 public totalLoot = 0; // total loot across all members\n\n    uint256 public totalGuildBankTokens = 0; // total tokens with non-zero balance in guild bank\n\n    address public constant GUILD = address(0xdead);\n    address public constant ESCROW = address(0xbeef);\n    address public constant TOTAL = address(0xbabe);\n    mapping (address => mapping(address => uint256)) public userTokenBalances; // userTokenBalances[userAddress][tokenAddress]\n\n    enum Vote {\n        Null, // default value, counted as abstention\n        Yes,\n        No\n    }\n\n    struct Member {\n        address delegateKey; // the key responsible for submitting proposals and voting - defaults to member address unless updated\n        uint256 shares; // the # of voting shares assigned to this member\n        uint256 loot; // the loot amount available to this member (combined with shares on ragequit)\n        bool exists; // always true once a member has been created\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\n        uint256 jailed; // set to proposalIndex of a passing guild kick proposal for this member, prevents voting on and sponsoring proposals\n    }\n\n    struct Proposal {\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals (doubles as guild kick target for gkick proposals)\n        address proposer; // the account that submitted the proposal (can be non-member)\n        address sponsor; // the member that sponsored the proposal (moving it into the queue)\n        uint256 sharesRequested; // the # of shares the applicant is requesting\n        uint256 lootRequested; // the amount of loot the applicant is requesting\n        uint256 tributeOffered; // amount of tokens offered as tribute\n        address tributeToken; // tribute token contract reference\n        uint256 paymentRequested; // amount of tokens requested as payment\n        address paymentToken; // payment token contract reference\n        uint256 startingPeriod; // the period in which voting can start for this proposal\n        uint256 yesVotes; // the total number of YES votes for this proposal\n        uint256 noVotes; // the total number of NO votes for this proposal\n        bool[6] flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n        string details; // proposal details - could be IPFS hash, plaintext, or JSON\n        uint256 maxTotalSharesAndLootAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\n        mapping(address => Vote) votesByMember; // the votes on this proposal by each member\n    }\n\n    mapping(address => bool) public tokenWhitelist;\n    address[] public approvedTokens;\n\n    mapping(address => bool) public proposedToWhitelist;\n    mapping(address => bool) public proposedToKick;\n\n    mapping(address => Member) public members;\n    mapping(address => address) public memberAddressByDelegateKey;\n\n    mapping(uint256 => Proposal) public proposals;\n\n    uint256[] public proposalQueue;\n\n    modifier onlyMember {\n        require(members[msg.sender].shares > 0 || members[msg.sender].loot > 0, \"not a member\");\n        _;\n    }\n\n    modifier onlyShareholder {\n        require(members[msg.sender].shares > 0, \"not a shareholder\");\n        _;\n    }\n\n    modifier onlyDelegate {\n        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, \"not a delegate\");\n        _;\n    }\n\n    constructor(\n        address _summoner,\n        address[] memory _approvedTokens,\n        uint256 _periodDuration,\n        uint256 _votingPeriodLength,\n        uint256 _gracePeriodLength,\n        uint256 _proposalDeposit,\n        uint256 _dilutionBound,\n        uint256 _processingReward,\n        address _laoFundAddress\n    ) {\n        require(_summoner != address(0), \"summoner cannot be 0\");\n        require(_periodDuration > 0, \"_periodDuration cannot be 0\");\n        require(_votingPeriodLength > 0, \"_votingPeriodLength cannot be 0\");\n        require(_votingPeriodLength <= MAX_VOTING_PERIOD_LENGTH, \"_votingPeriodLength exceeds limit\");\n        require(_gracePeriodLength <= MAX_GRACE_PERIOD_LENGTH, \"_gracePeriodLength exceeds limit\");\n        require(_dilutionBound > 0, \"_dilutionBound cannot be 0\");\n        require(_dilutionBound <= MAX_DILUTION_BOUND, \"_dilutionBound exceeds limit\");\n        require(_approvedTokens.length > 0, \"need at least one approved token\");\n        require(_approvedTokens.length <= MAX_TOKEN_WHITELIST_COUNT, \"too many tokens\");\n        require(_proposalDeposit >= _processingReward, \"_proposalDeposit cannot be smaller than _processingReward\");\n        require(_laoFundAddress != address(0), \"laoFundAddress cannot be 0\");\n        depositToken = _approvedTokens[0];\n        // NOTE: move event up here, avoid stack too deep if too many approved tokens\n        emit SummonComplete(_summoner, _approvedTokens, block.timestamp, _periodDuration, _votingPeriodLength, _gracePeriodLength, _proposalDeposit, _dilutionBound, _processingReward);\n\n\n        for (uint256 i = 0; i < _approvedTokens.length; i++) {\n            require(_approvedTokens[i] != address(0), \"_approvedToken cannot be 0\");\n            require(!tokenWhitelist[_approvedTokens[i]], \"duplicate approved token\");\n            tokenWhitelist[_approvedTokens[i]] = true;\n            approvedTokens.push(_approvedTokens[i]);\n        }\n\n        periodDuration = _periodDuration;\n        votingPeriodLength = _votingPeriodLength;\n        gracePeriodLength = _gracePeriodLength;\n        proposalDeposit = _proposalDeposit;\n        dilutionBound = _dilutionBound;\n        processingReward = _processingReward;\n\n        summoningTime = block.timestamp;\n        laoFundAddress = _laoFundAddress; //LAO add on for adminFee\n        lastPaymentTime = block.timestamp;  //LAO add on adminFee\n        members[_summoner] = Member(_summoner, 1, 0, true, 0, 0);\n        memberAddressByDelegateKey[_summoner] = _summoner;\n        totalShares = 1;\n       \n    }\n    \n    /*******\n\n    ADMIN FEE FUNCTION \n    -- LAO add on functions to MOLCOH\n    setAdminFee can only be changed by Owner\n    withdrawAdminFee can by be called by any ETH address\n\n    ******/\n    \n    // @dev Owner can change amount of adminFee and direction of funds \n    // @param adminFeeDenoimnator must be >= 200. Greater than 200, will equal 0.5% or less of assets.  \n    //@param laoFundAddress - where the Owner wants the funds to go. \n\n    function setAdminFee (uint256 _adminFeeDenominator, address _laoFundAddress) public nonReentrant onlyOwner{\n        require(_adminFeeDenominator >= 200); \n        adminFeeDenominator = _adminFeeDenominator; \n        laoFundAddress = _laoFundAddress;\n    } //end of setAdminFee\n    \n    //can be called by an ETH Address\n    function withdrawAdminFee () public nonReentrant {\n       \n        require (block.timestamp >= lastPaymentTime.add(paymentPeriod), \"90 days have not passed since last withdrawal\");\n        lastPaymentTime = block.timestamp;\n        //local variables to save gas by reading from storage only 1x\n        uint256 denominator = adminFeeDenominator; \n        address recipient = laoFundAddress;\n        \n        for (uint256 i = 0; i < approvedTokens.length; i++) {\n            address token = approvedTokens[i];\n            uint256 amount = userTokenBalances[GUILD][token] / denominator;\n            if (amount > 0) { // otherwise skip for efficiency, only tokens with a balance\n               userTokenBalances[GUILD][token] -= amount;\n               userTokenBalances[recipient][token] += amount;\n            }\n        } \n        // Remove Event emit WithdrawAdminFee(laoFundAddress,token, amount);\n    } //end of withdrawAdminFee\n    \n    /*****************\n    PROPOSAL FUNCTIONS\n    *****************/\n    function submitProposal(\n        address applicant,\n        uint256 sharesRequested,\n        uint256 lootRequested,\n        uint256 tributeOffered,\n        address tributeToken,\n        uint256 paymentRequested,\n        address paymentToken,\n        string memory details\n    ) public nonReentrant returns (uint256 proposalId) {\n        require(sharesRequested.add(lootRequested) <= MAX_NUMBER_OF_SHARES_AND_LOOT, \"too many shares requested\");\n        require(tokenWhitelist[tributeToken], \"tributeToken is not whitelisted\");\n        require(tokenWhitelist[paymentToken], \"payment is not whitelisted\");\n        require(applicant != address(0), \"applicant cannot be 0\");\n        require(applicant != GUILD && applicant != ESCROW && applicant != TOTAL, \"applicant address cannot be reserved\");\n        require(members[applicant].jailed == 0, \"proposal applicant must not be jailed\");\n\n        if (tributeOffered > 0 && userTokenBalances[GUILD][tributeToken] == 0) {\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, 'cannot submit more tribute proposals for new tokens - guildbank is full');\n        }\n\n        // collect tribute from proposer and store it in the Moloch until the proposal is processed\n        require(IERC20(tributeToken).transferFrom(msg.sender, address(this), tributeOffered), \"tribute token transfer failed\");\n        unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);\n\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n\n        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags);\n        return proposalCount - 1; // return proposalId - contracts calling submit might want it\n    }\n\n    function submitWhitelistProposal(address tokenToWhitelist, string memory details) public nonReentrant returns (uint256 proposalId) {\n        require(tokenToWhitelist != address(0), \"must provide token address\");\n        require(!tokenWhitelist[tokenToWhitelist], \"cannot already have whitelisted the token\");\n        require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"cannot submit more whitelist proposals\");\n\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n        flags[4] = true; // whitelist\n\n        _submitProposal(address(0), 0, 0, 0, tokenToWhitelist, 0, address(0), details, flags);\n        return proposalCount - 1;\n    }\n\n    function submitGuildKickProposal(address memberToKick, string memory details) public nonReentrant returns (uint256 proposalId) {\n        Member memory member = members[memberToKick];\n\n        require(member.shares > 0 || member.loot > 0, \"member must have at least one share or one loot\");\n        require(members[memberToKick].jailed == 0, \"member must not already be jailed\");\n\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n        flags[5] = true; // guild kick\n\n        _submitProposal(memberToKick, 0, 0, 0, address(0), 0, address(0), details, flags);\n        return proposalCount - 1;\n    }\n\n    function _submitProposal(\n        address applicant,\n        uint256 sharesRequested,\n        uint256 lootRequested,\n        uint256 tributeOffered,\n        address tributeToken,\n        uint256 paymentRequested,\n        address paymentToken,\n        string memory details,\n        bool[6] memory flags\n    ) internal {\n        Proposal storage proposal = proposals[proposalCount];\n        proposal.applicant = applicant; \n        proposal.proposer = msg.sender;\n        proposal.sponsor = address(0);\n        proposal.sharesRequested = sharesRequested;\n        proposal.lootRequested = lootRequested;\n        proposal.tributeOffered = tributeOffered;\n        proposal.tributeToken = tributeToken;\n        proposal.paymentRequested = paymentRequested;\n        proposal.paymentToken = paymentToken;\n        proposal.startingPeriod = 0;\n        proposal.yesVotes = 0;\n        proposal.noVotes = 0;\n        proposal.flags = flags;\n        proposal.details = details;\n        proposal.maxTotalSharesAndLootAtYesVote = 0;\n\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\n        // NOTE: argument order matters, avoid stack too deep\n        emit SubmitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, proposalCount, msg.sender, memberAddress);\n        proposalCount += 1;\n    }\n\n    function sponsorProposal(uint256 proposalId) public nonReentrant onlyDelegate {\n        // collect proposal deposit from sponsor and store it in the Moloch until the proposal is processed\n        require(IERC20(depositToken).transferFrom(msg.sender, address(this), proposalDeposit), \"proposal deposit token transfer failed\");\n        unsafeAddToBalance(ESCROW, depositToken, proposalDeposit);\n\n        Proposal storage proposal = proposals[proposalId];\n\n        require(proposal.proposer != address(0), 'proposal must have been proposed');\n        require(!proposal.flags[0], \"proposal has already been sponsored\");\n        require(!proposal.flags[3], \"proposal has been cancelled\");\n        require(members[proposal.applicant].jailed == 0, \"proposal applicant must not be jailed\");\n\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0) {\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, 'cannot sponsor more tribute proposals for new tokens - guildbank is full');\n        }\n\n        // whitelist proposal\n        if (proposal.flags[4]) {\n            require(!tokenWhitelist[address(proposal.tributeToken)], \"cannot already have whitelisted the token\");\n            require(!proposedToWhitelist[address(proposal.tributeToken)], 'already proposed to whitelist');\n            require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"cannot sponsor more whitelist proposals\");\n            proposedToWhitelist[address(proposal.tributeToken)] = true;\n\n        // guild kick proposal\n        } else if (proposal.flags[5]) {\n            require(!proposedToKick[proposal.applicant], 'already proposed to kick');\n            proposedToKick[proposal.applicant] = true;\n        }\n\n        // compute startingPeriod for proposal\n        uint256 startingPeriod = max(\n            getCurrentPeriod(),\n            proposalQueue.length == 0 ? 0 : proposals[proposalQueue[proposalQueue.length.sub(1)]].startingPeriod\n        ).add(1);\n\n        proposal.startingPeriod = startingPeriod;\n\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\n        proposal.sponsor = memberAddress;\n\n        proposal.flags[0] = true; // sponsored\n\n        // append proposal to the queue\n        proposalQueue.push(proposalId);\n        \n        emit SponsorProposal(msg.sender, memberAddress, proposalId, proposalQueue.length.sub(1), startingPeriod);\n    }\n\n    // NOTE: In MolochV2 proposalIndex !== proposalId\n    function submitVote(uint256 proposalIndex, uint8 uintVote) public nonReentrant onlyDelegate {\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\n        Member storage member = members[memberAddress];\n\n        require(proposalIndex < proposalQueue.length, \"proposal does not exist\");\n        Proposal storage proposal = proposals[proposalQueue[proposalIndex]];\n\n        require(uintVote < 3, \"must be less than 3\");\n        Vote vote = Vote(uintVote);\n\n        require(getCurrentPeriod() >= proposal.startingPeriod, \"voting period has not started\");\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \"proposal voting period has expired\");\n        require(proposal.votesByMember[memberAddress] == Vote.Null, \"member has already voted\");\n        require(vote == Vote.Yes || vote == Vote.No, \"vote must be either Yes or No\");\n\n        proposal.votesByMember[memberAddress] = vote;\n\n        if (vote == Vote.Yes) {\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\n\n            // set highest index (latest) yes vote - must be processed for member to ragequit\n            if (proposalIndex > member.highestIndexYesVote) {\n                member.highestIndexYesVote = proposalIndex;\n            }\n\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\n            if (totalShares.add(totalLoot) > proposal.maxTotalSharesAndLootAtYesVote) {\n                proposal.maxTotalSharesAndLootAtYesVote = totalShares.add(totalLoot);\n            }\n\n        } else if (vote == Vote.No) {\n            proposal.noVotes = proposal.noVotes.add(member.shares);\n        }\n     \n        // NOTE: subgraph indexes by proposalId not proposalIndex since proposalIndex isn't set untill it's been sponsored but proposal is created on submission\n        emit SubmitVote(proposalQueue[proposalIndex], proposalIndex, msg.sender, memberAddress, uintVote);\n    }\n\n    function processProposal(uint256 proposalIndex) public nonReentrant {\n        _validateProposalForProcessing(proposalIndex);\n\n        uint256 proposalId = proposalQueue[proposalIndex];\n        Proposal storage proposal = proposals[proposalId];\n\n        require(!proposal.flags[4] && !proposal.flags[5], \"must be a standard proposal\");\n\n        proposal.flags[1] = true; // processed\n\n        bool didPass = _didPass(proposalIndex);\n\n        // Make the proposal fail if the new total number of shares and loot exceeds the limit\n        if (totalShares.add(totalLoot).add(proposal.sharesRequested).add(proposal.lootRequested) > MAX_NUMBER_OF_SHARES_AND_LOOT) {\n            didPass = false;\n        }\n\n        // Make the proposal fail if it is requesting more tokens as payment than the available guild bank balance\n        if (proposal.paymentRequested > userTokenBalances[GUILD][proposal.paymentToken]) {\n            didPass = false;\n        }\n\n        // Make the proposal fail if it would result in too many tokens with non-zero balance in guild bank\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0 && totalGuildBankTokens >= MAX_TOKEN_GUILDBANK_COUNT) {\n           didPass = false;\n        }\n\n        // PROPOSAL PASSED\n        if (didPass) {\n            proposal.flags[2] = true; // didPass\n\n            // if the applicant is already a member, add to their existing shares & loot\n            if (members[proposal.applicant].exists) {\n                members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\n                members[proposal.applicant].loot = members[proposal.applicant].loot.add(proposal.lootRequested);\n\n            // the applicant is a new member, create a new record for them\n            } else {\n                // if the applicant address is already taken by a member's delegateKey, reset it to their member address\n                if (members[memberAddressByDelegateKey[proposal.applicant]].exists) {\n                    address memberToOverride = memberAddressByDelegateKey[proposal.applicant];\n                    memberAddressByDelegateKey[memberToOverride] = memberToOverride;\n                    members[memberToOverride].delegateKey = memberToOverride;\n                }\n\n                // use applicant address as delegateKey by default\n                members[proposal.applicant] = Member(proposal.applicant, proposal.sharesRequested, proposal.lootRequested, true, 0, 0);\n                memberAddressByDelegateKey[proposal.applicant] = proposal.applicant;\n            }\n\n            // mint new shares & loot\n            totalShares = totalShares.add(proposal.sharesRequested);\n            totalLoot = totalLoot.add(proposal.lootRequested);\n\n            // if the proposal tribute is the first tokens of its kind to make it into the guild bank, increment total guild bank tokens\n            if (userTokenBalances[GUILD][proposal.tributeToken] == 0 && proposal.tributeOffered > 0) {\n                totalGuildBankTokens += 1;\n            }\n\n            unsafeInternalTransfer(ESCROW, GUILD, proposal.tributeToken, proposal.tributeOffered);\n            unsafeInternalTransfer(GUILD, proposal.applicant, proposal.paymentToken, proposal.paymentRequested);\n\n            // if the proposal spends 100% of guild bank balance for a token, decrement total guild bank tokens\n            if (userTokenBalances[GUILD][proposal.paymentToken] == 0 && proposal.paymentRequested > 0) {\n                totalGuildBankTokens -= 1;\n            }\n\n        // PROPOSAL FAILED\n        } else {\n            // return all tokens to the proposer (not the applicant, because funds come from proposer)\n            unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\n        }\n\n        _returnDeposit(proposal.sponsor);\n\n        emit ProcessProposal(proposalIndex, proposalId, didPass);\n    }\n\n    function processWhitelistProposal(uint256 proposalIndex) public nonReentrant {\n        _validateProposalForProcessing(proposalIndex);\n\n        uint256 proposalId = proposalQueue[proposalIndex];\n        Proposal storage proposal = proposals[proposalId];\n\n        require(proposal.flags[4], \"must be a whitelist proposal\");\n\n        proposal.flags[1] = true; // processed\n\n        bool didPass = _didPass(proposalIndex);\n\n        if (approvedTokens.length >= MAX_TOKEN_WHITELIST_COUNT) {\n            didPass = false;\n        }\n\n        if (didPass) {\n            proposal.flags[2] = true; // didPass\n\n            tokenWhitelist[address(proposal.tributeToken)] = true;\n            approvedTokens.push(proposal.tributeToken);\n        }\n\n        proposedToWhitelist[address(proposal.tributeToken)] = false;\n\n        _returnDeposit(proposal.sponsor);\n\n        emit ProcessWhitelistProposal(proposalIndex, proposalId, didPass);\n    }\n\n    function processGuildKickProposal(uint256 proposalIndex) public nonReentrant {\n        _validateProposalForProcessing(proposalIndex);\n\n        uint256 proposalId = proposalQueue[proposalIndex];\n        Proposal storage proposal = proposals[proposalId];\n\n        require(proposal.flags[5], \"must be a guild kick proposal\");\n\n        proposal.flags[1] = true; // processed\n\n        bool didPass = _didPass(proposalIndex);\n\n        if (didPass) {\n            proposal.flags[2] = true; // didPass\n            Member storage member = members[proposal.applicant];\n            member.jailed = proposalIndex;\n\n            // transfer shares to loot\n            member.loot = member.loot.add(member.shares);\n            totalShares = totalShares.sub(member.shares);\n            totalLoot = totalLoot.add(member.shares);\n            member.shares = 0; // revoke all shares\n        }\n\n        proposedToKick[proposal.applicant] = false;\n\n        _returnDeposit(proposal.sponsor);\n\n        emit ProcessGuildKickProposal(proposalIndex, proposalId, didPass);\n    }\n\n    function _didPass(uint256 proposalIndex) internal view returns  (bool didPass) {\n        Proposal storage proposal = proposals[proposalQueue[proposalIndex]];\n\n        didPass = proposal.yesVotes > proposal.noVotes;\n\n        // Make the proposal fail if the dilutionBound is exceeded\n        if ((totalShares.add(totalLoot)).mul(dilutionBound) < proposal.maxTotalSharesAndLootAtYesVote) {\n            didPass = false;\n        }\n\n        // Make the proposal fail if the applicant is jailed\n        // - for standard proposals, we don't want the applicant to get any shares/loot/payment\n        // - for guild kick proposals, we should never be able to propose to kick a jailed member (or have two kick proposals active), so it doesn't matter\n        if (members[proposal.applicant].jailed != 0) {\n            didPass = false;\n        }\n\n        return didPass;\n    }\n\n    function _validateProposalForProcessing(uint256 proposalIndex) internal view {\n        require(proposalIndex < proposalQueue.length, \"proposal does not exist\");\n        Proposal storage proposal = proposals[proposalQueue[proposalIndex]];\n\n        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"proposal is not ready to be processed\");\n        require(proposal.flags[1] == false, \"proposal has already been processed\");\n        require(proposalIndex == 0 || proposals[proposalQueue[proposalIndex.sub(1)]].flags[1], \"previous proposal must be processed\");\n    }\n\n    function _returnDeposit(address sponsor) internal {\n        unsafeInternalTransfer(ESCROW, msg.sender, depositToken, processingReward);\n        unsafeInternalTransfer(ESCROW, sponsor, depositToken, proposalDeposit.sub(processingReward));\n    }\n\n    function ragequit(uint256 sharesToBurn, uint256 lootToBurn) public nonReentrant onlyMember {\n        _ragequit(msg.sender, sharesToBurn, lootToBurn);\n    }\n\n    function _ragequit(address memberAddress, uint256 sharesToBurn, uint256 lootToBurn) internal {\n        uint256 initialTotalSharesAndLoot = totalShares.add(totalLoot);\n\n        Member storage member = members[memberAddress];\n\n        require(member.shares >= sharesToBurn, \"insufficient shares\");\n        require(member.loot >= lootToBurn, \"insufficient loot\");\n\n        require(canRagequit(member.highestIndexYesVote), \"cannot ragequit until highest index proposal member voted YES on is processed\");\n\n        uint256 sharesAndLootToBurn = sharesToBurn.add(lootToBurn);\n\n        // burn shares and loot\n        member.shares = member.shares.sub(sharesToBurn);\n        member.loot = member.loot.sub(lootToBurn);\n        totalShares = totalShares.sub(sharesToBurn);\n        totalLoot = totalLoot.sub(lootToBurn);\n\n        for (uint256 i = 0; i < approvedTokens.length; i++) {\n            uint256 amountToRagequit = fairShare(userTokenBalances[GUILD][approvedTokens[i]], sharesAndLootToBurn, initialTotalSharesAndLoot);\n            if (amountToRagequit > 0) { // gas optimization to allow a higher maximum token limit\n                // deliberately not using safemath here to keep overflows from preventing the function execution (which would break ragekicks)\n                // if a token overflows, it is because the supply was artificially inflated to oblivion, so we probably don't care about it anyways\n                userTokenBalances[GUILD][approvedTokens[i]] -= amountToRagequit;\n                userTokenBalances[memberAddress][approvedTokens[i]] += amountToRagequit;\n            }\n        }\n\n        emit Ragequit(msg.sender, sharesToBurn, lootToBurn);\n    }\n\n    function ragekick(address memberToKick) public nonReentrant {\n        Member storage member = members[memberToKick];\n\n        require(member.jailed != 0, \"member must be in jail\");\n        require(member.loot > 0, \"member must have some loot\"); // note - should be impossible for jailed member to have shares\n        require(canRagequit(member.highestIndexYesVote), \"cannot ragequit until highest index proposal member voted YES on is processed\");\n\n        _ragequit(memberToKick, 0, member.loot);\n    }\n\n    function withdrawBalance(address token, uint256 amount) public nonReentrant {\n        _withdrawBalance(token, amount);\n    }\n\n    function withdrawBalances(address[] memory tokens, uint256[] memory amounts, bool max) public nonReentrant {\n        require(tokens.length == amounts.length, \"tokens and amounts arrays must be matching lengths\");\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 withdrawAmount = amounts[i];\n            if (max) { // withdraw the maximum balance\n                withdrawAmount = userTokenBalances[msg.sender][tokens[i]];\n            }\n\n            _withdrawBalance(tokens[i], withdrawAmount);\n        }\n    }\n    \n    function _withdrawBalance(address token, uint256 amount) internal {\n        require(userTokenBalances[msg.sender][token] >= amount, \"insufficient balance\");\n        unsafeSubtractFromBalance(msg.sender, token, amount);\n        require(IERC20(token).transfer(msg.sender, amount), \"transfer failed\");\n        emit Withdraw(msg.sender, token, amount);\n    }\n\n    function collectTokens(address token) public onlyDelegate nonReentrant {\n        uint256 amountToCollect = IERC20(token).balanceOf(address(this)).sub(userTokenBalances[TOTAL][token]);\n        // only collect if 1) there are tokens to collect 2) token is whitelisted 3) token has non-zero balance\n        require(amountToCollect > 0, 'no tokens to collect');\n        require(tokenWhitelist[token], 'token to collect must be whitelisted');\n        require(userTokenBalances[GUILD][token] > 0, 'token to collect must have non-zero guild bank balance');\n        \n        unsafeAddToBalance(GUILD, token, amountToCollect);\n        emit TokensCollected(token, amountToCollect);\n    }\n\n    // NOTE: requires that delegate key which sent the original proposal cancels, msg.sender == proposal.proposer\n    function cancelProposal(uint256 proposalId) public nonReentrant {\n        Proposal storage proposal = proposals[proposalId];\n        require(!proposal.flags[0], \"proposal has already been sponsored\");\n        require(!proposal.flags[3], \"proposal has already been cancelled\");\n        require(msg.sender == proposal.proposer, \"solely the proposer can cancel\");\n\n        proposal.flags[3] = true; // cancelled\n        \n        unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\n        emit CancelProposal(proposalId, msg.sender);\n    }\n\n    function updateDelegateKey(address newDelegateKey) public nonReentrant onlyShareholder {\n        require(newDelegateKey != address(0), \"newDelegateKey cannot be 0\");\n\n        // skip checks if member is setting the delegate key to their member address\n        if (newDelegateKey != msg.sender) {\n            require(!members[newDelegateKey].exists, \"cannot overwrite existing members\");\n            require(!members[memberAddressByDelegateKey[newDelegateKey]].exists, \"cannot overwrite existing delegate keys\");\n        }\n\n        Member storage member = members[msg.sender];\n        memberAddressByDelegateKey[member.delegateKey] = address(0);\n        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\n        member.delegateKey = newDelegateKey;\n\n        emit UpdateDelegateKey(msg.sender, newDelegateKey);\n    }\n\n    // can only ragequit if the latest proposal you voted YES on has been processed\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {\n        require(highestIndexYesVote < proposalQueue.length, \"proposal does not exist\");\n        return proposals[proposalQueue[highestIndexYesVote]].flags[1];\n    }\n\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\n    }\n\n    /***************\n    GETTER FUNCTIONS\n    ***************/\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x >= y ? x : y;\n    }\n\n    function getCurrentPeriod() public view returns (uint256) {\n        return block.timestamp.sub(summoningTime).div(periodDuration);\n    }\n\n    function getProposalQueueLength() public view returns (uint256) {\n        return proposalQueue.length;\n    }\n\n    function getProposalFlags(uint256 proposalId) public view returns (bool[6] memory) {\n        return proposals[proposalId].flags;\n    }\n\n    function getUserTokenBalance(address user, address token) public view returns (uint256) {\n        return userTokenBalances[user][token];\n    }\n\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) public view returns (Vote) {\n        require(members[memberAddress].exists, \"member does not exist\");\n        require(proposalIndex < proposalQueue.length, \"proposal does not exist\");\n        return proposals[proposalQueue[proposalIndex]].votesByMember[memberAddress];\n    }\n\n    function getTokenCount() public view returns (uint256) {\n        return approvedTokens.length;\n    }\n\n    /***************\n    HELPER FUNCTIONS\n    ***************/\n    function unsafeAddToBalance(address user, address token, uint256 amount) internal {\n        userTokenBalances[user][token] += amount;\n        userTokenBalances[TOTAL][token] += amount;\n    }\n\n    function unsafeSubtractFromBalance(address user, address token, uint256 amount) internal {\n        userTokenBalances[user][token] -= amount;\n        userTokenBalances[TOTAL][token] -= amount;\n    }\n\n    function unsafeInternalTransfer(address from, address to, address token, uint256 amount) internal {\n        unsafeSubtractFromBalance(from, token, amount);\n        unsafeAddToBalance(to, token, amount);\n    }\n\n    function fairShare(uint256 balance, uint256 shares, uint256 _totalShares) internal pure returns (uint256) {\n        require(_totalShares != 0);\n\n        if (balance == 0) { return 0; }\n\n        uint256 prod = balance * shares;\n\n        if (prod / balance == shares) { // no overflow in multiplication above?\n            return prod / _totalShares;\n        }\n\n        return (balance / _totalShares) * shares;\n    }\n}\n\ncontract EasyApply is Ownable {\n   using SafeMath for uint256;\n    LAO public lao;\n    WETH public weth;\n    uint256 public CHUNK_SIZE;\n    uint256 public SHARES_PER_CHUNK;\n    mapping(uint256 => bool) public processed;\n\n    modifier onlyMember {\n        address laoMember = msg.sender;\n        (, uint256 shares, , bool exists, , uint256 jailed) = lao.members(laoMember);\n        if(!exists) {\n            laoMember = lao.memberAddressByDelegateKey(msg.sender);\n            (, uint256 shares2, , bool exists2, , uint256 jailed2) = lao.members(laoMember);\n             \n            require(exists2 && shares2 > 0 && jailed2 == 0, \"sender is not allowed to sponsor a proposal\");\n        } else {\n            require(shares > 0 && jailed == 0, \"sender is not allowed to sponsor a proposal\");\n        }\n        \n        _;\n    }\n\n    constructor (address _lao, address payable _weth, uint256 _CHUNK_SIZE, uint256 _SHARES_PER_CHUNK) {\n        lao = LAO(_lao);\n        weth = WETH(_weth);\n        CHUNK_SIZE = _CHUNK_SIZE;\n        SHARES_PER_CHUNK = _SHARES_PER_CHUNK;\n    }\n\n    function setContributionParams(uint _chunkSize, uint256 _sharesPerChunk) external onlyOwner {\n        CHUNK_SIZE = _chunkSize;\n        SHARES_PER_CHUNK = _sharesPerChunk;\n    }\n    \n    function adminExecute (bytes calldata data, uint256 value) external onlyOwner returns (bool, bytes memory) {\n        return address(this).call{value:value}(data);\n    }\n    \n    receive() external payable {\n        //if we get ETH from WETH, just take it (since it is not an investment)\n        if(msg.sender != address(weth)) {\n            uint256 numberOfChunks = msg.value.div(CHUNK_SIZE);\n            require(numberOfChunks > 0, \"amount of ETH sent was not sufficient\");\n            uint256 amount = numberOfChunks.mul(CHUNK_SIZE);\n            uint256 sharesRequested = numberOfChunks.mul(SHARES_PER_CHUNK);\n            weth.deposit{value: amount}();\n            require(weth.approve(address(lao), amount), \"approval failed\");\n\n            _submitMembershipProposalLAO(msg.sender, sharesRequested, amount);\n\n            if(msg.value > amount) {\n                msg.sender.transfer(msg.value - amount);\n            }\n        }\n    }\n\n    function becomeMember() onlyOwner external {\n        _submitMembershipProposalLAO(address(this), 1, 0); //create a membership proposal in the LAO for 1 share in exchange to 0 WETH\n    }\n\n    function submitAndSponsorProjectProposal(uint256 payment, address applicant, string calldata details) onlyMember external {\n        uint256 proposalId = lao.submitProposal(\n             applicant,\n             0,\n             0, //hardcode loot request\n             0,\n             address(weth), //hardcode to WETH address\n             payment, //hardcode paymentRequested\n             address(weth),\n             details\n        );\n\n        lao.sponsorProposal(proposalId);\n    }\n\n    function  _submitMembershipProposalLAO (\n        address applicant,\n        uint256 sharesRequested,\n        uint256 tributeOffered) internal {\n        lao.submitProposal(\n             applicant,\n             sharesRequested,\n             0, //hardcode loot request\n             tributeOffered,\n             address(weth), //hardcode to WETH address\n             0, //hardcode paymentRequested\n             address(weth),\n             \"Membership\"\n        );\n    }\n\n    function cancelLaoProposal (uint256 _proposalId) external {\n        (address applicant, , , , ,uint256 tributeOffered , , , , , , , , ) = lao.proposals(_proposalId);\n        require(msg.sender == applicant, \"only the applicant can cancel a proposal\");\n        lao.cancelProposal(_proposalId);\n        lao.withdrawBalance(address(weth), tributeOffered);\n        weth.withdraw(tributeOffered);\n        msg.sender.transfer(tributeOffered);\n    }\n\n    function withdrawFromFailedProposal(uint256 _proposalId) external {\n        require(processed[_proposalId] == false, \"proposal was already processed\");\n        (address applicant, , , , ,uint256 tributeOffered , , , , , , , , ) = lao.proposals(_proposalId);\n        require(msg.sender == applicant, \"only the applicant can withdraw from his failed proposal\");\n        lao.withdrawBalance(address(weth), tributeOffered);\n        weth.withdraw(tributeOffered);\n        msg.sender.transfer(tributeOffered);\n        processed[_proposalId] = true;\n    }\n}"
    }
  }
}