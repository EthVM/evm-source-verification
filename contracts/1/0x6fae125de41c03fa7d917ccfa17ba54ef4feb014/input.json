{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"AddressProvider.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\n\n// \ninterface IVaultsCore {\n  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);\n  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Liquidated(\n    uint256 indexed vaultId,\n    uint256 debtRepaid,\n    uint256 collateralLiquidated,\n    address indexed owner,\n    address indexed sender\n  );\n\n  event CumulativeRateUpdated(\n    address indexed collateralType,\n    uint256 elapsedTime,\n    uint256 newCumulativeRate\n  ); //cumulative interest rate from deployment time T0\n\n  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);\n\n  function a() external view returns (IAddressProvider);\n\n  function deposit(address _collateralType, uint256 _amount) external;\n\n  function withdraw(uint256 _vaultId, uint256 _amount) external;\n\n  function withdrawAll(uint256 _vaultId) external;\n\n  function borrow(uint256 _vaultId, uint256 _amount) external;\n\n  function repayAll(uint256 _vaultId) external;\n\n  function repay(uint256 _vaultId, uint256 _amount) external;\n\n  function liquidate(uint256 _vaultId) external;\n\n  //Read only\n\n  function availableIncome() external view returns (uint256);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n\n  function lastRefresh(address _collateralType) external view returns (uint256);\n\n  //Refresh\n  function initializeRates(address _collateralType) external;\n\n  function refresh() external;\n\n  function refreshCollateral(address collateralType) external;\n\n  //upgrade\n  function upgrade(address _newVaultsCore) external;\n}\n\n// \ninterface IAccessController {\n  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n  function MANAGER_ROLE() external view returns (bytes32);\n\n  function MINTER_ROLE() external view returns (bytes32);\n\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n  function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  function grantRole(bytes32 role, address account) external;\n\n  function revokeRole(bytes32 role, address account) external;\n\n  function renounceRole(bytes32 role, address account) external;\n}\n\n// \ninterface IConfigProvider {\n  struct CollateralConfig {\n    address collateralType;\n    uint256 debtLimit;\n    uint256 minCollateralRatio;\n    uint256 borrowRate;\n    uint256 originationFee;\n  }\n\n  function a() external view returns (IAddressProvider);\n\n  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);\n\n  function collateralIds(address _collateralType) external view returns (uint256);\n\n  function numCollateralConfigs() external view returns (uint256);\n\n  function liquidationBonus() external view returns (uint256);\n\n  event CollateralUpdated(\n    address indexed collateralType,\n    uint256 debtLimit,\n    uint256 minCollateralRatio,\n    uint256 borrowRate,\n    uint256 originationFee\n  );\n  event CollateralRemoved(address indexed collateralType);\n\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee\n  ) external;\n\n  function removeCollateral(address _collateralType) external;\n\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;\n\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;\n\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;\n\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;\n\n  function setLiquidationBonus(uint256 _bonus) external;\n\n  function collateralDebtLimit(address _collateralType) external view returns (uint256);\n\n  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);\n\n  function collateralBorrowRate(address _collateralType) external view returns (uint256);\n\n  function collateralOriginationFee(address _collateralType) external view returns (uint256);\n}\n\n// \n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// \ninterface ISTABLEX is IERC20 {\n  function a() external view returns (IAddressProvider);\n\n  function mint(address account, uint256 amount) external;\n\n  function burn(address account, uint256 amount) external;\n}\n\n// \ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n\n// \ninterface IPriceFeed {\n  event OracleUpdated(address indexed asset, address oracle);\n\n  function a() external view returns (IAddressProvider);\n\n  function setAssetOracle(address _asset, address _oracle) external;\n\n  function assetOracles(address _asset) external view returns (AggregatorV3Interface);\n\n  function getAssetPrice(address _asset) external view returns (uint256);\n\n  function convertFrom(address _asset, uint256 _balance) external view returns (uint256);\n\n  function convertTo(address _asset, uint256 _balance) external view returns (uint256);\n}\n\n// \ninterface IRatesManager {\n  function a() external view returns (IAddressProvider);\n\n  //current annualized borrow rate\n  function annualizedBorrowRate(uint256 _currentBorrowRate) external pure returns (uint256);\n\n  //uses current cumulative rate to calculate totalDebt based on baseDebt at time T0\n  function calculateDebt(uint256 _baseDebt, uint256 _cumulativeRate) external pure returns (uint256);\n\n  //uses current cumulative rate to calculate baseDebt at time T0\n  function calculateBaseDebt(uint256 _debt, uint256 _cumulativeRate) external pure returns (uint256);\n\n  //calculate a new cumulative rate\n  function calculateCumulativeRate(\n    uint256 _borrowRate,\n    uint256 _cumulativeRate,\n    uint256 _timeElapsed\n  ) external view returns (uint256);\n}\n\n// \ninterface ILiquidationManager {\n  function a() external view returns (IAddressProvider);\n\n  function calculateHealthFactor(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) external view returns (uint256 healthFactor);\n\n  function liquidationBonus(uint256 _amount) external view returns (uint256 bonus);\n\n  function applyLiquidationDiscount(uint256 _amount) external view returns (uint256 discountedAmount);\n\n  function isHealthy(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) external view returns (bool);\n}\n\n// \ninterface IVaultsDataProvider {\n  struct Vault {\n    // borrowedType support USDX / PAR\n    address collateralType;\n    address owner;\n    uint256 collateralBalance;\n    uint256 baseDebt;\n    uint256 createdAt;\n  }\n\n  function a() external view returns (IAddressProvider);\n\n  // Read\n  function baseDebt(address _collateralType) external view returns (uint256);\n\n  function vaultCount() external view returns (uint256);\n\n  function vaults(uint256 _id) external view returns (Vault memory);\n\n  function vaultOwner(uint256 _id) external view returns (address);\n\n  function vaultCollateralType(uint256 _id) external view returns (address);\n\n  function vaultCollateralBalance(uint256 _id) external view returns (uint256);\n\n  function vaultBaseDebt(uint256 _id) external view returns (uint256);\n\n  function vaultId(address _collateralType, address _owner) external view returns (uint256);\n\n  function vaultExists(uint256 _id) external view returns (bool);\n\n  function vaultDebt(uint256 _vaultId) external view returns (uint256);\n\n  function debt() external view returns (uint256);\n\n  function collateralDebt(address _collateralType) external view returns (uint256);\n\n  //Write\n  function createVault(address _collateralType, address _owner) external returns (uint256);\n\n  function setCollateralBalance(uint256 _id, uint256 _balance) external;\n\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;\n}\n\n// \ninterface IFeeDistributor {\n  event PayeeAdded(address indexed account, uint256 shares);\n  event FeeReleased(uint256 income, uint256 releasedAt);\n\n  function a() external view returns (IAddressProvider);\n\n  function lastReleasedAt() external view returns (uint256);\n\n  function getPayees() external view returns (address[] memory);\n\n  function totalShares() external view returns (uint256);\n\n  function shares(address payee) external view returns (uint256);\n\n  function release() external;\n\n  function changePayees(address[] memory _payees, uint256[] memory _shares) external;\n}\n\n// \ninterface IAddressProvider {\n  function controller() external view returns (IAccessController);\n\n  function config() external view returns (IConfigProvider);\n\n  function core() external view returns (IVaultsCore);\n\n  function stablex() external view returns (ISTABLEX);\n\n  function ratesManager() external view returns (IRatesManager);\n\n  function priceFeed() external view returns (IPriceFeed);\n\n  function liquidationManager() external view returns (ILiquidationManager);\n\n  function vaultsData() external view returns (IVaultsDataProvider);\n\n  function feeDistributor() external view returns (IFeeDistributor);\n\n  function setAccessController(IAccessController _controller) external;\n\n  function setConfigProvider(IConfigProvider _config) external;\n\n  function setVaultsCore(IVaultsCore _core) external;\n\n  function setStableX(ISTABLEX _stablex) external;\n\n  function setRatesManager(IRatesManager _ratesManager) external;\n\n  function setPriceFeed(IPriceFeed _priceFeed) external;\n\n  function setLiquidationManager(ILiquidationManager _liquidationManager) external;\n\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;\n\n  function setFeeDistributor(IFeeDistributor _feeDistributor) external;\n}\n\n// \ncontract AddressProvider is IAddressProvider {\n  IAccessController public override controller;\n  IConfigProvider public override config;\n  IVaultsCore public override core;\n\n  ISTABLEX public override stablex;\n  IRatesManager public override ratesManager;\n  IPriceFeed public override priceFeed;\n  ILiquidationManager public override liquidationManager;\n  IVaultsDataProvider public override vaultsData;\n  IFeeDistributor public override feeDistributor;\n\n  constructor(IAccessController _controller) public {\n    controller = _controller;\n  }\n\n  modifier onlyManager() {\n    require(controller.hasRole(controller.MANAGER_ROLE(), msg.sender), \"Caller is not a Manager\");\n    _;\n  }\n\n  function setAccessController(IAccessController _controller) public override onlyManager {\n    require(address(_controller) != address(0));\n    controller = _controller;\n  }\n\n  function setConfigProvider(IConfigProvider _config) public override onlyManager {\n    require(address(_config) != address(0));\n    config = _config;\n  }\n\n  function setVaultsCore(IVaultsCore _core) public override onlyManager {\n    require(address(_core) != address(0));\n    core = _core;\n  }\n\n  function setStableX(ISTABLEX _stablex) public override onlyManager {\n    require(address(_stablex) != address(0));\n    stablex = _stablex;\n  }\n\n  function setRatesManager(IRatesManager _ratesManager) public override onlyManager {\n    require(address(_ratesManager) != address(0));\n    ratesManager = _ratesManager;\n  }\n\n  function setLiquidationManager(ILiquidationManager _liquidationManager) public override onlyManager {\n    require(address(_liquidationManager) != address(0));\n    liquidationManager = _liquidationManager;\n  }\n\n  function setPriceFeed(IPriceFeed _priceFeed) public override onlyManager {\n    require(address(_priceFeed) != address(0));\n    priceFeed = _priceFeed;\n  }\n\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) public override onlyManager {\n    require(address(_vaultsData) != address(0));\n    vaultsData = _vaultsData;\n  }\n\n  function setFeeDistributor(IFeeDistributor _feeDistributor) public override onlyManager {\n    require(address(_feeDistributor) != address(0));\n    feeDistributor = _feeDistributor;\n  }\n}"}}}