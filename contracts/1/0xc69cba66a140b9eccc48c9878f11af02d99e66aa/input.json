{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"YZHETH.sol":{"content":"pragma solidity 0.5.14;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    function transfer(address to, uint256 value) public returns(bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract YZHETH is ERC20 {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    \r\n    address public owner;\r\n    address public mlmAddress;\r\n    \r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n    mapping (bytes32 => bool) private hashConfirmation;\r\n    \r\n    \r\n    // defi governance in Eth\r\n    \r\n    /// @notice A record of each accounts delegate\r\n    mapping (address => address) internal _delegates;\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint256 votes;\r\n    }\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping (address => uint32) public numCheckpoints;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping (address => uint) public nonces;\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance); \r\n    \r\n    \r\n    constructor () public {\r\n        symbol = \"YZHETH\";\r\n        name = \"YZHE\";\r\n        decimals = 18;\r\n        owner = msg.sender;\r\n      \r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Check balance of the holder\r\n     * @param _owner Token holder address\r\n     */ \r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to specified address\r\n     * @param _to Receiver address\r\n     * @param _value Amount of the tokens\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0), \"Invalid address\");\r\n        require(_value <= balances[msg.sender], \"Insufficient balance\");\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        _moveDelegates(_delegates[msg.sender], _delegates[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from  The holder address\r\n     * @param _to  The Receiver address\r\n     * @param _value  the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_from != address(0), \"Invalid from address\");\r\n        require(_to != address(0), \"Invalid to address\");\r\n        require(_value <= balances[_from], \"Invalid balance\");\r\n        require(_value <= allowed[_from][msg.sender], \"Invalid allowance\");\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[msg.sender] = balances[msg.sender].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        _moveDelegates(_delegates[_from], _delegates[_to], _value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Approve respective tokens for spender\r\n     * @param _spender Spender address\r\n     * @param _value Amount of tokens to be allowed\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require(_spender != address(0), \"Null address\");\r\n        require(_value > 0, \"Invalid value\");\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev To view approved balance\r\n     * @param _owner Holder address\r\n     * @param _spender Spender address\r\n     */ \r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }  \r\n    \r\n    /**\r\n     * @param _newOwner New owner address\r\n     */ \r\n    function changeowner(address _newOwner) public onlyOwner returns(bool) {\r\n        require(_newOwner != address(0), \"Invalid Address\");\r\n        owner = _newOwner;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @param _newmlm new mlm address\r\n     */\r\n   \r\n    function changemlm(address _newmlm) public onlyOwner returns(bool) {\r\n        require(_newmlm != address(0), \"Invalid Address\");\r\n        mlmAddress = _newmlm;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev To mint YZHE Tokens\r\n     * @param _receiver Reciever address\r\n     * @param _amount Amount to mint\r\n    \r\n     */ \r\n    function mint(address _receiver, uint256 _amount) public returns (bool) {\r\n        require(_receiver != address(0), \"Invalid address\");\r\n        require(_amount >= 0, \"Invalid amount\");\r\n        require(mlmAddress == msg.sender, \"Only mlm\");\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_receiver] = balances[_receiver].add(_amount);\r\n        _moveDelegates(address(0), _delegates[_receiver], _amount);\r\n        emit Transfer(address(0), _receiver, _amount);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev To mint YZHE Tokens\r\n     * @param _receiver Reciever address\r\n     * @param _amount Amount to mint\r\n     */ \r\n    function ownerMint(address _receiver, uint256 _amount) public onlyOwner returns (bool) {\r\n        require(_receiver != address(0), \"Invalid address\");\r\n        require(_amount >= 0, \"Invalid amount\");\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_receiver] = balances[_receiver].add(_amount);\r\n        _moveDelegates(address(0), _delegates[_receiver], _amount);\r\n        emit Transfer(address(0), _receiver, _amount);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @notice Delegate votes from `msg.sender` to `delegatee`\r\n     * @param delegator The address to get delegatee for\r\n     */\r\n    function delegates(address delegator) external view returns (address)\r\n    {\r\n        return _delegates[delegator];\r\n    }\r\n\r\n    /**\r\n    * @notice Delegate votes from `msg.sender` to `delegatee`\r\n    * @param delegatee The address to delegate votes to\r\n    */\r\n    function delegate(address delegatee) external {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates votes from signatory to `delegatee`\r\n     * @param delegatee The address to delegate votes to\r\n     * @param nonce The contract state required to match the signature\r\n     * @param expiry The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function delegateBySig( address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s ) external  {\r\n        \r\n        bytes32 domainSeparator = keccak256(\r\n            abi.encode(\r\n                DOMAIN_TYPEHASH,\r\n                keccak256(bytes(name)),\r\n                getChainId(),\r\n                address(this)\r\n            )\r\n        );\r\n\r\n        bytes32 structHash = keccak256(\r\n            abi.encode(\r\n                DELEGATION_TYPEHASH,\r\n                delegatee,\r\n                nonce,\r\n                expiry\r\n            )\r\n        );\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                domainSeparator,\r\n                structHash\r\n            )\r\n        );\r\n\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"YZHE::delegateBySig: invalid signature\");\r\n        require(nonce == nonces[signatory]++, \"YZHE::delegateBySig: invalid nonce\");\r\n        require(now <= expiry, \"YZHE::delegateBySig: signature expired\");\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current votes balance for `account`\r\n     * @param account The address to get votes balance\r\n     * @return The number of current votes for `account`\r\n     */\r\n    function getCurrentVotes(address account) external view returns (uint256) {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine the prior number of votes for an account as of a block number\r\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\r\n     * @param account The address of the account to check\r\n     * @param blockNumber The block number to get the vote balance at\r\n     * @return The number of votes the account had as of the given block\r\n     */\r\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint256)   {\r\n        \r\n        require(blockNumber < block.number, \"YZHE::getPriorVotes: not yet determined\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // First check most recent balance\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        // Next check implicit zero balance\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee) internal {\r\n        address currentDelegate = _delegates[delegator];\r\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying YZHE (not scaled);\r\n        _delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                // decrease old representative\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint256 srcRepNew = srcRepOld.sub(amount);\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                // increase new representative\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint256 dstRepNew = dstRepOld.add(amount);\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint256 oldVotes, uint256 newVotes) internal {\r\n        uint32 blockNumber = safe32(block.number, \"YZHE::_writeCheckpoint: block number exceeds 32 bits\");\r\n\r\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n        } else {\r\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n            numCheckpoints[delegatee] = nCheckpoints + 1;\r\n        }\r\n\r\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n}"}}}