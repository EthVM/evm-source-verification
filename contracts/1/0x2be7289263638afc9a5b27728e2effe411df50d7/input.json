{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":40},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"},"contracts/Timelock.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n  Timelock contract.\n  Fixed token payout and timing.\n  Can add recipients and multiple grants per recipient.\n\n  @author iain\n  github.com/iainnash/simple-timelock\n */\ncontract Timelock {\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n    /**\n        Error codes lookup:\n        1: Recover and recieve grant days need to be greater than 0\n        2: Grant not valid.\n        3: Only owner can add grants.\n        4: Only owner can recover\n        5: Cannot set the recovery grant before the unlock time\n        6: Too early to recover\n        7: Too early to claim\n        8: Recover timestamp needs to be after receive timestamp\n        9: Already granted\n        10: Cannot grant after unlock\n        11: Token not approved or not enough\n        12: Invalid ownership\n    */\n\n    // Token amount to grant to each user\n    uint256 private immutable tokenAmount;\n    // Timestamp for when the recovery begins\n    uint256 public immutable timeRecoverGrant;\n    // Timestamp for when the receive begins\n    uint256 public immutable timeReceiveGrant;\n    // Owner that can recover grant and add new grant addresses\n    address private immutable owner;\n    // Token to lock\n    IERC20 private immutable token;\n\n    // Status of grant\n    enum GrantStatus {\n        // No grant setup for user\n        UNKNOWN,\n        // Granted to user\n        GRANTED,\n        // Claimed by user\n        CLAIMED\n    }\n\n    // Mapping of address to grant\n    mapping(address => GrantStatus) private grants;\n\n    // Emitted when a claim is recovered\n    event Recovered(address recipient, uint256 amount);\n\n    // Emitted when a claim is claimed\n    event Claimed(address actor, uint256 amount);\n\n    // Emitted when a grant is added\n    event GrantsAdded(address actor, address[] newRecipients);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"3\");\n        _;\n    }\n\n    /**\n        Sets up grant created by TimelockCreator Contract\n     */\n    constructor(\n        address _owner,\n        IERC20 _token,\n        uint256 _tokenAmount,\n        uint256 unlockTimestamp,\n        uint256 recoverTimestamp\n    ) {\n        token = _token;\n        owner = _owner;\n        tokenAmount = _tokenAmount;\n        require(\n            unlockTimestamp > block.timestamp &&\n                recoverTimestamp > block.timestamp,\n            \"1\"\n        );\n        require(recoverTimestamp > unlockTimestamp, \"8\");\n        timeReceiveGrant = unlockTimestamp;\n        timeRecoverGrant = recoverTimestamp;\n    }\n\n    /**\n        Returns token for timelock and amount per recipient\n     */\n    function getTokenAndAmount() public view returns (IERC20, uint256) {\n        return (token, tokenAmount);\n    }\n\n    /** \n        Returns the time users can recieve the grant / when the timelock expires\n     */\n    function getTimeUnlock() public view returns (uint256) {\n        return timeReceiveGrant;\n    }\n\n    /**\n        Proxied token information for bookkeeping / discoverability\n        Not implemented:\n            1. approvals\n            2. transfers\n            etc.\n    */\n    function balanceOf(address user) public view returns (uint256) {\n        return grants[user] == GrantStatus.GRANTED ? tokenAmount : 0;\n    }\n\n    function decimals() public view returns (uint8) {\n        return IERC20Metadata(address(token)).decimals();\n    }\n\n    function name() public view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    \"Timelocked \",\n                    IERC20Metadata(address(token)).name()\n                )\n            );\n    }\n\n    function symbol() public view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    \"LOCK_\",\n                    IERC20Metadata(address(token)).symbol()\n                )\n            );\n    }\n\n    /** \n        @dev Adds a grant to the timelock\n        Grants can be added at any time before claim period.\n    */\n    function addGrants(address[] memory newRecipients) external onlyOwner {\n        require(getTimeUnlock() > block.timestamp, \"10\");\n        require(\n            token.allowance(msg.sender, address(this)) >=\n                newRecipients.length * tokenAmount,\n            \"11\"\n        );\n\n        uint256 numberRecipients = newRecipients.length;\n        token.transferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount * numberRecipients\n        );\n        for (uint256 i = 0; i < numberRecipients; i++) {\n            emit Transfer(address(0), newRecipients[i], tokenAmount);\n            require(grants[newRecipients[i]] == GrantStatus.UNKNOWN, \"9\");\n            grants[newRecipients[i]] = GrantStatus.GRANTED;\n        }\n        emit GrantsAdded(owner, newRecipients);\n    }\n\n    /** \n        Returns the status of the grant.\n     */\n    function grantStatus(address recipient)\n        external\n        view\n        returns (GrantStatus)\n    {\n        return grants[recipient];\n    }\n\n    /**\n        Allows a user to claim their grant. Claimee has to be msg.sender.\n     */\n    function claim() external {\n        address recipient = msg.sender;\n        require(block.timestamp >= timeReceiveGrant, \"7\");\n        require(grants[recipient] == GrantStatus.GRANTED, \"2\");\n        token.transfer(recipient, tokenAmount);\n        grants[recipient] = GrantStatus.CLAIMED;\n        emit Claimed(recipient, tokenAmount);\n        emit Transfer(recipient, address(0x0), tokenAmount);\n    }\n\n    /**\n        The owner of the grant can recover after the recovery timestamp passes.\n        This sweeps remaining funds and destroys the contract data.\n     */\n    function recover() external onlyOwner {\n        address payable sender = payable(msg.sender);\n        require(block.timestamp >= timeRecoverGrant, \"6\");\n        uint256 balance = token.balanceOf(address(this));\n        emit Recovered(sender, balance);\n        token.transfer(sender, balance);\n        selfdestruct(sender);\n    }\n}\n"},"contracts/TimelockCreator.sol":{"content":"pragma solidity 0.8.6;\n\nimport \"./Timelock.sol\";\n\n/**\nFactory contract that creates a timelock given global timelock parameters.\n*/\ncontract TimelockCreator {\n    event CreatedTimelockContract(\n        address indexed,\n        Timelock indexed,\n        uint256,\n        uint256,\n        uint256\n    );\n\n    function createTimelock(\n        address owner,\n        IERC20 token,\n        uint256 payoutAmount,\n        uint256 unlockTimestamp,\n        uint256 recoverTimestamp\n    ) external returns (Timelock) {\n        Timelock response = new Timelock(\n            owner,\n            token,\n            payoutAmount,\n            unlockTimestamp,\n            recoverTimestamp\n        );\n        emit CreatedTimelockContract(\n            owner,\n            response,\n            payoutAmount,\n            unlockTimestamp,\n            recoverTimestamp\n        );\n        return response;\n    }\n}\n"}}}