{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/contracts/DAppIncubator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *  Program Name    : DappIncubator\n *  Website         : https://www.dappincubator.com\n *  Telegram        : https://t.me/dappincubatorofficial\n *  Concept         : High Return On Investment\n *  Category        : Passive Income\n *  Risk Category   : High Risk\n **/\n\npragma solidity >=0.6.0 <0.8.1;\n\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n     /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n    \n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\ncontract DappIncubator is Ownable {\n    \n    /**\n     * @dev Structure to hold tokens supplu and dividend per share against collateral.\n     */\n    struct TokenLedger {\n        uint supply;\n        uint dividend;\n        uint initialPrice;\n        uint incrementPrice;\n    }\n    \n    /**\n     * @dev Structure to hold collateral balalnce of wallet.\n     */\n    struct BalanceLedger {\n        uint tokenBalance;\n        uint referralBalance;\n        int payOut;\n    }\n    \n    /**\n     * @dev mapping to store all active contract addresses and wallet addresses. This will be used to check if contract address and wallet address already part of system.\n     */\n    mapping(address => bool) contractAddressRecord;\n    mapping(address => bool) walletAddressRecord;\n    \n    uint constant magnitude = 1e18 ;\n    uint constant dividendFee = 10;\n    \n    /**\n     * @dev structure mapping created for storing balance and token information.\n     */\n    mapping (address => mapping(address => BalanceLedger)) balanceLedger;\n    mapping(address => TokenLedger) tokenLedger;\n    \n    /**\n     * @dev events to register information about collateral buy, sell, reinvest and token withdraw.\n     */\n     \n    event onTokenOnboard(address indexed contractAddress, uint initialPrice, uint incrementPrice);\n    event onPurchase(address indexed walletAddress, address indexed contractAddress, uint incomingTokenAmount, uint collateralMinted, address indexed referredBy);\n    event onSell(address indexed walletAddress, address indexed contractAddress, uint tokenAmountToReceiver, uint collateralBurned);\n    event onReinvest(address indexed walletAddress, address indexed contractAddress, uint reInvestTokenAmount, uint collateralMinted);\n    event onWithdraw(address indexed walletAddress, address indexed contractAddress, uint amountToWithdraw);\n    event onTransfer(address indexed contractAddress, address indexed from,address indexed to,uint256 tokens);\n    \n    /**\n     * @dev function to add ERC-20 Token to ecosystem.\n     */\n     function tokenOnboard(address contractAddress, uint initialPrice, uint incrementPrice) public onlyOwner\n     {\n         if(contractAddressRecord[contractAddress] == false)\n         {\n            contractAddressRecord[contractAddress] = true;\n            tokenLedger[contractAddress].initialPrice = initialPrice;\n            tokenLedger[contractAddress].incrementPrice = incrementPrice;\n            tokenLedger[contractAddress].supply = 0;\n            tokenLedger[contractAddress].dividend = 0;\n            \n            emit onTokenOnboard(contractAddress, initialPrice, incrementPrice);\n         }\n         \n     }\n    \n    \n    /**\n     * @dev function to purchase collateral by sending Ethereum.\n     */\n    function buy(address _referredBy) public payable returns(uint256)\n    {\n        require(msg.value>0);\n        require(contractAddressRecord[address(0)] == true);\n        \n        // if first investment from user then activate wallet address in system.\n        if(walletAddressRecord[msg.sender] == false){\n            walletAddressRecord[msg.sender] = true;\n        }\n        \n        uint256 collateAmount = purchaseCollate(address(0), msg.value, _referredBy);\n        return collateAmount;\n    }\n    \n    /**\n     * @dev function to purchase collateral by sending any ERC-20 Tokens except Ethereum.\n     */\n    function buy(address contractAddress, uint256 tokenAmount, address _referredBy) public returns(uint256)\n    {\n        \n        // transfer token to system from user wallet\n        require(contractAddressRecord[contractAddress] == true);\n        require(tokenAmount > 0);\n        require(ERC20(contractAddress).allowance(msg.sender, address(this)) >= tokenAmount);\n        require(ERC20(contractAddress).transferFrom(msg.sender, address(this), tokenAmount));\n        \n        \n        \n        // if first investment from user then activate wallet address in system.\n        if(walletAddressRecord[msg.sender] == false){\n            walletAddressRecord[msg.sender] = true;\n        }\n        \n        uint256 collateAmount = purchaseCollate(contractAddress,tokenAmount, _referredBy);\n        return collateAmount;\n    }\n    \n    /**\n     * @dev function to purchase collateral by sending Ethereum directly to smart contract address.\n     */\n    fallback() payable external\n    {\n        require(msg.value > 0);\n        require(contractAddressRecord[address(0)] == true);\n        \n        // if first investment from user then activate wallet address in system.\n        if(walletAddressRecord[msg.sender] == false){\n            walletAddressRecord[msg.sender] = true;\n        }\n        purchaseCollate(address(0), msg.value, address(0));\n    }\n    \n    /**\n     * @dev function to convert all dividend to collateral.\n     */\n    function reinvest(address contractAddress) public\n    {\n        require(contractAddressRecord[contractAddress] == true);\n        require(walletAddressRecord[msg.sender] == true);\n        \n        // fetch dividends\n        uint256 _dividends = myDividends(contractAddress, false); // retrieve ref. bonus later in the code\n        \n        // pay out the dividends virtually\n        address _customerAddress = msg.sender;\n        balanceLedger[_customerAddress][contractAddress].payOut +=  (int256) (_dividends * magnitude);\n        \n        // retrieve ref. bonus\n        _dividends += balanceLedger[_customerAddress][contractAddress].referralBalance;\n        \n        balanceLedger[_customerAddress][contractAddress].referralBalance = 0;\n        \n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\n        uint256 _collate = purchaseCollate(contractAddress, _dividends, address(0));\n        \n        // fire event\n        emit onReinvest(_customerAddress, contractAddress, _dividends, _collate);\n    }\n    \n    /**\n     * @dev function to sell collateral and withdraw tokens.\n     */\n    function exit(address contractAddress) public\n    {\n        require(contractAddressRecord[contractAddress] == true);\n        require(walletAddressRecord[msg.sender] == true);\n        \n        // get token count for caller & sell them all\n        address _customerAddress = msg.sender;\n        uint256 _tokens = balanceLedger[_customerAddress][contractAddress].tokenBalance;\n        if(_tokens > 0) sell(contractAddress, _tokens);\n    \n        withdraw(contractAddress);\n    }\n\n    /**\n     * @dev function to withdraw tokens, dividend and referralBalance.\n     */\n    function withdraw(address contractAddress) public\n    {\n        require(contractAddressRecord[contractAddress] == true);\n        require(walletAddressRecord[msg.sender] == true);\n        \n        // setup data\n        address _customerAddress = msg.sender;\n        uint256 _dividends = myDividends(contractAddress, false); // get ref. bonus later in the code\n        \n        // update dividend tracker\n        balanceLedger[_customerAddress][contractAddress].payOut +=  (int256) (_dividends * magnitude);\n        \n        // add ref. bonus\n        _dividends += balanceLedger[_customerAddress][contractAddress].referralBalance;\n        balanceLedger[_customerAddress][contractAddress].referralBalance = 0;\n        \n        // delivery service\n        if (contractAddress == address(0)){\n            payable(address(_customerAddress)).transfer(_dividends);\n        }\n        else{\n            ERC20(contractAddress).transfer(_customerAddress,_dividends);\n        }\n        \n        \n        // fire event\n        emit onWithdraw(_customerAddress, contractAddress, _dividends);\n    }\n    \n    \n    /**\n     * Transfer collateral from the caller to a new holder.\n     * Remember, there's a 10% fee here as well.\n     */\n    function transfer(address contractAddress, address toAddress, uint256 amountOfCollate) public returns(bool)\n    {\n        address _customerAddress = msg.sender;\n        \n        require(contractAddressRecord[contractAddress] == true);\n        require(walletAddressRecord[_customerAddress] == true);\n        require(amountOfCollate <= balanceLedger[_customerAddress][contractAddress].tokenBalance);\n        \n        if(walletAddressRecord[toAddress] == false){\n            walletAddressRecord[toAddress] = true;\n        }\n        \n        // withdraw all outstanding dividends first\n        if(myDividends(contractAddress, true) > 0) withdraw(contractAddress);\n        \n        // calculate divident fees, tokens to transfer\n        uint256 _tokenFee = SafeMath.div(amountOfCollate, dividendFee);\n        uint256 _taxedTokens = SafeMath.sub(amountOfCollate, _tokenFee);\n        uint256 _dividends = collateralToToken_(contractAddress, _tokenFee);\n  \n        // burn the fee tokens\n        tokenLedger[contractAddress].supply = SafeMath.sub(tokenLedger[contractAddress].supply, _tokenFee);\n\n        // exchange tokens\n        balanceLedger[_customerAddress][contractAddress].tokenBalance = SafeMath.sub(balanceLedger[_customerAddress][contractAddress].tokenBalance, amountOfCollate);\n        balanceLedger[toAddress][contractAddress].tokenBalance = SafeMath.add(balanceLedger[toAddress][contractAddress].tokenBalance, _taxedTokens);\n        \n        // update dividend trackers\n        balanceLedger[_customerAddress][contractAddress].payOut -= (int256) (tokenLedger[contractAddress].dividend * amountOfCollate);\n        balanceLedger[toAddress][contractAddress].payOut += (int256) (tokenLedger[contractAddress].dividend * _taxedTokens);\n        \n        // disperse dividends among holders\n        tokenLedger[contractAddress].dividend = SafeMath.add(tokenLedger[contractAddress].dividend, (_dividends * magnitude) / tokenLedger[contractAddress].supply);\n        \n        // emit transfer events\n        emit onTransfer(contractAddress, _customerAddress, toAddress, _taxedTokens);\n        \n        return true;\n\n    }\n    \n    \n    /**\n     * @dev function to sell collatral.\n     */\n    function sell(address contractAddress, uint256 _amountOfCollate) public\n    {\n        require(contractAddressRecord[contractAddress] == true);\n        require(walletAddressRecord[msg.sender] == true);\n      \n        address _customerAddress = msg.sender;\n       \n        require(_amountOfCollate <= balanceLedger[_customerAddress][contractAddress].tokenBalance);\n        \n        uint256 _collates = _amountOfCollate;\n        uint256 _tokens = collateralToToken_(contractAddress, _collates);\n        uint256 _dividends = SafeMath.div(_tokens, dividendFee);\n        uint256 _taxedToken = SafeMath.sub(_tokens, _dividends);\n        \n        // burn the sold tokens\n        tokenLedger[contractAddress].supply = SafeMath.sub(tokenLedger[contractAddress].supply, _collates);\n        balanceLedger[_customerAddress][contractAddress].tokenBalance = SafeMath.sub(balanceLedger[_customerAddress][contractAddress].tokenBalance, _collates);\n        \n        // update dividends tracker\n        int256 _updatedPayouts = (int256) (tokenLedger[contractAddress].dividend * _collates + (_taxedToken * magnitude));\n        balanceLedger[_customerAddress][contractAddress].payOut -= _updatedPayouts;       \n        \n        // dividing by zero is a bad idea\n        if (tokenLedger[contractAddress].supply > 0) {\n            // update the amount of dividends per token\n            tokenLedger[contractAddress].dividend = SafeMath.add(tokenLedger[contractAddress].dividend, (_dividends * magnitude) / tokenLedger[contractAddress].supply);\n        }\n        \n        // fire event\n        emit onSell(_customerAddress, contractAddress, _taxedToken, _collates);\n    }\n        \n    /**\n     * @dev function to get current purchase price of single collateral.\n     */\n    function buyPrice(address contractAddress) public view returns(uint currentBuyPrice) {\n        require(contractAddressRecord[contractAddress] == true);\n        \n        if(tokenLedger[contractAddress].supply == 0){\n            return tokenLedger[contractAddress].initialPrice + tokenLedger[contractAddress].incrementPrice;\n        } else {\n            uint256 _token = collateralToToken_(contractAddress, 1e18);\n            uint256 _dividends = SafeMath.div(_token, dividendFee);\n            uint256 _taxedToken = SafeMath.add(_token, _dividends);\n            return _taxedToken;\n        }\n    }\n    \n    /**\n     * @dev function to get current sell price of single collateral.\n     */\n    function sellPrice(address contractAddress) public view returns(uint) {\n        require(contractAddressRecord[contractAddress] == true);\n        \n        if(tokenLedger[contractAddress].supply == 0){\n            return tokenLedger[contractAddress].initialPrice - tokenLedger[contractAddress].incrementPrice;\n        } else {\n            uint256 _token = collateralToToken_(contractAddress, 1e18);\n            uint256 _dividends = SafeMath.div(_token, dividendFee);\n            uint256 _taxedToken = SafeMath.sub(_token, _dividends);\n            return _taxedToken;\n        }\n    }\n\n    \n    /**\n     * @dev function to calculate collateral price based on an amount of incoming token\n     * It's an scientific algorithm;\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n     */\n    function tokentoCollateral_(address contractAddress, uint amount) internal view returns(uint)\n    {\n        uint256 _tokenPriceInitial = tokenLedger[contractAddress].initialPrice * 1e18;\n        uint256 tokenSupply_ = tokenLedger[contractAddress].supply;\n        uint tokenPriceIncremental_ = tokenLedger[contractAddress].incrementPrice;\n        \n        uint256 _tokensReceived = \n         (\n            (\n                // underflow attempts BTFO\n                SafeMath.sub(\n                    (sqrt\n                        (\n                            (_tokenPriceInitial**2)\n                            +\n                            (2*(tokenPriceIncremental_ * 1e18)*(amount * 1e18))\n                            +\n                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\n                            +\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\n                        )\n                    ), _tokenPriceInitial\n                )\n            )/(tokenPriceIncremental_)\n        )-(tokenSupply_)\n        ;\n  \n        return _tokensReceived;\n    }\n    \n    /**\n     * @dev function to calculate token price based on an amount of incoming collateral\n     * It's an scientific algorithm;\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n     */\n    function collateralToToken_(address contractAddress, uint256 _tokens) internal view returns(uint256)\n    {\n\n        uint256 tokens_ = _tokens + 1e18 ;\n        uint256 _tokenSupply = tokenLedger[contractAddress].supply + 1e18;\n        uint256 tokenPriceInitial_ = tokenLedger[contractAddress].initialPrice;\n        uint tokenPriceIncremental_ = tokenLedger[contractAddress].incrementPrice;\n        \n        uint256 _etherReceived =\n        (\n            // underflow attempts BTFO\n            SafeMath.sub(\n                (\n                    (\n                        (\n                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\n                        )-tokenPriceIncremental_\n                    )*(tokens_ - 1e18)\n                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\n            )\n        /1e18);\n        \n        return _etherReceived;\n    }\n    \n    /**\n     * @dev function to calculate amount of collateral received after sending tokens\n     */\n    function calculateCollateReceived(address contractAddress, uint256 _tokenAmount) public view returns(uint256)\n    {\n        require(contractAddressRecord[contractAddress] == true);\n        \n        uint256 _dividends = SafeMath.div(_tokenAmount, dividendFee);\n        uint256 _taxedToken = SafeMath.sub(_tokenAmount, _dividends);\n        uint256 _amountOfCollatral = tokentoCollateral_(contractAddress, _taxedToken);\n        \n        return _amountOfCollatral;\n    }\n     \n    /**\n     * @dev function to calculate amount of tokens received after sending collateral\n     */\n    function calculateTokenReceived(address contractAddress, uint256 _collateToSell) public view returns(uint256)\n    {\n        require(contractAddressRecord[contractAddress] == true);\n        require(_collateToSell <= tokenLedger[contractAddress].supply);\n        \n        uint256 _token = collateralToToken_(contractAddress, _collateToSell);\n        uint256 _dividends = SafeMath.div(_token, dividendFee);\n        uint256 _taxedToken = SafeMath.sub(_token, _dividends);\n        return _taxedToken;\n    }  \n    \n    /**\n     * @dev function to process purchase of collateral and update user balance, dividend\n     */\n    function purchaseCollate(address contractAddress, uint256 _incomingToken, address _referredBy) internal returns(uint256)\n    {\n        // data setup\n        address _customerAddress = msg.sender;\n        uint256 _undividedDividends = SafeMath.div(_incomingToken, dividendFee);\n        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n        uint256 _taxedToken = SafeMath.sub(_incomingToken, _undividedDividends);\n        uint256 _amountOfCollate = tokentoCollateral_(contractAddress,_taxedToken);\n        uint256 _fee = _dividends * magnitude;\n \n      \n        require(_amountOfCollate > 0 && (SafeMath.add(_amountOfCollate,tokenLedger[contractAddress].supply) > tokenLedger[contractAddress].supply));\n        \n        // is the user referred by a karmalink?\n        if(\n            // is this a referred purchase?\n            _referredBy != address(0) &&\n            \n            // no cheating!\n            _referredBy != _customerAddress &&\n            \n            walletAddressRecord[_referredBy] == true\n        ){\n            // wealth redistribution\n            balanceLedger[_referredBy][contractAddress].referralBalance = SafeMath.add(balanceLedger[_referredBy][contractAddress].referralBalance, _referralBonus);\n        } else {\n            // no ref purchase\n            // add the referral bonus back to the global dividends cake\n            _dividends = SafeMath.add(_dividends, _referralBonus);\n            _fee = _dividends * magnitude;\n        }\n        \n        // we can't give people infinite ethereum\n        if(tokenLedger[contractAddress].supply > 0){\n            \n            // add tokens to the pool\n            tokenLedger[contractAddress].supply = SafeMath.add(tokenLedger[contractAddress].supply, _amountOfCollate);\n \n            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n            tokenLedger[contractAddress].dividend += (_dividends * magnitude / (tokenLedger[contractAddress].supply));\n            \n            // calculate the amount of tokens the customer receives over his purchase \n            _fee = _fee - (_fee-(_amountOfCollate * (_dividends * magnitude / (tokenLedger[contractAddress].supply))));\n        \n        } else {\n            // add tokens to the pool\n            tokenLedger[contractAddress].supply = _amountOfCollate;\n        }\n        \n        // update circulating supply & the ledger address for the customer\n        balanceLedger[_customerAddress][contractAddress].tokenBalance = SafeMath.add(balanceLedger[_customerAddress][contractAddress].tokenBalance, _amountOfCollate);\n        \n        int256 _updatedPayouts = (int256) ((tokenLedger[contractAddress].dividend * _amountOfCollate) - _fee);\n        balanceLedger[_customerAddress][contractAddress].payOut += _updatedPayouts;\n        \n        // fire event\n        emit onPurchase(_customerAddress, contractAddress, _incomingToken, _amountOfCollate, _referredBy);\n        \n        return _amountOfCollate;\n    }\n    \n    /**\n     * @dev function to get tokens contract hold\n     */\n    function totalTokenBalance(address contractAddress) public view returns(uint)\n    {   \n        require(contractAddressRecord[contractAddress] == true);\n        \n        if (contractAddress== address(0)){\n            return address(this).balance;\n        }\n        else{\n            return ERC20(contractAddress).balanceOf(address(this));\n        }\n    }\n    \n    /**\n     * @dev function to retrieve the total token supply.\n     */\n    function totalSupply(address contractAddress) public view returns(uint256)\n    {\n        require(contractAddressRecord[contractAddress] == true);\n        \n        return tokenLedger[contractAddress].supply;\n    }\n    \n    /**\n     * @dev function to retrieve the tokens owned by the caller.\n     */\n    function myTokens(address contractAddress) public view returns(uint256)\n    {\n        require(contractAddressRecord[contractAddress] == true);\n        \n        address _customerAddress = msg.sender;\n        return balanceOf(contractAddress, _customerAddress);\n    }\n    \n    /**\n     * @dev function to retrieve the dividends owned by the caller.\n      */ \n    function myDividends(address contractAddress, bool _includeReferralBonus) public view returns(uint256)\n    {\n        require(contractAddressRecord[contractAddress] == true);\n        \n        address _customerAddress = msg.sender;\n        return _includeReferralBonus ? dividendsOf(contractAddress,_customerAddress) + balanceLedger[_customerAddress][contractAddress].referralBalance : dividendsOf(contractAddress, _customerAddress) ;\n    }\n    \n    /**\n     * @dev function to retrieve the token balance of any single address.\n     */\n    function balanceOf(address contractAddress, address _customerAddress) view public returns(uint256)\n    {\n        require(contractAddressRecord[contractAddress] == true);\n        \n        return balanceLedger[_customerAddress][contractAddress].tokenBalance;\n    }\n    \n    /**\n     * @dev function to retrieve the dividend balance of any single address.\n     */\n    function dividendsOf(address contractAddress, address _customerAddress) view public returns(uint256)\n    {\n        require(contractAddressRecord[contractAddress] == true);\n        \n        return (uint256) ((int256)(tokenLedger[contractAddress].dividend * balanceLedger[_customerAddress][contractAddress].tokenBalance) - balanceLedger[_customerAddress][contractAddress].payOut) / magnitude;\n    }\n    \n    function sqrt(uint x) internal pure returns (uint y) {\n        uint z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n}\n\n/**\n * @dev interface to process transfer of ERC20 tokens\n */ \ninterface ERC20 {\n    function totalSupply() external view returns (uint supply);\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\n    function approve(address _spender, uint _value) external returns (bool success);\n    function balanceOf(address _owner) external view returns (uint balance);\n    function transfer(address _to, uint _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n\n    event Approval(address indexed _owner, address indexed _spender,    uint _value);\n    event Transfer(address indexed _from, address indexed _to, uint    _value);\n}\n\n/**\n * @dev safemath library to avoid mathematical overflow error\n */ \nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n   \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n   \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}"
    }
  }
}