{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"KayboMon.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal pure returns (bool) {\r\n        require(account != address(0), \"isContract zero address\");\r\n        uint256 size;\r\n        return size > 0;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary EnumerableSet {\r\n    struct Set {\r\n        bytes32[] _values;\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        uint256 valueIndex = set._indexes[value];\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n            set._values.pop();\r\n            delete set._indexes[value];\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {return set._indexes[value] != 0;}\r\n    function _length(Set storage set) private view returns (uint256) {return set._values.length;}\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n    struct AddressSet {Set _inner;}\r\n    function add(AddressSet storage set, address value) internal returns (bool) {return _add(set._inner, bytes32(uint256(value)));}\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {return _remove(set._inner, bytes32(uint256(value)));}\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {return _contains(set._inner, bytes32(uint256(value)));}\r\n    function length(AddressSet storage set) internal view returns (uint256) {return _length(set._inner);}function at(AddressSet storage set, uint256 index) internal view returns (address) {return address(uint256(_at(set._inner, index)));}\r\n    struct UintSet {Set _inner;}\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {return _add(set._inner, bytes32(value));}\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {return _remove(set._inner, bytes32(value));}\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {return _contains(set._inner, bytes32(value));}\r\n    function length(UintSet storage set) internal view returns (uint256) {return _length(set._inner);}\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {return uint256(_at(set._inner, index));}\r\n}\r\n\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n    struct Counter {uint256 _value;}\r\n    function current(Counter storage counter) internal view returns (uint256) {return counter._value;}\r\n    function increment(Counter storage counter) internal {counter._value += 1;}\r\n    function decrement(Counter storage counter) internal {counter._value = counter._value.sub(1);}\r\n    \r\n    \r\n    \r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface ERC721Metadata{\r\n  function name() external view returns (string memory _name);\r\n  function symbol() external view returns (string memory _symbol);\r\n  function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n    constructor () internal {}\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {return _supportedInterfaces[interfaceId];}\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed coinowner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed coinowner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    //function ownerOf(uint256 tokenId) public view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n} \r\n\r\ncontract IERC721Receiver {\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public returns (bytes4);\r\n}\r\n\r\ncontract ERC721 is ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n    mapping (uint256 => address) private _tokenOwner;\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n    mapping (uint256 => string) private _tokenURIs;\r\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    mapping(address => mapping(bytes32 => string)) user_dataList;\r\n    address public owner;\r\n    constructor () public {_registerInterface(_INTERFACE_ID_ERC721);}\r\n    \r\n    struct EaCard {\r\n        string  name;\r\n        uint256 cardprice;\r\n        string stakingto;\r\n    }\r\n    \r\n    mapping(uint256 => EaCard) public Cards_list;\r\n    \r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address coinowner = _tokenOwner[tokenId];\r\n        require(coinowner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return coinowner;\r\n    }\r\n    function approve(address to, uint256 tokenId) public {\r\n        address coinowner = ownerOf(tokenId);\r\n        require(to != coinowner, \"ERC721: approval to current owner\");\r\n        require(msg.sender == coinowner || isApprovedForAll(owner, msg.sender),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(coinowner, to, tokenId);\r\n    }\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != msg.sender, \"ERC721: approve to caller\");\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n    function isApprovedForAll(address coinowner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[coinowner][operator];\r\n    }\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n    \r\n    \r\n    \r\n    function _burn(address coinowner, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == coinowner, \"ERC721: burn of token that is not own\");\r\n        _clearApproval(tokenId);\r\n        _tokenOwner[tokenId] = address(0);\r\n        _holderTokens[coinowner].remove(tokenId);\r\n        emit Transfer(coinowner, address(0), tokenId);\r\n    }\r\n    function _burn(uint256 tokenId) internal {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n    \r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool){\r\n        if (!to.isContract()) {return true;}\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {return \"0\";}\r\n        uint j = _i; uint len;\r\n        while (j != 0) {len++;j /= 10;}\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {bstr[k--] = byte(uint8(48 + _i % 10));_i /= 10;}\r\n        return string(bstr);\r\n    }\r\n    function concatStrng(string memory _a, string memory _b) internal pure returns (string memory){\r\n        bytes memory bytes_a = bytes(_a);\r\n        bytes memory bytes_b = bytes(_b);\r\n        string memory length_ab = new string(bytes_a.length + bytes_b.length);\r\n        bytes memory bytes_c = bytes(length_ab);\r\n        uint k = 0;\r\n        for (uint256 i = 0; i < bytes_a.length; i++) bytes_c[k++] = bytes_a[i];\r\n        for (uint256 i = 0; i < bytes_b.length; i++) bytes_c[k++] = bytes_b[i];\r\n        return string(bytes_c);\r\n    }\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n        _tokenOwner[tokenId] = to;\r\n        _holderTokens[to].add(tokenId);\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n    function tokenOfOwnerByIndex(address holder, uint256 index) public view returns (uint256) {\r\n        return _holderTokens[holder].at(index);\r\n    }\r\n    \r\n    function balanceOf(address coinowner) public view returns (uint256) {\r\n        require(coinowner != address(0), \"ERC721: balance query for the zero address\");\r\n        return _holderTokens[coinowner].length();\r\n    }\r\n    function _gettokenURI(uint256 tokenId) public view returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        return _tokenURI;\r\n    }\r\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\r\n        _tokenURIs[tokenId] = _tokenURI;\r\n    }\r\n    \r\n    function balanceByAddressAll(address holder) public view returns (string memory) {\r\n        require(holder != address(0), \"ERC721: balance query for the zero address\");\r\n        uint256 ns = _holderTokens[holder].length();\r\n        string memory _a1 = '[';\r\n        for(uint8 i = 0; i < ns; i++ ){\r\n            uint256 ea = _holderTokens[holder].at(i);\r\n            string memory No = uint2str(ea);\r\n            if( i > 0 ) _a1 = concatStrng(_a1, ',');\r\n            _a1 = concatStrng(_a1, No);\r\n            \r\n        }\r\n        _a1 = concatStrng(_a1, ']');\r\n        return _a1;\r\n    }\r\n    \r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address coinowner = ownerOf(tokenId);\r\n        return (spender == owner || spender == coinowner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address Coinowner = _tokenOwner[tokenId];\r\n        return Coinowner != address(0);\r\n    }\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from || from == owner , \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n        _clearApproval(tokenId);\r\n        address ThistokenOwner = ownerOf(tokenId);\r\n        _holderTokens[ThistokenOwner].remove(tokenId);\r\n        _holderTokens[from].remove(tokenId);\r\n        _tokenOwner[tokenId] = to;\r\n        _holderTokens[to].add(tokenId);\r\n        emit Transfer(ThistokenOwner, to, tokenId);\r\n    }\r\n    \r\n    \r\n    function getStringData(bytes32 key) public view returns (string memory) {\r\n        return user_dataList[msg.sender][key];\r\n    }\r\n    function setStringData(bytes32 key, string memory value) public {\r\n        user_dataList[msg.sender][key] = value;\r\n    }\r\n}\r\n\r\n\r\ncontract KayboMon is ERC721{\r\n    string public _name;\r\n    string public _symbol;\r\n    uint8 public _decimals;\r\n    uint256 public _totalSupply;\r\n    uint256 public prefix;\r\n   \r\n    string private baseImageUrl;\r\n    string private baseMeta;\r\n    \r\n    constructor () public {\r\n        _name =\"Kaybo mon\";\r\n        _symbol =\"KMON\";\r\n        _decimals =0;\r\n        _totalSupply = 0;\r\n        prefix = 100000;\r\n        baseImageUrl = \"https://kmon.io/datas/\";\r\n        baseMeta = \"https://kmon.io/kmon/\";\r\n        owner = msg.sender; \r\n    }\r\n    function _setCardPrice( uint256 cardId,uint256 price ) internal {Cards_list[cardId].cardprice = price;}\r\n    function _setCardName( uint256 cardId,string memory cardname ) internal {Cards_list[cardId].name = cardname;}\r\n    function _setbaseImageUrl( string memory change_url ) internal {baseImageUrl = change_url;}\r\n    function setbaseImageUrl(string memory change_url) public {\r\n        require(owner == msg.sender);\r\n        _setbaseImageUrl(change_url);\r\n    }\r\n    function _setbaseMeta( string memory change_url ) internal {baseMeta = change_url;}\r\n    function setbaseMeta(string memory change_url) public {\r\n        require(owner == msg.sender);\r\n        _setbaseMeta(change_url);\r\n    }\r\n    \r\n    function setCardPrice(uint256 cardId,uint256 price ) public {\r\n        require(owner == msg.sender);\r\n        _setCardPrice(cardId,price);\r\n    }\r\n    \r\n    function setCardName(uint256 cardId,string memory newexpress ) public {\r\n        require(owner == msg.sender);\r\n        _setCardName(cardId,newexpress);\r\n    }\r\n    function setCarddescription(uint256 cardId,string memory description ) public {\r\n        require(owner == msg.sender);\r\n        EaCard memory ea = Cards_list[cardId];\r\n        string memory No = uint2str(cardId);\r\n        \r\n        string memory _a1 = '';\r\n        _a1 = concatStrng('{\"name\": \"', ea.name);\r\n        _a1 = concatStrng(_a1, '\",\"image\":\"');\r\n        _a1 = concatStrng(_a1, baseImageUrl);\r\n        _a1 = concatStrng(_a1, No);\r\n        _a1 = concatStrng(_a1, '.png\",\"description\":\"');\r\n        _a1 = concatStrng(_a1, description);\r\n        _a1 = concatStrng(_a1, '\"}');\r\n        \r\n        _setTokenURI(cardId,_a1);   \r\n    }\r\n    \r\n    function getCardInfo( uint256 tokenId) public view returns (string memory cardname, uint256 cardprice , string memory stakingadr, address _tokenOwner){\r\n        EaCard memory ea = Cards_list[tokenId];\r\n        return (ea.name, ea.cardprice, ea.stakingto, ownerOf(tokenId));\r\n    }\r\n    function getbaseMeta() public view returns (string memory) {return baseMeta;}\r\n    function getbaseImageUrl() public view returns (string memory) {return baseImageUrl;}\r\n    function Contadmin() public view returns (address) {return owner;}\r\n    function totalSupply() public view returns (uint256) {return _totalSupply;}\r\n    function name() public view returns (string memory) {return _name;}\r\n    function symbol() public view returns (string memory) {return _symbol;}\r\n    function GettokenURI( uint256 cardId ) public view returns (string memory){\r\n        return _gettokenURI(cardId);\r\n    }\r\n    \r\n    function mintCard(string memory cardname, address account, uint256 price,string memory carddescription) public {\r\n        require(owner == msg.sender); // Only the Owner can create Items\r\n        uint256 cardId = prefix + _totalSupply; // Unique card ID\r\n        Cards_list[cardId] =EaCard(cardname, price,\"\" );\r\n        _mint(account, cardId ); // Mint a new card\r\n        \r\n        string memory No = uint2str(cardId);\r\n        string memory _a1 = '';\r\n        if( bytes(cardname).length > 0 ){\r\n             _a1 = concatStrng('{\"name\":\"', cardname);\r\n        }else{\r\n             _a1 = concatStrng('{\"name\": \"MCM #', No);\r\n        }\r\n        _a1 = concatStrng(_a1, '\",\"image\":\"');\r\n        _a1 = concatStrng(_a1, baseImageUrl);\r\n        _a1 = concatStrng(_a1, No);\r\n        _a1 = concatStrng(_a1, '.png\",\"description\":\"');\r\n        _a1 = concatStrng(_a1, carddescription);\r\n        _a1 = concatStrng(_a1, '\"}');\r\n        _setTokenURI(cardId,_a1);    \r\n        _totalSupply++;\r\n    }\r\n    \r\n    function mintCardTOmain(address account , uint256 _numberOfToken , string memory carddescription, uint256 price ) public {\r\n        require(owner == msg.sender); // Only the Owner can create Items\r\n        for(uint256 i = 0; i < _numberOfToken; i++) {\r\n            uint256 cardId = prefix + _totalSupply; // Unique card ID\r\n            Cards_list[cardId]= EaCard(\"AutoGen\", price, \"\" );\r\n            _mint(account, cardId); // Mint a new card\r\n            string memory No = uint2str(cardId);\r\n            string memory _a1 = '';\r\n            _a1 = concatStrng('{\"name\": \"MCM #', No);\r\n            _a1 = concatStrng(_a1, '\",\"image\":\"');\r\n            _a1 = concatStrng(_a1, baseImageUrl);\r\n            _a1 = concatStrng(_a1, No);\r\n            _a1 = concatStrng(_a1, '.png\",\"description\":\"');\r\n            _a1 = concatStrng(_a1, carddescription);\r\n            _a1 = concatStrng(_a1, '\"}');\r\n            \r\n            _setTokenURI(cardId,_a1);    \r\n            _totalSupply++;\r\n        }\r\n    }\r\n}"}}}