{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CollateralPool.sol":{"content":"// File: contracts\\modules\\SafeInt256.sol\r\n\r\npragma solidity =0.5.16;\r\nlibrary SafeInt256 {\r\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\r\n        require(((z = x + y) >= x) == (y >= 0), 'SafeInt256: addition overflow');\r\n    }\r\n\r\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\r\n        require(((z = x - y) <= x) == (y >= 0), 'SafeInt256: substraction underflow');\r\n    }\r\n\r\n    function mul(int256 x, int256 y) internal pure returns (int256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'SafeInt256: multiplication overflow');\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\SafeMath.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'SafeMath: addition overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'SafeMath: substraction underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'SafeMath: multiplication overflow');\r\n    }\r\n}\r\n\r\n// File: contracts\\ERC20\\IERC20.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts\\modules\\Ownable.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Managerable.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\ncontract Managerable is Ownable {\r\n\r\n    address private _managerAddress;\r\n    /**\r\n     * @dev modifier, Only manager can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyManager() {\r\n        require(_managerAddress == msg.sender,\"Managerable: caller is not the Manager\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev set manager by owner. \r\n     *\r\n     */\r\n    function setManager(address managerAddress)\r\n    public\r\n    onlyOwner\r\n    {\r\n        _managerAddress = managerAddress;\r\n    }\r\n    /**\r\n     * @dev get manager address. \r\n     *\r\n     */\r\n    function getManager()public view returns (address) {\r\n        return _managerAddress;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Halt.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\ncontract Halt is Ownable {\r\n    \r\n    bool private halted = false; \r\n    \r\n    modifier notHalted() {\r\n        require(!halted,\"This contract is halted\");\r\n        _;\r\n    }\r\n\r\n    modifier isHalted() {\r\n        require(halted,\"This contract is not halted\");\r\n        _;\r\n    }\r\n    \r\n    /// @notice function Emergency situation that requires \r\n    /// @notice contribution period to stop or not.\r\n    function setHalt(bool halt) \r\n        public \r\n        onlyOwner\r\n    {\r\n        halted = halt;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\whiteList.sol\r\n\r\npragma solidity =0.5.16;\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint32.\r\n     */\r\nlibrary whiteListUint32 {\r\n    /**\r\n     * @dev add uint32 into white list.\r\n     * @param whiteList the storage whiteList.\r\n     * @param temp input value\r\n     */\r\n\r\n    function addWhiteListUint32(uint32[] storage whiteList,uint32 temp) internal{\r\n        if (!isEligibleUint32(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    /**\r\n     * @dev remove uint32 from whitelist.\r\n     */\r\n    function removeWhiteListUint32(uint32[] storage whiteList,uint32 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible uint256.\r\n     */\r\nlibrary whiteListUint256 {\r\n    // add whiteList\r\n    function addWhiteListUint256(uint256[] storage whiteList,uint256 temp) internal{\r\n        if (!isEligibleUint256(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListUint256(uint256[] storage whiteList,uint256 temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n    /**\r\n     * @dev Implementation of a whitelist which filters a eligible address.\r\n     */\r\nlibrary whiteListAddress {\r\n    // add whiteList\r\n    function addWhiteListAddress(address[] storage whiteList,address temp) internal{\r\n        if (!isEligibleAddress(whiteList,temp)){\r\n            whiteList.push(temp);\r\n        }\r\n    }\r\n    function removeWhiteListAddress(address[] storage whiteList,address temp)internal returns (bool) {\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        if (i<len){\r\n            if (i!=len-1) {\r\n                whiteList[i] = whiteList[len-1];\r\n            }\r\n            whiteList.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isEligibleAddress(address[] memory whiteList,address temp) internal pure returns (bool){\r\n        uint256 len = whiteList.length;\r\n        for (uint256 i=0;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _getEligibleIndexAddress(address[] memory whiteList,address temp) internal pure returns (uint256){\r\n        uint256 len = whiteList.length;\r\n        uint256 i=0;\r\n        for (;i<len;i++){\r\n            if (whiteList[i] == temp)\r\n                break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\AddressWhiteList.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n    /**\r\n     * @dev Implementation of a whitelist filters a eligible address.\r\n     */\r\ncontract AddressWhiteList is Halt {\r\n\r\n    using whiteListAddress for address[];\r\n    uint256 constant internal allPermission = 0xffffffff;\r\n    uint256 constant internal allowBuyOptions = 1;\r\n    uint256 constant internal allowSellOptions = 1<<1;\r\n    uint256 constant internal allowExerciseOptions = 1<<2;\r\n    uint256 constant internal allowAddCollateral = 1<<3;\r\n    uint256 constant internal allowRedeemCollateral = 1<<4;\r\n    // The eligible adress list\r\n    address[] internal whiteList;\r\n    mapping(address => uint256) internal addressPermission;\r\n    /**\r\n     * @dev Implementation of add an eligible address into the whitelist.\r\n     * @param addAddress new eligible address.\r\n     */\r\n    function addWhiteList(address addAddress)public onlyOwner{\r\n        whiteList.addWhiteListAddress(addAddress);\r\n        addressPermission[addAddress] = allPermission;\r\n    }\r\n    function modifyPermission(address addAddress,uint256 permission)public onlyOwner{\r\n        addressPermission[addAddress] = permission;\r\n    }\r\n    /**\r\n     * @dev Implementation of revoke an invalid address from the whitelist.\r\n     * @param removeAddress revoked address.\r\n     */\r\n    function removeWhiteList(address removeAddress)public onlyOwner returns (bool){\r\n        addressPermission[removeAddress] = 0;\r\n        return whiteList.removeWhiteListAddress(removeAddress);\r\n    }\r\n    /**\r\n     * @dev Implementation of getting the eligible whitelist.\r\n     */\r\n    function getWhiteList()public view returns (address[] memory){\r\n        return whiteList;\r\n    }\r\n    /**\r\n     * @dev Implementation of testing whether the input address is eligible.\r\n     * @param tmpAddress input address for testing.\r\n     */    \r\n    function isEligibleAddress(address tmpAddress) public view returns (bool){\r\n        return whiteList.isEligibleAddress(tmpAddress);\r\n    }\r\n    function checkAddressPermission(address tmpAddress,uint256 state) public view returns (bool){\r\n        return  (addressPermission[tmpAddress]&state) == state;\r\n    }\r\n}\r\n\r\n// File: contracts\\OptionsPool\\IOptionsPool.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\ninterface IOptionsPool {\r\n//    function getOptionBalances(address user) external view returns(uint256[]);\r\n\r\n    function getExpirationList()external view returns (uint32[] memory);\r\n    function createOptions(address from,address settlement,uint256 type_ly_expiration,\r\n        uint128 strikePrice,uint128 underlyingPrice,uint128 amount,uint128 settlePrice) external returns(uint256);\r\n    function setSharedState(uint256 newFirstOption,int256[] calldata latestNetWorth,address[] calldata whiteList) external;\r\n    function getAllTotalOccupiedCollateral() external view returns (uint256,uint256);\r\n    function getCallTotalOccupiedCollateral() external view returns (uint256);\r\n    function getPutTotalOccupiedCollateral() external view returns (uint256);\r\n    function getTotalOccupiedCollateral() external view returns (uint256);\r\n//    function buyOptionCheck(uint32 expiration,uint32 underlying)external view;\r\n    function burnOptions(address from,uint256 id,uint256 amount,uint256 optionPrice)external;\r\n    function getOptionsById(uint256 optionsId)external view returns(uint256,address,uint8,uint32,uint256,uint256,uint256);\r\n    function getExerciseWorth(uint256 optionsId,uint256 amount)external view returns(uint256);\r\n    function calculatePhaseOptionsFall(uint256 lastOption,uint256 begin,uint256 end,address[] calldata whiteList) external view returns(int256[] memory);\r\n    function getOptionInfoLength()external view returns (uint256);\r\n    function getNetWrothCalInfo(address[] calldata whiteList)external view returns(uint256,int256[] memory);\r\n    function calRangeSharedPayment(uint256 lastOption,uint256 begin,uint256 end,address[] calldata whiteList)external view returns(int256[] memory,uint256[] memory,uint256);\r\n    function getNetWrothLatestWorth(address settlement)external view returns(int256);\r\n    function getBurnedFullPay(uint256 optionID,uint256 amount) external view returns(address,uint256);\r\n\r\n}\r\ncontract ImportOptionsPool is Ownable{\r\n    IOptionsPool internal _optionsPool;\r\n    function getOptionsPoolAddress() public view returns(address){\r\n        return address(_optionsPool);\r\n    }\r\n    function setOptionsPoolAddress(address optionsPool)public onlyOwner{\r\n        _optionsPool = IOptionsPool(optionsPool);\r\n    }\r\n}\r\n\r\n// File: contracts\\modules\\Operator.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * each operator can be granted exclusive access to specific functions.\r\n *\r\n */\r\ncontract Operator is Ownable {\r\n    using whiteListAddress for address[];\r\n    address[] private _operatorList;\r\n    /**\r\n     * @dev modifier, every operator can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyOperator() {\r\n        require(_operatorList.isEligibleAddress(msg.sender),\"Managerable: caller is not the Operator\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev modifier, Only indexed operator can be granted exclusive access to specific functions. \r\n     *\r\n     */\r\n    modifier onlyOperatorIndex(uint256 index) {\r\n        require(_operatorList.length>index && _operatorList[index] == msg.sender,\"Operator: caller is not the eligible Operator\");\r\n        _;\r\n    }\r\n    /**\r\n     * @dev add a new operator by owner. \r\n     *\r\n     */\r\n    function addOperator(address addAddress)public onlyOwner{\r\n        _operatorList.addWhiteListAddress(addAddress);\r\n    }\r\n    /**\r\n     * @dev modify indexed operator by owner. \r\n     *\r\n     */\r\n    function setOperator(uint256 index,address addAddress)public onlyOwner{\r\n        _operatorList[index] = addAddress;\r\n    }\r\n    /**\r\n     * @dev remove operator by owner. \r\n     *\r\n     */\r\n    function removeOperator(address removeAddress)public onlyOwner returns (bool){\r\n        return _operatorList.removeWhiteListAddress(removeAddress);\r\n    }\r\n    /**\r\n     * @dev get all operators. \r\n     *\r\n     */\r\n    function getOperator()public view returns (address[] memory) {\r\n        return _operatorList;\r\n    }\r\n    /**\r\n     * @dev set all operators by owner. \r\n     *\r\n     */\r\n    function setOperators(address[] memory operators)public onlyOwner {\r\n        _operatorList = operators;\r\n    }\r\n}\r\n\r\n// File: contracts\\CollateralPool\\CollateralData.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title collateral pool contract with coin and necessary storage data.\r\n * @dev A smart-contract which stores user's deposited collateral.\r\n *\r\n */\r\ncontract CollateralData is AddressWhiteList,Managerable,Operator,ImportOptionsPool{\r\n        // The total fees accumulated in the contract\r\n    mapping (address => uint256) \tinternal feeBalances;\r\n    uint32[] internal FeeRates;\r\n     /**\r\n     * @dev Returns the rate of trasaction fee.\r\n     */   \r\n    uint256 constant internal buyFee = 0;\r\n    uint256 constant internal sellFee = 1;\r\n    uint256 constant internal exerciseFee = 2;\r\n    uint256 constant internal addColFee = 3;\r\n    uint256 constant internal redeemColFee = 4;\r\n    event RedeemFee(address indexed recieptor,address indexed settlement,uint256 payback);\r\n    event AddFee(address indexed settlement,uint256 payback);\r\n    event TransferPayback(address indexed recieptor,address indexed settlement,uint256 payback);\r\n\r\n    //token net worth balance\r\n    mapping (address => int256) internal netWorthBalances;\r\n    //total user deposited collateral balance\r\n    // map from collateral address to amount\r\n    mapping (address => uint256) internal collateralBalances;\r\n    //user total paying for collateral, priced in usd;\r\n    mapping (address => uint256) internal userCollateralPaying;\r\n    //user original deposited collateral.\r\n    //map account -> collateral -> amount\r\n    mapping (address => mapping (address => uint256)) internal userInputCollateral;\r\n}\r\n\r\n// File: contracts\\CollateralPool\\TransactionFee.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n    /**\r\n     * @dev Implementation of a transaction fee manager.\r\n     */\r\ncontract TransactionFee is CollateralData {\r\n    using SafeMath for uint256;\r\n    constructor() internal{\r\n        initialize();\r\n    }\r\n    function initialize() onlyOwner public{\r\n        FeeRates.push(0);\r\n        FeeRates.push(50);\r\n        FeeRates.push(0);\r\n        FeeRates.push(0);\r\n        FeeRates.push(0);\r\n    }\r\n    function getFeeRateAll()public view returns (uint32[] memory){\r\n        return FeeRates;\r\n    }\r\n    function getFeeRate(uint256 feeType)public view returns (uint32){\r\n        return FeeRates[feeType];\r\n    }\r\n    /**\r\n     * @dev set the rate of trasaction fee.\r\n     * @param feeType the transaction fee type\r\n     * @param thousandth the numerator of transaction fee .\r\n     * transaction fee = thousandth/1000;\r\n     */   \r\n    function setTransactionFee(uint256 feeType,uint32 thousandth)public onlyOwner{\r\n        FeeRates[feeType] = thousandth;\r\n    }\r\n\r\n    function getFeeBalance(address settlement)public view returns(uint256){\r\n        return feeBalances[settlement];\r\n    }\r\n    function getAllFeeBalances()public view returns(address[] memory,uint256[] memory){\r\n        uint256[] memory balances = new uint256[](whiteList.length);\r\n        for (uint256 i=0;i<whiteList.length;i++){\r\n            balances[i] = feeBalances[whiteList[i]];\r\n        }\r\n        return (whiteList,balances);\r\n    }\r\n    function redeem(address currency)public onlyOwner{\r\n        uint256 fee = feeBalances[currency];\r\n        require (fee > 0, \"It's empty balance\");\r\n        feeBalances[currency] = 0;\r\n         if (currency == address(0)){\r\n            msg.sender.transfer(fee);\r\n        }else{\r\n            IERC20 currencyToken = IERC20(currency);\r\n            uint256 preBalance = currencyToken.balanceOf(address(this));\r\n            currencyToken.transfer(msg.sender,fee);\r\n            uint256 afterBalance = currencyToken.balanceOf(address(this));\r\n            require(preBalance - afterBalance == fee,\"settlement token transfer error!\");\r\n        }\r\n        emit RedeemFee(msg.sender,currency,fee);\r\n    }\r\n    function redeemAll()public onlyOwner{\r\n        for (uint256 i=0;i<whiteList.length;i++){\r\n            redeem(whiteList[i]);\r\n        }\r\n    }\r\n    function _addTransactionFee(address settlement,uint256 amount) internal {\r\n        if (amount > 0){\r\n            feeBalances[settlement] = feeBalances[settlement]+amount;\r\n            emit AddFee(settlement,amount);\r\n        }\r\n    }\r\n    function calculateFee(uint256 feeType,uint256 amount)public view returns (uint256){\r\n        return FeeRates[feeType]*amount/1000;\r\n    }\r\n    /**\r\n      * @dev  transfer settlement payback amount;\r\n      * @param recieptor payback recieptor\r\n      * @param settlement settlement address\r\n      * @param payback amount of settlement will payback \r\n      */\r\n    function _transferPaybackAndFee(address payable recieptor,address settlement,uint256 payback,uint256 feeType)internal{\r\n        if (payback == 0){\r\n            return;\r\n        }\r\n        uint256 fee = FeeRates[feeType]*payback/1000;\r\n        _transferPayback(recieptor,settlement,payback-fee);\r\n        _addTransactionFee(settlement,fee);\r\n    }\r\n    /**\r\n      * @dev  transfer settlement payback amount;\r\n      * @param recieptor payback recieptor\r\n      * @param settlement settlement address\r\n      * @param payback amount of settlement will payback \r\n      */\r\n    function _transferPayback(address payable recieptor,address settlement,uint256 payback)internal{\r\n        if (payback == 0){\r\n            return;\r\n        }\r\n        if (settlement == address(0)){\r\n            recieptor.transfer(payback);\r\n        }else{\r\n            IERC20 collateralToken = IERC20(settlement);\r\n            uint256 preBalance = collateralToken.balanceOf(address(this));\r\n            collateralToken.transfer(recieptor,payback);\r\n            uint256 afterBalance = collateralToken.balanceOf(address(this));\r\n            require(preBalance - afterBalance == payback,\"settlement token transfer error!\");\r\n        }\r\n        emit TransferPayback(recieptor,settlement,payback);\r\n    }\r\n}\r\n\r\n// File: contracts\\CollateralPool\\CollateralPool.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n/**\r\n * @title collateral pool contract with coin and necessary storage data.\r\n * @dev A smart-contract which stores user's deposited collateral.\r\n *\r\n */\r\ncontract CollateralPool is TransactionFee{\r\n    using SafeMath for uint256;\r\n    using SafeInt256 for int256;\r\n    constructor(address optionsPool)public{\r\n        _optionsPool = IOptionsPool(optionsPool);\r\n    }\r\n    /**\r\n     * @dev Transfer colleteral from manager contract to this contract.\r\n     *  Only manager contract can invoke this function.\r\n     */\r\n    function () external payable onlyManager{\r\n\r\n    }\r\n    function initialize() onlyOwner public {\r\n        TransactionFee.initialize();\r\n    }\r\n    function update() onlyOwner public{\r\n    }\r\n    /**\r\n     * @dev An interface for add transaction fee.\r\n     *  Only manager contract can invoke this function.\r\n     * @param collateral collateral address, also is the coin for fee.\r\n     * @param amount total transaction amount.\r\n     * @param feeType transaction fee type. see TransactionFee contract\r\n     */\r\n    function addTransactionFee(address collateral,uint256 amount,uint256 feeType)public onlyManager returns (uint256) {\r\n        uint256 fee = FeeRates[feeType]*amount/1000;\r\n        _addTransactionFee(collateral,fee);\r\n        return fee;\r\n    }\r\n    /**\r\n     * @dev Retrieve user's cost of collateral, priced in USD.\r\n     * @param user input retrieved account \r\n     */\r\n    function getUserPayingUsd(address user)public view returns (uint256){\r\n        return userCollateralPaying[user];\r\n    }\r\n    /**\r\n     * @dev Retrieve user's amount of the specified collateral.\r\n     * @param user input retrieved account \r\n     * @param collateral input retrieved collateral coin address \r\n     */\r\n    function getUserInputCollateral(address user,address collateral)public view returns (uint256){\r\n        return userInputCollateral[user][collateral];\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve collateral balance data.\r\n     * @param collateral input retrieved collateral coin address \r\n     */\r\n    function getCollateralBalance(address collateral)public view returns (uint256){\r\n        return collateralBalances[collateral];\r\n    }\r\n    /**\r\n     * @dev Opterator user paying data, priced in USD. Only manager contract can modify database.\r\n     * @param user input user account which need add paying amount.\r\n     * @param amount the input paying amount.\r\n     */\r\n    function addUserPayingUsd(address user,uint256 amount)public onlyManager{\r\n        userCollateralPaying[user] = userCollateralPaying[user].add(amount);\r\n    }\r\n    /**\r\n     * @dev Opterator user input collateral data. Only manager contract can modify database.\r\n     * @param user input user account which need add input collateral.\r\n     * @param collateral the collateral address.\r\n     * @param amount the input collateral amount.\r\n     */\r\n    function addUserInputCollateral(address user,address collateral,uint256 amount)public onlyManager{\r\n        userInputCollateral[user][collateral] = userInputCollateral[user][collateral].add(amount);\r\n    }\r\n    /**\r\n     * @dev Opterator net worth balance data. Only manager contract can modify database.\r\n     * @param whiteList available colleteral address list.\r\n     * @param newNetworth collateral net worth list.\r\n     */\r\n    function addNetWorthBalances(address[] memory whiteList,int256[] memory newNetworth)internal{\r\n        for (uint i=0;i<newNetworth.length;i++){\r\n            netWorthBalances[whiteList[i]] = netWorthBalances[whiteList[i]].add(newNetworth[i]);\r\n        }\r\n    }\r\n    /**\r\n     * @dev Opterator net worth balance data. Only manager contract can modify database.\r\n     * @param collateral available colleteral address.\r\n     * @param amount collateral net worth increase amount.\r\n     */\r\n    function addNetWorthBalance(address collateral,int256 amount)public onlyManager{\r\n        netWorthBalances[collateral] = netWorthBalances[collateral].add(amount);\r\n    }\r\n    /**\r\n     * @dev Opterator collateral balance data. Only manager contract can modify database.\r\n     * @param collateral available colleteral address.\r\n     * @param amount collateral colleteral increase amount.\r\n     */\r\n    function addCollateralBalance(address collateral,uint256 amount)public onlyManager{\r\n        collateralBalances[collateral] = collateralBalances[collateral].add(amount);\r\n    }\r\n    /**\r\n     * @dev Substract user paying data,priced in USD. Only manager contract can modify database.\r\n     * @param user user's account.\r\n     * @param amount user's decrease amount.\r\n     */\r\n    function subUserPayingUsd(address user,uint256 amount)public onlyManager{\r\n        userCollateralPaying[user] = userCollateralPaying[user].sub(amount);\r\n    }\r\n    /**\r\n     * @dev Substract user's collateral balance. Only manager contract can modify database.\r\n     * @param user user's account.\r\n     * @param collateral collateral address.\r\n     * @param amount user's decrease amount.\r\n     */\r\n    function subUserInputCollateral(address user,address collateral,uint256 amount)public onlyManager{\r\n        userInputCollateral[user][collateral] = userInputCollateral[user][collateral].sub(amount);\r\n    }\r\n    /**\r\n     * @dev Substract net worth balance. Only manager contract can modify database.\r\n     * @param collateral collateral address.\r\n     * @param amount the decrease amount.\r\n     */\r\n    function subNetWorthBalance(address collateral,int256 amount)public onlyManager{\r\n        netWorthBalances[collateral] = netWorthBalances[collateral].sub(amount);\r\n    }\r\n    /**\r\n     * @dev Substract collateral balance. Only manager contract can modify database.\r\n     * @param collateral collateral address.\r\n     * @param amount the decrease amount.\r\n     */\r\n    function subCollateralBalance(address collateral,uint256 amount)public onlyManager{\r\n        collateralBalances[collateral] = collateralBalances[collateral].sub(amount);\r\n    }\r\n    /**\r\n     * @dev set user paying data,priced in USD. Only manager contract can modify database.\r\n     * @param user user's account.\r\n     * @param amount user's new amount.\r\n     */\r\n    function setUserPayingUsd(address user,uint256 amount)public onlyManager{\r\n        userCollateralPaying[user] = amount;\r\n    }\r\n    /**\r\n     * @dev set user's collateral balance. Only manager contract can modify database.\r\n     * @param user user's account.\r\n     * @param collateral collateral address.\r\n     * @param amount user's new amount.\r\n     */\r\n    function setUserInputCollateral(address user,address collateral,uint256 amount)public onlyManager{\r\n        userInputCollateral[user][collateral] = amount;\r\n    }\r\n    /**\r\n     * @dev set net worth balance. Only manager contract can modify database.\r\n     * @param collateral collateral address.\r\n     * @param amount the new amount.\r\n     */\r\n    function setNetWorthBalance(address collateral,int256 amount)public onlyManager{\r\n        netWorthBalances[collateral] = amount;\r\n    }\r\n    /**\r\n     * @dev set collateral balance. Only manager contract can modify database.\r\n     * @param collateral collateral address.\r\n     * @param amount the new amount.\r\n     */\r\n    function setCollateralBalance(address collateral,uint256 amount)public onlyManager{\r\n        collateralBalances[collateral] = amount;\r\n    }\r\n    /**\r\n     * @dev Operation for transfer user's payback and deduct transaction fee. Only manager contract can invoke this function.\r\n     * @param recieptor the recieptor account.\r\n     * @param settlement the settlement coin address.\r\n     * @param payback the payback amount\r\n     * @param feeType the transaction fee type. see transactionFee contract\r\n     */\r\n    function transferPaybackAndFee(address payable recieptor,address settlement,uint256 payback,\r\n            uint256 feeType)public onlyManager{\r\n        _transferPaybackAndFee(recieptor,settlement,payback,feeType);\r\n        netWorthBalances[settlement] = netWorthBalances[settlement].sub(int256(payback));\r\n    }\r\n        /**\r\n     * @dev Operation for transfer user's payback. Only manager contract can invoke this function.\r\n     * @param recieptor the recieptor account.\r\n     * @param allPay the payback amount\r\n     */\r\n    function buyOptionsPayfor(address payable recieptor,address settlement,uint256 settlementAmount,uint256 allPay)public onlyManager{\r\n        uint256 fee = addTransactionFee(settlement,allPay,0);\r\n        require(settlementAmount>=allPay+fee,\"settlement asset is insufficient!\");\r\n        settlementAmount = settlementAmount-(allPay+fee);\r\n        if (settlementAmount > 0){\r\n            _transferPayback(recieptor,settlement,settlementAmount);\r\n        }\r\n    }\r\n    /**\r\n     * @dev Operation for transfer user's payback. Only manager contract can invoke this function.\r\n     * @param recieptor the recieptor account.\r\n     * @param settlement the settlement coin address.\r\n     * @param payback the payback amount\r\n     */\r\n    function transferPayback(address payable recieptor,address settlement,uint256 payback)public onlyManager{\r\n        _transferPayback(recieptor,settlement,payback);\r\n    }\r\n    /**\r\n     * @dev Operation for transfer user's payback and deduct transaction fee for multiple settlement Coin.\r\n     *       Specially used for redeem collateral.Only manager contract can invoke this function.\r\n     * @param account the recieptor account.\r\n     * @param redeemWorth the redeem worth, priced in USD.\r\n     * @param tmpWhiteList the settlement coin white list\r\n     * @param colBalances the Collateral balance based for user's input collateral.\r\n     * @param PremiumBalances the premium collateral balance if redeem worth is exceeded user's input collateral.\r\n     * @param prices the collateral prices list.\r\n     */\r\n    function transferPaybackBalances(address payable account,uint256 redeemWorth,address[] memory tmpWhiteList,uint256[] memory colBalances,\r\n        uint256[] memory PremiumBalances,uint256[] memory prices)public onlyManager {\r\n        uint256 ln = tmpWhiteList.length;\r\n        uint256[] memory PaybackBalances = new uint256[](ln);\r\n        uint256 i=0;\r\n        uint256 amount;\r\n        for(; i<ln && redeemWorth>0;i++){\r\n            //address addr = tmpWhiteList[i];\r\n            if (colBalances[i] > 0){\r\n                amount = redeemWorth/prices[i];\r\n                if (amount < colBalances[i]){\r\n                    redeemWorth = 0;\r\n                }else{\r\n                    amount = colBalances[i];\r\n                    redeemWorth = redeemWorth - colBalances[i]*prices[i];\r\n                }\r\n                PaybackBalances[i] = amount;\r\n                amount = amount * userInputCollateral[account][tmpWhiteList[i]]/colBalances[i];\r\n                userInputCollateral[account][tmpWhiteList[i]] =userInputCollateral[account][tmpWhiteList[i]].sub(amount);\r\n                collateralBalances[tmpWhiteList[i]] = collateralBalances[tmpWhiteList[i]].sub(amount);\r\n\r\n            }\r\n        }\r\n        if (redeemWorth>0) {\r\n           amount = 0;\r\n            for (i=0; i<ln;i++){\r\n                amount = amount.add(PremiumBalances[i]*prices[i]);\r\n            }\r\n//            require(amount >= redeemWorth ,\"redeem collateral is insufficient\");\r\n            if (amount<redeemWorth){\r\n                amount = redeemWorth;\r\n            }\r\n            for (i=0; i<ln;i++){\r\n                PaybackBalances[i] = PaybackBalances[i].add(PremiumBalances[i].mul(redeemWorth)/amount);\r\n            }\r\n        }\r\n        for (i=0;i<ln;i++){ \r\n            transferPaybackAndFee(account,tmpWhiteList[i],PaybackBalances[i],redeemColFee);\r\n        } \r\n    }\r\n    /**\r\n     * @dev calculate user's input collateral balance and premium collateral balance.\r\n     *      Specially used for user's redeem collateral.\r\n     * @param account the recieptor account.\r\n     * @param userTotalWorth the user's total FPTCoin worth, priced in USD.\r\n     * @param tmpWhiteList the settlement coin white list\r\n     * @param _RealBalances the real Collateral balance.\r\n     * @param prices the collateral prices list.\r\n     */\r\n    function getCollateralAndPremiumBalances(address account,uint256 userTotalWorth,address[] memory tmpWhiteList,\r\n        uint256[] memory _RealBalances,uint256[] memory prices) public view returns(uint256[] memory,uint256[] memory){\r\n//        uint256 ln = tmpWhiteList.length;\r\n        uint256[] memory colBalances = new uint256[](tmpWhiteList.length);\r\n        uint256[] memory PremiumBalances = new uint256[](tmpWhiteList.length);\r\n        uint256 totalWorth = 0;\r\n        uint256 PremiumWorth = 0;\r\n        uint256 i=0;\r\n        for(; i<tmpWhiteList.length;i++){\r\n            (colBalances[i],PremiumBalances[i]) = calUserNetWorthBalanceRate(tmpWhiteList[i],account,_RealBalances[i]);\r\n            totalWorth = totalWorth.add(prices[i]*colBalances[i]);\r\n            PremiumWorth = PremiumWorth.add(prices[i]*PremiumBalances[i]);\r\n        }\r\n        if (totalWorth >= userTotalWorth){\r\n            for (i=0; i<tmpWhiteList.length;i++){\r\n                colBalances[i] = colBalances[i].mul(userTotalWorth)/totalWorth;\r\n            }\r\n        }else if (PremiumWorth>0){\r\n            userTotalWorth = userTotalWorth - totalWorth;\r\n            for (i=0; i<tmpWhiteList.length;i++){\r\n                PremiumBalances[i] = PremiumBalances[i].mul(userTotalWorth)/PremiumWorth;\r\n            }\r\n        }\r\n        return (colBalances,PremiumBalances);\r\n    } \r\n    /**\r\n     * @dev calculate user's input collateral balance.\r\n     *      Specially used for user's redeem collateral.\r\n     * @param settlement the settlement coin address.\r\n     * @param user the recieptor account.\r\n     * @param netWorthBalance the settlement coin real balance\r\n     */\r\n    function calUserNetWorthBalanceRate(address settlement,address user,uint256 netWorthBalance)internal view returns(uint256,uint256){\r\n        uint256 collateralBalance = collateralBalances[settlement];\r\n        uint256 amount = userInputCollateral[user][settlement];\r\n        if (collateralBalance > 0){\r\n            uint256 curAmount = netWorthBalance.mul(amount)/collateralBalance;\r\n            return (curAmount,netWorthBalance.sub(curAmount));\r\n        }else{\r\n            return (0,netWorthBalance);\r\n        }\r\n    }\r\n    function getAllRealBalance(address[] memory whiteList)public view returns(int256[] memory){\r\n        uint256 len = whiteList.length;\r\n        int256[] memory realBalances = new int256[](len); \r\n        for (uint i = 0;i<len;i++){\r\n            int256 latestWorth = _optionsPool.getNetWrothLatestWorth(whiteList[i]);\r\n            realBalances[i] = netWorthBalances[whiteList[i]].add(latestWorth);\r\n        }\r\n        return realBalances;\r\n    }\r\n        /**\r\n     * @dev Retrieve the balance of collateral, the auxiliary function for the total collateral calculation. \r\n     */\r\n    function getRealBalance(address settlement)public view returns(int256){\r\n        int256 latestWorth = _optionsPool.getNetWrothLatestWorth(settlement);\r\n        return netWorthBalances[settlement].add(latestWorth);\r\n    }\r\n    function getNetWorthBalance(address settlement)public view returns(uint256){\r\n        int256 latestWorth = _optionsPool.getNetWrothLatestWorth(settlement);\r\n        int256 netWorth = netWorthBalances[settlement].add(latestWorth);\r\n        if (netWorth>0){\r\n            return uint256(netWorth);\r\n        }\r\n        return 0;\r\n    }\r\n        /**\r\n     * @dev  The foundation operator want to add some coin to netbalance, which can increase the FPTCoin net worth.\r\n     * @param settlement the settlement coin address which the foundation operator want to transfer in this contract address.\r\n     * @param amount the amount of the settlement coin which the foundation operator want to transfer in this contract address.\r\n     */\r\n    function addNetBalance(address settlement,uint256 amount) public payable {\r\n        amount = getPayableAmount(settlement,amount);\r\n        netWorthBalances[settlement] = netWorthBalances[settlement].add(int256(amount));\r\n    }\r\n        /**\r\n     * @dev the auxiliary function for getting user's transer\r\n     */\r\n    function getPayableAmount(address settlement,uint256 settlementAmount) internal returns (uint256) {\r\n        if (settlement == address(0)){\r\n            settlementAmount = msg.value;\r\n        }else if (settlementAmount > 0){\r\n            IERC20 oToken = IERC20(settlement);\r\n            uint256 preBalance = oToken.balanceOf(address(this));\r\n            oToken.transferFrom(msg.sender, address(this), settlementAmount);\r\n            uint256 afterBalance = oToken.balanceOf(address(this));\r\n            require(afterBalance-preBalance==settlementAmount,\"settlement token transfer error!\");\r\n        }\r\n        return settlementAmount;\r\n    }\r\n        /**\r\n     * @dev Calculate the collateral pool shared worth.\r\n     * The foundation operator will invoke this function frequently\r\n     */\r\n    function calSharedPayment(address[] memory _whiteList) public onlyOperatorIndex(0) {\r\n        (uint256 firstOption,int256[] memory latestShared) = _optionsPool.getNetWrothCalInfo(_whiteList);\r\n        uint256 lastOption = _optionsPool.getOptionInfoLength();\r\n        (int256[] memory newNetworth,uint256[] memory sharedBalance,uint256 newFirst) =\r\n                     _optionsPool.calRangeSharedPayment(lastOption,firstOption,lastOption,_whiteList);\r\n        int256[] memory fallBalance = _optionsPool.calculatePhaseOptionsFall(lastOption,newFirst,lastOption,_whiteList);\r\n        for (uint256 i= 0;i<fallBalance.length;i++){\r\n            fallBalance[i] = int256(sharedBalance[i]).sub(latestShared[i]).add(fallBalance[i]);\r\n        }\r\n        setSharedPayment(_whiteList,newNetworth,fallBalance,newFirst);\r\n    }\r\n    /**\r\n     * @dev Set the calculation results of the collateral pool shared worth.\r\n     * The foundation operator will invoke this function frequently\r\n     * @param newNetworth Current expired options' net worth \r\n     * @param sharedBalances All unexpired options' shared balance distributed by time.\r\n     * @param firstOption The new first unexpired option's index.\r\n     */\r\n    function setSharedPayment(address[] memory _whiteList,int256[] memory newNetworth,int256[] memory sharedBalances,uint256 firstOption) public onlyOperatorIndex(0){\r\n        _optionsPool.setSharedState(firstOption,sharedBalances,_whiteList);\r\n        addNetWorthBalances(_whiteList,newNetworth);\r\n    }\r\n}"}}}