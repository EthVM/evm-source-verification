{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ERC20Token.sol":{"content":"pragma solidity >=0.4.22 <0.6.0;\n\ninterface tokenRecipient { \n    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; \n}\n\ncontract TokenERC20 {\n   \n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n \n    uint256 public totalSupply;\n\n  \n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n   \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n  \n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n   \n    event Burn(address indexed from, uint256 value);\n\n   \n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  \n        balanceOf[msg.sender] = totalSupply;                \n        name = tokenName;                               \n        symbol = tokenSymbol;                         \n    }\n\n    \n    function _transfer(address _from, address _to, uint _value) internal {\n       \n        require(_to != address(0x0));\n     \n        require(balanceOf[_from] >= _value);\n     \n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n      \n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n       \n        balanceOf[_from] -= _value;\n       \n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n       \n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    \n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     \n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    \n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    \n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n   \n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        emit Burn(_from, _value);\n        return true;\n    }\n}\n"}}}