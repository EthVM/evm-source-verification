{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":100},"remappings":[],"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}},"sources":{"@openzeppelin/contracts-ethereum-package/contracts/introspection/IERC165.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"@openzeppelin/contracts-ethereum-package/contracts/math/Math.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"},"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Multiplies two signed integers, reverts on overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two signed integers, reverts on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two signed integers, reverts on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"},"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721.sol":{"content":"pragma solidity ^0.6.2;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"},"contracts/external/FixedPoint.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\n// solhint-disable\n// Imported from https://github.com/UMAprotocol/protocol/blob/4d1c8cc47a4df5e79f978cb05647a7432e111a3d/packages/core/contracts/common/implementation/FixedPoint.sol\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol\";\n\n/**\n * @title Library for fixed point arithmetic on uints\n */\nlibrary FixedPoint {\n  using SafeMath for uint256;\n  using SignedSafeMath for int256;\n\n  // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n  // For unsigned values:\n  //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n  uint256 private constant FP_SCALING_FACTOR = 10**18;\n\n  // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\n  struct Unsigned {\n    uint256 rawValue;\n  }\n\n  /**\n   * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5**18`.\n   * @param a uint to convert into a FixedPoint.\n   * @return the converted FixedPoint.\n   */\n  function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n    return Unsigned(a.mul(FP_SCALING_FACTOR));\n  }\n\n  /**\n   * @notice Whether `a` is equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if equal, or False.\n   */\n  function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue == fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if equal, or False.\n   */\n  function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue == b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue > b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue > fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n    return fromUnscaledUint(a).rawValue > b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue >= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue >= fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n    return fromUnscaledUint(a).rawValue >= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue < b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue < fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n    return fromUnscaledUint(a).rawValue < b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue <= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue <= fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n    return fromUnscaledUint(a).rawValue <= b.rawValue;\n  }\n\n  /**\n   * @notice The minimum of `a` and `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the minimum of `a` and `b`.\n   */\n  function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return a.rawValue < b.rawValue ? a : b;\n  }\n\n  /**\n   * @notice The maximum of `a` and `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the maximum of `a` and `b`.\n   */\n  function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return a.rawValue > b.rawValue ? a : b;\n  }\n\n  /**\n   * @notice Adds two `Unsigned`s, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the sum of `a` and `b`.\n   */\n  function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return Unsigned(a.rawValue.add(b.rawValue));\n  }\n\n  /**\n   * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return the sum of `a` and `b`.\n   */\n  function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    return add(a, fromUnscaledUint(b));\n  }\n\n  /**\n   * @notice Subtracts two `Unsigned`s, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return Unsigned(a.rawValue.sub(b.rawValue));\n  }\n\n  /**\n   * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    return sub(a, fromUnscaledUint(b));\n  }\n\n  /**\n   * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return sub(fromUnscaledUint(a), b);\n  }\n\n  /**\n   * @notice Multiplies two `Unsigned`s, reverting on overflow.\n   * @dev This will \"floor\" the product.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the product of `a` and `b`.\n   */\n  function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    // There are two caveats with this computation:\n    // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n    // stored internally as a uint256 ~10^59.\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n    // would round to 3, but this computation produces the result 2.\n    // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n    return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\n  }\n\n  /**\n   * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n   * @dev This will \"floor\" the product.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return the product of `a` and `b`.\n   */\n  function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    return Unsigned(a.rawValue.mul(b));\n  }\n\n  /**\n   * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the product of `a` and `b`.\n   */\n  function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    uint256 mulRaw = a.rawValue.mul(b.rawValue);\n    uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n    uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n    if (mod != 0) {\n      return Unsigned(mulFloor.add(1));\n    } else {\n      return Unsigned(mulFloor);\n    }\n  }\n\n  /**\n   * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the product of `a` and `b`.\n   */\n  function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    // Since b is an int, there is no risk of truncation and we can just mul it normally\n    return Unsigned(a.rawValue.mul(b));\n  }\n\n  /**\n   * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a FixedPoint numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    // There are two caveats with this computation:\n    // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n    // 10^41 is stored internally as a uint256 10^59.\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n    // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n    return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\n  }\n\n  /**\n   * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a FixedPoint numerator.\n   * @param b a uint256 denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    return Unsigned(a.rawValue.div(b));\n  }\n\n  /**\n   * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a uint256 numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return div(fromUnscaledUint(a), b);\n  }\n\n  /**\n   * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n   * @param a a FixedPoint numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n    uint256 divFloor = aScaled.div(b.rawValue);\n    uint256 mod = aScaled.mod(b.rawValue);\n    if (mod != 0) {\n      return Unsigned(divFloor.add(1));\n    } else {\n      return Unsigned(divFloor);\n    }\n  }\n\n  /**\n   * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n   * @param a a FixedPoint numerator.\n   * @param b a uint256 denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\n    // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n    // This creates the possibility of overflow if b is very large.\n    return divCeil(a, fromUnscaledUint(b));\n  }\n\n  /**\n   * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n   * @dev This will \"floor\" the result.\n   * @param a a FixedPoint numerator.\n   * @param b a uint256 denominator.\n   * @return output is `a` to the power of `b`.\n   */\n  function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n    output = fromUnscaledUint(1);\n    for (uint256 i = 0; i < b; i = i.add(1)) {\n      output = mul(output, a);\n    }\n  }\n\n  // ------------------------------------------------- SIGNED -------------------------------------------------------------\n  // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n  // For signed values:\n  //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\n  int256 private constant SFP_SCALING_FACTOR = 10**18;\n\n  struct Signed {\n    int256 rawValue;\n  }\n\n  function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\n    require(a.rawValue >= 0, \"Negative value provided\");\n    return Unsigned(uint256(a.rawValue));\n  }\n\n  function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\n    require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\n    return Signed(int256(a.rawValue));\n  }\n\n  /**\n   * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5**18`.\n   * @param a int to convert into a FixedPoint.Signed.\n   * @return the converted FixedPoint.Signed.\n   */\n  function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\n    return Signed(a.mul(SFP_SCALING_FACTOR));\n  }\n\n  /**\n   * @notice Whether `a` is equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a int256.\n   * @return True if equal, or False.\n   */\n  function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue == fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if equal, or False.\n   */\n  function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue == b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue > b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue > fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\n    return fromUnscaledInt(a).rawValue > b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue >= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue >= fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n    return fromUnscaledInt(a).rawValue >= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue < b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue < fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\n    return fromUnscaledInt(a).rawValue < b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue <= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue <= fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n    return fromUnscaledInt(a).rawValue <= b.rawValue;\n  }\n\n  /**\n   * @notice The minimum of `a` and `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the minimum of `a` and `b`.\n   */\n  function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    return a.rawValue < b.rawValue ? a : b;\n  }\n\n  /**\n   * @notice The maximum of `a` and `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the maximum of `a` and `b`.\n   */\n  function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    return a.rawValue > b.rawValue ? a : b;\n  }\n\n  /**\n   * @notice Adds two `Signed`s, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the sum of `a` and `b`.\n   */\n  function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    return Signed(a.rawValue.add(b.rawValue));\n  }\n\n  /**\n   * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return the sum of `a` and `b`.\n   */\n  function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    return add(a, fromUnscaledInt(b));\n  }\n\n  /**\n   * @notice Subtracts two `Signed`s, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    return Signed(a.rawValue.sub(b.rawValue));\n  }\n\n  /**\n   * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    return sub(a, fromUnscaledInt(b));\n  }\n\n  /**\n   * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\n    return sub(fromUnscaledInt(a), b);\n  }\n\n  /**\n   * @notice Multiplies two `Signed`s, reverting on overflow.\n   * @dev This will \"floor\" the product.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the product of `a` and `b`.\n   */\n  function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    // There are two caveats with this computation:\n    // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n    // stored internally as an int256 ~10^59.\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n    // would round to 3, but this computation produces the result 2.\n    // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\n    return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\n  }\n\n  /**\n   * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\n   * @dev This will \"floor\" the product.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return the product of `a` and `b`.\n   */\n  function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    return Signed(a.rawValue.mul(b));\n  }\n\n  /**\n   * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the product of `a` and `b`.\n   */\n  function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    int256 mulRaw = a.rawValue.mul(b.rawValue);\n    int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\n    // Manual mod because SignedSafeMath doesn't support it.\n    int256 mod = mulRaw % SFP_SCALING_FACTOR;\n    if (mod != 0) {\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n      return Signed(mulTowardsZero.add(valueToAdd));\n    } else {\n      return Signed(mulTowardsZero);\n    }\n  }\n\n  /**\n   * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the product of `a` and `b`.\n   */\n  function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    // Since b is an int, there is no risk of truncation and we can just mul it normally\n    return Signed(a.rawValue.mul(b));\n  }\n\n  /**\n   * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a FixedPoint numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    // There are two caveats with this computation:\n    // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n    // 10^41 is stored internally as an int256 10^59.\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n    // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n    return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\n  }\n\n  /**\n   * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a FixedPoint numerator.\n   * @param b an int256 denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    return Signed(a.rawValue.div(b));\n  }\n\n  /**\n   * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a an int256 numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\n    return div(fromUnscaledInt(a), b);\n  }\n\n  /**\n   * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n   * @param a a FixedPoint numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\n    int256 divTowardsZero = aScaled.div(b.rawValue);\n    // Manual mod because SignedSafeMath doesn't support it.\n    int256 mod = aScaled % b.rawValue;\n    if (mod != 0) {\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n      return Signed(divTowardsZero.add(valueToAdd));\n    } else {\n      return Signed(divTowardsZero);\n    }\n  }\n\n  /**\n   * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n   * @param a a FixedPoint numerator.\n   * @param b an int256 denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\n    // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\n    // This creates the possibility of overflow if b is very large.\n    return divAwayFromZero(a, fromUnscaledInt(b));\n  }\n\n  /**\n   * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n   * @dev This will \"floor\" the result.\n   * @param a a FixedPoint.Signed.\n   * @param b a uint256 (negative exponents are not allowed).\n   * @return output is `a` to the power of `b`.\n   */\n  function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\n    output = fromUnscaledInt(1);\n    for (uint256 i = 0; i < b; i = i.add(1)) {\n      output = mul(output, a);\n    }\n  }\n}\n"},"contracts/interfaces/ICreditLine.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface ICreditLine {\n  function borrower() external view returns (address);\n\n  function limit() external view returns (uint256);\n\n  function maxLimit() external view returns (uint256);\n\n  function interestApr() external view returns (uint256);\n\n  function paymentPeriodInDays() external view returns (uint256);\n\n  function principalGracePeriodInDays() external view returns (uint256);\n\n  function termInDays() external view returns (uint256);\n\n  function lateFeeApr() external view returns (uint256);\n\n  function isLate() external view returns (bool);\n\n  function withinPrincipalGracePeriod() external view returns (bool);\n\n  // Accounting variables\n  function balance() external view returns (uint256);\n\n  function interestOwed() external view returns (uint256);\n\n  function principalOwed() external view returns (uint256);\n\n  function termEndTime() external view returns (uint256);\n\n  function nextDueTime() external view returns (uint256);\n\n  function interestAccruedAsOf() external view returns (uint256);\n\n  function lastFullPaymentTime() external view returns (uint256);\n}\n"},"contracts/interfaces/IPoolTokens.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721.sol\";\n\ninterface IPoolTokens is IERC721 {\n  event TokenMinted(\n    address indexed owner,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 amount,\n    uint256 tranche\n  );\n\n  event TokenRedeemed(\n    address indexed owner,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 principalRedeemed,\n    uint256 interestRedeemed,\n    uint256 tranche\n  );\n  event TokenBurned(address indexed owner, address indexed pool, uint256 indexed tokenId);\n\n  struct TokenInfo {\n    address pool;\n    uint256 tranche;\n    uint256 principalAmount;\n    uint256 principalRedeemed;\n    uint256 interestRedeemed;\n  }\n\n  struct MintParams {\n    uint256 principalAmount;\n    uint256 tranche;\n  }\n\n  function mint(MintParams calldata params, address to) external returns (uint256);\n\n  function redeem(\n    uint256 tokenId,\n    uint256 principalRedeemed,\n    uint256 interestRedeemed\n  ) external;\n\n  function burn(uint256 tokenId) external;\n\n  function onPoolCreated(address newPool) external;\n\n  function getTokenInfo(uint256 tokenId) external view returns (TokenInfo memory);\n\n  function validPool(address sender) external view returns (bool);\n\n  function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\n}\n"},"contracts/interfaces/ITranchedPool.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./IV2CreditLine.sol\";\n\nabstract contract ITranchedPool {\n  IV2CreditLine public creditLine;\n  uint256 public createdAt;\n\n  enum Tranches {\n    Reserved,\n    Senior,\n    Junior\n  }\n\n  struct TrancheInfo {\n    uint256 id;\n    uint256 principalDeposited;\n    uint256 principalSharePrice;\n    uint256 interestSharePrice;\n    uint256 lockedUntil;\n  }\n\n  struct PoolSlice {\n    TrancheInfo seniorTranche;\n    TrancheInfo juniorTranche;\n    uint256 totalInterestAccrued;\n    uint256 principalDeployed;\n  }\n\n  struct SliceInfo {\n    uint256 reserveFeePercent;\n    uint256 interestAccrued;\n    uint256 principalAccrued;\n  }\n\n  struct ApplyResult {\n    uint256 interestRemaining;\n    uint256 principalRemaining;\n    uint256 reserveDeduction;\n    uint256 oldInterestSharePrice;\n    uint256 oldPrincipalSharePrice;\n  }\n\n  function initialize(\n    address _config,\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays,\n    uint256 _fundableAt,\n    uint256[] calldata _allowedUIDTypes\n  ) public virtual;\n\n  function getTranche(uint256 tranche) external view virtual returns (TrancheInfo memory);\n\n  function pay(uint256 amount) external virtual;\n\n  function lockJuniorCapital() external virtual;\n\n  function lockPool() external virtual;\n\n  function initializeNextSlice(uint256 _fundableAt) external virtual;\n\n  function totalJuniorDeposits() external view virtual returns (uint256);\n\n  function drawdown(uint256 amount) external virtual;\n\n  function setFundableAt(uint256 timestamp) external virtual;\n\n  function deposit(uint256 tranche, uint256 amount) external virtual returns (uint256 tokenId);\n\n  function assess() external virtual;\n\n  function depositWithPermit(\n    uint256 tranche,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual returns (uint256 tokenId);\n\n  function availableToWithdraw(uint256 tokenId)\n    external\n    view\n    virtual\n    returns (uint256 interestRedeemable, uint256 principalRedeemable);\n\n  function withdraw(uint256 tokenId, uint256 amount)\n    external\n    virtual\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\n\n  function withdrawMax(uint256 tokenId)\n    external\n    virtual\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\n\n  function withdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata amounts) external virtual;\n}\n"},"contracts/interfaces/IV2CreditLine.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./ICreditLine.sol\";\n\nabstract contract IV2CreditLine is ICreditLine {\n  function principal() external view virtual returns (uint256);\n\n  function totalInterestAccrued() external view virtual returns (uint256);\n\n  function termStartTime() external view virtual returns (uint256);\n\n  function setLimit(uint256 newAmount) external virtual;\n\n  function setMaxLimit(uint256 newAmount) external virtual;\n\n  function setBalance(uint256 newBalance) external virtual;\n\n  function setPrincipal(uint256 _principal) external virtual;\n\n  function setTotalInterestAccrued(uint256 _interestAccrued) external virtual;\n\n  function drawdown(uint256 amount) external virtual;\n\n  function assess()\n    external\n    virtual\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function initialize(\n    address _config,\n    address owner,\n    address _borrower,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays\n  ) public virtual;\n\n  function setTermEndTime(uint256 newTermEndTime) external virtual;\n\n  function setNextDueTime(uint256 newNextDueTime) external virtual;\n\n  function setInterestOwed(uint256 newInterestOwed) external virtual;\n\n  function setPrincipalOwed(uint256 newPrincipalOwed) external virtual;\n\n  function setInterestAccruedAsOf(uint256 newInterestAccruedAsOf) external virtual;\n\n  function setWritedownAmount(uint256 newWritedownAmount) external virtual;\n\n  function setLastFullPaymentTime(uint256 newLastFullPaymentTime) external virtual;\n\n  function setLateFeeApr(uint256 newLateFeeApr) external virtual;\n\n  function updateGoldfinchConfig() external virtual;\n}\n"},"contracts/protocol/core/TranchingLogic.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/IV2CreditLine.sol\";\nimport \"../../interfaces/ITranchedPool.sol\";\nimport \"../../interfaces/IPoolTokens.sol\";\nimport \"../../external/FixedPoint.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\n\n/**\n * @title TranchingLogic\n * @notice Library for handling the payments waterfall\n * @author Goldfinch\n */\n\nlibrary TranchingLogic {\n  using SafeMath for uint256;\n  using FixedPoint for FixedPoint.Unsigned;\n  using FixedPoint for uint256;\n\n  event SharePriceUpdated(\n    address indexed pool,\n    uint256 indexed tranche,\n    uint256 principalSharePrice,\n    int256 principalDelta,\n    uint256 interestSharePrice,\n    int256 interestDelta\n  );\n\n  uint256 public constant FP_SCALING_FACTOR = 1e18;\n  uint256 public constant ONE_HUNDRED = 100; // Need this because we cannot call .div on a literal 100\n\n  function usdcToSharePrice(uint256 amount, uint256 totalShares) public pure returns (uint256) {\n    return totalShares == 0 ? 0 : amount.mul(FP_SCALING_FACTOR).div(totalShares);\n  }\n\n  function sharePriceToUsdc(uint256 sharePrice, uint256 totalShares) public pure returns (uint256) {\n    return sharePrice.mul(totalShares).div(FP_SCALING_FACTOR);\n  }\n\n  function redeemableInterestAndPrincipal(\n    ITranchedPool.TrancheInfo storage trancheInfo,\n    IPoolTokens.TokenInfo memory tokenInfo\n  ) public view returns (uint256 interestRedeemable, uint256 principalRedeemable) {\n    // This supports withdrawing before or after locking because principal share price starts at 1\n    // and is set to 0 on lock. Interest share price is always 0 until interest payments come back, when it increases\n    uint256 maxPrincipalRedeemable = sharePriceToUsdc(trancheInfo.principalSharePrice, tokenInfo.principalAmount);\n    // The principalAmount is used as the totalShares because we want the interestSharePrice to be expressed as a\n    // percent of total loan value e.g. if the interest is 10% APR, the interestSharePrice should approach a max of 0.1.\n    uint256 maxInterestRedeemable = sharePriceToUsdc(trancheInfo.interestSharePrice, tokenInfo.principalAmount);\n\n    interestRedeemable = maxInterestRedeemable.sub(tokenInfo.interestRedeemed);\n    principalRedeemable = maxPrincipalRedeemable.sub(tokenInfo.principalRedeemed);\n\n    return (interestRedeemable, principalRedeemable);\n  }\n\n  function calculateExpectedSharePrice(\n    ITranchedPool.TrancheInfo memory tranche,\n    uint256 amount,\n    ITranchedPool.PoolSlice memory slice\n  ) public pure returns (uint256) {\n    uint256 sharePrice = usdcToSharePrice(amount, tranche.principalDeposited);\n    return scaleByPercentOwnership(tranche, sharePrice, slice);\n  }\n\n  function scaleForSlice(\n    ITranchedPool.PoolSlice memory slice,\n    uint256 amount,\n    uint256 totalDeployed\n  ) public pure returns (uint256) {\n    return scaleByFraction(amount, slice.principalDeployed, totalDeployed);\n  }\n\n  // We need to create this struct so we don't run into a stack too deep error due to too many variables\n  function getSliceInfo(\n    ITranchedPool.PoolSlice memory slice,\n    IV2CreditLine creditLine,\n    uint256 totalDeployed,\n    uint256 reserveFeePercent\n  ) public view returns (ITranchedPool.SliceInfo memory) {\n    (uint256 interestAccrued, uint256 principalAccrued) = getTotalInterestAndPrincipal(\n      slice,\n      creditLine,\n      totalDeployed\n    );\n    return\n      ITranchedPool.SliceInfo({\n        reserveFeePercent: reserveFeePercent,\n        interestAccrued: interestAccrued,\n        principalAccrued: principalAccrued\n      });\n  }\n\n  function getTotalInterestAndPrincipal(\n    ITranchedPool.PoolSlice memory slice,\n    IV2CreditLine creditLine,\n    uint256 totalDeployed\n  ) public view returns (uint256 interestAccrued, uint256 principalAccrued) {\n    principalAccrued = creditLine.principalOwed();\n    // In addition to principal actually owed, we need to account for early principal payments\n    // If the borrower pays back 5K early on a 10K loan, the actual principal accrued should be\n    // 5K (balance- deployed) + 0 (principal owed)\n    principalAccrued = totalDeployed.sub(creditLine.balance()).add(principalAccrued);\n    // Now we need to scale that correctly for the slice we're interested in\n    principalAccrued = scaleForSlice(slice, principalAccrued, totalDeployed);\n    // Finally, we need to account for partial drawdowns. e.g. If 20K was deposited, and only 10K was drawn down,\n    // Then principal accrued should start at 10K (total deposited - principal deployed), not 0. This is because\n    // share price starts at 1, and is decremented by what was drawn down.\n    uint256 totalDeposited = slice.seniorTranche.principalDeposited.add(slice.juniorTranche.principalDeposited);\n    principalAccrued = totalDeposited.sub(slice.principalDeployed).add(principalAccrued);\n    return (slice.totalInterestAccrued, principalAccrued);\n  }\n\n  function scaleByFraction(\n    uint256 amount,\n    uint256 fraction,\n    uint256 total\n  ) public pure returns (uint256) {\n    FixedPoint.Unsigned memory totalAsFixedPoint = FixedPoint.fromUnscaledUint(total);\n    FixedPoint.Unsigned memory fractionAsFixedPoint = FixedPoint.fromUnscaledUint(fraction);\n    return fractionAsFixedPoint.div(totalAsFixedPoint).mul(amount).div(FP_SCALING_FACTOR).rawValue;\n  }\n\n  function applyToAllSeniorTranches(\n    ITranchedPool.PoolSlice[] storage poolSlices,\n    uint256 interest,\n    uint256 principal,\n    uint256 reserveFeePercent,\n    uint256 totalDeployed,\n    IV2CreditLine creditLine,\n    uint256 juniorFeePercent\n  ) public returns (ITranchedPool.ApplyResult memory) {\n    ITranchedPool.ApplyResult memory seniorApplyResult;\n    for (uint256 i = 0; i < poolSlices.length; i++) {\n      ITranchedPool.SliceInfo memory sliceInfo = getSliceInfo(\n        poolSlices[i],\n        creditLine,\n        totalDeployed,\n        reserveFeePercent\n      );\n\n      // Since slices cannot be created when the loan is late, all interest collected can be assumed to split\n      // pro-rata across the slices. So we scale the interest and principal to the slice\n      ITranchedPool.ApplyResult memory applyResult = applyToSeniorTranche(\n        poolSlices[i],\n        scaleForSlice(poolSlices[i], interest, totalDeployed),\n        scaleForSlice(poolSlices[i], principal, totalDeployed),\n        juniorFeePercent,\n        sliceInfo\n      );\n      emitSharePriceUpdatedEvent(poolSlices[i].seniorTranche, applyResult);\n      seniorApplyResult.interestRemaining = seniorApplyResult.interestRemaining.add(applyResult.interestRemaining);\n      seniorApplyResult.principalRemaining = seniorApplyResult.principalRemaining.add(applyResult.principalRemaining);\n      seniorApplyResult.reserveDeduction = seniorApplyResult.reserveDeduction.add(applyResult.reserveDeduction);\n    }\n    return seniorApplyResult;\n  }\n\n  function applyToAllJuniorTranches(\n    ITranchedPool.PoolSlice[] storage poolSlices,\n    uint256 interest,\n    uint256 principal,\n    uint256 reserveFeePercent,\n    uint256 totalDeployed,\n    IV2CreditLine creditLine\n  ) public returns (uint256 totalReserveAmount) {\n    for (uint256 i = 0; i < poolSlices.length; i++) {\n      ITranchedPool.SliceInfo memory sliceInfo = getSliceInfo(\n        poolSlices[i],\n        creditLine,\n        totalDeployed,\n        reserveFeePercent\n      );\n      // Any remaining interest and principal is then shared pro-rata with the junior slices\n      ITranchedPool.ApplyResult memory applyResult = applyToJuniorTranche(\n        poolSlices[i],\n        scaleForSlice(poolSlices[i], interest, totalDeployed),\n        scaleForSlice(poolSlices[i], principal, totalDeployed),\n        sliceInfo\n      );\n      emitSharePriceUpdatedEvent(poolSlices[i].juniorTranche, applyResult);\n      totalReserveAmount = totalReserveAmount.add(applyResult.reserveDeduction);\n    }\n    return totalReserveAmount;\n  }\n\n  function emitSharePriceUpdatedEvent(\n    ITranchedPool.TrancheInfo memory tranche,\n    ITranchedPool.ApplyResult memory applyResult\n  ) internal {\n    emit SharePriceUpdated(\n      address(this),\n      tranche.id,\n      tranche.principalSharePrice,\n      int256(tranche.principalSharePrice.sub(applyResult.oldPrincipalSharePrice)),\n      tranche.interestSharePrice,\n      int256(tranche.interestSharePrice.sub(applyResult.oldInterestSharePrice))\n    );\n  }\n\n  function applyToSeniorTranche(\n    ITranchedPool.PoolSlice storage slice,\n    uint256 interestRemaining,\n    uint256 principalRemaining,\n    uint256 juniorFeePercent,\n    ITranchedPool.SliceInfo memory sliceInfo\n  ) public returns (ITranchedPool.ApplyResult memory) {\n    // First determine the expected share price for the senior tranche. This is the gross amount the senior\n    // tranche should receive.\n    uint256 expectedInterestSharePrice = calculateExpectedSharePrice(\n      slice.seniorTranche,\n      sliceInfo.interestAccrued,\n      slice\n    );\n    uint256 expectedPrincipalSharePrice = calculateExpectedSharePrice(\n      slice.seniorTranche,\n      sliceInfo.principalAccrued,\n      slice\n    );\n\n    // Deduct the junior fee and the protocol reserve\n    uint256 desiredNetInterestSharePrice = scaleByFraction(\n      expectedInterestSharePrice,\n      ONE_HUNDRED.sub(juniorFeePercent.add(sliceInfo.reserveFeePercent)),\n      ONE_HUNDRED\n    );\n    // Collect protocol fee interest received (we've subtracted this from the senior portion above)\n    uint256 reserveDeduction = scaleByFraction(interestRemaining, sliceInfo.reserveFeePercent, ONE_HUNDRED);\n    interestRemaining = interestRemaining.sub(reserveDeduction);\n    uint256 oldInterestSharePrice = slice.seniorTranche.interestSharePrice;\n    uint256 oldPrincipalSharePrice = slice.seniorTranche.principalSharePrice;\n    // Apply the interest remaining so we get up to the netInterestSharePrice\n    (interestRemaining, principalRemaining) = applyBySharePrice(\n      slice.seniorTranche,\n      interestRemaining,\n      principalRemaining,\n      desiredNetInterestSharePrice,\n      expectedPrincipalSharePrice\n    );\n    return\n      ITranchedPool.ApplyResult({\n        interestRemaining: interestRemaining,\n        principalRemaining: principalRemaining,\n        reserveDeduction: reserveDeduction,\n        oldInterestSharePrice: oldInterestSharePrice,\n        oldPrincipalSharePrice: oldPrincipalSharePrice\n      });\n  }\n\n  function applyToJuniorTranche(\n    ITranchedPool.PoolSlice storage slice,\n    uint256 interestRemaining,\n    uint256 principalRemaining,\n    ITranchedPool.SliceInfo memory sliceInfo\n  ) public returns (ITranchedPool.ApplyResult memory) {\n    // Then fill up the junior tranche with all the interest remaining, upto the principal share price\n    uint256 expectedInterestSharePrice = slice.juniorTranche.interestSharePrice.add(\n      usdcToSharePrice(interestRemaining, slice.juniorTranche.principalDeposited)\n    );\n    uint256 expectedPrincipalSharePrice = calculateExpectedSharePrice(\n      slice.juniorTranche,\n      sliceInfo.principalAccrued,\n      slice\n    );\n    uint256 oldInterestSharePrice = slice.juniorTranche.interestSharePrice;\n    uint256 oldPrincipalSharePrice = slice.juniorTranche.principalSharePrice;\n    (interestRemaining, principalRemaining) = applyBySharePrice(\n      slice.juniorTranche,\n      interestRemaining,\n      principalRemaining,\n      expectedInterestSharePrice,\n      expectedPrincipalSharePrice\n    );\n\n    // All remaining interest and principal is applied towards the junior tranche as interest\n    interestRemaining = interestRemaining.add(principalRemaining);\n    // Since any principal remaining is treated as interest (there is \"extra\" interest to be distributed)\n    // we need to make sure to collect the protocol fee on the additional interest (we only deducted the\n    // fee on the original interest portion)\n    uint256 reserveDeduction = scaleByFraction(principalRemaining, sliceInfo.reserveFeePercent, ONE_HUNDRED);\n    interestRemaining = interestRemaining.sub(reserveDeduction);\n    principalRemaining = 0;\n\n    (interestRemaining, principalRemaining) = applyByAmount(\n      slice.juniorTranche,\n      interestRemaining.add(principalRemaining),\n      0,\n      interestRemaining.add(principalRemaining),\n      0\n    );\n    return\n      ITranchedPool.ApplyResult({\n        interestRemaining: interestRemaining,\n        principalRemaining: principalRemaining,\n        reserveDeduction: reserveDeduction,\n        oldInterestSharePrice: oldInterestSharePrice,\n        oldPrincipalSharePrice: oldPrincipalSharePrice\n      });\n  }\n\n  function applyBySharePrice(\n    ITranchedPool.TrancheInfo storage tranche,\n    uint256 interestRemaining,\n    uint256 principalRemaining,\n    uint256 desiredInterestSharePrice,\n    uint256 desiredPrincipalSharePrice\n  ) public returns (uint256, uint256) {\n    uint256 desiredInterestAmount = desiredAmountFromSharePrice(\n      desiredInterestSharePrice,\n      tranche.interestSharePrice,\n      tranche.principalDeposited\n    );\n    uint256 desiredPrincipalAmount = desiredAmountFromSharePrice(\n      desiredPrincipalSharePrice,\n      tranche.principalSharePrice,\n      tranche.principalDeposited\n    );\n    return applyByAmount(tranche, interestRemaining, principalRemaining, desiredInterestAmount, desiredPrincipalAmount);\n  }\n\n  function applyByAmount(\n    ITranchedPool.TrancheInfo storage tranche,\n    uint256 interestRemaining,\n    uint256 principalRemaining,\n    uint256 desiredInterestAmount,\n    uint256 desiredPrincipalAmount\n  ) public returns (uint256, uint256) {\n    uint256 totalShares = tranche.principalDeposited;\n    uint256 newSharePrice;\n\n    (interestRemaining, newSharePrice) = applyToSharePrice(\n      interestRemaining,\n      tranche.interestSharePrice,\n      desiredInterestAmount,\n      totalShares\n    );\n    tranche.interestSharePrice = newSharePrice;\n\n    (principalRemaining, newSharePrice) = applyToSharePrice(\n      principalRemaining,\n      tranche.principalSharePrice,\n      desiredPrincipalAmount,\n      totalShares\n    );\n    tranche.principalSharePrice = newSharePrice;\n    return (interestRemaining, principalRemaining);\n  }\n\n  function migrateAccountingVariables(address originalClAddr, address newClAddr) public {\n    IV2CreditLine originalCl = IV2CreditLine(originalClAddr);\n    IV2CreditLine newCl = IV2CreditLine(newClAddr);\n\n    // Copy over all accounting variables\n    newCl.setBalance(originalCl.balance());\n    newCl.setLimit(originalCl.limit());\n    newCl.setInterestOwed(originalCl.interestOwed());\n    newCl.setPrincipalOwed(originalCl.principalOwed());\n    newCl.setTermEndTime(originalCl.termEndTime());\n    newCl.setNextDueTime(originalCl.nextDueTime());\n    newCl.setInterestAccruedAsOf(originalCl.interestAccruedAsOf());\n    newCl.setLastFullPaymentTime(originalCl.lastFullPaymentTime());\n    newCl.setTotalInterestAccrued(originalCl.totalInterestAccrued());\n  }\n\n  function closeCreditLine(address originalCl) public {\n    // Close out old CL\n    IV2CreditLine oldCreditLine = IV2CreditLine(originalCl);\n    oldCreditLine.setBalance(0);\n    oldCreditLine.setLimit(0);\n    oldCreditLine.setMaxLimit(0);\n  }\n\n  function desiredAmountFromSharePrice(\n    uint256 desiredSharePrice,\n    uint256 actualSharePrice,\n    uint256 totalShares\n  ) public pure returns (uint256) {\n    // If the desired share price is lower, then ignore it, and leave it unchanged\n    if (desiredSharePrice < actualSharePrice) {\n      desiredSharePrice = actualSharePrice;\n    }\n    uint256 sharePriceDifference = desiredSharePrice.sub(actualSharePrice);\n    return sharePriceToUsdc(sharePriceDifference, totalShares);\n  }\n\n  function applyToSharePrice(\n    uint256 amountRemaining,\n    uint256 currentSharePrice,\n    uint256 desiredAmount,\n    uint256 totalShares\n  ) public pure returns (uint256, uint256) {\n    // If no money left to apply, or don't need any changes, return the original amounts\n    if (amountRemaining == 0 || desiredAmount == 0) {\n      return (amountRemaining, currentSharePrice);\n    }\n    if (amountRemaining < desiredAmount) {\n      // We don't have enough money to adjust share price to the desired level. So just use whatever amount is left\n      desiredAmount = amountRemaining;\n    }\n    uint256 sharePriceDifference = usdcToSharePrice(desiredAmount, totalShares);\n    return (amountRemaining.sub(desiredAmount), currentSharePrice.add(sharePriceDifference));\n  }\n\n  function scaleByPercentOwnership(\n    ITranchedPool.TrancheInfo memory tranche,\n    uint256 amount,\n    ITranchedPool.PoolSlice memory slice\n  ) public pure returns (uint256) {\n    uint256 totalDeposited = slice.juniorTranche.principalDeposited.add(slice.seniorTranche.principalDeposited);\n    return scaleByFraction(amount, tranche.principalDeposited, totalDeposited);\n  }\n}\n"}}}