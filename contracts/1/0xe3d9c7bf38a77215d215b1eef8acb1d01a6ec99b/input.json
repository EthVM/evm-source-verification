{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 2900
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "BitGold.sol": {
      "content": "pragma solidity ^0.5.0;\r\n\r\n/*\r\n*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n*@@@@@@@@@@ Website: gold.bitx.network - Telegram: t.me/bitx_network @@@@@@@@@@@@\r\n*@@@@@@@@ Dividends Platform which pays BXTG token holders 10% dividends.@@@@@@@@\r\n*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 0% Transfer Fee @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\r\n*/\r\n\r\n// Interfaces for easy copypasta\r\n\r\ninterface ERC20interface {\r\n\tfunction transfer(address to, uint value) external returns(bool success);\r\n\tfunction approve(address spender, uint tokens) external returns(bool success);\r\n\tfunction transferFrom(address from, address to, uint tokens) external returns(bool success);\r\n\r\n\tfunction allowance(address tokenOwner, address spender) external view returns(uint remaining);\r\n\tfunction balanceOf(address tokenOwner) external view returns(uint balance);\r\n}\r\n\r\ninterface ERC223interface {\r\n\tfunction transfer(address to, uint value) external returns(bool ok);\r\n\tfunction transfer(address to, uint value, bytes calldata data) external returns(bool ok);\r\n\tfunction transfer(address to, uint value, bytes calldata data, string calldata customFallback) external returns(bool ok);\r\n\r\n\tfunction balanceOf(address who) external view returns(uint);\r\n}\r\n\r\n// If your contract wants to accept BXTG, implement this function\r\ninterface ERC223Handler {\r\n\tfunction tokenFallback(address _from, uint _value, bytes calldata _data) external;\r\n}\r\n\r\n// External gauntlet interfaces can be useful for something like voting systems or contests\r\ninterface ExternalGauntletInterface {\r\n\tfunction gauntletRequirement(address wearer, uint256 oldAmount, uint256 newAmount) external returns(bool);\r\n\tfunction gauntletRemovable(address wearer) external view returns(bool);\r\n}\r\n\r\n// This is BITX itself (not a complete interface)\r\ninterface BITX {\r\n\tfunction decimals() external view returns(uint8);\r\n\tfunction stakingRequirement() external view returns(uint256);\r\n\tfunction balanceOf(address tokenOwner) external view returns(uint);\r\n\tfunction dividendsOf(address tokenOwner) external view returns(uint);\r\n\tfunction calculateTokensReceived(uint256 _ethereumToSpend) external view returns(uint256);\r\n\tfunction calculateEthereumReceived(uint256 _tokensToSell) external view returns(uint256);\r\n\tfunction myTokens() external view returns(uint256);\r\n\tfunction myDividends(bool _includeReferralBonus) external view returns(uint256);\r\n\tfunction totalSupply() external view returns(uint256);\r\n\r\n\tfunction transfer(address to, uint value) external returns(bool);\r\n\tfunction buy(address referrer) external payable returns(uint256);\r\n\tfunction sell(uint256 amount) external;\r\n\tfunction withdraw() external;\r\n}\r\n\r\n// Here's an interface in case you want to integration your dApp with this.\r\n// Descriptions of each function are down below in the soure code.\r\n// NOTE: It's not _entirely_ compatible with the BITX interface. myTokens() has been renamed to myBalance().\r\n/*\r\ninterface BitGold {\r\n\tfunction buy(address referrerAddress) payable external returns(uint256 tokensReceieved);\r\n\tfunction buy(string calldata referrerName) payable external returns(uint256 tokensReceieved);\r\n\tfunction reinvest() external returns(uint256 tokensReceieved);\r\n\tfunction reinvestPartial(uint256 ethToReinvest) external returns(uint256 tokensReceieved);\r\n\tfunction reinvestPartial(uint256 ethToReinvest, bool withdrawAfter) external returns(uint256 tokensReceieved);\r\n\tfunction sell(uint256 amount, bool withdrawAfter) external returns(uint256 ethReceieved);\r\n\tfunction sell(uint256 amount) external returns(uint256 ethReceieved); // Alias of sell(amount, false)\r\n\tfunction withdraw() external;\r\n\tfunction exit() external;\r\n\tfunction acquireGauntlet(uint256 amount, uint8 gType, uint256 end) external;\r\n\tfunction acquireExternalGauntlet(uint256 amount, address extGauntlet) external;\r\n\tfunction setReferrer(address referrer) external;\r\n\tfunction setReferrer(string calldata referrerName) external;\r\n\r\n\tfunction myBalance() external view returns(uint256 balance);\r\n\tfunction dividendsOf(address accountHolder, bool includeReferralBonus) external view returns(uint256 divs);\r\n\tfunction dividendsOf(address accountHolder) external view returns(uint256 divs); // Alias of dividendsOf(accountHolder, true)\r\n\tfunction myDividends(bool includeReferralBonus) external view returns(uint256 divs);\r\n\tfunction myDividends() external view returns(uint256 divs); // Alias of myDividends(true);\r\n\r\n\tfunction usableBalanceOf(address accountHolder) external view returns(uint256 balance);\r\n\tfunction myUsableBalance() external view returns(uint256 balance);\r\n\tfunction refBonusOf(address customerAddress) external view returns(uint256);\r\n\tfunction myRefBonus() external view returns(uint256);\r\n\tfunction gauntletTypeOf(address accountHolder) external view returns(uint256 stakeAmount, uint256 gType, uint256 end);\r\n\tfunction myGauntletType() external view returns(uint256 stakeAmount, uint256 gType, uint256 end);\r\n\tfunction stakingRequirement() external view returns(uint256);\r\n\tfunction savedReferral(address accountHolder) external view returns(address);\r\n\r\n\t// ERC 20/223\r\n\tfunction balanceOf(address tokenOwner) external view returns(uint balance);\r\n\tfunction transfer(address to, uint value) external returns(bool ok);\r\n\tfunction transfer(address to, uint value, bytes data) external returns(bool ok);\r\n\tfunction transfer(address to, uint value, bytes data, string customFallback) external returns(bool ok);\r\n\tfunction allowance(address tokenOwner, address spender) external view returns(uint remaining);\r\n\tfunction approve(address spender, uint tokens) external returns(bool success);\r\n\tfunction transferFrom(address from, address to, uint tokens) external returns(bool success);\r\n\r\n\t// Events (cannot be in interfaces used here as a reference)\r\n\tevent Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tevent Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n\tevent onTokenPurchase(\r\n\t\taddress indexed accountHolder,\r\n\t\tuint256 ethereumSpent,\r\n\t\tuint256 tokensCreated,\r\n\t\tuint256 tokensGiven,\r\n\t\taddress indexed referrer,\r\n\t\tuint8 bitFlags // 1 = invalidMasternode, 2 = usedBITXMasternode, 4 = reinvestment\r\n\t);\r\n\tevent onTokenSell(\r\n\t\taddress indexed accountHolder,\r\n\t\tuint256 tokensDestroyed,\r\n\t\tuint256 ethereumEarned\r\n\t);\r\n\tevent onWithdraw(\r\n\t\taddress indexed accountHolder,\r\n\t\tuint256 earningsWithdrawn,\r\n\t\tuint256 refBonusWithdrawn,\r\n\t\tbool reinvestment\r\n\t);\r\n\tevent onDonatedDividends(\r\n\t\taddress indexed donator,\r\n\t\tuint256 ethereumDonated\r\n\t);\r\n\tevent onGauntletAcquired(\r\n\t\taddress indexed strongHands,\r\n\t\tuint256 stakeAmount,\r\n\t\tuint8 gauntletType,\r\n\t\tuint256 end\r\n\t);\r\n\tevent onExternalGauntletAcquired(\r\n\t\taddress indexed strongHands,\r\n\t\tuint256 stakeAmount,\r\n\t\taddress indexed extGauntlet\r\n\t);\r\n\t// Gauntlet events will be emitted with stakeAmount == 0 when the gauntlets expire.\r\n}\r\n*/\r\n\r\n// This contract is intended to only be used by BitGold. Think of this as BitGold's second account (or child slave with its own account)\r\n\r\ncontract BitGoldReferralHandler {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeMath for uint;\r\n\taddress internal parent;\r\n\tBITX internal bitx;\r\n\r\n\tconstructor(BITX h) public {\r\n\t\tbitx = h;\r\n\t\tparent = msg.sender;\r\n\t}\r\n\r\n\t// Don't expose this account to literally everyone\r\n\tmodifier onlyParent {\r\n\t\trequire(msg.sender == parent, \"Can only be executed by parent process\");\r\n\t\t_;\r\n\t}\r\n\r\n\t// Contract's total ETH balance including divs\r\n\tfunction totalBalance() public view returns(uint256) {\r\n\t\treturn address(this).balance + bitx.myDividends(true);\r\n\t}\r\n\r\n\t// Buy BITX from given ether\r\n\tfunction buyTokens(address referrer) public payable onlyParent {\r\n\t\tbitx.buy.value(msg.value)(referrer);\r\n\t}\r\n\r\n\t// Buy BITX from own ether balance\r\n\tfunction buyTokensFromBalance(address referrer, uint256 amount) public onlyParent {\r\n\t\tif (address(this).balance < amount) {\r\n\t\t\tbitx.withdraw();\r\n\t\t}\r\n\t\tbitx.buy.value(amount)(referrer);\r\n\t}\r\n\r\n\t// Sell a specified amount of BITX for ether\r\n\tfunction sellTokens(uint256 amount) public onlyParent {\r\n\t\tif (amount > 0) {\r\n\t\t\tbitx.sell(amount);\r\n\t\t}\r\n\t}\r\n\r\n\t// Withdraw outstanding divs to internal balance\r\n\tfunction withdrawDivs() public onlyParent {\r\n\t\tbitx.withdraw();\r\n\t}\r\n\r\n\t// Send eth from internal balance to a specified account\r\n\tfunction sendETH(address payable to, uint256 amount) public onlyParent {\r\n\t\tif (address(this).balance < amount) {\r\n\t\t\tbitx.withdraw();\r\n\t\t}\r\n\t\tto.transfer(amount);\r\n\t}\r\n\r\n\t// Only allow ETH from our master or from the bitx.\r\n\tfunction() payable external {\r\n\t\trequire(msg.sender == address(bitx) || msg.sender == parent, \"No, I don't accept donations\");\r\n\t}\r\n\r\n\t// Reject possible accidental sendin of higher-tech shitcoins.\r\n\tfunction tokenFallback(address from, uint value, bytes memory data) public pure {\r\n\t\trevert(\"I don't want your shitcoins!\");\r\n\t}\r\n\r\n\t// Allow anyone else to take forcefully sent low-tech shitcoins. (I sure as hell don't want them)\r\n\tfunction takeShitcoin(address shitCoin) public {\r\n\t\trequire(shitCoin != address(bitx), \"BITX isn't a shitcoin\");\r\n\t\tERC20interface s = ERC20interface(shitCoin);\r\n\t\ts.transfer(msg.sender, s.balanceOf(address(this)));\r\n\t}\r\n}\r\n\r\ncontract BitGold {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeMath for uint;\r\n\tusing SafeMath for int256;\r\n\r\n\tmodifier onlyOwner {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\t// Make the thing\r\n\tconstructor(address h) public {\r\n\t\t// Set up ERC20 values\r\n\t\tname = \"BitX Gold\";\r\n\t\tsymbol = \"BXTG\";\r\n\t\tdecimals = 18;\r\n\t\ttotalSupply = 0;\r\n\r\n\t\t// Add external contracts\r\n\t\tbitx = BITX(h);\r\n\r\n\t\t// Set referral requirement to be the same as BITX by default.\r\n\t\treferralRequirement = bitx.stakingRequirement();\r\n\r\n\t\t// Yes I could deploy 2 contracts myself, but I'm lazy. :^)\r\n\t\trefHandler = new BitGoldReferralHandler(bitx);\r\n\r\n\t\t// Internal stuffs\r\n\t\tignoreTokenFallbackEnable = false;\r\n\t\towner = msg.sender;\r\n\t}\r\n\t// BitGold-specific data\r\n\taddress owner;\r\n\taddress newOwner;\r\n\r\n\tuint256 referralRequirement;\r\n\tuint256 internal profitPerShare = 0;\r\n\tuint256 public lastTotalBalance = 0;\r\n\tuint256 constant internal ROUNDING_MAGNITUDE = 2**64;\r\n\taddress constant internal NULL_ADDRESS = 0x0000000000000000000000000000000000000000;\r\n\r\n\t// I would get this from bitx, but these values are inaccessable to the public.\r\n\tuint8 constant internal BITX_FEE = 10;\r\n\tuint8 constant internal BITX_BONUS = 2;\r\n\r\n\t// External contracts\r\n\tBITX internal bitx;\r\n\tBitGoldReferralHandler internal refHandler;\r\n\r\n\t// BXTG Specific data\r\n\tmapping(address => int256) internal payouts;\r\n\tmapping(address => uint256) internal bonuses;\r\n\tmapping(address => address) public savedReferral;\r\n\r\n\t// Futureproofing stuffs\r\n\tmapping(address => mapping (address => bool)) internal ignoreTokenFallbackList;\r\n\tbool internal ignoreTokenFallbackEnable;\r\n\r\n\t// Gauntlets\r\n\tmapping(address => uint256) internal gauntletBalance;\r\n\tmapping(address => uint256) internal gauntletEnd;\r\n\tmapping(address => uint8) internal gauntletType; // 1 = Time, 2 = BITX Supply, 3 = External\r\n\r\n\t// Normal token data\r\n\tmapping(address => uint256) internal balances;\r\n\tmapping(address => mapping (address => uint256)) internal allowances;\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\tuint256 public totalSupply;\r\n\r\n\t// --Events\r\n\tevent Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tevent Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\r\n\t// Q: Why do you have 2 transfer events?\r\n\t// A: Because keccak256(\"Transfer(address,address,uint256)\") != keccak256(\"Transfer(address,address,uint256,bytes)\")\r\n\t//    and etherscan listens for the former.\r\n\r\n\r\n\tevent onTokenPurchase(\r\n\t\taddress indexed accountHolder,\r\n\t\tuint256 ethereumSpent,\r\n\t\tuint256 tokensCreated,\r\n\t\t// If BITX is given to the contract, that amount in BXTG will be given to the next buyer since we have no idea who gave us the BITX.\r\n\t\tuint256 tokensGiven,\r\n\t\taddress indexed referrer,\r\n\t\tuint8 indexed bitFlags // 1 = invalidMasternode, 2 = usedBITXsMasternode, 4 = reinvestment\r\n\t);\r\n\tevent onTokenSell(\r\n\t\taddress indexed accountHolder,\r\n\t\tuint256 tokensDestroyed,\r\n\t\tuint256 ethereumEarned\r\n\t);\r\n\tevent onWithdraw(\r\n\t\taddress indexed accountHolder,\r\n\t\tuint256 earningsWithdrawn,\r\n\t\tuint256 refBonusWithdrawn,\r\n\t\tbool indexed reinvestment\r\n\t);\r\n\tevent onDonatedDividends(\r\n\t\taddress indexed donator,\r\n\t\tuint256 ethereumDonated\r\n\t);\r\n\tevent onGauntletAcquired(\r\n\t\taddress indexed strongHands,\r\n\t\tuint256 stakeAmount,\r\n\t\tuint8 indexed gauntletType,\r\n\t\tuint256 end\r\n\t);\r\n\tevent onExternalGauntletAcquired(\r\n\t\taddress indexed strongHands,\r\n\t\tuint256 stakeAmount,\r\n\t\taddress indexed extGauntlet\r\n\t);\r\n\t// --Events--\r\n\r\n\t// --Owner only functions\r\n\tfunction setNewOwner(address o) public onlyOwner {\r\n\t\tnewOwner = o;\r\n\t}\r\n\r\n\tfunction acceptNewOwner() public {\r\n\t\trequire(msg.sender == newOwner);\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\t// BXTG allows re-branding.\r\n\tfunction rebrand(string memory n, string memory s) public onlyOwner {\r\n\t\tname = n;\r\n\t\tsymbol = s;\r\n\t}\r\n\r\n\t// BXTG selling point: _lower staking requirement than BITX!!_\r\n\tfunction setReferralRequirement(uint256 r) public onlyOwner {\r\n\t\treferralRequirement = r;\r\n\t}\r\n\r\n\t// Enables the function defined below.\r\n\tfunction allowIgnoreTokenFallback() public onlyOwner {\r\n\t\tignoreTokenFallbackEnable = true;\r\n\t}\r\n\t// --Owner only functions--\r\n\r\n\t// --Public write functions\r\n\r\n\t// Ethereum _might_ implement something where every address, including ones controlled by humans, is a smart contract.\r\n\t// Obviously transfering BXTG to other people with no fee is one of its selling points.\r\n\t// A somewhat future-proofing fix is for the sender to specify that their recipiant is human if such a change ever takes place.\r\n\t// However, due to the popularity of ERC223, this might not be necessary.\r\n\tfunction ignoreTokenFallback(address to, bool ignore) public {\r\n\t\trequire(ignoreTokenFallbackEnable, \"This function is disabled\");\r\n\t\tignoreTokenFallbackList[msg.sender][to] = ignore;\r\n\t}\r\n\r\n\t// Transfer tokens to the specified address, call the specified function, and pass the specified data\r\n\tfunction transfer(address payable to, uint value, bytes memory data, string memory func) public returns(bool) {\r\n\t\tactualTransfer(msg.sender, to, value, data, func, true);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Transfer tokens to the specified address, call tokenFallback, and pass the specified data\r\n\tfunction transfer(address payable to, uint value, bytes memory data) public returns(bool) {\r\n\t\tactualTransfer(msg.sender, to, value, data, \"\", true);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Transfer tokens to the specified address, call tokenFallback if applicable\r\n\tfunction transfer(address payable to, uint value) public returns(bool) {\r\n\t\tactualTransfer(msg.sender, to, value, \"\", \"\", !ignoreTokenFallbackList[msg.sender][to]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Allow someone else to spend your tokens\r\n\tfunction approve(address spender, uint value) public returns(bool) {\r\n\t\trequire(updateUsableBalanceOf(msg.sender) >= value, \"Insufficient balance to approve\");\r\n\t\tallowances[msg.sender][spender] = value;\r\n\t\temit Approval(msg.sender, spender, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Have that someone else spend your tokens\r\n\tfunction transferFrom(address payable from, address payable to, uint value) public returns(bool success) {\r\n\t\tuint256 allowance = allowances[from][msg.sender];\r\n\t\trequire(allowance > 0, \"Not approved\");\r\n\t\trequire(allowance >= value, \"Over spending limit\");\r\n\t\tallowances[from][msg.sender] = allowance.sub(value);\r\n\t\tactualTransfer(from, to, value, \"\", \"\", false);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// The fallback function\r\n\tfunction() payable external{\r\n\t\t// Only accept free ETH from the bitx and from our child slave.\r\n\t\tif (msg.sender != address(bitx) && msg.sender != address(refHandler)) {\r\n\t\t\t// Now, sending ETH increases the balance _before_ the transaction has been fully processed.\r\n\t\t\t// We don't want to distribute the entire purchase order as dividends.\r\n\t\t\tif (msg.value > 0) {\r\n\t\t\t\tlastTotalBalance += msg.value;\r\n\t\t\t\tdistributeDividends(0, NULL_ADDRESS);\r\n\t\t\t\tlastTotalBalance -= msg.value;\r\n\t\t\t}\r\n\t\t\tcreateTokens(msg.sender, msg.value, NULL_ADDRESS, false);\r\n\t\t}\r\n\t}\r\n\r\n\t// Worried about having weak hands? Put on an optional gauntlet.\r\n\t// Prevents you from selling or transfering a specified amount of tokens\r\n\tfunction acquireGauntlet(uint256 amount, uint8 gType, uint256 end) public{\r\n\t\trequire(amount <= balances[msg.sender], \"Insufficient balance\");\r\n\r\n\t\t// We need to apply the data first in order to prevent re-entry attacks.\r\n\t\t// ExternalGauntletInterface.gauntletRequirement _is_ a function which can change the state, after all.\r\n\t\tuint256 oldGauntletType = gauntletType[msg.sender];\r\n\t\tuint256 oldGauntletBalance = gauntletBalance[msg.sender];\r\n\t\tuint256 oldGauntletEnd = gauntletEnd[msg.sender];\r\n\r\n\t\tgauntletType[msg.sender] = gType;\r\n\t\tgauntletEnd[msg.sender] = end;\r\n\t\tgauntletBalance[msg.sender] = amount;\r\n\r\n\t\tif (oldGauntletType == 0) {\r\n\t\t\tif (gType == 1) {\r\n\t\t\t\trequire(end >= (block.timestamp + 97200), \"Gauntlet time must be >= 4 weeks\"); //97200 seconds = 3 weeks and 6 days.\r\n\t\t\t\temit onGauntletAcquired(msg.sender, amount, gType, end);\r\n\t\t\t} else if (gType == 2) {\r\n\t\t\t\tuint256 BITXSupply = bitx.totalSupply();\r\n\t\t\t\trequire(end >= (BITXSupply + (BITXSupply / 5)), \"Gauntlet must make a profit\"); // BITX buyers are down 19% when they buy, so make gauntlet gainz a minimum of 20%.\r\n\t\t\t\temit onGauntletAcquired(msg.sender, amount, gType, end);\r\n\t\t\t} else if (gType == 3) {\r\n\t\t\t\trequire(end <= 0x00ffffffffffffffffffffffffffffffffffffffff, \"Invalid address\");\r\n\t\t\t\trequire(ExternalGauntletInterface(address(end)).gauntletRequirement(msg.sender, 0, amount), \"External gauntlet check failed\");\r\n\t\t\t\temit onExternalGauntletAcquired(msg.sender, amount, address(end));\r\n\t\t\t} else {\r\n\t\t\t\trevert(\"Invalid gauntlet type\");\r\n\t\t\t}\r\n\t\t} else if (oldGauntletType == 3) {\r\n\t\t\trequire(gType == 3, \"New gauntlet must be same type\");\r\n\t\t\trequire(end == gauntletEnd[msg.sender], \"Must be same external gauntlet\");\r\n\t\t\trequire(ExternalGauntletInterface(address(end)).gauntletRequirement(msg.sender, oldGauntletBalance, amount), \"External gauntlet check failed\");\r\n\t\t\temit onExternalGauntletAcquired(msg.sender, amount, address(end));\r\n\t\t} else {\r\n\t\t\trequire(gType == oldGauntletType, \"New gauntlet must be same type\");\r\n\t\t\trequire(end > oldGauntletEnd, \"Gauntlet must be an upgrade\");\r\n\t\t\trequire(amount >= oldGauntletBalance, \"New gauntlet must hold more tokens\");\r\n\t\t\temit onGauntletAcquired(msg.sender, amount, gType, end);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction acquireExternalGauntlet(uint256 amount, address extGauntlet) public{\r\n\t\tacquireGauntlet(amount, 3, uint256(extGauntlet));\r\n\t}\r\n\r\n\t// Throw your money at this thing with a referrer specified by their Ethereum address.\r\n\t// Returns the amount of tokens created.\r\n\tfunction buy(address referrerAddress) payable public returns(uint256) {\r\n\t\t// Now, sending ETH increases the balance _before_ the transaction has been fully processed.\r\n\t\t// We don't want to distribute the entire purchase order as dividends.\r\n\t\tif (msg.value > 0) {\r\n\t\t\tlastTotalBalance += msg.value;\r\n\t\t\tdistributeDividends(0, NULL_ADDRESS);\r\n\t\t\tlastTotalBalance -= msg.value;\r\n\t\t}\r\n\t\treturn createTokens(msg.sender, msg.value, referrerAddress, false);\r\n\t}\r\n\r\n\t// Use all the ETH you earned hodling BXTG to buy more BXTG.\r\n\t// Returns the amount of tokens created.\r\n\tfunction reinvest() public returns(uint256) {\r\n\t\taddress accountHolder = msg.sender;\r\n\t\tdistributeDividends(0, NULL_ADDRESS); // Just in case BITX-only transactions happened.\r\n\t\tuint256 payout;\r\n\t\tuint256 bonusPayout;\r\n\t\t(payout, bonusPayout) = clearDividends(accountHolder);\r\n\t\temit onWithdraw(accountHolder, payout, bonusPayout, true);\r\n\t\treturn createTokens(accountHolder, payout + bonusPayout, NULL_ADDRESS, true);\r\n\t}\r\n\r\n\t// Use some of the ETH you earned hodling BXTG to buy more BXTG.\r\n\t// You can withdraw the rest or keep it in here allocated for you.\r\n\t// Returns the amount of tokens created.\r\n\tfunction reinvestPartial(uint256 ethToReinvest, bool withdrawAfter) public returns(uint256 tokensCreated) {\r\n\t\taddress payable accountHolder = msg.sender;\r\n\t\tdistributeDividends(0, NULL_ADDRESS); // Just in case BITX-only transactions happened.\r\n\r\n\t\tuint256 payout = dividendsOf(accountHolder, false);\r\n\t\tuint256 bonusPayout = bonuses[accountHolder];\r\n\r\n\t\tuint256 payoutReinvested = 0;\r\n\t\tuint256 bonusReinvested;\r\n\r\n\t\trequire((payout + bonusPayout) >= ethToReinvest, \"Insufficient balance for reinvestment\");\r\n\t\t// We're going to take ETH out of the masternode bonus first, then the outstanding divs.\r\n\t\tif (ethToReinvest > bonusPayout){\r\n\t\t\tpayoutReinvested = ethToReinvest - bonusPayout;\r\n\t\t\tbonusReinvested = bonusPayout;\r\n\t\t\t// Take ETH out from outstanding dividends.\r\n\t\t\tpayouts[accountHolder] += int256(payoutReinvested * ROUNDING_MAGNITUDE);\r\n\t\t}else{\r\n\t\t\tbonusReinvested = ethToReinvest;\r\n\t\t}\r\n\t\t// Take ETH from the masternode bonus.\r\n\t\tbonuses[accountHolder] -= bonusReinvested;\r\n\r\n\t\temit onWithdraw(accountHolder, payoutReinvested, bonusReinvested, true);\r\n\t\t// Do the buy thing!\r\n\t\ttokensCreated = createTokens(accountHolder, ethToReinvest, NULL_ADDRESS, true);\r\n\r\n\t\tif (withdrawAfter && dividendsOf(msg.sender, true) > 0) {\r\n\t\t\twithdrawDividends(msg.sender);\r\n\t\t}\r\n\t\treturn tokensCreated;\r\n\t}\r\n\r\n\t// I'm just a man who loves \"default variables\"\r\n\tfunction reinvestPartial(uint256 ethToReinvest) public returns(uint256) {\r\n\t\treturn reinvestPartial(ethToReinvest, true);\r\n\t}\r\n\r\n\t// There's literally no reason to call this function\r\n\tfunction sell(uint256 amount, bool withdrawAfter) public returns(uint256) {\r\n\t\trequire(amount > 0, \"You have to sell something\");\r\n\t\tuint256 sellAmount = destroyTokens(msg.sender, amount);\r\n\t\tif (withdrawAfter && dividendsOf(msg.sender, true) > 0) {\r\n\t\t\twithdrawDividends(msg.sender);\r\n\t\t}\r\n\t\treturn sellAmount;\r\n\t}\r\n\r\n\t// Again with the default variables!\r\n\tfunction sell(uint256 amount) public returns(uint256) {\r\n\t\trequire(amount > 0, \"You have to sell something\");\r\n\t\treturn destroyTokens(msg.sender, amount);\r\n\t}\r\n\r\n\t// Transfer the sender's masternode bonuses and their outstanding divs to their wallet.\r\n\tfunction withdraw() public{\r\n\t\trequire(dividendsOf(msg.sender, true) > 0, \"No dividends to withdraw\");\r\n\t\twithdrawDividends(msg.sender);\r\n\t}\r\n\r\n\t// There's definitely no reason to call this function\r\n\tfunction exit() public{\r\n\t\taddress payable accountHolder = msg.sender;\r\n\t\tuint256 balance = balances[accountHolder];\r\n\t\tif (balance > 0) {\r\n\t\t\tdestroyTokens(accountHolder, balance);\r\n\t\t}\r\n\t\tif (dividendsOf(accountHolder, true) > 0) {\r\n\t\t\twithdrawDividends(accountHolder);\r\n\t\t}\r\n\t}\r\n\r\n\t// Since website won't be released on launch, provide something on etherscan which will allow users to easily set masternodes.\r\n\tfunction setReferrer(address ref) public{\r\n\t\tsavedReferral[msg.sender] = ref;\r\n\t}\r\n\r\n\t// Another BXTG selling point: Get BXTG-exclusive didvidends _combined with_ BITX dividends!\r\n\tfunction donateDividends() payable public{\r\n\t\tdistributeDividends(0, NULL_ADDRESS);\r\n\t\temit onDonatedDividends(msg.sender, msg.value);\r\n\t}\r\n\r\n\t// --Public write functions--\r\n\r\n\t// --Public read-only functions\r\n\r\n\t// Returns the BITX address.\r\n\tfunction baseBITX() external view returns(address) {\r\n\t\treturn address(bitx);\r\n\t}\r\n\r\n\t// Returns the salve account address (was mostly used for debugging purposes)\r\n\tfunction refHandlerAddress() external view returns(address) {\r\n\t\treturn address(refHandler);\r\n\t}\r\n\r\n\t// Retruns an addresses gauntlet type.\r\n\tfunction gauntletTypeOf(address accountHolder) public view returns(uint stakeAmount, uint gType, uint end) {\r\n\t\tif (isGauntletExpired(accountHolder)) {\r\n\t\t\treturn (0, 0, gauntletEnd[accountHolder]);\r\n\t\t} else {\r\n\t\t\treturn (gauntletBalance[accountHolder], gauntletType[accountHolder], gauntletEnd[accountHolder]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Same as above except for msg.sender\r\n\tfunction myGauntletType() public view returns(uint stakeAmount, uint gType, uint end) {\r\n\t\treturn gauntletTypeOf(msg.sender);\r\n\t}\r\n\r\n\t// Returns an addresse's BXTG balance minus what they have in their gauntlet.\r\n\tfunction usableBalanceOf(address accountHolder) public view returns(uint balance) {\r\n\t\tif (isGauntletExpired(accountHolder)) {\r\n\t\t\treturn balances[accountHolder];\r\n\t\t} else {\r\n\t\t\treturn balances[accountHolder].sub(gauntletBalance[accountHolder]);\r\n\t\t}\r\n\t}\r\n\r\n\t// Same as above except for msg.sender\r\n\tfunction myUsableBalance() public view returns(uint balance) {\r\n\t\treturn usableBalanceOf(msg.sender);\r\n\t}\r\n\r\n\t// I mean, every ERC20 token has this function. I'm sure you know what it does.\r\n\tfunction balanceOf(address accountHolder) external view returns(uint balance) {\r\n\t\treturn balances[accountHolder];\r\n\t}\r\n\r\n\t// Same as above except for msg.sender\r\n\tfunction myBalance() public view returns(uint256) {\r\n\t\treturn balances[msg.sender];\r\n\t}\r\n\r\n\t// See if the specified sugardaddy allows the spender to spend their tokens\r\n\tfunction allowance(address sugardaddy, address spender) external view returns(uint remaining) {\r\n\t\treturn allowances[sugardaddy][spender];\r\n\t}\r\n\r\n\t// Returns all the ETH that this contract has access to\r\n\tfunction totalBalance() public view returns(uint256) {\r\n\t\treturn address(this).balance + bitx.myDividends(true) + refHandler.totalBalance();\r\n\t}\r\n\r\n\t// Returns the ETH the specified address is owed.\r\n\tfunction dividendsOf(address customerAddress, bool includeReferralBonus) public view returns(uint256) {\r\n\t\tuint256 divs = uint256(int256(profitPerShare * balances[customerAddress]) - payouts[customerAddress]) / ROUNDING_MAGNITUDE;\r\n\t\tif (includeReferralBonus) {\r\n\t\t\tdivs += bonuses[customerAddress];\r\n\t\t}\r\n\t\treturn divs;\r\n\t}\r\n\r\n\t// Same as above except includes the masternode bonus\r\n\tfunction dividendsOf(address customerAddress) public view returns(uint256) {\r\n\t\treturn dividendsOf(customerAddress, true);\r\n\t}\r\n\r\n\t// Alias of dividendsOf(msg.sender)\r\n\tfunction myDividends() public view returns(uint256) {\r\n\t\treturn dividendsOf(msg.sender, true);\r\n\t}\r\n\r\n\t// Alias of dividendsOf(msg.sender, includeReferralBonus)\r\n\tfunction myDividends(bool includeReferralBonus) public view returns(uint256) {\r\n\t\treturn dividendsOf(msg.sender, includeReferralBonus);\r\n\t}\r\n\r\n\t// Returns the masternode earnings of a specified account\r\n\tfunction refBonusOf(address customerAddress) external view returns(uint256) {\r\n\t\treturn bonuses[customerAddress];\r\n\t}\r\n\r\n\t// Same as above xcept with msg.sender\r\n\tfunction myRefBonus() external view returns(uint256) {\r\n\t\treturn bonuses[msg.sender];\r\n\t}\r\n\r\n\t// Backwards compatibility with the BITX interface\r\n\tfunction stakingRequirement() external view returns(uint256) {\r\n\t\treturn referralRequirement;\r\n\t}\r\n\r\n\t// Backwards compatibility with the BITX interface\r\n\tfunction calculateTokensReceived(uint256 ethereumToSpend) public view returns(uint256) {\r\n\t\treturn bitx.calculateTokensReceived(ethereumToSpend);\r\n\t}\r\n\r\n\t// Backwards compatibility with the BITX interface\r\n\tfunction calculateEthereumReceived(uint256 tokensToSell) public view returns(uint256) {\r\n\t\treturn bitx.calculateEthereumReceived(tokensToSell);\r\n\t}\r\n\t// --Public read-only functions--\r\n\r\n\t// Internal functions\r\n\r\n\t// Returns true if the gauntlet has expired. Otherwise, false.\r\n\tfunction isGauntletExpired(address holder) internal view returns(bool) {\r\n\t\tif (gauntletType[holder] != 0) {\r\n\t\t\tif (gauntletType[holder] == 1) {\r\n\t\t\t\treturn (block.timestamp >= gauntletEnd[holder]);\r\n\t\t\t} else if (gauntletType[holder] == 2) {\r\n\t\t\t\treturn (bitx.totalSupply() >= gauntletEnd[holder]);\r\n\t\t\t} else if (gauntletType[holder] == 3) {\r\n\t\t\t\treturn ExternalGauntletInterface(gauntletEnd[holder]).gauntletRemovable(holder);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Same as usableBalanceOf, except the gauntlet is lifted when it's expired.\r\n\tfunction updateUsableBalanceOf(address holder) internal returns(uint256) {\r\n\t\t// isGauntletExpired is a _view_ function, with uses STATICCALL in solidity 0.5.0 or later.\r\n\t\t// Since STATICCALLs can't modifiy the state, re-entry attacks aren't possible here.\r\n\t\tif (isGauntletExpired(holder)) {\r\n\t\t\tif (gauntletType[holder] == 3){\r\n\t\t\t\temit onExternalGauntletAcquired(holder, 0, NULL_ADDRESS);\r\n\t\t\t}else{\r\n\t\t\t\temit onGauntletAcquired(holder, 0, 0, 0);\r\n\t\t\t}\r\n\t\t\tgauntletType[holder] = 0;\r\n\t\t\tgauntletBalance[holder] = 0;\r\n\r\n\t\t\treturn balances[holder];\r\n\t\t}\r\n\t\treturn balances[holder] - gauntletBalance[holder];\r\n\t}\r\n\r\n\t// This is the actual buy function\r\n\tfunction createTokens(address creator, uint256 eth, address referrer, bool reinvestment) internal returns(uint256) {\r\n\t\t// Let's not call the parent bitx all the time.\r\n\t\tuint256 parentReferralRequirement = bitx.stakingRequirement();\r\n\t\t// How much ETH will be given to the referrer if there is one.\r\n\t\tuint256 referralBonus = eth / BITX_FEE / BITX_BONUS;\r\n\r\n\t\tbool usedBITXMasternode = false;\r\n\t\tbool invalidMasternode = false;\r\n\t\tif (referrer == NULL_ADDRESS) {\r\n\t\t\treferrer = savedReferral[creator];\r\n\t\t}\r\n\r\n\t\t// Solidity has limited amount of local variables, so the memory allocated to this one gets reused for other purposes later.\r\n\t\t//uint256 refHandlerBalance = bitx.balanceOf(address(refHandler));\r\n\t\tuint256 tmp = bitx.balanceOf(address(refHandler));\r\n\r\n\t\t// Let's once again pretend this actually prevents people from cheating.\r\n\t\tif (creator == referrer) {\r\n\t\t\t// Tell everyone that no referral purchase was made because cheating (unlike BITX)\r\n\t\t\tinvalidMasternode = true;\r\n\t\t} else if (referrer == NULL_ADDRESS) {\r\n\t\t\tusedBITXMasternode = true;\r\n\t\t// Make sure that the referrer has enough funds to _be_ a referrer, and make sure that we have our own BITX masternode to get that extra ETH\r\n\t\t} else if (balances[referrer] >= referralRequirement && (tmp >= parentReferralRequirement || bitx.balanceOf(address(this)) >= parentReferralRequirement)) {\r\n\t\t\t// It's a valid BXTG masternode, hooray! (do nothing)\r\n\t\t} else if (bitx.balanceOf(referrer) >= parentReferralRequirement) {\r\n\t\t\tusedBITXMasternode = true;\r\n\t\t} else {\r\n\t\t\t// Tell everyone that no referral purchase was made because not enough balance (again, unlike BITX)\r\n\t\t\tinvalidMasternode = true;\r\n\t\t}\r\n\r\n\t\tuint256 createdTokens = bitx.totalSupply();\r\n\r\n\t\t// if the refHandler has less BITX than BITX's masternode requirement, then it should buy the tokens.\r\n\t\tif (tmp < parentReferralRequirement) {\r\n\t\t\tif (reinvestment) {\r\n\t\t\t\t// We need to know if the refHandler has enough ETH to do the reinvestment on its own\r\n\t\t\t\t//uint256 refHandlerEthBalance = refHandler.totalBalance();\r\n\t\t\t\ttmp = refHandler.totalBalance();\r\n\t\t\t\tif (tmp < eth) {\r\n\t\t\t\t\t// If it doesn't, then we must transfer it the remaining ETH it needs.\r\n\t\t\t\t\ttmp = eth - tmp; // fundsToGive = eth - refHandlerEthBalance;\r\n\t\t\t\t\tif (address(this).balance < tmp) {\r\n\t\t\t\t\t\t// If this fails, something went horribly wrong because the client is attempting to reinvest more ethereum than we've got\r\n\t\t\t\t\t\tbitx.withdraw();\r\n\t\t\t\t\t}\r\n\t\t\t\t\taddress(refHandler).transfer(tmp);\r\n\t\t\t\t}\r\n\t\t\t\t// Reinvestments are always done using the null referrer\r\n\t\t\t\trefHandler.buyTokensFromBalance(NULL_ADDRESS, eth);\r\n\t\t\t} else {\r\n\t\t\t\t// these nested ? statements are only here because I can only have a limited amount of local variables.\r\n\t\t\t\t// Forward the ETH we were sent to the refHandler to place the buy order.\r\n\t\t\t\trefHandler.buyTokens.value(eth)(invalidMasternode ? NULL_ADDRESS : (usedBITXMasternode ? referrer : address(this)));\r\n\t\t\t}\r\n\t\t\ttmp = bitx.balanceOf(address(refHandler));\r\n\t\t} else {\r\n\t\t\tif (reinvestment) {\r\n\t\t\t\t// If we don't have enough ETH to do the reinvestment, withdraw.\r\n\t\t\t\tif (address(this).balance < eth && bitx.myDividends(true) > 0) {\r\n\t\t\t\t\tbitx.withdraw();\r\n\t\t\t\t}\r\n\t\t\t\t// If we _still_ don't have enough ETH to do the reinvestment, have the refHandler sends us some.\r\n\t\t\t\tif (address(this).balance < eth) {\r\n\t\t\t\t\trefHandler.sendETH(address(this), eth - address(this).balance);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbitx.buy.value(eth)(invalidMasternode ? NULL_ADDRESS : (usedBITXMasternode ? referrer : address(refHandler)));\r\n\t\t}\r\n\r\n\t\t// Use the delta from before and after the buy order to get the amount of BITX created.\r\n\t\tcreatedTokens = bitx.totalSupply() - createdTokens;\r\n\t\ttotalSupply += createdTokens;\r\n\r\n\t\t// This is here for when someone transfers BITX to the contract directly. We have no way of knowing who it's from, so we'll just give it to the next person who happens to buy.\r\n\t\tuint256 bonusTokens = bitx.myTokens() + tmp - totalSupply;\r\n\r\n\t\t// Here I now re-use that uint256 to create the bit flags.\r\n\t\ttmp = 0;\r\n\t\tif (invalidMasternode)\t\t\t{ tmp |= 1; }\r\n\t\tif (usedBITXMasternode)\t{ tmp |= 2; }\r\n\t\tif (reinvestment)\t\t\t\t{ tmp |= 4; }\r\n\r\n\t\temit onTokenPurchase(creator, eth, createdTokens, bonusTokens, referrer, uint8(tmp));\r\n\t\tcreatedTokens += bonusTokens;\r\n\t\t// We can finally give the BXTG to the buyer!\r\n\t\tbalances[creator] += createdTokens;\r\n\t\ttotalSupply += bonusTokens;\r\n\r\n\t\t//Updates services like etherscan which track token hodlings.\r\n\t\temit Transfer(address(this), creator, createdTokens, \"\");\r\n\t\temit Transfer(address(this), creator, createdTokens);\r\n\r\n\t\t// Unfortunatly, SafeMath cannot be used here, otherwise the stack gets too deep\r\n\t\tpayouts[creator] += int256(profitPerShare * createdTokens); // You don't deserve the dividends before you owned the tokens.\r\n\r\n\t\tif (reinvestment) {\r\n\t\t\t// No dividend distribution underflows allowed.\r\n\t\t\t// Ethereum has been given away after a \"reinvestment\" purchase, so we have to keep track of that.\r\n\t\t\tlastTotalBalance = lastTotalBalance.sub(eth);\r\n\t\t}\r\n\t\tdistributeDividends((usedBITXMasternode || invalidMasternode) ? 0 : referralBonus, referrer);\r\n\t\tif (referrer != NULL_ADDRESS) {\r\n\t\t\t// Save the referrer for next time!\r\n\t\t\tsavedReferral[creator] = referrer;\r\n\t\t}\r\n\t\treturn createdTokens;\r\n\t}\r\n\r\n\t// This is marked as an internal function because selling could have been the result of transfering BXTG to the contract via a transferFrom transaction.\r\n\tfunction destroyTokens(address weakHand, uint256 bags) internal returns(uint256) {\r\n\t\trequire(updateUsableBalanceOf(weakHand) >= bags, \"Insufficient balance\");\r\n\r\n\t\t// Give the weak hand the last of their deserved payout.\r\n\t\t// Also updates lastTotalBalance\r\n\t\tdistributeDividends(0, NULL_ADDRESS);\r\n\t\tuint256 tokenBalance = bitx.myTokens();\r\n\r\n\t\t// We can't rely on ETH balance delta because we get cut of the sell fee ourselves.\r\n\t\tuint256 ethReceived = bitx.calculateEthereumReceived(bags);\r\n\t\tlastTotalBalance += ethReceived;\r\n\t\tif (tokenBalance >= bags) {\r\n\t\t\tbitx.sell(bags);\r\n\t\t} else {\r\n\t\t\t// If we don't have enough BITX to sell ourselves, get the slave to sell some, too.\r\n\t\t\tif (tokenBalance > 0) {\r\n\t\t\t\tbitx.sell(tokenBalance);\r\n\t\t\t}\r\n\t\t\trefHandler.sellTokens(bags - tokenBalance);\r\n\t\t}\r\n\r\n\t\t// Put the ETH in outstanding dividends, and allow the weak hand access to the divs they've accumilated before they sold.\r\n\t\tint256 updatedPayouts = int256(profitPerShare * bags + (ethReceived * ROUNDING_MAGNITUDE));\r\n\t\tpayouts[weakHand] = payouts[weakHand].sub(updatedPayouts);\r\n\r\n\t\t// We already checked the balance of the weakHanded person, so SafeMathing here is redundant.\r\n\t\tbalances[weakHand] -= bags;\r\n\t\ttotalSupply -= bags;\r\n\r\n\t\temit onTokenSell(weakHand, bags, ethReceived);\r\n\r\n\t\t// Tell etherscan of this tragity.\r\n\t\temit Transfer(weakHand, address(this), bags, \"\");\r\n\t\temit Transfer(weakHand, address(this), bags);\r\n\t\treturn ethReceived;\r\n\t}\r\n\r\n\t// sends ETH to the specified account, using all the ETH BXTG has access to.\r\n\tfunction sendETH(address payable to, uint256 amount) internal {\r\n\t\tuint256 childTotalBalance = refHandler.totalBalance();\r\n\t\tuint256 thisBalance = address(this).balance;\r\n\t\tuint256 thisTotalBalance = thisBalance + bitx.myDividends(true);\r\n\t\tif (childTotalBalance >= amount) {\r\n\t\t\t// the refHanlder has enough of its own ETH to send, so it should do that.\r\n\t\t\trefHandler.sendETH(to, amount);\r\n\t\t} else if (thisTotalBalance >= amount) {\r\n\t\t\t// We have enough ETH of our own to send.\r\n\t\t\tif (thisBalance < amount) {\r\n\t\t\t\tbitx.withdraw();\r\n\t\t\t}\r\n\t\t\tto.transfer(amount);\r\n\t\t} else {\r\n\t\t\t// Neither we nor the refHandler has enough ETH to send individually, so both contracts have to send ETH.\r\n\t\t\trefHandler.sendETH(to, childTotalBalance);\r\n\t\t\tif (bitx.myDividends(true) > 0) {\r\n\t\t\t\tbitx.withdraw();\r\n\t\t\t}\r\n\t\t\tto.transfer(amount - childTotalBalance);\r\n\t\t}\r\n\t\t// keep the dividend tracker in check.\r\n\t\tlastTotalBalance = lastTotalBalance.sub(amount);\r\n\t}\r\n\r\n\t// Take the ETH we've got and distribute it among our token holders.\r\n\tfunction distributeDividends(uint256 bonus, address bonuser) internal{\r\n\t\t// Prevents \"HELP I WAS THE LAST PERSON WHO SOLD AND I CAN'T WITHDRAW MY ETH WHAT DO????\" (dividing by 0 results in a crash)\r\n\t\tif (totalSupply > 0) {\r\n\t\t\tuint256 tb = totalBalance();\r\n\t\t\tuint256 delta = tb - lastTotalBalance;\r\n\t\t\tif (delta > 0) {\r\n\t\t\t\t// We have more ETH than before, so we'll just distribute those dividends among our token holders.\r\n\t\t\t\tif (bonus != 0) {\r\n\t\t\t\t\tbonuses[bonuser] += bonus;\r\n\t\t\t\t}\r\n\t\t\t\tprofitPerShare = profitPerShare.add(((delta - bonus) * ROUNDING_MAGNITUDE) / totalSupply);\r\n\t\t\t\tlastTotalBalance += delta;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Clear out someone's dividends.\r\n\tfunction clearDividends(address accountHolder) internal returns(uint256, uint256) {\r\n\t\tuint256 payout = dividendsOf(accountHolder, false);\r\n\t\tuint256 bonusPayout = bonuses[accountHolder];\r\n\r\n\t\tpayouts[accountHolder] += int256(payout * ROUNDING_MAGNITUDE);\r\n\t\tbonuses[accountHolder] = 0;\r\n\r\n\t\t// External apps can now get reliable masternode statistics\r\n\t\treturn (payout, bonusPayout);\r\n\t}\r\n\r\n\t// Withdraw 100% of someone's dividends\r\n\tfunction withdrawDividends(address payable accountHolder) internal {\r\n\t\tdistributeDividends(0, NULL_ADDRESS); // Just in case BITX-only transactions happened.\r\n\t\tuint256 payout;\r\n\t\tuint256 bonusPayout;\r\n\t\t(payout, bonusPayout) = clearDividends(accountHolder);\r\n\t\temit onWithdraw(accountHolder, payout, bonusPayout, false);\r\n\t\tsendETH(accountHolder, payout + bonusPayout);\r\n\t}\r\n\r\n\t// The internal transfer function.\r\n\tfunction actualTransfer (address payable from, address payable to, uint value, bytes memory data, string memory func, bool careAboutHumanity) internal{\r\n\t\trequire(updateUsableBalanceOf(from) >= value, \"Insufficient balance\");\r\n\t\trequire(to != address(refHandler), \"My slave doesn't get paid\"); // I don't know why anyone would do this, but w/e\r\n\t\trequire(to != address(bitx), \"BITX has no need for these\"); // Prevent h4x0rs from having BXTG call arbitrary BITX functions.\r\n\r\n\t\tif (to == address(this)) {\r\n\t\t\t// Treat transfers to this contract as a sell and withdraw order.\r\n\t\t\tif (value == 0) {\r\n\t\t\t\t// Transfers of 0 still have to be emitted... for some reason.\r\n\t\t\t\temit Transfer(from, to, value, data);\r\n\t\t\t\temit Transfer(from, to, value);\r\n\t\t\t} else {\r\n\t\t\t\tdestroyTokens(from, value);\r\n\t\t\t}\r\n\t\t\twithdrawDividends(from);\r\n\t\t} else {\r\n\t\t\tdistributeDividends(0, NULL_ADDRESS); // Just in case BITX-only transactions happened.\r\n\t\t\t// I was going to add a value == 0 check here, but if you're sending 0 tokens to someone, you deserve to pay for wasted gas.\r\n\r\n\t\t\t// Throwing an exception undos all changes. Otherwise changing the balance now would be a shitshow\r\n\t\t\tbalances[from] = balances[from].sub(value);\r\n\t\t\tbalances[to] = balances[to].add(value);\r\n\r\n\t\t\t// Sender can have their dividends from when they owned the tokens\r\n\t\t\tpayouts[from] -= int256(profitPerShare * value);\r\n\t\t\t// Receiver is not allowed to have dividends from before they owned the tokens.\r\n\t\t\tpayouts[to] += int256(profitPerShare * value);\r\n\r\n\t\t\tif (careAboutHumanity && isContract(to)) {\r\n\t\t\t\tif (bytes(func).length == 0) {\r\n\t\t\t\t\tERC223Handler receiver = ERC223Handler(to);\r\n\t\t\t\t\treceiver.tokenFallback(from, value, data);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbool success;\r\n\t\t\t\t\tbytes memory returnData;\r\n\t\t\t\t\t(success, returnData) = to.call.value(0)(abi.encodeWithSignature(func, from, value, data));\r\n\t\t\t\t\tassert(success);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\temit Transfer(from, to, value, data);\r\n\t\t\temit Transfer(from, to, value);\r\n\t\t}\r\n\t}\r\n\r\n\t// If bytecode exists at _addr then the _addr is a contract.\r\n\tfunction isContract(address _addr) internal view returns(bool) {\r\n\t\tuint length;\r\n\t\tassembly {\r\n\t\t\t//retrieve the size of the code on target address, this needs assembly\r\n\t\t\tlength := extcodesize(_addr)\r\n\t\t}\r\n\t\treturn (length>0);\r\n\t}\r\n\r\n\t// Reject possible accidental sendin of higher-tech shitcoins. (with a fancy message)\r\n\tfunction tokenFallback(address from, uint value, bytes memory data) public pure{\r\n\t\trevert(\"I don't want your shitcoins!\");\r\n\t}\r\n\r\n\t// Allow anyone else to take forcefully sent low-tech shitcoins. (I sure as hell don't want them)\r\n\tfunction takeShitcoin(address shitCoin) public{\r\n\t\t// Don't allow people to siphon funds from us\r\n\t\trequire(shitCoin != address(bitx), \"BITX isn't a shitcoin\");\r\n\t\tERC20interface s = ERC20interface(shitCoin);\r\n\t\ts.transfer(msg.sender, s.balanceOf(address(this)));\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n\t/**\r\n\t* @dev Multiplies two numbers, throws on overflow.\r\n\t*/\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns(uint256 c) {\r\n\t\tif (a == 0 || b == 0) {\r\n\t\t   return 0;\r\n\t\t}\r\n\t\tc = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Integer division of two numbers, truncating the quotient.\r\n\t*/\r\n\tfunction div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\t// uint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Adds two numbers, throws on overflow.\r\n\t*/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns(uint256 c) {\r\n\t\tc = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Subtracts two numbers, throws on underflow\r\n\t*/\r\n\tfunction sub(int256 a, int256 b) internal pure returns(int256 c) {\r\n\t\tc = a - b;\r\n\t\tassert(c <= a);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Adds two numbers, throws on overflow.\r\n\t*/\r\n\tfunction add(int256 a, int256 b) internal pure returns(int256 c) {\r\n\t\tc = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}"
    }
  }
}