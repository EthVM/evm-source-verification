{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DrillBase.sol":{"content":"// hevm: flattened sources of src/DrillBase.sol\r\npragma solidity >=0.4.23 >=0.4.24 <0.7.0 >=0.6.7 <0.7.0;\r\n\r\n////// lib/ds-auth/src/auth.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity >=0.4.23; */\r\n\r\ninterface DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) external view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\n////// lib/zeppelin-solidity/src/proxy/Initializable.sol\r\n// SPDX-License-Identifier: MIT\r\n\r\n// solhint-disable-next-line compiler-version\r\n/* pragma solidity >=0.4.24 <0.7.0; */\r\n\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n * \r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n * \r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function _isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        address self = address(this);\r\n        uint256 cs;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { cs := extcodesize(self) }\r\n        return cs == 0;\r\n    }\r\n}\r\n\r\n////// src/interfaces/IObjectOwnership.sol\r\n/* pragma solidity ^0.6.7; */\r\n\r\ninterface IObjectOwnership {\r\n    function mintObject(address _to, uint128 _objectId) external returns (uint256 _tokenId);\r\n\t\r\n    function burn(address _to, uint256 _tokenId) external;\r\n}\r\n\r\n////// src/interfaces/ISettingsRegistry.sol\r\n/* pragma solidity ^0.6.7; */\r\n\r\ninterface ISettingsRegistry {\r\n    enum SettingsValueTypes { NONE, UINT, STRING, ADDRESS, BYTES, BOOL, INT }\r\n\r\n    function uintOf(bytes32 _propertyName) external view returns (uint256);\r\n\r\n    function stringOf(bytes32 _propertyName) external view returns (string memory);\r\n\r\n    function addressOf(bytes32 _propertyName) external view returns (address);\r\n\r\n    function bytesOf(bytes32 _propertyName) external view returns (bytes memory);\r\n\r\n    function boolOf(bytes32 _propertyName) external view returns (bool);\r\n\r\n    function intOf(bytes32 _propertyName) external view returns (int);\r\n\r\n    function setUintProperty(bytes32 _propertyName, uint _value) external;\r\n\r\n    function setStringProperty(bytes32 _propertyName, string calldata _value) external;\r\n\r\n    function setAddressProperty(bytes32 _propertyName, address _value) external;\r\n\r\n    function setBytesProperty(bytes32 _propertyName, bytes calldata _value) external;\r\n\r\n    function setBoolProperty(bytes32 _propertyName, bool _value) external;\r\n\r\n    function setIntProperty(bytes32 _propertyName, int _value) external;\r\n\r\n    function getValueTypeOf(bytes32 _propertyName) external view returns (uint /* SettingsValueTypes */ );\r\n\r\n    event ChangeProperty(bytes32 indexed _propertyName, uint256 _type);\r\n}\r\n\r\n////// src/DrillBase.sol\r\n/* pragma solidity ^0.6.7; */\r\n\r\n/* import \"zeppelin-solidity/proxy/Initializable.sol\"; */\r\n/* import \"ds-auth/auth.sol\"; */\r\n/* import \"./interfaces/ISettingsRegistry.sol\"; */\r\n/* import \"./interfaces/IObjectOwnership.sol\"; */\r\n\r\ncontract DrillBase is Initializable, DSAuth {\r\n\tevent Create(\r\n\t\taddress indexed owner,\r\n\t\tuint256 indexed tokenId,\r\n\t\tuint16 grade,\r\n\t\tuint256 createTime\r\n\t);\r\n\tevent Destroy(address indexed owner, uint256 indexed tokenId);\r\n\r\n\tuint256 internal constant _CLEAR_HIGH =\r\n\t\t0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\r\n\r\n\t// 0x434f4e54524143545f4f424a4543545f4f574e45525348495000000000000000\r\n\tbytes32 public constant CONTRACT_OBJECT_OWNERSHIP =\r\n\t\t\"CONTRACT_OBJECT_OWNERSHIP\";\r\n\r\n\t/*** STORAGE ***/\r\n\tuint128 public lastDrillObjectId;\r\n\r\n\tISettingsRegistry public registry;\r\n\r\n\t/**\r\n\t * @dev Same with constructor, but is used and called by storage proxy as logic contract.\r\n\t */\r\n\tfunction initialize(address _registry) public initializer {\r\n\t\towner = msg.sender;\r\n\t\temit LogSetOwner(msg.sender);\r\n\r\n\t\tregistry = ISettingsRegistry(_registry);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev create a Drill.\r\n\t * @param grade - Drill grade.\r\n\t * @param to - owner of the Drill.\r\n\t * @return   - tokenId.\r\n\t */\r\n\tfunction createDrill(uint16 grade, address to)\r\n\t\tpublic\r\n\t\tauth\r\n\t\treturns (uint256)\r\n\t{\r\n\t\treturn _createDrill(grade, to);\r\n\t}\r\n\r\n\tfunction _createDrill(uint16 grade, address to) internal returns (uint256) {\r\n\t\tlastDrillObjectId += 1;\r\n\t\trequire(\r\n\t\t\tlastDrillObjectId < 5192296858534827628530496329220095,\r\n\t\t\t\"Drill: object id overflow.\"\r\n\t\t);\r\n\r\n\t\tuint128 objectId = (uint128(grade) << 112) | lastDrillObjectId;\r\n\r\n\t\tuint256 tokenId =\r\n\t\t\tIObjectOwnership(registry.addressOf(CONTRACT_OBJECT_OWNERSHIP))\r\n\t\t\t\t.mintObject(to, objectId);\r\n\t\temit Create(\r\n\t\t\tto,\r\n\t\t\ttokenId,\r\n\t\t\tgrade,\r\n\t\t\tnow // solhint-disable-line\r\n\t\t);\r\n\t\treturn tokenId;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev destroy a Drill.\r\n\t * @param to owner of the drill.\r\n\t * @param tokenId tokenId of the drill.\r\n\t */\r\n\tfunction destroyDrill(address to, uint256 tokenId) public auth {\r\n\t\tIObjectOwnership(registry.addressOf(CONTRACT_OBJECT_OWNERSHIP)).burn(\r\n\t\t\tto,\r\n\t\t\ttokenId\r\n\t\t);\r\n\t\temit Destroy(to, tokenId);\r\n\t}\r\n\r\n\tfunction getGrade(uint256 tokenId) public pure returns (uint16) {\r\n\t\tuint128 objectId = uint128(tokenId & _CLEAR_HIGH);\r\n\t\treturn uint16(objectId >> 112);\r\n\t}\r\n}"}}}