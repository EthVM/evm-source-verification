{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ChainlinkOracle.sol":{"content":"/*\n * Origin Protocol\n * https://originprotocol.com\n *\n * Released under the MIT license\n * https://github.com/OriginProtocol/origin-dollar\n *\n * Copyright 2020 Origin Protocol, Inc\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n// File: contracts/oracle/AggregatorV3Interface.sol\n\npragma solidity ^0.5.11;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n// File: contracts/interfaces/IPriceOracle.sol\n\npragma solidity 0.5.11;\n\ninterface IPriceOracle {\n    /**\n     * @dev returns the asset price in USD, 6 decimal digits.\n     * Compatible with the Open Price Feed.\n     */\n    function price(string calldata symbol) external view returns (uint256);\n}\n\n// File: contracts/interfaces/IEthUsdOracle.sol\n\npragma solidity 0.5.11;\n\ninterface IEthUsdOracle {\n    /**\n     * @notice Returns ETH price in USD.\n     * @return Price in USD with 6 decimal digits.\n     */\n    function ethUsdPrice() external view returns (uint256);\n\n    /**\n     * @notice Returns token price in USD.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in USD with 6 decimal digits.\n     */\n    function tokUsdPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the asset price in ETH.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in ETH with 8 decimal digits.\n     */\n    function tokEthPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n}\n\ninterface IViewEthUsdOracle {\n    /**\n     * @notice Returns ETH price in USD.\n     * @return Price in USD with 6 decimal digits.\n     */\n    function ethUsdPrice() external view returns (uint256);\n\n    /**\n     * @notice Returns token price in USD.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in USD with 6 decimal digits.\n     */\n    function tokUsdPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the asset price in ETH.\n     * @param symbol. Asset symbol. For ex. \"DAI\".\n     * @return Price in ETH with 8 decimal digits.\n     */\n    function tokEthPrice(string calldata symbol)\n        external\n        view\n        returns (uint256);\n}\n\n// File: contracts/governance/Governable.sol\n\npragma solidity 0.5.11;\n\n/**\n * @title OUSD Governable Contract\n * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\n *      from owner to governor and renounce methods removed. Does not use\n *      Context.sol like Ownable.sol does for simplification.\n * @author Origin Protocol Inc\n */\ncontract Governable {\n    // Storage position of the owner and pendingOwner of the contract\n    // keccak256(\"OUSD.governor\");\n    bytes32\n        private constant governorPosition = 0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\n\n    // keccak256(\"OUSD.pending.governor\");\n    bytes32\n        private constant pendingGovernorPosition = 0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\n\n    // keccak256(\"OUSD.reentry.status\");\n    bytes32\n        private constant reentryStatusPosition = 0x53bf423e48ed90e97d02ab0ebab13b2a235a6bfbe9c321847d5c175333ac4535;\n\n    // See OpenZeppelin ReentrancyGuard implementation\n    uint256 constant _NOT_ENTERED = 1;\n    uint256 constant _ENTERED = 2;\n\n    event PendingGovernorshipTransfer(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    event GovernorshipTransferred(\n        address indexed previousGovernor,\n        address indexed newGovernor\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial Governor.\n     */\n    constructor() internal {\n        _setGovernor(msg.sender);\n        emit GovernorshipTransferred(address(0), _governor());\n    }\n\n    /**\n     * @dev Returns the address of the current Governor.\n     */\n    function governor() public view returns (address) {\n        return _governor();\n    }\n\n    /**\n     * @dev Returns the address of the current Governor.\n     */\n    function _governor() internal view returns (address governorOut) {\n        bytes32 position = governorPosition;\n        assembly {\n            governorOut := sload(position)\n        }\n    }\n\n    /**\n     * @dev Returns the address of the pending Governor.\n     */\n    function _pendingGovernor()\n        internal\n        view\n        returns (address pendingGovernor)\n    {\n        bytes32 position = pendingGovernorPosition;\n        assembly {\n            pendingGovernor := sload(position)\n        }\n    }\n\n    /**\n     * @dev Throws if called by any account other than the Governor.\n     */\n    modifier onlyGovernor() {\n        require(isGovernor(), \"Caller is not the Governor\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current Governor.\n     */\n    function isGovernor() public view returns (bool) {\n        return msg.sender == _governor();\n    }\n\n    function _setGovernor(address newGovernor) internal {\n        bytes32 position = governorPosition;\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        bytes32 position = reentryStatusPosition;\n        uint256 _reentry_status;\n        assembly {\n            _reentry_status := sload(position)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_reentry_status != _ENTERED, \"Reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        assembly {\n            sstore(position, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        assembly {\n            sstore(position, _NOT_ENTERED)\n        }\n    }\n\n    function _setPendingGovernor(address newGovernor) internal {\n        bytes32 position = pendingGovernorPosition;\n        assembly {\n            sstore(position, newGovernor)\n        }\n    }\n\n    /**\n     * @dev Transfers Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the current Governor. Must be claimed for this to complete\n     * @param _newGovernor Address of the new Governor\n     */\n    function transferGovernance(address _newGovernor) external onlyGovernor {\n        _setPendingGovernor(_newGovernor);\n        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\n    }\n\n    /**\n     * @dev Claim Governance of the contract to a new account (`newGovernor`).\n     * Can only be called by the new Governor.\n     */\n    function claimGovernance() external {\n        require(\n            msg.sender == _pendingGovernor(),\n            \"Only the pending Governor can complete the claim\"\n        );\n        _changeGovernor(msg.sender);\n    }\n\n    /**\n     * @dev Change Governance of the contract to a new account (`newGovernor`).\n     * @param _newGovernor Address of the new Governor\n     */\n    function _changeGovernor(address _newGovernor) internal {\n        require(_newGovernor != address(0), \"New Governor is address(0)\");\n        emit GovernorshipTransferred(_governor(), _newGovernor);\n        _setGovernor(_newGovernor);\n    }\n}\n\n// File: contracts/oracle/ChainlinkOracle.sol\n\npragma solidity 0.5.11;\n\n/**\n * @title OUSD ChainlinkOracle Contract\n * @author Origin Protocol Inc\n */\n\n\n\n\ncontract ChainlinkOracle is IEthUsdOracle, IPriceOracle, Governable {\n    event FeedRegistered(address _feed, string _symbol, bool _directToUsd);\n\n    address ethFeed;\n\n    struct FeedConfig {\n        address feed;\n        uint8 decimals;\n        bool directToUsd;\n    }\n\n    mapping(bytes32 => FeedConfig) feeds;\n\n    uint8 ethDecimals;\n\n    string constant ethSymbol = \"ETH\";\n    bytes32 constant ethHash = keccak256(abi.encodePacked(ethSymbol));\n\n    constructor(address ethFeed_) public {\n        ethFeed = ethFeed_;\n        ethDecimals = AggregatorV3Interface(ethFeed_).decimals();\n    }\n\n    function registerFeed(\n        address feed,\n        string memory symbol,\n        bool directToUsd\n    ) public onlyGovernor {\n        FeedConfig storage config = feeds[keccak256(abi.encodePacked(symbol))];\n\n        config.feed = feed;\n        config.decimals = AggregatorV3Interface(feed).decimals();\n        config.directToUsd = directToUsd;\n\n        emit FeedRegistered(feed, symbol, directToUsd);\n    }\n\n    function getLatestPrice(address feed) internal view returns (int256) {\n        (\n            uint80 roundID,\n            int256 price,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(feed).latestRoundData();\n        // silence\n        roundID;\n        startedAt;\n        timeStamp;\n        answeredInRound;\n        return price;\n    }\n\n    function ethUsdPrice() external view returns (uint256) {\n        return (uint256(getLatestPrice(ethFeed)) /\n            (uint256(10)**(ethDecimals - 6)));\n    }\n\n    function tokUsdPrice(string calldata symbol)\n        external\n        view\n        returns (uint256)\n    {\n        bytes32 tokenSymbolHash = keccak256(abi.encodePacked(symbol));\n        FeedConfig storage config = feeds[tokenSymbolHash];\n        int256 tPrice = getLatestPrice(config.feed);\n\n        require(config.directToUsd, \"Price is not direct to usd\");\n        require(tPrice > 0, \"Price must be greater than zero\");\n        return uint256(tPrice);\n    }\n\n    function tokEthPrice(string calldata symbol)\n        external\n        view\n        returns (uint256)\n    {\n        bytes32 tokenSymbolHash = keccak256(abi.encodePacked(symbol));\n        FeedConfig storage config = feeds[tokenSymbolHash];\n        int256 tPrice = getLatestPrice(config.feed);\n\n        require(!config.directToUsd, \"Price is not in terms of ETH\");\n        require(tPrice > 0, \"Price must be greater than zero\");\n        //attempt to return 8 digit precision here\n        return uint256(tPrice) / (uint256(10)**(config.decimals - 8));\n    }\n\n    // This actually calculate the latest price from outside oracles\n    // It's a view but substantially more costly in terms of calculation\n    function price(string calldata symbol) external view returns (uint256) {\n        bytes32 tokenSymbolHash = keccak256(abi.encodePacked(symbol));\n\n        if (ethHash == tokenSymbolHash) {\n            return (uint256(getLatestPrice(ethFeed)) /\n                (uint256(10)**(ethDecimals - 6)));\n        } else {\n            FeedConfig storage config = feeds[tokenSymbolHash];\n            int256 tPrice = getLatestPrice(config.feed);\n\n            if (config.directToUsd) {\n                require(tPrice > 0, \"Price must be greater than zero\");\n                return uint256(tPrice);\n            } else {\n                int256 ethPrice = getLatestPrice(ethFeed); // grab the eth price from the open oracle\n                require(\n                    tPrice > 0 && ethPrice > 0,\n                    \"Both eth and price must be greater than zero\"\n                );\n                //not actually sure why it's 6 units here, this is just to match with openoracle for now\n                return\n                    mul(uint256(tPrice), uint256(ethPrice)) /\n                    (uint256(10)**(ethDecimals + config.decimals - 6));\n            }\n        }\n    }\n\n    /// @dev Overflow proof multiplication\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"multiplication overflow\");\n        return c;\n    }\n}\n"}}}