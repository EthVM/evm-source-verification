{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"LiquidityProtectionSingleLimitStrategy.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"./StrategyBase.sol\";\n\ncontract LiquidityProtectionSingleLimitStrategy is StrategyBase {\n    mapping(address => Protection) private protection;\n\n    struct Limit {\n        uint256 periodInSeconds;  \n        uint256 lastCheckpointTime; \n        uint256 amountPerPeriod;\n        uint256 amountLeftInCurrentPeriod;\n    }\n\n    struct Protection {\n        mapping(address => Limit) limits;\n    }\n\n    constructor(Guardian _guardian, LosslessController _controller) StrategyBase(_guardian, _controller) {}\n\n    // --- VIEWS ---\n\n    function getLimit(address token, address protectedAddress) external view returns(Limit memory) {\n        return protection[token].limits[protectedAddress];\n    }\n\n    // --- METHODS ---\n\n    // @param token Project token, the protection will be scoped inside of this token's transfers.\n    // @param protectedAddress Address to apply the limits to.\n    // @param periodInSeconds Limit period in seconds.\n    // @param amountPerPeriod Max amount that can be transfered in period.\n    // @param startTimestamp Shows when limit should be activated.\n    // @dev This method allows setting 1 limit to 0...N addresses.\n    function setLimitBatched(\n        address token,\n        address[] calldata protectedAddresses,\n        uint256 periodInSeconds,\n        uint256 amountPerPeriod,\n        uint256 startTimestamp\n    ) external onlyProtectionAdmin(token) {\n        for(uint8 i = 0; i < protectedAddresses.length; i++) {\n            saveLimit(token, protectedAddresses[i], periodInSeconds, amountPerPeriod, startTimestamp);\n            guardian.setProtectedAddress(token, protectedAddresses[i]);\n        }\n    }\n\n    // @dev params pretty much the same as in batched\n    // @dev This method allows setting 1 limit 1 address.\n    function setLimit(\n        address token,\n        address protectedAddress,\n        uint256 periodInSeconds,\n        uint256 amountPerPeriod,\n        uint256 startTimestamp\n    ) external onlyProtectionAdmin(token) {\n        \n        saveLimit(token, protectedAddress, periodInSeconds, amountPerPeriod, startTimestamp);\n        guardian.setProtectedAddress(token, protectedAddress);\n    }\n\n    function removeLimits(address token, address[] calldata protectedAddresses) external onlyProtectionAdmin(token) {\n        for(uint8 i = 0; i < protectedAddresses.length; i++) {\n            delete protection[token].limits[protectedAddresses[i]];\n            guardian.removeProtectedAddresses(token, protectedAddresses[i]);\n        }\n    }\n\n    // @dev Pausing is just adding a limit with amount 0.\n    // @dev amountLeftInCurrentPeriod never resets because of the lastCheckpointTime\n    // @dev This approach uses less gas than having a separate isPaused flag.\n    function pause(address token, address protectedAddress) external onlyProtectionAdmin(token) {\n        require(controller.isAddressProtected(token, protectedAddress), \"LOSSLESS: Address not protected\");\n        Limit storage limit = protection[token].limits[protectedAddress];\n        limit.amountLeftInCurrentPeriod = 0;\n        limit.lastCheckpointTime = type(uint256).max - limit.periodInSeconds;\n        emit Paused(token, protectedAddress);\n    }\n\n    // @dev Limit is reset every period.\n    // @dev Every period has it's own amountLeft which gets decreased on every transfer.\n    // @dev This method modifies state so should be callable only by the trusted address!\n    function isTransferAllowed(address token, address sender, address recipient, uint256 amount) external {\n        require(msg.sender == address(controller), \"LOSSLESS: LSS Controller only\");\n        Limit storage limit = protection[token].limits[sender];\n\n        // Is transfer is in the same period ?\n        if (limit.lastCheckpointTime + limit.periodInSeconds > block.timestamp) { \n            limit.amountLeftInCurrentPeriod = calculateAmountLeft(amount, limit.amountLeftInCurrentPeriod);\n        }\n        // New period started, update checkpoint and reset amount\n        else {\n            limit.lastCheckpointTime = calculateUpdatedCheckpoint(limit.lastCheckpointTime, limit.periodInSeconds);\n            limit.amountLeftInCurrentPeriod = calculateAmountLeft(amount, limit.amountPerPeriod);\n        }\n        \n        require(limit.amountLeftInCurrentPeriod > 0, \"LOSSLESS: Strategy Limit reached\");\n    }\n\n    // --- INTERNAL METHODS ---\n\n    function saveLimit(\n        address token,\n        address protectedAddress,\n        uint256 periodInSeconds,\n        uint256 amountPerPeriod,\n        uint256 startTimestamp\n    ) internal {\n        Limit storage limit = protection[token].limits[protectedAddress];\n        limit.periodInSeconds = periodInSeconds;\n        limit.amountPerPeriod = amountPerPeriod;\n        limit.lastCheckpointTime = startTimestamp;\n        limit.amountLeftInCurrentPeriod = amountPerPeriod;\n    }\n\n    function calculateAmountLeft(uint256 amount, uint256 amountLeft) internal pure returns (uint256)  {\n        if (amount >= amountLeft) {\n            return 0;\n        } else {\n            return amountLeft - amount;\n        }\n    }\n\n    function calculateUpdatedCheckpoint(uint256 lastCheckpoint, uint256 periodInSeconds) internal view returns(uint256) {\n        return lastCheckpoint + (periodInSeconds * ((block.timestamp - lastCheckpoint) / periodInSeconds));\n    }\n}"},"StrategyBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\ninterface LosslessController {\n    function admin() external returns(address);\n\n    function isAddressProtected(address token, address protectedAddress) external view returns (bool);\n}\n\ninterface Guardian {\n    function protectionAdmin(address token) external returns (address);\n\n    function setProtectedAddress(address token, address guardedAddress) external;\n\n    function removeProtectedAddresses(address token, address protectedAddress) external;\n}\n\nabstract contract StrategyBase {\n    Guardian public guardian;\n    LosslessController public controller;\n\n    // --- EVENTS ---\n\n    event GuardianSet(address indexed newGuardian);\n    event Paused(address indexed token, address indexed protectedAddress);\n    event Unpaused(address indexed token, address indexed protectedAddress);\n\n    constructor(Guardian _guardian, LosslessController _controller) {\n        guardian = _guardian;\n        controller = _controller;\n    }\n\n    // --- MODIFIERS ---\n\n    modifier onlyProtectionAdmin(address token) {\n        require(msg.sender == guardian.protectionAdmin(token), \"LOSSLESS: Not protection admin\");\n        _;\n    }\n\n    // --- METHODS ---\n\n    // @dev In case guardian is changed, this allows not to redeploy strategy and just update it.\n    function setGuardian(Guardian newGuardian) external {\n        require(msg.sender == controller.admin(), \"LOSSLESS: Not lossless admin\");\n        guardian = newGuardian;\n        emit GuardianSet(address(newGuardian));\n    }\n}"}}}