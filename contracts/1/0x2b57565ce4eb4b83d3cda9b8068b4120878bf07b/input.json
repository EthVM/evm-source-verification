{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/NFT8008.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nabstract contract IClock {\n    function mint(uint256 tokenId) external payable {}\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable {}\n}\n\ncontract nft8008 {\n    // Clock8008 will be the base contract with ownership data\n\n    // Note: The process of \"approving\", \"transfering\" etc should all be done on the base contract\n    address internal constant base = 0xf2470e641a551D7Dbdf4B8D064Cf208edfB06586;\n\n    fallback(bytes calldata) external payable returns (bytes memory) {\n        (bool success, bytes memory m) = base.call{value: msg.value}(msg.data);\n        require(success);\n        return m;\n    }\n\n    function mint(uint256 tokenId) public payable {\n        IClock(base).mint{value: msg.value}(tokenId);\n        IClock(base).transferFrom(address(this), msg.sender, tokenId);\n    }\n\n    function name() public pure returns (string memory) {\n        return \"NFT8008\";\n    }\n\n    function symbol() public pure returns (string memory) {\n        return \"NFT8008\";\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    function tokenURI(uint256 tokenId) public pure returns (string memory) {\n        string[3] memory parts;\n        parts[\n            0\n        ] = '<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"420x\" height=\"420px\" viewBox=\"0 0 100 100\"><style type=\"text/css\">@font-face{font-family:\"Share Tech Mono\";font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/sharetechmono/v10/J7aHnp1uDWRBEqV98dVQztYldFcLowEF.woff2) format(\"woff2\");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}text{filter:url(#filter);fill:#fff;font-family:\"Share Tech Mono\",sans-serif;font-size:20px;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}body{background:#000}.info{color:#fff;font:1em/1 sans-serif;text-align:center}.info a{color:#fff}svg{width:420px;height:420px;display:block;position:relative;overflow:hidden;background:#000}</style> <defs> <filter id=\"filter\"> <feFlood flood-color=\"black\" result=\"black\"/> <feFlood flood-color=\"red\" result=\"flood1\"/> <feFlood flood-color=\"limegreen\" result=\"flood2\"/> <feOffset in=\"SourceGraphic\" dx=\"3\" dy=\"0\" result=\"off1a\"/> <feOffset in=\"SourceGraphic\" dx=\"2\" dy=\"0\" result=\"off1b\"/> <feOffset in=\"SourceGraphic\" dx=\"-3\" dy=\"0\" result=\"off2a\"/> <feOffset in=\"SourceGraphic\" dx=\"-2\" dy=\"0\" result=\"off2b\"/> <feComposite in=\"flood1\" in2=\"off1a\" operator=\"in\" result=\"comp1\"/> <feComposite in=\"flood2\" in2=\"off2a\" operator=\"in\" result=\"comp2\"/> <feMerge x=\"0\" width=\"100%\" result=\"merge1\"> <feMergeNode in=\"black\"/> <feMergeNode in=\"comp1\"/> <feMergeNode in=\"off1b\"/> <animate attributeName=\"y\" id=\"y\" dur=\"4s\" values=\"104px; 104px; 30px; 105px; 30px; 2px; 2px; 50px; 40px; 105px; 105px; 20px; 60px; 40px; 104px; 40px; 70px; 10px; 30px; 104px; 102px\" keyTimes=\"0; 0.362; 0.368; 0.421; 0.440; 0.477; 0.518; 0.564; 0.593; 0.613; 0.644; 0.693; 0.721; 0.736; 0.772; 0.818; 0.844; 0.894; 0.925; 0.939; 1\" repeatCount=\"indefinite\"/> <animate attributeName=\"height\" id=\"h\" dur=\"4s\" values=\"10px; 0px; 10px; 30px; 50px; 0px; 10px; 0px; 0px; 0px; 10px; 50px; 40px; 0px; 0px; 0px; 40px; 30px; 10px; 0px; 50px\" keyTimes=\"0; 0.362; 0.368; 0.421; 0.440; 0.477; 0.518; 0.564; 0.593; 0.613; 0.644; 0.693; 0.721; 0.736; 0.772; 0.818; 0.844; 0.894; 0.925; 0.939; 1\" repeatCount=\"indefinite\"/> </feMerge> <feMerge x=\"0\" width=\"100%\" y=\"60px\" height=\"65px\" result=\"merge2\"> <feMergeNode in=\"black\"/> <feMergeNode in=\"comp2\"/> <feMergeNode in=\"off2b\"/> <animate attributeName=\"y\" id=\"y\" dur=\"4s\" values=\"103px; 104px; 69px; 53px; 42px; 104px; 78px; 89px; 96px; 100px; 67px; 50px; 96px; 66px; 88px; 42px; 13px; 100px; 100px; 104px;\" keyTimes=\"0; 0.055; 0.100; 0.125; 0.159; 0.182; 0.202; 0.236; 0.268; 0.326; 0.357; 0.400; 0.408; 0.461; 0.493; 0.513; 0.548; 0.577; 0.613; 1\" repeatCount=\"indefinite\"/> <animate attributeName=\"height\" id=\"h\" dur=\"4s\" values=\"0px; 0px; 0px; 16px; 16px; 12px; 12px; 0px; 0px; 5px; 10px; 22px; 33px; 11px; 0px; 0px; 10px\" keyTimes=\"0; 0.055; 0.100; 0.125; 0.159; 0.182; 0.202; 0.236; 0.268; 0.326; 0.357; 0.400; 0.408; 0.461; 0.493; 0.513; 1\" repeatCount=\"indefinite\"/> </feMerge> <feMerge> <feMergeNode in=\"SourceGraphic\"/> <feMergeNode in=\"merge1\"/> <feMergeNode in=\"merge2\"/> </feMerge> </filter> </defs> <g> <text x=\"50%\" y=\"20\" dominant-baseline=\"middle\" text-anchor=\"middle\"> NFT8008 </text> <text style=\"font-size:32px\" x=\"50%\" y=\"50\" dominant-baseline=\"middle\" text-anchor=\"middle\"> #';\n        parts[1] = Utils.toString(tokenId);\n        parts[2] = \"</text></g></svg>\";\n\n        string memory output = string(\n            abi.encodePacked(parts[0], parts[1], parts[2])\n        );\n\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"NFT8008 Passport #',\n                        Utils.toString(tokenId),\n                        '\", \"description\": \"NFT8008 is your passport to the 8008 digital collectible world. It is the all-in-one pass for the ever expanding 8008 meta-universe. Buy once, valid forever!\", \"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(bytes(output)),\n                        '\"}'\n                    )\n                )\n            )\n        );\n        output = string(\n            abi.encodePacked(\"data:application/json;base64,\", json)\n        );\n\n        return output;\n    }\n}\n\nlibrary Utils {\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT license\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n\n/// [MIT License]\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n    bytes internal constant TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\n                )\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}\n"
    }
  }
}