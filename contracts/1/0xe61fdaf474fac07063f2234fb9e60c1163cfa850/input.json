{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CoinToken.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMathLib{\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  \r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n  address public coinvest;\r\n  mapping (address => bool) public admins;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n    coinvest = msg.sender;\r\n    admins[owner] = true;\r\n    admins[coinvest] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier onlyCoinvest() {\r\n      require(msg.sender == coinvest);\r\n      _;\r\n  }\r\n\r\n  modifier onlyAdmin() {\r\n      require(admins[msg.sender]);\r\n      _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n  \r\n  /**\r\n   * @dev Changes the Coinvest wallet that will receive funds from investment contract.\r\n   * @param _newCoinvest The address of the new wallet.\r\n  **/\r\n  function transferCoinvest(address _newCoinvest) \r\n    external\r\n    onlyCoinvest\r\n  {\r\n    require(_newCoinvest != address(0));\r\n    coinvest = _newCoinvest;\r\n  }\r\n\r\n  /**\r\n   * @dev Used to add admins who are allowed to add funds to the investment contract.\r\n   * @param _user The address of the admin to add or remove.\r\n   * @param _status True to add the user, False to remove the user.\r\n  **/\r\n  function alterAdmin(address _user, bool _status)\r\n    external\r\n    onlyCoinvest\r\n  {\r\n    require(_user != address(0));\r\n    require(_user != coinvest);\r\n    admins[_user] = _status;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @dev Abstract contract for approveAndCall.\r\n**/\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n}\r\n\r\n/**\r\n * @title Coin Utility Token\r\n * @dev ERC20 contract utilizing ERC865 structure (3esmit's implementation with alterations).\r\n * @dev to allow users to pay Ethereum fees in tokens.\r\n * @author Coin -- Robert M.C. Forster\r\n**/\r\ncontract CoinToken is Ownable {\r\n    using SafeMathLib for uint256;\r\n    \r\n    string public constant symbol = \"COIN\";\r\n    string public constant name = \"Coin Utility Token\";\r\n    \r\n    uint8 public constant decimals = 18;\r\n    uint256 private _totalSupply = 107142857 * (10 ** 18);\r\n    \r\n    // Function sigs to be used within contract for signature recovery.\r\n    bytes4 internal constant transferSig = 0xa9059cbb;\r\n    bytes4 internal constant approveSig = 0x095ea7b3;\r\n    bytes4 internal constant increaseApprovalSig = 0xd73dd623;\r\n    bytes4 internal constant decreaseApprovalSig = 0x66188463;\r\n    bytes4 internal constant approveAndCallSig = 0xcae9ca51;\r\n    bytes4 internal constant revokeHashSig = 0x70de43f1;\r\n\r\n    // Balances for each account\r\n    mapping(address => uint256) balances;\r\n\r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n    \r\n    // Mapping of past used hashes: true if already used.\r\n    mapping(address => mapping (bytes32 => bool)) invalidHashes;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed from, address indexed spender, uint tokens);\r\n    event HashRedeemed(bytes32 indexed txHash, address indexed from);\r\n\r\n    /**\r\n     * @dev Set owner and beginning balance.\r\n    **/\r\n    constructor()\r\n      public\r\n    {\r\n        balances[msg.sender] = _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev approveAndCall reception used primarily to pay gas with other tokens.\r\n    **/\r\n    function receiveApproval(address _from, uint256 _amount, address _token, bytes _data) \r\n      public\r\n    {\r\n        require(msg.sender != address(this));\r\n        require(address(this).delegatecall(_data));\r\n        _from; _amount; _token;\r\n    }\r\n\r\n/** ******************************** ERC20 ********************************* **/\r\n\r\n    /**\r\n     * @dev Transfers coins from one address to another.\r\n     * @param _to The recipient of the transfer amount.\r\n     * @param _amount The amount of tokens to transfer.\r\n    **/\r\n    function transfer(address _to, uint256 _amount) \r\n      public\r\n    returns (bool success)\r\n    {\r\n        require(_transfer(msg.sender, _to, _amount));\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev An allowed address can transfer tokens from another's address.\r\n     * @param _from The owner of the tokens to be transferred.\r\n     * @param _to The address to which the tokens will be transferred.\r\n     * @param _amount The amount of tokens to be transferred.\r\n    **/\r\n    function transferFrom(address _from, address _to, uint _amount)\r\n      public\r\n    returns (bool success)\r\n    {\r\n        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount);\r\n\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        require(_transfer(_from, _to, _amount));\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Approves a wallet to transfer tokens on one's behalf.\r\n     * @param _spender The wallet approved to spend tokens.\r\n     * @param _amount The amount of tokens approved to spend.\r\n    **/\r\n    function approve(address _spender, uint256 _amount) \r\n      public\r\n    returns (bool success)\r\n    {\r\n        require(_approve(msg.sender, _spender, _amount));\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Increases the allowed amount for spender from msg.sender.\r\n     * @param _spender The address to increase allowed amount for.\r\n     * @param _amount The amount of tokens to increase allowed amount by.\r\n    **/\r\n    function increaseApproval(address _spender, uint256 _amount) \r\n      public\r\n    returns (bool success)\r\n    {\r\n        require(_increaseApproval(msg.sender, _spender, _amount));\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Decreases the allowed amount for spender from msg.sender.\r\n     * @param _spender The address to decrease allowed amount for.\r\n     * @param _amount The amount of tokens to decrease allowed amount by.\r\n    **/\r\n    function decreaseApproval(address _spender, uint256 _amount) \r\n      public\r\n    returns (bool success)\r\n    {\r\n        require(_decreaseApproval(msg.sender, _spender, _amount));\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Used to approve an address and call a function on it in the same transaction.\r\n     * @dev _spender The address to be approved to spend COIN.\r\n     * @dev _amount The amount of COIN to be approved to spend.\r\n     * @dev _data The data to send to the called contract.\r\n    **/\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _data) \r\n      public\r\n    returns (bool success) \r\n    {\r\n        require(_approve(msg.sender, _spender, _amount));\r\n        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _data);\r\n        return true;\r\n    }\r\n\r\n/** ****************************** Internal ******************************** **/\r\n    \r\n    /**\r\n     * @dev Internal transfer for all functions that transfer.\r\n     * @param _from The address that is transferring coins.\r\n     * @param _to The receiving address of the coins.\r\n     * @param _amount The amount of coins being transferred.\r\n    **/\r\n    function _transfer(address _from, address _to, uint256 _amount)\r\n      internal\r\n    returns (bool success)\r\n    {\r\n        require (_to != address(0), \"Invalid transfer recipient address.\");\r\n        require(balances[_from] >= _amount, \"Sender does not have enough balance.\");\r\n        \r\n        balances[_from] = balances[_from].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        \r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal approve for all functions that require an approve.\r\n     * @param _owner The owner who is allowing spender to use their balance.\r\n     * @param _spender The wallet approved to spend tokens.\r\n     * @param _amount The amount of tokens approved to spend.\r\n    **/\r\n    function _approve(address _owner, address _spender, uint256 _amount) \r\n      internal\r\n    returns (bool success)\r\n    {\r\n        allowed[_owner][_spender] = _amount;\r\n        emit Approval(_owner, _spender, _amount);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Increases the allowed by \"_amount\" for \"_spender\" from \"owner\"\r\n     * @param _owner The address that tokens may be transferred from.\r\n     * @param _spender The address that may transfer these tokens.\r\n     * @param _amount The amount of tokens to transfer.\r\n    **/\r\n    function _increaseApproval(address _owner, address _spender, uint256 _amount)\r\n      internal\r\n    returns (bool success)\r\n    {\r\n        allowed[_owner][_spender] = allowed[_owner][_spender].add(_amount);\r\n        emit Approval(_owner, _spender, allowed[_owner][_spender]);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Decreases the allowed by \"_amount\" for \"_spender\" from \"_owner\"\r\n     * @param _owner The owner of the tokens to decrease allowed for.\r\n     * @param _spender The spender whose allowed will decrease.\r\n     * @param _amount The amount of tokens to decrease allowed by.\r\n    **/\r\n    function _decreaseApproval(address _owner, address _spender, uint256 _amount)\r\n      internal\r\n    returns (bool success)\r\n    {\r\n        if (allowed[_owner][_spender] <= _amount) allowed[_owner][_spender] = 0;\r\n        else allowed[_owner][_spender] = allowed[_owner][_spender].sub(_amount);\r\n        \r\n        emit Approval(_owner, _spender, allowed[_owner][_spender]);\r\n        return true;\r\n    }\r\n    \r\n/** ************************ Delegated Functions *************************** **/\r\n\r\n    /**\r\n     * @dev Called by delegate with a signed hash of the transaction data to allow a user\r\n     * @dev to transfer tokens without paying gas in Ether (they pay in COIN instead).\r\n     * @param _signature Signed hash of data for this transfer.\r\n     * @param _to The address to transfer COIN to.\r\n     * @param _value The amount of COIN to transfer.\r\n     * @param _gasPrice Price (IN COIN) that will be paid per unit of gas by user to \"delegate\".\r\n     * @param _nonce Nonce of the user's new transaction.\r\n    **/\r\n    function transferPreSigned(\r\n        bytes _signature,\r\n        address _to, \r\n        uint256 _value,\r\n        uint256 _gasPrice, \r\n        uint256 _nonce) \r\n      public\r\n    returns (bool) \r\n    {\r\n        // Log starting gas left of transaction for later gas price calculations.\r\n        uint256 gas = gasleft();\r\n        \r\n        // Recover signer address from signature; ensure address is valid.\r\n        address from = recoverPreSigned(_signature, transferSig, _to, _value, \"\", _gasPrice, _nonce);\r\n        require(from != address(0), \"Invalid signature provided.\");\r\n        \r\n        // Require the hash has not been used, declare it used.\r\n        bytes32 txHash = getPreSignedHash(transferSig, _to, _value, \"\", _gasPrice, _nonce);\r\n        require(!invalidHashes[from][txHash], \"Transaction has already been executed.\");\r\n        invalidHashes[from][txHash] = true;\r\n\r\n        // Internal transfer.\r\n        require(_transfer(from, _to, _value));\r\n\r\n        // If the delegate is charging, pay them for gas in COIN.\r\n        if (_gasPrice > 0) {\r\n            // 35000 because of base fee of 21000 and ~14000 for the fee transfer.\r\n            gas = 35000 + gas.sub(gasleft());\r\n            require(_transfer(from, tx.origin, _gasPrice.mul(gas)), \"Gas cost could not be paid.\");\r\n        }\r\n        \r\n        emit HashRedeemed(txHash, from);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Called by a delegate with signed hash to approve a transaction for user.\r\n     * @dev All variables equivalent to transfer except _to:\r\n     * @param _to The address that will be approved to transfer COIN from user's wallet.\r\n    **/\r\n    function approvePreSigned(\r\n        bytes _signature,\r\n        address _to, \r\n        uint256 _value,\r\n        uint256 _gasPrice, \r\n        uint256 _nonce) \r\n      public\r\n    returns (bool) \r\n    {\r\n        uint256 gas = gasleft();\r\n        address from = recoverPreSigned(_signature, approveSig, _to, _value, \"\", _gasPrice, _nonce);\r\n        require(from != address(0), \"Invalid signature provided.\");\r\n\r\n        bytes32 txHash = getPreSignedHash(approveSig, _to, _value, \"\", _gasPrice, _nonce);\r\n        require(!invalidHashes[from][txHash], \"Transaction has already been executed.\");\r\n        invalidHashes[from][txHash] = true;\r\n\r\n        require(_approve(from, _to, _value));\r\n\r\n        if (_gasPrice > 0) {\r\n            gas = 35000 + gas.sub(gasleft());\r\n            require(_transfer(from, tx.origin, _gasPrice.mul(gas)), \"Gas cost could not be paid.\");\r\n        }\r\n\r\n        emit HashRedeemed(txHash, from);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Used to increase the amount allowed for \"_to\" to spend from \"from\"\r\n     * @dev A bare approve allows potentially nasty race conditions when using a delegate.\r\n    **/\r\n    function increaseApprovalPreSigned(\r\n        bytes _signature,\r\n        address _to, \r\n        uint256 _value,\r\n        uint256 _gasPrice, \r\n        uint256 _nonce)\r\n      public\r\n    returns (bool) \r\n    {\r\n        uint256 gas = gasleft();\r\n        address from = recoverPreSigned(_signature, increaseApprovalSig, _to, _value, \"\", _gasPrice, _nonce);\r\n        require(from != address(0), \"Invalid signature provided.\");\r\n\r\n        bytes32 txHash = getPreSignedHash(increaseApprovalSig, _to, _value, \"\", _gasPrice, _nonce);\r\n        require(!invalidHashes[from][txHash], \"Transaction has already been executed.\");\r\n        invalidHashes[from][txHash] = true;\r\n\r\n        require(_increaseApproval(from, _to, _value));\r\n\r\n        if (_gasPrice > 0) {\r\n            gas = 35000 + gas.sub(gasleft());\r\n            require(_transfer(from, tx.origin, _gasPrice.mul(gas)), \"Gas cost could not be paid.\");\r\n        }\r\n        \r\n        emit HashRedeemed(txHash, from);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Added for the same reason as increaseApproval. Decreases to 0 if \"_value\" is greater than allowed.\r\n    **/\r\n    function decreaseApprovalPreSigned(\r\n        bytes _signature,\r\n        address _to, \r\n        uint256 _value, \r\n        uint256 _gasPrice, \r\n        uint256 _nonce) \r\n      public\r\n    returns (bool) \r\n    {\r\n        uint256 gas = gasleft();\r\n        address from = recoverPreSigned(_signature, decreaseApprovalSig, _to, _value, \"\", _gasPrice, _nonce);\r\n        require(from != address(0), \"Invalid signature provided.\");\r\n\r\n        bytes32 txHash = getPreSignedHash(decreaseApprovalSig, _to, _value, \"\", _gasPrice, _nonce);\r\n        require(!invalidHashes[from][txHash], \"Transaction has already been executed.\");\r\n        invalidHashes[from][txHash] = true;\r\n\r\n        require(_decreaseApproval(from, _to, _value));\r\n\r\n        if (_gasPrice > 0) {\r\n            gas = 35000 + gas.sub(gasleft());\r\n            require(_transfer(from, tx.origin, _gasPrice.mul(gas)), \"Gas cost could not be paid.\");\r\n        }\r\n\r\n        emit HashRedeemed(txHash, from);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev approveAndCallPreSigned allows a user to approve a contract and call a function on it\r\n     * @dev in the same transaction. As with the other presigneds, a delegate calls this with signed data from user.\r\n     * @dev This function is the big reason we're using gas price and calculating gas use.\r\n     * @dev Using this with the investment contract can result in varying gas costs.\r\n     * @param _extraData The data to send to the contract.\r\n    **/\r\n    function approveAndCallPreSigned(\r\n        bytes _signature,\r\n        address _to, \r\n        uint256 _value,\r\n        bytes _extraData,\r\n        uint256 _gasPrice,\r\n        uint256 _nonce) \r\n      public\r\n    returns (bool) \r\n    {\r\n        uint256 gas = gasleft();\r\n        address from = recoverPreSigned(_signature, approveAndCallSig, _to, _value, _extraData, _gasPrice, _nonce);\r\n        require(from != address(0), \"Invalid signature provided.\");\r\n\r\n        bytes32 txHash = getPreSignedHash(approveAndCallSig, _to, _value, _extraData, _gasPrice, _nonce);\r\n        require(!invalidHashes[from][txHash], \"Transaction has already been executed.\");\r\n        invalidHashes[from][txHash] = true;\r\n\r\n        if (_value > 0) require(_approve(from, _to, _value));\r\n        ApproveAndCallFallBack(_to).receiveApproval(from, _value, address(this), _extraData);\r\n\r\n        if (_gasPrice > 0) {\r\n            gas = 35000 + gas.sub(gasleft());\r\n            require(_transfer(from, tx.origin, _gasPrice.mul(gas)), \"Gas cost could not be paid.\");\r\n        }\r\n        \r\n        emit HashRedeemed(txHash, from);\r\n        return true;\r\n    }\r\n\r\n/** *************************** Revoke PreSigned ************************** **/\r\n    \r\n    /**\r\n     * @dev Revoke hash without going through a delegate.\r\n     * @param _hashToRevoke The hash that you no longer want to be used.\r\n    **/\r\n    function revokeHash(bytes32 _hashToRevoke)\r\n      public\r\n    returns (bool)\r\n    {\r\n        invalidHashes[msg.sender][_hashToRevoke] = true;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Revoke hash through a delegate.\r\n     * @param _signature The signature allowing this revocation.\r\n     * @param _hashToRevoke The hash that you would like revoked.\r\n     * @param _gasPrice The amount of token wei to be paid for each uint of gas.\r\n    **/\r\n    function revokeHashPreSigned(\r\n        bytes _signature,\r\n        bytes32 _hashToRevoke,\r\n        uint256 _gasPrice)\r\n      public\r\n    returns (bool)\r\n    {\r\n        uint256 gas = gasleft();\r\n        address from = recoverRevokeHash(_signature, _hashToRevoke, _gasPrice);\r\n        require(from != address(0), \"Invalid signature provided.\");\r\n        \r\n        bytes32 txHash = getRevokeHash(_hashToRevoke, _gasPrice);\r\n        require(!invalidHashes[from][txHash], \"Transaction has already been executed.\");\r\n        invalidHashes[from][txHash] = true;\r\n\r\n        invalidHashes[from][_hashToRevoke] = true;\r\n        \r\n        if (_gasPrice > 0) {\r\n            gas = 35000 + gas.sub(gasleft());\r\n            require(_transfer(from, tx.origin, _gasPrice.mul(gas)), \"Gas cost could not be paid.\");\r\n        }\r\n        \r\n        emit HashRedeemed(txHash, from);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get hash for a revocation.\r\n     * @param _hashToRevoke The signature to be revoked.\r\n     * @param _gasPrice The amount to be paid to delegate for sending this tx.\r\n    **/\r\n    function getRevokeHash(bytes32 _hashToRevoke, uint256 _gasPrice)\r\n      public\r\n      view\r\n    returns (bytes32 txHash)\r\n    {\r\n        return keccak256(abi.encodePacked(address(this), revokeHashSig, _hashToRevoke, _gasPrice));\r\n    }\r\n\r\n    /**\r\n     * @dev Recover the address from a revocation hash.\r\n     * @param _hashToRevoke The hash to be revoked.\r\n     * @param _signature The signature allowing this revocation.\r\n     * @param _gasPrice The amount of token wei to be paid for each unit of gas.\r\n    **/\r\n    function recoverRevokeHash(bytes _signature, bytes32 _hashToRevoke, uint256 _gasPrice)\r\n      public\r\n      view\r\n    returns (address from)\r\n    {\r\n        return ecrecoverFromSig(getSignHash(getRevokeHash(_hashToRevoke, _gasPrice)), _signature);\r\n    }\r\n    \r\n/** ************************** PreSigned Constants ************************ **/\r\n\r\n    /**\r\n     * @dev Used in frontend and contract to get hashed data of any given pre-signed transaction.\r\n     * @param _to The address to transfer COIN to.\r\n     * @param _value The amount of COIN to be transferred.\r\n     * @param _extraData Extra data of tx if needed. Transfers and approves will leave this null.\r\n     * @param _function Function signature of the pre-signed function being used.\r\n     * @param _gasPrice The agreed-upon amount of COIN to be paid per unit of gas.\r\n     * @param _nonce The user's nonce of the new transaction.\r\n    **/\r\n    function getPreSignedHash(\r\n        bytes4 _function,\r\n        address _to, \r\n        uint256 _value,\r\n        bytes _extraData,\r\n        uint256 _gasPrice,\r\n        uint256 _nonce)\r\n      public\r\n      view\r\n    returns (bytes32 txHash) \r\n    {\r\n        return keccak256(abi.encodePacked(address(this), _function, _to, _value, _extraData, _gasPrice, _nonce));\r\n    }\r\n    \r\n    /**\r\n     * @dev Recover an address from a signed pre-signed hash.\r\n     * @param _sig The signed hash.\r\n     * @param _function The function signature for function being called.\r\n     * @param _to The address to transfer/approve/transferFrom/etc. tokens to.\r\n     * @param _value The amont of tokens to transfer/approve/etc.\r\n     * @param _extraData The extra data included in the transaction, if any.\r\n     * @param _gasPrice The amount of token wei to be paid to the delegate for each unit of gas.\r\n     * @param _nonce The user's nonce for this transaction.\r\n    **/\r\n    function recoverPreSigned(\r\n        bytes _sig,\r\n        bytes4 _function,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes _extraData,\r\n        uint256 _gasPrice,\r\n        uint256 _nonce) \r\n      public\r\n      view\r\n    returns (address recovered)\r\n    {\r\n        return ecrecoverFromSig(getSignHash(getPreSignedHash(_function, _to, _value, _extraData, _gasPrice, _nonce)), _sig);\r\n    }\r\n    \r\n    /**\r\n     * @dev Add signature prefix to hash for recovery Ã  la ERC191.\r\n     * @param _hash The hashed transaction to add signature prefix to.\r\n    **/\r\n    function getSignHash(bytes32 _hash)\r\n      public\r\n      pure\r\n    returns (bytes32 signHash)\r\n    {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash));\r\n    }\r\n\r\n    /**\r\n     * @dev Helps to reduce stack depth problems for delegations. Thank you to Bokky for this!\r\n     * @param hash The hash of signed data for the transaction.\r\n     * @param sig Contains r, s, and v for recovery of address from the hash.\r\n    **/\r\n    function ecrecoverFromSig(bytes32 hash, bytes sig) \r\n      public \r\n      pure \r\n    returns (address recoveredAddress) \r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        if (sig.length != 65) return address(0);\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            // Here we are loading the last 32 bytes. We exploit the fact that 'mload' will pad with zeroes if we overread.\r\n            // There is no 'mload8' to do this, but that would be nicer.\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n        // Albeit non-transactional signatures are not specified by the YP, one would expect it to match the YP range of [27, 28]\r\n        // geth uses [0, 1] and some clients have followed. This might change, see https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27) v += 27;\r\n        if (v != 27 && v != 28) return address(0);\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n/** ****************************** Constants ******************************* **/\r\n    \r\n    /**\r\n     * @dev Return total supply of token.\r\n    **/\r\n    function totalSupply() \r\n      external\r\n      view \r\n     returns (uint256)\r\n    {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Return balance of a certain address.\r\n     * @param _owner The address whose balance we want to check.\r\n    **/\r\n    function balanceOf(address _owner)\r\n      external\r\n      view \r\n    returns (uint256) \r\n    {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    /**\r\n     * @dev Allowed amount for a user to spend of another's tokens.\r\n     * @param _owner The owner of the tokens approved to spend.\r\n     * @param _spender The address of the user allowed to spend the tokens.\r\n    **/\r\n    function allowance(address _owner, address _spender) \r\n      external\r\n      view \r\n    returns (uint256) \r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n/** ****************************** onlyOwner ******************************* **/\r\n    \r\n    /**\r\n     * @dev Allow the owner to take ERC20 tokens off of this contract if they are accidentally sent.\r\n    **/\r\n    function tokenEscape(address _tokenContract)\r\n      external\r\n      onlyOwner\r\n    {\r\n        CoinToken lostToken = CoinToken(_tokenContract);\r\n        \r\n        uint256 stuckTokens = lostToken.balanceOf(address(this));\r\n        lostToken.transfer(owner, stuckTokens);\r\n    }\r\n    \r\n}"}}}