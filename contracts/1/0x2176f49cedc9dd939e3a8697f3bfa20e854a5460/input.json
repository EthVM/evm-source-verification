{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"KyberHelper.sol":{"content":"/**\r\n * For 0xaa448eff88b1e752d50b87220b543d79eac15a0e reserve\r\n*/\r\n\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nabstract contract IConversionRate {\r\n\r\n    function getStepFunctionData(address token, uint command, uint param) virtual external view returns(int);\r\n    function getListedTokens() virtual external view returns(address[] memory);\r\n    function getBasicRate(address token, bool buy) virtual external view returns(uint);\r\n    function getRateUpdateBlock(address token) virtual external view returns(uint);\r\n    function getCompactData(address token) virtual external view returns(uint, uint, byte, byte);\r\n    function getTokenControlInfo(address token) virtual external view returns(uint, uint, uint);\r\n    \r\n     mapping(address => mapping(uint=>uint)) public tokenImbalanceData;\r\n}\r\n\r\n\r\n\r\ncontract KyberHelper {\r\n    \r\n    // bps - basic rate steps. one step is 1 / 10000 of the rate.\r\n    struct StepFunction {\r\n        int[] x; // quantity for each step. Quantity of each step includes previous steps.\r\n        int[] y; // rate change per quantity step  in bps.\r\n    }\r\n\r\n    struct TokenData {\r\n        address token;\r\n        \r\n        uint256 rateUpdateBlock;\r\n\r\n        uint256 baseBuyRate;\r\n        uint256 baseSellRate;\r\n        \r\n        StepFunction buyRateQtyStepFunction;       // in bps. higher quantity - bigger the rate.\r\n        StepFunction sellRateQtyStepFunction;      // in bps. higher the qua\r\n        StepFunction buyRateImbalanceStepFunction; // in BPS. higher reserve imbalance - bigger the rate.\r\n        StepFunction sellRateImbalanceStepFunction;\r\n    }\r\n    \r\n    struct RatesCompactData {\r\n        address token;\r\n        byte buy;\r\n        byte sell;\r\n    }\r\n    \r\n    struct TokenControlInfo {\r\n        address token;\r\n        uint minimalRecordResolution;\r\n        uint maxPerBlockImbalance;\r\n        uint maxTotalImbalance;\r\n    }\r\n    \r\n    struct TokenImbalanceData {\r\n        address token;\r\n        uint256[5] data;\r\n    }\r\n    \r\n    function getTokenImbalanceData(address conversionRateContract) external view returns (TokenImbalanceData[] memory data) {\r\n        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n        data = new TokenImbalanceData[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            data[i].token = tokens[i];\r\n            for (uint j = 0; j < 5; j++) {\r\n                data[i].data[j] = IConversionRate(conversionRateContract).tokenImbalanceData(tokens[i], j);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getTokenControlInfo(address conversionRateContract) external view returns (TokenControlInfo[] memory data) {\r\n        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n        data = new TokenControlInfo[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n             (\r\n                 uint minimalRecordResolution,\r\n                 uint maxPerBlockImbalance,\r\n                 uint maxTotalImbalance\r\n             ) = IConversionRate(conversionRateContract).getTokenControlInfo(tokens[i]);\r\n            \r\n            data[i].token = tokens[i];\r\n            data[i].minimalRecordResolution = minimalRecordResolution;\r\n            data[i].maxPerBlockImbalance = maxPerBlockImbalance;\r\n            data[i].maxTotalImbalance = maxTotalImbalance;\r\n        }\r\n    }\r\n    \r\n    function getRatesCompactData(address conversionRateContract) external view returns (RatesCompactData[] memory data) {\r\n          address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n          data = new RatesCompactData[](tokens.length);\r\n          for (uint i = 0; i < tokens.length; i++) {\r\n              (,,byte buy, byte sell) = IConversionRate(conversionRateContract).getCompactData(tokens[i]);\r\n              \r\n              data[i].token = tokens[i];\r\n              data[i].buy = buy;\r\n              data[i].sell = sell;\r\n          }\r\n    }\r\n    \r\n    function getStepFunctionData(address conversionRateContract) external view returns (TokenData[] memory data) {\r\n        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\r\n        \r\n        data = new TokenData[](tokens.length);\r\n        \r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            \r\n            data[i].token = tokens[i];\r\n            \r\n            data[i].rateUpdateBlock = IConversionRate(conversionRateContract).getRateUpdateBlock(tokens[i]);\r\n            \r\n            data[i].baseBuyRate = IConversionRate(conversionRateContract).getBasicRate(tokens[i], true);\r\n            data[i].baseSellRate = IConversionRate(conversionRateContract).getBasicRate(tokens[i], false);\r\n            \r\n            uint[8] memory stepFunctionLenList = [\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 0, 0)),  // none\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 2, 0)),  // none\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 4, 0)),  // none\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 6, 0)),  // none\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 10, 0)), // buyRateImbalanceStepFunctionXLen\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 10, 0)), // buyRateImbalanceStepFunctionYLen\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 14, 0)), // sellRateImbalanceStepFunctionXLen\r\n                uint(getStepFunctionData(conversionRateContract, tokens[i], 14, 0))  // sellRateImbalanceStepFunctionYLen\r\n            ]; \r\n            \r\n            data[i].buyRateQtyStepFunction = initStepFunction(stepFunctionLenList[0], stepFunctionLenList[1]);\r\n            data[i].sellRateQtyStepFunction = initStepFunction(stepFunctionLenList[2], stepFunctionLenList[3]);\r\n            data[i].buyRateImbalanceStepFunction = initStepFunction(stepFunctionLenList[4], stepFunctionLenList[5]);\r\n            data[i].sellRateImbalanceStepFunction = initStepFunction(stepFunctionLenList[6], stepFunctionLenList[7]);\r\n\r\n            for (uint j = 0; j < getMaxValue(stepFunctionLenList); j++) {\r\n              if (j < stepFunctionLenList[0]) {\r\n                data[i].buyRateQtyStepFunction.x[j] = getStepFunctionData(conversionRateContract, tokens[i], 1, j);\r\n              }\r\n              if (j < stepFunctionLenList[1]) {\r\n                data[i].buyRateQtyStepFunction.y[j] = getStepFunctionData(conversionRateContract, tokens[i], 3, j);\r\n              }\r\n              if (j < stepFunctionLenList[2]) {\r\n                data[i].sellRateQtyStepFunction.x[j] = getStepFunctionData(conversionRateContract, tokens[i], 5, j);\r\n              }\r\n              if (j < stepFunctionLenList[3]) {\r\n                data[i].sellRateQtyStepFunction.y[j] = getStepFunctionData(conversionRateContract, tokens[i], 7, j);\r\n              }\r\n              if (j < stepFunctionLenList[4]) {\r\n                data[i].buyRateImbalanceStepFunction.x[j] = getStepFunctionData(conversionRateContract, tokens[i], 9, j);\r\n              }\r\n              if (j < stepFunctionLenList[5]) {\r\n                data[i].buyRateImbalanceStepFunction.y[j] = getStepFunctionData(conversionRateContract, tokens[i], 11, j);\r\n              }\r\n              if (j < stepFunctionLenList[6]) {\r\n                data[i].sellRateImbalanceStepFunction.x[j] = getStepFunctionData(conversionRateContract, tokens[i], 13, j);\r\n              }\r\n              if (j < stepFunctionLenList[7]) {\r\n                data[i].sellRateImbalanceStepFunction.y[j] = getStepFunctionData(conversionRateContract, tokens[i], 15, j);\r\n              }  \r\n            }\r\n        }\r\n    }\r\n    \r\n    function getMaxValue(uint[8] memory values) private pure returns (uint) {\r\n        uint max; \r\n        for(uint i = 0; i < values.length; i++) {\r\n            if(values[i] > max) {\r\n                max = values[i]; \r\n            } \r\n        }\r\n        return max;\r\n    }\r\n    \r\n    function initStepFunction(uint xLen, uint yLen) private pure returns (StepFunction memory stepFunc) {\r\n        stepFunc.x = new int[](xLen);\r\n        stepFunc.y = new int[](yLen);\r\n    }\r\n    \r\n    function getStepFunctionData(address conversionRateContract, address token, uint256 command, uint256 param) private view returns (int) {\r\n        try IConversionRate(conversionRateContract).getStepFunctionData(token, command, param) returns (int len) {\r\n            return (len);\r\n        } catch {\r\n            return (0);\r\n        }\r\n    }\r\n    \r\n}"}}}