{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CpuConstraintPoly.sol":{"content":"/*\r\n  Copyright 2019-2021 StarkWare Industries Ltd.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\").\r\n  You may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  https://www.starkware.co/open-source-license/\r\n\r\n  Unless required by applicable law or agreed to in writing,\r\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions\r\n  and limitations under the License.\r\n*/\r\n// ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\r\n// SPDX-License-Identifier: Apache-2.0.\r\npragma solidity ^0.6.11;\r\n\r\ncontract CpuConstraintPoly {\r\n    // The Memory map during the execution of this contract is as follows:\r\n    // [0x0, 0x20) - periodic_column/pedersen/points/x.\r\n    // [0x20, 0x40) - periodic_column/pedersen/points/y.\r\n    // [0x40, 0x60) - periodic_column/ecdsa/generator_points/x.\r\n    // [0x60, 0x80) - periodic_column/ecdsa/generator_points/y.\r\n    // [0x80, 0xa0) - trace_length.\r\n    // [0xa0, 0xc0) - offset_size.\r\n    // [0xc0, 0xe0) - half_offset_size.\r\n    // [0xe0, 0x100) - initial_ap.\r\n    // [0x100, 0x120) - initial_pc.\r\n    // [0x120, 0x140) - final_ap.\r\n    // [0x140, 0x160) - final_pc.\r\n    // [0x160, 0x180) - memory/multi_column_perm/perm/interaction_elm.\r\n    // [0x180, 0x1a0) - memory/multi_column_perm/hash_interaction_elm0.\r\n    // [0x1a0, 0x1c0) - memory/multi_column_perm/perm/public_memory_prod.\r\n    // [0x1c0, 0x1e0) - rc16/perm/interaction_elm.\r\n    // [0x1e0, 0x200) - rc16/perm/public_memory_prod.\r\n    // [0x200, 0x220) - rc_min.\r\n    // [0x220, 0x240) - rc_max.\r\n    // [0x240, 0x260) - pedersen/shift_point.x.\r\n    // [0x260, 0x280) - pedersen/shift_point.y.\r\n    // [0x280, 0x2a0) - initial_pedersen_addr.\r\n    // [0x2a0, 0x2c0) - initial_rc_addr.\r\n    // [0x2c0, 0x2e0) - ecdsa/sig_config.alpha.\r\n    // [0x2e0, 0x300) - ecdsa/sig_config.shift_point.x.\r\n    // [0x300, 0x320) - ecdsa/sig_config.shift_point.y.\r\n    // [0x320, 0x340) - ecdsa/sig_config.beta.\r\n    // [0x340, 0x360) - initial_ecdsa_addr.\r\n    // [0x360, 0x380) - initial_checkpoints_addr.\r\n    // [0x380, 0x3a0) - final_checkpoints_addr.\r\n    // [0x3a0, 0x3c0) - trace_generator.\r\n    // [0x3c0, 0x3e0) - oods_point.\r\n    // [0x3e0, 0x440) - interaction_elements.\r\n    // [0x440, 0x2000) - coefficients.\r\n    // [0x2000, 0x30a0) - oods_values.\r\n    // ----------------------- end of input data - -------------------------\r\n    // [0x30a0, 0x30c0) - composition_degree_bound.\r\n    // [0x30c0, 0x30e0) - intermediate_value/cpu/decode/opcode_rc/bit_0.\r\n    // [0x30e0, 0x3100) - intermediate_value/cpu/decode/opcode_rc/bit_1.\r\n    // [0x3100, 0x3120) - intermediate_value/cpu/decode/opcode_rc/bit_2.\r\n    // [0x3120, 0x3140) - intermediate_value/cpu/decode/opcode_rc/bit_4.\r\n    // [0x3140, 0x3160) - intermediate_value/cpu/decode/opcode_rc/bit_3.\r\n    // [0x3160, 0x3180) - intermediate_value/cpu/decode/opcode_rc/bit_9.\r\n    // [0x3180, 0x31a0) - intermediate_value/cpu/decode/opcode_rc/bit_5.\r\n    // [0x31a0, 0x31c0) - intermediate_value/cpu/decode/opcode_rc/bit_6.\r\n    // [0x31c0, 0x31e0) - intermediate_value/cpu/decode/opcode_rc/bit_7.\r\n    // [0x31e0, 0x3200) - intermediate_value/cpu/decode/opcode_rc/bit_8.\r\n    // [0x3200, 0x3220) - intermediate_value/npc_reg_0.\r\n    // [0x3220, 0x3240) - intermediate_value/cpu/decode/opcode_rc/bit_10.\r\n    // [0x3240, 0x3260) - intermediate_value/cpu/decode/opcode_rc/bit_11.\r\n    // [0x3260, 0x3280) - intermediate_value/cpu/decode/opcode_rc/bit_12.\r\n    // [0x3280, 0x32a0) - intermediate_value/cpu/decode/opcode_rc/bit_13.\r\n    // [0x32a0, 0x32c0) - intermediate_value/cpu/decode/opcode_rc/bit_14.\r\n    // [0x32c0, 0x32e0) - intermediate_value/memory/address_diff_0.\r\n    // [0x32e0, 0x3300) - intermediate_value/rc16/diff_0.\r\n    // [0x3300, 0x3320) - intermediate_value/pedersen/hash0/ec_subset_sum/bit_0.\r\n    // [0x3320, 0x3340) - intermediate_value/pedersen/hash0/ec_subset_sum/bit_neg_0.\r\n    // [0x3340, 0x3360) - intermediate_value/rc_builtin/value0_0.\r\n    // [0x3360, 0x3380) - intermediate_value/rc_builtin/value1_0.\r\n    // [0x3380, 0x33a0) - intermediate_value/rc_builtin/value2_0.\r\n    // [0x33a0, 0x33c0) - intermediate_value/rc_builtin/value3_0.\r\n    // [0x33c0, 0x33e0) - intermediate_value/rc_builtin/value4_0.\r\n    // [0x33e0, 0x3400) - intermediate_value/rc_builtin/value5_0.\r\n    // [0x3400, 0x3420) - intermediate_value/rc_builtin/value6_0.\r\n    // [0x3420, 0x3440) - intermediate_value/rc_builtin/value7_0.\r\n    // [0x3440, 0x3460) - intermediate_value/ecdsa/signature0/doubling_key/x_squared.\r\n    // [0x3460, 0x3480) - intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0.\r\n    // [0x3480, 0x34a0) - intermediate_value/ecdsa/signature0/exponentiate_generator/bit_neg_0.\r\n    // [0x34a0, 0x34c0) - intermediate_value/ecdsa/signature0/exponentiate_key/bit_0.\r\n    // [0x34c0, 0x34e0) - intermediate_value/ecdsa/signature0/exponentiate_key/bit_neg_0.\r\n    // [0x34e0, 0x37a0) - expmods.\r\n    // [0x37a0, 0x3a80) - denominator_invs.\r\n    // [0x3a80, 0x3d60) - denominators.\r\n    // [0x3d60, 0x3ec0) - numerators.\r\n    // [0x3ec0, 0x41c0) - adjustments.\r\n    // [0x41c0, 0x4280) - expmod_context.\r\n\r\n    fallback() external {\r\n        uint256 res;\r\n        assembly {\r\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\r\n            // Copy input from calldata to memory.\r\n            calldatacopy(0x0, 0x0, /*Input data size*/ 0x30a0)\r\n            let point := /*oods_point*/ mload(0x3c0)\r\n            // Initialize composition_degree_bound to 2 * trace_length.\r\n            mstore(0x30a0, mul(2, /*trace_length*/ mload(0x80)))\r\n            function expmod(base, exponent, modulus) -> result {\r\n              let p := /*expmod_context*/ 0x41c0\r\n              mstore(p, 0x20)                 // Length of Base.\r\n              mstore(add(p, 0x20), 0x20)      // Length of Exponent.\r\n              mstore(add(p, 0x40), 0x20)      // Length of Modulus.\r\n              mstore(add(p, 0x60), base)      // Base.\r\n              mstore(add(p, 0x80), exponent)  // Exponent.\r\n              mstore(add(p, 0xa0), modulus)   // Modulus.\r\n              // Call modexp precompile.\r\n              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {\r\n                revert(0, 0)\r\n              }\r\n              result := mload(p)\r\n            }\r\n\r\n            function degreeAdjustment(compositionPolynomialDegreeBound, constraintDegree, numeratorDegree,\r\n                                       denominatorDegree) -> result {\r\n              result := sub(sub(compositionPolynomialDegreeBound, 1),\r\n                         sub(add(constraintDegree, numeratorDegree), denominatorDegree))\r\n            }\r\n\r\n            {\r\n              // Prepare expmods for denominators and numerators.\r\n\r\n              // expmods[0] = point^trace_length.\r\n              mstore(0x34e0, expmod(point, /*trace_length*/ mload(0x80), PRIME))\r\n\r\n              // expmods[1] = point^(trace_length / 16).\r\n              mstore(0x3500, expmod(point, div(/*trace_length*/ mload(0x80), 16), PRIME))\r\n\r\n              // expmods[2] = point^(trace_length / 2).\r\n              mstore(0x3520, expmod(point, div(/*trace_length*/ mload(0x80), 2), PRIME))\r\n\r\n              // expmods[3] = point^(trace_length / 8).\r\n              mstore(0x3540, expmod(point, div(/*trace_length*/ mload(0x80), 8), PRIME))\r\n\r\n              // expmods[4] = point^(trace_length / 4).\r\n              mstore(0x3560, expmod(point, div(/*trace_length*/ mload(0x80), 4), PRIME))\r\n\r\n              // expmods[5] = point^(trace_length / 256).\r\n              mstore(0x3580, expmod(point, div(/*trace_length*/ mload(0x80), 256), PRIME))\r\n\r\n              // expmods[6] = point^(trace_length / 512).\r\n              mstore(0x35a0, expmod(point, div(/*trace_length*/ mload(0x80), 512), PRIME))\r\n\r\n              // expmods[7] = point^(trace_length / 64).\r\n              mstore(0x35c0, expmod(point, div(/*trace_length*/ mload(0x80), 64), PRIME))\r\n\r\n              // expmods[8] = point^(trace_length / 16384).\r\n              mstore(0x35e0, expmod(point, div(/*trace_length*/ mload(0x80), 16384), PRIME))\r\n\r\n              // expmods[9] = point^(trace_length / 128).\r\n              mstore(0x3600, expmod(point, div(/*trace_length*/ mload(0x80), 128), PRIME))\r\n\r\n              // expmods[10] = point^(trace_length / 32768).\r\n              mstore(0x3620, expmod(point, div(/*trace_length*/ mload(0x80), 32768), PRIME))\r\n\r\n              // expmods[11] = trace_generator^(15 * trace_length / 16).\r\n              mstore(0x3640, expmod(/*trace_generator*/ mload(0x3a0), div(mul(15, /*trace_length*/ mload(0x80)), 16), PRIME))\r\n\r\n              // expmods[12] = trace_generator^(16 * (trace_length / 16 - 1)).\r\n              mstore(0x3660, expmod(/*trace_generator*/ mload(0x3a0), mul(16, sub(div(/*trace_length*/ mload(0x80), 16), 1)), PRIME))\r\n\r\n              // expmods[13] = trace_generator^(2 * (trace_length / 2 - 1)).\r\n              mstore(0x3680, expmod(/*trace_generator*/ mload(0x3a0), mul(2, sub(div(/*trace_length*/ mload(0x80), 2), 1)), PRIME))\r\n\r\n              // expmods[14] = trace_generator^(4 * (trace_length / 4 - 1)).\r\n              mstore(0x36a0, expmod(/*trace_generator*/ mload(0x3a0), mul(4, sub(div(/*trace_length*/ mload(0x80), 4), 1)), PRIME))\r\n\r\n              // expmods[15] = trace_generator^(255 * trace_length / 256).\r\n              mstore(0x36c0, expmod(/*trace_generator*/ mload(0x3a0), div(mul(255, /*trace_length*/ mload(0x80)), 256), PRIME))\r\n\r\n              // expmods[16] = trace_generator^(63 * trace_length / 64).\r\n              mstore(0x36e0, expmod(/*trace_generator*/ mload(0x3a0), div(mul(63, /*trace_length*/ mload(0x80)), 64), PRIME))\r\n\r\n              // expmods[17] = trace_generator^(trace_length / 2).\r\n              mstore(0x3700, expmod(/*trace_generator*/ mload(0x3a0), div(/*trace_length*/ mload(0x80), 2), PRIME))\r\n\r\n              // expmods[18] = trace_generator^(512 * (trace_length / 512 - 1)).\r\n              mstore(0x3720, expmod(/*trace_generator*/ mload(0x3a0), mul(512, sub(div(/*trace_length*/ mload(0x80), 512), 1)), PRIME))\r\n\r\n              // expmods[19] = trace_generator^(256 * (trace_length / 256 - 1)).\r\n              mstore(0x3740, expmod(/*trace_generator*/ mload(0x3a0), mul(256, sub(div(/*trace_length*/ mload(0x80), 256), 1)), PRIME))\r\n\r\n              // expmods[20] = trace_generator^(251 * trace_length / 256).\r\n              mstore(0x3760, expmod(/*trace_generator*/ mload(0x3a0), div(mul(251, /*trace_length*/ mload(0x80)), 256), PRIME))\r\n\r\n              // expmods[21] = trace_generator^(32768 * (trace_length / 32768 - 1)).\r\n              mstore(0x3780, expmod(/*trace_generator*/ mload(0x3a0), mul(32768, sub(div(/*trace_length*/ mload(0x80), 32768), 1)), PRIME))\r\n\r\n            }\r\n\r\n            {\r\n              // Prepare denominators for batch inverse.\r\n\r\n              // Denominator for constraints: 'cpu/decode/opcode_rc/bit', 'pedersen/hash0/ec_subset_sum/booleanity_test', 'pedersen/hash0/ec_subset_sum/add_points/slope', 'pedersen/hash0/ec_subset_sum/add_points/x', 'pedersen/hash0/ec_subset_sum/add_points/y', 'pedersen/hash0/ec_subset_sum/copy_point/x', 'pedersen/hash0/ec_subset_sum/copy_point/y'.\r\n              // denominators[0] = point^trace_length - 1.\r\n              mstore(0x3a80,\r\n                     addmod(/*point^trace_length*/ mload(0x34e0), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'cpu/decode/opcode_rc/zero'.\r\n              // denominators[1] = point^(trace_length / 16) - trace_generator^(15 * trace_length / 16).\r\n              mstore(0x3aa0,\r\n                     addmod(\r\n                       /*point^(trace_length / 16)*/ mload(0x3500),\r\n                       sub(PRIME, /*trace_generator^(15 * trace_length / 16)*/ mload(0x3640)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'cpu/decode/opcode_rc_input', 'cpu/operands/mem_dst_addr', 'cpu/operands/mem0_addr', 'cpu/operands/mem1_addr', 'cpu/operands/ops_mul', 'cpu/operands/res', 'cpu/update_registers/update_pc/tmp0', 'cpu/update_registers/update_pc/tmp1', 'cpu/update_registers/update_pc/pc_cond_negative', 'cpu/update_registers/update_pc/pc_cond_positive', 'cpu/update_registers/update_ap/ap_update', 'cpu/update_registers/update_fp/fp_update', 'cpu/opcodes/call/push_fp', 'cpu/opcodes/call/push_pc', 'cpu/opcodes/assert_eq/assert_eq'.\r\n              // denominators[2] = point^(trace_length / 16) - 1.\r\n              mstore(0x3ac0,\r\n                     addmod(/*point^(trace_length / 16)*/ mload(0x3500), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'initial_ap', 'initial_fp', 'initial_pc', 'memory/multi_column_perm/perm/init0', 'memory/initial_addr', 'rc16/perm/init0', 'rc16/minimum', 'pedersen/init_addr', 'rc_builtin/init_addr', 'ecdsa/init_addr', 'checkpoints/req_pc_init_addr'.\r\n              // denominators[3] = point - 1.\r\n              mstore(0x3ae0,\r\n                     addmod(point, sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'final_ap', 'final_pc'.\r\n              // denominators[4] = point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              mstore(0x3b00,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(16 * (trace_length / 16 - 1))*/ mload(0x3660)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'memory/multi_column_perm/perm/step0', 'memory/diff_is_bit', 'memory/is_func'.\r\n              // denominators[5] = point^(trace_length / 2) - 1.\r\n              mstore(0x3b20,\r\n                     addmod(/*point^(trace_length / 2)*/ mload(0x3520), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'memory/multi_column_perm/perm/last'.\r\n              // denominators[6] = point - trace_generator^(2 * (trace_length / 2 - 1)).\r\n              mstore(0x3b40,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(2 * (trace_length / 2 - 1))*/ mload(0x3680)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'public_memory_addr_zero', 'public_memory_value_zero'.\r\n              // denominators[7] = point^(trace_length / 8) - 1.\r\n              mstore(0x3b60,\r\n                     addmod(/*point^(trace_length / 8)*/ mload(0x3540), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'rc16/perm/step0', 'rc16/diff_is_bit'.\r\n              // denominators[8] = point^(trace_length / 4) - 1.\r\n              mstore(0x3b80,\r\n                     addmod(/*point^(trace_length / 4)*/ mload(0x3560), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'rc16/perm/last', 'rc16/maximum'.\r\n              // denominators[9] = point - trace_generator^(4 * (trace_length / 4 - 1)).\r\n              mstore(0x3ba0,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(4 * (trace_length / 4 - 1))*/ mload(0x36a0)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'pedersen/hash0/ec_subset_sum/bit_unpacking/last_one_is_zero', 'pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones0', 'pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit192', 'pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones192', 'pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit196', 'pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones196', 'pedersen/hash0/copy_point/x', 'pedersen/hash0/copy_point/y', 'rc_builtin/value', 'rc_builtin/addr_step', 'checkpoints/required_fp_addr', 'checkpoints/required_pc_next_addr', 'checkpoints/req_pc', 'checkpoints/req_fp'.\r\n              // denominators[10] = point^(trace_length / 256) - 1.\r\n              mstore(0x3bc0,\r\n                     addmod(/*point^(trace_length / 256)*/ mload(0x3580), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'pedersen/hash0/ec_subset_sum/bit_extraction_end'.\r\n              // denominators[11] = point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\r\n              mstore(0x3be0,\r\n                     addmod(\r\n                       /*point^(trace_length / 256)*/ mload(0x3580),\r\n                       sub(PRIME, /*trace_generator^(63 * trace_length / 64)*/ mload(0x36e0)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'pedersen/hash0/ec_subset_sum/zeros_tail'.\r\n              // denominators[12] = point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              mstore(0x3c00,\r\n                     addmod(\r\n                       /*point^(trace_length / 256)*/ mload(0x3580),\r\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x36c0)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'pedersen/hash0/init/x', 'pedersen/hash0/init/y', 'pedersen/input0_value0', 'pedersen/input0_addr', 'pedersen/input1_value0', 'pedersen/input1_addr', 'pedersen/output_value0', 'pedersen/output_addr'.\r\n              // denominators[13] = point^(trace_length / 512) - 1.\r\n              mstore(0x3c20,\r\n                     addmod(/*point^(trace_length / 512)*/ mload(0x35a0), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/doubling_key/slope', 'ecdsa/signature0/doubling_key/x', 'ecdsa/signature0/doubling_key/y', 'ecdsa/signature0/exponentiate_key/booleanity_test', 'ecdsa/signature0/exponentiate_key/add_points/slope', 'ecdsa/signature0/exponentiate_key/add_points/x', 'ecdsa/signature0/exponentiate_key/add_points/y', 'ecdsa/signature0/exponentiate_key/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_key/copy_point/x', 'ecdsa/signature0/exponentiate_key/copy_point/y'.\r\n              // denominators[14] = point^(trace_length / 64) - 1.\r\n              mstore(0x3c40,\r\n                     addmod(/*point^(trace_length / 64)*/ mload(0x35c0), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_generator/booleanity_test', 'ecdsa/signature0/exponentiate_generator/add_points/slope', 'ecdsa/signature0/exponentiate_generator/add_points/x', 'ecdsa/signature0/exponentiate_generator/add_points/y', 'ecdsa/signature0/exponentiate_generator/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_generator/copy_point/x', 'ecdsa/signature0/exponentiate_generator/copy_point/y'.\r\n              // denominators[15] = point^(trace_length / 128) - 1.\r\n              mstore(0x3c60,\r\n                     addmod(/*point^(trace_length / 128)*/ mload(0x3600), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_generator/bit_extraction_end'.\r\n              // denominators[16] = point^(trace_length / 32768) - trace_generator^(251 * trace_length / 256).\r\n              mstore(0x3c80,\r\n                     addmod(\r\n                       /*point^(trace_length / 32768)*/ mload(0x3620),\r\n                       sub(PRIME, /*trace_generator^(251 * trace_length / 256)*/ mload(0x3760)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_generator/zeros_tail'.\r\n              // denominators[17] = point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\r\n              mstore(0x3ca0,\r\n                     addmod(\r\n                       /*point^(trace_length / 32768)*/ mload(0x3620),\r\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x36c0)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_key/bit_extraction_end'.\r\n              // denominators[18] = point^(trace_length / 16384) - trace_generator^(251 * trace_length / 256).\r\n              mstore(0x3cc0,\r\n                     addmod(\r\n                       /*point^(trace_length / 16384)*/ mload(0x35e0),\r\n                       sub(PRIME, /*trace_generator^(251 * trace_length / 256)*/ mload(0x3760)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_key/zeros_tail'.\r\n              // denominators[19] = point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\r\n              mstore(0x3ce0,\r\n                     addmod(\r\n                       /*point^(trace_length / 16384)*/ mload(0x35e0),\r\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x36c0)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/init_gen/x', 'ecdsa/signature0/init_gen/y', 'ecdsa/signature0/add_results/slope', 'ecdsa/signature0/add_results/x', 'ecdsa/signature0/add_results/y', 'ecdsa/signature0/add_results/x_diff_inv', 'ecdsa/signature0/extract_r/slope', 'ecdsa/signature0/extract_r/x', 'ecdsa/signature0/extract_r/x_diff_inv', 'ecdsa/signature0/z_nonzero', 'ecdsa/signature0/q_on_curve/x_squared', 'ecdsa/signature0/q_on_curve/on_curve', 'ecdsa/message_addr', 'ecdsa/pubkey_addr', 'ecdsa/message_value0', 'ecdsa/pubkey_value0'.\r\n              // denominators[20] = point^(trace_length / 32768) - 1.\r\n              mstore(0x3d00,\r\n                     addmod(/*point^(trace_length / 32768)*/ mload(0x3620), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/init_key/x', 'ecdsa/signature0/init_key/y', 'ecdsa/signature0/r_and_w_nonzero'.\r\n              // denominators[21] = point^(trace_length / 16384) - 1.\r\n              mstore(0x3d20,\r\n                     addmod(/*point^(trace_length / 16384)*/ mload(0x35e0), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'checkpoints/req_pc_final_addr'.\r\n              // denominators[22] = point - trace_generator^(256 * (trace_length / 256 - 1)).\r\n              mstore(0x3d40,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(256 * (trace_length / 256 - 1))*/ mload(0x3740)),\r\n                       PRIME))\r\n\r\n            }\r\n\r\n            {\r\n              // Compute the inverses of the denominators into denominatorInvs using batch inverse.\r\n\r\n              // Start by computing the cumulative product.\r\n              // Let (d_0, d_1, d_2, ..., d_{n-1}) be the values in denominators. After this loop\r\n              // denominatorInvs will be (1, d_0, d_0 * d_1, ...) and prod will contain the value of\r\n              // d_0 * ... * d_{n-1}.\r\n              // Compute the offset between the partialProducts array and the input values array.\r\n              let productsToValuesOffset := 0x2e0\r\n              let prod := 1\r\n              let partialProductEndPtr := 0x3a80\r\n              for { let partialProductPtr := 0x37a0 }\r\n                  lt(partialProductPtr, partialProductEndPtr)\r\n                  { partialProductPtr := add(partialProductPtr, 0x20) } {\r\n                  mstore(partialProductPtr, prod)\r\n                  // prod *= d_{i}.\r\n                  prod := mulmod(prod,\r\n                                 mload(add(partialProductPtr, productsToValuesOffset)),\r\n                                 PRIME)\r\n              }\r\n\r\n              let firstPartialProductPtr := 0x37a0\r\n              // Compute the inverse of the product.\r\n              let prodInv := expmod(prod, sub(PRIME, 2), PRIME)\r\n\r\n              if eq(prodInv, 0) {\r\n                  // Solidity generates reverts with reason that look as follows:\r\n                  // 1. 4 bytes with the constant 0x08c379a0 (== Keccak256(b'Error(string)')[:4]).\r\n                  // 2. 32 bytes offset bytes (always 0x20 as far as i can tell).\r\n                  // 3. 32 bytes with the length of the revert reason.\r\n                  // 4. Revert reason string.\r\n\r\n                  mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                  mstore(0x4, 0x20)\r\n                  mstore(0x24, 0x1e)\r\n                  mstore(0x44, \"Batch inverse product is zero.\")\r\n                  revert(0, 0x62)\r\n              }\r\n\r\n              // Compute the inverses.\r\n              // Loop over denominator_invs in reverse order.\r\n              // currentPartialProductPtr is initialized to one past the end.\r\n              let currentPartialProductPtr := 0x3a80\r\n              for { } gt(currentPartialProductPtr, firstPartialProductPtr) { } {\r\n                  currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\r\n                  // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\r\n                  mstore(currentPartialProductPtr,\r\n                         mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\r\n                  // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\r\n                  prodInv := mulmod(prodInv,\r\n                                     mload(add(currentPartialProductPtr, productsToValuesOffset)),\r\n                                     PRIME)\r\n              }\r\n            }\r\n\r\n            {\r\n              // Compute numerators and adjustment polynomials.\r\n\r\n              // Numerator for constraints 'cpu/decode/opcode_rc/bit'.\r\n              // numerators[0] = point^(trace_length / 16) - trace_generator^(15 * trace_length / 16).\r\n              mstore(0x3d60,\r\n                     addmod(\r\n                       /*point^(trace_length / 16)*/ mload(0x3500),\r\n                       sub(PRIME, /*trace_generator^(15 * trace_length / 16)*/ mload(0x3640)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'cpu/update_registers/update_pc/tmp0', 'cpu/update_registers/update_pc/tmp1', 'cpu/update_registers/update_pc/pc_cond_negative', 'cpu/update_registers/update_pc/pc_cond_positive', 'cpu/update_registers/update_ap/ap_update', 'cpu/update_registers/update_fp/fp_update'.\r\n              // numerators[1] = point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              mstore(0x3d80,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(16 * (trace_length / 16 - 1))*/ mload(0x3660)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'memory/multi_column_perm/perm/step0', 'memory/diff_is_bit', 'memory/is_func'.\r\n              // numerators[2] = point - trace_generator^(2 * (trace_length / 2 - 1)).\r\n              mstore(0x3da0,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(2 * (trace_length / 2 - 1))*/ mload(0x3680)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'rc16/perm/step0', 'rc16/diff_is_bit'.\r\n              // numerators[3] = point - trace_generator^(4 * (trace_length / 4 - 1)).\r\n              mstore(0x3dc0,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(4 * (trace_length / 4 - 1))*/ mload(0x36a0)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'pedersen/hash0/ec_subset_sum/booleanity_test', 'pedersen/hash0/ec_subset_sum/add_points/slope', 'pedersen/hash0/ec_subset_sum/add_points/x', 'pedersen/hash0/ec_subset_sum/add_points/y', 'pedersen/hash0/ec_subset_sum/copy_point/x', 'pedersen/hash0/ec_subset_sum/copy_point/y'.\r\n              // numerators[4] = point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              mstore(0x3de0,\r\n                     addmod(\r\n                       /*point^(trace_length / 256)*/ mload(0x3580),\r\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x36c0)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'pedersen/hash0/copy_point/x', 'pedersen/hash0/copy_point/y'.\r\n              // numerators[5] = point^(trace_length / 512) - trace_generator^(trace_length / 2).\r\n              mstore(0x3e00,\r\n                     addmod(\r\n                       /*point^(trace_length / 512)*/ mload(0x35a0),\r\n                       sub(PRIME, /*trace_generator^(trace_length / 2)*/ mload(0x3700)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'pedersen/input0_addr'.\r\n              // numerators[6] = point - trace_generator^(512 * (trace_length / 512 - 1)).\r\n              mstore(0x3e20,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(512 * (trace_length / 512 - 1))*/ mload(0x3720)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'rc_builtin/addr_step', 'checkpoints/required_pc_next_addr', 'checkpoints/req_pc', 'checkpoints/req_fp'.\r\n              // numerators[7] = point - trace_generator^(256 * (trace_length / 256 - 1)).\r\n              mstore(0x3e40,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(256 * (trace_length / 256 - 1))*/ mload(0x3740)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'ecdsa/signature0/doubling_key/slope', 'ecdsa/signature0/doubling_key/x', 'ecdsa/signature0/doubling_key/y', 'ecdsa/signature0/exponentiate_key/booleanity_test', 'ecdsa/signature0/exponentiate_key/add_points/slope', 'ecdsa/signature0/exponentiate_key/add_points/x', 'ecdsa/signature0/exponentiate_key/add_points/y', 'ecdsa/signature0/exponentiate_key/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_key/copy_point/x', 'ecdsa/signature0/exponentiate_key/copy_point/y'.\r\n              // numerators[8] = point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\r\n              mstore(0x3e60,\r\n                     addmod(\r\n                       /*point^(trace_length / 16384)*/ mload(0x35e0),\r\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x36c0)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'ecdsa/signature0/exponentiate_generator/booleanity_test', 'ecdsa/signature0/exponentiate_generator/add_points/slope', 'ecdsa/signature0/exponentiate_generator/add_points/x', 'ecdsa/signature0/exponentiate_generator/add_points/y', 'ecdsa/signature0/exponentiate_generator/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_generator/copy_point/x', 'ecdsa/signature0/exponentiate_generator/copy_point/y'.\r\n              // numerators[9] = point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\r\n              mstore(0x3e80,\r\n                     addmod(\r\n                       /*point^(trace_length / 32768)*/ mload(0x3620),\r\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x36c0)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'ecdsa/pubkey_addr'.\r\n              // numerators[10] = point - trace_generator^(32768 * (trace_length / 32768 - 1)).\r\n              mstore(0x3ea0,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(32768 * (trace_length / 32768 - 1))*/ mload(0x3780)),\r\n                       PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'cpu/decode/opcode_rc/bit'.\r\n              // adjustments[0] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 16, trace_length).\r\n              mstore(0x3ec0,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), mul(2, sub(/*trace_length*/ mload(0x80), 1)), div(/*trace_length*/ mload(0x80), 16), /*trace_length*/ mload(0x80)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'cpu/decode/opcode_rc/zero', 'cpu/decode/opcode_rc_input'.\r\n              // adjustments[1] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 16).\r\n              mstore(0x3ee0,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), sub(/*trace_length*/ mload(0x80), 1), 0, div(/*trace_length*/ mload(0x80), 16)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'cpu/operands/mem_dst_addr', 'cpu/operands/mem0_addr', 'cpu/operands/mem1_addr', 'cpu/operands/ops_mul', 'cpu/operands/res', 'cpu/opcodes/call/push_fp', 'cpu/opcodes/call/push_pc', 'cpu/opcodes/assert_eq/assert_eq'.\r\n              // adjustments[2] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), 0, trace_length / 16).\r\n              mstore(0x3f00,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 0, div(/*trace_length*/ mload(0x80), 16)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'cpu/update_registers/update_pc/tmp0', 'cpu/update_registers/update_pc/tmp1', 'cpu/update_registers/update_pc/pc_cond_negative', 'cpu/update_registers/update_pc/pc_cond_positive', 'cpu/update_registers/update_ap/ap_update', 'cpu/update_registers/update_fp/fp_update'.\r\n              // adjustments[3] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), 1, trace_length / 16).\r\n              mstore(0x3f20,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 1, div(/*trace_length*/ mload(0x80), 16)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'initial_ap', 'initial_fp', 'initial_pc', 'final_ap', 'final_pc', 'memory/multi_column_perm/perm/last', 'memory/initial_addr', 'rc16/perm/last', 'rc16/minimum', 'rc16/maximum', 'pedersen/init_addr', 'rc_builtin/init_addr', 'ecdsa/init_addr', 'checkpoints/req_pc_init_addr', 'checkpoints/req_pc_final_addr'.\r\n              // adjustments[4] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, 1).\r\n              mstore(0x3f40,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), sub(/*trace_length*/ mload(0x80), 1), 0, 1), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'memory/multi_column_perm/perm/init0', 'rc16/perm/init0'.\r\n              // adjustments[5] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), 0, 1).\r\n              mstore(0x3f60,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 0, 1), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'memory/multi_column_perm/perm/step0', 'memory/diff_is_bit', 'memory/is_func'.\r\n              // adjustments[6] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), 1, trace_length / 2).\r\n              mstore(0x3f80,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 1, div(/*trace_length*/ mload(0x80), 2)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'public_memory_addr_zero', 'public_memory_value_zero'.\r\n              // adjustments[7] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 8).\r\n              mstore(0x3fa0,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), sub(/*trace_length*/ mload(0x80), 1), 0, div(/*trace_length*/ mload(0x80), 8)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'rc16/perm/step0', 'rc16/diff_is_bit'.\r\n              // adjustments[8] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), 1, trace_length / 4).\r\n              mstore(0x3fc0,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 1, div(/*trace_length*/ mload(0x80), 4)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'pedersen/hash0/ec_subset_sum/bit_unpacking/last_one_is_zero', 'pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones0', 'pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit192', 'pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones192', 'pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit196', 'pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones196'.\r\n              // adjustments[9] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), 0, trace_length / 256).\r\n              mstore(0x3fe0,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 0, div(/*trace_length*/ mload(0x80), 256)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'pedersen/hash0/ec_subset_sum/booleanity_test', 'pedersen/hash0/ec_subset_sum/add_points/slope', 'pedersen/hash0/ec_subset_sum/add_points/x', 'pedersen/hash0/ec_subset_sum/add_points/y', 'pedersen/hash0/ec_subset_sum/copy_point/x', 'pedersen/hash0/ec_subset_sum/copy_point/y'.\r\n              // adjustments[10] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 256, trace_length).\r\n              mstore(0x4000,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), mul(2, sub(/*trace_length*/ mload(0x80), 1)), div(/*trace_length*/ mload(0x80), 256), /*trace_length*/ mload(0x80)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'pedersen/hash0/ec_subset_sum/bit_extraction_end', 'pedersen/hash0/ec_subset_sum/zeros_tail', 'rc_builtin/value', 'checkpoints/required_fp_addr'.\r\n              // adjustments[11] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 256).\r\n              mstore(0x4020,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), sub(/*trace_length*/ mload(0x80), 1), 0, div(/*trace_length*/ mload(0x80), 256)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'pedersen/hash0/copy_point/x', 'pedersen/hash0/copy_point/y'.\r\n              // adjustments[12] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, trace_length / 512, trace_length / 256).\r\n              mstore(0x4040,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), sub(/*trace_length*/ mload(0x80), 1), div(/*trace_length*/ mload(0x80), 512), div(/*trace_length*/ mload(0x80), 256)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'pedersen/hash0/init/x', 'pedersen/hash0/init/y', 'pedersen/input0_value0', 'pedersen/input1_value0', 'pedersen/input1_addr', 'pedersen/output_value0', 'pedersen/output_addr'.\r\n              // adjustments[13] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 512).\r\n              mstore(0x4060,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), sub(/*trace_length*/ mload(0x80), 1), 0, div(/*trace_length*/ mload(0x80), 512)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'pedersen/input0_addr'.\r\n              // adjustments[14] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 1, trace_length / 512).\r\n              mstore(0x4080,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), sub(/*trace_length*/ mload(0x80), 1), 1, div(/*trace_length*/ mload(0x80), 512)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'rc_builtin/addr_step'.\r\n              // adjustments[15] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 1, trace_length / 256).\r\n              mstore(0x40a0,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), sub(/*trace_length*/ mload(0x80), 1), 1, div(/*trace_length*/ mload(0x80), 256)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'ecdsa/signature0/doubling_key/slope', 'ecdsa/signature0/doubling_key/x', 'ecdsa/signature0/doubling_key/y', 'ecdsa/signature0/exponentiate_key/booleanity_test', 'ecdsa/signature0/exponentiate_key/add_points/slope', 'ecdsa/signature0/exponentiate_key/add_points/x', 'ecdsa/signature0/exponentiate_key/add_points/y', 'ecdsa/signature0/exponentiate_key/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_key/copy_point/x', 'ecdsa/signature0/exponentiate_key/copy_point/y'.\r\n              // adjustments[16] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 16384, trace_length / 64).\r\n              mstore(0x40c0,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), mul(2, sub(/*trace_length*/ mload(0x80), 1)), div(/*trace_length*/ mload(0x80), 16384), div(/*trace_length*/ mload(0x80), 64)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'ecdsa/signature0/exponentiate_generator/booleanity_test', 'ecdsa/signature0/exponentiate_generator/add_points/slope', 'ecdsa/signature0/exponentiate_generator/add_points/x', 'ecdsa/signature0/exponentiate_generator/add_points/y', 'ecdsa/signature0/exponentiate_generator/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_generator/copy_point/x', 'ecdsa/signature0/exponentiate_generator/copy_point/y'.\r\n              // adjustments[17] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 32768, trace_length / 128).\r\n              mstore(0x40e0,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), mul(2, sub(/*trace_length*/ mload(0x80), 1)), div(/*trace_length*/ mload(0x80), 32768), div(/*trace_length*/ mload(0x80), 128)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'ecdsa/signature0/exponentiate_generator/bit_extraction_end', 'ecdsa/signature0/exponentiate_generator/zeros_tail', 'ecdsa/signature0/init_gen/x', 'ecdsa/signature0/init_gen/y', 'ecdsa/message_addr', 'ecdsa/message_value0', 'ecdsa/pubkey_value0'.\r\n              // adjustments[18] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 32768).\r\n              mstore(0x4100,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), sub(/*trace_length*/ mload(0x80), 1), 0, div(/*trace_length*/ mload(0x80), 32768)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'ecdsa/signature0/exponentiate_key/bit_extraction_end', 'ecdsa/signature0/exponentiate_key/zeros_tail', 'ecdsa/signature0/init_key/x', 'ecdsa/signature0/init_key/y'.\r\n              // adjustments[19] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 16384).\r\n              mstore(0x4120,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), sub(/*trace_length*/ mload(0x80), 1), 0, div(/*trace_length*/ mload(0x80), 16384)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'ecdsa/signature0/add_results/slope', 'ecdsa/signature0/add_results/x', 'ecdsa/signature0/add_results/y', 'ecdsa/signature0/add_results/x_diff_inv', 'ecdsa/signature0/extract_r/slope', 'ecdsa/signature0/extract_r/x', 'ecdsa/signature0/extract_r/x_diff_inv', 'ecdsa/signature0/z_nonzero', 'ecdsa/signature0/q_on_curve/x_squared', 'ecdsa/signature0/q_on_curve/on_curve'.\r\n              // adjustments[20] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), 0, trace_length / 32768).\r\n              mstore(0x4140,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 0, div(/*trace_length*/ mload(0x80), 32768)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'ecdsa/signature0/r_and_w_nonzero'.\r\n              // adjustments[21] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), 0, trace_length / 16384).\r\n              mstore(0x4160,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 0, div(/*trace_length*/ mload(0x80), 16384)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'ecdsa/pubkey_addr'.\r\n              // adjustments[22] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 1, trace_length / 32768).\r\n              mstore(0x4180,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), sub(/*trace_length*/ mload(0x80), 1), 1, div(/*trace_length*/ mload(0x80), 32768)), PRIME))\r\n\r\n              // Adjustment polynomial for constraints 'checkpoints/required_pc_next_addr', 'checkpoints/req_pc', 'checkpoints/req_fp'.\r\n              // adjustments[23] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), 1, trace_length / 256).\r\n              mstore(0x41a0,\r\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x30a0), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 1, div(/*trace_length*/ mload(0x80), 256)), PRIME))\r\n\r\n            }\r\n\r\n            {\r\n              // Compute the result of the composition polynomial.\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_0 = column0_row0 - (column0_row1 + column0_row1).\r\n              let val := addmod(\r\n                /*column0_row0*/ mload(0x2000),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row1*/ mload(0x2020), /*column0_row1*/ mload(0x2020), PRIME)),\r\n                PRIME)\r\n              mstore(0x30c0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_1 = column0_row1 - (column0_row2 + column0_row2).\r\n              let val := addmod(\r\n                /*column0_row1*/ mload(0x2020),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row2*/ mload(0x2040), /*column0_row2*/ mload(0x2040), PRIME)),\r\n                PRIME)\r\n              mstore(0x30e0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_2 = column0_row2 - (column0_row3 + column0_row3).\r\n              let val := addmod(\r\n                /*column0_row2*/ mload(0x2040),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row3*/ mload(0x2060), /*column0_row3*/ mload(0x2060), PRIME)),\r\n                PRIME)\r\n              mstore(0x3100, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_4 = column0_row4 - (column0_row5 + column0_row5).\r\n              let val := addmod(\r\n                /*column0_row4*/ mload(0x2080),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row5*/ mload(0x20a0), /*column0_row5*/ mload(0x20a0), PRIME)),\r\n                PRIME)\r\n              mstore(0x3120, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_3 = column0_row3 - (column0_row4 + column0_row4).\r\n              let val := addmod(\r\n                /*column0_row3*/ mload(0x2060),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row4*/ mload(0x2080), /*column0_row4*/ mload(0x2080), PRIME)),\r\n                PRIME)\r\n              mstore(0x3140, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_9 = column0_row9 - (column0_row10 + column0_row10).\r\n              let val := addmod(\r\n                /*column0_row9*/ mload(0x2120),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row10*/ mload(0x2140), /*column0_row10*/ mload(0x2140), PRIME)),\r\n                PRIME)\r\n              mstore(0x3160, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_5 = column0_row5 - (column0_row6 + column0_row6).\r\n              let val := addmod(\r\n                /*column0_row5*/ mload(0x20a0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row6*/ mload(0x20c0), /*column0_row6*/ mload(0x20c0), PRIME)),\r\n                PRIME)\r\n              mstore(0x3180, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_6 = column0_row6 - (column0_row7 + column0_row7).\r\n              let val := addmod(\r\n                /*column0_row6*/ mload(0x20c0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row7*/ mload(0x20e0), /*column0_row7*/ mload(0x20e0), PRIME)),\r\n                PRIME)\r\n              mstore(0x31a0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_7 = column0_row7 - (column0_row8 + column0_row8).\r\n              let val := addmod(\r\n                /*column0_row7*/ mload(0x20e0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row8*/ mload(0x2100), /*column0_row8*/ mload(0x2100), PRIME)),\r\n                PRIME)\r\n              mstore(0x31c0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_8 = column0_row8 - (column0_row9 + column0_row9).\r\n              let val := addmod(\r\n                /*column0_row8*/ mload(0x2100),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row9*/ mload(0x2120), /*column0_row9*/ mload(0x2120), PRIME)),\r\n                PRIME)\r\n              mstore(0x31e0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // npc_reg_0 = column5_row0 + cpu__decode__opcode_rc__bit_2 + 1.\r\n              let val := addmod(\r\n                addmod(\r\n                  /*column5_row0*/ mload(0x2480),\r\n                  /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x3100),\r\n                  PRIME),\r\n                1,\r\n                PRIME)\r\n              mstore(0x3200, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_10 = column0_row10 - (column0_row11 + column0_row11).\r\n              let val := addmod(\r\n                /*column0_row10*/ mload(0x2140),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row11*/ mload(0x2160), /*column0_row11*/ mload(0x2160), PRIME)),\r\n                PRIME)\r\n              mstore(0x3220, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_11 = column0_row11 - (column0_row12 + column0_row12).\r\n              let val := addmod(\r\n                /*column0_row11*/ mload(0x2160),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row12*/ mload(0x2180), /*column0_row12*/ mload(0x2180), PRIME)),\r\n                PRIME)\r\n              mstore(0x3240, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_12 = column0_row12 - (column0_row13 + column0_row13).\r\n              let val := addmod(\r\n                /*column0_row12*/ mload(0x2180),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row13*/ mload(0x21a0), /*column0_row13*/ mload(0x21a0), PRIME)),\r\n                PRIME)\r\n              mstore(0x3260, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_13 = column0_row13 - (column0_row14 + column0_row14).\r\n              let val := addmod(\r\n                /*column0_row13*/ mload(0x21a0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row14*/ mload(0x21c0), /*column0_row14*/ mload(0x21c0), PRIME)),\r\n                PRIME)\r\n              mstore(0x3280, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_14 = column0_row14 - (column0_row15 + column0_row15).\r\n              let val := addmod(\r\n                /*column0_row14*/ mload(0x21c0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row15*/ mload(0x21e0), /*column0_row15*/ mload(0x21e0), PRIME)),\r\n                PRIME)\r\n              mstore(0x32a0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // memory/address_diff_0 = column6_row2 - column6_row0.\r\n              let val := addmod(/*column6_row2*/ mload(0x28a0), sub(PRIME, /*column6_row0*/ mload(0x2860)), PRIME)\r\n              mstore(0x32c0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc16/diff_0 = column7_row6 - column7_row2.\r\n              let val := addmod(/*column7_row6*/ mload(0x29a0), sub(PRIME, /*column7_row2*/ mload(0x2920)), PRIME)\r\n              mstore(0x32e0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // pedersen/hash0/ec_subset_sum/bit_0 = column4_row0 - (column4_row1 + column4_row1).\r\n              let val := addmod(\r\n                /*column4_row0*/ mload(0x2360),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column4_row1*/ mload(0x2380), /*column4_row1*/ mload(0x2380), PRIME)),\r\n                PRIME)\r\n              mstore(0x3300, val)\r\n              }\r\n\r\n\r\n              {\r\n              // pedersen/hash0/ec_subset_sum/bit_neg_0 = 1 - pedersen__hash0__ec_subset_sum__bit_0.\r\n              let val := addmod(\r\n                1,\r\n                sub(PRIME, /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3300)),\r\n                PRIME)\r\n              mstore(0x3320, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value0_0 = column7_row12.\r\n              let val := /*column7_row12*/ mload(0x2a40)\r\n              mstore(0x3340, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value1_0 = rc_builtin__value0_0 * offset_size + column7_row44.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value0_0*/ mload(0x3340),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column7_row44*/ mload(0x2b40),\r\n                PRIME)\r\n              mstore(0x3360, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value2_0 = rc_builtin__value1_0 * offset_size + column7_row76.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value1_0*/ mload(0x3360),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column7_row76*/ mload(0x2be0),\r\n                PRIME)\r\n              mstore(0x3380, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value3_0 = rc_builtin__value2_0 * offset_size + column7_row108.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value2_0*/ mload(0x3380),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column7_row108*/ mload(0x2c60),\r\n                PRIME)\r\n              mstore(0x33a0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value4_0 = rc_builtin__value3_0 * offset_size + column7_row140.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value3_0*/ mload(0x33a0),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column7_row140*/ mload(0x2ca0),\r\n                PRIME)\r\n              mstore(0x33c0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value5_0 = rc_builtin__value4_0 * offset_size + column7_row172.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value4_0*/ mload(0x33c0),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column7_row172*/ mload(0x2cc0),\r\n                PRIME)\r\n              mstore(0x33e0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value6_0 = rc_builtin__value5_0 * offset_size + column7_row204.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value5_0*/ mload(0x33e0),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column7_row204*/ mload(0x2ce0),\r\n                PRIME)\r\n              mstore(0x3400, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value7_0 = rc_builtin__value6_0 * offset_size + column7_row236.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value6_0*/ mload(0x3400),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column7_row236*/ mload(0x2d00),\r\n                PRIME)\r\n              mstore(0x3420, val)\r\n              }\r\n\r\n\r\n              {\r\n              // ecdsa/signature0/doubling_key/x_squared = column7_row7 * column7_row7.\r\n              let val := mulmod(/*column7_row7*/ mload(0x29c0), /*column7_row7*/ mload(0x29c0), PRIME)\r\n              mstore(0x3440, val)\r\n              }\r\n\r\n\r\n              {\r\n              // ecdsa/signature0/exponentiate_generator/bit_0 = column8_row96 - (column8_row224 + column8_row224).\r\n              let val := addmod(\r\n                /*column8_row96*/ mload(0x2f20),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column8_row224*/ mload(0x2f80), /*column8_row224*/ mload(0x2f80), PRIME)),\r\n                PRIME)\r\n              mstore(0x3460, val)\r\n              }\r\n\r\n\r\n              {\r\n              // ecdsa/signature0/exponentiate_generator/bit_neg_0 = 1 - ecdsa__signature0__exponentiate_generator__bit_0.\r\n              let val := addmod(\r\n                1,\r\n                sub(\r\n                  PRIME,\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x3460)),\r\n                PRIME)\r\n              mstore(0x3480, val)\r\n              }\r\n\r\n\r\n              {\r\n              // ecdsa/signature0/exponentiate_key/bit_0 = column7_row31 - (column7_row95 + column7_row95).\r\n              let val := addmod(\r\n                /*column7_row31*/ mload(0x2b00),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column7_row95*/ mload(0x2c20), /*column7_row95*/ mload(0x2c20), PRIME)),\r\n                PRIME)\r\n              mstore(0x34a0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // ecdsa/signature0/exponentiate_key/bit_neg_0 = 1 - ecdsa__signature0__exponentiate_key__bit_0.\r\n              let val := addmod(\r\n                1,\r\n                sub(\r\n                  PRIME,\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x34a0)),\r\n                PRIME)\r\n              mstore(0x34c0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // Constraint expression for cpu/decode/opcode_rc/bit: cpu__decode__opcode_rc__bit_0 * cpu__decode__opcode_rc__bit_0 - cpu__decode__opcode_rc__bit_0.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x30c0),\r\n                  /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x30c0),\r\n                  PRIME),\r\n                sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x30c0)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 16) - trace_generator^(15 * trace_length / 16).\r\n              // val *= numerators[0].\r\n              val := mulmod(val, mload(0x3d60), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x37a0), PRIME)\r\n\r\n              // res += val * (coefficients[0] + coefficients[1] * adjustments[0]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[0]*/ mload(0x440),\r\n                                       mulmod(/*coefficients[1]*/ mload(0x460),\r\n                                              /*adjustments[0]*/mload(0x3ec0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/decode/opcode_rc/zero: column0_row0.\r\n              let val := /*column0_row0*/ mload(0x2000)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - trace_generator^(15 * trace_length / 16).\r\n              // val *= denominator_invs[1].\r\n              val := mulmod(val, mload(0x37c0), PRIME)\r\n\r\n              // res += val * (coefficients[2] + coefficients[3] * adjustments[1]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[2]*/ mload(0x480),\r\n                                       mulmod(/*coefficients[3]*/ mload(0x4a0),\r\n                                              /*adjustments[1]*/mload(0x3ee0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/decode/opcode_rc_input: column5_row1 - (((column0_row0 * offset_size + column7_row4) * offset_size + column7_row8) * offset_size + column7_row0).\r\n              let val := addmod(\r\n                /*column5_row1*/ mload(0x24a0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    mulmod(\r\n                      addmod(\r\n                        mulmod(\r\n                          addmod(\r\n                            mulmod(/*column0_row0*/ mload(0x2000), /*offset_size*/ mload(0xa0), PRIME),\r\n                            /*column7_row4*/ mload(0x2960),\r\n                            PRIME),\r\n                          /*offset_size*/ mload(0xa0),\r\n                          PRIME),\r\n                        /*column7_row8*/ mload(0x29e0),\r\n                        PRIME),\r\n                      /*offset_size*/ mload(0xa0),\r\n                      PRIME),\r\n                    /*column7_row0*/ mload(0x28e0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[4] + coefficients[5] * adjustments[1]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[4]*/ mload(0x4c0),\r\n                                       mulmod(/*coefficients[5]*/ mload(0x4e0),\r\n                                              /*adjustments[1]*/mload(0x3ee0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/operands/mem_dst_addr: column5_row8 + half_offset_size - (cpu__decode__opcode_rc__bit_0 * column7_row9 + (1 - cpu__decode__opcode_rc__bit_0) * column7_row1 + column7_row0).\r\n              let val := addmod(\r\n                addmod(/*column5_row8*/ mload(0x2580), /*half_offset_size*/ mload(0xc0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x30c0),\r\n                        /*column7_row9*/ mload(0x2a00),\r\n                        PRIME),\r\n                      mulmod(\r\n                        addmod(\r\n                          1,\r\n                          sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x30c0)),\r\n                          PRIME),\r\n                        /*column7_row1*/ mload(0x2900),\r\n                        PRIME),\r\n                      PRIME),\r\n                    /*column7_row0*/ mload(0x28e0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[6] + coefficients[7] * adjustments[2]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[6]*/ mload(0x500),\r\n                                       mulmod(/*coefficients[7]*/ mload(0x520),\r\n                                              /*adjustments[2]*/mload(0x3f00),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/operands/mem0_addr: column5_row4 + half_offset_size - (cpu__decode__opcode_rc__bit_1 * column7_row9 + (1 - cpu__decode__opcode_rc__bit_1) * column7_row1 + column7_row8).\r\n              let val := addmod(\r\n                addmod(/*column5_row4*/ mload(0x2500), /*half_offset_size*/ mload(0xc0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_1*/ mload(0x30e0),\r\n                        /*column7_row9*/ mload(0x2a00),\r\n                        PRIME),\r\n                      mulmod(\r\n                        addmod(\r\n                          1,\r\n                          sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_1*/ mload(0x30e0)),\r\n                          PRIME),\r\n                        /*column7_row1*/ mload(0x2900),\r\n                        PRIME),\r\n                      PRIME),\r\n                    /*column7_row8*/ mload(0x29e0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[8] + coefficients[9] * adjustments[2]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[8]*/ mload(0x540),\r\n                                       mulmod(/*coefficients[9]*/ mload(0x560),\r\n                                              /*adjustments[2]*/mload(0x3f00),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/operands/mem1_addr: column5_row12 + half_offset_size - (cpu__decode__opcode_rc__bit_2 * column5_row0 + cpu__decode__opcode_rc__bit_4 * column7_row1 + cpu__decode__opcode_rc__bit_3 * column7_row9 + (1 - (cpu__decode__opcode_rc__bit_2 + cpu__decode__opcode_rc__bit_4 + cpu__decode__opcode_rc__bit_3)) * column5_row5 + column7_row4).\r\n              let val := addmod(\r\n                addmod(/*column5_row12*/ mload(0x25c0), /*half_offset_size*/ mload(0xc0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      addmod(\r\n                        addmod(\r\n                          mulmod(\r\n                            /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x3100),\r\n                            /*column5_row0*/ mload(0x2480),\r\n                            PRIME),\r\n                          mulmod(\r\n                            /*intermediate_value/cpu/decode/opcode_rc/bit_4*/ mload(0x3120),\r\n                            /*column7_row1*/ mload(0x2900),\r\n                            PRIME),\r\n                          PRIME),\r\n                        mulmod(\r\n                          /*intermediate_value/cpu/decode/opcode_rc/bit_3*/ mload(0x3140),\r\n                          /*column7_row9*/ mload(0x2a00),\r\n                          PRIME),\r\n                        PRIME),\r\n                      mulmod(\r\n                        addmod(\r\n                          1,\r\n                          sub(\r\n                            PRIME,\r\n                            addmod(\r\n                              addmod(\r\n                                /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x3100),\r\n                                /*intermediate_value/cpu/decode/opcode_rc/bit_4*/ mload(0x3120),\r\n                                PRIME),\r\n                              /*intermediate_value/cpu/decode/opcode_rc/bit_3*/ mload(0x3140),\r\n                              PRIME)),\r\n                          PRIME),\r\n                        /*column5_row5*/ mload(0x2520),\r\n                        PRIME),\r\n                      PRIME),\r\n                    /*column7_row4*/ mload(0x2960),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[10] + coefficients[11] * adjustments[2]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[10]*/ mload(0x580),\r\n                                       mulmod(/*coefficients[11]*/ mload(0x5a0),\r\n                                              /*adjustments[2]*/mload(0x3f00),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/operands/ops_mul: column7_row5 - column5_row5 * column5_row13.\r\n              let val := addmod(\r\n                /*column7_row5*/ mload(0x2980),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(/*column5_row5*/ mload(0x2520), /*column5_row13*/ mload(0x25e0), PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[12] + coefficients[13] * adjustments[2]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[12]*/ mload(0x5c0),\r\n                                       mulmod(/*coefficients[13]*/ mload(0x5e0),\r\n                                              /*adjustments[2]*/mload(0x3f00),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/operands/res: (1 - cpu__decode__opcode_rc__bit_9) * column7_row13 - (cpu__decode__opcode_rc__bit_5 * (column5_row5 + column5_row13) + cpu__decode__opcode_rc__bit_6 * column7_row5 + (1 - (cpu__decode__opcode_rc__bit_5 + cpu__decode__opcode_rc__bit_6 + cpu__decode__opcode_rc__bit_9)) * column5_row13).\r\n              let val := addmod(\r\n                mulmod(\r\n                  addmod(\r\n                    1,\r\n                    sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3160)),\r\n                    PRIME),\r\n                  /*column7_row13*/ mload(0x2a60),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_5*/ mload(0x3180),\r\n                        addmod(/*column5_row5*/ mload(0x2520), /*column5_row13*/ mload(0x25e0), PRIME),\r\n                        PRIME),\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_6*/ mload(0x31a0),\r\n                        /*column7_row5*/ mload(0x2980),\r\n                        PRIME),\r\n                      PRIME),\r\n                    mulmod(\r\n                      addmod(\r\n                        1,\r\n                        sub(\r\n                          PRIME,\r\n                          addmod(\r\n                            addmod(\r\n                              /*intermediate_value/cpu/decode/opcode_rc/bit_5*/ mload(0x3180),\r\n                              /*intermediate_value/cpu/decode/opcode_rc/bit_6*/ mload(0x31a0),\r\n                              PRIME),\r\n                            /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3160),\r\n                            PRIME)),\r\n                        PRIME),\r\n                      /*column5_row13*/ mload(0x25e0),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[14] + coefficients[15] * adjustments[2]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[14]*/ mload(0x600),\r\n                                       mulmod(/*coefficients[15]*/ mload(0x620),\r\n                                              /*adjustments[2]*/mload(0x3f00),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/update_registers/update_pc/tmp0: column7_row3 - cpu__decode__opcode_rc__bit_9 * column5_row9.\r\n              let val := addmod(\r\n                /*column7_row3*/ mload(0x2940),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3160),\r\n                    /*column5_row9*/ mload(0x25a0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= numerators[1].\r\n              val := mulmod(val, mload(0x3d80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[16] + coefficients[17] * adjustments[3]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[16]*/ mload(0x640),\r\n                                       mulmod(/*coefficients[17]*/ mload(0x660),\r\n                                              /*adjustments[3]*/mload(0x3f20),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/update_registers/update_pc/tmp1: column7_row11 - column7_row3 * column7_row13.\r\n              let val := addmod(\r\n                /*column7_row11*/ mload(0x2a20),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(/*column7_row3*/ mload(0x2940), /*column7_row13*/ mload(0x2a60), PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= numerators[1].\r\n              val := mulmod(val, mload(0x3d80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[18] + coefficients[19] * adjustments[3]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[18]*/ mload(0x680),\r\n                                       mulmod(/*coefficients[19]*/ mload(0x6a0),\r\n                                              /*adjustments[3]*/mload(0x3f20),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/update_registers/update_pc/pc_cond_negative: (1 - cpu__decode__opcode_rc__bit_9) * column5_row16 + column7_row3 * (column5_row16 - (column5_row0 + column5_row13)) - ((1 - (cpu__decode__opcode_rc__bit_7 + cpu__decode__opcode_rc__bit_8 + cpu__decode__opcode_rc__bit_9)) * npc_reg_0 + cpu__decode__opcode_rc__bit_7 * column7_row13 + cpu__decode__opcode_rc__bit_8 * (column5_row0 + column7_row13)).\r\n              let val := addmod(\r\n                addmod(\r\n                  mulmod(\r\n                    addmod(\r\n                      1,\r\n                      sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3160)),\r\n                      PRIME),\r\n                    /*column5_row16*/ mload(0x2600),\r\n                    PRIME),\r\n                  mulmod(\r\n                    /*column7_row3*/ mload(0x2940),\r\n                    addmod(\r\n                      /*column5_row16*/ mload(0x2600),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column5_row0*/ mload(0x2480), /*column5_row13*/ mload(0x25e0), PRIME)),\r\n                      PRIME),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      mulmod(\r\n                        addmod(\r\n                          1,\r\n                          sub(\r\n                            PRIME,\r\n                            addmod(\r\n                              addmod(\r\n                                /*intermediate_value/cpu/decode/opcode_rc/bit_7*/ mload(0x31c0),\r\n                                /*intermediate_value/cpu/decode/opcode_rc/bit_8*/ mload(0x31e0),\r\n                                PRIME),\r\n                              /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3160),\r\n                              PRIME)),\r\n                          PRIME),\r\n                        /*intermediate_value/npc_reg_0*/ mload(0x3200),\r\n                        PRIME),\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_7*/ mload(0x31c0),\r\n                        /*column7_row13*/ mload(0x2a60),\r\n                        PRIME),\r\n                      PRIME),\r\n                    mulmod(\r\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_8*/ mload(0x31e0),\r\n                      addmod(/*column5_row0*/ mload(0x2480), /*column7_row13*/ mload(0x2a60), PRIME),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= numerators[1].\r\n              val := mulmod(val, mload(0x3d80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[20] + coefficients[21] * adjustments[3]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[20]*/ mload(0x6c0),\r\n                                       mulmod(/*coefficients[21]*/ mload(0x6e0),\r\n                                              /*adjustments[3]*/mload(0x3f20),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/update_registers/update_pc/pc_cond_positive: (column7_row11 - cpu__decode__opcode_rc__bit_9) * (column5_row16 - npc_reg_0).\r\n              let val := mulmod(\r\n                addmod(\r\n                  /*column7_row11*/ mload(0x2a20),\r\n                  sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3160)),\r\n                  PRIME),\r\n                addmod(\r\n                  /*column5_row16*/ mload(0x2600),\r\n                  sub(PRIME, /*intermediate_value/npc_reg_0*/ mload(0x3200)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= numerators[1].\r\n              val := mulmod(val, mload(0x3d80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[22] + coefficients[23] * adjustments[3]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[22]*/ mload(0x700),\r\n                                       mulmod(/*coefficients[23]*/ mload(0x720),\r\n                                              /*adjustments[3]*/mload(0x3f20),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/update_registers/update_ap/ap_update: column7_row17 - (column7_row1 + cpu__decode__opcode_rc__bit_10 * column7_row13 + cpu__decode__opcode_rc__bit_11 + cpu__decode__opcode_rc__bit_12 * 2).\r\n              let val := addmod(\r\n                /*column7_row17*/ mload(0x2aa0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      addmod(\r\n                        /*column7_row1*/ mload(0x2900),\r\n                        mulmod(\r\n                          /*intermediate_value/cpu/decode/opcode_rc/bit_10*/ mload(0x3220),\r\n                          /*column7_row13*/ mload(0x2a60),\r\n                          PRIME),\r\n                        PRIME),\r\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_11*/ mload(0x3240),\r\n                      PRIME),\r\n                    mulmod(/*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3260), 2, PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= numerators[1].\r\n              val := mulmod(val, mload(0x3d80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[24] + coefficients[25] * adjustments[3]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[24]*/ mload(0x740),\r\n                                       mulmod(/*coefficients[25]*/ mload(0x760),\r\n                                              /*adjustments[3]*/mload(0x3f20),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/update_registers/update_fp/fp_update: column7_row25 - ((1 - (cpu__decode__opcode_rc__bit_12 + cpu__decode__opcode_rc__bit_13)) * column7_row9 + cpu__decode__opcode_rc__bit_13 * column5_row9 + cpu__decode__opcode_rc__bit_12 * (column7_row1 + 2)).\r\n              let val := addmod(\r\n                /*column7_row25*/ mload(0x2ae0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      mulmod(\r\n                        addmod(\r\n                          1,\r\n                          sub(\r\n                            PRIME,\r\n                            addmod(\r\n                              /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3260),\r\n                              /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x3280),\r\n                              PRIME)),\r\n                          PRIME),\r\n                        /*column7_row9*/ mload(0x2a00),\r\n                        PRIME),\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x3280),\r\n                        /*column5_row9*/ mload(0x25a0),\r\n                        PRIME),\r\n                      PRIME),\r\n                    mulmod(\r\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3260),\r\n                      addmod(/*column7_row1*/ mload(0x2900), 2, PRIME),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= numerators[1].\r\n              val := mulmod(val, mload(0x3d80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[26] + coefficients[27] * adjustments[3]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[26]*/ mload(0x780),\r\n                                       mulmod(/*coefficients[27]*/ mload(0x7a0),\r\n                                              /*adjustments[3]*/mload(0x3f20),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/opcodes/call/push_fp: cpu__decode__opcode_rc__bit_12 * (column5_row9 - column7_row9).\r\n              let val := mulmod(\r\n                /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3260),\r\n                addmod(/*column5_row9*/ mload(0x25a0), sub(PRIME, /*column7_row9*/ mload(0x2a00)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[28] + coefficients[29] * adjustments[2]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[28]*/ mload(0x7c0),\r\n                                       mulmod(/*coefficients[29]*/ mload(0x7e0),\r\n                                              /*adjustments[2]*/mload(0x3f00),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/opcodes/call/push_pc: cpu__decode__opcode_rc__bit_12 * (column5_row5 - (column5_row0 + cpu__decode__opcode_rc__bit_2 + 1)).\r\n              let val := mulmod(\r\n                /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3260),\r\n                addmod(\r\n                  /*column5_row5*/ mload(0x2520),\r\n                  sub(\r\n                    PRIME,\r\n                    addmod(\r\n                      addmod(\r\n                        /*column5_row0*/ mload(0x2480),\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x3100),\r\n                        PRIME),\r\n                      1,\r\n                      PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[30] + coefficients[31] * adjustments[2]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[30]*/ mload(0x800),\r\n                                       mulmod(/*coefficients[31]*/ mload(0x820),\r\n                                              /*adjustments[2]*/mload(0x3f00),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/opcodes/assert_eq/assert_eq: cpu__decode__opcode_rc__bit_14 * (column5_row9 - column7_row13).\r\n              let val := mulmod(\r\n                /*intermediate_value/cpu/decode/opcode_rc/bit_14*/ mload(0x32a0),\r\n                addmod(/*column5_row9*/ mload(0x25a0), sub(PRIME, /*column7_row13*/ mload(0x2a60)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x37e0), PRIME)\r\n\r\n              // res += val * (coefficients[32] + coefficients[33] * adjustments[2]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[32]*/ mload(0x840),\r\n                                       mulmod(/*coefficients[33]*/ mload(0x860),\r\n                                              /*adjustments[2]*/mload(0x3f00),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for initial_ap: column7_row1 - initial_ap.\r\n              let val := addmod(/*column7_row1*/ mload(0x2900), sub(PRIME, /*initial_ap*/ mload(0xe0)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x3800), PRIME)\r\n\r\n              // res += val * (coefficients[34] + coefficients[35] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[34]*/ mload(0x880),\r\n                                       mulmod(/*coefficients[35]*/ mload(0x8a0),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for initial_fp: column7_row9 - initial_ap.\r\n              let val := addmod(/*column7_row9*/ mload(0x2a00), sub(PRIME, /*initial_ap*/ mload(0xe0)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x3800), PRIME)\r\n\r\n              // res += val * (coefficients[36] + coefficients[37] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[36]*/ mload(0x8c0),\r\n                                       mulmod(/*coefficients[37]*/ mload(0x8e0),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for initial_pc: column5_row0 - initial_pc.\r\n              let val := addmod(/*column5_row0*/ mload(0x2480), sub(PRIME, /*initial_pc*/ mload(0x100)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x3800), PRIME)\r\n\r\n              // res += val * (coefficients[38] + coefficients[39] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[38]*/ mload(0x900),\r\n                                       mulmod(/*coefficients[39]*/ mload(0x920),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for final_ap: column7_row1 - final_ap.\r\n              let val := addmod(/*column7_row1*/ mload(0x2900), sub(PRIME, /*final_ap*/ mload(0x120)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= denominator_invs[4].\r\n              val := mulmod(val, mload(0x3820), PRIME)\r\n\r\n              // res += val * (coefficients[40] + coefficients[41] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[40]*/ mload(0x940),\r\n                                       mulmod(/*coefficients[41]*/ mload(0x960),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for final_pc: column5_row0 - final_pc.\r\n              let val := addmod(/*column5_row0*/ mload(0x2480), sub(PRIME, /*final_pc*/ mload(0x140)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= denominator_invs[4].\r\n              val := mulmod(val, mload(0x3820), PRIME)\r\n\r\n              // res += val * (coefficients[42] + coefficients[43] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[42]*/ mload(0x980),\r\n                                       mulmod(/*coefficients[43]*/ mload(0x9a0),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for memory/multi_column_perm/perm/init0: (memory/multi_column_perm/perm/interaction_elm - (column6_row0 + memory/multi_column_perm/hash_interaction_elm0 * column6_row1)) * column9_inter1_row0 + column5_row0 + memory/multi_column_perm/hash_interaction_elm0 * column5_row1 - memory/multi_column_perm/perm/interaction_elm.\r\n              let val := addmod(\r\n                addmod(\r\n                  addmod(\r\n                    mulmod(\r\n                      addmod(\r\n                        /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160),\r\n                        sub(\r\n                          PRIME,\r\n                          addmod(\r\n                            /*column6_row0*/ mload(0x2860),\r\n                            mulmod(\r\n                              /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180),\r\n                              /*column6_row1*/ mload(0x2880),\r\n                              PRIME),\r\n                            PRIME)),\r\n                        PRIME),\r\n                      /*column9_inter1_row0*/ mload(0x3020),\r\n                      PRIME),\r\n                    /*column5_row0*/ mload(0x2480),\r\n                    PRIME),\r\n                  mulmod(\r\n                    /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180),\r\n                    /*column5_row1*/ mload(0x24a0),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(PRIME, /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x3800), PRIME)\r\n\r\n              // res += val * (coefficients[44] + coefficients[45] * adjustments[5]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[44]*/ mload(0x9c0),\r\n                                       mulmod(/*coefficients[45]*/ mload(0x9e0),\r\n                                              /*adjustments[5]*/mload(0x3f60),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for memory/multi_column_perm/perm/step0: (memory/multi_column_perm/perm/interaction_elm - (column6_row2 + memory/multi_column_perm/hash_interaction_elm0 * column6_row3)) * column9_inter1_row2 - (memory/multi_column_perm/perm/interaction_elm - (column5_row2 + memory/multi_column_perm/hash_interaction_elm0 * column5_row3)) * column9_inter1_row0.\r\n              let val := addmod(\r\n                mulmod(\r\n                  addmod(\r\n                    /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160),\r\n                    sub(\r\n                      PRIME,\r\n                      addmod(\r\n                        /*column6_row2*/ mload(0x28a0),\r\n                        mulmod(\r\n                          /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180),\r\n                          /*column6_row3*/ mload(0x28c0),\r\n                          PRIME),\r\n                        PRIME)),\r\n                    PRIME),\r\n                  /*column9_inter1_row2*/ mload(0x3060),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    addmod(\r\n                      /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(\r\n                          /*column5_row2*/ mload(0x24c0),\r\n                          mulmod(\r\n                            /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180),\r\n                            /*column5_row3*/ mload(0x24e0),\r\n                            PRIME),\r\n                          PRIME)),\r\n                      PRIME),\r\n                    /*column9_inter1_row0*/ mload(0x3020),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(2 * (trace_length / 2 - 1)).\r\n              // val *= numerators[2].\r\n              val := mulmod(val, mload(0x3da0), PRIME)\r\n              // Denominator: point^(trace_length / 2) - 1.\r\n              // val *= denominator_invs[5].\r\n              val := mulmod(val, mload(0x3840), PRIME)\r\n\r\n              // res += val * (coefficients[46] + coefficients[47] * adjustments[6]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[46]*/ mload(0xa00),\r\n                                       mulmod(/*coefficients[47]*/ mload(0xa20),\r\n                                              /*adjustments[6]*/mload(0x3f80),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for memory/multi_column_perm/perm/last: column9_inter1_row0 - memory/multi_column_perm/perm/public_memory_prod.\r\n              let val := addmod(\r\n                /*column9_inter1_row0*/ mload(0x3020),\r\n                sub(PRIME, /*memory/multi_column_perm/perm/public_memory_prod*/ mload(0x1a0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(2 * (trace_length / 2 - 1)).\r\n              // val *= denominator_invs[6].\r\n              val := mulmod(val, mload(0x3860), PRIME)\r\n\r\n              // res += val * (coefficients[48] + coefficients[49] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[48]*/ mload(0xa40),\r\n                                       mulmod(/*coefficients[49]*/ mload(0xa60),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for memory/diff_is_bit: memory__address_diff_0 * memory__address_diff_0 - memory__address_diff_0.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/memory/address_diff_0*/ mload(0x32c0),\r\n                  /*intermediate_value/memory/address_diff_0*/ mload(0x32c0),\r\n                  PRIME),\r\n                sub(PRIME, /*intermediate_value/memory/address_diff_0*/ mload(0x32c0)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(2 * (trace_length / 2 - 1)).\r\n              // val *= numerators[2].\r\n              val := mulmod(val, mload(0x3da0), PRIME)\r\n              // Denominator: point^(trace_length / 2) - 1.\r\n              // val *= denominator_invs[5].\r\n              val := mulmod(val, mload(0x3840), PRIME)\r\n\r\n              // res += val * (coefficients[50] + coefficients[51] * adjustments[6]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[50]*/ mload(0xa80),\r\n                                       mulmod(/*coefficients[51]*/ mload(0xaa0),\r\n                                              /*adjustments[6]*/mload(0x3f80),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for memory/is_func: (memory__address_diff_0 - 1) * (column6_row1 - column6_row3).\r\n              let val := mulmod(\r\n                addmod(/*intermediate_value/memory/address_diff_0*/ mload(0x32c0), sub(PRIME, 1), PRIME),\r\n                addmod(/*column6_row1*/ mload(0x2880), sub(PRIME, /*column6_row3*/ mload(0x28c0)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(2 * (trace_length / 2 - 1)).\r\n              // val *= numerators[2].\r\n              val := mulmod(val, mload(0x3da0), PRIME)\r\n              // Denominator: point^(trace_length / 2) - 1.\r\n              // val *= denominator_invs[5].\r\n              val := mulmod(val, mload(0x3840), PRIME)\r\n\r\n              // res += val * (coefficients[52] + coefficients[53] * adjustments[6]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[52]*/ mload(0xac0),\r\n                                       mulmod(/*coefficients[53]*/ mload(0xae0),\r\n                                              /*adjustments[6]*/mload(0x3f80),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for memory/initial_addr: column6_row0 - 1.\r\n              let val := addmod(/*column6_row0*/ mload(0x2860), sub(PRIME, 1), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x3800), PRIME)\r\n\r\n              // res += val * (coefficients[54] + coefficients[55] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[54]*/ mload(0xb00),\r\n                                       mulmod(/*coefficients[55]*/ mload(0xb20),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for public_memory_addr_zero: column5_row2.\r\n              let val := /*column5_row2*/ mload(0x24c0)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8) - 1.\r\n              // val *= denominator_invs[7].\r\n              val := mulmod(val, mload(0x3880), PRIME)\r\n\r\n              // res += val * (coefficients[56] + coefficients[57] * adjustments[7]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[56]*/ mload(0xb40),\r\n                                       mulmod(/*coefficients[57]*/ mload(0xb60),\r\n                                              /*adjustments[7]*/mload(0x3fa0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for public_memory_value_zero: column5_row3.\r\n              let val := /*column5_row3*/ mload(0x24e0)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8) - 1.\r\n              // val *= denominator_invs[7].\r\n              val := mulmod(val, mload(0x3880), PRIME)\r\n\r\n              // res += val * (coefficients[58] + coefficients[59] * adjustments[7]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[58]*/ mload(0xb80),\r\n                                       mulmod(/*coefficients[59]*/ mload(0xba0),\r\n                                              /*adjustments[7]*/mload(0x3fa0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc16/perm/init0: (rc16/perm/interaction_elm - column7_row2) * column9_inter1_row1 + column7_row0 - rc16/perm/interaction_elm.\r\n              let val := addmod(\r\n                addmod(\r\n                  mulmod(\r\n                    addmod(\r\n                      /*rc16/perm/interaction_elm*/ mload(0x1c0),\r\n                      sub(PRIME, /*column7_row2*/ mload(0x2920)),\r\n                      PRIME),\r\n                    /*column9_inter1_row1*/ mload(0x3040),\r\n                    PRIME),\r\n                  /*column7_row0*/ mload(0x28e0),\r\n                  PRIME),\r\n                sub(PRIME, /*rc16/perm/interaction_elm*/ mload(0x1c0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x3800), PRIME)\r\n\r\n              // res += val * (coefficients[60] + coefficients[61] * adjustments[5]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[60]*/ mload(0xbc0),\r\n                                       mulmod(/*coefficients[61]*/ mload(0xbe0),\r\n                                              /*adjustments[5]*/mload(0x3f60),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc16/perm/step0: (rc16/perm/interaction_elm - column7_row6) * column9_inter1_row5 - (rc16/perm/interaction_elm - column7_row4) * column9_inter1_row1.\r\n              let val := addmod(\r\n                mulmod(\r\n                  addmod(\r\n                    /*rc16/perm/interaction_elm*/ mload(0x1c0),\r\n                    sub(PRIME, /*column7_row6*/ mload(0x29a0)),\r\n                    PRIME),\r\n                  /*column9_inter1_row5*/ mload(0x3080),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    addmod(\r\n                      /*rc16/perm/interaction_elm*/ mload(0x1c0),\r\n                      sub(PRIME, /*column7_row4*/ mload(0x2960)),\r\n                      PRIME),\r\n                    /*column9_inter1_row1*/ mload(0x3040),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(4 * (trace_length / 4 - 1)).\r\n              // val *= numerators[3].\r\n              val := mulmod(val, mload(0x3dc0), PRIME)\r\n              // Denominator: point^(trace_length / 4) - 1.\r\n              // val *= denominator_invs[8].\r\n              val := mulmod(val, mload(0x38a0), PRIME)\r\n\r\n              // res += val * (coefficients[62] + coefficients[63] * adjustments[8]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[62]*/ mload(0xc00),\r\n                                       mulmod(/*coefficients[63]*/ mload(0xc20),\r\n                                              /*adjustments[8]*/mload(0x3fc0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc16/perm/last: column9_inter1_row1 - rc16/perm/public_memory_prod.\r\n              let val := addmod(\r\n                /*column9_inter1_row1*/ mload(0x3040),\r\n                sub(PRIME, /*rc16/perm/public_memory_prod*/ mload(0x1e0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(4 * (trace_length / 4 - 1)).\r\n              // val *= denominator_invs[9].\r\n              val := mulmod(val, mload(0x38c0), PRIME)\r\n\r\n              // res += val * (coefficients[64] + coefficients[65] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[64]*/ mload(0xc40),\r\n                                       mulmod(/*coefficients[65]*/ mload(0xc60),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc16/diff_is_bit: rc16__diff_0 * rc16__diff_0 - rc16__diff_0.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc16/diff_0*/ mload(0x32e0),\r\n                  /*intermediate_value/rc16/diff_0*/ mload(0x32e0),\r\n                  PRIME),\r\n                sub(PRIME, /*intermediate_value/rc16/diff_0*/ mload(0x32e0)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(4 * (trace_length / 4 - 1)).\r\n              // val *= numerators[3].\r\n              val := mulmod(val, mload(0x3dc0), PRIME)\r\n              // Denominator: point^(trace_length / 4) - 1.\r\n              // val *= denominator_invs[8].\r\n              val := mulmod(val, mload(0x38a0), PRIME)\r\n\r\n              // res += val * (coefficients[66] + coefficients[67] * adjustments[8]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[66]*/ mload(0xc80),\r\n                                       mulmod(/*coefficients[67]*/ mload(0xca0),\r\n                                              /*adjustments[8]*/mload(0x3fc0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc16/minimum: column7_row2 - rc_min.\r\n              let val := addmod(/*column7_row2*/ mload(0x2920), sub(PRIME, /*rc_min*/ mload(0x200)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x3800), PRIME)\r\n\r\n              // res += val * (coefficients[68] + coefficients[69] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[68]*/ mload(0xcc0),\r\n                                       mulmod(/*coefficients[69]*/ mload(0xce0),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc16/maximum: column7_row2 - rc_max.\r\n              let val := addmod(/*column7_row2*/ mload(0x2920), sub(PRIME, /*rc_max*/ mload(0x220)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(4 * (trace_length / 4 - 1)).\r\n              // val *= denominator_invs[9].\r\n              val := mulmod(val, mload(0x38c0), PRIME)\r\n\r\n              // res += val * (coefficients[70] + coefficients[71] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[70]*/ mload(0xd00),\r\n                                       mulmod(/*coefficients[71]*/ mload(0xd20),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/last_one_is_zero: column8_row80 * (column4_row0 - (column4_row1 + column4_row1)).\r\n              let val := mulmod(\r\n                /*column8_row80*/ mload(0x2f00),\r\n                addmod(\r\n                  /*column4_row0*/ mload(0x2360),\r\n                  sub(\r\n                    PRIME,\r\n                    addmod(/*column4_row1*/ mload(0x2380), /*column4_row1*/ mload(0x2380), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[72] + coefficients[73] * adjustments[9]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[72]*/ mload(0xd40),\r\n                                       mulmod(/*coefficients[73]*/ mload(0xd60),\r\n                                              /*adjustments[9]*/mload(0x3fe0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones0: column8_row80 * (column4_row1 - 3138550867693340381917894711603833208051177722232017256448 * column4_row192).\r\n              let val := mulmod(\r\n                /*column8_row80*/ mload(0x2f00),\r\n                addmod(\r\n                  /*column4_row1*/ mload(0x2380),\r\n                  sub(\r\n                    PRIME,\r\n                    mulmod(\r\n                      3138550867693340381917894711603833208051177722232017256448,\r\n                      /*column4_row192*/ mload(0x23a0),\r\n                      PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[74] + coefficients[75] * adjustments[9]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[74]*/ mload(0xd80),\r\n                                       mulmod(/*coefficients[75]*/ mload(0xda0),\r\n                                              /*adjustments[9]*/mload(0x3fe0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit192: column8_row80 - column3_row255 * (column4_row192 - (column4_row193 + column4_row193)).\r\n              let val := addmod(\r\n                /*column8_row80*/ mload(0x2f00),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column3_row255*/ mload(0x2340),\r\n                    addmod(\r\n                      /*column4_row192*/ mload(0x23a0),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column4_row193*/ mload(0x23c0), /*column4_row193*/ mload(0x23c0), PRIME)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[76] + coefficients[77] * adjustments[9]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[76]*/ mload(0xdc0),\r\n                                       mulmod(/*coefficients[77]*/ mload(0xde0),\r\n                                              /*adjustments[9]*/mload(0x3fe0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones192: column3_row255 * (column4_row193 - 8 * column4_row196).\r\n              let val := mulmod(\r\n                /*column3_row255*/ mload(0x2340),\r\n                addmod(\r\n                  /*column4_row193*/ mload(0x23c0),\r\n                  sub(PRIME, mulmod(8, /*column4_row196*/ mload(0x23e0), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[78] + coefficients[79] * adjustments[9]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[78]*/ mload(0xe00),\r\n                                       mulmod(/*coefficients[79]*/ mload(0xe20),\r\n                                              /*adjustments[9]*/mload(0x3fe0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit196: column3_row255 - (column4_row251 - (column4_row252 + column4_row252)) * (column4_row196 - (column4_row197 + column4_row197)).\r\n              let val := addmod(\r\n                /*column3_row255*/ mload(0x2340),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    addmod(\r\n                      /*column4_row251*/ mload(0x2420),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column4_row252*/ mload(0x2440), /*column4_row252*/ mload(0x2440), PRIME)),\r\n                      PRIME),\r\n                    addmod(\r\n                      /*column4_row196*/ mload(0x23e0),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column4_row197*/ mload(0x2400), /*column4_row197*/ mload(0x2400), PRIME)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[80] + coefficients[81] * adjustments[9]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[80]*/ mload(0xe40),\r\n                                       mulmod(/*coefficients[81]*/ mload(0xe60),\r\n                                              /*adjustments[9]*/mload(0x3fe0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones196: (column4_row251 - (column4_row252 + column4_row252)) * (column4_row197 - 18014398509481984 * column4_row251).\r\n              let val := mulmod(\r\n                addmod(\r\n                  /*column4_row251*/ mload(0x2420),\r\n                  sub(\r\n                    PRIME,\r\n                    addmod(/*column4_row252*/ mload(0x2440), /*column4_row252*/ mload(0x2440), PRIME)),\r\n                  PRIME),\r\n                addmod(\r\n                  /*column4_row197*/ mload(0x2400),\r\n                  sub(PRIME, mulmod(18014398509481984, /*column4_row251*/ mload(0x2420), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[82] + coefficients[83] * adjustments[9]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[82]*/ mload(0xe80),\r\n                                       mulmod(/*coefficients[83]*/ mload(0xea0),\r\n                                              /*adjustments[9]*/mload(0x3fe0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/booleanity_test: pedersen__hash0__ec_subset_sum__bit_0 * (pedersen__hash0__ec_subset_sum__bit_0 - 1).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3300),\r\n                addmod(\r\n                  /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3300),\r\n                  sub(PRIME, 1),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[4].\r\n              val := mulmod(val, mload(0x3de0), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x37a0), PRIME)\r\n\r\n              // res += val * (coefficients[84] + coefficients[85] * adjustments[10]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[84]*/ mload(0xec0),\r\n                                       mulmod(/*coefficients[85]*/ mload(0xee0),\r\n                                              /*adjustments[10]*/mload(0x4000),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_extraction_end: column4_row0.\r\n              let val := /*column4_row0*/ mload(0x2360)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x3900), PRIME)\r\n\r\n              // res += val * (coefficients[86] + coefficients[87] * adjustments[11]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[86]*/ mload(0xf00),\r\n                                       mulmod(/*coefficients[87]*/ mload(0xf20),\r\n                                              /*adjustments[11]*/mload(0x4020),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/zeros_tail: column4_row0.\r\n              let val := /*column4_row0*/ mload(0x2360)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= denominator_invs[12].\r\n              val := mulmod(val, mload(0x3920), PRIME)\r\n\r\n              // res += val * (coefficients[88] + coefficients[89] * adjustments[11]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[88]*/ mload(0xf40),\r\n                                       mulmod(/*coefficients[89]*/ mload(0xf60),\r\n                                              /*adjustments[11]*/mload(0x4020),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/add_points/slope: pedersen__hash0__ec_subset_sum__bit_0 * (column2_row0 - pedersen__points__y) - column3_row0 * (column1_row0 - pedersen__points__x).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3300),\r\n                  addmod(\r\n                    /*column2_row0*/ mload(0x22a0),\r\n                    sub(PRIME, /*periodic_column/pedersen/points/y*/ mload(0x20)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column3_row0*/ mload(0x2320),\r\n                    addmod(\r\n                      /*column1_row0*/ mload(0x2200),\r\n                      sub(PRIME, /*periodic_column/pedersen/points/x*/ mload(0x0)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[4].\r\n              val := mulmod(val, mload(0x3de0), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x37a0), PRIME)\r\n\r\n              // res += val * (coefficients[90] + coefficients[91] * adjustments[10]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[90]*/ mload(0xf80),\r\n                                       mulmod(/*coefficients[91]*/ mload(0xfa0),\r\n                                              /*adjustments[10]*/mload(0x4000),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/add_points/x: column3_row0 * column3_row0 - pedersen__hash0__ec_subset_sum__bit_0 * (column1_row0 + pedersen__points__x + column1_row1).\r\n              let val := addmod(\r\n                mulmod(/*column3_row0*/ mload(0x2320), /*column3_row0*/ mload(0x2320), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3300),\r\n                    addmod(\r\n                      addmod(\r\n                        /*column1_row0*/ mload(0x2200),\r\n                        /*periodic_column/pedersen/points/x*/ mload(0x0),\r\n                        PRIME),\r\n                      /*column1_row1*/ mload(0x2220),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[4].\r\n              val := mulmod(val, mload(0x3de0), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x37a0), PRIME)\r\n\r\n              // res += val * (coefficients[92] + coefficients[93] * adjustments[10]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[92]*/ mload(0xfc0),\r\n                                       mulmod(/*coefficients[93]*/ mload(0xfe0),\r\n                                              /*adjustments[10]*/mload(0x4000),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/add_points/y: pedersen__hash0__ec_subset_sum__bit_0 * (column2_row0 + column2_row1) - column3_row0 * (column1_row0 - column1_row1).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3300),\r\n                  addmod(/*column2_row0*/ mload(0x22a0), /*column2_row1*/ mload(0x22c0), PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column3_row0*/ mload(0x2320),\r\n                    addmod(/*column1_row0*/ mload(0x2200), sub(PRIME, /*column1_row1*/ mload(0x2220)), PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[4].\r\n              val := mulmod(val, mload(0x3de0), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x37a0), PRIME)\r\n\r\n              // res += val * (coefficients[94] + coefficients[95] * adjustments[10]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[94]*/ mload(0x1000),\r\n                                       mulmod(/*coefficients[95]*/ mload(0x1020),\r\n                                              /*adjustments[10]*/mload(0x4000),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/copy_point/x: pedersen__hash0__ec_subset_sum__bit_neg_0 * (column1_row1 - column1_row0).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_neg_0*/ mload(0x3320),\r\n                addmod(/*column1_row1*/ mload(0x2220), sub(PRIME, /*column1_row0*/ mload(0x2200)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[4].\r\n              val := mulmod(val, mload(0x3de0), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x37a0), PRIME)\r\n\r\n              // res += val * (coefficients[96] + coefficients[97] * adjustments[10]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[96]*/ mload(0x1040),\r\n                                       mulmod(/*coefficients[97]*/ mload(0x1060),\r\n                                              /*adjustments[10]*/mload(0x4000),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/copy_point/y: pedersen__hash0__ec_subset_sum__bit_neg_0 * (column2_row1 - column2_row0).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_neg_0*/ mload(0x3320),\r\n                addmod(/*column2_row1*/ mload(0x22c0), sub(PRIME, /*column2_row0*/ mload(0x22a0)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[4].\r\n              val := mulmod(val, mload(0x3de0), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x37a0), PRIME)\r\n\r\n              // res += val * (coefficients[98] + coefficients[99] * adjustments[10]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[98]*/ mload(0x1080),\r\n                                       mulmod(/*coefficients[99]*/ mload(0x10a0),\r\n                                              /*adjustments[10]*/mload(0x4000),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/copy_point/x: column1_row256 - column1_row255.\r\n              let val := addmod(\r\n                /*column1_row256*/ mload(0x2260),\r\n                sub(PRIME, /*column1_row255*/ mload(0x2240)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x3e00), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[100] + coefficients[101] * adjustments[12]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[100]*/ mload(0x10c0),\r\n                                       mulmod(/*coefficients[101]*/ mload(0x10e0),\r\n                                              /*adjustments[12]*/mload(0x4040),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/copy_point/y: column2_row256 - column2_row255.\r\n              let val := addmod(\r\n                /*column2_row256*/ mload(0x2300),\r\n                sub(PRIME, /*column2_row255*/ mload(0x22e0)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x3e00), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[102] + coefficients[103] * adjustments[12]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[102]*/ mload(0x1100),\r\n                                       mulmod(/*coefficients[103]*/ mload(0x1120),\r\n                                              /*adjustments[12]*/mload(0x4040),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/init/x: column1_row0 - pedersen/shift_point.x.\r\n              let val := addmod(\r\n                /*column1_row0*/ mload(0x2200),\r\n                sub(PRIME, /*pedersen/shift_point.x*/ mload(0x240)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[13].\r\n              val := mulmod(val, mload(0x3940), PRIME)\r\n\r\n              // res += val * (coefficients[104] + coefficients[105] * adjustments[13]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[104]*/ mload(0x1140),\r\n                                       mulmod(/*coefficients[105]*/ mload(0x1160),\r\n                                              /*adjustments[13]*/mload(0x4060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/init/y: column2_row0 - pedersen/shift_point.y.\r\n              let val := addmod(\r\n                /*column2_row0*/ mload(0x22a0),\r\n                sub(PRIME, /*pedersen/shift_point.y*/ mload(0x260)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[13].\r\n              val := mulmod(val, mload(0x3940), PRIME)\r\n\r\n              // res += val * (coefficients[106] + coefficients[107] * adjustments[13]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[106]*/ mload(0x1180),\r\n                                       mulmod(/*coefficients[107]*/ mload(0x11a0),\r\n                                              /*adjustments[13]*/mload(0x4060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input0_value0: column5_row7 - column4_row0.\r\n              let val := addmod(/*column5_row7*/ mload(0x2560), sub(PRIME, /*column4_row0*/ mload(0x2360)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[13].\r\n              val := mulmod(val, mload(0x3940), PRIME)\r\n\r\n              // res += val * (coefficients[108] + coefficients[109] * adjustments[13]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[108]*/ mload(0x11c0),\r\n                                       mulmod(/*coefficients[109]*/ mload(0x11e0),\r\n                                              /*adjustments[13]*/mload(0x4060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input0_addr: column5_row518 - (column5_row134 + 1).\r\n              let val := addmod(\r\n                /*column5_row518*/ mload(0x27e0),\r\n                sub(PRIME, addmod(/*column5_row134*/ mload(0x26a0), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(512 * (trace_length / 512 - 1)).\r\n              // val *= numerators[6].\r\n              val := mulmod(val, mload(0x3e20), PRIME)\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[13].\r\n              val := mulmod(val, mload(0x3940), PRIME)\r\n\r\n              // res += val * (coefficients[110] + coefficients[111] * adjustments[14]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[110]*/ mload(0x1200),\r\n                                       mulmod(/*coefficients[111]*/ mload(0x1220),\r\n                                              /*adjustments[14]*/mload(0x4080),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/init_addr: column5_row6 - initial_pedersen_addr.\r\n              let val := addmod(\r\n                /*column5_row6*/ mload(0x2540),\r\n                sub(PRIME, /*initial_pedersen_addr*/ mload(0x280)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x3800), PRIME)\r\n\r\n              // res += val * (coefficients[112] + coefficients[113] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[112]*/ mload(0x1240),\r\n                                       mulmod(/*coefficients[113]*/ mload(0x1260),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input1_value0: column5_row263 - column4_row256.\r\n              let val := addmod(\r\n                /*column5_row263*/ mload(0x2740),\r\n                sub(PRIME, /*column4_row256*/ mload(0x2460)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[13].\r\n              val := mulmod(val, mload(0x3940), PRIME)\r\n\r\n              // res += val * (coefficients[114] + coefficients[115] * adjustments[13]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[114]*/ mload(0x1280),\r\n                                       mulmod(/*coefficients[115]*/ mload(0x12a0),\r\n                                              /*adjustments[13]*/mload(0x4060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input1_addr: column5_row262 - (column5_row6 + 1).\r\n              let val := addmod(\r\n                /*column5_row262*/ mload(0x2720),\r\n                sub(PRIME, addmod(/*column5_row6*/ mload(0x2540), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[13].\r\n              val := mulmod(val, mload(0x3940), PRIME)\r\n\r\n              // res += val * (coefficients[116] + coefficients[117] * adjustments[13]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[116]*/ mload(0x12c0),\r\n                                       mulmod(/*coefficients[117]*/ mload(0x12e0),\r\n                                              /*adjustments[13]*/mload(0x4060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/output_value0: column5_row135 - column1_row511.\r\n              let val := addmod(\r\n                /*column5_row135*/ mload(0x26c0),\r\n                sub(PRIME, /*column1_row511*/ mload(0x2280)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[13].\r\n              val := mulmod(val, mload(0x3940), PRIME)\r\n\r\n              // res += val * (coefficients[118] + coefficients[119] * adjustments[13]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[118]*/ mload(0x1300),\r\n                                       mulmod(/*coefficients[119]*/ mload(0x1320),\r\n                                              /*adjustments[13]*/mload(0x4060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/output_addr: column5_row134 - (column5_row262 + 1).\r\n              let val := addmod(\r\n                /*column5_row134*/ mload(0x26a0),\r\n                sub(PRIME, addmod(/*column5_row262*/ mload(0x2720), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[13].\r\n              val := mulmod(val, mload(0x3940), PRIME)\r\n\r\n              // res += val * (coefficients[120] + coefficients[121] * adjustments[13]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[120]*/ mload(0x1340),\r\n                                       mulmod(/*coefficients[121]*/ mload(0x1360),\r\n                                              /*adjustments[13]*/mload(0x4060),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc_builtin/value: rc_builtin__value7_0 - column5_row71.\r\n              let val := addmod(\r\n                /*intermediate_value/rc_builtin/value7_0*/ mload(0x3420),\r\n                sub(PRIME, /*column5_row71*/ mload(0x2680)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[122] + coefficients[123] * adjustments[11]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[122]*/ mload(0x1380),\r\n                                       mulmod(/*coefficients[123]*/ mload(0x13a0),\r\n                                              /*adjustments[11]*/mload(0x4020),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc_builtin/addr_step: column5_row326 - (column5_row70 + 1).\r\n              let val := addmod(\r\n                /*column5_row326*/ mload(0x2760),\r\n                sub(PRIME, addmod(/*column5_row70*/ mload(0x2660), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(256 * (trace_length / 256 - 1)).\r\n              // val *= numerators[7].\r\n              val := mulmod(val, mload(0x3e40), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[124] + coefficients[125] * adjustments[15]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[124]*/ mload(0x13c0),\r\n                                       mulmod(/*coefficients[125]*/ mload(0x13e0),\r\n                                              /*adjustments[15]*/mload(0x40a0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc_builtin/init_addr: column5_row70 - initial_rc_addr.\r\n              let val := addmod(\r\n                /*column5_row70*/ mload(0x2660),\r\n                sub(PRIME, /*initial_rc_addr*/ mload(0x2a0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x3800), PRIME)\r\n\r\n              // res += val * (coefficients[126] + coefficients[127] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[126]*/ mload(0x1400),\r\n                                       mulmod(/*coefficients[127]*/ mload(0x1420),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/doubling_key/slope: ecdsa__signature0__doubling_key__x_squared + ecdsa__signature0__doubling_key__x_squared + ecdsa__signature0__doubling_key__x_squared + ecdsa/sig_config.alpha - (column7_row39 + column7_row39) * column7_row23.\r\n              let val := addmod(\r\n                addmod(\r\n                  addmod(\r\n                    addmod(\r\n                      /*intermediate_value/ecdsa/signature0/doubling_key/x_squared*/ mload(0x3440),\r\n                      /*intermediate_value/ecdsa/signature0/doubling_key/x_squared*/ mload(0x3440),\r\n                      PRIME),\r\n                    /*intermediate_value/ecdsa/signature0/doubling_key/x_squared*/ mload(0x3440),\r\n                    PRIME),\r\n                  /*ecdsa/sig_config.alpha*/ mload(0x2c0),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    addmod(/*column7_row39*/ mload(0x2b20), /*column7_row39*/ mload(0x2b20), PRIME),\r\n                    /*column7_row23*/ mload(0x2ac0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x3e60), PRIME)\r\n              // Denominator: point^(trace_length / 64) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x3960), PRIME)\r\n\r\n              // res += val * (coefficients[128] + coefficients[129] * adjustments[16]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[128]*/ mload(0x1440),\r\n                                       mulmod(/*coefficients[129]*/ mload(0x1460),\r\n                                              /*adjustments[16]*/mload(0x40c0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/doubling_key/x: column7_row23 * column7_row23 - (column7_row7 + column7_row7 + column7_row71).\r\n              let val := addmod(\r\n                mulmod(/*column7_row23*/ mload(0x2ac0), /*column7_row23*/ mload(0x2ac0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(/*column7_row7*/ mload(0x29c0), /*column7_row7*/ mload(0x29c0), PRIME),\r\n                    /*column7_row71*/ mload(0x2bc0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x3e60), PRIME)\r\n              // Denominator: point^(trace_length / 64) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x3960), PRIME)\r\n\r\n              // res += val * (coefficients[130] + coefficients[131] * adjustments[16]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[130]*/ mload(0x1480),\r\n                                       mulmod(/*coefficients[131]*/ mload(0x14a0),\r\n                                              /*adjustments[16]*/mload(0x40c0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/doubling_key/y: column7_row39 + column7_row103 - column7_row23 * (column7_row7 - column7_row71).\r\n              let val := addmod(\r\n                addmod(/*column7_row39*/ mload(0x2b20), /*column7_row103*/ mload(0x2c40), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column7_row23*/ mload(0x2ac0),\r\n                    addmod(/*column7_row7*/ mload(0x29c0), sub(PRIME, /*column7_row71*/ mload(0x2bc0)), PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x3e60), PRIME)\r\n              // Denominator: point^(trace_length / 64) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x3960), PRIME)\r\n\r\n              // res += val * (coefficients[132] + coefficients[133] * adjustments[16]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[132]*/ mload(0x14c0),\r\n                                       mulmod(/*coefficients[133]*/ mload(0x14e0),\r\n                                              /*adjustments[16]*/mload(0x40c0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/booleanity_test: ecdsa__signature0__exponentiate_generator__bit_0 * (ecdsa__signature0__exponentiate_generator__bit_0 - 1).\r\n              let val := mulmod(\r\n                /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x3460),\r\n                addmod(\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x3460),\r\n                  sub(PRIME, 1),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x3e80), PRIME)\r\n              // Denominator: point^(trace_length / 128) - 1.\r\n              // val *= denominator_invs[15].\r\n              val := mulmod(val, mload(0x3980), PRIME)\r\n\r\n              // res += val * (coefficients[134] + coefficients[135] * adjustments[17]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[134]*/ mload(0x1500),\r\n                                       mulmod(/*coefficients[135]*/ mload(0x1520),\r\n                                              /*adjustments[17]*/mload(0x40e0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/bit_extraction_end: column8_row96.\r\n              let val := /*column8_row96*/ mload(0x2f20)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - trace_generator^(251 * trace_length / 256).\r\n              // val *= denominator_invs[16].\r\n              val := mulmod(val, mload(0x39a0), PRIME)\r\n\r\n              // res += val * (coefficients[136] + coefficients[137] * adjustments[18]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[136]*/ mload(0x1540),\r\n                                       mulmod(/*coefficients[137]*/ mload(0x1560),\r\n                                              /*adjustments[18]*/mload(0x4100),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/zeros_tail: column8_row96.\r\n              let val := /*column8_row96*/ mload(0x2f20)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\r\n              // val *= denominator_invs[17].\r\n              val := mulmod(val, mload(0x39c0), PRIME)\r\n\r\n              // res += val * (coefficients[138] + coefficients[139] * adjustments[18]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[138]*/ mload(0x1580),\r\n                                       mulmod(/*coefficients[139]*/ mload(0x15a0),\r\n                                              /*adjustments[18]*/mload(0x4100),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/add_points/slope: ecdsa__signature0__exponentiate_generator__bit_0 * (column8_row64 - ecdsa__generator_points__y) - column8_row32 * (column8_row0 - ecdsa__generator_points__x).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x3460),\r\n                  addmod(\r\n                    /*column8_row64*/ mload(0x2ee0),\r\n                    sub(PRIME, /*periodic_column/ecdsa/generator_points/y*/ mload(0x60)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column8_row32*/ mload(0x2ec0),\r\n                    addmod(\r\n                      /*column8_row0*/ mload(0x2e80),\r\n                      sub(PRIME, /*periodic_column/ecdsa/generator_points/x*/ mload(0x40)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x3e80), PRIME)\r\n              // Denominator: point^(trace_length / 128) - 1.\r\n              // val *= denominator_invs[15].\r\n              val := mulmod(val, mload(0x3980), PRIME)\r\n\r\n              // res += val * (coefficients[140] + coefficients[141] * adjustments[17]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[140]*/ mload(0x15c0),\r\n                                       mulmod(/*coefficients[141]*/ mload(0x15e0),\r\n                                              /*adjustments[17]*/mload(0x40e0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/add_points/x: column8_row32 * column8_row32 - ecdsa__signature0__exponentiate_generator__bit_0 * (column8_row0 + ecdsa__generator_points__x + column8_row128).\r\n              let val := addmod(\r\n                mulmod(/*column8_row32*/ mload(0x2ec0), /*column8_row32*/ mload(0x2ec0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x3460),\r\n                    addmod(\r\n                      addmod(\r\n                        /*column8_row0*/ mload(0x2e80),\r\n                        /*periodic_column/ecdsa/generator_points/x*/ mload(0x40),\r\n                        PRIME),\r\n                      /*column8_row128*/ mload(0x2f40),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x3e80), PRIME)\r\n              // Denominator: point^(trace_length / 128) - 1.\r\n              // val *= denominator_invs[15].\r\n              val := mulmod(val, mload(0x3980), PRIME)\r\n\r\n              // res += val * (coefficients[142] + coefficients[143] * adjustments[17]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[142]*/ mload(0x1600),\r\n                                       mulmod(/*coefficients[143]*/ mload(0x1620),\r\n                                              /*adjustments[17]*/mload(0x40e0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/add_points/y: ecdsa__signature0__exponentiate_generator__bit_0 * (column8_row64 + column8_row192) - column8_row32 * (column8_row0 - column8_row128).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x3460),\r\n                  addmod(/*column8_row64*/ mload(0x2ee0), /*column8_row192*/ mload(0x2f60), PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column8_row32*/ mload(0x2ec0),\r\n                    addmod(/*column8_row0*/ mload(0x2e80), sub(PRIME, /*column8_row128*/ mload(0x2f40)), PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x3e80), PRIME)\r\n              // Denominator: point^(trace_length / 128) - 1.\r\n              // val *= denominator_invs[15].\r\n              val := mulmod(val, mload(0x3980), PRIME)\r\n\r\n              // res += val * (coefficients[144] + coefficients[145] * adjustments[17]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[144]*/ mload(0x1640),\r\n                                       mulmod(/*coefficients[145]*/ mload(0x1660),\r\n                                              /*adjustments[17]*/mload(0x40e0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/add_points/x_diff_inv: column8_row16 * (column8_row0 - ecdsa__generator_points__x) - 1.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*column8_row16*/ mload(0x2ea0),\r\n                  addmod(\r\n                    /*column8_row0*/ mload(0x2e80),\r\n                    sub(PRIME, /*periodic_column/ecdsa/generator_points/x*/ mload(0x40)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(PRIME, 1),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x3e80), PRIME)\r\n              // Denominator: point^(trace_length / 128) - 1.\r\n              // val *= denominator_invs[15].\r\n              val := mulmod(val, mload(0x3980), PRIME)\r\n\r\n              // res += val * (coefficients[146] + coefficients[147] * adjustments[17]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[146]*/ mload(0x1680),\r\n                                       mulmod(/*coefficients[147]*/ mload(0x16a0),\r\n                                              /*adjustments[17]*/mload(0x40e0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/copy_point/x: ecdsa__signature0__exponentiate_generator__bit_neg_0 * (column8_row128 - column8_row0).\r\n              let val := mulmod(\r\n                /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_neg_0*/ mload(0x3480),\r\n                addmod(/*column8_row128*/ mload(0x2f40), sub(PRIME, /*column8_row0*/ mload(0x2e80)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x3e80), PRIME)\r\n              // Denominator: point^(trace_length / 128) - 1.\r\n              // val *= denominator_invs[15].\r\n              val := mulmod(val, mload(0x3980), PRIME)\r\n\r\n              // res += val * (coefficients[148] + coefficients[149] * adjustments[17]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[148]*/ mload(0x16c0),\r\n                                       mulmod(/*coefficients[149]*/ mload(0x16e0),\r\n                                              /*adjustments[17]*/mload(0x40e0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/copy_point/y: ecdsa__signature0__exponentiate_generator__bit_neg_0 * (column8_row192 - column8_row64).\r\n              let val := mulmod(\r\n                /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_neg_0*/ mload(0x3480),\r\n                addmod(\r\n                  /*column8_row192*/ mload(0x2f60),\r\n                  sub(PRIME, /*column8_row64*/ mload(0x2ee0)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x3e80), PRIME)\r\n              // Denominator: point^(trace_length / 128) - 1.\r\n              // val *= denominator_invs[15].\r\n              val := mulmod(val, mload(0x3980), PRIME)\r\n\r\n              // res += val * (coefficients[150] + coefficients[151] * adjustments[17]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[150]*/ mload(0x1700),\r\n                                       mulmod(/*coefficients[151]*/ mload(0x1720),\r\n                                              /*adjustments[17]*/mload(0x40e0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/booleanity_test: ecdsa__signature0__exponentiate_key__bit_0 * (ecdsa__signature0__exponentiate_key__bit_0 - 1).\r\n              let val := mulmod(\r\n                /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x34a0),\r\n                addmod(\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x34a0),\r\n                  sub(PRIME, 1),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x3e60), PRIME)\r\n              // Denominator: point^(trace_length / 64) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x3960), PRIME)\r\n\r\n              // res += val * (coefficients[152] + coefficients[153] * adjustments[16]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[152]*/ mload(0x1740),\r\n                                       mulmod(/*coefficients[153]*/ mload(0x1760),\r\n                                              /*adjustments[16]*/mload(0x40c0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/bit_extraction_end: column7_row31.\r\n              let val := /*column7_row31*/ mload(0x2b00)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16384) - trace_generator^(251 * trace_length / 256).\r\n              // val *= denominator_invs[18].\r\n              val := mulmod(val, mload(0x39e0), PRIME)\r\n\r\n              // res += val * (coefficients[154] + coefficients[155] * adjustments[19]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[154]*/ mload(0x1780),\r\n                                       mulmod(/*coefficients[155]*/ mload(0x17a0),\r\n                                              /*adjustments[19]*/mload(0x4120),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/zeros_tail: column7_row31.\r\n              let val := /*column7_row31*/ mload(0x2b00)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\r\n              // val *= denominator_invs[19].\r\n              val := mulmod(val, mload(0x3a00), PRIME)\r\n\r\n              // res += val * (coefficients[156] + coefficients[157] * adjustments[19]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[156]*/ mload(0x17c0),\r\n                                       mulmod(/*coefficients[157]*/ mload(0x17e0),\r\n                                              /*adjustments[19]*/mload(0x4120),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/add_points/slope: ecdsa__signature0__exponentiate_key__bit_0 * (column7_row15 - column7_row39) - column7_row47 * (column7_row55 - column7_row7).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x34a0),\r\n                  addmod(/*column7_row15*/ mload(0x2a80), sub(PRIME, /*column7_row39*/ mload(0x2b20)), PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column7_row47*/ mload(0x2b60),\r\n                    addmod(/*column7_row55*/ mload(0x2b80), sub(PRIME, /*column7_row7*/ mload(0x29c0)), PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x3e60), PRIME)\r\n              // Denominator: point^(trace_length / 64) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x3960), PRIME)\r\n\r\n              // res += val * (coefficients[158] + coefficients[159] * adjustments[16]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[158]*/ mload(0x1800),\r\n                                       mulmod(/*coefficients[159]*/ mload(0x1820),\r\n                                              /*adjustments[16]*/mload(0x40c0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/add_points/x: column7_row47 * column7_row47 - ecdsa__signature0__exponentiate_key__bit_0 * (column7_row55 + column7_row7 + column7_row119).\r\n              let val := addmod(\r\n                mulmod(/*column7_row47*/ mload(0x2b60), /*column7_row47*/ mload(0x2b60), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x34a0),\r\n                    addmod(\r\n                      addmod(/*column7_row55*/ mload(0x2b80), /*column7_row7*/ mload(0x29c0), PRIME),\r\n                      /*column7_row119*/ mload(0x2c80),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x3e60), PRIME)\r\n              // Denominator: point^(trace_length / 64) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x3960), PRIME)\r\n\r\n              // res += val * (coefficients[160] + coefficients[161] * adjustments[16]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[160]*/ mload(0x1840),\r\n                                       mulmod(/*coefficients[161]*/ mload(0x1860),\r\n                                              /*adjustments[16]*/mload(0x40c0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/add_points/y: ecdsa__signature0__exponentiate_key__bit_0 * (column7_row15 + column7_row79) - column7_row47 * (column7_row55 - column7_row119).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x34a0),\r\n                  addmod(/*column7_row15*/ mload(0x2a80), /*column7_row79*/ mload(0x2c00), PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column7_row47*/ mload(0x2b60),\r\n                    addmod(\r\n                      /*column7_row55*/ mload(0x2b80),\r\n                      sub(PRIME, /*column7_row119*/ mload(0x2c80)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x3e60), PRIME)\r\n              // Denominator: point^(trace_length / 64) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x3960), PRIME)\r\n\r\n              // res += val * (coefficients[162] + coefficients[163] * adjustments[16]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[162]*/ mload(0x1880),\r\n                                       mulmod(/*coefficients[163]*/ mload(0x18a0),\r\n                                              /*adjustments[16]*/mload(0x40c0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/add_points/x_diff_inv: column7_row63 * (column7_row55 - column7_row7) - 1.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*column7_row63*/ mload(0x2ba0),\r\n                  addmod(/*column7_row55*/ mload(0x2b80), sub(PRIME, /*column7_row7*/ mload(0x29c0)), PRIME),\r\n                  PRIME),\r\n                sub(PRIME, 1),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x3e60), PRIME)\r\n              // Denominator: point^(trace_length / 64) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x3960), PRIME)\r\n\r\n              // res += val * (coefficients[164] + coefficients[165] * adjustments[16]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[164]*/ mload(0x18c0),\r\n                                       mulmod(/*coefficients[165]*/ mload(0x18e0),\r\n                                              /*adjustments[16]*/mload(0x40c0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/copy_point/x: ecdsa__signature0__exponentiate_key__bit_neg_0 * (column7_row119 - column7_row55).\r\n              let val := mulmod(\r\n                /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_neg_0*/ mload(0x34c0),\r\n                addmod(\r\n                  /*column7_row119*/ mload(0x2c80),\r\n                  sub(PRIME, /*column7_row55*/ mload(0x2b80)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x3e60), PRIME)\r\n              // Denominator: point^(trace_length / 64) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x3960), PRIME)\r\n\r\n              // res += val * (coefficients[166] + coefficients[167] * adjustments[16]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[166]*/ mload(0x1900),\r\n                                       mulmod(/*coefficients[167]*/ mload(0x1920),\r\n                                              /*adjustments[16]*/mload(0x40c0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/copy_point/y: ecdsa__signature0__exponentiate_key__bit_neg_0 * (column7_row79 - column7_row15).\r\n              let val := mulmod(\r\n                /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_neg_0*/ mload(0x34c0),\r\n                addmod(/*column7_row79*/ mload(0x2c00), sub(PRIME, /*column7_row15*/ mload(0x2a80)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x3e60), PRIME)\r\n              // Denominator: point^(trace_length / 64) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x3960), PRIME)\r\n\r\n              // res += val * (coefficients[168] + coefficients[169] * adjustments[16]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[168]*/ mload(0x1940),\r\n                                       mulmod(/*coefficients[169]*/ mload(0x1960),\r\n                                              /*adjustments[16]*/mload(0x40c0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/init_gen/x: column8_row0 - ecdsa/sig_config.shift_point.x.\r\n              let val := addmod(\r\n                /*column8_row0*/ mload(0x2e80),\r\n                sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[170] + coefficients[171] * adjustments[18]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[170]*/ mload(0x1980),\r\n                                       mulmod(/*coefficients[171]*/ mload(0x19a0),\r\n                                              /*adjustments[18]*/mload(0x4100),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/init_gen/y: column8_row64 + ecdsa/sig_config.shift_point.y.\r\n              let val := addmod(\r\n                /*column8_row64*/ mload(0x2ee0),\r\n                /*ecdsa/sig_config.shift_point.y*/ mload(0x300),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[172] + coefficients[173] * adjustments[18]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[172]*/ mload(0x19c0),\r\n                                       mulmod(/*coefficients[173]*/ mload(0x19e0),\r\n                                              /*adjustments[18]*/mload(0x4100),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/init_key/x: column7_row55 - ecdsa/sig_config.shift_point.x.\r\n              let val := addmod(\r\n                /*column7_row55*/ mload(0x2b80),\r\n                sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16384) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x3a40), PRIME)\r\n\r\n              // res += val * (coefficients[174] + coefficients[175] * adjustments[19]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[174]*/ mload(0x1a00),\r\n                                       mulmod(/*coefficients[175]*/ mload(0x1a20),\r\n                                              /*adjustments[19]*/mload(0x4120),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/init_key/y: column7_row15 - ecdsa/sig_config.shift_point.y.\r\n              let val := addmod(\r\n                /*column7_row15*/ mload(0x2a80),\r\n                sub(PRIME, /*ecdsa/sig_config.shift_point.y*/ mload(0x300)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16384) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x3a40), PRIME)\r\n\r\n              // res += val * (coefficients[176] + coefficients[177] * adjustments[19]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[176]*/ mload(0x1a40),\r\n                                       mulmod(/*coefficients[177]*/ mload(0x1a60),\r\n                                              /*adjustments[19]*/mload(0x4120),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/add_results/slope: column8_row32704 - (column7_row16335 + column8_row32656 * (column8_row32640 - column7_row16375)).\r\n              let val := addmod(\r\n                /*column8_row32704*/ mload(0x3000),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    /*column7_row16335*/ mload(0x2d20),\r\n                    mulmod(\r\n                      /*column8_row32656*/ mload(0x2fc0),\r\n                      addmod(\r\n                        /*column8_row32640*/ mload(0x2fa0),\r\n                        sub(PRIME, /*column7_row16375*/ mload(0x2d80)),\r\n                        PRIME),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[178] + coefficients[179] * adjustments[20]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[178]*/ mload(0x1a80),\r\n                                       mulmod(/*coefficients[179]*/ mload(0x1aa0),\r\n                                              /*adjustments[20]*/mload(0x4140),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/add_results/x: column8_row32656 * column8_row32656 - (column8_row32640 + column7_row16375 + column7_row16391).\r\n              let val := addmod(\r\n                mulmod(/*column8_row32656*/ mload(0x2fc0), /*column8_row32656*/ mload(0x2fc0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(/*column8_row32640*/ mload(0x2fa0), /*column7_row16375*/ mload(0x2d80), PRIME),\r\n                    /*column7_row16391*/ mload(0x2dc0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[180] + coefficients[181] * adjustments[20]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[180]*/ mload(0x1ac0),\r\n                                       mulmod(/*coefficients[181]*/ mload(0x1ae0),\r\n                                              /*adjustments[20]*/mload(0x4140),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/add_results/y: column8_row32704 + column7_row16423 - column8_row32656 * (column8_row32640 - column7_row16391).\r\n              let val := addmod(\r\n                addmod(/*column8_row32704*/ mload(0x3000), /*column7_row16423*/ mload(0x2de0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column8_row32656*/ mload(0x2fc0),\r\n                    addmod(\r\n                      /*column8_row32640*/ mload(0x2fa0),\r\n                      sub(PRIME, /*column7_row16391*/ mload(0x2dc0)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[182] + coefficients[183] * adjustments[20]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[182]*/ mload(0x1b00),\r\n                                       mulmod(/*coefficients[183]*/ mload(0x1b20),\r\n                                              /*adjustments[20]*/mload(0x4140),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/add_results/x_diff_inv: column8_row32672 * (column8_row32640 - column7_row16375) - 1.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*column8_row32672*/ mload(0x2fe0),\r\n                  addmod(\r\n                    /*column8_row32640*/ mload(0x2fa0),\r\n                    sub(PRIME, /*column7_row16375*/ mload(0x2d80)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(PRIME, 1),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[184] + coefficients[185] * adjustments[20]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[184]*/ mload(0x1b40),\r\n                                       mulmod(/*coefficients[185]*/ mload(0x1b60),\r\n                                              /*adjustments[20]*/mload(0x4140),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/extract_r/slope: column7_row32719 + ecdsa/sig_config.shift_point.y - column7_row16367 * (column7_row32759 - ecdsa/sig_config.shift_point.x).\r\n              let val := addmod(\r\n                addmod(\r\n                  /*column7_row32719*/ mload(0x2e00),\r\n                  /*ecdsa/sig_config.shift_point.y*/ mload(0x300),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column7_row16367*/ mload(0x2d60),\r\n                    addmod(\r\n                      /*column7_row32759*/ mload(0x2e60),\r\n                      sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[186] + coefficients[187] * adjustments[20]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[186]*/ mload(0x1b80),\r\n                                       mulmod(/*coefficients[187]*/ mload(0x1ba0),\r\n                                              /*adjustments[20]*/mload(0x4140),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/extract_r/x: column7_row16367 * column7_row16367 - (column7_row32759 + ecdsa/sig_config.shift_point.x + column7_row31).\r\n              let val := addmod(\r\n                mulmod(/*column7_row16367*/ mload(0x2d60), /*column7_row16367*/ mload(0x2d60), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      /*column7_row32759*/ mload(0x2e60),\r\n                      /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0),\r\n                      PRIME),\r\n                    /*column7_row31*/ mload(0x2b00),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[188] + coefficients[189] * adjustments[20]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[188]*/ mload(0x1bc0),\r\n                                       mulmod(/*coefficients[189]*/ mload(0x1be0),\r\n                                              /*adjustments[20]*/mload(0x4140),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/extract_r/x_diff_inv: column7_row32751 * (column7_row32759 - ecdsa/sig_config.shift_point.x) - 1.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*column7_row32751*/ mload(0x2e40),\r\n                  addmod(\r\n                    /*column7_row32759*/ mload(0x2e60),\r\n                    sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(PRIME, 1),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[190] + coefficients[191] * adjustments[20]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[190]*/ mload(0x1c00),\r\n                                       mulmod(/*coefficients[191]*/ mload(0x1c20),\r\n                                              /*adjustments[20]*/mload(0x4140),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/z_nonzero: column8_row96 * column7_row16343 - 1.\r\n              let val := addmod(\r\n                mulmod(/*column8_row96*/ mload(0x2f20), /*column7_row16343*/ mload(0x2d40), PRIME),\r\n                sub(PRIME, 1),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[192] + coefficients[193] * adjustments[20]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[192]*/ mload(0x1c40),\r\n                                       mulmod(/*coefficients[193]*/ mload(0x1c60),\r\n                                              /*adjustments[20]*/mload(0x4140),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/r_and_w_nonzero: column7_row31 * column7_row16383 - 1.\r\n              let val := addmod(\r\n                mulmod(/*column7_row31*/ mload(0x2b00), /*column7_row16383*/ mload(0x2da0), PRIME),\r\n                sub(PRIME, 1),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16384) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x3a40), PRIME)\r\n\r\n              // res += val * (coefficients[194] + coefficients[195] * adjustments[21]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[194]*/ mload(0x1c80),\r\n                                       mulmod(/*coefficients[195]*/ mload(0x1ca0),\r\n                                              /*adjustments[21]*/mload(0x4160),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/q_on_curve/x_squared: column7_row32727 - column7_row7 * column7_row7.\r\n              let val := addmod(\r\n                /*column7_row32727*/ mload(0x2e20),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(/*column7_row7*/ mload(0x29c0), /*column7_row7*/ mload(0x29c0), PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[196] + coefficients[197] * adjustments[20]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[196]*/ mload(0x1cc0),\r\n                                       mulmod(/*coefficients[197]*/ mload(0x1ce0),\r\n                                              /*adjustments[20]*/mload(0x4140),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/q_on_curve/on_curve: column7_row39 * column7_row39 - (column7_row7 * column7_row32727 + ecdsa/sig_config.alpha * column7_row7 + ecdsa/sig_config.beta).\r\n              let val := addmod(\r\n                mulmod(/*column7_row39*/ mload(0x2b20), /*column7_row39*/ mload(0x2b20), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      mulmod(/*column7_row7*/ mload(0x29c0), /*column7_row32727*/ mload(0x2e20), PRIME),\r\n                      mulmod(/*ecdsa/sig_config.alpha*/ mload(0x2c0), /*column7_row7*/ mload(0x29c0), PRIME),\r\n                      PRIME),\r\n                    /*ecdsa/sig_config.beta*/ mload(0x320),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[198] + coefficients[199] * adjustments[20]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[198]*/ mload(0x1d00),\r\n                                       mulmod(/*coefficients[199]*/ mload(0x1d20),\r\n                                              /*adjustments[20]*/mload(0x4140),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/init_addr: column5_row390 - initial_ecdsa_addr.\r\n              let val := addmod(\r\n                /*column5_row390*/ mload(0x2780),\r\n                sub(PRIME, /*initial_ecdsa_addr*/ mload(0x340)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x3800), PRIME)\r\n\r\n              // res += val * (coefficients[200] + coefficients[201] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[200]*/ mload(0x1d40),\r\n                                       mulmod(/*coefficients[201]*/ mload(0x1d60),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/message_addr: column5_row16774 - (column5_row390 + 1).\r\n              let val := addmod(\r\n                /*column5_row16774*/ mload(0x2800),\r\n                sub(PRIME, addmod(/*column5_row390*/ mload(0x2780), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[202] + coefficients[203] * adjustments[18]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[202]*/ mload(0x1d80),\r\n                                       mulmod(/*coefficients[203]*/ mload(0x1da0),\r\n                                              /*adjustments[18]*/mload(0x4100),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/pubkey_addr: column5_row33158 - (column5_row16774 + 1).\r\n              let val := addmod(\r\n                /*column5_row33158*/ mload(0x2840),\r\n                sub(PRIME, addmod(/*column5_row16774*/ mload(0x2800), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(32768 * (trace_length / 32768 - 1)).\r\n              // val *= numerators[10].\r\n              val := mulmod(val, mload(0x3ea0), PRIME)\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[204] + coefficients[205] * adjustments[22]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[204]*/ mload(0x1dc0),\r\n                                       mulmod(/*coefficients[205]*/ mload(0x1de0),\r\n                                              /*adjustments[22]*/mload(0x4180),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/message_value0: column5_row16775 - column8_row96.\r\n              let val := addmod(\r\n                /*column5_row16775*/ mload(0x2820),\r\n                sub(PRIME, /*column8_row96*/ mload(0x2f20)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[206] + coefficients[207] * adjustments[18]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[206]*/ mload(0x1e00),\r\n                                       mulmod(/*coefficients[207]*/ mload(0x1e20),\r\n                                              /*adjustments[18]*/mload(0x4100),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/pubkey_value0: column5_row391 - column7_row7.\r\n              let val := addmod(/*column5_row391*/ mload(0x27a0), sub(PRIME, /*column7_row7*/ mload(0x29c0)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 32768) - 1.\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x3a20), PRIME)\r\n\r\n              // res += val * (coefficients[208] + coefficients[209] * adjustments[18]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[208]*/ mload(0x1e40),\r\n                                       mulmod(/*coefficients[209]*/ mload(0x1e60),\r\n                                              /*adjustments[18]*/mload(0x4100),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for checkpoints/req_pc_init_addr: column5_row198 - initial_checkpoints_addr.\r\n              let val := addmod(\r\n                /*column5_row198*/ mload(0x26e0),\r\n                sub(PRIME, /*initial_checkpoints_addr*/ mload(0x360)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x3800), PRIME)\r\n\r\n              // res += val * (coefficients[210] + coefficients[211] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[210]*/ mload(0x1e80),\r\n                                       mulmod(/*coefficients[211]*/ mload(0x1ea0),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for checkpoints/req_pc_final_addr: column5_row198 - final_checkpoints_addr.\r\n              let val := addmod(\r\n                /*column5_row198*/ mload(0x26e0),\r\n                sub(PRIME, /*final_checkpoints_addr*/ mload(0x380)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(256 * (trace_length / 256 - 1)).\r\n              // val *= denominator_invs[22].\r\n              val := mulmod(val, mload(0x3a60), PRIME)\r\n\r\n              // res += val * (coefficients[212] + coefficients[213] * adjustments[4]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[212]*/ mload(0x1ec0),\r\n                                       mulmod(/*coefficients[213]*/ mload(0x1ee0),\r\n                                              /*adjustments[4]*/mload(0x3f40),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for checkpoints/required_fp_addr: column5_row38 - (column5_row198 + 1).\r\n              let val := addmod(\r\n                /*column5_row38*/ mload(0x2620),\r\n                sub(PRIME, addmod(/*column5_row198*/ mload(0x26e0), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[214] + coefficients[215] * adjustments[11]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[214]*/ mload(0x1f00),\r\n                                       mulmod(/*coefficients[215]*/ mload(0x1f20),\r\n                                              /*adjustments[11]*/mload(0x4020),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for checkpoints/required_pc_next_addr: (column5_row454 - column5_row198) * (column5_row454 - (column5_row198 + 2)).\r\n              let val := mulmod(\r\n                addmod(\r\n                  /*column5_row454*/ mload(0x27c0),\r\n                  sub(PRIME, /*column5_row198*/ mload(0x26e0)),\r\n                  PRIME),\r\n                addmod(\r\n                  /*column5_row454*/ mload(0x27c0),\r\n                  sub(PRIME, addmod(/*column5_row198*/ mload(0x26e0), 2, PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(256 * (trace_length / 256 - 1)).\r\n              // val *= numerators[7].\r\n              val := mulmod(val, mload(0x3e40), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[216] + coefficients[217] * adjustments[23]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[216]*/ mload(0x1f40),\r\n                                       mulmod(/*coefficients[217]*/ mload(0x1f60),\r\n                                              /*adjustments[23]*/mload(0x41a0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for checkpoints/req_pc: (column5_row454 - column5_row198) * (column5_row199 - column5_row0).\r\n              let val := mulmod(\r\n                addmod(\r\n                  /*column5_row454*/ mload(0x27c0),\r\n                  sub(PRIME, /*column5_row198*/ mload(0x26e0)),\r\n                  PRIME),\r\n                addmod(/*column5_row199*/ mload(0x2700), sub(PRIME, /*column5_row0*/ mload(0x2480)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(256 * (trace_length / 256 - 1)).\r\n              // val *= numerators[7].\r\n              val := mulmod(val, mload(0x3e40), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[218] + coefficients[219] * adjustments[23]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[218]*/ mload(0x1f80),\r\n                                       mulmod(/*coefficients[219]*/ mload(0x1fa0),\r\n                                              /*adjustments[23]*/mload(0x41a0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for checkpoints/req_fp: (column5_row454 - column5_row198) * (column5_row39 - column7_row9).\r\n              let val := mulmod(\r\n                addmod(\r\n                  /*column5_row454*/ mload(0x27c0),\r\n                  sub(PRIME, /*column5_row198*/ mload(0x26e0)),\r\n                  PRIME),\r\n                addmod(/*column5_row39*/ mload(0x2640), sub(PRIME, /*column7_row9*/ mload(0x2a00)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(256 * (trace_length / 256 - 1)).\r\n              // val *= numerators[7].\r\n              val := mulmod(val, mload(0x3e40), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x38e0), PRIME)\r\n\r\n              // res += val * (coefficients[220] + coefficients[221] * adjustments[23]).\r\n              res := addmod(res,\r\n                            mulmod(val,\r\n                                   add(/*coefficients[220]*/ mload(0x1fc0),\r\n                                       mulmod(/*coefficients[221]*/ mload(0x1fe0),\r\n                                              /*adjustments[23]*/mload(0x41a0),\r\n                      PRIME)),\r\n                      PRIME),\r\n                      PRIME)\r\n              }\r\n\r\n            mstore(0, res)\r\n            return(0, 0x20)\r\n            }\r\n        }\r\n    }\r\n}\r\n// ---------- End of auto-generated code. ----------"}}}