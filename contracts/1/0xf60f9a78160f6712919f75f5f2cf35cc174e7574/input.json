{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "LiquidityTransformer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface IReferral {\r\n    function setReferrer(address farmer, address referrer) external;\r\n    function getReferrer(address farmer) external view returns (address);\r\n    function isValidReferrer(address referrer) external view returns (bool);\r\n    function rndSeed(uint256 rnd) external view returns (address, bool);\r\n}\r\n\r\ncontract LiquidityTransformer {\r\n    uint256 public constant SECONDS_PER_DAY = 1 days;\r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n\r\n    uint256 public constant TOTAL_RESERVE_DAYS = 50;\r\n    uint256 public constant RESERVE_ETH_UNIT = 100 finney;\r\n\r\n    struct DailyState {\r\n        mapping(address => uint256) userAmount;\r\n        mapping(address => uint256) referrerAmount;\r\n        uint256 totalAmount;\r\n        uint256 userCount;\r\n    }\r\n\r\n    struct DailyConfig{\r\n        uint256 twap;\r\n        uint256 dt;\r\n    }\r\n\r\n    DailyState[TOTAL_RESERVE_DAYS] public reserveDays;\r\n    DailyConfig[TOTAL_RESERVE_DAYS] public configDays;\r\n\r\n    uint256 public totalScrap;\r\n    uint256 public launchTime;\r\n\r\n    IReferral public iReferral;\r\n    mapping(address => bool) private operator;\r\n\r\n    event Reserved(uint256 indexed day, address indexed user, address indexed referer, uint256 amount);\r\n    event Recovered(address indexed token, uint256 amount);\r\n    event Launched(uint256 time);\r\n\r\n    constructor() public {\r\n        operator[msg.sender] = true;\r\n\r\n        for (uint256 i=0; i<TOTAL_RESERVE_DAYS; i++) {\r\n            reserveDays[i] = DailyState(0,0);\r\n            configDays[i] = DailyConfig(0,0);\r\n        }\r\n    }\r\n\r\n    modifier onlyOperator{\r\n        require(operator[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function _condition(uint256 _lteDay, uint256 _lteAmount) internal view returns (bool) {\r\n        require(msg.value >= _lteAmount, 'DAO: the actual amount below LTE Amount');\r\n        require(msg.value >= RESERVE_ETH_UNIT, 'DAO: LTE Amount below minimum');\r\n\r\n        require(_lteDay < TOTAL_RESERVE_DAYS, 'DAO: incorrect LTE day');\r\n        DailyConfig memory cfg = configDays[_lteDay];\r\n        require(cfg.twap == 0, 'DAO: closed');\r\n\r\n        return true;\r\n    }\r\n\r\n    function firstReserveRand(uint256 _lteAmount, uint256 rand) external payable {\r\n        require(!iReferral.isValidReferrer(msg.sender), 'DAO: not first');\r\n        require(_condition(currentDay(), _lteAmount));\r\n\r\n        (address _referrerAddress, ) = iReferral.rndSeed(rand);\r\n        iReferral.setReferrer(msg.sender, _referrerAddress);\r\n\r\n        // use the current day as the LTE day for the first reserve\r\n        _reserve(currentDay(), msg.sender);\r\n    }\r\n\r\n    function firstReserve(uint256 _lteAmount, address _referrerAddress) external payable {\r\n        require(!iReferral.isValidReferrer(msg.sender), 'DAO: not first');\r\n        require(_condition(currentDay(), _lteAmount));\r\n\r\n        iReferral.setReferrer(msg.sender, _referrerAddress);\r\n\r\n        // use the current day as the LTE day for the first reserve\r\n        _reserve(currentDay(), msg.sender);\r\n    }\r\n\r\n    function reserve(uint256 _lteDay, uint256 _lteAmount) external payable {\r\n        require(iReferral.isValidReferrer(msg.sender), 'DAO: the caller should be a referer');\r\n        require(_condition(_lteDay, _lteAmount));\r\n\r\n        _reserve(_lteDay, msg.sender);\r\n    }\r\n\r\n    function reserveFor(uint256 _lteDay, uint256 _lteAmount, address _beneficiaryAddress) external payable {\r\n        require(iReferral.isValidReferrer(msg.sender), 'DAO: the caller should be a referer');\r\n        require(_condition(_lteDay, _lteAmount));\r\n\r\n        require(_beneficiaryAddress != address(0), 'DAO: cannot be 0');\r\n        if (!iReferral.isValidReferrer(_beneficiaryAddress)) {\r\n            iReferral.setReferrer(_beneficiaryAddress, msg.sender);\r\n        }\r\n\r\n        _reserve(_lteDay, _beneficiaryAddress);\r\n    }\r\n\r\n    function _reserve(uint256 _lteDay, address _userAddress) internal {\r\n        uint256 _scrap = msg.value % RESERVE_ETH_UNIT;\r\n        uint256 _availableAmount = msg.value - _scrap;\r\n        totalScrap += _scrap;\r\n\r\n        address _referrerAddress = iReferral.getReferrer(_userAddress);\r\n\r\n        DailyState storage day = reserveDays[_lteDay];\r\n\r\n        if (day.userAmount[_userAddress] == 0) {\r\n            day.userCount++;\r\n        }\r\n\r\n        day.userAmount[_userAddress] += _availableAmount;\r\n        day.referrerAmount[_referrerAddress] += _availableAmount;\r\n        day.totalAmount += _availableAmount;\r\n\r\n        emit Reserved(_lteDay, _userAddress, _referrerAddress, _availableAmount);\r\n    }\r\n\r\n    function userAmount(address account, uint256 day) external view returns (uint256) {\r\n        return reserveDays[day].userAmount[account];\r\n    }\r\n\r\n    function referrerAmount(address account, uint256 day) external view returns (uint256) {\r\n        return reserveDays[day].referrerAmount[account];\r\n    }\r\n\r\n    function userTotalAmount(address account) external view returns (uint256) {\r\n        uint256 _totalAmount = 0;\r\n        for(uint256 i=0; i<TOTAL_RESERVE_DAYS; i++){\r\n            _totalAmount += reserveDays[i].userAmount[account];\r\n        }\r\n        return _totalAmount;\r\n    }\r\n\r\n    function referrerTotalAmount(address account) external view returns (uint256) {\r\n        uint256 _totalAmount = 0;\r\n        for(uint256 i=0; i<TOTAL_RESERVE_DAYS; i++){\r\n            _totalAmount += reserveDays[i].referrerAmount[account];\r\n        }\r\n        return _totalAmount;\r\n    }\r\n\r\n    function currentDay() public view returns (uint256) {\r\n        return now >= launchTime ? (now - launchTime) / SECONDS_PER_DAY : 0;\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\r\n    }\r\n\r\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOperator {\r\n        _safeTransfer(tokenAddress, msg.sender, tokenAmount);\r\n        emit Recovered(tokenAddress, tokenAmount);\r\n    }\r\n\r\n    function withdrawLTE(uint256 amount) external onlyOperator {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function launch(uint256 time) external onlyOperator {\r\n        require(launchTime == 0);\r\n        require(time >= now);\r\n        launchTime = time;\r\n\r\n        emit Launched(launchTime);\r\n    }\r\n\r\n    function update(uint256[TOTAL_RESERVE_DAYS] calldata dts) external onlyOperator {\r\n        for (uint256 i=0; i<TOTAL_RESERVE_DAYS; i++) {\r\n            configDays[i].dt = dts[i];\r\n        }\r\n    }\r\n\r\n    function twapOracle(uint256 day, uint256 twap) external onlyOperator {\r\n        require(day < TOTAL_RESERVE_DAYS);\r\n        DailyConfig storage cfg = configDays[day];\r\n        cfg.twap = twap;\r\n    }\r\n\r\n    function setReferral(address _iReferral) external onlyOperator {\r\n        require(_iReferral != address(0));\r\n        iReferral = IReferral(_iReferral);\r\n    }\r\n\r\n    function setOperator(address payable op, bool flag) external onlyOperator {\r\n        require(op != address(0));\r\n        require(op != msg.sender, '!self');\r\n        operator[op] = flag;\r\n    }\r\n}"
    }
  }
}