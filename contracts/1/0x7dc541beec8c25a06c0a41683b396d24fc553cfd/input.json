{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IBridge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\npragma experimental ABIEncoderV2;\n\n\ninterface IBridge {\n    struct TONEvent {\n        uint64 eventTransactionLt;\n        uint32 eventTimestamp;\n        bytes eventData;\n        int8 configurationWid;\n        uint256 configurationAddress;\n        int8 eventContractWid;\n        uint256 eventContractAddress;\n        address proxy;\n        uint32 round;\n    }\n\n    struct Round {\n        uint32 end;\n        uint32 ttl;\n        uint32 relays;\n        uint32 requiredSignatures;\n    }\n\n    struct TONAddress {\n        int8 wid;\n        uint256 addr;\n    }\n\n    function updateMinimumRequiredSignatures(uint32 _minimumRequiredSignatures) external;\n    function updateRoundRelaysConfiguration(TONAddress calldata _roundRelaysConfiguration) external;\n    function updateRoundTTL(uint32 _roundTTL) external;\n\n    function isRelay(\n        uint32 round,\n        address candidate\n    ) external view returns(bool);\n\n    function isBanned(\n        address candidate\n    ) external view returns(bool);\n\n    function isRoundRotten(\n        uint32 round\n    ) external view returns(bool);\n\n    function verifySignedTonEvent(\n        bytes memory payload,\n        bytes[] memory signatures\n    ) external view returns(uint32);\n\n    function setRoundRelays(\n        bytes calldata payload,\n        bytes[] calldata signatures\n    ) external;\n\n    function forceRoundRelays(\n        uint160[] calldata _relays,\n        uint32 roundEnd\n    ) external;\n\n    function banRelays(\n        address[] calldata _relays\n    ) external;\n\n    function unbanRelays(\n        address[] calldata _relays\n    ) external;\n\n    function pause() external;\n    function unpause() external;\n\n    function setRoundSubmitter(address _roundSubmitter) external;\n\n    event EmergencyShutdown(bool active);\n\n    event UpdateMinimumRequiredSignatures(uint32 value);\n    event UpdateRoundTTL(uint32 value);\n    event UpdateRoundRelaysConfiguration(TONAddress configuration);\n    event UpdateRoundSubmitter(address _roundSubmitter);\n\n    event NewRound(uint32 indexed round, Round meta);\n    event RoundRelay(uint32 indexed round, address indexed relay);\n    event BanRelay(address indexed relay, bool status);\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\n\ninterface IVault {\n    struct TONAddress {\n        int128 wid;\n        uint256 addr;\n    }\n\n    struct StrategyParams {\n        uint256 performanceFee;\n        uint256 activation;\n        uint256 debtRatio;\n        uint256 minDebtPerHarvest;\n        uint256 maxDebtPerHarvest;\n        uint256 lastReport;\n        uint256 totalDebt;\n        uint256 totalGain;\n        uint256 totalSkim;\n        uint256 totalLoss;\n        address rewardsManager;\n        TONAddress rewards;\n    }\n\n\n    struct PendingWithdrawalId {\n        address recipient;\n        uint256 id;\n    }\n\n    function saveWithdraw(\n        bytes32 payloadId,\n        address recipient,\n        uint256 amount,\n        uint256 bounty\n    ) external;\n\n    function deposit(\n        address sender,\n        TONAddress calldata recipient,\n        uint256 _amount,\n        PendingWithdrawalId calldata pendingWithdrawalId,\n        bool sendTransferToTon\n    ) external;\n\n    function forceWithdraw(\n        address recipient,\n        uint256 id\n    ) external;\n\n    function configuration() external view returns(TONAddress memory _configuration);\n    function bridge() external view returns(address);\n    function apiVersion() external view returns(string memory api_version);\n\n    function initialize(\n        address _token,\n        address _governance,\n        address _bridge,\n        address _wrapper,\n        address guardian,\n        address management,\n        uint256 _targetDecimals\n    ) external;\n\n    function debtOutstanding() external view returns (uint256);\n    function creditAvailable() external view returns (uint256);\n    function report(uint256 profit, uint256 loss, uint256 debtPayment) external returns (uint256);\n    function revokeStrategy() external;\n\n    function strategies(address strategy) external view returns (StrategyParams memory);\n\n    function governance() external view returns(address);\n    function token() external view returns(address);\n    function guardian() external view returns(address);\n    function management() external view returns(address);\n    function wrapper() external view returns(address);\n\n    function tokenDecimals() external view returns(uint256);\n    function targetDecimals() external view returns(uint256);\n}\n"
    },
    "contracts/interfaces/IVaultWrapper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\n\ninterface IVaultWrapper {\n    function initialize(address _vault) external;\n    function apiVersion() external view returns(string memory);\n}\n"
    },
    "contracts/utils/ChainId.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\n\ncontract ChainId {\n    function getChainID() public view returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n}\n"
    },
    "contracts/vault/VaultWrapper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"./../interfaces/IBridge.sol\";\nimport \"./../interfaces/IVault.sol\";\nimport \"./../interfaces/IVaultWrapper.sol\";\nimport \"./../utils/ChainId.sol\";\n\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n\ncontract VaultWrapper is ChainId, Initializable, IVaultWrapper {\n    address constant ZERO_ADDRESS = 0x0000000000000000000000000000000000000000;\n    string constant API_VERSION = \"0.1.2\";\n\n    address public vault;\n\n    function initialize(\n        address _vault\n    ) external override initializer {\n        vault = _vault;\n    }\n\n    function apiVersion()\n        external\n        override\n        pure\n    returns (\n        string memory api_version\n    ) {\n        return API_VERSION;\n    }\n\n    /**\n        @notice\n            Most common entry point for Broxus Bridge.this\n            Simply transfers tokens to the FreeTON side.\n        @param recipient Recipient TON address\n        @param amount Amount of tokens to be deposited\n    */\n    function deposit(\n        IVault.TONAddress memory recipient,\n        uint256 amount\n    ) external {\n        IVault.PendingWithdrawalId memory pendingWithdrawalId = IVault.PendingWithdrawalId(ZERO_ADDRESS, 0);\n\n        IVault(vault).deposit(\n            msg.sender,\n            recipient,\n            amount,\n            pendingWithdrawalId,\n            true\n        );\n    }\n\n    event FactoryDeposit(\n        uint128 amount,\n        int8 wid,\n        uint256 user,\n        uint256 creditor,\n        uint256 recipient,\n        uint128 tokenAmount,\n        uint128 tonAmount,\n        uint8 swapType,\n        uint128 slippageNumerator,\n        uint128 slippageDenominator,\n        bytes1 separator,\n        bytes level3\n    );\n\n    function _convertToTargetDecimals(uint128 amount) internal view returns(uint128) {\n        uint256 targetDecimals = IVault(vault).targetDecimals();\n        uint256 tokenDecimals = IVault(vault).tokenDecimals();\n\n        if (targetDecimals == tokenDecimals) {\n            return amount;\n        } else if (targetDecimals > tokenDecimals) {\n            return uint128(amount * 10 ** (targetDecimals - tokenDecimals));\n        } else {\n            return uint128(amount / 10 ** (tokenDecimals - targetDecimals));\n        }\n    }\n\n    function depositToFactory(\n        uint128 amount,\n        int8 wid,\n        uint256 user,\n        uint256 creditor,\n        uint256 recipient,\n        uint128 tokenAmount,\n        uint128 tonAmount,\n        uint8 swapType,\n        uint128 slippageNumerator,\n        uint128 slippageDenominator,\n        bytes memory level3\n    ) external {\n        require(\n            tokenAmount <= amount &&\n            swapType < 2 &&\n            user != 0 &&\n            recipient != 0 &&\n            creditor != 0 &&\n            slippageNumerator < slippageDenominator,\n            \"Wrapper: wrong args\"\n        );\n\n        IVault(vault).deposit(\n            msg.sender,\n            IVault.TONAddress(0, 0),\n            amount,\n            IVault.PendingWithdrawalId(ZERO_ADDRESS, 0),\n            false\n        );\n\n        emit FactoryDeposit(\n            _convertToTargetDecimals(amount),\n            wid,\n            user,\n            creditor,\n            recipient,\n            tokenAmount,\n            tonAmount,\n            swapType,\n            slippageNumerator,\n            slippageDenominator,\n            0x07,\n            level3\n        );\n    }\n\n    /**\n        @notice\n            Special type of deposit, which allows to fill specified\n            pending withdrawals. Set of fillings should be created off-chain.\n            Usually allows depositor to receive additional reward (bounty) on the FreeTON side.\n        @param recipient Recipient TON address\n        @param amount Amount of tokens to be deposited, should be gte than sum(fillings)\n        @param pendingWithdrawalsIdsToFill List of pending withdrawals ids\n    */\n    function depositWithFillings(\n        IVault.TONAddress calldata recipient,\n        uint256 amount,\n        IVault.PendingWithdrawalId[] calldata pendingWithdrawalsIdsToFill\n    ) external {\n        require(\n            pendingWithdrawalsIdsToFill.length > 0,\n            'Wrapper: no pending withdrawals specified'\n        );\n\n        for (uint i = 0; i < pendingWithdrawalsIdsToFill.length; i++) {\n            IVault(vault).deposit(\n                msg.sender,\n                recipient,\n                amount,\n                pendingWithdrawalsIdsToFill[i],\n                true\n            );\n        }\n    }\n\n    /**\n        @notice\n            Force withdraw multiple pending withdrawals. Does not close strategy positions.\n            Works only in case Vault has enough tokens to close all the pending withdrawals.\n        @param pendingWithdrawalsIdsToWithdraw List of pending withdrawals ids\n    */\n    function forceWithdraw(\n        IVault.PendingWithdrawalId[] calldata pendingWithdrawalsIdsToWithdraw\n    ) external {\n        require(\n            pendingWithdrawalsIdsToWithdraw.length > 0,\n            'Wrapper: no pending withdrawals specified'\n        );\n\n        for (uint i = 0; i < pendingWithdrawalsIdsToWithdraw.length; i++) {\n            IVault(vault).forceWithdraw(\n                pendingWithdrawalsIdsToWithdraw[i].recipient,\n                pendingWithdrawalsIdsToWithdraw[i].id\n            );\n        }\n    }\n\n    function decodeWithdrawEventData(\n        bytes memory payload\n    ) public pure returns (\n        int8 sender_wid,\n        uint256 sender_addr,\n        uint128 amount,\n        uint160 _recipient,\n        uint32 chainId\n    ) {\n        (IBridge.TONEvent memory tonEvent) = abi.decode(payload, (IBridge.TONEvent));\n\n        return abi.decode(\n            tonEvent.eventData,\n            (int8, uint256, uint128, uint160, uint32)\n        );\n    }\n\n    /**\n        @notice Entry point for withdrawing tokens from the Broxus Bridge.\n        Expects payload with withdraw details and list of relay's signatures.\n        @param payload Bytes encoded `IBridge.TONEvent` structure\n        @param signatures Set of relay's signatures\n        @param bounty Pending withdraw bounty, can be set only by withdraw recipient. Ignores otherwise.\n    */\n    function saveWithdraw(\n        bytes calldata payload,\n        bytes[] calldata signatures,\n        uint256 bounty\n    ) external {\n        address bridge = IVault(vault).bridge();\n\n        // Check signatures correct\n        require(\n            IBridge(bridge).verifySignedTonEvent(\n                payload,\n                signatures\n            ) == 0,\n            \"Vault wrapper: signatures verification failed\"\n        );\n\n        // Decode TON event\n        (IBridge.TONEvent memory tonEvent) = abi.decode(payload, (IBridge.TONEvent));\n\n        // dev: fix stack too deep\n        {\n            // Check event configuration matches Vault's configuration\n            IVault.TONAddress memory configuration = IVault(vault).configuration();\n\n            require(\n                tonEvent.configurationWid == configuration.wid &&\n                tonEvent.configurationAddress == configuration.addr,\n                \"Vault wrapper: wrong event configuration\"\n            );\n        }\n\n        // Decode event data\n        (\n            int8 sender_wid,\n            uint256 sender_addr,\n            uint128 amount,\n            uint160 _recipient,\n            uint32 chainId\n        ) = decodeWithdrawEventData(payload);\n\n        // Check chain id\n        require(chainId == getChainID(), \"Vault wrapper: wrong chain id\");\n\n        address recipient = address(_recipient);\n\n        IVault(vault).saveWithdraw(\n            keccak256(payload),\n            recipient,\n            amount,\n            recipient == msg.sender ? bounty : 0\n        );\n    }\n}\n"
    }
  }
}