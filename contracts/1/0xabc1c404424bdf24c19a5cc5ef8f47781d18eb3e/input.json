{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"EtheremonData.sol":{"content":"pragma solidity ^0.4.16;\r\n\r\n// copyright contact@Etheremon.com\r\n\r\ncontract SafeMath {\r\n\r\n    /* function assert(bool assertion) internal { */\r\n    /*   if (!assertion) { */\r\n    /*     throw; */\r\n    /*   } */\r\n    /* }      // assert no longer needed once solidity is on 0.4.10 */\r\n\r\n    function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }\r\n\r\n}\r\n\r\ncontract BasicAccessControl {\r\n    address public owner;\r\n    address[] public moderators;\r\n\r\n    function BasicAccessControl() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyModerators() {\r\n        if (msg.sender != owner) {\r\n            bool found = false;\r\n            for (uint index = 0; index < moderators.length; index++) {\r\n                if (moderators[index] == msg.sender) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            require(found);\r\n        }\r\n        _;\r\n    }\r\n\r\n    function ChangeOwner(address _newOwner) onlyOwner public {\r\n        if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }\r\n    }\r\n\r\n    function Kill() onlyOwner public {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function AddModerator(address _newModerator) onlyOwner public {\r\n        if (_newModerator != address(0)) {\r\n            for (uint index = 0; index < moderators.length; index++) {\r\n                if (moderators[index] == _newModerator) {\r\n                    return;\r\n                }\r\n            }\r\n            moderators.push(_newModerator);\r\n        }\r\n    }\r\n    \r\n    function RemoveModerator(address _oldModerator) onlyOwner public {\r\n        uint foundIndex = 0;\r\n        for (; foundIndex < moderators.length; foundIndex++) {\r\n            if (moderators[foundIndex] == _oldModerator) {\r\n                break;\r\n            }\r\n        }\r\n        if (foundIndex < moderators.length) {\r\n            moderators[foundIndex] = moderators[moderators.length-1];\r\n            delete moderators[moderators.length-1];\r\n            moderators.length--;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract EtheremonEnum {\r\n\r\n    enum ResultCode {\r\n        SUCCESS,\r\n        ERROR_CLASS_NOT_FOUND,\r\n        ERROR_LOW_BALANCE,\r\n        ERROR_SEND_FAIL,\r\n        ERROR_NOT_TRAINER,\r\n        ERROR_NOT_ENOUGH_MONEY,\r\n        ERROR_INVALID_AMOUNT\r\n    }\r\n    \r\n    enum ArrayType {\r\n        CLASS_TYPE,\r\n        STAT_STEP,\r\n        STAT_START,\r\n        STAT_BASE,\r\n        OBJ_SKILL\r\n    }\r\n}\r\n\r\ncontract EtheremonDataBase is EtheremonEnum, BasicAccessControl, SafeMath {\r\n    \r\n    uint64 public totalMonster;\r\n    uint32 public totalClass;\r\n    \r\n    // write\r\n    function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint);\r\n    function updateIndexOfArrayType(ArrayType _type, uint64 _id, uint _index, uint8 _value) onlyModerators public returns(uint);\r\n    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) onlyModerators public returns(uint32);\r\n    function addMonsterObj(uint32 _classId, address _trainer, string _name) onlyModerators public returns(uint64);\r\n    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) onlyModerators public;\r\n    function increaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;\r\n    function decreaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public;\r\n    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;\r\n    function addMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public;\r\n    function clearMonsterReturnBalance(uint64 _monsterId) onlyModerators public returns(uint256 amount);\r\n    function collectAllReturnBalance(address _trainer) onlyModerators public returns(uint256 amount);\r\n    function transferMonster(address _from, address _to, uint64 _monsterId) onlyModerators public returns(ResultCode);\r\n    function addExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);\r\n    function deductExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256);\r\n    function setExtraBalance(address _trainer, uint256 _amount) onlyModerators public;\r\n    \r\n    // read\r\n    function getSizeArrayType(ArrayType _type, uint64 _id) constant public returns(uint);\r\n    function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8);\r\n    function getMonsterClass(uint32 _classId) constant public returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable);\r\n    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);\r\n    function getMonsterName(uint64 _objId) constant public returns(string name);\r\n    function getExtraBalance(address _trainer) constant public returns(uint256);\r\n    function getMonsterDexSize(address _trainer) constant public returns(uint);\r\n    function getMonsterObjId(address _trainer, uint index) constant public returns(uint64);\r\n    function getExpectedBalance(address _trainer) constant public returns(uint256);\r\n    function getMonsterReturn(uint64 _objId) constant public returns(uint256 current, uint256 total);\r\n}\r\n\r\ncontract EtheremonData is EtheremonDataBase {\r\n\r\n    struct MonsterClass {\r\n        uint32 classId;\r\n        uint8[] types;\r\n        uint8[] statSteps;\r\n        uint8[] statStarts;\r\n        uint256 price;\r\n        uint256 returnPrice;\r\n        uint32 total;\r\n        bool catchable;\r\n    }\r\n    \r\n    struct MonsterObj {\r\n        uint64 monsterId;\r\n        uint32 classId;\r\n        address trainer;\r\n        string name;\r\n        uint32 exp;\r\n        uint8[] statBases;\r\n        uint8[] skills;\r\n        uint32 createIndex;\r\n        uint32 lastClaimIndex;\r\n        uint createTime;\r\n    }\r\n\r\n    mapping(uint32 => MonsterClass) public monsterClass;\r\n    mapping(uint64 => MonsterObj) public monsterWorld;\r\n    mapping(address => uint64[]) public trainerDex;\r\n    mapping(address => uint256) public trainerExtraBalance;\r\n    \r\n    \r\n    // write access\r\n    function withdrawEther(address _sendTo, uint _amount) onlyOwner public returns(ResultCode) {\r\n        if (_amount > this.balance) {\r\n            return ResultCode.ERROR_INVALID_AMOUNT;\r\n        }\r\n        \r\n        _sendTo.transfer(_amount);\r\n        return ResultCode.SUCCESS;\r\n    }\r\n    \r\n    function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) onlyModerators public returns(uint) {\r\n        uint8[] storage array = monsterWorld[_id].statBases;\r\n        if (_type == ArrayType.CLASS_TYPE) {\r\n            array = monsterClass[uint32(_id)].types;\r\n        } else if (_type == ArrayType.STAT_STEP) {\r\n            array = monsterClass[uint32(_id)].statSteps;\r\n        } else if (_type == ArrayType.STAT_START) {\r\n            array = monsterClass[uint32(_id)].statStarts;\r\n        } else if (_type == ArrayType.OBJ_SKILL) {\r\n            array = monsterWorld[_id].skills;\r\n        }\r\n        array.push(_value);\r\n        return array.length;\r\n    }\r\n    \r\n    function updateIndexOfArrayType(ArrayType _type, uint64 _id, uint _index, uint8 _value) onlyModerators public returns(uint) {\r\n        uint8[] storage array = monsterWorld[_id].statBases;\r\n        if (_type == ArrayType.CLASS_TYPE) {\r\n            array = monsterClass[uint32(_id)].types;\r\n        } else if (_type == ArrayType.STAT_STEP) {\r\n            array = monsterClass[uint32(_id)].statSteps;\r\n        } else if (_type == ArrayType.STAT_START) {\r\n            array = monsterClass[uint32(_id)].statStarts;\r\n        } else if (_type == ArrayType.OBJ_SKILL) {\r\n            array = monsterWorld[_id].skills;\r\n        }\r\n        if (_index < array.length) {\r\n            if (_value == 255) {\r\n                // consider as delete\r\n                for(uint i = _index; i < array.length - 1; i++) {\r\n                    array[i] = array[i+1];\r\n                }\r\n                delete array[array.length-1];\r\n                array.length--;\r\n            } else {\r\n                array[_index] = _value;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function setMonsterClass(uint32 _classId, uint256 _price, uint256 _returnPrice, bool _catchable) onlyModerators public returns(uint32) {\r\n        MonsterClass storage class = monsterClass[_classId];\r\n        if (class.classId == 0) {\r\n            totalClass += 1;\r\n        }\r\n        class.classId = _classId;\r\n        class.price = _price;\r\n        class.returnPrice = _returnPrice;\r\n        class.catchable = _catchable;\r\n        return totalClass;\r\n    }\r\n    \r\n    function addMonsterObj(uint32 _classId, address _trainer, string _name) onlyModerators public returns(uint64) {\r\n        MonsterClass storage class = monsterClass[_classId];\r\n        if (class.classId == 0)\r\n            return 0;\r\n                \r\n        // construct new monster\r\n        totalMonster += 1;\r\n        class.total += 1;\r\n\r\n        MonsterObj storage obj = monsterWorld[totalMonster];\r\n        obj.monsterId = totalMonster;\r\n        obj.classId = _classId;\r\n        obj.trainer = _trainer;\r\n        obj.name = _name;\r\n        obj.exp = 1;\r\n        obj.createIndex = class.total;\r\n        obj.lastClaimIndex = class.total;\r\n        obj.createTime = now;\r\n\r\n        // add to monsterdex\r\n        addMonsterIdMapping(_trainer, obj.monsterId);\r\n        return obj.monsterId;\r\n    }\r\n    \r\n    function setMonsterObj(uint64 _objId, string _name, uint32 _exp, uint32 _createIndex, uint32 _lastClaimIndex) onlyModerators public {\r\n        MonsterObj storage obj = monsterWorld[_objId];\r\n        if (obj.monsterId == _objId) {\r\n            obj.name = _name;\r\n            obj.exp = _exp;\r\n            obj.createIndex = _createIndex;\r\n            obj.lastClaimIndex = _lastClaimIndex;\r\n        }\r\n    }\r\n\r\n    function increaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public {\r\n        MonsterObj storage obj = monsterWorld[_objId];\r\n        if (obj.monsterId == _objId) {\r\n            obj.exp = uint32(safeAdd(obj.exp, amount));\r\n        }\r\n    }\r\n\r\n    function decreaseMonsterExp(uint64 _objId, uint32 amount) onlyModerators public {\r\n        MonsterObj storage obj = monsterWorld[_objId];\r\n        if (obj.monsterId == _objId) {\r\n            obj.exp = uint32(safeSubtract(obj.exp, amount));\r\n        }\r\n    }\r\n\r\n    function removeMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public {\r\n        uint foundIndex = 0;\r\n        uint64[] storage objIdList = trainerDex[_trainer];\r\n        for (; foundIndex < objIdList.length; foundIndex++) {\r\n            if (objIdList[foundIndex] == _monsterId) {\r\n                break;\r\n            }\r\n        }\r\n        if (foundIndex < objIdList.length) {\r\n            objIdList[foundIndex] = objIdList[objIdList.length-1];\r\n            delete objIdList[objIdList.length-1];\r\n            objIdList.length--;\r\n            MonsterObj storage monster = monsterWorld[_monsterId];\r\n            monster.trainer = 0;\r\n        }\r\n    }\r\n    \r\n    function addMonsterIdMapping(address _trainer, uint64 _monsterId) onlyModerators public {\r\n        if (_trainer != address(0) && _monsterId > 0) {\r\n            uint64[] storage objIdList = trainerDex[_trainer];\r\n            for (uint i = 0; i < objIdList.length; i++) {\r\n                if (objIdList[i] == _monsterId) {\r\n                    return;\r\n                }\r\n            }\r\n            objIdList.push(_monsterId);\r\n            MonsterObj storage monster = monsterWorld[_monsterId];\r\n            monster.trainer = _trainer;\r\n        }\r\n    }\r\n    \r\n    function clearMonsterReturnBalance(uint64 _monsterId) onlyModerators public returns(uint256) {\r\n        MonsterObj storage monster = monsterWorld[_monsterId];\r\n        MonsterClass storage class = monsterClass[monster.classId];\r\n        if (monster.monsterId == 0 || class.classId == 0)\r\n            return 0;\r\n        uint256 amount = 0;\r\n        uint32 gap = uint32(safeSubtract(class.total, monster.lastClaimIndex));\r\n        if (gap > 0) {\r\n            monster.lastClaimIndex = class.total;\r\n            amount = safeMult(gap, class.returnPrice);\r\n            trainerExtraBalance[monster.trainer] = safeAdd(trainerExtraBalance[monster.trainer], amount);\r\n        }\r\n        return amount;\r\n    }\r\n    \r\n    function collectAllReturnBalance(address _trainer) onlyModerators public returns(uint256 amount) {\r\n        uint64[] storage objIdList = trainerDex[_trainer];\r\n        for (uint i = 0; i < objIdList.length; i++) {\r\n            clearMonsterReturnBalance(objIdList[i]);\r\n        }\r\n        return trainerExtraBalance[_trainer];\r\n    }\r\n    \r\n    function transferMonster(address _from, address _to, uint64 _monsterId) onlyModerators public returns(ResultCode) {\r\n        MonsterObj storage monster = monsterWorld[_monsterId];\r\n        if (monster.trainer != _from) {\r\n            return ResultCode.ERROR_NOT_TRAINER;\r\n        }\r\n        \r\n        clearMonsterReturnBalance(_monsterId);\r\n        \r\n        removeMonsterIdMapping(_from, _monsterId);\r\n        addMonsterIdMapping(_to, _monsterId);\r\n        return ResultCode.SUCCESS;\r\n    }\r\n    \r\n    function addExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256) {\r\n        trainerExtraBalance[_trainer] = safeAdd(trainerExtraBalance[_trainer], _amount);\r\n        return trainerExtraBalance[_trainer];\r\n    }\r\n    \r\n    function deductExtraBalance(address _trainer, uint256 _amount) onlyModerators public returns(uint256) {\r\n        trainerExtraBalance[_trainer] = safeSubtract(trainerExtraBalance[_trainer], _amount);\r\n        return trainerExtraBalance[_trainer];\r\n    }\r\n    \r\n    function setExtraBalance(address _trainer, uint256 _amount) onlyModerators public {\r\n        trainerExtraBalance[_trainer] = _amount;\r\n    }\r\n    \r\n    \r\n    // public\r\n    function () payable public {\r\n        addExtraBalance(msg.sender, msg.value);\r\n    }\r\n\r\n    // read access\r\n    function getSizeArrayType(ArrayType _type, uint64 _id) constant public returns(uint) {\r\n        uint8[] storage array = monsterWorld[_id].statBases;\r\n        if (_type == ArrayType.CLASS_TYPE) {\r\n            array = monsterClass[uint32(_id)].types;\r\n        } else if (_type == ArrayType.STAT_STEP) {\r\n            array = monsterClass[uint32(_id)].statSteps;\r\n        } else if (_type == ArrayType.STAT_START) {\r\n            array = monsterClass[uint32(_id)].statStarts;\r\n        } else if (_type == ArrayType.OBJ_SKILL) {\r\n            array = monsterWorld[_id].skills;\r\n        }\r\n        return array.length;\r\n    }\r\n    \r\n    function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8) {\r\n        uint8[] storage array = monsterWorld[_id].statBases;\r\n        if (_type == ArrayType.CLASS_TYPE) {\r\n            array = monsterClass[uint32(_id)].types;\r\n        } else if (_type == ArrayType.STAT_STEP) {\r\n            array = monsterClass[uint32(_id)].statSteps;\r\n        } else if (_type == ArrayType.STAT_START) {\r\n            array = monsterClass[uint32(_id)].statStarts;\r\n        } else if (_type == ArrayType.OBJ_SKILL) {\r\n            array = monsterWorld[_id].skills;\r\n        }\r\n        if (_index >= array.length)\r\n            return 0;\r\n        return array[_index];\r\n    }\r\n    \r\n    \r\n    function getMonsterClass(uint32 _classId) constant public returns(uint32 classId, uint256 price, uint256 returnPrice, uint32 total, bool catchable) {\r\n        MonsterClass storage class = monsterClass[_classId];\r\n        classId = class.classId;\r\n        price = class.price;\r\n        returnPrice = class.returnPrice;\r\n        total = class.total;\r\n        catchable = class.catchable;\r\n    }\r\n    \r\n    function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime) {\r\n        MonsterObj storage monster = monsterWorld[_objId];\r\n        objId = monster.monsterId;\r\n        classId = monster.classId;\r\n        trainer = monster.trainer;\r\n        exp = monster.exp;\r\n        createIndex = monster.createIndex;\r\n        lastClaimIndex = monster.lastClaimIndex;\r\n        createTime = monster.createTime;\r\n    }\r\n    \r\n    function getMonsterName(uint64 _objId) constant public returns(string name) {\r\n        return monsterWorld[_objId].name;\r\n    }\r\n\r\n    function getExtraBalance(address _trainer) constant public returns(uint256) {\r\n        return trainerExtraBalance[_trainer];\r\n    }\r\n    \r\n    function getMonsterDexSize(address _trainer) constant public returns(uint) {\r\n        return trainerDex[_trainer].length;\r\n    }\r\n    \r\n    function getMonsterObjId(address _trainer, uint index) constant public returns(uint64) {\r\n        if (index >= trainerDex[_trainer].length)\r\n            return 0;\r\n        return trainerDex[_trainer][index];\r\n    }\r\n    \r\n    function getExpectedBalance(address _trainer) constant public returns(uint256) {\r\n        uint64[] storage objIdList = trainerDex[_trainer];\r\n        uint256 monsterBalance = 0;\r\n        for (uint i = 0; i < objIdList.length; i++) {\r\n            MonsterObj memory monster = monsterWorld[objIdList[i]];\r\n            MonsterClass storage class = monsterClass[monster.classId];\r\n            uint32 gap = uint32(safeSubtract(class.total, monster.lastClaimIndex));\r\n            monsterBalance += safeMult(gap, class.returnPrice);\r\n        }\r\n        return monsterBalance;\r\n    }\r\n    \r\n    function getMonsterReturn(uint64 _objId) constant public returns(uint256 current, uint256 total) {\r\n        MonsterObj memory monster = monsterWorld[_objId];\r\n        MonsterClass storage class = monsterClass[monster.classId];\r\n        uint32 totalGap = uint32(safeSubtract(class.total, monster.createIndex));\r\n        uint32 currentGap = uint32(safeSubtract(class.total, monster.lastClaimIndex));\r\n        return (safeMult(currentGap, class.returnPrice), safeMult(totalGap, class.returnPrice));\r\n    }\r\n\r\n}"}}}