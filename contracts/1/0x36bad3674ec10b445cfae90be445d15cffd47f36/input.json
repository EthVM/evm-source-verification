{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/JasmyHyperDrop.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.6.12;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract JasmyHyperDrop\r\n{\r\n    address private admin;\r\n    address private signOwner;\r\n    IERC20 private token;\r\n    \r\n    uint256 private defaultTokensAmount;\r\n    uint32 private claimedCount;\r\n    \r\n    mapping(uint16 => uint256) private bitmask;\r\n    \r\n    string private constant ERR_MSG_SENDER = \"ERR_MSG_SENDER\";\r\n    string private constant ERR_AMOUNT = \"ERR_AMOUNT\";\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    constructor(address _admin, address _signOwner, address _tokenAddress, uint256 _defaultTokensAmount) public\r\n    {\r\n        admin                   = _admin;\r\n        signOwner               = _signOwner;\r\n        token                   = IERC20(_tokenAddress);\r\n        defaultTokensAmount     = _defaultTokensAmount;\r\n        \r\n        setClaimed(type(uint16).max, type(uint8).max); // gas savings for the first user that will claim tokens\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function getAdmin() external view returns (address)\r\n    {\r\n        return admin;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function getSignOwner() external view returns (address)\r\n    {\r\n        return signOwner;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function setSignOwner(address _signOwner) external\r\n    {\r\n        require(msg.sender == admin, ERR_MSG_SENDER);\r\n        \r\n        signOwner = _signOwner;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function getTokenAddress() external view returns (address)\r\n    {\r\n        return address(token);\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function getTotalTokensBalance() external view returns (uint256)\r\n    {\r\n        return token.balanceOf(address(this));\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function sendTokens(address _to, uint256 _amount) external\r\n    {\r\n        require(msg.sender == admin, ERR_MSG_SENDER);\r\n        require(_amount <= token.balanceOf(address(this)), ERR_AMOUNT);\r\n        \r\n        if(_amount == 0)\r\n        {\r\n            token.transfer(_to, token.balanceOf(address(this)));\r\n        }\r\n        else\r\n        {\r\n            token.transfer(_to, _amount);\r\n        }\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function getDefaultTokensAmount() external view returns (uint256)\r\n    {\r\n        return defaultTokensAmount;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function setDefaultTokensAmount(uint256 _amount) external\r\n    {\r\n        require(msg.sender == admin, ERR_MSG_SENDER);\r\n        \r\n        defaultTokensAmount = _amount;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function getClaimedCount() external view returns (uint32)\r\n    {\r\n        return claimedCount;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function claimTokens(uint16 _block, uint8 _bit, bytes memory _signature) external\r\n    {\r\n        require(!isClaimed(_block, _bit), \"ERR_ALREADY_CLAIMED\");\r\n        \r\n        string memory message = string(abi.encodePacked(toAsciiString(msg.sender), \";\", uintToString(_block), \";\", uintToString(_bit)));\r\n        verify(message, _signature);\r\n        \r\n        token.transfer(msg.sender, defaultTokensAmount);\r\n        \r\n        setClaimed(_block, _bit);\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function claimTokens(uint16 _block, uint8 _bit, uint256 _tokensCount, bytes memory _signature) external\r\n    {\r\n        require(!isClaimed(_block, _bit));\r\n        \r\n        string memory message = string(abi.encodePacked(toAsciiString(msg.sender), \";\", uintToString(_block), \";\", uintToString(_bit), \";\", uintToString(_tokensCount)));\r\n        verify(message, _signature);\r\n        \r\n        token.transfer(msg.sender, _tokensCount);\r\n        \r\n        setClaimed(_block, _bit);\r\n    }\r\n\r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function setClaimed(uint16 _block, uint8 _bit) private\r\n    {\r\n        uint256 bitBlock = bitmask[_block];\r\n        uint256 mask = uint256(1) << _bit;\r\n        \r\n        bitmask[_block] = (bitBlock | mask);\r\n        \r\n        ++claimedCount;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function isClaimed(uint16 _block, uint8 _bit) public view returns (bool)\r\n    {\r\n        uint256 bitBlock = bitmask[_block];\r\n        uint256 mask = uint256(1) << _bit;\r\n        \r\n        return (bitBlock & mask) > 0;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function verify(string memory _message, bytes memory _sig) private view\r\n    {\r\n        bytes32 messageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(abi.encodePacked(_message))));\r\n        address messageSigner = recover(messageHash, _sig);\r\n        \r\n        require(messageSigner == signOwner, \"ERR_VERIFICATION_FAILED\");\r\n    }\r\n\r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function recover(bytes32 _hash, bytes memory _sig) private pure returns (address)\r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        \r\n        require(_sig.length == 65, \"ERR_RECOVER_SIG_SIZE\");\r\n\r\n        assembly\r\n        {\r\n            r := mload(add(_sig, 32))\r\n            s := mload(add(_sig, 64))\r\n            v := byte(0, mload(add(_sig, 96)))\r\n        }\r\n\r\n        if(v < 27)\r\n        {\r\n            v += 27;\r\n        }\r\n        \r\n        require(v == 27 || v == 28, \"ERR_RECOVER_INVALID_SIG\");\r\n\r\n        return ecrecover(_hash, v, r, s);\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function uintToString(uint _i) private pure returns (string memory)\r\n    {\r\n        if(_i == 0)\r\n        {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0)\r\n        {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while(_i != 0)\r\n        {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function toAsciiString(address _addr) private pure returns (string memory)\r\n    {\r\n        bytes memory s = new bytes(40);\r\n        for(uint i = 0; i < 20; i++)\r\n        {\r\n            byte b = byte(uint8(uint(_addr) / (2**(8*(19 - i)))));\r\n            byte hi = byte(uint8(b) / 16);\r\n            byte lo = byte(uint8(b) - 16 * uint8(hi));\r\n            s[2*i] = char(hi);\r\n            s[2*i+1] = char(lo);            \r\n        }\r\n        return string(s);\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------------------------------------------------------\r\n    function char(byte value) private pure returns (byte)\r\n    {\r\n        if(uint8(value) < 10)\r\n        {\r\n            return byte(uint8(value) + 0x30);\r\n        }\r\n        else\r\n        {\r\n            return byte(uint8(value) + 0x57);\r\n        }\r\n    }\r\n}"
    }
  }
}