{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}},"sources":{"contracts/AtopiaApe.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./utils/Base.sol\";\nimport \"./libs/BatchCounters.sol\";\nimport \"./interfaces/IDrawer.sol\";\n\ncontract AtopiaApe is AtopiaBase {\n\tbool public initialized;\n\tusing BatchCounters for BatchCounters.Counter;\n\tBatchCounters.Counter private _tokenIds;\n\n\tstruct Token {\n\t\taddress token;\n\t\tuint256 price;\n\t\tuint256 limit;\n\t}\n\n\tevent TraitUpdated(uint256 tokenId, uint256 tokenTrait);\n\n\tuint256 public constant saleFee = 0.06 ether;\n\tuint256 public constant BLOCK_COUNT = 1000;\n\n\tmapping(address => bool) public memberships;\n\tmapping(address => uint256) public whitelists;\n\tToken[] public tokens;\n\n\tmapping(uint256 => string) names;\n\n\tmapping(uint256 => uint256) public tokenTraits;\n\tmapping(uint256 => mapping(uint256 => uint256)) public traitStore;\n\tuint256[] blockHashes;\n\tuint256 seed;\n\n\tIDrawer public drawer;\n\n\tuint8 public state;\n\n\tfunction initialize(address bucks) public virtual override {\n\t\trequire(!initialized);\n\t\tinitialized = true;\n\t\tAtopiaBase.initialize(bucks);\n\t\tseed = uint256(keccak256(abi.encodePacked(block.difficulty, block.coinbase, block.timestamp)));\n\t}\n\n\tfunction totalTokens() external view returns (uint256) {\n\t\treturn tokens.length;\n\t}\n\n\tmodifier onlyState(uint8 _state) {\n\t\trequire(state >= _state, \"Not Allowed\");\n\t\t_;\n\t}\n\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn _tokenIds.current();\n\t}\n\n\tfunction nextGenInfo(uint256 last) public pure returns (uint256, uint256) {\n\t\tif (last < 10_000) {\n\t\t\treturn (10_000_000_000, 5 * apeYear); // 10k ABUCKS\n\t\t} else if (last < 20_000) {\n\t\t\treturn (10_000_000_000, 3 * apeYear); // 15k ABUCKS\n\t\t} else if (last < 30_000) {\n\t\t\treturn (15_000_000_000, 2 * apeYear); // 15k ABUCKS\n\t\t} else if (last < 40_000) {\n\t\t\treturn (20_000_000_000, 1 * apeYear); // 20k ABUCKS\n\t\t} else {\n\t\t\treturn (25_000_000_000, 1 * apeYear); // 25k ABUCKS\n\t\t}\n\t}\n\n\tfunction blockToken(uint256 blockIndex) public view returns (uint256) {\n\t\tuint256 blockHash = blockHashes[blockIndex];\n\t\tif (blockHash > 0) {\n\t\t\treturn (blockHash % BLOCK_COUNT) + 1 + blockIndex * BLOCK_COUNT;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfunction enter(\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tuint256 _seed\n\t) internal {\n\t\tuint256 tokenTrait;\n\t\tfor (uint16 i = 0; i < drawer.traitCount() - 1; i++) {\n\t\t\ttokenTrait = (tokenTrait << 16) | ((_seed & 0xFFFF) % drawer.itemCount(i));\n\t\t\t_seed = _seed >> 16;\n\t\t}\n\n\t\t// Furry Body & Face Colors\n\t\tif (((tokenTrait >> 144) & 0xFFFF) == ((tokenTrait >> 128) & 0xFFFF)) {\n\t\t\ttokenTrait = (tokenTrait << 16) | 1;\n\t\t} else {\n\t\t\ttokenTrait = tokenTrait << 16;\n\t\t}\n\n\t\ttokenTraits[tokenId] = tokenTrait;\n\t\t_mint(to, tokenId);\n\t}\n\n\tfunction batch(\n\t\taddress to,\n\t\tuint256 amount,\n\t\tuint256 age\n\t) internal {\n\t\tuint256 newSeed = seed;\n\t\t(uint256 start, uint256 end) = _tokenIds.increment(amount);\n\t\tuint256 info = ((block.timestamp - age) << 64) | uint64(block.timestamp);\n\t\tfor (uint256 i = start; i <= end; i++) {\n\t\t\tinfos[i] = info;\n\n\t\t\tnewSeed = uint256(keccak256(abi.encodePacked(i, info, newSeed)));\n\t\t\tenter(to, i, newSeed);\n\n\t\t\tif (i % BLOCK_COUNT == 0) {\n\t\t\t\tblockHashes.push(newSeed);\n\t\t\t}\n\t\t}\n\t\tseed = newSeed;\n\t}\n\n\tfunction mint(uint256 amount) external payable onlyState(2) {\n\t\trequire(amount <= 7);\n\t\trequire(totalSupply() + amount <= 10_000);\n\t\trequire(msg.value >= saleFee * amount);\n\t\tbatch(msg.sender, amount, 5 * apeYear);\n\t}\n\n\tfunction mintPresale(uint256 amount) external payable onlyState(1) {\n\t\trequire(whitelists[msg.sender] >= amount);\n\t\twhitelists[msg.sender] -= amount;\n\t\trequire(totalSupply() + amount <= 10_000);\n\t\trequire(msg.value >= saleFee * amount);\n\t\tbatch(msg.sender, amount, 5 * apeYear);\n\t}\n\n\tfunction mintOG() external onlyState(1) {\n\t\trequire(memberships[msg.sender]);\n\t\tdelete memberships[msg.sender];\n\t\trequire(totalSupply() < 10_000);\n\t\tbatch(msg.sender, 1, 5 * apeYear);\n\t}\n\n\tfunction mintWithToken(uint256 index, uint256 amount) external onlyState(1) {\n\t\trequire(amount <= (state == 1 ? 3 : 7));\n\t\trequire(tokens[index].limit >= amount);\n\t\ttokens[index].limit -= amount;\n\t\trequire(totalSupply() + amount <= 10_000);\n\t\tIBucks(tokens[index].token).transferFrom(msg.sender, admin, tokens[index].price * amount);\n\t\tbatch(msg.sender, amount, 5 * apeYear);\n\t}\n\n\tfunction mintNextGen(uint256 amount) external {\n\t\tuint256 last = totalSupply();\n\t\tuint256 end = last + amount;\n\t\trequire(end <= 50_000);\n\t\trequire((last / 10_000) == (end / 10_000));\n\t\t(uint256 price, uint256 age) = nextGenInfo(end);\n\t\tbucks.burnFrom(msg.sender, price * amount);\n\t\tbatch(msg.sender, amount, age);\n\t}\n\n\tfunction setName(uint256 tokenId, string memory name) external {\n\t\tonlyTokenOwner(tokenId);\n\t\tbucks.burnFrom(msg.sender, 700_000_000);\n\t\tnames[tokenId] = name;\n\t}\n\n\tfunction placeItem(\n\t\tuint256 tokenId,\n\t\tuint16 traitType,\n\t\tuint256 traitId,\n\t\tbool isStore\n\t) internal {\n\t\tuint16 traitPos = (10 - traitType) * 16;\n\t\tuint256 tokenTrait = tokenTraits[tokenId];\n\t\tuint256 exchangeId = (tokenTrait >> traitPos) & 0xFFFF;\n\n\t\tif (isStore) {\n\t\t\tuint256 store = traitStore[tokenId][traitType];\n\t\t\tuint256 count = store & 0xFFFF;\n\t\t\tstore = store >> 16;\n\t\t\tif (count == 0 && exchangeId > 0) {\n\t\t\t\tstore = exchangeId;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t\ttraitStore[tokenId][traitType] = (store << 32) | (traitId << 16) | (count + 1);\n\t\t}\n\n\t\ttokenTrait = ((tokenTrait ^ (exchangeId << traitPos)) ^ 0) | (traitId << traitPos);\n\t\ttokenTraits[tokenId] = tokenTrait;\n\t\temit TraitUpdated(tokenId, tokenTrait);\n\t}\n\n\tfunction useItem(\n\t\tuint256 tokenId,\n\t\tuint256 itemId,\n\t\tuint256 amount\n\t) external {\n\t\tonlyTokenOwner(tokenId);\n\t\t(uint256 job, uint256 task, ) = space.getLife(tokenId);\n\t\trequire(job == 0 || task > 0);\n\t\tuint256 itemInfo = IShop(shop).itemInfo(itemId - 1);\n\t\t// Min Age\n\t\trequire(getAge(tokenId) >= itemInfo & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\t\titemInfo = itemInfo >> 128;\n\t\t// Bonus Trait\n\t\tif (itemInfo & 0xFFFFFFFF > 0) {\n\t\t\trequire(amount == 1);\n\t\t\tuint16 traitId = uint16(itemInfo & 0xFFFF);\n\t\t\tuint16 traitType = uint16((itemInfo >> 16) & 0xFFFF);\n\t\t\tplaceItem(tokenId, traitType, traitId, true);\n\t\t}\n\t\tIShop(shop).burn(msg.sender, itemId, amount);\n\t\titemInfo = itemInfo >> 64;\n\t\t// Bonus Age\n\t\tuseItemInternal(tokenId, itemInfo * amount);\n\t}\n\n\tfunction makeup(\n\t\tuint256 tokenId,\n\t\tuint16 traitType,\n\t\tuint256 storeIndex\n\t) external {\n\t\tonlyTokenOwner(tokenId);\n\t\tuint256 store = traitStore[tokenId][traitType];\n\t\tuint256 count = store & 0xFFFF;\n\t\trequire(storeIndex > 0 && storeIndex <= count);\n\t\tuint16 traitId = uint16((store >> (storeIndex * 16)) & 0xFFFF);\n\t\tplaceItem(tokenId, traitType, traitId, false);\n\t}\n\n\tfunction claimTraits(uint256 blockIndex) external {\n\t\tuint16 trait5Index = uint16(drawer.itemCount(5) + blockIndex);\n\t\trequire(trait5Index < drawer.totalItems(5));\n\t\tuint16 traitSpecial = uint16(drawer.itemCount(10) + blockIndex);\n\t\trequire(traitSpecial < drawer.totalItems(10));\n\t\tuint256 tokenId = blockToken(blockIndex);\n\t\trequire(msg.sender == ownerOf[tokenId]);\n\t\tblockHashes[blockIndex] = 0;\n\t\tplaceItem(tokenId, 5, trait5Index, true);\n\t\tplaceItem(tokenId, 10, traitSpecial, false);\n\t}\n\n\tfunction setState(uint8 _state) external onlyOwner {\n\t\tstate = _state;\n\t}\n\n\tfunction setDrawer(address _drawer) external onlyOwner {\n\t\tdrawer = IDrawer(_drawer);\n\t\temit DrawerUpdated(_drawer);\n\t}\n\n\tfunction addMembership(address[] calldata members) public onlyOwner {\n\t\tfor (uint256 i = 0; i < members.length; i++) {\n\t\t\tmemberships[members[i]] = true;\n\t\t}\n\t}\n\n\tfunction addWhitelists(address[] calldata members) public onlyOwner {\n\t\tfor (uint256 i = 0; i < members.length; i++) {\n\t\t\twhitelists[members[i]] = 3;\n\t\t}\n\t}\n\n\tfunction addToken(\n\t\taddress token,\n\t\tuint256 price,\n\t\tuint256 limit\n\t) public onlyOwner {\n\t\ttokens.push(Token(token, price, limit));\n\t}\n\n\tfunction withdraw() external onlyOwner {\n\t\tpayable(admin).transfer(address(this).balance);\n\t}\n\n\tfunction tokenURI(uint256 tokenId) public view returns (string memory) {\n\t\trequire(ownerOf[tokenId] != address(0), \"Token Invalid\");\n\t\treturn drawer.tokenURI(tokenId, names[tokenId], tokenTraits[tokenId], uint16((getAge(tokenId) / apeYear)));\n\t}\n}\n"},"contracts/interfaces/IBucks.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBucks {\n\tfunction mint(address account, uint256 amount) external;\n\n\tfunction burn(uint256 amount) external;\n\n\tfunction burnFrom(address account, uint256 amount) external;\n\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) external returns (bool);\n\n\tfunction balanceOf(address account) external view returns (uint256);\n}\n"},"contracts/interfaces/IDrawer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ITrait.sol\";\n\ninterface IDrawer {\n\tfunction traitCount() external view returns (uint16);\n\n\tfunction itemCount(uint256 traitId) external view returns (uint256);\n\n\tfunction totalItems(uint256 traitId) external view returns (uint256);\n\n\tfunction tokenURI(\n\t\tuint256 tokenId,\n\t\tstring memory name,\n\t\tuint256 tokenTrait,\n\t\tuint16 age\n\t) external view returns (string memory);\n}\n"},"contracts/interfaces/IShop.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IShop {\n\tfunction itemInfo(uint256 index) external view returns (uint256);\n\n\tfunction burn(\n\t\taddress account,\n\t\tuint256 id,\n\t\tuint256 value\n\t) external;\n}\n"},"contracts/interfaces/ITrait.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITrait {\n\tfunction name() external view returns (string memory);\n\n\tfunction itemCount() external view returns (uint256);\n\n\tfunction totalItems() external view returns (uint256);\n\n\tfunction getTraitName(uint16 traitId) external view returns (string memory);\n\n\tfunction getTraitContent(uint16 traitId) external view returns (string memory);\n\n\tfunction getTraitByAge(uint16 age) external view returns (uint16);\n\n\tfunction isOverEye(uint16 traitId) external view returns (bool);\n}\n"},"contracts/libs/BatchCounters.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary BatchCounters {\n\tstruct Counter {\n\t\tuint256 _value; // default: 0\n\t}\n\n\tfunction current(Counter storage counter) internal view returns (uint256) {\n\t\treturn counter._value;\n\t}\n\n\tfunction increment(Counter storage counter, uint256 amount) internal returns (uint256 start, uint256 end) {\n\t\tstart = counter._value + 1;\n\t\tcounter._value += amount;\n\t\tend = counter._value;\n\t}\n}\n"},"contracts/utils/Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC721.sol\";\nimport \"../interfaces/IBucks.sol\";\nimport \"../interfaces/IShop.sol\";\n\ninterface ISpace {\n\tfunction getLife(uint256 tokenId)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 job,\n\t\t\tuint256 task,\n\t\t\tuint256 data\n\t\t);\n}\n\nabstract contract AtopiaBase is ERC721 {\n\tuint256 constant apeYear = 365 days / 10;\n\n\tIBucks public bucks;\n\taddress public shop;\n\tISpace public space;\n\n\tmapping(uint256 => uint256) public infos;\n\tmapping(uint256 => uint256) public grow;\n\n\tfunction initialize(address _bucks) public virtual {\n\t\tname = \"Atopia Apes\";\n\t\tsymbol = \"ATPAPE\";\n\t\tbucks = IBucks(_bucks);\n\t}\n\n\tfunction getRewardsInternal(\n\t\tuint256 tokenId,\n\t\tuint256 info,\n\t\tuint256 timestamp\n\t) internal view returns (uint256) {\n\t\tif (info == 0) return 0;\n\t\tuint64 claims = uint64(info);\n\t\tuint256 duration = timestamp - claims;\n\t\tuint256 averageSpeed = (timestamp + claims) / 2 + grow[tokenId] - (uint128(info) >> 64);\n\t\treturn (averageSpeed * duration * 20_000_000) / apeYear / 1 days;\n\t}\n\n\tfunction getAge(uint256 tokenId) public view returns (uint256) {\n\t\treturn (block.timestamp - (uint128(infos[tokenId]) >> 64)) + grow[tokenId];\n\t}\n\n\tfunction getReward(uint256 tokenId) internal view returns (uint256 pending, uint256 info) {\n\t\t(uint256 job, uint256 task, ) = space.getLife(tokenId);\n\t\tinfo = infos[tokenId];\n\t\tpending = info >> 128;\n\t\tif (job == 0 || task > 0) {\n\t\t\tpending += getRewardsInternal(tokenId, info, block.timestamp);\n\t\t}\n\t}\n\n\tfunction getRewards(uint256[] memory tokenIds) external view returns (uint256 rewards) {\n\t\tfor (uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\tuint256 tokenId = tokenIds[i];\n\t\t\t(uint256 pending, ) = getReward(tokenId);\n\t\t\trewards += pending;\n\t\t}\n\t}\n\n\tfunction onlyTokenOwner(uint256 tokenId) public {\n\t\trequire(ownerOf[tokenId] == msg.sender);\n\t}\n\n\tfunction updateInternal(uint256 tokenId) internal {\n\t\tuint256 timestamp = block.timestamp;\n\t\tuint256 info = infos[tokenId];\n\t\tuint64 claims = uint64(info);\n\t\tuint128 birth = (uint128(info) >> 64);\n\t\tuint256 duration = timestamp - claims;\n\t\tuint256 average = ((timestamp + claims) >> 1) + grow[tokenId] - birth;\n\t\tuint256 pending = (info >> 128) + (average * duration * 20_000_000) / apeYear / 1 days;\n\t\tinfos[tokenId] = (pending << 128) | (birth << 64) | uint64(timestamp);\n\t}\n\n\tfunction claimRewards(uint256[] memory tokenIds) public {\n\t\tuint256 timestamp = block.timestamp;\n\t\tuint256 rewards;\n\t\tfor (uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\tuint256 tokenId = tokenIds[i];\n\t\t\trequire(ownerOf[tokenId] == msg.sender);\n\t\t\t(uint256 pending, uint256 info) = getReward(tokenId);\n\t\t\tif (pending > 0) {\n\t\t\t\trewards += pending;\n\t\t\t\tinfos[tokenId] = ((uint128(info) >> 64) << 64) | uint64(timestamp);\n\t\t\t}\n\t\t}\n\t\tif (rewards > 0) {\n\t\t\tbucks.mint(msg.sender, rewards);\n\t\t}\n\t}\n\n\tfunction useItemInternal(uint256 tokenId, uint256 bonusAge) internal {\n\t\tupdateInternal(tokenId);\n\t\tgrow[tokenId] += bonusAge;\n\t}\n\n\tfunction update(uint256 tokenId) external {\n\t\trequire(address(space) == msg.sender);\n\t\tupdateInternal(tokenId);\n\t}\n\n\tfunction exitCenter(\n\t\tuint256 tokenId,\n\t\taddress center,\n\t\tuint256 grown,\n\t\tuint256 enjoyFee\n\t) external {\n\t\trequire(address(space) == msg.sender);\n\t\tuint256 timestamp = block.timestamp;\n\t\tuint256 info = infos[tokenId];\n\t\tuint256 rewards = getRewardsInternal(tokenId, info, timestamp);\n\t\tuint256 fee = (rewards * enjoyFee) / 10000;\n\t\tuint256 pending = (infos[tokenId] >> 128) + (rewards - fee);\n\t\tinfos[tokenId] = (pending << 128) | ((uint128(info) >> 64) << 64) | uint64(timestamp);\n\t\tgrow[tokenId] += grown;\n\t\tbucks.mint(center, fee);\n\t}\n\n\tfunction setShop(address _shop) external onlyOwner {\n\t\tshop = _shop;\n\t\temit ShopUpdated(_shop);\n\t}\n\n\tfunction setSpace(address _space) external onlyOwner {\n\t\tspace = ISpace(_space);\n\t\temit SpaceUpdated(_space);\n\t}\n\n\tfunction _beforeTokenTransfer(\n\t\taddress,\n\t\taddress,\n\t\tuint256 tokenId\n\t) internal virtual override {\n\t\tuint256 timestamp = block.timestamp;\n\t\t(uint256 pending, uint256 info) = getReward(tokenId);\n\t\tif (pending > 0) {\n\t\t\tinfos[tokenId] = ((uint128(info) >> 64) << 64) | uint64(timestamp);\n\t\t\tbucks.mint(ownerOf[tokenId], pending);\n\t\t}\n\t}\n\n\tevent DrawerUpdated(address drawer);\n\tevent ShopUpdated(address shop);\n\tevent SpaceUpdated(address space);\n}\n"},"contracts/utils/ERC721.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation,\n/// including the MetaData, and partially, Enumerable extensions.\ncontract ERC721 {\n\t/*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n\tevent Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\n\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n\t/*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n\taddress implementation_;\n\taddress public admin;\n\n\tstring public name;\n\tstring public symbol;\n\n\t/*///////////////////////////////////////////////////////////////\n                             ERC-721 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n\tmapping(address => uint256) public balanceOf;\n\n\tmapping(uint256 => address) public ownerOf;\n\n\tmapping(uint256 => address) public getApproved;\n\n\tmapping(address => mapping(address => bool)) public isApprovedForAll;\n\n\t/*///////////////////////////////////////////////////////////////\n                             VIEW FUNCTION\n    //////////////////////////////////////////////////////////////*/\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == admin);\n\t\t_;\n\t}\n\n\tfunction owner() external view returns (address) {\n\t\treturn admin;\n\t}\n\n\t/*///////////////////////////////////////////////////////////////\n                              ERC-20-LIKE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction transfer(address to, uint256 tokenId) external {\n\t\trequire(msg.sender == ownerOf[tokenId], \"NOT_OWNER\");\n\n\t\t_transfer(msg.sender, to, tokenId);\n\t}\n\n\t/*///////////////////////////////////////////////////////////////\n                              ERC-721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction supportsInterface(bytes4 interfaceId) external pure returns (bool supported) {\n\t\tsupported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;\n\t}\n\n\tfunction approve(address spender, uint256 tokenId) external {\n\t\taddress owner_ = ownerOf[tokenId];\n\n\t\trequire(msg.sender == owner_ || isApprovedForAll[owner_][msg.sender], \"NOT_APPROVED\");\n\n\t\tgetApproved[tokenId] = spender;\n\n\t\temit Approval(owner_, spender, tokenId);\n\t}\n\n\tfunction setApprovalForAll(address operator, bool approved) external {\n\t\tisApprovedForAll[msg.sender][operator] = approved;\n\n\t\temit ApprovalForAll(msg.sender, operator, approved);\n\t}\n\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) public {\n\t\trequire(\n\t\t\tmsg.sender == from || msg.sender == getApproved[tokenId] || isApprovedForAll[from][msg.sender],\n\t\t\t\"NOT_APPROVED\"\n\t\t);\n\n\t\t_transfer(from, to, tokenId);\n\t}\n\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external {\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\n\t}\n\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory data\n\t) public {\n\t\ttransferFrom(from, to, tokenId);\n\n\t\tif (to.code.length != 0) {\n\t\t\t// selector = `onERC721Received(address,address,uint,bytes)`\n\t\t\t(, bytes memory returned) = to.staticcall(\n\t\t\t\tabi.encodeWithSelector(0x150b7a02, msg.sender, from, tokenId, data)\n\t\t\t);\n\n\t\t\tbytes4 selector = abi.decode(returned, (bytes4));\n\n\t\t\trequire(selector == 0x150b7a02, \"NOT_ERC721_RECEIVER\");\n\t\t}\n\t}\n\n\t/*///////////////////////////////////////////////////////////////\n                          INTERNAL UTILS\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction _transfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) internal {\n\t\trequire(ownerOf[tokenId] == from);\n\t\t_beforeTokenTransfer(from, to, tokenId);\n\n\t\tbalanceOf[from]--;\n\t\tbalanceOf[to]++;\n\n\t\tdelete getApproved[tokenId];\n\n\t\townerOf[tokenId] = to;\n\t\temit Transfer(msg.sender, to, tokenId);\n\t}\n\n\tfunction _mint(address to, uint256 tokenId) internal {\n\t\trequire(ownerOf[tokenId] == address(0), \"ALREADY_MINTED\");\n\n\t\t// This is safe because the sum of all user\n\t\t// balances can't exceed type(uint256).max!\n\t\tunchecked {\n\t\t\tbalanceOf[to]++;\n\t\t}\n\n\t\townerOf[tokenId] = to;\n\n\t\temit Transfer(address(0), to, tokenId);\n\t}\n\n\tfunction _burn(uint256 tokenId) internal {\n\t\taddress owner_ = ownerOf[tokenId];\n\n\t\trequire(owner_ != address(0), \"NOT_MINTED\");\n\t\t_beforeTokenTransfer(owner_, address(0), tokenId);\n\n\t\tbalanceOf[owner_]--;\n\n\t\tdelete ownerOf[tokenId];\n\n\t\temit Transfer(owner_, address(0), tokenId);\n\t}\n\n\tfunction _beforeTokenTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) internal virtual {}\n}\n"}}}