{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MarketUtilityV2_1.sol": {
      "content": "// File: contracts/external/uniswap/solidity-interface.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n  function allPairs(uint) external view returns (address pair);\r\n  function allPairsLength() external view returns (uint);\r\n\r\n  function feeTo() external view returns (address);\r\n  function feeToSetter() external view returns (address);\r\n\r\n  function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2ERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n\r\ninterface IUniswapV2Callee {\r\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts/external/uniswap/FixedPoint.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n// computes square roots using the babylonian method\r\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\r\npragma solidity >=0.5.0;\r\nlibrary Babylonian {\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n        // else z = 0\r\n    }\r\n}\r\n\r\nlibrary UQ112x112 {\r\n    uint224 constant Q112 = 2**112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 y) internal pure returns (uint224 z) {\r\n        z = uint224(y) * Q112; // never overflows\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n        z = x / uint224(y);\r\n    }\r\n}\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // range: [0, 2**144 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq144x112 {\r\n        uint _x;\r\n    }\r\n\r\n    uint8 private constant RESOLUTION = 112;\r\n    uint private constant Q112 = uint(1) << RESOLUTION;\r\n    uint private constant Q224 = Q112 << RESOLUTION;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(x) << RESOLUTION);\r\n    }\r\n\r\n    // encodes a uint144 as a UQ144x112\r\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\r\n        return uq144x112(uint256(x) << RESOLUTION);\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\r\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\r\n        return uq112x112(self._x / uint224(x));\r\n    }\r\n\r\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\r\n    // reverts on overflow\r\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\r\n        uint z;\r\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\r\n        return uq144x112(z);\r\n    }\r\n\r\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\r\n    // equivalent to encode(numerator).div(denominator)\r\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\r\n    }\r\n\r\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\r\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\r\n        return uint112(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\r\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\r\n        return uint144(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // take the reciprocal of a UQ112x112\r\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\r\n        return uq112x112(uint224(Q224 / self._x));\r\n    }\r\n\r\n    // square root of a UQ112x112\r\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\r\n    }\r\n}\r\n\r\n// File: contracts/external/uniswap/oracleLibrary.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\n\r\n\r\n// library with helper methods for oracles that are concerned with computing average prices\r\nlibrary UniswapV2OracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2 ** 32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(\r\n        address pair\r\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\r\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            // subtraction overflow is desired\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n            // addition overflow is desired\r\n            // counterfactual\r\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n            // counterfactual\r\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/external/openzeppelin-solidity/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath128 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        uint128 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint128 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\r\n        require(b <= a, errorMessage);\r\n        uint128 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint128 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint128 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath64 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        uint64 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint64 a, uint64 b, string memory errorMessage) internal pure returns (uint64) {\r\n        require(b <= a, errorMessage);\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint64 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint64 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath32 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint32 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\r\n        require(b <= a, errorMessage);\r\n        uint32 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint32 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/external/proxy/Proxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function () external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n            }\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function implementation() public view returns (address);\r\n}\r\n\r\n// File: contracts/external/proxy/UpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param implementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    // Storage position of the address of the current implementation\r\n    bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.govblocks.proxy.implementation\");\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor() public {}\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the current implementation\r\n    * @param _newImplementation address representing the new implementation to be set\r\n    */\r\n    function _setImplementation(address _newImplementation) internal {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n        sstore(position, _newImplementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(address _newImplementation) internal {\r\n        address currentImplementation = implementation();\r\n        require(currentImplementation != _newImplementation);\r\n        _setImplementation(_newImplementation);\r\n        emit Upgraded(_newImplementation);\r\n    }\r\n}\r\n\r\n// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    // Storage position of the owner of the contract\r\n    bytes32 private constant PROXY_OWNER_POSITION = keccak256(\"org.govblocks.proxy.owner\");\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor(address _implementation) public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\r\n        require(_newOwner != address(0));\r\n        _setUpgradeabilityOwner(_newOwner);\r\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\r\n    * @param _implementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(address _implementation) public onlyProxyOwner {\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            sstore(position, _newProxyOwner)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/ITokenController.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract ITokenController {\r\n\taddress public token;\r\n    address public bLOTToken;\r\n\r\n    /**\r\n    * @dev Swap BLOT token.\r\n    * account.\r\n    * @param amount The amount that will be swapped.\r\n    */\r\n    function swapBLOT(address _of, address _to, uint256 amount) public;\r\n\r\n    function totalBalanceOf(address _of)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    function transferFrom(address _token, address _of, address _to, uint256 amount) public;\r\n\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason at a specific time\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     * @param _time The timestamp to query the lock tokens for\r\n     */\r\n    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burnCommissionTokens(uint256 amount) external returns(bool);\r\n \r\n    function initiateVesting(address _vesting) external;\r\n\r\n    function lockForGovernanceVote(address _of, uint _days) public;\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function mint(address _member, uint _amount) public;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IMarketRegistry.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IMarketRegistry {\r\n\r\n    enum MarketType {\r\n      HourlyMarket,\r\n      DailyMarket,\r\n      WeeklyMarket\r\n    }\r\n    address public owner;\r\n    address public tokenController;\r\n    address public marketUtility;\r\n    bool public marketCreationPaused;\r\n\r\n    mapping(address => bool) public isMarket;\r\n    function() external payable{}\r\n\r\n    function marketDisputeStatus(address _marketAddress) public view returns(uint _status);\r\n\r\n    function burnDisputedProposalTokens(uint _proposaId) external;\r\n\r\n    function isWhitelistedSponsor(address _address) public view returns(bool);\r\n\r\n    function transferAssets(address _asset, address _to, uint _amount) external;\r\n\r\n    /**\r\n    * @dev Initialize the PlotX.\r\n    * @param _marketConfig The address of market config.\r\n    * @param _plotToken The address of PLOT token.\r\n    */\r\n    function initiate(address _defaultAddress, address _marketConfig, address _plotToken, address payable[] memory _configParams) public;\r\n\r\n    /**\r\n    * @dev Create proposal if user wants to raise the dispute.\r\n    * @param proposalTitle The title of proposal created by user.\r\n    * @param description The description of dispute.\r\n    * @param solutionHash The ipfs solution hash.\r\n    * @param actionHash The action hash for solution.\r\n    * @param stakeForDispute The token staked to raise the diospute.\r\n    * @param user The address who raises the dispute.\r\n    */\r\n    function createGovernanceProposal(string memory proposalTitle, string memory description, string memory solutionHash, bytes memory actionHash, uint256 stakeForDispute, address user, uint256 ethSentToPool, uint256 tokenSentToPool, uint256 proposedValue) public {\r\n    }\r\n\r\n    /**\r\n    * @dev Emits the PlacePrediction event and sets user data.\r\n    * @param _user The address who placed prediction.\r\n    * @param _value The amount of ether user staked.\r\n    * @param _predictionPoints The positions user will get.\r\n    * @param _predictionAsset The prediction assets user will get.\r\n    * @param _prediction The option range on which user placed prediction.\r\n    * @param _leverage The leverage selected by user at the time of place prediction.\r\n    */\r\n    function setUserGlobalPredictionData(address _user,uint _value, uint _predictionPoints, address _predictionAsset, uint _prediction,uint _leverage) public{\r\n    }\r\n\r\n    /**\r\n    * @dev Emits the claimed event.\r\n    * @param _user The address who claim their reward.\r\n    * @param _reward The reward which is claimed by user.\r\n    * @param incentives The incentives of user.\r\n    * @param incentiveToken The incentive tokens of user.\r\n    */\r\n    function callClaimedEvent(address _user , uint[] memory _reward, address[] memory predictionAssets, uint incentives, address incentiveToken) public {\r\n    }\r\n\r\n        /**\r\n    * @dev Emits the MarketResult event.\r\n    * @param _totalReward The amount of reward to be distribute.\r\n    * @param _winningOption The winning option of the market.\r\n    * @param _closeValue The closing value of the market currency.\r\n    */\r\n    function callMarketResultEvent(uint[] memory _totalReward, uint _winningOption, uint _closeValue, uint roundId) public {\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IChainLinkOracle.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ninterface IChainLinkOracle\r\n{\r\n\t/**\r\n    * @dev Gets the latest answer of chainLink oracle.\r\n    * @return int256 representing the latest answer of chainLink oracle.\r\n    */\r\n\tfunction latestAnswer() external view returns (int256);\r\n\tfunction decimals() external view returns (uint8);\r\n\tfunction getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  \tfunction latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    ); \r\n}\r\n\r\n// File: contracts/interfaces/IToken.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IToken {\r\n\r\n    function decimals() external view returns(uint8);\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param account The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param recipient The address to transfer to.\r\n    * @param amount The amount to be transferred.\r\n    */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev function that mints an amount of the token and assigns it to\r\n    * an account.\r\n    * @param account The account that will receive the created tokens.\r\n    * @param amount The amount that will be created.\r\n    */\r\n    function mint(address account, uint256 amount) external returns (bool);\r\n    \r\n     /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burn(uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param sender address The address which you want to send tokens from\r\n    * @param recipient address The address which you want to transfer to\r\n    * @param amount uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/MarketUtility.sol\r\n\r\n/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MarketUtility {\r\n    using SafeMath for uint256;\r\n    using FixedPoint for *;\r\n\r\n    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    uint256 constant updatePeriod = 1 hours;\r\n\r\n    uint256 internal STAKE_WEIGHTAGE;\r\n    uint256 internal STAKE_WEIGHTAGE_MIN_AMOUNT;\r\n    uint256 internal minTimeElapsedDivisor;\r\n    uint256 internal minPredictionAmount;\r\n    uint256 internal maxPredictionAmount;\r\n    uint256 internal positionDecimals;\r\n    uint256 internal minStakeForMultiplier;\r\n    uint256 internal riskPercentage;\r\n    uint256 internal tokenStakeForDispute;\r\n    address internal plotToken;\r\n    address internal plotETHpair;\r\n    address internal weth;\r\n    address internal initiater;\r\n    address public authorizedAddress;\r\n    bool public initialized;\r\n\r\n\r\n    struct UniswapPriceData {\r\n        FixedPoint.uq112x112 price0Average;\r\n        uint256 price0CumulativeLast;\r\n        FixedPoint.uq112x112 price1Average;\r\n        uint256 price1CumulativeLast;\r\n        uint32 blockTimestampLast;\r\n        bool initialized;\r\n    }\r\n\r\n    mapping(address => UniswapPriceData) internal uniswapPairData;\r\n    IUniswapV2Factory uniswapFactory;\r\n\r\n    ITokenController internal tokenController;\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == authorizedAddress, \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initiates the config contact with initial values\r\n     **/\r\n    function initialize(address payable[] memory _addressParams, address _initiater) public {\r\n        OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(\r\n            address(uint160(address(this)))\r\n        );\r\n        require(msg.sender == proxy.proxyOwner(), \"Sender is not proxy owner.\");\r\n        require(!initialized, \"Already initialized\");\r\n        initialized = true;\r\n        _setInitialParameters();\r\n        authorizedAddress = msg.sender;\r\n        tokenController = ITokenController(IMarketRegistry(msg.sender).tokenController());\r\n        plotToken = _addressParams[1];\r\n        initiater = _initiater;\r\n        weth = IUniswapV2Router02(_addressParams[0]).WETH();\r\n        uniswapFactory = IUniswapV2Factory(_addressParams[2]);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set initial value\r\n     **/\r\n    function _setInitialParameters() internal {\r\n        STAKE_WEIGHTAGE = 40; //\r\n        STAKE_WEIGHTAGE_MIN_AMOUNT = 20 ether;\r\n        minTimeElapsedDivisor = 6;\r\n        minPredictionAmount = 1e15;\r\n        maxPredictionAmount = 28 ether;\r\n        positionDecimals = 1e2;\r\n        minStakeForMultiplier = 5e17;\r\n        riskPercentage = 20;\r\n        tokenStakeForDispute = 500 ether;\r\n    }\r\n\r\n    /**\r\n    * @dev Check if user gets any multiplier on his positions\r\n    * @param _asset The assets uses by user during prediction.\r\n    * @param _predictionStake The amount staked by user at the time of prediction.\r\n    * @param predictionPoints The actual positions user got during prediction.\r\n    * @param _stakeValue The stake value of asset.\r\n    * @return uint256 representing multiplied positions\r\n    */\r\n    function checkMultiplier(address _asset, address _user, uint _predictionStake, uint predictionPoints, uint _stakeValue) public view returns(uint, bool) {\r\n      bool multiplierApplied;\r\n      uint _stakedBalance = tokenController.tokensLockedAtTime(_user, \"SM\", now);\r\n      uint _predictionValueInToken;\r\n      (, _predictionValueInToken) = getValueAndMultiplierParameters(_asset, _predictionStake);\r\n      if(_stakeValue < minStakeForMultiplier) {\r\n        return (predictionPoints,multiplierApplied);\r\n      }\r\n      uint _muliplier = 100;\r\n      if(_stakedBalance.div(_predictionValueInToken) > 0) {\r\n        _muliplier = _muliplier + _stakedBalance.mul(100).div(_predictionValueInToken.mul(10));\r\n        multiplierApplied = true;\r\n      }\r\n      return (predictionPoints.mul(_muliplier).div(100),multiplierApplied);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates integer parameters of config\r\n     **/\r\n    function updateUintParameters(bytes8 code, uint256 value)\r\n        external\r\n        onlyAuthorized\r\n    {\r\n        if (code == \"SW\") { // Stake weightage\r\n            require(value <= 100, \"Value must be less or equal to 100\");\r\n            STAKE_WEIGHTAGE = value;\r\n        } else if (code == \"SWMA\") { // Minimum amount required for stake weightage\r\n            STAKE_WEIGHTAGE_MIN_AMOUNT = value;\r\n        } else if (code == \"MTED\") { // Minimum time elapsed divisor\r\n            minTimeElapsedDivisor = value;\r\n        } else if (code == \"MINPRD\") { // Minimum predictionamount\r\n            minPredictionAmount = value;\r\n        } else if (code == \"MAXPRD\") { // Minimum predictionamount\r\n            maxPredictionAmount = value;\r\n        } else if (code == \"PDEC\") { // Position's Decimals\r\n            positionDecimals = value;\r\n        } else if (code == \"MINSTM\") { // Min stake required for applying multiplier\r\n            minStakeForMultiplier = value;\r\n        } else if (code == \"RPERC\") { // Risk percentage\r\n            riskPercentage = value;\r\n        } else if (code == \"TSDISP\") { // Amount of tokens to be staked for raising a dispute\r\n            tokenStakeForDispute = value;\r\n        } else {\r\n            revert(\"Invalid code\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Updates address parameters of config\r\n     **/\r\n    function updateAddressParameters(bytes8 code, address payable value)\r\n        external\r\n        onlyAuthorized\r\n    {\r\n        require(value != address(0), \"Value cannot be address(0)\");\r\n        if (code == \"UNIFAC\") { // Uniswap factory address\r\n            uniswapFactory = IUniswapV2Factory(value);\r\n            plotETHpair = uniswapFactory.getPair(plotToken, weth);\r\n        } else {\r\n            revert(\"Invalid code\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Update cumulative price of token in uniswap\r\n     **/\r\n    function update() external onlyAuthorized {\r\n        require(plotETHpair != address(0), \"Uniswap pair not set\");\r\n        UniswapPriceData storage _priceData = uniswapPairData[plotETHpair];\r\n        (\r\n            uint256 price0Cumulative,\r\n            uint256 price1Cumulative,\r\n            uint32 blockTimestamp\r\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(plotETHpair);\r\n        uint32 timeElapsed = blockTimestamp - _priceData.blockTimestampLast; // overflow is desired\r\n\r\n        if (timeElapsed >= updatePeriod || !_priceData.initialized) {\r\n            // overflow is desired, casting never truncates\r\n            // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\r\n            _priceData.price0Average = FixedPoint.uq112x112(\r\n                uint224(\r\n                    (price0Cumulative - _priceData.price0CumulativeLast) /\r\n                        timeElapsed\r\n                )\r\n            );\r\n            _priceData.price1Average = FixedPoint.uq112x112(\r\n                uint224(\r\n                    (price1Cumulative - _priceData.price1CumulativeLast) /\r\n                        timeElapsed\r\n                )\r\n            );\r\n\r\n            _priceData.price0CumulativeLast = price0Cumulative;\r\n            _priceData.price1CumulativeLast = price1Cumulative;\r\n            _priceData.blockTimestampLast = blockTimestamp;\r\n            if(!_priceData.initialized) {\r\n              _priceData.initialized = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set initial PLOT/ETH pair cummulative price\r\n     **/\r\n    function setInitialCummulativePrice() public {\r\n      require(msg.sender == initiater);\r\n      require(plotETHpair == address(0),\"Already initialised\");\r\n      plotETHpair = uniswapFactory.getPair(plotToken, weth);\r\n      UniswapPriceData storage _priceData = uniswapPairData[plotETHpair];\r\n      (\r\n          uint256 price0Cumulative,\r\n          uint256 price1Cumulative,\r\n          uint32 blockTimestamp\r\n      ) = UniswapV2OracleLibrary.currentCumulativePrices(plotETHpair);\r\n      _priceData.price0CumulativeLast = price0Cumulative;\r\n      _priceData.price1CumulativeLast = price1Cumulative;\r\n      _priceData.blockTimestampLast = blockTimestamp;\r\n    }\r\n\r\n    /**\r\n    * @dev Get decimals of given price feed address \r\n    */\r\n    function getPriceFeedDecimals(address _priceFeed) public view returns(uint8) {\r\n      return IChainLinkOracle(_priceFeed).decimals();\r\n    }\r\n\r\n    /**\r\n     * @dev Get basic market details\r\n     * @return Minimum amount required to predict in market\r\n     * @return Percentage of users leveraged amount to deduct when placed in wrong prediction\r\n     * @return Decimal points for prediction positions\r\n     * @return Maximum prediction amount\r\n     **/\r\n    function getBasicMarketDetails()\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        return (minPredictionAmount, riskPercentage, positionDecimals, maxPredictionAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Get Parameter required for option price calculation\r\n     * @param _marketFeedAddress  Feed Address of currency on which market options are based on\r\n     * @return Stake weightage percentage for calculation option price\r\n     * @return minimum amount of stake required to consider stake weightage\r\n     * @return Current price of the market currency\r\n     * @return Divisor to calculate minimum time elapsed for a market type\r\n     **/\r\n    function getPriceCalculationParams(\r\n        address _marketFeedAddress\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 _currencyPrice = getAssetPriceUSD(\r\n            _marketFeedAddress\r\n        );\r\n        return (\r\n            STAKE_WEIGHTAGE,\r\n            STAKE_WEIGHTAGE_MIN_AMOUNT,\r\n            _currencyPrice,\r\n            minTimeElapsedDivisor\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Get price of provided feed address\r\n     * @param _currencyFeedAddress  Feed Address of currency on which market options are based on\r\n     * @return Current price of the market currency\r\n     **/\r\n    function getAssetPriceUSD(\r\n        address _currencyFeedAddress\r\n    ) public view returns (uint256 latestAnswer) {\r\n        return uint256(IChainLinkOracle(_currencyFeedAddress).latestAnswer());\r\n    }\r\n\r\n    /**\r\n     * @dev Get price of provided feed address\r\n     * @param _currencyFeedAddress  Feed Address of currency on which market options are based on\r\n     * @return Current price of the market currency\r\n     **/\r\n    function getSettlemetPrice(\r\n        address _currencyFeedAddress,\r\n        uint256 _settleTime\r\n    ) public view returns (uint256 latestAnswer, uint256 roundId) {\r\n        uint80 currentRoundId;\r\n        uint256 currentRoundTime;\r\n        int256 currentRoundAnswer;\r\n        (currentRoundId, currentRoundAnswer, , currentRoundTime, )= IChainLinkOracle(_currencyFeedAddress).latestRoundData();\r\n        while(currentRoundTime > _settleTime) {\r\n            currentRoundId--;\r\n            (currentRoundId, currentRoundAnswer, , currentRoundTime, )= IChainLinkOracle(_currencyFeedAddress).getRoundData(currentRoundId);\r\n            if(currentRoundTime <= _settleTime) {\r\n                break;\r\n            }\r\n        }\r\n        return\r\n            (uint256(currentRoundAnswer), currentRoundId);\r\n    }\r\n\r\n    /**\r\n     * @dev Get value of provided currency address in ETH\r\n     * @param _currencyAddress Address of currency\r\n     * @param _amount Amount of provided currency\r\n     * @return Value of provided amount in ETH\r\n     **/\r\n    function getAssetValueETH(address _currencyAddress, uint256 _amount)\r\n        public\r\n        view\r\n        returns (uint256 tokenEthValue)\r\n    {\r\n        tokenEthValue = _amount;\r\n        if (_currencyAddress != ETH_ADDRESS) {\r\n            tokenEthValue = getPrice(plotETHpair, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get price of provided currency address in ETH\r\n     * @param _currencyAddress Address of currency\r\n     * @return Price of provided currency in ETH\r\n     * @return Decimals of the currency\r\n     **/\r\n    function getAssetPriceInETH(address _currencyAddress)\r\n        public\r\n        view\r\n        returns (uint256 tokenEthValue, uint256 decimals)\r\n    {\r\n        tokenEthValue = 1;\r\n        if (_currencyAddress != ETH_ADDRESS) {\r\n            decimals = IToken(_currencyAddress).decimals();\r\n            tokenEthValue = getPrice(plotETHpair, 10**decimals);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get amount of stake required to raise a dispute\r\n     **/\r\n    function getDisputeResolutionParams() public view returns (uint256) {\r\n        return tokenStakeForDispute;\r\n    }\r\n\r\n    /**\r\n     * @dev Get value of _asset in PLOT token and multiplier parameters\r\n     * @param _asset Address of asset for which value is requested\r\n     * @param _amount Amount of _asset\r\n     * @return min prediction amount required for multiplier\r\n     * @return value of given asset in PLOT tokens\r\n     **/\r\n    function getValueAndMultiplierParameters(address _asset, uint256 _amount)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 _value = _amount;\r\n        if (_asset == ETH_ADDRESS) {\r\n            _value = (uniswapPairData[plotETHpair].price1Average)\r\n                .mul(_amount)\r\n                .decode144();\r\n        }\r\n        return (minStakeForMultiplier, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Get Market feed address\r\n     * @return Uniswap factory address\r\n     **/\r\n    function getFeedAddresses() public view returns (address) {\r\n        return (address(uniswapFactory));\r\n    }\r\n\r\n    /**\r\n     * @dev Get value of token in pair\r\n     **/\r\n    function getPrice(address pair, uint256 amountIn)\r\n        public\r\n        view\r\n        returns (uint256 amountOut)\r\n    {\r\n        amountOut = (uniswapPairData[pair].price0Average)\r\n            .mul(amountIn)\r\n            .decode144();\r\n    }\r\n\r\n    /**\r\n    * @dev function to calculate square root of a number\r\n    */\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n      uint z = (x + 1) / 2;\r\n      y = x;\r\n      while (z < y) {\r\n          y = z;\r\n          z = (x / z + z) / 2;\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Calculate the prediction value, passing all the required params\r\n    * params index\r\n    * 0 _prediction\r\n    * 1 neutralMinValue\r\n    * 2 neutralMaxValue\r\n    * 3 startTime\r\n    * 4 expireTime\r\n    * 5 totalStakedETH\r\n    * 6 totalStakedToken\r\n    * 7 ethStakedOnOption\r\n    * 8 plotStakedOnOption\r\n    * 9 _stake\r\n    * 10 _leverage\r\n    */\r\n    function calculatePredictionValue(uint[] memory params, address asset, address user, address marketFeedAddress, bool _checkMultiplier) public view returns(uint _predictionValue, bool _multiplierApplied) {\r\n      uint _stakeValue = getAssetValueETH(asset, params[9]);\r\n      if(_stakeValue < minPredictionAmount || _stakeValue > maxPredictionAmount) {\r\n        return (_predictionValue, _multiplierApplied);\r\n      }\r\n      uint optionPrice;\r\n      \r\n      optionPrice = calculateOptionPrice(params, marketFeedAddress);\r\n      _predictionValue = _calculatePredictionPoints(_stakeValue.mul(positionDecimals), optionPrice, params[10]);\r\n      if(_checkMultiplier) {\r\n        return checkMultiplier(asset, user, params[9],  _predictionValue, _stakeValue);\r\n      }\r\n      return (_predictionValue, _multiplierApplied);\r\n    }\r\n\r\n    function _calculatePredictionPoints(uint value, uint optionPrice, uint _leverage) internal pure returns(uint) {\r\n      //leverageMultiplier = levergage + (leverage -1)*0.05; Raised by 3 decimals i.e 1000\r\n      uint leverageMultiplier = 1000 + (_leverage-1)*50;\r\n      value = value.mul(2500).div(1e18);\r\n      // (amount*sqrt(amount*100)*leverage*100/(price*10*125000/1000));\r\n      return value.mul(sqrt(value.mul(10000))).mul(_leverage*100*leverageMultiplier).div(optionPrice.mul(1250000000));\r\n    }\r\n\r\n    /**\r\n    * @dev Calculate the option price for given params\r\n    * params\r\n    * 0 _option\r\n    * 1 neutralMinValue\r\n    * 2 neutralMaxValue\r\n    * 3 startTime\r\n    * 4 expireTime\r\n    * 5 totalStakedETH\r\n    * 6 totalStakedToken\r\n    * 7 ethStakedOnOption\r\n    * 8 plotStakedOnOption\r\n    */\r\n    function calculateOptionPrice(uint[] memory params, address marketFeedAddress) public view returns(uint _optionPrice) {\r\n      uint _totalStaked = params[5].add(getAssetValueETH(plotToken, params[6]));\r\n      uint _assetStakedOnOption = params[7]\r\n                                .add(\r\n                                  (getAssetValueETH(plotToken, params[8])));\r\n      _optionPrice = 0;\r\n      uint currentPriceOption = 0;\r\n      uint256 currentPrice = getAssetPriceUSD(\r\n          marketFeedAddress\r\n      );\r\n      uint stakeWeightage = STAKE_WEIGHTAGE;\r\n      uint predictionWeightage = 100 - stakeWeightage;\r\n      uint predictionTime = params[4].sub(params[3]);\r\n      uint minTimeElapsed = (predictionTime).div(minTimeElapsedDivisor);\r\n      if(now > params[4]) {\r\n        return 0;\r\n      }\r\n      if(_totalStaked > STAKE_WEIGHTAGE_MIN_AMOUNT) {\r\n        _optionPrice = (_assetStakedOnOption).mul(1000000).div(_totalStaked.mul(stakeWeightage));\r\n      }\r\n\r\n      uint maxDistance;\r\n      if(currentPrice < params[1]) {\r\n        currentPriceOption = 1;\r\n        maxDistance = 2;\r\n      } else if(currentPrice > params[2]) {\r\n        currentPriceOption = 3;\r\n        maxDistance = 2;\r\n      } else {\r\n        currentPriceOption = 2;\r\n        maxDistance = 1;\r\n      }\r\n      uint distance = _getAbsoluteDifference(currentPriceOption, params[0]);\r\n      uint timeElapsed = now > params[3] ? now.sub(params[3]) : 0;\r\n      timeElapsed = timeElapsed > minTimeElapsed ? timeElapsed: minTimeElapsed;\r\n      _optionPrice = _optionPrice.add((((maxDistance+1).sub(distance)).mul(1000000).mul(timeElapsed)).div((maxDistance+1).mul(predictionWeightage).mul(predictionTime)));\r\n      _optionPrice = _optionPrice.div(100);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to get the absolute difference of two values\r\n    */\r\n    function _getAbsoluteDifference(uint value1, uint value2) internal pure returns(uint) {\r\n      return value1 > value2 ? value1.sub(value2) : value2.sub(value1);\r\n    }\r\n}\r\n\r\n// File: contracts/MarketUtilityV2.sol\r\n\r\n/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract MarketUtilityV2 is MarketUtility {\r\n\r\n  using SafeMath64 for uint64;\r\n\r\n  function setAuthorizedAddress(address _allMarketsContract) external {\r\n    require(msg.sender == initiater);\r\n    authorizedAddress = _allMarketsContract;\r\n  }\r\n\r\n  function calculateOptionRange(uint _optionRangePerc, uint64 _decimals, uint8 _roundOfToNearest, address _marketFeed) external view returns(uint64 _minValue, uint64 _maxValue) {\r\n    uint currentPrice = getAssetPriceUSD(_marketFeed);\r\n    uint optionRangePerc = currentPrice.mul(_optionRangePerc.div(2)).div(10000);\r\n    _minValue = uint64((ceil(currentPrice.sub(optionRangePerc).div(_roundOfToNearest), 10**_decimals)).mul(_roundOfToNearest));\r\n    _maxValue = uint64((ceil(currentPrice.add(optionRangePerc).div(_roundOfToNearest), 10**_decimals)).mul(_roundOfToNearest));\r\n  }\r\n\r\n  function calculatePredictionPoints(address _user, bool multiplierApplied, uint _predictionStake, address _asset, uint64 totalPredictionPoints, uint64 predictionPointsOnOption) external view returns(uint64 predictionPoints, bool isMultiplierApplied) {\r\n      uint _stakeValue = getAssetValueETH(_asset, _predictionStake.mul(1e10));\r\n      if(_stakeValue < minPredictionAmount || _stakeValue > maxPredictionAmount) {\r\n        return (0, isMultiplierApplied);\r\n      }\r\n      uint64 _optionPrice = getOptionPrice(totalPredictionPoints, predictionPointsOnOption);\r\n      predictionPoints = uint64(_stakeValue.div(1e10)).div(_optionPrice);\r\n      if(!multiplierApplied) {\r\n        uint256 _predictionPoints;\r\n        (_predictionPoints, isMultiplierApplied) = checkMultiplier(_asset, _user, _predictionStake.mul(1e10),  predictionPoints, _stakeValue);\r\n        predictionPoints = uint64(_predictionPoints);\r\n      }\r\n    }\r\n\r\n    function getOptionPrice(uint64 totalPredictionPoints, uint64 predictionPointsOnOption) public view returns(uint64 _optionPrice) {\r\n      if(totalPredictionPoints > 0) {\r\n        _optionPrice = (predictionPointsOnOption.mul(100)).div(totalPredictionPoints) + 100;\r\n      } else {\r\n        _optionPrice = 100;\r\n      }\r\n    }\r\n\r\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n        return ((a + m - 1) / m) * m;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/MarketUtilityV2_1.sol\r\n\r\n/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract MarketUtilityV2_1 is MarketUtilityV2 {\r\n    /**\r\n     * @dev Get price of provided feed address\r\n     * @param _currencyFeedAddress  Feed Address of currency on which market options are based on\r\n     * @return Current price of the market currency\r\n     **/\r\n    function getSettlemetPriceByRoundId(\r\n        address _currencyFeedAddress,\r\n        uint256 _settleTime,\r\n        uint80 _roundId\r\n    ) public view returns (uint256 latestAnswer, uint256 roundId) {\r\n        uint80 roundIdToCheck;\r\n        uint256 currentRoundTime;\r\n        int256 currentRoundAnswer;\r\n        (roundIdToCheck, currentRoundAnswer, , currentRoundTime, )= IChainLinkOracle(_currencyFeedAddress).latestRoundData();\r\n        if(roundIdToCheck == _roundId) {\r\n          if(currentRoundTime <= _settleTime) {\r\n            return (uint256(currentRoundAnswer), roundIdToCheck);\r\n          }\r\n        } else {\r\n          (roundIdToCheck, currentRoundAnswer, , currentRoundTime, )= IChainLinkOracle(_currencyFeedAddress).getRoundData(_roundId + 1);\r\n          require(currentRoundTime > _settleTime);\r\n          roundIdToCheck = _roundId + 1;\r\n        }\r\n        while(currentRoundTime > _settleTime) {\r\n            roundIdToCheck--;\r\n            (roundIdToCheck, currentRoundAnswer, , currentRoundTime, )= IChainLinkOracle(_currencyFeedAddress).getRoundData(roundIdToCheck);\r\n        }\r\n        return\r\n            (uint256(currentRoundAnswer), roundIdToCheck);\r\n    }\r\n}"
    }
  }
}