{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"/Users/Elena/Source/argent-contracts/contracts/infrastructure/IModuleRegistry.sol":{"content":"// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.7.0;\n\n/**\n * @title IModuleRegistry\n * @notice Interface for the registry of authorised modules.\n */\ninterface IModuleRegistry {\n    function registerModule(address _module, bytes32 _name) external;\n\n    function deregisterModule(address _module) external;\n\n    function registerUpgrader(address _upgrader, bytes32 _name) external;\n\n    function deregisterUpgrader(address _upgrader) external;\n\n    function recoverToken(address _token) external;\n\n    function moduleInfo(address _module) external view returns (bytes32);\n\n    function upgraderInfo(address _upgrader) external view returns (bytes32);\n\n    function isRegisteredModule(address _module) external view returns (bool);\n\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool);\n\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool);\n}"},"/Users/Elena/Source/argent-contracts/contracts/infrastructure/ITokenPriceRegistry.sol":{"content":"// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\n/**\n * @title ITokenPriceRegistry\n * @notice TokenPriceRegistry interface\n */\ninterface ITokenPriceRegistry {\n    function getTokenPrice(address _token) external view returns (uint184 _price);\n    function isTokenTradable(address _token) external view returns (bool _isTradable);\n}"},"/Users/Elena/Source/argent-contracts/contracts/infrastructure/storage/ILimitStorage.sol":{"content":"// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @title ILimitStorage\n * @notice LimitStorage interface\n */\ninterface ILimitStorage {\n\n    struct Limit {\n        // the current limit\n        uint128 current;\n        // the pending limit if any\n        uint128 pending;\n        // when the pending limit becomes the current limit\n        uint64 changeAfter;\n    }\n\n    struct DailySpent {\n        // The amount already spent during the current period\n        uint128 alreadySpent;\n        // The end of the current period\n        uint64 periodEnd;\n    }\n\n    function setLimit(address _wallet, Limit memory _limit) external;\n\n    function getLimit(address _wallet) external view returns (Limit memory _limit);\n\n    function setDailySpent(address _wallet, DailySpent memory _dailySpent) external;\n\n    function getDailySpent(address _wallet) external view returns (DailySpent memory _dailySpent);\n\n    function setLimitAndDailySpent(address _wallet, Limit memory _limit, DailySpent memory _dailySpent) external;\n\n    function getLimitAndDailySpent(address _wallet) external view returns (Limit memory _limit, DailySpent memory _dailySpent);\n}"},"/Users/Elena/Source/argent-contracts/contracts/infrastructure/storage/ILockStorage.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.7.0;\n\ninterface ILockStorage {\n    function isLocked(address _wallet) external view returns (bool);\n\n    function getLock(address _wallet) external view returns (uint256);\n\n    function getLocker(address _wallet) external view returns (address);\n\n    function setLock(address _wallet, address _locker, uint256 _releaseAfter) external;\n}"},"/Users/Elena/Source/argent-contracts/contracts/infrastructure/storage/ITransferStorage.sol":{"content":"// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.7.0;\n\n/**\n * @title ITransferStorage\n * @notice TransferStorage interface\n */\ninterface ITransferStorage {\n    function setWhitelist(address _wallet, address _target, uint256 _value) external;\n\n    function getWhitelist(address _wallet, address _target) external view returns (uint256);\n}"},"/Users/Elena/Source/argent-contracts/contracts/modules/TransferManager.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./common/Utils.sol\";\nimport \"./common/BaseTransfer.sol\";\nimport \"./common/LimitUtils.sol\";\nimport \"../infrastructure/storage/ILimitStorage.sol\";\nimport \"../infrastructure/storage/ITransferStorage.sol\";\nimport \"../infrastructure/ITokenPriceRegistry.sol\";\nimport \"../../lib/other/ERC20.sol\";\n\n/**\n * @title TransferManager\n * @notice Feature to transfer and approve tokens (ETH or ERC20) or data (contract call) based on a security context (daily limit, whitelist, etc).\n * @author Julien Niset - <julien@argent.xyz>\n */\ncontract TransferManager is BaseTransfer {\n\n    bytes32 constant NAME = \"TransferManager\";\n\n    bytes4 private constant ERC1271_ISVALIDSIGNATURE_BYTES32 = bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"));\n\n    enum ActionType { Transfer }\n\n    using SafeMath for uint256;\n\n    struct TokenManagerConfig {\n        // Mapping between pending action hash and their timestamp\n        mapping (bytes32 => uint256) pendingActions;\n    }\n\n    // wallet specific storage\n    mapping (address => TokenManagerConfig) internal configs;\n\n    // The security period\n    uint256 public securityPeriod;\n    // The execution window\n    uint256 public securityWindow;\n    // The default limit\n    uint128 public defaultLimit;\n    // The Token storage\n    ITransferStorage public transferStorage;\n    // The previous limit manager needed to migrate the limits\n    TransferManager public oldTransferManager;\n    // The limit storage\n    ILimitStorage public limitStorage;\n    // The token price storage\n    ITokenPriceRegistry public tokenPriceRegistry;\n\n    // *************** Events *************************** //\n\n    event AddedToWhitelist(address indexed wallet, address indexed target, uint64 whitelistAfter);\n    event RemovedFromWhitelist(address indexed wallet, address indexed target);\n    event PendingTransferCreated(address indexed wallet, bytes32 indexed id, uint256 indexed executeAfter,\n    address token, address to, uint256 amount, bytes data);\n    event PendingTransferExecuted(address indexed wallet, bytes32 indexed id);\n    event PendingTransferCanceled(address indexed wallet, bytes32 indexed id);\n    event DailyLimitMigrated(address indexed wallet, uint256 currentDailyLimit, uint256 pendingDailyLimit, uint256 changeDailyLimitAfter);\n    event DailyLimitDisabled(address indexed wallet, uint256 securityPeriod);\n\n    // *************** Constructor ********************** //\n\n    constructor(\n        ILockStorage _lockStorage,\n        ITransferStorage _transferStorage,\n        ILimitStorage _limitStorage,\n        ITokenPriceRegistry _tokenPriceRegistry,\n        IVersionManager _versionManager,\n        uint256 _securityPeriod,\n        uint256 _securityWindow,\n        uint256 _defaultLimit,\n        address _wethToken,\n        TransferManager _oldTransferManager\n    )\n        BaseFeature(_lockStorage, _versionManager, NAME)\n        BaseTransfer(_wethToken)\n        public\n    {\n        transferStorage = _transferStorage;\n        limitStorage = _limitStorage;\n        tokenPriceRegistry = _tokenPriceRegistry;\n        securityPeriod = _securityPeriod;\n        securityWindow = _securityWindow;\n        defaultLimit = LimitUtils.safe128(_defaultLimit);\n        oldTransferManager = _oldTransferManager;\n    }\n\n    /**\n     * @inheritdoc IFeature\n     */\n    function getRequiredSignatures(address, bytes calldata) external view override returns (uint256, OwnerSignature) {\n        return (1, OwnerSignature.Required);\n    }\n\n    /**\n     * @inheritdoc IFeature\n     */\n    function getStaticCallSignatures() external virtual override view returns (bytes4[] memory _sigs) {\n        _sigs = new bytes4[](1);\n        _sigs[0] = ERC1271_ISVALIDSIGNATURE_BYTES32;\n    }\n\n\n    /**\n     * @notice Inits the feature for a wallet by setting up the isValidSignature (EIP 1271)\n     * static call redirection from the wallet to the feature and copying all the parameters\n     * of the daily limit from the previous implementation of the LimitManager module.\n     * @param _wallet The target wallet.\n     */\n    function init(address _wallet) external override(BaseFeature) onlyVersionManager {\n\n        if (address(oldTransferManager) == address(0)) {\n            setLimit(_wallet, ILimitStorage.Limit(defaultLimit, 0, 0));\n        } else {\n            uint256 current = oldTransferManager.getCurrentLimit(_wallet);\n            (uint256 pending, uint64 changeAfter) = oldTransferManager.getPendingLimit(_wallet);\n            if (current == 0 && changeAfter == 0) {\n                // new wallet: we setup the default limit\n                setLimit(_wallet, ILimitStorage.Limit(defaultLimit, 0, 0));\n            } else {\n                // migrate limit and daily spent (if we are in a rolling period)\n                (uint256 unspent, uint64 periodEnd) = oldTransferManager.getDailyUnspent(_wallet);\n\n                if (periodEnd < block.timestamp) {\n                    setLimit(_wallet, ILimitStorage.Limit(LimitUtils.safe128(current), LimitUtils.safe128(pending), changeAfter));\n                } else {\n                    setLimitAndDailySpent(\n                        _wallet,\n                        ILimitStorage.Limit(LimitUtils.safe128(current), LimitUtils.safe128(pending), changeAfter),\n                        ILimitStorage.DailySpent(LimitUtils.safe128(current.sub(unspent)), periodEnd)\n                    );\n                }\n\n                emit DailyLimitMigrated(_wallet, current, pending, changeAfter);\n            }\n        }\n    }\n\n    // *************** External/Public Functions ********************* //\n\n    /**\n    * @notice Lets the owner transfer tokens (ETH or ERC20) from a wallet.\n    * @param _wallet The target wallet.\n    * @param _token The address of the token to transfer.\n    * @param _to The destination address\n    * @param _amount The amoutn of token to transfer\n    * @param _data The data for the transaction\n    */\n    function transferToken(\n        address _wallet,\n        address _token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        if (isWhitelisted(_wallet, _to)) {\n            // transfer to whitelist\n            doTransfer(_wallet, _token, _to, _amount, _data);\n        } else {\n            uint256 etherAmount = (_token == ETH_TOKEN) ? _amount : LimitUtils.getEtherValue(tokenPriceRegistry, _amount, _token);\n            if (LimitUtils.checkAndUpdateDailySpent(limitStorage, versionManager, _wallet, etherAmount)) {\n                // transfer under the limit\n                doTransfer(_wallet, _token, _to, _amount, _data);\n            } else {\n                // transfer above the limit\n                (bytes32 id, uint256 executeAfter) = addPendingAction(ActionType.Transfer, _wallet, _token, _to, _amount, _data);\n                emit PendingTransferCreated(_wallet, id, executeAfter, _token, _to, _amount, _data);\n            }\n        }\n    }\n\n    /**\n    * @notice Lets the owner approve an allowance of ERC20 tokens for a spender (dApp).\n    * @param _wallet The target wallet.\n    * @param _token The address of the token to transfer.\n    * @param _spender The address of the spender\n    * @param _amount The amount of tokens to approve\n    */\n    function approveToken(\n        address _wallet,\n        address _token,\n        address _spender,\n        uint256 _amount\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        if (isWhitelisted(_wallet, _spender)) {\n            // approve to whitelist\n            doApproveToken(_wallet, _token, _spender, _amount);\n        } else {\n            // get current alowance\n            uint256 currentAllowance = ERC20(_token).allowance(_wallet, _spender);\n            if (_amount <= currentAllowance) {\n                // approve if we reduce the allowance\n                doApproveToken(_wallet, _token, _spender, _amount);\n            } else {\n                // check if delta is under the limit\n                uint delta = _amount - currentAllowance;\n                uint256 deltaInEth = LimitUtils.getEtherValue(tokenPriceRegistry, delta, _token);\n                require(LimitUtils.checkAndUpdateDailySpent(limitStorage, versionManager, _wallet, deltaInEth), \"TM: Approve above daily limit\");\n                // approve if under the limit\n                doApproveToken(_wallet, _token, _spender, _amount);\n            }\n        }\n    }\n\n    /**\n    * @notice Lets the owner call a contract.\n    * @param _wallet The target wallet.\n    * @param _contract The address of the contract.\n    * @param _value The amount of ETH to transfer as part of call\n    * @param _data The encoded method data\n    */\n    function callContract(\n        address _wallet,\n        address _contract,\n        uint256 _value,\n        bytes calldata _data\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n        onlyAuthorisedContractCall(_wallet, _contract)\n    {\n        checkAndUpdateDailySpentIfNeeded(_wallet, ETH_TOKEN, _value, _contract);\n        doCallContract(_wallet, _contract, _value, _data);\n    }\n\n    /**\n    * @notice Lets the owner do an ERC20 approve followed by a call to a contract.\n    * We assume that the contract will pull the tokens and does not require ETH.\n    * @param _wallet The target wallet.\n    * @param _token The token to approve.\n    * @param _proxy The address to approve, which may be different from the contract being called.\n    * @param _amount The amount of ERC20 tokens to approve.\n    * @param _contract The address of the contract.\n    * @param _data The encoded method data\n    */\n    function approveTokenAndCallContract(\n        address _wallet,\n        address _token,\n        address _proxy,\n        uint256 _amount,\n        address _contract,\n        bytes calldata _data\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n        onlyAuthorisedContractCall(_wallet, _contract)\n    {\n        checkAndUpdateDailySpentIfNeeded(_wallet, _token, _amount, _contract);\n        doApproveTokenAndCallContract(_wallet, _token, _proxy, _amount, _contract, _data);\n    }\n\n    /**\n    * @notice Lets the owner wrap ETH into WETH, approve the WETH and call a contract.\n    * We assume that the contract will pull the tokens and does not require ETH.\n    * @param _wallet The target wallet.\n    * @param _proxy The address to approve, which may be different from the contract being called.\n    * @param _amount The amount of ETH to wrap and approve.\n    * @param _contract The address of the contract.\n    * @param _data The encoded method data\n    */\n    function approveWethAndCallContract(\n        address _wallet,\n        address _proxy,\n        uint256 _amount,\n        address _contract,\n        bytes calldata _data\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n        onlyAuthorisedContractCall(_wallet, _contract)\n    {\n        checkAndUpdateDailySpentIfNeeded(_wallet, wethToken, _amount, _contract);\n        doApproveWethAndCallContract(_wallet, _proxy, _amount, _contract, _data);\n    }\n\n    /**\n     * @notice Adds an address to the whitelist of a wallet.\n     * @param _wallet The target wallet.\n     * @param _target The address to add.\n     */\n    function addToWhitelist(\n        address _wallet,\n        address _target\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        require(!isWhitelisted(_wallet, _target), \"TT: target already whitelisted\");\n\n        uint256 whitelistAfter = block.timestamp.add(securityPeriod);\n        setWhitelist(_wallet, _target, whitelistAfter);\n        emit AddedToWhitelist(_wallet, _target, uint64(whitelistAfter));\n    }\n\n    /**\n     * @notice Removes an address from the whitelist of a wallet.\n     * @param _wallet The target wallet.\n     * @param _target The address to remove.\n     */\n    function removeFromWhitelist(\n        address _wallet,\n        address _target\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        setWhitelist(_wallet, _target, 0);\n        emit RemovedFromWhitelist(_wallet, _target);\n    }\n\n    /**\n    * @notice Executes a pending transfer for a wallet.\n    * The method can be called by anyone to enable orchestration.\n    * @param _wallet The target wallet.\n    * @param _token The token of the pending transfer.\n    * @param _to The destination address of the pending transfer.\n    * @param _amount The amount of token to transfer of the pending transfer.\n    * @param _data The data associated to the pending transfer.\n    * @param _block The block at which the pending transfer was created.\n    */\n    function executePendingTransfer(\n        address _wallet,\n        address _token,\n        address _to,\n        uint _amount,\n        bytes calldata _data,\n        uint _block\n    )\n        external\n        onlyWhenUnlocked(_wallet)\n    {\n        bytes32 id = keccak256(abi.encodePacked(ActionType.Transfer, _token, _to, _amount, _data, _block));\n        uint executeAfter = configs[_wallet].pendingActions[id];\n        require(executeAfter > 0, \"TT: unknown pending transfer\");\n        uint executeBefore = executeAfter.add(securityWindow);\n\n        require(executeAfter <= block.timestamp && block.timestamp <= executeBefore, \"TT: transfer outside of the execution window\");\n        delete configs[_wallet].pendingActions[id];\n        doTransfer(_wallet, _token, _to, _amount, _data);\n        emit PendingTransferExecuted(_wallet, id);\n    }\n\n    function cancelPendingTransfer(\n        address _wallet,\n        bytes32 _id\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        require(configs[_wallet].pendingActions[_id] > 0, \"TT: unknown pending action\");\n        delete configs[_wallet].pendingActions[_id];\n        emit PendingTransferCanceled(_wallet, _id);\n    }\n\n    /**\n     * @notice Lets the owner of a wallet change its daily limit.\n     * The limit is expressed in ETH. Changes to the limit take 24 hours.\n     * @param _wallet The target wallet.\n     * @param _newLimit The new limit.\n     */\n    function changeLimit(address _wallet, uint256 _newLimit) external onlyWalletOwnerOrFeature(_wallet) onlyWhenUnlocked(_wallet) {\n        ILimitStorage.Limit memory limit = LimitUtils.changeLimit(limitStorage, versionManager, _wallet, _newLimit, securityPeriod);\n        emit LimitChanged(_wallet, _newLimit, limit.changeAfter);\n    }\n\n    /**\n     * @notice Convenience method to disable the limit\n     * The limit is disabled by setting it to an arbitrary large value.\n     * @param _wallet The target wallet.\n     */\n    function disableLimit(address _wallet) external onlyWalletOwnerOrFeature(_wallet) onlyWhenUnlocked(_wallet) {\n        LimitUtils.disableLimit(limitStorage, versionManager, _wallet, securityPeriod);\n        emit DailyLimitDisabled(_wallet, securityPeriod);\n    }\n\n    /**\n    * @notice Gets the current daily limit for a wallet.\n    * @param _wallet The target wallet.\n    * @return _currentLimit The current limit expressed in ETH.\n    */\n    function getCurrentLimit(address _wallet) external view returns (uint256 _currentLimit) {\n        ILimitStorage.Limit memory limit = limitStorage.getLimit(_wallet);\n        return LimitUtils.currentLimit(limit);\n    }\n\n    /**\n    * @notice Returns whether the daily limit is disabled for a wallet.\n    * @param _wallet The target wallet.\n    * @return _limitDisabled true if the daily limit is disabled, false otherwise.\n    */\n    function isLimitDisabled(address _wallet) public view returns (bool _limitDisabled) {\n        return LimitUtils.isLimitDisabled(limitStorage, _wallet);\n    }\n\n    /**\n    * @notice Gets a pending limit for a wallet if any.\n    * @param _wallet The target wallet.\n    * @return _pendingLimit The pending limit (in ETH).\n    * @return _changeAfter The time at which the pending limit will become effective.\n    */\n    function getPendingLimit(address _wallet) external view returns (uint256 _pendingLimit, uint64 _changeAfter) {\n        ILimitStorage.Limit memory limit = limitStorage.getLimit(_wallet);\n\n        return ((block.timestamp < limit.changeAfter)? (limit.pending, uint64(limit.changeAfter)) : (0,0));\n    }\n\n    /**\n    * @notice Gets the amount of tokens that has not yet been spent during the current period.\n    * @param _wallet The target wallet.\n    * @return _unspent The amount of tokens (in ETH) that has not been spent yet.\n    * @return _periodEnd The end of the daily period.\n    */\n    function getDailyUnspent(address _wallet) external view returns (uint256 _unspent, uint64 _periodEnd) {\n        (\n            ILimitStorage.Limit memory limit,\n            ILimitStorage.DailySpent memory dailySpent\n        ) = limitStorage.getLimitAndDailySpent(_wallet);\n        uint256 currentLimit = LimitUtils.currentLimit(limit);\n\n        if (block.timestamp > dailySpent.periodEnd) {\n            return (currentLimit, uint64(block.timestamp.add(24 hours)));\n        } else if (dailySpent.alreadySpent < currentLimit) {\n            return (currentLimit.sub(dailySpent.alreadySpent), dailySpent.periodEnd);\n        } else {\n            return (0, dailySpent.periodEnd);\n        }\n    }\n\n    /**\n    * @notice Checks if an address is whitelisted for a wallet.\n    * @param _wallet The target wallet.\n    * @param _target The address.\n    * @return _isWhitelisted true if the address is whitelisted.\n    */\n    function isWhitelisted(address _wallet, address _target) public view returns (bool _isWhitelisted) {\n        uint whitelistAfter = transferStorage.getWhitelist(_wallet, _target);\n        \n        return whitelistAfter > 0 && whitelistAfter < block.timestamp;\n    }\n\n    /**\n    * @notice Gets the info of a pending transfer for a wallet.\n    * @param _wallet The target wallet.\n    * @param _id The pending transfer ID.\n    * @return _executeAfter The epoch time at which the pending transfer can be executed.\n    */\n    function getPendingTransfer(address _wallet, bytes32 _id) external view returns (uint64 _executeAfter) {\n        _executeAfter = uint64(configs[address(_wallet)].pendingActions[_id]);\n    }\n\n    /**\n    * @notice Implementation of EIP 1271.\n    * Should return whether the signature provided is valid for the provided data.\n    * @param _msgHash Hash of a message signed on the behalf of address(this)\n    * @param _signature Signature byte array associated with _msgHash\n    */\n    function isValidSignature(bytes32 _msgHash, bytes memory _signature) public view returns (bytes4) {\n        require(_signature.length == 65, \"TM: invalid signature length\");\n        address signer = Utils.recoverSigner(_msgHash, _signature, 0);\n        require(isOwner(msg.sender, signer), \"TM: Invalid signer\");\n        return ERC1271_ISVALIDSIGNATURE_BYTES32;\n    }\n\n    // *************** Internal Functions ********************* //\n\n    /**\n     * @notice Creates a new pending action for a wallet.\n     * @param _action The target action.\n     * @param _wallet The target wallet.\n     * @param _token The target token for the action.\n     * @param _to The recipient of the action.\n     * @param _amount The amount of token associated to the action.\n     * @param _data The data associated to the action.\n     * @return id The identifier for the new pending action.\n     * @return executeAfter The time when the action can be executed\n     */\n    function addPendingAction(\n        ActionType _action,\n        address _wallet,\n        address _token,\n        address _to,\n        uint _amount,\n        bytes memory _data\n    )\n        internal\n        returns (bytes32 id, uint256 executeAfter)\n    {\n        id = keccak256(abi.encodePacked(_action, _token, _to, _amount, _data, block.number));\n        require(configs[_wallet].pendingActions[id] == 0, \"TM: duplicate pending action\");\n\n        executeAfter = block.timestamp.add(securityPeriod);\n        configs[_wallet].pendingActions[id] = executeAfter;\n    }\n\n    /**\n    * @notice Make sure a contract call is not trying to call a supported ERC20.\n    * @param _wallet The target wallet.\n    * @param _contract The address of the contract.\n     */\n    function coveredByDailyLimit(address _wallet, address _contract) internal view returns (bool) {\n        return (tokenPriceRegistry.getTokenPrice(_contract) > 0 && !isLimitDisabled(_wallet));\n    }\n\n    /**\n    * @notice Verify and update the daily spent if the spender is not whitelisted.\n    * Reverts if the daily spent is insufficient or if the contract to call is\n    * protected by the daily limit (i.e. is a token contract).\n    * @param _wallet The target wallet.\n    * @param _token The token that the spender will spend.\n    * @param _amount The amount of ERC20 or ETH that the spender will spend.\n    * @param _contract The address of the contract called by the wallet for the spend to occur.\n    */\n\n    function checkAndUpdateDailySpentIfNeeded(\n        address _wallet,\n        address _token,\n        uint256 _amount,\n        address _contract\n    )\n        internal\n    {\n        if (!isWhitelisted(_wallet, _contract)) {\n            // Make sure we don't call a supported ERC20 that's not whitelisted\n            require(!coveredByDailyLimit(_wallet, _contract), \"TM: Forbidden contract\");\n\n            // Check if the amount is under the daily limit.\n            // Check the entire amount because the currently approved amount will be restored and should still count towards the daily limit\n            uint256 valueInEth;\n            if (_token == ETH_TOKEN || _token == wethToken) {\n                valueInEth = _amount;\n            } else {\n                valueInEth = LimitUtils.getEtherValue(tokenPriceRegistry, _amount, _token);\n            }\n            require(LimitUtils.checkAndUpdateDailySpent(limitStorage, versionManager, _wallet, valueInEth), \"TM: Approve above daily limit\");\n        }\n    }\n\n    // *************** Internal Functions ********************* //\n\n    function setWhitelist(address _wallet, address _target, uint256 _whitelistAfter) internal {\n        versionManager.invokeStorage(\n            _wallet,\n            address(transferStorage),\n            abi.encodeWithSelector(transferStorage.setWhitelist.selector, _wallet, _target, _whitelistAfter)\n        );\n    }\n\n    function setLimit(address _wallet, ILimitStorage.Limit memory _limit) internal {\n        versionManager.invokeStorage(\n            _wallet,\n            address(limitStorage),\n            abi.encodeWithSelector(limitStorage.setLimit.selector, _wallet, _limit)\n        );\n    }\n\n    function setLimitAndDailySpent(\n        address _wallet,\n        ILimitStorage.Limit memory _limit,\n        ILimitStorage.DailySpent memory _dailySpent\n    ) internal {\n        versionManager.invokeStorage(\n            _wallet,\n            address(limitStorage),\n            abi.encodeWithSelector(limitStorage.setLimitAndDailySpent.selector, _wallet, _limit, _dailySpent)\n        );\n    }\n}\n"},"/Users/Elena/Source/argent-contracts/contracts/modules/common/BaseFeature.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.s\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../wallet/IWallet.sol\";\nimport \"../../infrastructure/IModuleRegistry.sol\";\nimport \"../../infrastructure/storage/ILockStorage.sol\";\nimport \"./IFeature.sol\";\nimport \"../../../lib/other/ERC20.sol\";\nimport \"./IVersionManager.sol\";\n\n/**\n * @title BaseFeature\n * @notice Base Feature contract that contains methods common to all Feature contracts.\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\n */\ncontract BaseFeature is IFeature {\n\n    // Empty calldata\n    bytes constant internal EMPTY_BYTES = \"\";\n    // Mock token address for ETH\n    address constant internal ETH_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    // The address of the Lock storage\n    ILockStorage internal lockStorage;\n    // The address of the Version Manager\n    IVersionManager internal versionManager;\n\n    event FeatureCreated(bytes32 name);\n\n    /**\n     * @notice Throws if the wallet is locked.\n     */\n    modifier onlyWhenUnlocked(address _wallet) {\n        require(!lockStorage.isLocked(_wallet), \"BF: wallet locked\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not the VersionManager.\n     */\n    modifier onlyVersionManager() {\n        require(msg.sender == address(versionManager), \"BF: caller must be VersionManager\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not the owner of the target wallet.\n     */\n    modifier onlyWalletOwner(address _wallet) {\n        require(isOwner(_wallet, msg.sender), \"BF: must be wallet owner\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not an authorised feature of the target wallet.\n     */\n    modifier onlyWalletFeature(address _wallet) {\n        require(versionManager.isFeatureAuthorised(_wallet, msg.sender), \"BF: must be a wallet feature\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not the owner of the target wallet or the feature itself.\n     */\n    modifier onlyWalletOwnerOrFeature(address _wallet) {\n        // Wrapping in an internal method reduces deployment cost by avoiding duplication of inlined code\n        verifyOwnerOrAuthorisedFeature(_wallet, msg.sender);\n        _;\n    }\n\n    constructor(\n        ILockStorage _lockStorage,\n        IVersionManager _versionManager,\n        bytes32 _name\n    ) public {\n        lockStorage = _lockStorage;\n        versionManager = _versionManager;\n        emit FeatureCreated(_name);\n    }\n\n    /**\n    * @inheritdoc IFeature\n    */\n    function recoverToken(address _token) external virtual override {\n        uint total = ERC20(_token).balanceOf(address(this));\n        _token.call(abi.encodeWithSelector(ERC20(_token).transfer.selector, address(versionManager), total));\n    }\n\n    /**\n     * @notice Inits the feature for a wallet by doing nothing.\n     * @dev !! Overriding methods need make sure `init()` can only be called by the VersionManager !!\n     * @param _wallet The wallet.\n     */\n    function init(address _wallet) external virtual override  {}\n\n    /**\n     * @inheritdoc IFeature\n     */\n    function getRequiredSignatures(address, bytes calldata) external virtual view override returns (uint256, OwnerSignature) {\n        revert(\"BF: disabled method\");\n    }\n\n    /**\n     * @inheritdoc IFeature\n     */\n    function getStaticCallSignatures() external virtual override view returns (bytes4[] memory _sigs) {}\n\n    /**\n     * @inheritdoc IFeature\n     */\n    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) public override view returns (bool) {\n        return versionManager.isFeatureAuthorised(_wallet, _feature);\n    }\n\n    /**\n    * @notice Checks that the wallet address provided as the first parameter of _data matches _wallet\n    * @return false if the addresses are different.\n    */\n    function verifyData(address _wallet, bytes calldata _data) internal pure returns (bool) {\n        require(_data.length >= 36, \"RM: Invalid dataWallet\");\n        address dataWallet = abi.decode(_data[4:], (address));\n        return dataWallet == _wallet;\n    }\n    \n     /**\n     * @notice Helper method to check if an address is the owner of a target wallet.\n     * @param _wallet The target wallet.\n     * @param _addr The address.\n     */\n    function isOwner(address _wallet, address _addr) internal view returns (bool) {\n        return IWallet(_wallet).owner() == _addr;\n    }\n\n    /**\n     * @notice Verify that the caller is an authorised feature or the wallet owner.\n     * @param _wallet The target wallet.\n     * @param _sender The caller.\n     */\n    function verifyOwnerOrAuthorisedFeature(address _wallet, address _sender) internal view {\n        require(isFeatureAuthorisedInVersionManager(_wallet, _sender) || isOwner(_wallet, _sender), \"BF: must be owner or feature\");\n    }\n\n    /**\n     * @notice Helper method to invoke a wallet.\n     * @param _wallet The target wallet.\n     * @param _to The target address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data)\n        internal\n        returns (bytes memory _res) \n    {\n        _res = versionManager.checkAuthorisedFeatureAndInvokeWallet(_wallet, _to, _value, _data);\n    }\n\n}"},"/Users/Elena/Source/argent-contracts/contracts/modules/common/BaseTransfer.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\nimport \"./BaseFeature.sol\";\nimport \"./LimitUtils.sol\";\n\n/**\n * @title BaseTransfer\n * @notice Contains common methods to transfer tokens or call third-party contracts.\n * @author Olivier VDB - <olivier@argent.xyz>\n */\nabstract contract BaseTransfer is BaseFeature {\n\n    // The address of the WETH token\n    address public wethToken;\n\n    // *************** Events *************************** //\n\n    event Transfer(address indexed wallet, address indexed token, uint256 indexed amount, address to, bytes data);\n    event Approved(address indexed wallet, address indexed token, uint256 amount, address spender);\n    event CalledContract(address indexed wallet, address indexed to, uint256 amount, bytes data);\n    event ApprovedAndCalledContract(\n        address indexed wallet,\n        address indexed to,\n        address spender,\n        address indexed token,\n        uint256 amountApproved,\n        uint256 amountSpent,\n        bytes data\n    );\n    event LimitChanged(address indexed wallet, uint indexed newLimit, uint64 indexed startAfter);\n\n\n    // *************** Constructor ********************** //\n\n    constructor(address _wethToken) public {\n        wethToken = _wethToken;\n    }\n\n            \n    // *************** Internal Functions ********************* //\n    /**\n    * @notice Make sure a contract call is not trying to call a module, a feature, or the wallet itself.\n    * @param _wallet The target wallet.\n    * @param _contract The address of the contract.\n     */\n    modifier onlyAuthorisedContractCall(address _wallet, address _contract) {\n        require(\n            _contract != _wallet && // not calling the wallet\n            !IWallet(_wallet).authorised(_contract) && // not calling an authorised module\n            !versionManager.isFeatureAuthorised(_wallet, _contract), // not calling an authorised feature\n            \"BT: Forbidden contract\"\n        );\n        _;\n    }\n\n    /**\n    * @notice Helper method to transfer ETH or ERC20 for a wallet.\n    * @param _wallet The target wallet.\n    * @param _token The ERC20 address.\n    * @param _to The recipient.\n    * @param _value The amount of ETH to transfer\n    * @param _data The data to *log* with the transfer.\n    */\n    function doTransfer(address _wallet, address _token, address _to, uint256 _value, bytes memory _data) internal {\n        if (_token == ETH_TOKEN) {\n            invokeWallet(_wallet, _to, _value, EMPTY_BYTES);\n        } else {\n            bytes memory methodData = abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _value);\n            bytes memory transferSuccessBytes = invokeWallet(_wallet, _token, 0, methodData);\n            // Check transfer is successful, when `transfer` returns a success bool result\n            if (transferSuccessBytes.length > 0) {\n                require(abi.decode(transferSuccessBytes, (bool)), \"RM: Transfer failed\");\n            }\n        }\n        emit Transfer(_wallet, _token, _value, _to, _data);\n    }\n\n    /**\n    * @notice Helper method to approve spending the ERC20 of a wallet.\n    * @param _wallet The target wallet.\n    * @param _token The ERC20 address.\n    * @param _spender The spender address.\n    * @param _value The amount of token to transfer.\n    */\n    function doApproveToken(address _wallet, address _token, address _spender, uint256 _value) internal {\n        bytes memory methodData = abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _value);\n        invokeWallet(_wallet, _token, 0, methodData);\n        emit Approved(_wallet, _token, _value, _spender);\n    }\n\n    /**\n    * @notice Helper method to call an external contract.\n    * @param _wallet The target wallet.\n    * @param _contract The contract address.\n    * @param _value The ETH value to transfer.\n    * @param _data The method data.\n    */\n    function doCallContract(address _wallet, address _contract, uint256 _value, bytes memory _data) internal {\n        invokeWallet(_wallet, _contract, _value, _data);\n        emit CalledContract(_wallet, _contract, _value, _data);\n    }\n\n    /**\n    * @notice Helper method to approve a certain amount of token and call an external contract.\n    * The address that spends the _token and the address that is called with _data can be different.\n    * @param _wallet The target wallet.\n    * @param _token The ERC20 address.\n    * @param _proxy The address to approve.\n    * @param _amount The amount of tokens to transfer.\n    * @param _contract The contract address.\n    * @param _data The method data.\n    */\n    function doApproveTokenAndCallContract(\n        address _wallet,\n        address _token,\n        address _proxy,\n        uint256 _amount,\n        address _contract,\n        bytes memory _data\n    )\n        internal\n    {\n        // Ensure there is sufficient balance of token before we approve\n        uint256 balance = ERC20(_token).balanceOf(_wallet);\n        require(balance >= _amount, \"BT: insufficient balance\");\n\n        uint256 existingAllowance = ERC20(_token).allowance(_wallet, _proxy);\n        uint256 totalAllowance = SafeMath.add(existingAllowance, _amount);\n        // Approve the desired amount plus existing amount. This logic allows for potential gas saving later\n        // when restoring the original approved amount, in cases where the _proxy uses the exact approved _amount.\n        bytes memory methodData = abi.encodeWithSignature(\"approve(address,uint256)\", _proxy, totalAllowance);\n\n        invokeWallet(_wallet, _token, 0, methodData);\n        invokeWallet(_wallet, _contract, 0, _data);\n\n        // Calculate the approved amount that was spent after the call\n        uint256 unusedAllowance = ERC20(_token).allowance(_wallet, _proxy);\n        uint256 usedAllowance = SafeMath.sub(totalAllowance, unusedAllowance);\n        // Ensure the amount spent does not exceed the amount approved for this call\n        require(usedAllowance <= _amount, \"BT: insufficient amount for call\");\n\n        if (unusedAllowance != existingAllowance) {\n            // Restore the original allowance amount if the amount spent was different (can be lower).\n            methodData = abi.encodeWithSignature(\"approve(address,uint256)\", _proxy, existingAllowance);\n            invokeWallet(_wallet, _token, 0, methodData);\n        }\n\n        emit ApprovedAndCalledContract(\n            _wallet,\n            _contract,\n            _proxy,\n            _token,\n            _amount,\n            usedAllowance,\n            _data);\n    }\n\n    /**\n    * @notice Helper method to wrap ETH into WETH, approve a certain amount of WETH and call an external contract.\n    * The address that spends the WETH and the address that is called with _data can be different.\n    * @param _wallet The target wallet.\n    * @param _proxy The address to approves.\n    * @param _amount The amount of tokens to transfer.\n    * @param _contract The contract address.\n    * @param _data The method data.\n    */\n    function doApproveWethAndCallContract(\n        address _wallet,\n        address _proxy,\n        uint256 _amount,\n        address _contract,\n        bytes memory _data\n    )\n        internal\n    {\n        uint256 wethBalance = ERC20(wethToken).balanceOf(_wallet);\n        if (wethBalance < _amount) {\n            // Wrap ETH into WETH\n            invokeWallet(_wallet, wethToken, _amount - wethBalance, abi.encodeWithSignature(\"deposit()\"));\n        }\n\n        doApproveTokenAndCallContract(_wallet, wethToken, _proxy, _amount, _contract, _data);\n    }\n}\n"},"/Users/Elena/Source/argent-contracts/contracts/modules/common/IFeature.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.7.0;\n\n/**\n * @title IFeature\n * @notice Interface for a Feature.\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\n */\ninterface IFeature {\n\n    enum OwnerSignature {\n        Anyone,             // Anyone\n        Required,           // Owner required\n        Optional,           // Owner and/or guardians\n        Disallowed          // guardians only\n    }\n\n    /**\n    * @notice Utility method to recover any ERC20 token that was sent to the Feature by mistake.\n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external;\n\n    /**\n     * @notice Inits a Feature for a wallet by e.g. setting some wallet specific parameters in storage.\n     * @param _wallet The wallet.\n     */\n    function init(address _wallet) external;\n\n    /**\n     * @notice Helper method to check if an address is an authorised feature of a target wallet.\n     * @param _wallet The target wallet.\n     * @param _feature The address.\n     */\n    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) external view returns (bool);\n\n    /**\n    * @notice Gets the number of valid signatures that must be provided to execute a\n    * specific relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _data The data of the relayed transaction.\n    * @return The number of required signatures and the wallet owner signature requirement.\n    */\n    function getRequiredSignatures(address _wallet, bytes calldata _data) external view returns (uint256, OwnerSignature);\n\n    /**\n    * @notice Gets the list of static call signatures that this feature responds to on behalf of wallets\n    */\n    function getStaticCallSignatures() external view returns (bytes4[] memory);\n}"},"/Users/Elena/Source/argent-contracts/contracts/modules/common/IVersionManager.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../infrastructure/storage/ILimitStorage.sol\";\n\n/**\n * @title IVersionManager\n * @notice Interface for the VersionManager module.\n * @author Olivier VDB - <olivier@argent.xyz>\n */\ninterface IVersionManager {\n    /**\n     * @notice Returns true if the feature is authorised for the wallet\n     * @param _wallet The target wallet.\n     * @param _feature The feature.\n     */\n    function isFeatureAuthorised(address _wallet, address _feature) external view returns (bool);\n\n    /**\n     * @notice Lets a feature (caller) invoke a wallet.\n     * @param _wallet The target wallet.\n     * @param _to The target address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function checkAuthorisedFeatureAndInvokeWallet(\n        address _wallet,\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes memory _res);\n\n    /* ******* Backward Compatibility with old Storages and BaseWallet *************** */\n\n    /**\n     * @notice Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _wallet, address _newOwner) external;\n\n    /**\n     * @notice Lets a feature write data to a storage contract.\n     * @param _wallet The target wallet.\n     * @param _storage The storage contract.\n     * @param _data The data of the call\n     */\n    function invokeStorage(address _wallet, address _storage, bytes calldata _data) external;\n\n    /**\n     * @notice Upgrade a wallet to a new version.\n     * @param _wallet the wallet to upgrade\n     * @param _toVersion the new version\n     */\n    function upgradeWallet(address _wallet, uint256 _toVersion) external;\n \n}"},"/Users/Elena/Source/argent-contracts/contracts/modules/common/LimitUtils.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../infrastructure/storage/ILimitStorage.sol\";\nimport \"../../infrastructure/ITokenPriceRegistry.sol\";\nimport \"./IVersionManager.sol\";\n\n/**\n * @title LimitUtils\n * @notice Helper library to manage the daily limit and interact with a contract implementing the ILimitStorage interface.\n * @author Julien Niset - <julien@argent.xyz>\n */\nlibrary LimitUtils {\n\n    // large limit when the limit can be considered disabled\n    uint128 constant internal LIMIT_DISABLED = uint128(-1);\n\n    using SafeMath for uint256;\n\n    // *************** Internal Functions ********************* //\n\n    /**\n     * @notice Changes the daily limit (expressed in ETH).\n     * Decreasing the limit is immediate while increasing the limit is pending for the security period.\n     * @param _lStorage The storage contract.\n     * @param _versionManager The version manager.\n     * @param _wallet The target wallet.\n     * @param _targetLimit The target limit.\n     * @param _securityPeriod The security period.\n     */\n    function changeLimit(\n        ILimitStorage _lStorage,\n        IVersionManager _versionManager,\n        address _wallet,\n        uint256 _targetLimit,\n        uint256 _securityPeriod\n    )\n        internal\n        returns (ILimitStorage.Limit memory)\n    {\n        ILimitStorage.Limit memory limit = _lStorage.getLimit(_wallet);\n        uint256 currentLimit = currentLimit(limit);\n        ILimitStorage.Limit memory newLimit;\n        if (_targetLimit <= currentLimit) {\n            uint128 targetLimit = safe128(_targetLimit);\n            newLimit = ILimitStorage.Limit(targetLimit, targetLimit, safe64(block.timestamp));\n        } else {\n            newLimit = ILimitStorage.Limit(safe128(currentLimit), safe128(_targetLimit), safe64(block.timestamp.add(_securityPeriod)));\n        }\n        setLimit(_versionManager, _lStorage, _wallet, newLimit);\n        return newLimit;\n    }\n\n     /**\n     * @notice Disable the daily limit.\n     * The change is pending for the security period.\n     * @param _lStorage The storage contract.\n     * @param _versionManager The version manager.\n     * @param _wallet The target wallet.\n     * @param _securityPeriod The security period.\n     */\n    function disableLimit(\n        ILimitStorage _lStorage,\n        IVersionManager _versionManager,\n        address _wallet,\n        uint256 _securityPeriod\n    )\n        internal\n    {\n        changeLimit(_lStorage, _versionManager, _wallet, LIMIT_DISABLED, _securityPeriod);\n    }\n\n    /**\n    * @notice Returns whether the daily limit is disabled for a wallet.\n    * @param _wallet The target wallet.\n    * @return _limitDisabled true if the daily limit is disabled, false otherwise.\n    */\n    function isLimitDisabled(ILimitStorage _lStorage, address _wallet) internal view returns (bool) {\n        ILimitStorage.Limit memory limit = _lStorage.getLimit(_wallet);\n        uint256 currentLimit = currentLimit(limit);\n        return (currentLimit == LIMIT_DISABLED);\n    }\n\n    /**\n    * @notice Checks if a transfer is within the limit. If yes the daily spent is updated.\n    * @param _lStorage The storage contract.\n    * @param _versionManager The Version Manager.\n    * @param _wallet The target wallet.\n    * @param _amount The amount for the transfer\n    * @return true if the transfer is withing the daily limit.\n    */\n    function checkAndUpdateDailySpent(\n        ILimitStorage _lStorage,\n        IVersionManager _versionManager,\n        address _wallet,\n        uint256 _amount\n    )\n        internal\n        returns (bool)\n    {\n        (ILimitStorage.Limit memory limit, ILimitStorage.DailySpent memory dailySpent) = _lStorage.getLimitAndDailySpent(_wallet);\n        uint256 currentLimit = currentLimit(limit);\n        if (_amount == 0 || currentLimit == LIMIT_DISABLED) {\n            return true;\n        }\n        ILimitStorage.DailySpent memory newDailySpent;\n        if (dailySpent.periodEnd <= block.timestamp && _amount <= currentLimit) {\n            newDailySpent = ILimitStorage.DailySpent(safe128(_amount), safe64(block.timestamp + 24 hours));\n            setDailySpent(_versionManager, _lStorage, _wallet, newDailySpent);\n            return true;\n        } else if (dailySpent.periodEnd > block.timestamp && _amount.add(dailySpent.alreadySpent) <= currentLimit) {\n            newDailySpent = ILimitStorage.DailySpent(safe128(_amount.add(dailySpent.alreadySpent)), safe64(dailySpent.periodEnd));\n            setDailySpent(_versionManager, _lStorage, _wallet, newDailySpent);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n    * @notice Helper method to Reset the daily consumption.\n    * @param _versionManager The Version Manager.\n    * @param _wallet The target wallet.\n    */\n    function resetDailySpent(IVersionManager _versionManager, ILimitStorage limitStorage, address _wallet) internal {\n        setDailySpent(_versionManager, limitStorage, _wallet, ILimitStorage.DailySpent(uint128(0), uint64(0)));\n    }\n\n    /**\n    * @notice Helper method to get the ether value equivalent of a token amount.\n    * @notice For low value amounts of tokens we accept this to return zero as these are small enough to disregard.\n    * Note that the price stored for tokens = price for 1 token (in ETH wei) * 10^(18-token decimals).\n    * @param _amount The token amount.\n    * @param _token The address of the token.\n    * @return The ether value for _amount of _token.\n    */\n    function getEtherValue(ITokenPriceRegistry _priceRegistry, uint256 _amount, address _token) internal view returns (uint256) {\n        uint256 price = _priceRegistry.getTokenPrice(_token);\n        uint256 etherValue = price.mul(_amount).div(10**18);\n        return etherValue;\n    }\n\n    /**\n    * @notice Helper method to get the current limit from a Limit struct.\n    * @param _limit The limit struct\n    */\n    function currentLimit(ILimitStorage.Limit memory _limit) internal view returns (uint256) {\n        if (_limit.changeAfter > 0 && _limit.changeAfter < block.timestamp) {\n            return _limit.pending;\n        }\n        return _limit.current;\n    }\n\n    function safe128(uint256 _num) internal pure returns (uint128) {\n        require(_num < 2**128, \"LU: more then 128 bits\");\n        return uint128(_num);\n    }\n\n    function safe64(uint256 _num) internal pure returns (uint64) {\n        require(_num < 2**64, \"LU: more then 64 bits\");\n        return uint64(_num);\n    }\n\n    // *************** Storage invocations in VersionManager ********************* //\n\n    function setLimit(\n        IVersionManager _versionManager,\n        ILimitStorage _lStorage,\n        address _wallet, \n        ILimitStorage.Limit memory _limit\n    ) internal {\n        _versionManager.invokeStorage(\n            _wallet,\n            address(_lStorage),\n            abi.encodeWithSelector(_lStorage.setLimit.selector, _wallet, _limit)\n        );\n    }\n\n    function setDailySpent(\n        IVersionManager _versionManager,\n        ILimitStorage _lStorage,\n        address _wallet, \n        ILimitStorage.DailySpent memory _dailySpent\n    ) private {\n        _versionManager.invokeStorage(\n            _wallet,\n            address(_lStorage),\n            abi.encodeWithSelector(_lStorage.setDailySpent.selector, _wallet, _dailySpent)\n        );\n    }\n\n}"},"/Users/Elena/Source/argent-contracts/contracts/modules/common/Utils.sol":{"content":"// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\n/**\n * @title Utils\n * @notice Common utility methods used by modules.\n */\nlibrary Utils {\n\n    /**\n    * @notice Helper method to recover the signer at a given position from a list of concatenated signatures.\n    * @param _signedHash The signed hash\n    * @param _signatures The concatenated signatures.\n    * @param _index The index of the signature to recover.\n    */\n    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint _index) internal pure returns (address) {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n        // we jump 65 (0x41) per signature\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\n        }\n        require(v == 27 || v == 28);\n\n        address recoveredAddress = ecrecover(_signedHash, v, r, s);\n        require(recoveredAddress != address(0), \"Utils: ecrecover returned 0\");\n        return recoveredAddress;\n    }\n\n    /**\n    * @notice Helper method to parse data and extract the method signature.\n    */\n    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\n        require(_data.length >= 4, \"RM: Invalid functionPrefix\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            prefix := mload(add(_data, 0x20))\n        }\n    }\n\n    /**\n    * @notice Returns ceil(a / b).\n    */\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        if (a % b == 0) {\n            return c;\n        } else {\n            return c + 1;\n        }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return a;\n        }\n        return b;\n    }\n}\n"},"/Users/Elena/Source/argent-contracts/contracts/wallet/IWallet.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.5.4 <0.7.0;\n\n/**\n * @title IWallet\n * @notice Interface for the BaseWallet\n */\ninterface IWallet {\n    /**\n     * @notice Returns the wallet owner.\n     * @return The wallet owner address.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Returns the number of authorised modules.\n     * @return The number of authorised modules.\n     */\n    function modules() external view returns (uint);\n\n    /**\n     * @notice Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _newOwner) external;\n\n    /**\n     * @notice Checks if a module is authorised on the wallet.\n     * @param _module The module address to check.\n     * @return `true` if the module is authorised, otherwise `false`.\n     */\n    function authorised(address _module) external view returns (bool);\n\n    /**\n     * @notice Returns the module responsible for a static call redirection.\n     * @param _sig The signature of the static call.\n     * @return the module doing the redirection\n     */\n    function enabled(bytes4 _sig) external view returns (address);\n\n    /**\n     * @notice Enables/Disables a module.\n     * @param _module The target module.\n     * @param _value Set to `true` to authorise the module.\n     */\n    function authoriseModule(address _module, bool _value) external;\n\n    /**\n    * @notice Enables a static method by specifying the target module to which the call must be delegated.\n    * @param _module The target module.\n    * @param _method The static method signature.\n    */\n    function enableStaticCall(address _module, bytes4 _method) external;\n}"},"/Users/Elena/Source/argent-contracts/lib/other/ERC20.sol":{"content":"pragma solidity >=0.5.4 <0.7.0;\n\n/**\n * ERC20 contract interface.\n */\ninterface ERC20 {\n    function totalSupply() external view returns (uint);\n    function decimals() external view returns (uint);\n    function balanceOf(address tokenOwner) external view returns (uint balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n    function transfer(address to, uint tokens) external returns (bool success);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n}"},"@openzeppelin/contracts/math/SafeMath.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}}