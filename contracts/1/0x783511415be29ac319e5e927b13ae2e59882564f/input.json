{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/AlgoBit.sol":{"content":"pragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract owned {\r\n    address payable public owner;\r\n\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable newOwner) onlyOwner public returns (bool) {\r\n        owner = newOwner;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract AlgoBit is owned{\r\n    using SafeMath for uint;\r\n    \r\n    address payable public devWallet;\r\n    address payable public beneficiary;\r\n\r\n    struct UserStruct {\r\n        bool isExist;\r\n        bool reReg;\r\n        uint id;\r\n        address payable wallet;\r\n        uint referrerID;\r\n        uint[] referral;\r\n        uint investment;\r\n        uint downline;\r\n    }\r\n\r\n    uint REFERRER_1_LEVEL_LIMIT = 5;\r\n    \r\n    bool isInit = false;\r\n\r\n    uint public totalInvest = 0;\r\n    uint public withdrawal = 0;\r\n\r\n    uint public precent_of_reward_1 = 35;\r\n    uint public precent_of_reward_2 = 10;\r\n    uint public precent_of_reward_3 = 10;\r\n    uint public precent_of_reward_4 = 5;\r\n\r\n    uint public getLostProfit_day_1 = 80;\r\n    uint public getLostProfit_day_2 = 60;\r\n    \r\n    mapping (uint => UserStruct) public users;\r\n    mapping (address => uint) public userList;\r\n\r\n    mapping (address => mapping (uint => uint)) public lostMoney;\r\n\r\n    mapping (address => mapping (uint => uint)) public investForLostMoney;\r\n\r\n    mapping (address => mapping (uint => uint)) public lostMoneyDL_3;\r\n    mapping (address => mapping (uint => uint)) public lostMoneyDL_4;\r\n\r\n    mapping (uint => uint) public totalLost;\r\n\r\n    uint public currUserID = 0;\r\n\r\n    event regEvent(address indexed _user, address indexed _referrer, uint _time);\r\n    event investEvent(address indexed _user, uint _amount, uint _time);\r\n    event getMoneyEvent(uint indexed _user, uint indexed _referral, uint _amount, uint _level, uint _time);\r\n    event lostMoneyEvent(uint indexed _user, uint indexed _referral, uint _amount, uint _level, uint _time);\r\n    event lostMoneyLDEvent(uint indexed _user, uint indexed _referral, uint _amount, uint _level, uint _time);\r\n    event getlostMoneyEvent(address indexed _user, uint _amount, uint _time);\r\n    event getlostMoneyLDEvent(address indexed _user, uint _amount, uint _level, uint _time);\r\n\r\n    constructor() public {\r\n        devWallet = msg.sender;\r\n        beneficiary = 0xeaA21cf4B2fff443c9d51fbafeD8324cFe7e1967;\r\n\r\n        UserStruct memory userStruct;\r\n        currUserID++;\r\n\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            reReg: false,\r\n            id: currUserID,\r\n            wallet: beneficiary,\r\n            referrerID: 0,\r\n            referral: new uint[](0),\r\n            investment: 99999999 ether,\r\n            downline: 0\r\n        });\r\n        users[currUserID] = userStruct;\r\n        userList[beneficiary] = currUserID;\r\n    }\r\n\r\n    function init(uint _maxLimit) public {\r\n        require(!isInit, 'initialized');\r\n        UserStruct memory userStruct;\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            reReg: false,\r\n            id: currUserID,\r\n            wallet: beneficiary,\r\n            referrerID: 1,\r\n            referral: new uint[](0),\r\n            investment: 99999999 ether,\r\n            downline: 0\r\n        });\r\n        \r\n        for(uint i = 0; i < _maxLimit; i++) {\r\n            currUserID++;\r\n            userStruct.id = currUserID;\r\n            users[currUserID] = userStruct;\r\n            users[1].referral.push(currUserID);\r\n            users[1].downline++;\r\n        }\r\n    }\r\n    \r\n    function inited() public {\r\n        isInit = true;\r\n    }\r\n\r\n    receive() external payable {\r\n        if(users[userList[msg.sender]].isExist){\r\n            invest();\r\n        } else {\r\n            uint refId = 0;\r\n            address referrer = bytesToAddress(msg.data);\r\n\r\n            if(users[userList[referrer]].isExist) refId = userList[referrer];\r\n            else revert('Incorrect referrer');\r\n\r\n            regUser(refId);\r\n        }\r\n    }\r\n\r\n    function regUser(uint _referrerID) public payable {\r\n        require(!users[userList[msg.sender]].isExist, 'User exist');\r\n        require(userList[msg.sender] == 0, 'User exist');\r\n        require(msg.value > 0, 'register with ETH');\r\n        require(_referrerID > 0 && _referrerID <= currUserID, 'Incorrect referrer Id');\r\n\r\n        require(users[_referrerID].referral.length < REFERRER_1_LEVEL_LIMIT,'Incorrect referrer Id');\r\n\r\n        totalInvest += msg.value;\r\n        devWallet.transfer(uint(msg.value).mul(2).div(100));\r\n\r\n        UserStruct memory userStruct;\r\n        currUserID++;\r\n\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            reReg: false,\r\n            id: currUserID,\r\n            wallet: msg.sender,\r\n            referrerID: _referrerID,\r\n            referral: new uint[](0),\r\n            investment: msg.value,\r\n            downline: 0\r\n        });\r\n\r\n        users[currUserID] = userStruct;\r\n        userList[msg.sender] = currUserID;\r\n\r\n        users[_referrerID].referral.push(currUserID);\r\n        users[_referrerID].downline++;\r\n        users[users[_referrerID].referrerID].downline++;\r\n        users[users[users[_referrerID].referrerID].referrerID].downline++;\r\n        users[users[users[users[_referrerID].referrerID].referrerID].referrerID].downline++;\r\n\r\n        address payable referral_3 = users[_referrerID].wallet;\r\n        if(users[_referrerID].referral.length >= 3){\r\n            if(lostMoneyDL_3[referral_3][uint(now).div(1 days).mul(1 days)] > 0){\r\n                referral_3.transfer(uint(lostMoneyDL_3[referral_3][uint(now).div(1 days).mul(1 days)]).mul(getLostProfit_day_1).div(100));\r\n                emit getlostMoneyLDEvent(referral_3, uint(lostMoneyDL_3[referral_3][uint(now).div(1 days).mul(1 days)]).mul(getLostProfit_day_1).div(100), 3, now);\r\n                lostMoneyDL_3[referral_3][uint(now).div(1 days).mul(1 days)] = 0;\r\n            }\r\n            if(lostMoneyDL_3[referral_3][uint(now).div(1 days).sub(1).mul(1 days)] > 0){\r\n                referral_3.transfer(uint(lostMoneyDL_3[referral_3][uint(now).div(1 days).sub(1).mul(1 days)]).mul(getLostProfit_day_1).div(100));\r\n                emit getlostMoneyLDEvent(referral_3, uint(lostMoneyDL_3[referral_3][uint(now).div(1 days).sub(1).mul(1 days)]).mul(getLostProfit_day_1).div(100), 3, now);\r\n                lostMoneyDL_3[referral_3][uint(now).div(1 days).sub(1).mul(1 days)] = 0;\r\n            }\r\n            if(lostMoneyDL_3[referral_3][uint(now).div(1 days).sub(2).mul(1 days)] > 0){\r\n                referral_3.transfer(uint(lostMoneyDL_3[referral_3][uint(now).div(1 days).sub(2).mul(1 days)]).mul(getLostProfit_day_2).div(100));\r\n                emit getlostMoneyLDEvent(referral_3, uint(lostMoneyDL_3[referral_3][uint(now).div(1 days).sub(2).mul(1 days)]).mul(getLostProfit_day_2).div(100), 3, now);\r\n                lostMoneyDL_3[referral_3][uint(now).div(1 days).sub(2).mul(1 days)] = 0; \r\n            }\r\n        }\r\n\r\n        address payable referral_4 = users[_referrerID].wallet;\r\n        if(users[_referrerID].referral.length >= 5){\r\n            if(lostMoneyDL_4[referral_4][uint(now).div(1 days).mul(1 days)] > 0){\r\n                referral_4.transfer(uint(lostMoneyDL_4[referral_4][uint(now).div(1 days).mul(1 days)]).mul(getLostProfit_day_1).div(100));\r\n                emit getlostMoneyLDEvent(referral_3, uint(lostMoneyDL_4[referral_4][uint(now).div(1 days).mul(1 days)]).mul(getLostProfit_day_1).div(100), 4, now);\r\n                lostMoneyDL_4[referral_4][uint(now).div(1 days).mul(1 days)] = 0;\r\n            }\r\n            if(lostMoneyDL_4[referral_4][uint(now).div(1 days).sub(1).mul(1 days)] > 0){\r\n                referral_4.transfer(uint(lostMoneyDL_4[referral_4][uint(now).div(1 days).sub(1).mul(1 days)]).mul(getLostProfit_day_1).div(100));\r\n                emit getlostMoneyLDEvent(referral_3, uint(lostMoneyDL_4[referral_4][uint(now).div(1 days).sub(1).mul(1 days)]).mul(getLostProfit_day_1).div(100), 4, now);\r\n                lostMoneyDL_4[referral_4][uint(now).div(1 days).sub(1).mul(1 days)] = 0;\r\n            }\r\n            if(lostMoneyDL_4[referral_4][uint(now).div(1 days).sub(2).mul(1 days)] > 0){\r\n                referral_4.transfer(uint(lostMoneyDL_4[referral_4][uint(now).div(1 days).sub(2).mul(1 days)]).mul(getLostProfit_day_2).div(100));\r\n                emit getlostMoneyLDEvent(referral_3, uint(lostMoneyDL_4[referral_4][uint(now).div(1 days).sub(2).mul(1 days)]).mul(getLostProfit_day_2).div(100), 4, now);\r\n                lostMoneyDL_4[referral_4][uint(now).div(1 days).sub(2).mul(1 days)] = 0;\r\n            }\r\n        }\r\n\r\n        if(users[users[users[users[_referrerID].referrerID].referrerID].referrerID].downline >= 780) users[users[users[users[_referrerID].referrerID].referrerID].referrerID].isExist = false;\r\n\r\n        UniLevel(msg.value, userList[msg.sender]);\r\n\r\n        emit regEvent(msg.sender, users[_referrerID].wallet, now);\r\n    }\r\n\r\n    function re_regUser(uint _referrerID) public payable {\r\n        require(!users[userList[msg.sender]].isExist, 'User exist');\r\n        require(users[userList[msg.sender]].downline >= 780, 'User exist');\r\n        // uint _referrerID = users[userList[msg.sender]].id;\r\n        require(_referrerID > 0 && _referrerID <= currUserID, 'Incorrect referrer Id');\r\n\r\n        require(msg.value >= (users[userList[msg.sender]].investment.mul(2)), 'Amount must be double of previce investment.');\r\n\r\n        require(users[_referrerID].referral.length < REFERRER_1_LEVEL_LIMIT,'Incorrect referrer Id');\r\n\r\n        totalInvest += msg.value;\r\n        devWallet.transfer(uint(msg.value).mul(2).div(100));\r\n\r\n        UserStruct memory userStruct;\r\n        currUserID++;\r\n\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            reReg: true,\r\n            id: currUserID,\r\n            wallet: msg.sender,\r\n            referrerID: _referrerID,\r\n            referral: new uint[](0),\r\n            investment: msg.value,\r\n            downline: 0\r\n        });\r\n\r\n        users[currUserID] = userStruct;\r\n        userList[msg.sender] = currUserID;\r\n\r\n        users[_referrerID].referral.push(currUserID);\r\n        users[_referrerID].downline++;\r\n        users[users[_referrerID].referrerID].downline++;\r\n        users[users[users[_referrerID].referrerID].referrerID].downline++;\r\n        users[users[users[users[_referrerID].referrerID].referrerID].referrerID].downline++;\r\n        if(users[users[users[users[_referrerID].referrerID].referrerID].referrerID].downline >= 780) users[users[users[users[_referrerID].referrerID].referrerID].referrerID].isExist = false;\r\n        \r\n        UniLevel(msg.value, userList[msg.sender]);\r\n        \r\n        emit regEvent(msg.sender, users[_referrerID].wallet, now);\r\n    }\r\n\r\n    function invest() public payable {\r\n        require(users[userList[msg.sender]].isExist, 'User not exist');\r\n        require(msg.value > 0, 'invest with ETH');\r\n\r\n        totalInvest += msg.value;\r\n        devWallet.transfer(uint(msg.value).mul(2).div(100));\r\n\r\n        users[userList[msg.sender]].investment = users[userList[msg.sender]].investment + msg.value;\r\n        if(investForLostMoney[msg.sender][uint(now).div(1 days).mul(1 days)] > 0 && lostMoney[msg.sender][uint(now).div(1 days).mul(1 days)] > 0){\r\n            payable(msg.sender).transfer(uint(lostMoney[msg.sender][uint(now).div(1 days).mul(1 days)]).mul(getLostProfit_day_1).div(100));\r\n            emit getlostMoneyEvent(msg.sender, uint(lostMoney[msg.sender][uint(now).div(1 days).mul(1 days)]).mul(getLostProfit_day_1).div(100), now);\r\n            lostMoney[msg.sender][uint(now).div(1 days).mul(1 days)] = 0;\r\n            investForLostMoney[msg.sender][uint(now).div(1 days).mul(1 days)] = 0;\r\n        }\r\n        if(investForLostMoney[msg.sender][uint(now).div(1 days).sub(1).mul(1 days)] > 0 && lostMoney[msg.sender][uint(now).div(1 days).sub(1).mul(1 days)] > 0){\r\n            payable(msg.sender).transfer(uint(lostMoney[msg.sender][uint(now).div(1 days).sub(1).mul(1 days)]).mul(getLostProfit_day_1).div(100));\r\n            emit getlostMoneyEvent(msg.sender, uint(lostMoney[msg.sender][uint(now).div(1 days).sub(1).mul(1 days)]).mul(getLostProfit_day_1).div(100), now);\r\n            lostMoney[msg.sender][uint(now).div(1 days).sub(1).mul(1 days)] = 0;\r\n            investForLostMoney[msg.sender][uint(now).div(1 days).sub(1).mul(1 days)] = 0;\r\n        }\r\n        if(investForLostMoney[msg.sender][uint(now).div(1 days).sub(2).mul(1 days)] > 0 && lostMoney[msg.sender][uint(now).div(1 days).sub(2).mul(1 days)] > 0){\r\n            payable(msg.sender).transfer(uint(lostMoney[msg.sender][uint(now).div(1 days).sub(2).mul(1 days)]).mul(getLostProfit_day_2).div(100));\r\n            emit getlostMoneyEvent(msg.sender, uint(lostMoney[msg.sender][uint(now).div(1 days).sub(2).mul(1 days)]).mul(getLostProfit_day_2).div(100), now);\r\n            lostMoney[msg.sender][uint(now).div(1 days).sub(2).mul(1 days)] = 0;\r\n            investForLostMoney[msg.sender][uint(now).div(1 days).sub(2).mul(1 days)] = 0;\r\n        }\r\n\r\n        UniLevel(msg.value, userList[msg.sender]);\r\n\r\n        emit investEvent(msg.sender, msg.value, now);\r\n    }\r\n\r\n    struct reward{\r\n        uint referer;\r\n        uint amount;\r\n        uint lost_amount;\r\n    }\r\n\r\n    function UniLevel(uint _amount, uint _user) internal {\r\n        \r\n        reward memory referer1;\r\n        reward memory referer2;\r\n        reward memory referer3;\r\n        reward memory referer4;\r\n\r\n        bool selfReReg = users[_user].reReg;\r\n\r\n        referer1.referer = users[_user].referrerID;\r\n        bool upReReg = users[referer1.referer].reReg;\r\n\r\n        if(users[referer1.referer].isExist){\r\n            if(users[referer1.referer].investment >= users[_user].investment){\r\n                if(selfReReg && !upReReg){\r\n                    referer1.amount =  _amount.mul(precent_of_reward_1.sub(5)).div(100);\r\n                }else{\r\n                    if(upReReg && !selfReReg){\r\n                        referer1.amount =  _amount.mul(precent_of_reward_1.add(5)).div(100);\r\n                    }else{\r\n                        referer1.amount =  _amount.mul(precent_of_reward_1).div(100);\r\n                    }\r\n                }\r\n                users[referer1.referer].wallet.transfer(referer1.amount);\r\n                emit getMoneyEvent(referer1.referer, userList[msg.sender], referer1.amount, 1, now);\r\n            }else{\r\n                if(_amount > users[_user].investment.sub( users[referer1.referer].investment ) ){\r\n                    if(selfReReg && !upReReg){\r\n                        referer1.lost_amount = ( (users[_user].investment.sub( users[referer1.referer].investment ) ) ).mul( precent_of_reward_1.sub(5) ).div(100);\r\n                        referer1.amount =  (_amount.sub( users[_user].investment.sub(users[referer1.referer].investment ) ) ).mul( precent_of_reward_1.sub(5) ).div(100);\r\n                    }else{\r\n                        if(upReReg && !selfReReg){\r\n                            referer1.lost_amount = ( users[_user].investment.sub(users[referer1.referer].investment) ).mul( precent_of_reward_1.add(5) ).div(100);\r\n                            referer1.amount =  ( _amount.sub( users[_user].investment.sub(users[referer1.referer].investment) ) ).mul( precent_of_reward_1.add(5) ).div(100);\r\n                        }else{\r\n                            referer1.lost_amount = ( users[_user].investment.sub(users[referer1.referer].investment ) ).mul(precent_of_reward_1).div(100);\r\n                            referer1.amount =  ( _amount.sub( users[_user].investment.sub(users[referer1.referer].investment) ) ).mul( precent_of_reward_1).div(100);\r\n                        }\r\n                    }\r\n                    users[referer1.referer].wallet.transfer(referer1.amount);\r\n                    emit getMoneyEvent(referer1.referer, userList[msg.sender], referer1.amount, 1, now);\r\n\r\n                    lostMoney[users[referer1.referer].wallet][uint(now).div(1 days).mul(1 days)] = referer1.lost_amount;\r\n                    if(investForLostMoney[users[referer1.referer].wallet][uint(now).div(1 days).mul(1 days)] < users[_user].investment.sub(users[referer1.referer].investment)){\r\n                        investForLostMoney[users[referer1.referer].wallet][uint(now).div(1 days).mul(1 days)] = users[_user].investment.sub(users[referer1.referer].investment);\r\n                    }\r\n                    totalLost[uint(now).div(1 days).mul(1 days)] += referer1.lost_amount;\r\n                    emit lostMoneyEvent(referer1.referer, userList[msg.sender], referer1.lost_amount, 1, now);\r\n\r\n                }else{\r\n                    referer1.lost_amount = users[_user].investment - users[referer1.referer].investment * precent_of_reward_1 / 100;\r\n                    if(investForLostMoney[users[referer1.referer].wallet][uint(now).div(1 days).mul(1 days)] < users[_user].investment.sub(users[referer1.referer].investment)){\r\n                        investForLostMoney[users[referer1.referer].wallet][uint(now).div(1 days).mul(1 days)] = users[_user].investment.sub(users[referer1.referer].investment);\r\n                    }\r\n                    totalLost[uint(now).div(1 days).mul(1 days)] += referer1.lost_amount;\r\n                    emit lostMoneyEvent(referer1.referer, userList[msg.sender], referer1.lost_amount, 1, now);\r\n                }\r\n                \r\n            }\r\n        }\r\n        referer2.referer = users[referer1.referer].referrerID;\r\n        if(users[referer2.referer].isExist){\r\n            if(users[referer2.referer].investment >= users[_user].investment){\r\n                referer2.amount =  _amount.mul( precent_of_reward_2 ).div( 100 );\r\n                users[referer2.referer].wallet.transfer(referer2.amount);\r\n                emit getMoneyEvent(referer2.referer, userList[msg.sender], referer2.amount, 2, now);\r\n            }else{\r\n                if(_amount > users[_user].investment.sub( users[referer2.referer].investment ) ){\r\n                    referer2.lost_amount = ( users[_user].investment.sub( users[referer2.referer].investment ) ).mul( precent_of_reward_2 ).div( 100 );\r\n                    referer2.amount =  ( _amount.sub( users[_user].investment.sub( users[referer2.referer].investment ) ) ).mul( precent_of_reward_2 ).div( 100 );\r\n                    users[referer2.referer].wallet.transfer(referer2.amount);\r\n                    emit getMoneyEvent(referer2.referer, userList[msg.sender], referer2.amount, 2, now);\r\n\r\n                    lostMoney[users[referer2.referer].wallet][uint(now).div(1 days).mul(1 days)] = referer2.lost_amount;\r\n                    if(investForLostMoney[users[referer2.referer].wallet][uint(now).div(1 days).mul(1 days)] < users[_user].investment.sub( users[referer2.referer].investment )){\r\n                        investForLostMoney[users[referer2.referer].wallet][uint(now).div(1 days).mul(1 days)] = users[_user].investment.sub( users[referer2.referer].investment );\r\n                    }\r\n                    totalLost[uint(now).div(1 days).mul(1 days)] += referer2.lost_amount;\r\n                    emit lostMoneyEvent(referer2.referer, userList[msg.sender], referer2.lost_amount, 2, now);\r\n\r\n                }else{\r\n                    referer2.lost_amount = ( users[_user].investment.sub( users[referer2.referer].investment ) ).mul( precent_of_reward_2 ).div( 100 );\r\n\r\n                    lostMoney[users[referer2.referer].wallet][uint(now).div(1 days).mul(1 days)] = referer2.lost_amount;\r\n                    if(investForLostMoney[users[referer2.referer].wallet][uint(now).div(1 days).mul(1 days)] < users[_user].investment.sub( users[referer2.referer].investment )){\r\n                        investForLostMoney[users[referer2.referer].wallet][uint(now).div(1 days).mul(1 days)] = users[_user].investment.sub( users[referer2.referer].investment );\r\n                    }\r\n                    totalLost[uint(now).div(1 days).mul(1 days)] += referer2.lost_amount;\r\n                    emit lostMoneyEvent(referer2.referer, userList[msg.sender], referer2.lost_amount, 2, now);\r\n                }\r\n                \r\n            }\r\n        }\r\n        referer3.referer = users[referer2.referer].referrerID;\r\n        if(users[referer3.referer].isExist){\r\n            if(users[referer3.referer].investment >= users[_user].investment){\r\n                referer3.amount = _amount.mul( precent_of_reward_3 ).div( 100 );\r\n                if(users[referer3.referer].referral.length >= 3){\r\n                    users[referer3.referer].wallet.transfer(referer3.amount);\r\n                    emit getMoneyEvent(referer3.referer, userList[msg.sender], referer3.amount, 3, now);\r\n                }else{\r\n                    lostMoneyDL_3[users[referer3.referer].wallet][uint(now).div(1 days).mul(1 days)] = referer3.amount;\r\n                    totalLost[uint(now).div(1 days).mul(1 days)] += referer3.amount;\r\n                    emit lostMoneyLDEvent(referer3.referer, userList[msg.sender], referer3.amount, 3, now);\r\n                }\r\n            }else{\r\n                if( _amount > users[_user].investment.sub( users[referer3.referer].investment ) ){\r\n                    referer3.lost_amount = ( users[_user].investment.sub( users[referer3.referer].investment ) ).mul( precent_of_reward_3 ).div( 100 );\r\n                    referer3.amount = ( _amount.sub( users[_user].investment.sub( users[referer3.referer].investment ) ) ).mul( precent_of_reward_3 ).div( 100 );\r\n                    if(users[referer3.referer].referral.length >= 3){\r\n                        users[referer3.referer].wallet.transfer(referer3.amount);\r\n                        emit getMoneyEvent(referer3.referer, userList[msg.sender], referer3.amount, 3, now);\r\n\r\n                        lostMoney[users[referer3.referer].wallet][uint(now).div(1 days).mul(1 days)] = referer3.lost_amount;\r\n                        if(investForLostMoney[users[referer3.referer].wallet][uint(now).div(1 days).mul(1 days)] < users[_user].investment.sub( users[referer3.referer].investment )){\r\n                            investForLostMoney[users[referer3.referer].wallet][uint(now).div(1 days).mul(1 days)] = users[_user].investment.sub( users[referer3.referer].investment );\r\n                        }\r\n                        totalLost[uint(now).div(1 days).mul(1 days)] += referer3.lost_amount;\r\n                        emit lostMoneyEvent(referer3.referer, userList[msg.sender], referer3.lost_amount, 3, now);\r\n                    }else{\r\n                        lostMoneyDL_3[users[referer3.referer].wallet][uint(now).div(1 days).mul(1 days)] = referer3.amount;\r\n                        totalLost[uint(now).div(1 days).mul(1 days)] += referer3.amount;\r\n                        emit lostMoneyLDEvent(referer3.referer, userList[msg.sender], referer3.amount, 3, now);\r\n\r\n                        lostMoney[users[referer3.referer].wallet][uint(now).div(1 days).mul(1 days)] = referer3.lost_amount;\r\n                        if(investForLostMoney[users[referer3.referer].wallet][uint(now).div(1 days).mul(1 days)] < users[_user].investment.sub( users[referer3.referer].investment )){\r\n                            investForLostMoney[users[referer3.referer].wallet][uint(now).div(1 days).mul(1 days)] = users[_user].investment.sub( users[referer3.referer].investment );\r\n                        }\r\n                        totalLost[uint(now).div(1 days).mul(1 days)] += referer3.lost_amount;\r\n                        emit lostMoneyEvent(referer3.referer, userList[msg.sender], referer3.lost_amount, 3, now);\r\n                    }\r\n                }else{\r\n                    referer3.lost_amount = ( users[_user].investment.sub( users[referer3.referer].investment ) ).mul( precent_of_reward_3 ).div( 100 );\r\n                    lostMoney[users[referer3.referer].wallet][uint(now).div(1 days).mul(1 days)] = referer3.lost_amount;\r\n                    if(investForLostMoney[users[referer3.referer].wallet][uint(now).div(1 days).mul(1 days)] < users[_user].investment.sub( users[referer3.referer].investment )){\r\n                        investForLostMoney[users[referer3.referer].wallet][uint(now).div(1 days).mul(1 days)] = users[_user].investment.sub( users[referer3.referer].investment );\r\n                    }\r\n                    totalLost[uint(now).div(1 days).mul(1 days)] += referer3.lost_amount;\r\n                    emit lostMoneyEvent(referer3.referer, userList[msg.sender], referer3.lost_amount, 3, now);\r\n                }\r\n                \r\n            }\r\n        }\r\n        referer4.referer = users[referer3.referer].referrerID;\r\n        if(users[referer4.referer].isExist){\r\n            if(users[referer4.referer].investment >= users[_user].investment){\r\n                referer4.amount =  _amount.mul( precent_of_reward_4 ).div( 100 );\r\n                if(users[referer3.referer].referral.length >= 5){\r\n                    users[referer4.referer].wallet.transfer(referer4.amount);\r\n                    emit getMoneyEvent(referer4.referer, userList[msg.sender], referer4.amount, 4, now);\r\n                }else{\r\n                    lostMoneyDL_4[users[referer4.referer].wallet][uint(now).div(1 days).mul(1 days)] = referer4.amount;\r\n                    totalLost[uint(now).div(1 days).mul(1 days)] += referer4.amount;\r\n                    emit lostMoneyLDEvent(referer4.referer, userList[msg.sender], referer4.amount, 4, now);\r\n                }\r\n            }else{\r\n                if( _amount > users[_user].investment.sub( users[referer4.referer].investment ) ){\r\n                    referer4.lost_amount = ( users[_user].investment.sub( users[referer4.referer].investment ) ).mul( precent_of_reward_4 ).div( 100 );\r\n                    referer4.amount =  ( _amount.sub( users[_user].investment.sub( users[referer4.referer].investment ) ) ).mul( precent_of_reward_4 ).div( 100 );\r\n                    if(users[referer3.referer].referral.length >= 5){\r\n                        users[referer4.referer].wallet.transfer(referer4.amount);\r\n                        emit getMoneyEvent(referer4.referer, userList[msg.sender], referer4.amount, 4, now);\r\n\r\n                        lostMoney[users[referer4.referer].wallet][uint(now).div(1 days).mul(1 days)] = referer4.lost_amount;\r\n                        if(investForLostMoney[users[referer4.referer].wallet][uint(now).div(1 days).mul(1 days)] < users[_user].investment.sub( users[referer4.referer].investment )){\r\n                            investForLostMoney[users[referer4.referer].wallet][uint(now).div(1 days).mul(1 days)] = users[_user].investment.sub( users[referer4.referer].investment );\r\n                        }\r\n                        totalLost[uint(now).div(1 days).mul(1 days)] += referer4.lost_amount;\r\n                        emit lostMoneyEvent(referer4.referer, userList[msg.sender], referer4.lost_amount, 4, now);\r\n                    }else{\r\n                        lostMoneyDL_4[users[referer4.referer].wallet][uint(now).div(1 days).mul(1 days)] = referer4.amount;\r\n                        totalLost[uint(now).div(1 days).mul(1 days)] += referer4.amount;\r\n                        emit lostMoneyLDEvent(referer4.referer, userList[msg.sender], referer4.amount, 4, now);\r\n\r\n                        lostMoney[users[referer4.referer].wallet][uint(now).div(1 days).mul(1 days)] = referer4.lost_amount;\r\n                        if(investForLostMoney[users[referer4.referer].wallet][uint(now).div(1 days).mul(1 days)] < users[_user].investment.sub( users[referer4.referer].investment )){\r\n                            investForLostMoney[users[referer4.referer].wallet][uint(now).div(1 days).mul(1 days)] = users[_user].investment.sub( users[referer4.referer].investment );\r\n                        }\r\n                        totalLost[uint(now).div(1 days).mul(1 days)] += referer4.lost_amount;\r\n                        emit lostMoneyEvent(referer4.referer, userList[msg.sender], referer4.lost_amount, 4, now);\r\n                    }\r\n\r\n                }else{\r\n                    referer4.lost_amount = ( users[_user].investment.sub( users[referer4.referer].investment ) ).mul( precent_of_reward_4 ).div( 100 );\r\n                    lostMoney[users[referer4.referer].wallet][uint(now).div(1 days).mul(1 days)] = referer4.lost_amount;\r\n                    if(investForLostMoney[users[referer4.referer].wallet][uint(now).div(1 days).mul(1 days)] < users[_user].investment.sub( users[referer4.referer].investment )){\r\n                        investForLostMoney[users[referer4.referer].wallet][uint(now).div(1 days).mul(1 days)] = users[_user].investment.sub( users[referer4.referer].investment );\r\n                    }\r\n                    totalLost[uint(now).div(1 days).mul(1 days)] += referer4.lost_amount;\r\n                    emit lostMoneyEvent(referer4.referer, userList[msg.sender], referer4.lost_amount, 4, now);\r\n                }\r\n                \r\n            }\r\n        }\r\n    }\r\n\r\n    function viewUserReferral(uint _user) public view returns(uint[] memory) {\r\n        return users[_user].referral;\r\n    }\r\n\r\n    function viewRecoLostMoney(address _user) public view returns(uint) {\r\n        uint money = lostMoney[_user][uint(now).div(1 days).mul(1 days)];\r\n        money += lostMoney[_user][uint(now).div(1 days).sub(1).mul(1 days)];\r\n        money += lostMoney[_user][uint(now).div(1 days).sub(2).mul(1 days)];\r\n        return money;\r\n    }\r\n\r\n    function viewLostMoney(address _user, uint _day) public view returns(uint) {\r\n        return lostMoney[_user][uint(now).div(1 days).sub(_day).mul(1 days)];\r\n    }\r\n\r\n    function viewRecoLostMoneyDL_3(address _user) public view returns(uint) {\r\n        uint money = lostMoneyDL_3[_user][uint(now).div(1 days).mul(1 days)];\r\n        money += lostMoneyDL_3[_user][uint(now).div(1 days).sub(1).mul(1 days)];\r\n        money += lostMoneyDL_3[_user][uint(now).div(1 days).sub(2).mul(1 days)];\r\n        return money;\r\n    }\r\n\r\n    function viewLostMoneyDL_3(address _user, uint _day) public view returns(uint) {\r\n        return lostMoneyDL_3[_user][uint(now).div(1 days).sub(_day).mul(1 days)];\r\n    }\r\n\r\n    function viewRecoLostMoneyDL_4(address _user) public view returns(uint) {\r\n        uint money = lostMoneyDL_4[_user][uint(now).div(1 days).mul(1 days)];\r\n        money += lostMoneyDL_4[_user][uint(now).div(1 days).sub(1).mul(1 days)];\r\n        money += lostMoneyDL_4[_user][uint(now).div(1 days).sub(2).mul(1 days)];\r\n        return money;\r\n    }\r\n\r\n    function viewLostMoneyDL_4(address _user, uint _day) public view returns(uint) {\r\n        return lostMoneyDL_4[_user][uint(now).div(1 days).sub(_day).mul(1 days)];\r\n    }\r\n\r\n    function viewRecoInvestForLostMoney(address _user) public view returns(uint) {\r\n        uint amount = investForLostMoney[_user][uint(now).div(1 days).mul(1 days)];\r\n        if(amount < investForLostMoney[_user][uint(now).div(1 days).sub(1).mul(1 days)]){\r\n            amount = investForLostMoney[_user][uint(now).div(1 days).sub(1).mul(1 days)];\r\n        }\r\n        if(amount < investForLostMoney[_user][uint(now).div(1 days).sub(2).mul(1 days)]){\r\n            amount = investForLostMoney[_user][uint(now).div(1 days).sub(2).mul(1 days)];\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function viewInvestForLostMoney(address _user, uint _day) public view returns(uint) {\r\n        return investForLostMoney[_user][uint(now).div(1 days).sub(_day).mul(1 days)];\r\n    }\r\n\r\n    function viewHoldTotalLost() public view returns(uint) {\r\n        uint amount = totalLost[uint(now).div(1 days).mul(1 days)];\r\n        amount += totalLost[uint(now).div(1 days).sub(1).mul(1 days)];\r\n        amount += totalLost[uint(now).div(1 days).sub(2).mul(1 days)];\r\n        return amount;\r\n    }\r\n\r\n    function viewTotalLost(uint _day) public view returns(uint) {\r\n        return totalLost[uint(now).div(1 days).sub(_day).mul(1 days)];\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n\r\n    function beneficiaryWithdrawal() public returns (bool) {\r\n        require(msg.sender == beneficiary, 'Access Denied');\r\n        uint balance = address(this).balance;\r\n        balance = balance.sub(totalLost[uint(now).div(1 days).mul(1 days)]).sub(totalLost[uint(now).div(1 days).sub(1).mul(1 days)]).sub(totalLost[uint(now).div(1 days).sub(2).mul(1 days)]);\r\n        beneficiary.transfer(balance);\r\n        withdrawal += balance;\r\n        return true;\r\n    }\r\n\r\n    function updateRewardPercent(uint _precent_of_reward_1, uint _precent_of_reward_2, uint _precent_of_reward_3, uint _precent_of_reward_4) onlyOwner public returns (bool) {\r\n        precent_of_reward_1 = _precent_of_reward_1;\r\n        precent_of_reward_2 = _precent_of_reward_2;\r\n        precent_of_reward_3 = _precent_of_reward_3;\r\n        precent_of_reward_4 = _precent_of_reward_4;\r\n        return true;\r\n    }\r\n\r\n    function updateLostPercent(uint _getLostProfit_day_1, uint _getLostProfit_day_2) onlyOwner public returns (bool) {\r\n        getLostProfit_day_1 = _getLostProfit_day_1;\r\n        getLostProfit_day_2 = _getLostProfit_day_2;\r\n        return true;\r\n    }\r\n\r\n    function updateUser(uint _id, address payable _address, uint _amount) onlyOwner public returns (bool) {\r\n        require(_id <= 51, \"Update System ID Only.\");\r\n        users[_id].wallet = _address;\r\n        users[_id].investment = _amount;\r\n        userList[_address] = _id;\r\n        return true;\r\n    }\r\n\r\n    function updateBeneficiary(address payable _address) public returns (bool) {\r\n        require(msg.sender == beneficiary, 'Access Denied');\r\n        beneficiary = _address;\r\n        return true;\r\n    }\r\n    \r\n    function updateDevWallet(address payable _address) public returns (bool) {\r\n        require(msg.sender == devWallet, 'Access Denied');\r\n        devWallet = _address;\r\n        return true;\r\n    }\r\n}"}}}