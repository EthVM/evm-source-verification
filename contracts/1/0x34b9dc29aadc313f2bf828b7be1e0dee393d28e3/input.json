{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "CP.sol": {
      "content": "// File: contracts/lib/SafeMath.sol\n\n/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title SafeMath\n * @author DODO Breeder\n *\n * @notice Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"MUL_ERROR\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"DIVIDING_ERROR\");\n        return a / b;\n    }\n\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 quotient = div(a, b);\n        uint256 remainder = a - quotient * b;\n        if (remainder > 0) {\n            return quotient + 1;\n        } else {\n            return quotient;\n        }\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SUB_ERROR\");\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ADD_ERROR\");\n        return c;\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = x / 2 + 1;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n}\n\n// File: contracts/lib/DecimalMath.sol\n\n\n/**\n * @title DecimalMath\n * @author DODO Breeder\n *\n * @notice Functions for fixed point number with 18 decimals\n */\nlibrary DecimalMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant ONE = 10**18;\n    uint256 internal constant ONE2 = 10**36;\n\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target.mul(d) / (10**18);\n    }\n\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target.mul(d).divCeil(10**18);\n    }\n\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target.mul(10**18).div(d);\n    }\n\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target.mul(10**18).divCeil(d);\n    }\n\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\n        return uint256(10**36).div(target);\n    }\n\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\n        return uint256(10**36).divCeil(target);\n    }\n}\n\n// File: contracts/lib/Ownable.sol\n\n/**\n * @title Ownable\n * @author DODO Breeder\n *\n * @notice Ownership related functions\n */\ncontract Ownable {\n    address public _OWNER_;\n    address public _NEW_OWNER_;\n\n    // ============ Events ============\n\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // ============ Modifiers ============\n\n    modifier onlyOwner() {\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\n        _;\n    }\n\n    // ============ Functions ============\n\n    constructor() internal {\n        _OWNER_ = msg.sender;\n        emit OwnershipTransferred(address(0), _OWNER_);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n        _NEW_OWNER_ = newOwner;\n    }\n\n    function claimOwnership() external {\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n        _OWNER_ = _NEW_OWNER_;\n        _NEW_OWNER_ = address(0);\n    }\n}\n\n// File: contracts/intf/IERC20.sol\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n\n// File: contracts/lib/SafeERC20.sol\n\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// File: contracts/DODOVendingMachine/intf/IDVM.sol\n\n\ninterface IDVM {\n    function init(\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external;\n\n    function _BASE_TOKEN_() external returns (address);\n\n    function _QUOTE_TOKEN_() external returns (address);\n\n    function _MT_FEE_RATE_MODEL_() external returns (address);\n\n    function getVaultReserve() external returns (uint256 baseReserve, uint256 quoteReserve);\n\n    function sellBase(address to) external returns (uint256);\n\n    function sellQuote(address to) external returns (uint256);\n\n    function buyShares(address to) external returns (uint256,uint256,uint256);\n\n}\n\n// File: contracts/lib/InitializableOwnable.sol\n\n\n/**\n * @title Ownable\n * @author DODO Breeder\n *\n * @notice Ownership related functions\n */\ncontract InitializableOwnable {\n    address public _OWNER_;\n    address public _NEW_OWNER_;\n    bool internal _INITIALIZED_;\n\n    // ============ Events ============\n\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // ============ Modifiers ============\n\n    modifier notInitialized() {\n        require(!_INITIALIZED_, \"DODO_INITIALIZED\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\n        _;\n    }\n\n    // ============ Functions ============\n\n    function initOwner(address newOwner) public notInitialized {\n        _INITIALIZED_ = true;\n        _OWNER_ = newOwner;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n        _NEW_OWNER_ = newOwner;\n    }\n\n    function claimOwnership() public {\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n        _OWNER_ = _NEW_OWNER_;\n        _NEW_OWNER_ = address(0);\n    }\n}\n\n// File: contracts/lib/CloneFactory.sol\n\n\ninterface ICloneFactory {\n    function clone(address prototype) external returns (address proxy);\n}\n\n// introduction of proxy mode design: https://docs.openzeppelin.com/upgrades/2.8/\n// minimum implementation of transparent proxy: https://eips.ethereum.org/EIPS/eip-1167\n\ncontract CloneFactory is ICloneFactory {\n    function clone(address prototype) external override returns (address proxy) {\n        bytes20 targetBytes = bytes20(prototype);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            proxy := create(0, clone, 0x37)\n        }\n        return proxy;\n    }\n}\n\n// File: contracts/Factory/DVMFactory.sol\n\n\n\n\ninterface IDVMFactory {\n    function createDODOVendingMachine(\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external returns (address newVendingMachine);\n}\n\n\n/**\n * @title DODO VendingMachine Factory\n * @author DODO Breeder\n *\n * @notice Create And Register DVM Pools \n */\ncontract DVMFactory is InitializableOwnable {\n    // ============ Templates ============\n\n    address public immutable _CLONE_FACTORY_;\n    address public immutable _DEFAULT_MAINTAINER_;\n    address public immutable _DEFAULT_MT_FEE_RATE_MODEL_;\n    address public _DVM_TEMPLATE_;\n\n    // ============ Registry ============\n\n    // base -> quote -> DVM address list\n    mapping(address => mapping(address => address[])) public _REGISTRY_;\n    // creator -> DVM address list\n    mapping(address => address[]) public _USER_REGISTRY_;\n\n    // ============ Events ============\n\n    event NewDVM(\n        address baseToken,\n        address quoteToken,\n        address creator,\n        address dvm\n    );\n\n    event RemoveDVM(address dvm);\n\n    // ============ Functions ============\n\n    constructor(\n        address cloneFactory,\n        address dvmTemplate,\n        address defaultMaintainer,\n        address defaultMtFeeRateModel\n    ) public {\n        _CLONE_FACTORY_ = cloneFactory;\n        _DVM_TEMPLATE_ = dvmTemplate;\n        _DEFAULT_MAINTAINER_ = defaultMaintainer;\n        _DEFAULT_MT_FEE_RATE_MODEL_ = defaultMtFeeRateModel;\n    }\n\n    function createDODOVendingMachine(\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external returns (address newVendingMachine) {\n        newVendingMachine = ICloneFactory(_CLONE_FACTORY_).clone(_DVM_TEMPLATE_);\n        {\n            IDVM(newVendingMachine).init(\n                _DEFAULT_MAINTAINER_,\n                baseToken,\n                quoteToken,\n                lpFeeRate,\n                _DEFAULT_MT_FEE_RATE_MODEL_,\n                i,\n                k,\n                isOpenTWAP\n            );\n        }\n        _REGISTRY_[baseToken][quoteToken].push(newVendingMachine);\n        _USER_REGISTRY_[tx.origin].push(newVendingMachine);\n        emit NewDVM(baseToken, quoteToken, tx.origin, newVendingMachine);\n    }\n\n    // ============ Admin Operation Functions ============\n\n    function updateDvmTemplate(address _newDVMTemplate) external onlyOwner {\n        _DVM_TEMPLATE_ = _newDVMTemplate;\n    }\n\n    function addPoolByAdmin(\n        address creator,\n        address baseToken, \n        address quoteToken,\n        address pool\n    ) external onlyOwner {\n        _REGISTRY_[baseToken][quoteToken].push(pool);\n        _USER_REGISTRY_[creator].push(pool);\n        emit NewDVM(baseToken, quoteToken, creator, pool);\n    }\n\n    function removePoolByAdmin(\n        address creator,\n        address baseToken, \n        address quoteToken,\n        address pool\n    ) external onlyOwner {\n        address[] memory registryList = _REGISTRY_[baseToken][quoteToken];\n        for (uint256 i = 0; i < registryList.length; i++) {\n            if (registryList[i] == pool) {\n                registryList[i] = registryList[registryList.length - 1];\n                break;\n            }\n        }\n        _REGISTRY_[baseToken][quoteToken] = registryList;\n        _REGISTRY_[baseToken][quoteToken].pop();\n        address[] memory userRegistryList = _USER_REGISTRY_[creator];\n        for (uint256 i = 0; i < userRegistryList.length; i++) {\n            if (userRegistryList[i] == pool) {\n                userRegistryList[i] = userRegistryList[userRegistryList.length - 1];\n                break;\n            }\n        }\n        _USER_REGISTRY_[creator] = userRegistryList;\n        _USER_REGISTRY_[creator].pop();\n        emit RemoveDVM(pool);\n    }\n\n    // ============ View Functions ============\n\n    function getDODOPool(address baseToken, address quoteToken)\n        external\n        view\n        returns (address[] memory machines)\n    {\n        return _REGISTRY_[baseToken][quoteToken];\n    }\n\n    function getDODOPoolBidirection(address token0, address token1)\n        external\n        view\n        returns (address[] memory baseToken0Machines, address[] memory baseToken1Machines)\n    {\n        return (_REGISTRY_[token0][token1], _REGISTRY_[token1][token0]);\n    }\n\n    function getDODOPoolByUser(address user)\n        external\n        view\n        returns (address[] memory machines)\n    {\n        return _USER_REGISTRY_[user];\n    }\n}\n\n// File: contracts/lib/ReentrancyGuard.sol\n\n\n/**\n * @title ReentrancyGuard\n * @author DODO Breeder\n *\n * @notice Protect functions from Reentrancy Attack\n */\ncontract ReentrancyGuard {\n    // https://solidity.readthedocs.io/en/latest/control-structures.html?highlight=zero-state#scoping-and-declarations\n    // zero-state of _ENTERED_ is false\n    bool private _ENTERED_;\n\n    modifier preventReentrant() {\n        require(!_ENTERED_, \"REENTRANT\");\n        _ENTERED_ = true;\n        _;\n        _ENTERED_ = false;\n    }\n}\n\n// File: contracts/lib/PermissionManager.sol\n\n\ninterface IPermissionManager {\n    function initOwner(address) external;\n\n    function isAllowed(address) external view returns (bool);\n}\n\ncontract PermissionManager is InitializableOwnable {\n    bool public _WHITELIST_MODE_ON_;\n\n    mapping(address => bool) internal _whitelist_;\n    mapping(address => bool) internal _blacklist_;\n\n    function isAllowed(address account) external view returns (bool) {\n        if (_WHITELIST_MODE_ON_) {\n            return _whitelist_[account];\n        } else {\n            return !_blacklist_[account];\n        }\n    }\n\n    function openBlacklistMode() external onlyOwner {\n        _WHITELIST_MODE_ON_ = false;\n    }\n\n    function openWhitelistMode() external onlyOwner {\n        _WHITELIST_MODE_ON_ = true;\n    }\n\n    function addToWhitelist(address account) external onlyOwner {\n        _whitelist_[account] = true;\n    }\n\n    function removeFromWhitelist(address account) external onlyOwner {\n        _whitelist_[account] = false;\n    }\n\n    function addToBlacklist(address account) external onlyOwner {\n        _blacklist_[account] = true;\n    }\n\n    function removeFromBlacklist(address account) external onlyOwner {\n        _blacklist_[account] = false;\n    }\n}\n\n// File: contracts/lib/FeeRateModel.sol\n\n\n\ninterface IFeeRateImpl {\n    function getFeeRate(address pool, address trader) external view returns (uint256);\n}\n\ninterface IFeeRateModel {\n    function getFeeRate(address trader) external view returns (uint256);\n}\n\ncontract FeeRateModel is InitializableOwnable {\n    address public feeRateImpl;\n\n    function setFeeProxy(address _feeRateImpl) public onlyOwner {\n        feeRateImpl = _feeRateImpl;\n    }\n    \n    function getFeeRate(address trader) external view returns (uint256) {\n        if(feeRateImpl == address(0))\n            return 0;\n        return IFeeRateImpl(feeRateImpl).getFeeRate(msg.sender,trader);\n    }\n}\n\n// File: contracts/CrowdPooling/impl/CPStorage.sol\n\n\ncontract CPStorage is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    // ============ Constant ============\n    \n    uint256 internal constant _SETTLEMENT_EXPIRE_ = 86400 * 7;\n    uint256 internal constant _SETTEL_FUND_ = 200 finney;\n    bool public _IS_OPEN_TWAP_ = false;\n\n    // ============ Timeline ============\n\n    uint256 public _PHASE_BID_STARTTIME_;\n    uint256 public _PHASE_BID_ENDTIME_;\n    uint256 public _PHASE_CALM_ENDTIME_;\n    uint256 public _SETTLED_TIME_;\n    bool public _SETTLED_;\n\n    // ============ Core Address ============\n\n    IERC20 public _BASE_TOKEN_;\n    IERC20 public _QUOTE_TOKEN_;\n\n    // ============ Distribution Parameters ============\n\n    uint256 public _TOTAL_BASE_;\n    uint256 public _POOL_QUOTE_CAP_;\n\n    // ============ Settlement ============\n\n    uint256 public _QUOTE_RESERVE_;\n\n    uint256 public _UNUSED_BASE_;\n    uint256 public _UNUSED_QUOTE_;\n\n    uint256 public _TOTAL_SHARES_;\n    mapping(address => uint256) internal _SHARES_;\n    mapping(address => bool) public _CLAIMED_;\n\n    address public _POOL_FACTORY_;\n    address public _POOL_;\n    uint256 public _AVG_SETTLED_PRICE_;\n\n    // ============ Advanced Control ============\n\n    address public _MAINTAINER_;\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n    IPermissionManager public _BIDDER_PERMISSION_;\n\n    // ============ PMM Parameters ============\n\n    uint256 public _K_;\n    uint256 public _I_;\n\n    // ============ LP Token Vesting ============\n\n    uint256 public _TOTAL_LP_AMOUNT_;\n    uint256 public _FREEZE_DURATION_;\n    uint256 public _VESTING_DURATION_;\n    uint256 public _CLIFF_RATE_;\n\n    // ============ Modifiers ============\n\n    modifier phaseBid() {\n        require(\n            block.timestamp >= _PHASE_BID_STARTTIME_ && block.timestamp < _PHASE_BID_ENDTIME_,\n            \"NOT_PHASE_BID\"\n        );\n        _;\n    }\n\n    modifier phaseCalm() {\n        require(\n            block.timestamp >= _PHASE_BID_ENDTIME_ && block.timestamp < _PHASE_CALM_ENDTIME_,\n            \"NOT_PHASE_CALM\"\n        );\n        _;\n    }\n\n    modifier phaseBidOrCalm() {\n        require(\n            block.timestamp >= _PHASE_BID_STARTTIME_ && block.timestamp < _PHASE_CALM_ENDTIME_,\n            \"NOT_PHASE_BID_OR_CALM\"\n        );\n        _;\n    }\n\n    modifier phaseSettlement() {\n        require(block.timestamp >= _PHASE_CALM_ENDTIME_, \"NOT_PHASE_EXE\");\n        _;\n    }\n\n    modifier phaseVesting() {\n        require(_SETTLED_, \"NOT_VESTING\");\n        _;\n    }\n}\n\n// File: contracts/lib/DODOMath.sol\n\n/**\n * @title DODOMath\n * @author DODO Breeder\n *\n * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions\n */\nlibrary DODOMath {\n    using SafeMath for uint256;\n\n    /*\n        Integrate dodo curve from V1 to V2\n        require V0>=V1>=V2>0\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n        let V1-V2=delta\n        res = i*delta*(1-k+k(V0^2/V1/V2))\n\n        i is the price of V-res trading pair\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _GeneralIntegrate(\n        uint256 V0,\n        uint256 V1,\n        uint256 V2,\n        uint256 i,\n        uint256 k\n    ) internal pure returns (uint256) {\n        require(V0 > 0, \"TARGET_IS_ZERO\");\n        uint256 fairAmount = i.mul(V1.sub(V2)); // i*delta\n        if (k == 0) {\n            return fairAmount.div(DecimalMath.ONE);\n        }\n        uint256 V0V0V1V2 = DecimalMath.divFloor(V0.mul(V0).div(V1), V2);\n        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\n        return DecimalMath.ONE.sub(k).add(penalty).mul(fairAmount).div(DecimalMath.ONE2);\n    }\n\n    /*\n        Follow the integration function above\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\n\n        i is the price of delta-V trading pair\n        give out target of V\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _SolveQuadraticFunctionForTarget(\n        uint256 V1,\n        uint256 delta,\n        uint256 i,\n        uint256 k\n    ) internal pure returns (uint256) {\n        if (V1 == 0) {\n            return 0;\n        }\n        if (k == 0) {\n            return V1.add(DecimalMath.mulFloor(i, delta));\n        }\n        // V0 = V1*(1+(sqrt-1)/2k)\n        // sqrt = âˆš(1+4kidelta/V1)\n        // premium = 1+(sqrt-1)/2k\n        // uint256 sqrt = (4 * k).mul(i).mul(delta).div(V1).add(DecimalMath.ONE2).sqrt();\n        uint256 sqrt;\n        uint256 ki = (4 * k).mul(i);\n        if (ki == 0) {\n            sqrt = DecimalMath.ONE;\n        } else if ((ki * delta) / ki == delta) {\n            sqrt = (ki * delta).div(V1).add(DecimalMath.ONE2).sqrt();\n        } else {\n            sqrt = ki.div(V1).mul(delta).add(DecimalMath.ONE2).sqrt();\n        }\n        uint256 premium =\n            DecimalMath.divFloor(sqrt.sub(DecimalMath.ONE), k * 2).add(DecimalMath.ONE);\n        // V0 is greater than or equal to V1 according to the solution\n        return DecimalMath.mulFloor(V1, premium);\n    }\n\n    /*\n        Follow the integration expression above, we have:\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Given Q1 and deltaB, solve Q2\n        This is a quadratic function and the standard version is\n        aQ2^2 + bQ2 + c = 0, where\n        a=1-k\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\n        c=-kQ0^2 \n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\n        note: another root is negative, abondan\n\n        if deltaBSig=true, then Q2>Q1, user sell Q and receive B\n        if deltaBSig=false, then Q2<Q1, user sell B and receive Q\n        return |Q1-Q2|\n\n        as we only support sell amount as delta, the deltaB is always negative\n        the input ideltaB is actually -ideltaB in the equation\n\n        i is the price of delta-V trading pair\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _SolveQuadraticFunctionForTrade(\n        uint256 V0,\n        uint256 V1,\n        uint256 delta,\n        uint256 i,\n        uint256 k\n    ) internal pure returns (uint256) {\n        require(V0 > 0, \"TARGET_IS_ZERO\");\n        if (delta == 0) {\n            return 0;\n        }\n\n        if (k == 0) {\n            return DecimalMath.mulFloor(i, delta) > V1 ? V1 : DecimalMath.mulFloor(i, delta);\n        }\n\n        if (k == DecimalMath.ONE) {\n            // if k==1\n            // Q2=Q1/(1+ideltaBQ1/Q0/Q0)\n            // temp = ideltaBQ1/Q0/Q0\n            // Q2 = Q1/(1+temp)\n            // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))\n            // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));\n            uint256 temp;\n            uint256 idelta = i.mul(delta);\n            if (idelta == 0) {\n                temp = 0;\n            } else if ((idelta * V1) / idelta == V1) {\n                temp = (idelta * V1).div(V0.mul(V0));\n            } else {\n                temp = delta.mul(V1).div(V0).mul(i).div(V0);\n            }\n            return V1.mul(temp).div(temp.add(DecimalMath.ONE));\n        }\n\n        // calculate -b value and sig\n        // b = kQ0^2/Q1-i*deltaB-(1-k)Q1\n        // part1 = (1-k)Q1 >=0\n        // part2 = kQ0^2/Q1-i*deltaB >=0\n        // bAbs = abs(part1-part2)\n        // if part1>part2 => b is negative => bSig is false\n        // if part2>part1 => b is positive => bSig is true\n        uint256 part2 = k.mul(V0).div(V1).mul(V0).add(i.mul(delta)); // kQ0^2/Q1-i*deltaB\n        uint256 bAbs = DecimalMath.ONE.sub(k).mul(V1); // (1-k)Q1\n\n        bool bSig;\n        if (bAbs >= part2) {\n            bAbs = bAbs - part2;\n            bSig = false;\n        } else {\n            bAbs = part2 - bAbs;\n            bSig = true;\n        }\n        bAbs = bAbs.div(DecimalMath.ONE);\n\n        // calculate sqrt\n        uint256 squareRoot =\n            DecimalMath.mulFloor(\n                DecimalMath.ONE.sub(k).mul(4),\n                DecimalMath.mulFloor(k, V0).mul(V0)\n            ); // 4(1-k)kQ0^2\n        squareRoot = bAbs.mul(bAbs).add(squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\n\n        // final res\n        uint256 denominator = DecimalMath.ONE.sub(k).mul(2); // 2(1-k)\n        uint256 numerator;\n        if (bSig) {\n            numerator = squareRoot.sub(bAbs);\n        } else {\n            numerator = bAbs.add(squareRoot);\n        }\n\n        uint256 V2 = DecimalMath.divCeil(numerator, denominator);\n        if (V2 > V1) {\n            return 0;\n        } else {\n            return V1 - V2;\n        }\n    }\n}\n\n// File: contracts/lib/PMMPricing.sol\n\n\n/**\n * @title Pricing\n * @author DODO Breeder\n *\n * @notice DODO Pricing model\n */\n\nlibrary PMMPricing {\n    using SafeMath for uint256;\n\n    enum RState {ONE, ABOVE_ONE, BELOW_ONE}\n\n    struct PMMState {\n        uint256 i;\n        uint256 K;\n        uint256 B;\n        uint256 Q;\n        uint256 B0;\n        uint256 Q0;\n        RState R;\n    }\n\n    // ============ buy & sell ============\n\n    function sellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (uint256 receiveQuoteAmount, RState newR)\n    {\n        if (state.R == RState.ONE) {\n            // case 1: R=1\n            // R falls below one\n            receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);\n            newR = RState.BELOW_ONE;\n        } else if (state.R == RState.ABOVE_ONE) {\n            uint256 backToOnePayBase = state.B0.sub(state.B);\n            uint256 backToOneReceiveQuote = state.Q.sub(state.Q0);\n            // case 2: R>1\n            // complex case, R status depends on trading amount\n            if (payBaseAmount < backToOnePayBase) {\n                // case 2.1: R status do not change\n                receiveQuoteAmount = _RAboveSellBaseToken(state, payBaseAmount);\n                newR = RState.ABOVE_ONE;\n                if (receiveQuoteAmount > backToOneReceiveQuote) {\n                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount\n                    // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote\n                    receiveQuoteAmount = backToOneReceiveQuote;\n                }\n            } else if (payBaseAmount == backToOnePayBase) {\n                // case 2.2: R status changes to ONE\n                receiveQuoteAmount = backToOneReceiveQuote;\n                newR = RState.ONE;\n            } else {\n                // case 2.3: R status changes to BELOW_ONE\n                receiveQuoteAmount = backToOneReceiveQuote.add(\n                    _ROneSellBaseToken(state, payBaseAmount.sub(backToOnePayBase))\n                );\n                newR = RState.BELOW_ONE;\n            }\n        } else {\n            // state.R == RState.BELOW_ONE\n            // case 3: R<1\n            receiveQuoteAmount = _RBelowSellBaseToken(state, payBaseAmount);\n            newR = RState.BELOW_ONE;\n        }\n    }\n\n    function sellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (uint256 receiveBaseAmount, RState newR)\n    {\n        if (state.R == RState.ONE) {\n            receiveBaseAmount = _ROneSellQuoteToken(state, payQuoteAmount);\n            newR = RState.ABOVE_ONE;\n        } else if (state.R == RState.ABOVE_ONE) {\n            receiveBaseAmount = _RAboveSellQuoteToken(state, payQuoteAmount);\n            newR = RState.ABOVE_ONE;\n        } else {\n            uint256 backToOnePayQuote = state.Q0.sub(state.Q);\n            uint256 backToOneReceiveBase = state.B.sub(state.B0);\n            if (payQuoteAmount < backToOnePayQuote) {\n                receiveBaseAmount = _RBelowSellQuoteToken(state, payQuoteAmount);\n                newR = RState.BELOW_ONE;\n                if (receiveBaseAmount > backToOneReceiveBase) {\n                    receiveBaseAmount = backToOneReceiveBase;\n                }\n            } else if (payQuoteAmount == backToOnePayQuote) {\n                receiveBaseAmount = backToOneReceiveBase;\n                newR = RState.ONE;\n            } else {\n                receiveBaseAmount = backToOneReceiveBase.add(\n                    _ROneSellQuoteToken(state, payQuoteAmount.sub(backToOnePayQuote))\n                );\n                newR = RState.ABOVE_ONE;\n            }\n        }\n    }\n\n    // ============ R = 1 cases ============\n\n    function _ROneSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        // in theory Q2 <= targetQuoteTokenAmount\n        // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.Q0,\n                state.Q0,\n                payBaseAmount,\n                state.i,\n                state.K\n            );\n    }\n\n    function _ROneSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.B0,\n                state.B0,\n                payQuoteAmount,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n    }\n\n    // ============ R < 1 cases ============\n\n    function _RBelowSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return\n            DODOMath._GeneralIntegrate(\n                state.Q0,\n                state.Q.add(payQuoteAmount),\n                state.Q,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n    }\n\n    function _RBelowSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.Q0,\n                state.Q,\n                payBaseAmount,\n                state.i,\n                state.K\n            );\n    }\n\n    // ============ R > 1 cases ============\n\n    function _RAboveSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        return\n            DODOMath._GeneralIntegrate(\n                state.B0,\n                state.B.add(payBaseAmount),\n                state.B,\n                state.i,\n                state.K\n            );\n    }\n\n    function _RAboveSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.B0,\n                state.B,\n                payQuoteAmount,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n    }\n\n    // ============ Helper functions ============\n\n    function adjustedTarget(PMMState memory state) internal pure {\n        if (state.R == RState.BELOW_ONE) {\n            state.Q0 = DODOMath._SolveQuadraticFunctionForTarget(\n                state.Q,\n                state.B.sub(state.B0),\n                state.i,\n                state.K\n            );\n        } else if (state.R == RState.ABOVE_ONE) {\n            state.B0 = DODOMath._SolveQuadraticFunctionForTarget(\n                state.B,\n                state.Q.sub(state.Q0),\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n        }\n    }\n\n    function getMidPrice(PMMState memory state) internal pure returns (uint256) {\n        if (state.R == RState.BELOW_ONE) {\n            uint256 R = DecimalMath.divFloor(state.Q0.mul(state.Q0).div(state.Q), state.Q);\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\n            return DecimalMath.divFloor(state.i, R);\n        } else {\n            uint256 R = DecimalMath.divFloor(state.B0.mul(state.B0).div(state.B), state.B);\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\n            return DecimalMath.mulFloor(state.i, R);\n        }\n    }\n}\n\n// File: contracts/intf/IDODOCallee.sol\n\n\ninterface IDODOCallee {\n    function DVMSellShareCall(\n        address sender,\n        uint256 burnShareAmount,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function DVMFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function DPPFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function DSPFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function CPCancelCall(\n        address sender,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n\tfunction CPClaimBidCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n}\n\n// File: contracts/CrowdPooling/impl/CPFunding.sol\n\n\n\n\n\ncontract CPFunding is CPStorage {\n    using SafeERC20 for IERC20;\n    \n    // ============ Events ============\n    \n    event Bid(address to, uint256 amount, uint256 fee);\n    event Cancel(address to,uint256 amount);\n    event Settle();\n\n    // ============ BID & CALM PHASE ============\n    \n    modifier isBidderAllow(address bidder) {\n        require(_BIDDER_PERMISSION_.isAllowed(bidder), \"BIDDER_NOT_ALLOWED\");\n        _;\n    }\n\n    function bid(address to) external phaseBid preventReentrant isBidderAllow(to) {\n        uint256 input = _getQuoteInput();\n        uint256 mtFee = DecimalMath.mulFloor(input, _MT_FEE_RATE_MODEL_.getFeeRate(to));\n        _transferQuoteOut(_MAINTAINER_, mtFee);\n        _mintShares(to, input.sub(mtFee));\n        _sync();\n        emit Bid(to, input, mtFee);\n    }\n\n    function cancel(address to, uint256 amount, bytes calldata data) external phaseBidOrCalm preventReentrant {\n        require(_SHARES_[msg.sender] >= amount, \"SHARES_NOT_ENOUGH\");\n        _burnShares(msg.sender, amount);\n        _transferQuoteOut(to, amount);\n        _sync();\n\n        if(data.length > 0){\n            IDODOCallee(to).CPCancelCall(msg.sender,amount,data);\n        }\n\n        emit Cancel(msg.sender,amount);\n    }\n\n    function _mintShares(address to, uint256 amount) internal {\n        _SHARES_[to] = _SHARES_[to].add(amount);\n        _TOTAL_SHARES_ = _TOTAL_SHARES_.add(amount);\n    }\n\n    function _burnShares(address from, uint256 amount) internal {\n        _SHARES_[from] = _SHARES_[from].sub(amount);\n        _TOTAL_SHARES_ = _TOTAL_SHARES_.sub(amount);\n    }\n\n    // ============ SETTLEMENT ============\n\n    function settle() external phaseSettlement preventReentrant {\n        _settle();\n\n        (uint256 poolBase, uint256 poolQuote, uint256 poolI, uint256 unUsedBase, uint256 unUsedQuote) = getSettleResult();\n        _UNUSED_BASE_ = unUsedBase;\n        _UNUSED_QUOTE_ = unUsedQuote;\n\n        address _poolBaseToken;\n        address _poolQuoteToken;\n\n        if (_UNUSED_BASE_ > poolBase) {\n            _poolBaseToken = address(_QUOTE_TOKEN_);\n            _poolQuoteToken = address(_BASE_TOKEN_);\n        } else {\n            _poolBaseToken = address(_BASE_TOKEN_);\n            _poolQuoteToken = address(_QUOTE_TOKEN_);\n        }\n\n        _POOL_ = IDVMFactory(_POOL_FACTORY_).createDODOVendingMachine(\n            _poolBaseToken,\n            _poolQuoteToken,\n            3e15, // 0.3% lp feeRate\n            poolI,\n            DecimalMath.ONE,\n            _IS_OPEN_TWAP_\n        );\n\n        uint256 avgPrice = unUsedBase == 0 ? _I_ : DecimalMath.divCeil(poolQuote, unUsedBase);\n        _AVG_SETTLED_PRICE_ = avgPrice;\n\n        _transferBaseOut(_POOL_, poolBase);\n        _transferQuoteOut(_POOL_, poolQuote);\n\n        (_TOTAL_LP_AMOUNT_, ,) = IDVM(_POOL_).buyShares(address(this));\n\n        msg.sender.transfer(_SETTEL_FUND_);\n\n        emit Settle();\n    }\n\n    // in case something wrong with base token contract\n    function emergencySettle() external phaseSettlement preventReentrant {\n        require(block.timestamp >= _PHASE_CALM_ENDTIME_.add(_SETTLEMENT_EXPIRE_), \"NOT_EMERGENCY\");\n        _settle();\n        _UNUSED_QUOTE_ = _QUOTE_TOKEN_.balanceOf(address(this));\n    }\n\n    function _settle() internal {\n        require(!_SETTLED_, \"ALREADY_SETTLED\");\n        _SETTLED_ = true;\n        _SETTLED_TIME_ = block.timestamp;\n    }\n\n    // ============ Pricing ============\n\n    function getSettleResult() public view returns (uint256 poolBase, uint256 poolQuote, uint256 poolI, uint256 unUsedBase, uint256 unUsedQuote) {\n        poolQuote = _QUOTE_TOKEN_.balanceOf(address(this));\n        if (poolQuote > _POOL_QUOTE_CAP_) {\n            poolQuote = _POOL_QUOTE_CAP_;\n        }\n        (uint256 soldBase,) = PMMPricing.sellQuoteToken(_getPMMState(), poolQuote);\n        poolBase = _TOTAL_BASE_.sub(soldBase);\n\n        unUsedQuote = _QUOTE_TOKEN_.balanceOf(address(this)).sub(poolQuote);\n        unUsedBase = _BASE_TOKEN_.balanceOf(address(this)).sub(poolBase);\n\n        // Try to make midPrice equal to avgPrice\n        // k=1, If quote and base are not balanced, one side must be cut off\n        // DVM truncated quote, but if more quote than base entering the pool, we need set the quote to the base\n\n        // m = avgPrice\n        // i = m (1-quote/(m*base))\n        // if quote = m*base i = 1\n        // if quote > m*base reverse\n        uint256 avgPrice = unUsedBase == 0 ? _I_ : DecimalMath.divCeil(poolQuote, unUsedBase);\n        uint256 baseDepth = DecimalMath.mulFloor(avgPrice, poolBase);\n\n        if (poolQuote == 0) {\n            // ask side only DVM\n            poolI = _I_;\n        } else if (unUsedBase== poolBase) {\n            // standard bonding curve\n            poolI = 1;\n        } else if (unUsedBase < poolBase) {\n            // poolI up round\n            uint256 ratio = DecimalMath.ONE.sub(DecimalMath.divFloor(poolQuote, baseDepth));\n            poolI = avgPrice.mul(ratio).mul(ratio).divCeil(DecimalMath.ONE2);\n        } else if (unUsedBase > poolBase) {\n            // poolI down round\n            uint256 ratio = DecimalMath.ONE.sub(DecimalMath.divCeil(baseDepth, poolQuote));\n            poolI = ratio.mul(ratio).div(avgPrice);\n        }\n    }\n\n    function _getPMMState() internal view returns (PMMPricing.PMMState memory state) {\n        state.i = _I_;\n        state.K = _K_;\n        state.B = _TOTAL_BASE_;\n        state.Q = 0;\n        state.B0 = state.B;\n        state.Q0 = 0;\n        state.R = PMMPricing.RState.ONE;\n    }\n\n    function getExpectedAvgPrice() external view returns (uint256) {\n        require(!_SETTLED_, \"ALREADY_SETTLED\");\n        (uint256 poolBase, uint256 poolQuote, , , ) = getSettleResult();\n        return DecimalMath.divCeil(poolQuote, _BASE_TOKEN_.balanceOf(address(this)).sub(poolBase));\n    }\n\n    // ============ Asset In ============\n\n    function _getQuoteInput() internal view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(_QUOTE_RESERVE_);\n    }\n\n    // ============ Set States ============\n\n    function _sync() internal {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_RESERVE_ = quoteBalance;\n        }\n    }\n\n    // ============ Asset Out ============\n\n    function _transferBaseOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _BASE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _transferQuoteOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function getShares(address user) external view returns (uint256) {\n        return _SHARES_[user];\n    }\n}\n\n// File: contracts/CrowdPooling/impl/CPVesting.sol\n\n\n\n\n\n/**\n * @title CPVesting\n * @author DODO Breeder\n *\n * @notice Lock Token and release it linearly\n */\n\ncontract CPVesting is CPFunding {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ============ Events ============\n    \n    event Claim(address user, uint256 baseAmount, uint256 quoteAmount);\n    event ClaimLP(uint256 amount);\n\n\n    // ================ Modifiers ================\n\n    modifier afterSettlement() {\n        require(_SETTLED_, \"NOT_SETTLED\");\n        _;\n    }\n\n    modifier afterFreeze() {\n        require(_SETTLED_ && block.timestamp >= _SETTLED_TIME_.add(_FREEZE_DURATION_), \"FREEZED\");\n        _;\n    }\n\n    // ============ Bidder Functions ============\n\n    function bidderClaim(address to,bytes calldata data) external afterSettlement {\n        require(!_CLAIMED_[msg.sender], \"ALREADY_CLAIMED\");\n        _CLAIMED_[msg.sender] = true;\n\n\t\tuint256 baseAmount = _UNUSED_BASE_.mul(_SHARES_[msg.sender]).div(_TOTAL_SHARES_);\n\t\tuint256 quoteAmount = _UNUSED_QUOTE_.mul(_SHARES_[msg.sender]).div(_TOTAL_SHARES_);\n\n        _transferBaseOut(to, baseAmount);\n        _transferQuoteOut(to, quoteAmount);\n\n\t\tif(data.length>0){\n\t\t\tIDODOCallee(to).CPClaimBidCall(msg.sender,baseAmount,quoteAmount,data);\n\t\t}\n\n        emit Claim(msg.sender, baseAmount, quoteAmount);\n    }\n\n    // ============ Owner Functions ============\n\n    function claimLPToken() external onlyOwner afterFreeze {\n        uint256 lpAmount = getClaimableLPToken();\n        IERC20(_POOL_).safeTransfer(_OWNER_, lpAmount);\n        emit ClaimLP(lpAmount);\n    }\n\n    function getClaimableLPToken() public view afterFreeze returns (uint256) {\n        uint256 remainingLPToken = DecimalMath.mulFloor(\n            getRemainingLPRatio(block.timestamp),\n            _TOTAL_LP_AMOUNT_\n        );\n        return IERC20(_POOL_).balanceOf(address(this)).sub(remainingLPToken);\n    }\n\n    function getRemainingLPRatio(uint256 timestamp) public view afterFreeze returns (uint256) {\n        uint256 timePast = timestamp.sub(_SETTLED_TIME_.add(_FREEZE_DURATION_));\n        if (timePast < _VESTING_DURATION_) {\n            uint256 remainingTime = _VESTING_DURATION_.sub(timePast);\n            return DecimalMath.ONE.sub(_CLIFF_RATE_).mul(remainingTime).div(_VESTING_DURATION_);\n        } else {\n            return 0;\n        }\n    }\n}\n\n// File: contracts/CrowdPooling/impl/CP.sol\n\n\n\n/**\n * @title DODO CrowdPooling\n * @author DODO Breeder\n *\n * @notice CrowdPooling initialization\n */\ncontract CP is CPVesting {\n    using SafeMath for uint256;\n\n    receive() external payable {}\n\n    function init(\n        address[] calldata addressList,\n        uint256[] calldata timeLine,\n        uint256[] calldata valueList,\n        bool isOpenTWAP\n    ) external {\n        /*\n        Address List\n        0. owner\n        1. maintainer\n        2. baseToken\n        3. quoteToken\n        4. permissionManager\n        5. feeRateModel\n        6. poolFactory\n      */\n\n        require(addressList.length == 7, \"LIST_LENGTH_WRONG\");\n\n        initOwner(addressList[0]);\n        _MAINTAINER_ = addressList[1];\n        _BASE_TOKEN_ = IERC20(addressList[2]);\n        _QUOTE_TOKEN_ = IERC20(addressList[3]);\n        _BIDDER_PERMISSION_ = IPermissionManager(addressList[4]);\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(addressList[5]);\n        _POOL_FACTORY_ = addressList[6];\n\n        /*\n        Time Line\n        0. phase bid starttime\n        1. phase bid duration\n        2. phase calm duration\n        3. freeze duration\n        4. vesting duration\n        */\n\n        require(timeLine.length == 5, \"LIST_LENGTH_WRONG\");\n\n        _PHASE_BID_STARTTIME_ = timeLine[0];\n        _PHASE_BID_ENDTIME_ = _PHASE_BID_STARTTIME_.add(timeLine[1]);\n        _PHASE_CALM_ENDTIME_ = _PHASE_BID_ENDTIME_.add(timeLine[2]);\n\n        _FREEZE_DURATION_ = timeLine[3];\n        _VESTING_DURATION_ = timeLine[4];\n\n        require(block.timestamp <= _PHASE_BID_STARTTIME_, \"TIMELINE_WRONG\");\n\n        /*\n        Value List\n        0. pool quote cap\n        1. k\n        2. i\n        3. cliff rate\n        */\n\n        require(valueList.length == 4, \"LIST_LENGTH_WRONG\");\n\n        _POOL_QUOTE_CAP_ = valueList[0];\n        _K_ = valueList[1];\n        _I_ = valueList[2];\n        _CLIFF_RATE_ = valueList[3];\n\n        require(_I_ > 0 && _I_ <= 1e36, \"I_VALUE_WRONG\");\n        require(_K_ <= 1e18, \"K_VALUE_WRONG\");\n        require(_CLIFF_RATE_ <= 1e18, \"CLIFF_RATE_WRONG\");\n\n        _TOTAL_BASE_ = _BASE_TOKEN_.balanceOf(address(this));\n\n        _IS_OPEN_TWAP_ = isOpenTWAP;\n\n        require(address(this).balance == _SETTEL_FUND_, \"SETTLE_FUND_NOT_MATCH\");\n    }\n}\n"
    }
  }
}