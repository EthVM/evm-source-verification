{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "BondMakerHelper.sol": {
      "content": "pragma solidity 0.6.6;\r\n\r\n// File: contracts/oracle/LatestPriceOracleInterface.sol\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the price oracle.\r\n */\r\ninterface LatestPriceOracleInterface {\r\n    /**\r\n     * @dev Returns `true`if oracle is working.\r\n     */\r\n    function isWorking() external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the last updated price. Decimals is 8.\r\n     **/\r\n    function latestPrice() external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the timestamp of the last updated price.\r\n     */\r\n    function latestTimestamp() external returns (uint256);\r\n}\r\n\r\n// File: contracts/oracle/PriceOracleInterface.sol\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the price oracle.\r\n */\r\ninterface PriceOracleInterface is LatestPriceOracleInterface {\r\n    /**\r\n     * @dev Returns the latest id. The id start from 1 and increments by 1.\r\n     */\r\n    function latestId() external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the historical price specified by `id`. Decimals is 8.\r\n     */\r\n    function getPrice(uint256 id) external returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the timestamp of historical price specified by `id`.\r\n     */\r\n    function getTimestamp(uint256 id) external returns (uint256);\r\n}\r\n\r\n// File: contracts/util/TransferETHInterface.sol\r\n\r\n\r\n\r\n\r\ninterface TransferETHInterface {\r\n    receive() external payable;\r\n\r\n    event LogTransferETH(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/bondToken/BondTokenInterface.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface BondTokenInterface is IERC20 {\r\n    event LogExpire(uint128 rateNumerator, uint128 rateDenominator, bool firstTime);\r\n\r\n    function mint(address account, uint256 amount) external returns (bool success);\r\n\r\n    function expire(uint128 rateNumerator, uint128 rateDenominator)\r\n        external\r\n        returns (bool firstTime);\r\n\r\n    function simpleBurn(address account, uint256 amount) external returns (bool success);\r\n\r\n    function burn(uint256 amount) external returns (bool success);\r\n\r\n    function burnAll() external returns (uint256 amount);\r\n\r\n    function getRate() external view returns (uint128 rateNumerator, uint128 rateDenominator);\r\n}\r\n\r\n// File: contracts/bondMaker/BondMakerInterface.sol\r\n\r\n\r\n\r\n\r\n\r\ninterface BondMakerInterface {\r\n    event LogNewBond(\r\n        bytes32 indexed bondID,\r\n        address indexed bondTokenAddress,\r\n        uint256 indexed maturity,\r\n        bytes32 fnMapID\r\n    );\r\n\r\n    event LogNewBondGroup(\r\n        uint256 indexed bondGroupID,\r\n        uint256 indexed maturity,\r\n        uint64 indexed sbtStrikePrice,\r\n        bytes32[] bondIDs\r\n    );\r\n\r\n    event LogIssueNewBonds(uint256 indexed bondGroupID, address indexed issuer, uint256 amount);\r\n\r\n    event LogReverseBondGroupToCollateral(\r\n        uint256 indexed bondGroupID,\r\n        address indexed owner,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogExchangeEquivalentBonds(\r\n        address indexed owner,\r\n        uint256 indexed inputBondGroupID,\r\n        uint256 indexed outputBondGroupID,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogLiquidateBond(bytes32 indexed bondID, uint128 rateNumerator, uint128 rateDenominator);\r\n\r\n    function registerNewBond(uint256 maturity, bytes calldata fnMap)\r\n        external\r\n        returns (\r\n            bytes32 bondID,\r\n            address bondTokenAddress,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function registerNewBondGroup(bytes32[] calldata bondIDList, uint256 maturity)\r\n        external\r\n        returns (uint256 bondGroupID);\r\n\r\n    function reverseBondGroupToCollateral(uint256 bondGroupID, uint256 amount)\r\n        external\r\n        returns (bool success);\r\n\r\n    function exchangeEquivalentBonds(\r\n        uint256 inputBondGroupID,\r\n        uint256 outputBondGroupID,\r\n        uint256 amount,\r\n        bytes32[] calldata exceptionBonds\r\n    ) external returns (bool);\r\n\r\n    function liquidateBond(uint256 bondGroupID, uint256 oracleHintID)\r\n        external\r\n        returns (uint256 totalPayment);\r\n\r\n    function collateralAddress() external view returns (address);\r\n\r\n    function oracleAddress() external view returns (PriceOracleInterface);\r\n\r\n    function feeTaker() external view returns (address);\r\n\r\n    function decimalsOfBond() external view returns (uint8);\r\n\r\n    function decimalsOfOraclePrice() external view returns (uint8);\r\n\r\n    function maturityScale() external view returns (uint256);\r\n\r\n    function nextBondGroupID() external view returns (uint256);\r\n\r\n    function getBond(bytes32 bondID)\r\n        external\r\n        view\r\n        returns (\r\n            address bondAddress,\r\n            uint256 maturity,\r\n            uint64 solidStrikePrice,\r\n            bytes32 fnMapID\r\n        );\r\n\r\n    function getFnMap(bytes32 fnMapID) external view returns (bytes memory fnMap);\r\n\r\n    function getBondGroup(uint256 bondGroupID)\r\n        external\r\n        view\r\n        returns (bytes32[] memory bondIDs, uint256 maturity);\r\n\r\n    function generateFnMapID(bytes calldata fnMap) external view returns (bytes32 fnMapID);\r\n\r\n    function generateBondID(uint256 maturity, bytes calldata fnMap)\r\n        external\r\n        view\r\n        returns (bytes32 bondID);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SignedSafeMath.sol\r\n\r\n\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Multiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/SafeCast.sol\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n// File: contracts/math/UseSafeMath.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice ((a - 1) / b) + 1 = (a + b -1) / b\r\n * for example a.add(10**18 -1).div(10**18) = a.sub(1).div(10**18) + 1\r\n */\r\n\r\nlibrary SafeMathDivRoundUp {\r\n    using SafeMath for uint256;\r\n\r\n    function divRoundUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        require(b > 0, errorMessage);\r\n        return ((a - 1) / b) + 1;\r\n    }\r\n\r\n    function divRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return divRoundUp(a, b, \"SafeMathDivRoundUp: modulo by zero\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title UseSafeMath\r\n * @dev One can use SafeMath for not only uint256 but also uin64 or uint16,\r\n * and also can use SafeCast for uint256.\r\n * For example:\r\n *   uint64 a = 1;\r\n *   uint64 b = 2;\r\n *   a = a.add(b).toUint64() // `a` become 3 as uint64\r\n * In addition, one can use SignedSafeMath and SafeCast.toUint256(int256) for int256.\r\n * In the case of the operation to the uint64 value, one needs to cast the value into int256 in\r\n * advance to use `sub` as SignedSafeMath.sub not SafeMath.sub.\r\n * For example:\r\n *   int256 a = 1;\r\n *   uint64 b = 2;\r\n *   int256 c = 3;\r\n *   a = a.add(int256(b).sub(c)); // `a` becomes 0 as int256\r\n *   b = a.toUint256().toUint64(); // `b` becomes 0 as uint64\r\n */\r\nabstract contract UseSafeMath {\r\n    using SafeMath for uint256;\r\n    using SafeMathDivRoundUp for uint256;\r\n    using SafeMath for uint64;\r\n    using SafeMathDivRoundUp for uint64;\r\n    using SafeMath for uint16;\r\n    using SignedSafeMath for int256;\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n}\r\n\r\n// File: contracts/util/Polyline.sol\r\n\r\n\r\n\r\n\r\ncontract Polyline is UseSafeMath {\r\n    struct Point {\r\n        uint64 x; // Value of the x-axis of the x-y plane\r\n        uint64 y; // Value of the y-axis of the x-y plane\r\n    }\r\n\r\n    struct LineSegment {\r\n        Point left; // The left end of the line definition range\r\n        Point right; // The right end of the line definition range\r\n    }\r\n\r\n    /**\r\n     * @notice Return the value of y corresponding to x on the given line. line in the form of\r\n     * a rational number (numerator / denominator).\r\n     * If you treat a line as a line segment instead of a line, you should run\r\n     * includesDomain(line, x) to check whether x is included in the line's domain or not.\r\n     * @dev To guarantee accuracy, the bit length of the denominator must be greater than or equal\r\n     * to the bit length of x, and the bit length of the numerator must be greater than or equal\r\n     * to the sum of the bit lengths of x and y.\r\n     */\r\n    function _mapXtoY(LineSegment memory line, uint64 x)\r\n        internal\r\n        pure\r\n        returns (uint128 numerator, uint64 denominator)\r\n    {\r\n        int256 x1 = int256(line.left.x);\r\n        int256 y1 = int256(line.left.y);\r\n        int256 x2 = int256(line.right.x);\r\n        int256 y2 = int256(line.right.y);\r\n\r\n        require(x2 > x1, \"must be left.x < right.x\");\r\n\r\n        denominator = uint64(x2 - x1);\r\n\r\n        // Calculate y = ((x2 - x) * y1 + (x - x1) * y2) / (x2 - x1)\r\n        // in the form of a fraction (numerator / denominator).\r\n        int256 n = (x - x1) * y2 + (x2 - x) * y1;\r\n\r\n        require(n >= 0, \"underflow n\");\r\n        require(n < 2**128, \"system error: overflow n\");\r\n        numerator = uint128(n);\r\n    }\r\n\r\n    /**\r\n     * @notice Checking that a line segment is a valid format.\r\n     */\r\n    function assertLineSegment(LineSegment memory segment) internal pure {\r\n        uint64 x1 = segment.left.x;\r\n        uint64 x2 = segment.right.x;\r\n        require(x1 < x2, \"must be left.x < right.x\");\r\n    }\r\n\r\n    /**\r\n     * @notice Checking that a polyline is a valid format.\r\n     */\r\n    function assertPolyline(LineSegment[] memory polyline) internal pure {\r\n        uint256 numOfSegment = polyline.length;\r\n        require(numOfSegment != 0, \"polyline must not be empty array\");\r\n\r\n        LineSegment memory leftSegment = polyline[0]; // mutable\r\n        int256 gradientNumerator = int256(leftSegment.right.y) - int256(leftSegment.left.y); // mutable\r\n        int256 gradientDenominator = int256(leftSegment.right.x) - int256(leftSegment.left.x); // mutable\r\n\r\n        // The beginning of the first line segment's domain is 0.\r\n        require(\r\n            leftSegment.left.x == uint64(0),\r\n            \"the x coordinate of left end of the first segment must be 0\"\r\n        );\r\n        // The value of y when x is 0 is 0.\r\n        require(\r\n            leftSegment.left.y == uint64(0),\r\n            \"the y coordinate of left end of the first segment must be 0\"\r\n        );\r\n\r\n        // Making sure that the first line segment is a correct format.\r\n        assertLineSegment(leftSegment);\r\n\r\n        // The end of the domain of a segment and the beginning of the domain of the adjacent\r\n        // segment must coincide.\r\n        LineSegment memory rightSegment; // mutable\r\n        for (uint256 i = 1; i < numOfSegment; i++) {\r\n            rightSegment = polyline[i];\r\n\r\n            // Make sure that the i-th line segment is a correct format.\r\n            assertLineSegment(rightSegment);\r\n\r\n            // Checking that the x-coordinates are same.\r\n            require(\r\n                leftSegment.right.x == rightSegment.left.x,\r\n                \"given polyline has an undefined domain.\"\r\n            );\r\n\r\n            // Checking that the y-coordinates are same.\r\n            require(\r\n                leftSegment.right.y == rightSegment.left.y,\r\n                \"given polyline is not a continuous function\"\r\n            );\r\n\r\n            int256 nextGradientNumerator = int256(rightSegment.right.y) -\r\n                int256(rightSegment.left.y);\r\n            int256 nextGradientDenominator = int256(rightSegment.right.x) -\r\n                int256(rightSegment.left.x);\r\n            require(\r\n                nextGradientNumerator * gradientDenominator !=\r\n                    nextGradientDenominator * gradientNumerator,\r\n                \"the sequential segments must not have the same gradient\"\r\n            );\r\n\r\n            leftSegment = rightSegment;\r\n            gradientNumerator = nextGradientNumerator;\r\n            gradientDenominator = nextGradientDenominator;\r\n        }\r\n\r\n        // rightSegment is lastSegment\r\n\r\n        // About the last line segment.\r\n        require(\r\n            gradientNumerator >= 0 && gradientNumerator <= gradientDenominator,\r\n            \"the gradient of last line segment must be non-negative, and equal to or less than 1\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice zip a LineSegment structure to uint256\r\n     * @return zip uint256( 0 ... 0 | x1 | y1 | x2 | y2 )\r\n     */\r\n    function zipLineSegment(LineSegment memory segment) internal pure returns (uint256 zip) {\r\n        uint256 x1U256 = uint256(segment.left.x) << (64 + 64 + 64); // uint64\r\n        uint256 y1U256 = uint256(segment.left.y) << (64 + 64); // uint64\r\n        uint256 x2U256 = uint256(segment.right.x) << 64; // uint64\r\n        uint256 y2U256 = uint256(segment.right.y); // uint64\r\n        zip = x1U256 | y1U256 | x2U256 | y2U256;\r\n    }\r\n\r\n    /**\r\n     * @notice unzip uint256 to a LineSegment structure\r\n     */\r\n    function unzipLineSegment(uint256 zip) internal pure returns (LineSegment memory) {\r\n        uint64 x1 = uint64(zip >> (64 + 64 + 64));\r\n        uint64 y1 = uint64(zip >> (64 + 64));\r\n        uint64 x2 = uint64(zip >> 64);\r\n        uint64 y2 = uint64(zip);\r\n        return LineSegment({left: Point({x: x1, y: y1}), right: Point({x: x2, y: y2})});\r\n    }\r\n\r\n    /**\r\n     * @notice unzip the fnMap to uint256[].\r\n     */\r\n    function decodePolyline(bytes memory fnMap) internal pure returns (uint256[] memory) {\r\n        return abi.decode(fnMap, (uint256[]));\r\n    }\r\n}\r\n\r\n// File: contracts/helper/BondMakerHelper.sol\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\ncontract BondMakerHelper is Polyline {\r\n    event LogRegisterSbt(bytes32 bondID);\r\n    event LogRegisterLbt(bytes32 bondID);\r\n    event LogRegisterBondAndBondGroup(uint256 indexed bondGroupID, bytes32[] bondIDs);\r\n\r\n    function registerSbt(\r\n        address bondMakerAddress,\r\n        uint64 strikePrice,\r\n        uint256 maturity\r\n    ) external returns (bytes32 bondID) {\r\n        require(strikePrice != 0, \"the strike price must be non-zero\");\r\n        require(strikePrice <= uint64(-2), \"the strike price is too large\");\r\n\r\n        BondMakerInterface bondMaker = BondMakerInterface(bondMakerAddress);\r\n        try bondMaker.oracleAddress().latestPrice() returns (uint256 spotPrice) {\r\n            require(\r\n                strikePrice >= spotPrice / 10 && strikePrice <= spotPrice * 10,\r\n                \"must be 0.1 <= S/K <= 10\"\r\n            );\r\n        } catch {}\r\n\r\n        bytes memory fnMap = _getSbtFnMap(strikePrice);\r\n        (bondID, , ) = bondMaker.registerNewBond(maturity, fnMap);\r\n\r\n        emit LogRegisterSbt(bondID);\r\n    }\r\n\r\n    function registerLbt(\r\n        address bondMakerAddress,\r\n        uint64 strikePrice,\r\n        uint256 maturity\r\n    ) external returns (bytes32 bondID) {\r\n        require(strikePrice != 0, \"the strike price must be non-zero\");\r\n        require(strikePrice <= uint64(-2), \"the strike price is too large\");\r\n\r\n        BondMakerInterface bondMaker = BondMakerInterface(bondMakerAddress);\r\n        try bondMaker.oracleAddress().latestPrice() returns (uint256 spotPrice) {\r\n            require(\r\n                strikePrice >= spotPrice / 10 && strikePrice <= spotPrice * 10,\r\n                \"must be 0.1 <= S/K <= 10\"\r\n            );\r\n        } catch {}\r\n\r\n        bytes memory fnMap = _getLbtFnMap(strikePrice);\r\n        (bondID, , ) = bondMaker.registerNewBond(maturity, fnMap);\r\n\r\n        emit LogRegisterLbt(bondID);\r\n    }\r\n\r\n    function registerSbtAndLbtAndBondGroup(\r\n        address bondMakerAddress,\r\n        uint64 strikePrice,\r\n        uint256 maturity\r\n    ) external returns (uint256 bondGroupID) {\r\n        require(strikePrice != 0, \"the SBT strike price must be non-zero\");\r\n\r\n        BondMakerInterface bondMaker = BondMakerInterface(bondMakerAddress);\r\n        try bondMaker.oracleAddress().latestPrice() returns (uint256 spotPrice) {\r\n            require(\r\n                strikePrice >= spotPrice / 10 && strikePrice <= spotPrice * 10,\r\n                \"must be 0.1 <= S/K <= 10\"\r\n            );\r\n        } catch {}\r\n\r\n        bytes[] memory fnMaps = _getSbtAndLbtFnMap(strikePrice);\r\n        bondGroupID = _registerBondAndBondGroup(bondMakerAddress, fnMaps, maturity);\r\n    }\r\n\r\n    function registerExoticBondAndBondGroup(\r\n        address bondMakerAddress,\r\n        uint64 sbtstrikePrice,\r\n        uint64 lbtStrikePrice,\r\n        uint256 maturity\r\n    ) external returns (uint256 bondGroupID) {\r\n        require(sbtstrikePrice != 0, \"the SBT strike price must be non-zero\");\r\n\r\n        BondMakerInterface bondMaker = BondMakerInterface(bondMakerAddress);\r\n        try bondMaker.oracleAddress().latestPrice() returns (uint256 spotPrice) {\r\n            require(\r\n                sbtstrikePrice >= spotPrice / 10 && sbtstrikePrice <= spotPrice * 10,\r\n                \"must be 0.1 <= S/K <= 10\"\r\n            );\r\n            require(\r\n                lbtStrikePrice >= spotPrice / 10 && lbtStrikePrice <= spotPrice * 10,\r\n                \"must be 0.1 <= S/K <= 10\"\r\n            );\r\n        } catch {}\r\n\r\n        bytes[] memory fnMaps = _getExoticFnMap(sbtstrikePrice, lbtStrikePrice);\r\n        bondGroupID = _registerBondAndBondGroup(bondMakerAddress, fnMaps, maturity);\r\n    }\r\n\r\n    function registerBondAndBondGroup(\r\n        address bondMakerAddress,\r\n        bytes[] calldata fnMaps,\r\n        uint256 maturity\r\n    ) external returns (uint256 bondGroupID) {\r\n        bondGroupID = _registerBondAndBondGroup(bondMakerAddress, fnMaps, maturity);\r\n    }\r\n\r\n    function getSbtFnMap(uint64 strikePrice) external pure returns (bytes memory fnMap) {\r\n        fnMap = _getSbtFnMap(strikePrice);\r\n    }\r\n\r\n    function getLbtFnMap(uint64 strikePrice) external pure returns (bytes memory fnMap) {\r\n        fnMap = _getLbtFnMap(strikePrice);\r\n    }\r\n\r\n    function getSbtAndLbtFnMap(uint64 strikePrice) external pure returns (bytes[] memory fnMaps) {\r\n        fnMaps = _getSbtAndLbtFnMap(strikePrice);\r\n    }\r\n\r\n    function getExoticFnMap(uint64 sbtStrikePrice, uint64 lbtStrikePrice)\r\n        external\r\n        pure\r\n        returns (bytes[] memory fnMaps)\r\n    {\r\n        fnMaps = _getExoticFnMap(sbtStrikePrice, lbtStrikePrice);\r\n    }\r\n\r\n    /**\r\n     * @dev register bonds and bond group\r\n     */\r\n    function _registerBondAndBondGroup(\r\n        address bondMakerAddress,\r\n        bytes[] memory fnMaps,\r\n        uint256 maturity\r\n    ) internal returns (uint256 bondGroupID) {\r\n        require(fnMaps.length != 0, \"fnMaps must be non-empty list\");\r\n\r\n        BondMakerInterface bondMaker = BondMakerInterface(bondMakerAddress);\r\n        bytes32[] memory bondIDs = new bytes32[](fnMaps.length);\r\n        for (uint256 j = 0; j < fnMaps.length; j++) {\r\n            bytes32 bondID = bondMaker.generateBondID(maturity, fnMaps[j]);\r\n            (address bondAddress, , , ) = bondMaker.getBond(bondID);\r\n            if (bondAddress == address(0)) {\r\n                (bytes32 returnedBondID, , ) = bondMaker.registerNewBond(maturity, fnMaps[j]);\r\n                require(\r\n                    returnedBondID == bondID,\r\n                    \"system error: bondID was not generated as expected\"\r\n                );\r\n            }\r\n            bondIDs[j] = bondID;\r\n        }\r\n\r\n        bondGroupID = bondMaker.registerNewBondGroup(bondIDs, maturity);\r\n        emit LogRegisterBondAndBondGroup(bondGroupID, bondIDs);\r\n    }\r\n\r\n    /**\r\n     * @return fnMaps divided into SBT and LBT\r\n     */\r\n    function _getSbtAndLbtFnMap(uint64 strikePrice) internal pure returns (bytes[] memory fnMaps) {\r\n        require(strikePrice <= uint64(-2), \"the strike price is too large\");\r\n\r\n        fnMaps = new bytes[](2);\r\n        fnMaps[0] = _getSbtFnMap(strikePrice);\r\n        fnMaps[1] = _getLbtFnMap(strikePrice);\r\n    }\r\n\r\n    /**\r\n     * @return fnMaps divided into pure SBT, LBT, semi-SBT and triangle bond.\r\n     */\r\n    function _getExoticFnMap(uint64 sbtStrikePrice, uint64 lbtStrikePrice)\r\n        internal\r\n        pure\r\n        returns (bytes[] memory fnMaps)\r\n    {\r\n        require(\r\n            sbtStrikePrice < lbtStrikePrice,\r\n            \"the SBT strike price must be less than the LBT strike price\"\r\n        );\r\n        uint64 semiSbtStrikePrice = lbtStrikePrice - sbtStrikePrice;\r\n        require(semiSbtStrikePrice % 2 == 0, \"the triangle peak must be integer\");\r\n        uint64 trianglePeak = semiSbtStrikePrice / 2;\r\n        uint64 triangleRightmost = semiSbtStrikePrice + lbtStrikePrice;\r\n        require(\r\n            triangleRightmost > lbtStrikePrice,\r\n            \"the triangle rightmost must be more than the LBT strike price\"\r\n        );\r\n        require(triangleRightmost <= uint64(-2), \"the strike price is too large\");\r\n\r\n        uint256[] memory semiSbtPolyline;\r\n        {\r\n            Point[] memory points = new Point[](3);\r\n            points[0] = Point(sbtStrikePrice, 0);\r\n            points[1] = Point(triangleRightmost, semiSbtStrikePrice);\r\n            points[2] = Point(triangleRightmost + 1, semiSbtStrikePrice);\r\n            semiSbtPolyline = _calcPolyline(points);\r\n        }\r\n\r\n        uint256[] memory trianglePolyline;\r\n        {\r\n            Point[] memory points = new Point[](4);\r\n            points[0] = Point(sbtStrikePrice, 0);\r\n            points[1] = Point(lbtStrikePrice, trianglePeak);\r\n            points[2] = Point(triangleRightmost, 0);\r\n            points[3] = Point(triangleRightmost + 1, 0);\r\n            trianglePolyline = _calcPolyline(points);\r\n        }\r\n\r\n        fnMaps = new bytes[](4);\r\n        fnMaps[0] = _getSbtFnMap(sbtStrikePrice);\r\n        fnMaps[1] = _getLbtFnMap(lbtStrikePrice);\r\n        fnMaps[2] = abi.encode(semiSbtPolyline);\r\n        fnMaps[3] = abi.encode(trianglePolyline);\r\n    }\r\n\r\n    function _getSbtFnMap(uint64 strikePrice) internal pure returns (bytes memory fnMap) {\r\n        Point[] memory points = new Point[](2);\r\n        points[0] = Point(strikePrice, strikePrice);\r\n        points[1] = Point(strikePrice + 1, strikePrice);\r\n        uint256[] memory polyline = _calcPolyline(points);\r\n\r\n        fnMap = abi.encode(polyline);\r\n    }\r\n\r\n    function _getLbtFnMap(uint64 strikePrice) internal pure returns (bytes memory fnMap) {\r\n        Point[] memory points = new Point[](2);\r\n        points[0] = Point(strikePrice, 0);\r\n        points[1] = Point(strikePrice + 1, 1);\r\n        uint256[] memory polyline = _calcPolyline(points);\r\n\r\n        fnMap = abi.encode(polyline);\r\n    }\r\n\r\n    /**\r\n     * @dev [(x_1, y_1), (x_2, y_2), ..., (x_(n-1), y_(n-1)), (x_n, y_n)]\r\n     *   -> [(0, 0, x_1, y_1), (x_1, y_1, x_2, y_2), ..., (x_(n-1), y_(n-1), x_n, y_n)]\r\n     */\r\n    function _calcPolyline(Point[] memory points)\r\n        internal\r\n        pure\r\n        returns (uint256[] memory polyline)\r\n    {\r\n        Point memory leftPoint = Point(0, 0);\r\n        polyline = new uint256[](points.length);\r\n        for (uint256 i = 0; i < points.length; i++) {\r\n            Point memory rightPoint = points[i];\r\n            polyline[i] = zipLineSegment(LineSegment(leftPoint, rightPoint));\r\n            leftPoint = rightPoint;\r\n        }\r\n    }\r\n}"
    }
  }
}