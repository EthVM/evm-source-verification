{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n  \n\n\t/**\n\t* @dev Returns true if `account` is a contract.\n\t*\n\t* [IMPORTANT]\n\t* ====\n\t* It is unsafe to assume that an address for which this function returns\n\t* false is an externally-owned account (EOA) and not a contract.\n\t*\n\t* Among others, `isContract` will return false for the following\n\t* types of addresses:\n\t*\n\t*  - an externally-owned account\n\t*  - a contract in construction\n\t*  - an address where a contract will be created\n\t*  - an address where a contract lived, but was destroyed\n\t* ====\n\t*/\n\tfunction isContract(address account) internal view returns (bool) {\n\t// This method relies on extcodesize, which returns 0 for contracts in\n\t// construction, since the code is only stored at the end of the\n\t// constructor execution.\n\n\tuint256 size;\n\t// solhint-disable-next-line no-inline-assembly\n\tassembly { size := extcodesize(account) }\n\treturn size > 0;\n\t}\n\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\n\t}\n\n\t/**\n\t\t* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n\t\t* `errorMessage` as a fallback revert reason when `target` reverts.\n\t\t*\n\t\t* _Available since v3.1._\n\t\t*/\n\tfunction functionCall(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tstring memory errorMessage\n\t) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\n\t}\n\n\t/**\n\t\t* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t\t* but also transferring `value` wei to `target`.\n\t\t*\n\t\t* Requirements:\n\t\t*\n\t\t* - the calling contract must have an ETH balance of at least `value`.\n\t\t* - the called Solidity function must be `payable`.\n\t\t*\n\t\t* _Available since v3.1._\n\t\t*/\n\tfunction functionCallWithValue(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tuint256 value\n\t) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\t}\n\n\n\t/**\n\t\t* @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n\t\t* with `errorMessage` as a fallback revert reason when `target` reverts.\n\t\t*\n\t\t* _Available since v3.1._\n\t\t*/\n\tfunction functionCallWithValue(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tuint256 value,\n\t\tstring memory errorMessage\n\t) internal returns (bytes memory) {\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\n\t\trequire(isContract(target), \"Address: call to non-contract\");\n\n\t\t(bool success, bytes memory returndata) = target.call{value: value}(data);\n\t\treturn verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\n\t/**\n\t\t* @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n\t\t* revert reason using the provided one.\n\t\t*\n\t\t* _Available since v4.3._\n\t\t*/\n\tfunction verifyCallResult(\n\t\tbool success,\n\t\tbytes memory returndata,\n\t\tstring memory errorMessage\n\t) internal pure returns (bytes memory) {\n\t\tif (success) {\n\t\t\treturn returndata;\n\t\t} else {\n\t\t\t// Look for revert reason and bubble it up if present\n\t\t\tif (returndata.length > 0) {\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\n\n\t\t\t\tassembly {\n\t\t\t\t\tlet returndata_size := mload(returndata)\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trevert(errorMessage);\n\t\t\t}\n\t\t}\n\t}\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nabstract contract IERC20 {\n  function transfer(address to, uint tokens) public virtual returns (bool success);\n  function balanceOf(address _sender) public virtual view returns (uint _bal);\n  function allowance(address tokenOwner, address spender) public virtual view returns (uint remaining);\n  event Transfer(address indexed from, address indexed to, uint tokens);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);\n}"},"Marktplace.sol":{"content":"\n// SPDX-License-Identifier: MIT\n\n// This version supports ETH and ERC20\npragma solidity 0.8.0;\nimport \"./SafeErc20.sol\";\n\ninterface IERC721 {\n  function transferFrom(address _from, address _to, uint256 _tokenId) external;\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _value, bytes calldata _data) external;\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ninterface IERC1155 {\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n}\n\ninterface ISecondaryMarketFees {\n  struct Fee {\n    address recipient;\n    uint256 value;\n  }\n  function getFeeRecipients(uint256 tokenId) external view returns(address[] memory);\n  function getFeeBps(uint256 tokenId) external view returns(uint256[] memory);\n}\n\ncontract Marketplace {\n\n  using SafeERC20 for IERC20;\n  bytes4 private constant INTERFACE_ID_FEES = 0xb7799584;\n  address public beneficiary;\n  address public orderSigner;\n  address public owner;\n\n  enum AssetType { ETH, ERC20, ERC721, ERC1155, ERC721Deprecated, OffchainPayment }\n  enum OrderStatus { LISTED, COMPLETED, CANCELLED }\n\n  struct Asset {\n    address contractAddress;\n    uint256 tokenId;\n    AssetType assetType;\n    uint256 value;\n  }\n\n  struct Order {\n    address seller;\n    Asset sellAsset;\n    Asset buyAsset;\n    uint256 salt;\n  }\n\n  struct Signature {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n  }\n\n  mapping(bytes32 => Order) orders;\n  mapping(bytes32 => OrderStatus) public orderStatus;\n\n  event Buy(\n    address indexed sellContract, uint256 indexed sellTokenId, uint256 sellValue,\n    address owner,\n    address buyContract, uint256 buyTokenId, uint256 buyValue,\n    address buyer,\n    uint256 salt\n  );\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Only owner is allowed\");\n    _;\n  }\n\n  constructor(address _beneficiary, address _orderSigner) {\n    beneficiary = _beneficiary;\n    orderSigner = _orderSigner;\n    owner = msg.sender;\n  }\n\n  function updateOrderSigner(address newOrderSigner) public onlyOwner {\n    orderSigner =  newOrderSigner;\n  }\n\n  function updateBeneficiary(address newBeneficiary) public onlyOwner {\n    beneficiary = newBeneficiary;\n  }\n\n  /**\n    @notice This function is used to execute exchange off-chain.\n    @dev The payment functionality is secured off-chain. Only exhange is happening here.\n   */\n  function offlineExchange(Order calldata order,  Signature calldata ownerSig, address buyer) public {\n    // only NFTs can be sold\n    require(order.sellAsset.assetType == AssetType.ERC721 || order.sellAsset.assetType == AssetType.ERC1155  , \"Only ERC721 are supported on seller side\");\n    // buy asset should not have any data \n    require(order.buyAsset.assetType == AssetType.OffchainPayment, \"Unsupported asset type\");\n    require(order.buyAsset.tokenId == 0, \"Buy token id must be 0\");\n\n    // if buyer is zero address, the asset is transferred to the caller\n    if(buyer == address(0)) buyer = msg.sender;\n\n    bytes32 message = getMessageForOfflineExchange(order, buyer);\n    require(getSigner(message, ownerSig) == owner, \"Owner must sign order data\");\n\n    transfer(order.sellAsset, order.seller, buyer, order.sellAsset.value);\n    emitBuy(order, buyer);\n  }\n\n  function exchange(\n    Order calldata order,\n    Signature calldata sellerSignature,\n    Signature calldata buyerSignature,\n    address buyer,\n    uint256 sellerFee,\n    uint256 buyerFee\n  ) public payable {\n    if(buyer == address(0)) buyer = msg.sender;\n\n    validateSellerSignature(order, sellerFee, sellerSignature);\n    validateBuyerSignature(order, buyer, buyerFee, buyerSignature);\n    \n    require(order.sellAsset.assetType == AssetType.ERC721 || order.sellAsset.assetType == AssetType.ERC1155  , \"Only ERC721 are supported on seller side\");\n    require(order.buyAsset.assetType == AssetType.ETH || order.buyAsset.assetType == AssetType.ERC20, \"Only Eth/ERC20 supported on buy side\");\n    require(order.buyAsset.tokenId == 0, \"Buy token id must be UINT256_MAX\");\n    if(order.buyAsset.assetType == AssetType.ETH) {\n      validateEthTransfer(order.buyAsset.value, buyerFee);\n    }\n\n    uint256 remainingAmount = transferFeeToBeneficiary(\n      order.buyAsset, \n      buyer,\n      order.buyAsset.value,\n      sellerFee,\n      buyerFee\n    );\n\n    transfer(order.sellAsset, order.seller, buyer, order.sellAsset.value);\n    transferWithFee(order.buyAsset, buyer, order.seller, remainingAmount, order.sellAsset);\n    emitBuy(order, buyer);\n  }\n\n  \n  function transferFeeToBeneficiary(\n    Asset memory asset, address from, uint256 amount, uint256 sellerFee, uint256 buyerFee\n  ) internal returns(uint256) {\n    uint256 sellerCommission = getPercentageCalc(amount, sellerFee);\n    uint256 buyerCommission = getPercentageCalc(amount, buyerFee);\n    require(sellerCommission <= amount, \"Seller commission exceeds amount\");\n    uint256 totalCommission = sellerCommission + buyerCommission;\n    if(totalCommission > 0) {\n      transfer(asset, from, beneficiary, totalCommission);\n    }\n    return amount - sellerCommission;\n  }\n\n  function transferWithFee(\n    Asset memory _primaryAsset,\n    address from,\n    address to,\n    uint256 amount,\n    Asset memory _secondaryAsset\n  ) internal {\n    uint256 remainingAmount = amount;\n    if(supportsSecondaryFees(_secondaryAsset)) {\n      ISecondaryMarketFees _secondaryMktContract = ISecondaryMarketFees(_secondaryAsset.contractAddress);\n      address[] memory recipients = _secondaryMktContract.getFeeRecipients(_secondaryAsset.tokenId);\n      uint[] memory fees = _secondaryMktContract.getFeeBps(_secondaryAsset.tokenId);\n      require(fees.length == recipients.length, \"Invalid fees arguments\");\n      for(uint256 i=0; i<fees.length; i++) {\n        uint256 _fee = getPercentageCalc(_primaryAsset.value, fees[i]);\n        remainingAmount = remainingAmount - _fee;\n        transfer(_primaryAsset, from, recipients[i], _fee);\n      }\n    }\n    transfer(_primaryAsset, from, to, remainingAmount);\n  }\n\n  function transfer(Asset memory _asset, address from, address to, uint256 value) internal {\n    if(_asset.assetType == AssetType.ETH) {\n      payable(to).transfer(value);\n    } else if(_asset.assetType == AssetType.ERC20) {\n      IERC20(_asset.contractAddress).safeTransferFrom(from, to, value);\n    } else if(_asset.assetType == AssetType.ERC721) {\n      require(value == 1, \"value should be 1 for ERC-721\");\n      IERC721(_asset.contractAddress).safeTransferFrom(from, to, _asset.tokenId);\n    } else if(_asset.assetType == AssetType.ERC1155) {\n      IERC1155(_asset.contractAddress).safeTransferFrom(from, to, _asset.tokenId, value, \"0x\");\n    } else {\n      require(value == 1, \"value should be 1 for ERC-721\");\n      IERC721(_asset.contractAddress).transferFrom(from, to, _asset.tokenId);\n    }\n  }\n\n  function validateEthTransfer(uint amount, uint buyerFee) internal view {\n    uint256 buyerCommission =  getPercentageCalc(amount, buyerFee);\n    require(msg.value == amount + buyerCommission, \"msg.value is incorrect\");\n  }\n\n  function validateSellerSignature(Order calldata _order, uint256 sellerFee, Signature calldata _sig) public pure {\n    bytes32 signature = getMessageForSeller(_order, sellerFee);\n    require(getSigner(signature, _sig) == _order.seller, \"Seller must sign order data\");\n  }\n\n  function validateBuyerSignature(Order calldata order, address buyer, uint256 buyerFee,\n    Signature calldata sig) public view {\n    bytes32 message = getMessageForBuyer(order, buyer, buyerFee);\n    require(getSigner(message, sig) == orderSigner, \"Order signer must sign\");\n  }\n\n  function getMessageForSeller(Order calldata order, uint256 sellerFee) public pure returns(bytes32) {\n    return keccak256(abi.encode(order, sellerFee));\n  }\n\n  function getMessageForBuyer(Order calldata order, address buyer, uint256 buyerFee) public pure returns(bytes32) {\n    return keccak256(abi.encode(order, buyer, buyerFee));\n  }\n\n  function getSigner(bytes32 message, Signature memory _sig) public pure returns (address){\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n    return ecrecover(keccak256(abi.encodePacked(prefix, message)),_sig.v, _sig.r, _sig.s);\n  }\n\n  function getMessageForOfflineExchange(Order calldata order, address buyer) public pure returns (bytes32) {\n    return keccak256(abi.encode(order, buyer));\n  }\n\n  function emitBuy(Order calldata order, address buyer) internal {\n    emit Buy(\n      order.sellAsset.contractAddress,\n      order.sellAsset.tokenId,\n      order.sellAsset.value,\n      order.seller,\n      order.buyAsset.contractAddress,\n      order.buyAsset.tokenId,\n      order.buyAsset.value,\n      buyer,\n      order.salt\n    );\n  }\n\n  function getPercentageCalc(uint256 totalValue, uint _percentage) internal pure returns(uint256) {\n    return (totalValue * _percentage) / 1000 / 100;\n  }\n  \n  function supportsSecondaryFees(Asset memory asset) internal view returns(bool) {\n    return (\n      (asset.assetType == AssetType.ERC1155 &&\n      IERC1155(asset.contractAddress).supportsInterface(INTERFACE_ID_FEES)) ||\n      ( isERC721(asset.assetType) &&\n      IERC721(asset.contractAddress).supportsInterface(INTERFACE_ID_FEES))\n    );\n  }\n  \n  function isERC721(AssetType assetType) internal pure returns(bool){\n    return assetType == AssetType.ERC721 || assetType == AssetType.ERC721Deprecated;\n  }\n\n}"},"SafeErc20.sol":{"content":"\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    \n\tusing Address for address;\n\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n  \n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n        // functionCall(target, data, \"Address: low-level call failed\")\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n"}}}