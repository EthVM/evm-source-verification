{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BridgeManager.sol":{"content":"// SPDX-License-Identifier: SimPL-2.0\r\npragma solidity ^0.8.6;\r\n\r\ninterface Bridge {\r\n    function withdraw(uint toChainId, address toToken, address recipient, uint256 value, bytes memory hash) external;\r\n\r\n    function withdrawNative(uint toChainId, address payable recipient, bool isMain, uint256 value, bytes memory hash) external;\r\n}\r\n\r\ncontract BridgeManager {\r\n\r\n    address public owner;\r\n\r\n    address public bridgeAddress;\r\n\r\n    // 确认事件，前端可用于捕获自己的跨链进度\r\n    event Confirmation(uint fromChainId, bytes txHash, address toToken, address recipient, uint256 amount, bytes32 transactionId, address sender);\r\n\r\n    address[] public Managers;\r\n    mapping(address => bool) public isManager;\r\n    mapping(bytes32 => mapping(address => bool)) public confirmations;\r\n    mapping(bytes32 => Transaction) public transactions;\r\n\r\n\r\n    // 需要多签数量\r\n    uint public signLimit;\r\n\r\n    //跨链交易\r\n    struct Transaction {\r\n        uint fromChainId;//目标链\r\n        bytes txHash;//跨链hash\r\n        address toToken; //代币\r\n        address recipient;//接收\r\n        uint amount;//数量\r\n        bool isNative;// 是否主网币\r\n        bool isMain;// 是否主链\r\n        bool executed;//是否执行\r\n    }\r\n\r\n    // multiSigns[networkID][txHash] = managers[]\r\n    mapping(uint => mapping(bytes => address[])) public multiSigns;\r\n\r\n    constructor(uint _signLimit, address _bridgeAddress, address _owner) {\r\n        owner = _owner;\r\n        signLimit = _signLimit;\r\n        bridgeAddress = _bridgeAddress;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Bridge Manager: only use owner to call\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyManager {\r\n        require(isManager[msg.sender], \"Bridge Manager: only manager can call this function\");\r\n        _;\r\n    }\r\n\r\n    function setOwner(address payable _owner) public onlyOwner {\r\n        owner = _owner;\r\n    }\r\n\r\n    function setBridgeAddress(address _bridgeAddress) public onlyOwner {\r\n        bridgeAddress = _bridgeAddress;\r\n    }\r\n\r\n    // 设置多签数量\r\n    function setSignLimit(uint num) public onlyOwner {\r\n        signLimit = num;\r\n    }\r\n\r\n    // 添加管理员\r\n    function managerAdd(address _address) public onlyOwner {\r\n        bool push = true;\r\n        uint256 i = 0;\r\n        while (push && i < Managers.length) {\r\n            if (Managers[i] == _address) push = false;\r\n            i++;\r\n        }\r\n        if (push) Managers.push(_address);\r\n        isManager[_address] = true;\r\n    }\r\n\r\n    // 删除管理员\r\n    function managerDel(address _address) public onlyOwner {\r\n        address[] memory newManagers;\r\n        uint256 j = 0;\r\n        for (uint256 i = 0; i < Managers.length; i++) {\r\n            if (Managers[i] != _address) {\r\n                newManagers[j] = Managers[i];\r\n                j++;\r\n            }\r\n        }\r\n        Managers = newManagers;\r\n        isManager[_address] = false;\r\n    }\r\n\r\n\r\n    function allManagersLength() public view returns (uint){\r\n        return Managers.length;\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(bytes32 transactionId)\r\n    public view\r\n    returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i = 0; i < Managers.length; i++) {\r\n            if (confirmations[transactionId][Managers[i]])\r\n                count += 1;\r\n            if (count == signLimit)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //查询id\r\n    function getTransactionId(uint fromChainId, bytes memory txHash, address toToken, address recipient, uint256 amount) pure public returns (bytes32){\r\n        // 根据来源跨链交易生成唯一hash id，作为这笔跨链的id\r\n        bytes32 transactionId = keccak256(abi.encodePacked(fromChainId, txHash, toToken, recipient, amount));\r\n\r\n        return transactionId;\r\n    }\r\n\r\n\r\n    // 查询一笔交易是否跨链成功\r\n    function isExecuted(uint fromChainId, bytes memory txHash, address toToken, address recipient, uint256 amount) view public returns (bool){\r\n        // 根据来源跨链交易生成唯一hash id，作为这笔跨链的id\r\n        bytes32 transactionId = keccak256(abi.encodePacked(fromChainId, txHash, toToken, recipient, amount));\r\n\r\n        if (transactions[transactionId].executed)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    /// @dev 提交一个跨链请求\r\n    /// @param fromChainId 来源链id\r\n    /// @param txHash      来源链交易hash\r\n    /// @param toToken     目标token\r\n    /// @param recipient   接收地址\r\n    /// @param amount      数量\r\n    function submitTransaction(uint fromChainId, bytes memory txHash, address toToken, address recipient, uint256 amount, bool isNative, bool isMain) public onlyManager returns (bool) {\r\n        // 根据来源跨链交易生成唯一hash id，作为这笔跨链的id\r\n        bytes32 transactionId = keccak256(abi.encodePacked(fromChainId, txHash, toToken, recipient, amount));\r\n        if (confirmations[transactionId][msg.sender])\r\n            return true;\r\n\r\n        //如果已经成功跨链，直接返回成功\r\n        if (transactions[transactionId].executed)\r\n            return true;\r\n\r\n        transactions[transactionId] = Transaction({\r\n        fromChainId : fromChainId,\r\n        txHash : txHash,\r\n        toToken : toToken,\r\n        recipient : recipient,\r\n        amount : amount,\r\n        isNative : isNative,\r\n        isMain : isMain,\r\n        executed : false\r\n        });\r\n\r\n        confirmations[transactionId][msg.sender] = true;\r\n\r\n        // 弹出事件，用于其它程序捕获，例如前端可以捕获自己跨链\r\n        emit Confirmation(fromChainId, txHash, toToken, recipient, amount, transactionId, msg.sender);\r\n\r\n        if (isConfirmed(transactionId))\r\n        {\r\n            executeTransaction(transactionId);\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    // 执行跨链操作，任意账号均可\r\n    function executeTransaction(bytes32 transactionId) public {\r\n        Transaction storage txn = transactions[transactionId];\r\n        bool _confirmed = isConfirmed(transactionId);\r\n        if (_confirmed && txn.executed == false) {\r\n            txn.executed = true;\r\n            if (txn.isNative) {\r\n                withdrawNative(txn.fromChainId, txn.isMain, payable(txn.recipient), txn.amount, txn.txHash);\r\n            } else {\r\n                withdraw(txn.fromChainId, txn.toToken, txn.recipient, txn.amount, txn.txHash);\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdraw(uint fromChainId, address toToken, address recipient, uint256 amount, bytes memory depositHash) private {\r\n        Bridge bridge = Bridge(bridgeAddress);\r\n        bridge.withdraw(fromChainId, toToken, recipient, amount, depositHash);\r\n\r\n    }\r\n\r\n    function withdrawNative(uint fromChainId, bool isMain, address payable recipient, uint256 amount, bytes memory depositHash) private {\r\n        Bridge bridge = Bridge(bridgeAddress);\r\n        bridge.withdrawNative(fromChainId, recipient, isMain, amount, depositHash);\r\n    }\r\n\r\n}"}}}