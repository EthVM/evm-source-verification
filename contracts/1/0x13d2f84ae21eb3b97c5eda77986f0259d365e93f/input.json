{
  "language": "Solidity",
  "sources": {
    "/home/gabriele/rigoblock-monorepo/packages/contracts/src/protocol/extensions/adapters/AUniswapV3.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0-or-later\n/*\n\n Copyright 2021 Rigo Intl.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\n*/\n\n// solhint-disable-next-line\npragma solidity 0.7.6;\npragma abicoder v2; // in 0.8 solc this is default behaviour\n\nimport \"../../../utils/exchanges/uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"../../../utils/exchanges/uniswap/v3-periphery/contracts/interfaces/IPeripheryPaymentsWithFee.sol\";\nimport \"../../../utils/exchanges/uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol\";\nimport \"../../../utils/exchanges/uniswap/v3-periphery/contracts/libraries/Path.sol\";\n\ninterface Token {\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256);\n    function balanceOf(address _who) external view returns (uint256);\n}\n\n/// @title Interface for WETH9\ninterface IWETH9 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n\ncontract AUniswapV3 {\n    \n    using Path for bytes;\n    \n    address payable immutable private UNISWAP_V3_SWAP_ROUTER_ADDRESS = payable(address(0xE592427A0AEce92De3Edee1F18E0157C05861564));\n    bytes4 immutable private APPROVE_SELECTOR = bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n    bytes4 immutable private EXACT_INPUT_SELECTOR = bytes4(keccak256(\"exactInput(ISwapRouter.ExactInputParams)\"));\n    bytes4 immutable private EXACT_INPUT_SINGLE_SELECTOR = bytes4(keccak256(\"exactInputSingle(ISwapRouter.ExactInputSingleParams)\"));\n    bytes4 immutable private EXACT_OUTPUT_SELECTOR = bytes4(keccak256(\"exactOutput(ISwapRouter.exactOutputParams)\"));\n    bytes4 immutable private EXACT_OUTPUT_SINGLE_SELECTOR = bytes4(keccak256(\"exactOutputSingle(ISwapRouter.ExactOutputSingleParams)\"));\n    bytes4 immutable private REFUND_ETH_SELECTOR = bytes4(keccak256(\"refundETH()\"));\n    bytes4 immutable private SWEEP_TOKEN_SELECTOR = bytes4(keccak256(\"sweepToken(address,uint256,address)\"));\n    bytes4 immutable private SWEEP_TOKEN_WITH_FEE_SELECTOR = bytes4(keccak256(\"sweepTokenWithFee(address,uint256,address,uint256,address)\"));\n    bytes4 immutable private UNWRAP_WETH9_SELECTOR = bytes4(keccak256(\"unwrapWETH9(uint256,address)\"));\n    bytes4 immutable private UNWRAP_WETH9_WITH_FEE_SELECTOR = bytes4(keccak256(\"unwrapWETH9WithFee(uint256,address,uint256,address)\"));\n    bytes4 immutable private WRAP_ETH_SELECTOR = bytes4(keccak256(\"wrapETH(uint256)\"));\n    \n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param data The encoded function data for each of the calls to make to this contract\n    function multicall(bytes[] calldata data) external payable {\n        for (uint256 i = 0; i < data.length; i++) {\n            bytes memory messagePack = data[i];\n            bytes4 selector;\n            assembly {\n                selector := mload(add(messagePack, 32))\n            }\n            \n            if (selector == EXACT_INPUT_SINGLE_SELECTOR) {\n                exactInputSingleInternal(abi.decode(data[i], (ISwapRouter.ExactInputSingleParams)));\n            } else if (selector == EXACT_INPUT_SELECTOR) {\n                exactInputInternal(abi.decode(data[i], (ISwapRouter.ExactInputParams)));\n            } else if (selector == EXACT_OUTPUT_SINGLE_SELECTOR) {\n                exactOutputSingleInternal(abi.decode(data[i], (ISwapRouter.ExactOutputSingleParams)));\n            } else if (selector == EXACT_OUTPUT_SELECTOR) {\n                exactOutputInternal(abi.decode(data[i], (ISwapRouter.ExactOutputParams)));\n            } else if (selector == WRAP_ETH_SELECTOR) {\n                wrapETHInternal(abi.decode(data[i], (uint256)));\n            } else if (selector == UNWRAP_WETH9_SELECTOR) {\n                (uint256 amountMinimum, address recipient) = abi.decode(data[i], (uint256, address));\n                unwrapWETH9Internal(amountMinimum, recipient);\n            } else if (selector == REFUND_ETH_SELECTOR) {\n                refundETHInternal();\n            } else if (selector == SWEEP_TOKEN_SELECTOR) {\n                (address token, uint256 amountMinimum, address recipient) = abi.decode(\n                    data[i],\n                    (address, uint256, address)\n                );\n                sweepTokenInternal(token, amountMinimum, recipient);\n            } else if (selector == UNWRAP_WETH9_WITH_FEE_SELECTOR) {\n                (uint256 amountMinimum, address recipient, uint256 feeBips, address feeRecipient) = abi.decode(\n                    data[i],\n                    (uint256, address, uint256, address)\n                );\n                unwrapWETH9WithFeeInternal(amountMinimum, recipient, feeBips, feeRecipient);\n            } else if (selector == SWEEP_TOKEN_WITH_FEE_SELECTOR) {\n                (\n                    address token,\n                    uint256 amountMinimum,\n                    address recipient,\n                    uint256 feeBips,\n                    address feeRecipient\n                ) = abi.decode(\n                    data[i],\n                    (address, uint256, address, uint256, address)\n                );\n                sweepTokenWithFeeInternal(token, amountMinimum, recipient, feeBips, feeRecipient);\n            } else revert(\"UNKNOWN_SELECTOR\");\n        }\n    }\n    \n    /// @notice Wraps ETH when value input is non-null\n    /// @param value The ETH amount to be wrapped\n    function wrapETH(uint256 value) external payable {\n        wrapETHInternal(value);\n    }\n    \n    function wrapETHInternal(uint256 value) internal {\n        if (value > uint256(0)) {\n            IWETH9(\n                IPeripheryImmutableState(UNISWAP_V3_SWAP_ROUTER_ADDRESS).WETH9()\n            ).deposit{value: value}();\n        }\n    }\n    \n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in memory\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ISwapRouter.ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut)\n    {\n        amountOut = exactInputSingleInternal(params);\n    }\n    \n    function exactInputSingleInternal(ISwapRouter.ExactInputSingleParams memory params)\n        internal\n        returns (uint256 amountOut)\n    {\n        // we first set the allowance to the uniswap router\n        if (Token(params.tokenIn).allowance(address(this), UNISWAP_V3_SWAP_ROUTER_ADDRESS) < params.amountIn) {\n            safeApproveInternal(params.tokenIn, UNISWAP_V3_SWAP_ROUTER_ADDRESS, type(uint).max);\n        }\n        \n        // finally, we swap the tokens\n        amountOut = ISwapRouter(UNISWAP_V3_SWAP_ROUTER_ADDRESS).exactInputSingle(\n            ISwapRouter.ExactInputSingleParams({\n                tokenIn: params.tokenIn,\n                tokenOut: params.tokenOut,\n                fee: params.fee,\n                recipient: address(this), // this drago is always the recipient\n                deadline: params.deadline,\n                amountIn: params.amountIn,\n                amountOutMinimum: params.amountOutMinimum,\n                sqrtPriceLimitX96: params.sqrtPriceLimitX96\n            })\n        );\n    }\n    \n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in memory\n    /// @return amountOut The amount of the received token\n    function exactInput(ISwapRouter.ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut)\n    {\n        amountOut = exactInputInternal(params);\n    }\n    \n    function exactInputInternal(ISwapRouter.ExactInputParams memory params)\n        internal\n        returns (uint256 amountOut)\n    {\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        \n        // we first set the allowance to the uniswap router\n        if (Token(tokenIn).allowance(address(this), UNISWAP_V3_SWAP_ROUTER_ADDRESS) < params.amountIn) {\n            safeApproveInternal(tokenIn, UNISWAP_V3_SWAP_ROUTER_ADDRESS, type(uint).max);\n        }\n        \n        // finally, we swap the tokens\n        amountOut = ISwapRouter(UNISWAP_V3_SWAP_ROUTER_ADDRESS).exactInput(\n            ISwapRouter.ExactInputParams({\n                path: params.path,\n                recipient: address(this), // this drago is always the recipient\n                deadline: params.deadline,\n                amountIn: params.amountIn,\n                amountOutMinimum: params.amountOutMinimum\n            })    \n        );\n    }\n    \n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in memory\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ISwapRouter.ExactOutputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn)\n    {\n        amountIn = exactOutputSingleInternal(params);\n    }\n    \n    function exactOutputSingleInternal(ISwapRouter.ExactOutputSingleParams memory params)\n        internal\n        returns (uint256 amountIn)\n    {\n        // we first set the allowance to the uniswap router\n        if (Token(params.tokenIn).allowance(address(this), UNISWAP_V3_SWAP_ROUTER_ADDRESS) < params.amountInMaximum) {\n            safeApproveInternal(params.tokenIn, UNISWAP_V3_SWAP_ROUTER_ADDRESS, type(uint).max);\n        }\n        \n        // finally, we swap the tokens\n        amountIn = ISwapRouter(UNISWAP_V3_SWAP_ROUTER_ADDRESS).exactOutputSingle(\n            ISwapRouter.ExactOutputSingleParams({\n                tokenIn: params.tokenIn,\n                tokenOut: params.tokenOut,\n                fee: params.fee,\n                recipient: address(this), // this drago is always the recipient\n                deadline: params.deadline,\n                amountOut: params.amountOut,\n                amountInMaximum: params.amountInMaximum,\n                sqrtPriceLimitX96: params.sqrtPriceLimitX96\n            })    \n        );\n    }\n    \n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in memory\n    /// @return amountIn The amount of the input token\n    function exactOutput(ISwapRouter.ExactOutputParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn)\n    {\n        amountIn = exactOutputInternal(params);\n    }\n    \n    function exactOutputInternal(ISwapRouter.ExactOutputParams memory params)\n        internal\n        returns (uint256 amountIn)\n    {\n        (address tokenIn, , ) = params.path.decodeFirstPool();\n        \n        // we first set the allowance to the uniswap router\n        if (Token(tokenIn).allowance(address(this), UNISWAP_V3_SWAP_ROUTER_ADDRESS) < params.amountInMaximum) {\n            safeApproveInternal(tokenIn, UNISWAP_V3_SWAP_ROUTER_ADDRESS, type(uint).max);\n        }\n        \n        // finally, we swap the tokens\n        amountIn = ISwapRouter(UNISWAP_V3_SWAP_ROUTER_ADDRESS).exactOutput(\n            ISwapRouter.ExactOutputParams({\n                path: params.path,\n                recipient: address(this), // this drago is always the recipient\n                deadline: params.deadline,\n                amountOut: params.amountOut,\n                amountInMaximum: params.amountInMaximum\n            })\n        );\n    }\n    \n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n    /// @param recipient The address receiving ETH\n    function unwrapWETH9(uint256 amountMinimum, address recipient)\n        external\n        payable\n    {\n        unwrapWETH9Internal(amountMinimum, recipient);\n    }\n    \n    function unwrapWETH9Internal(uint256 amountMinimum, address recipient)\n        internal\n    {\n        IPeripheryPaymentsWithFee(UNISWAP_V3_SWAP_ROUTER_ADDRESS).unwrapWETH9(\n            amountMinimum,\n            recipient != address(this) ? address(this) : address(this) // this drago is always the recipient\n        );\n    }\n    \n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n    /// that use ether for the input amount\n    function refundETH()\n        external\n        payable\n    {\n        refundETHInternal();\n    }\n    \n    function refundETHInternal()\n        internal\n    {\n        IPeripheryPaymentsWithFee(UNISWAP_V3_SWAP_ROUTER_ADDRESS).refundETH();\n    }\n    \n    /// @notice Transfers the full amount of a token held by this contract to recipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    /// @param token The contract address of the token which will be transferred to `recipient`\n    /// @param amountMinimum The minimum amount of token required for a transfer\n    /// @param recipient The destination address of the token\n    function sweepToken(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    )\n        external\n        payable\n    {\n        sweepTokenInternal(token, amountMinimum, recipient);\n    }\n    \n    function sweepTokenInternal(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    )\n        internal\n    {\n        IPeripheryPaymentsWithFee(UNISWAP_V3_SWAP_ROUTER_ADDRESS).sweepToken(\n            token,\n            amountMinimum,\n            recipient != address(this) ? address(this) : address(this) // this drago is always the recipient\n        );\n    }\n    \n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between\n    /// 0 (exclusive), and 1 (inclusive) going to feeRecipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    function unwrapWETH9WithFee(\n        uint256 amountMinimum,\n        address recipient,\n        uint256 feeBips,\n        address feeRecipient\n    )\n        external\n        payable\n    {\n        unwrapWETH9WithFeeInternal(amountMinimum, recipient, feeBips, feeRecipient);\n    }\n    \n    function unwrapWETH9WithFeeInternal(\n        uint256 amountMinimum,\n        address recipient,\n        uint256 feeBips,\n        address feeRecipient\n    )\n        internal\n    {\n        IPeripheryPaymentsWithFee(UNISWAP_V3_SWAP_ROUTER_ADDRESS).unwrapWETH9WithFee(\n            amountMinimum,\n            recipient != address(this) ? address(this) : address(this),  // this drago is always the recipient\n            feeBips,\n            feeRecipient\n        );\n    }\n    \n    /// @notice Transfers the full amount of a token held by this contract to recipient, with a percentage between\n    /// 0 (exclusive) and 1 (inclusive) going to feeRecipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    function sweepTokenWithFee(\n        address token,\n        uint256 amountMinimum,\n        address recipient,\n        uint256 feeBips,\n        address feeRecipient\n    )\n        external\n        payable\n    {\n        sweepTokenWithFeeInternal(token, amountMinimum, recipient, feeBips, feeRecipient);\n    }\n\n    function sweepTokenWithFeeInternal(\n        address token,\n        uint256 amountMinimum,\n        address recipient,\n        uint256 feeBips,\n        address feeRecipient\n    )\n        internal\n    {\n        IPeripheryPaymentsWithFee(UNISWAP_V3_SWAP_ROUTER_ADDRESS).sweepTokenWithFee(\n            token,\n            amountMinimum,\n            recipient != address(this) ? address(this) : address(this),  // this drago is always the recipient\n            feeBips,\n            feeRecipient\n        );\n    }\n    \n    function safeApproveInternal(\n        address token,\n        address spender,\n        uint256 value\n    )\n        internal\n    {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(APPROVE_SELECTOR, spender, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"RIGOBLOCK_APPROVE_FAILED\"\n        );\n    }\n}\n"
    },
    "/home/gabriele/rigoblock-monorepo/packages/contracts/src/utils/exchanges/uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "/home/gabriele/rigoblock-monorepo/packages/contracts/src/utils/exchanges/uniswap/v3-periphery/contracts/interfaces/IPeripheryPaymentsWithFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPayments {\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n    /// @param recipient The address receiving ETH\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n    /// that use ether for the input amount\n    function refundETH() external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    /// @param token The contract address of the token which will be transferred to `recipient`\n    /// @param amountMinimum The minimum amount of token required for a transfer\n    /// @param recipient The destination address of the token\n    function sweepToken(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    ) external payable;\n}\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPaymentsWithFee is IPeripheryPayments {\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between\n    /// 0 (exclusive), and 1 (inclusive) going to feeRecipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    function unwrapWETH9WithFee(\n        uint256 amountMinimum,\n        address recipient,\n        uint256 feeBips,\n        address feeRecipient\n    ) external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient, with a percentage between\n    /// 0 (exclusive) and 1 (inclusive) going to feeRecipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    function sweepTokenWithFee(\n        address token,\n        uint256 amountMinimum,\n        address recipient,\n        uint256 feeBips,\n        address feeRecipient\n    ) external payable;\n}\n"
    },
    "/home/gabriele/rigoblock-monorepo/packages/contracts/src/utils/exchanges/uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Immutable state\n/// @notice Functions that return immutable state of the router\ninterface IPeripheryImmutableState {\n    /// @return Returns the address of the Uniswap V3 factory\n    function factory() external view returns (address);\n\n    /// @return Returns the address of WETH9\n    function WETH9() external view returns (address);\n}\n"
    },
    "/home/gabriele/rigoblock-monorepo/packages/contracts/src/utils/exchanges/uniswap/v3-periphery/contracts/libraries/Path.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nlibrary BytesLib {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_start + _length >= _start, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, 'toAddress_overflow');\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, 'toUint24_overflow');\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary Path {\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Returns the number of pools in the path\n    /// @param path The encoded swap path\n    /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + fee elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}