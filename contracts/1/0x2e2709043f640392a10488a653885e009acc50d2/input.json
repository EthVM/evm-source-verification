{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"NoFiPartyStarter.sol":{"content":"// File: browser/CloneFactory.sol\r\n\r\n/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2018 Murray Software, LLC.\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\ncontract CloneFactory { // Mystic implementation of eip-1167 - see https://eips.ethereum.org/EIPS/eip-1167\r\n    function createClone(address target) internal returns (address result) {\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            result := create(0, clone, 0x37)\r\n        }\r\n    }\r\n}\r\n// File: browser/WETHParty.sol\r\n\r\n\r\n// File: contracts/oz/SafeMath.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n    \r\n}\r\n\r\nlibrary Address { // helper for address type - see openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\n// File: contracts/oz/IERC20.sol\r\n\r\ninterface IERC20 { // brief interface for moloch erc20 token txs\r\n    function balanceOf(address who) external view returns (uint256);\r\n    \r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\nlibrary SafeERC20 { // wrapper around erc20 token tx for non-standard contract - see openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n    using Address for address;\r\n    \r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n    \r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n    \r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n        (bool success, bytes memory returnData) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returnData.length > 0) { // return data is optional\r\n            require(abi.decode(returnData, (bool)), \"SafeERC20: erc20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/oz/NewReentrancy.sol\r\n\r\ncontract ReentrancyGuard { // call wrapper for reentrancy check\r\n    bool private _notEntered;\r\n\r\n    function _initReentrancyGuard () internal {\r\n        _notEntered = true;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// File: contracts/CloneParty.sol\r\n\r\n\r\n    /*=====================\r\n    WELCOME TO THE POOL Party vWETH\r\n    \r\n    **USE AT YOUR OWN RISK**\r\n    Forked from an early version of the permissioned Mystic v2x by LexDAO \r\n    Special thanks to LexDAO for pushing the boundaries of Moloch mysticism \r\n    \r\n    Developed by Peeps Democracy\r\n    MIT License - But please use for good (ie. don't be a dick). \r\n    Definitely NO WARRANTIES.\r\n    =======================*/\r\n\r\n\r\ncontract NoFiParty is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    \r\n    /****************\r\n    GOVERNANCE PARAMS\r\n    ****************/\r\n    uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\r\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\r\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\r\n    uint256 public proposalDepositReward; // default = 10 ETH (~$1,000 worth of ETH at contract deployment)\r\n    uint256 public depositRate; // rate to convert into shares during summoning time (default = 10000000000000000000 wei amt. // 100 wETH => 10 shares)\r\n    uint256 public summoningTime; // needed to determine the current period\r\n    uint256 public partyGoal; // savings goal for DAO \r\n    uint256 public dilutionBound;\r\n\r\n    address public daoFee; // address where fees are sent\r\n    address public depositToken; // deposit token contract reference; default = periodDuration\r\n    address public idleToken; // = depositToken address \r\n    \r\n    bool public initialized;\r\n\r\n\r\n    // HARD-CODED LIMITS\r\n    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations\r\n    // with periods or shares, yet big enough to not limit reasonable use cases.\r\n     // default = 5\r\n    uint256 constant MAX_INPUT = 10**36; // maximum bound for reasonable limits\r\n    uint256 constant MAX_TOKEN_WHITELIST_COUNT = 50; // maximum number of whitelisted tokens\r\n\r\n    // ***************\r\n    // EVENTS\r\n    // ***************\r\n    event SummonComplete(address[] indexed summoners, address[] tokens, uint256 summoningTime, uint256 periodDuration, uint256 votingPeriodLength, uint256 gracePeriodLength, uint256 proposalDepositReward, uint256 partyGoal, uint256 depositRate);\r\n    event MakeDeposit(address indexed memberAddress, uint256 tribute, uint256 mintedTokens, uint256 indexed shares, uint8 goalHit);\r\n    event ProcessAmendGovernance(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass, address newToken, address newIdle, uint256 newPartyGoal, uint256 newDepositRate);    \r\n    event SubmitProposal(address indexed applicant, uint256 sharesRequested, uint256 lootRequested, uint256 tributeOffered, address tributeToken, uint256 paymentRequested, address paymentToken, bytes32 details, bool[8] flags, uint256 proposalId, address indexed delegateKey, address indexed memberAddress);\r\n    event SponsorProposal(address indexed sponsor, address indexed memberAddress, uint256 proposalId, uint256 proposalIndex, uint256 startingPeriod);\r\n    event SubmitVote(uint256 proposalId, uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\r\n    event ProcessProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event ProcessGuildKickProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\r\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn, uint256 lootToBurn);\r\n    event TokensCollected(address indexed token, uint256 amountToCollect);\r\n    event CancelProposal(uint256 indexed proposalId, address applicantAddress);\r\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\r\n    event WithdrawEarnings(address indexed memberAddress, address iToken, uint256 earningsToUser, address depositToken, uint256 redeemedTokens);\r\n    event Withdraw(address indexed memberAddress, address token, uint256 amount);\r\n\r\n    // *******************\r\n    // INTERNAL ACCOUNTING\r\n    // *******************\r\n\r\n    uint8 public goalHit; // tracks whether goal has been hit\r\n    uint256 public proposalCount; // total proposals submitted\r\n    uint256 public totalShares; // total shares across all members\r\n    uint256 public totalLoot; // total loot across all members\r\n    int256 public totalDeposits; //track deposits made for goal and peg for earnings \r\n\r\n\r\n    address public constant GUILD = address(0xdead);\r\n    address public constant ESCROW = address(0xbeef);\r\n    address public constant TOTAL = address(0xbabe);\r\n    mapping(address => mapping(address => uint256)) public userTokenBalances; // userTokenBalances[userAddress][tokenAddress]\r\n\r\n    enum Vote {\r\n        Null, // default value, counted as abstention\r\n        Yes,\r\n        No\r\n    }\r\n\r\n    struct Member {\r\n        uint256 shares; // the # of voting shares assigned to this member\r\n        uint256 loot; // the loot amount available to this member (combined with shares on ragequit)\r\n        uint256 iTB; // Deposit Token Balance\r\n        uint256 iTW; // Deposit Token withdrawals\r\n        uint256 iVal; // base value off which earnings are calculated\r\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\r\n        bool jailed; // set to proposalIndex of a passing guild kick proposal for this member, prevents voting on and sponsoring proposals\r\n        bool exists; // always true once a member has been created\r\n    }\r\n\r\n    struct Proposal {\r\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals (doubles as guild kick target for gkick proposals)\r\n        address proposer; // the account that submitted the proposal (can be non-member)\r\n        address sponsor; // the member that sponsored the proposal (moving it into the queue)\r\n        uint256 sharesRequested; // the # of shares the applicant is requesting\r\n        uint256 lootRequested; // the amount of loot the applicant is requesting\r\n        uint256 tributeOffered; // amount of tokens offered as tribute\r\n        address tributeToken; // tribute token contract reference\r\n        uint256 paymentRequested; // amount of tokens requested as payment\r\n        address paymentToken; // payment token contract reference\r\n        uint256 startingPeriod; // the period in which voting can start for this proposal\r\n        uint256 yesVotes; // the total number of YES votes for this proposal\r\n        uint256 noVotes; // the total number of NO votes for this proposal\r\n        bool[8] flags; // [sponsored, processed, didPass, cancelled, guildkick, spending, member, action]\r\n        bytes32 details; // proposal details to add context for members \r\n        uint256 maxTotalSharesAndLootAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\r\n        mapping(address => Vote) votesByMember; // the votes on this proposal by each member\r\n    }\r\n\r\n    mapping(address => bool) public tokenWhitelist;\r\n    address[] public approvedTokens;\r\n\r\n    mapping(address => bool) public proposedToKick;\r\n\r\n    mapping(address => Member) public members;\r\n    address[] public memberList;\r\n\r\n    mapping(uint256 => Proposal) public proposals;\r\n    uint256[] public proposalQueue;\r\n    mapping(uint256 => bytes) public actions; // proposalId => action data\r\n\r\n    \r\n    /******************\r\n    SUMMONING FUNCTIONS\r\n    ******************/\r\n    function init(\r\n        address[] calldata _founders,\r\n        address[] calldata _approvedTokens,\r\n        address _daoFee,\r\n        uint256 _periodDuration,\r\n        uint256 _votingPeriodLength,\r\n        uint256 _gracePeriodLength,\r\n        uint256 _proposalDepositReward,\r\n        uint256 _depositRate,\r\n        uint256 _partyGoal,\r\n        uint256 _dilutionBound\r\n    ) external {\r\n        require(!initialized, \"initialized\");\r\n        initialized = true;\r\n        require(_periodDuration > 0, \"_periodDuration zeroed\");\r\n        require(_votingPeriodLength > 0, \"_votingPeriodLength zeroed\");\r\n        require(_votingPeriodLength <= MAX_INPUT, \"_votingPeriodLength maxed\");\r\n        require(_gracePeriodLength <= MAX_INPUT, \"_gracePeriodLength maxed\");\r\n        require(_approvedTokens.length > 0, \"need token\");\r\n        \r\n        depositToken = _approvedTokens[0];\r\n        idleToken = _approvedTokens[0]; // Same address as Deposit Token\r\n        \r\n        // NOTE: move event up here, avoid stack too deep if too many approved tokens\r\n        emit SummonComplete(_founders, _approvedTokens, now, _periodDuration, _votingPeriodLength, _gracePeriodLength, _proposalDepositReward, _depositRate, _partyGoal);\r\n        \r\n        for (uint256 i = 0; i < _approvedTokens.length; i++) {\r\n            require(!tokenWhitelist[_approvedTokens[i]], \"token duplicated\");\r\n            tokenWhitelist[_approvedTokens[i]] = true;\r\n            approvedTokens.push(_approvedTokens[i]);\r\n        }\r\n        \r\n         for (uint256 i = 0; i < _founders.length; i++) {\r\n             _addFounder(_founders[i]);\r\n         }\r\n        \r\n        daoFee = _daoFee;\r\n        periodDuration = _periodDuration;\r\n        votingPeriodLength = _votingPeriodLength;\r\n        gracePeriodLength = _gracePeriodLength;\r\n        proposalDepositReward = _proposalDepositReward;\r\n        depositRate = _depositRate;\r\n        partyGoal = _partyGoal;\r\n        summoningTime = now;\r\n        goalHit = 0;\r\n        dilutionBound = _dilutionBound;\r\n        \r\n        _initReentrancyGuard();\r\n    }\r\n    \r\n    \r\n    function _addFounder(address founder) internal {\r\n            members[founder] = Member(0, 0, 0, 0, 0, 0, false, true);\r\n            memberList.push(founder);\r\n    }\r\n    \r\n    // Can also be used to upgrade the idle contract, but not switch to new DeFi token (ie. iDAI to iUSDC)\r\n     function _setIdle(address _idle) internal {\r\n         idleToken = _idle;\r\n     }\r\n    \r\n\r\n     /*****************\r\n    PROPOSAL FUNCTIONS\r\n    *****************/\r\n    function submitProposal(\r\n        address applicant,\r\n        uint256 tributeOffered,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 paymentRequested,\r\n        uint256 flagNumber,\r\n        address tributeToken,\r\n        address paymentToken,\r\n        bytes32 details\r\n    ) public nonReentrant returns (uint256 proposalId) {\r\n        require(sharesRequested.add(lootRequested) <= MAX_INPUT, \"shares maxed\");\r\n        if(flagNumber != 7){\r\n            require(tokenWhitelist[tributeToken] && tokenWhitelist[paymentToken], \"tokens not whitelisted\");\r\n            // collect tribute from proposer and store it in the Moloch until the proposal is processed\r\n            IERC20(tributeToken).transferFrom(msg.sender, address(this), tributeOffered);\r\n            unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);\r\n        }\r\n        require(applicant != address(0), \"applicant cannot be 0\");\r\n        require(members[applicant].jailed == false, \"applicant jailed\");\r\n        require(flagNumber != 0 || flagNumber != 1 || flagNumber != 2 || flagNumber != 3, \"flag must be 4 - guildkick, 5 - spending, 6 - membership, 7 - governance\");\r\n        \r\n        // collect deposit from proposer\r\n        require(IERC20(depositToken).transferFrom(msg.sender, address(this), proposalDepositReward), \"proposal deposit failed\");\r\n        unsafeAddToBalance(ESCROW, depositToken, proposalDepositReward);\r\n        \r\n        // check whether pool goal is met before allowing spending proposals\r\n        if(flagNumber == 5) {\r\n            require(goalHit == 1, \"goal not met yet\");\r\n        }\r\n        \r\n         if(flagNumber == 6) {\r\n            require(paymentRequested == 0 || goalHit == 1, \"goal not met yet\");\r\n        }\r\n        \r\n        bool[8] memory flags; // [sponsored, processed, didPass, cancelled, guildkick, spending, member, governance]\r\n        flags[flagNumber] = true;\r\n        \r\n        if(flagNumber == 4) {\r\n            _submitProposal(applicant, 0, 0, 0, address(0), 0, address(0), details, flags);\r\n        } \r\n        \r\n        else if (flagNumber == 7) { // for amend governance use sharesRequested for partyGoal, tributeRequested for depositRate, tributeToken for new Token, paymentToken for new WETHaddress\r\n            _submitProposal(applicant, 0, 0, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags);\r\n        } \r\n        \r\n        else {\r\n        \r\n        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags);\r\n\r\n        }\r\n        // NOTE: Should approve the 0x address as a blank token for guildKick proposals where there's no token. \r\n        return proposalCount - 1; // return proposalId - contracts calling submit might want it\r\n    }\r\n    \r\n\r\n   function _submitProposal(\r\n        address applicant,\r\n        uint256 sharesRequested,\r\n        uint256 lootRequested,\r\n        uint256 tributeOffered,\r\n        address tributeToken,\r\n        uint256 paymentRequested,\r\n        address paymentToken,\r\n        bytes32 details,\r\n        bool[8] memory flags\r\n    ) internal {\r\n        Proposal memory proposal = Proposal({\r\n            applicant : applicant,\r\n            proposer : msg.sender,\r\n            sponsor : address(0),\r\n            sharesRequested : sharesRequested,\r\n            lootRequested : lootRequested,\r\n            tributeOffered : tributeOffered,\r\n            tributeToken : tributeToken,\r\n            paymentRequested : paymentRequested,\r\n            paymentToken : paymentToken,\r\n            startingPeriod : 0,\r\n            yesVotes : 0,\r\n            noVotes : 0,\r\n            flags : flags,\r\n            details : details,\r\n            maxTotalSharesAndLootAtYesVote : 0\r\n        });\r\n        \r\n        proposals[proposalCount] = proposal;\r\n        address memberAddress = msg.sender;\r\n        // NOTE: argument order matters, avoid stack too deep\r\n        emit SubmitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, proposalCount, msg.sender, memberAddress);\r\n        proposalCount += 1;\r\n    }\r\n\r\n    function sponsorProposal(uint256 proposalId) public nonReentrant  {\r\n\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.proposer != address(0), 'proposal must have been proposed');\r\n        require(!proposal.flags[0], \"proposal has already been sponsored\");\r\n        require(!proposal.flags[3], \"proposal has been cancelled\");\r\n        require(members[proposal.applicant].jailed == false, \"proposal applicant must not be jailed\");\r\n\r\n        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0) {\r\n            require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, 'cannot sponsor more tribute proposals for new tokens - guildbank is full');\r\n        }\r\n\r\n         if (proposal.flags[4]) {\r\n            require(!proposedToKick[proposal.applicant], 'already proposed to kick');\r\n            proposedToKick[proposal.applicant] = true;\r\n        }\r\n\r\n        // compute startingPeriod for proposal\r\n        uint256 startingPeriod = max(\r\n            getCurrentPeriod(),\r\n            proposalQueue.length == 0 ? 0 : proposals[proposalQueue[proposalQueue.length.sub(1)]].startingPeriod\r\n        ).add(1);\r\n\r\n        proposal.startingPeriod = startingPeriod;\r\n\r\n        address memberAddress = msg.sender;\r\n        proposal.sponsor = memberAddress;\r\n\r\n        proposal.flags[0] = true; // sponsored\r\n\r\n        // append proposal to the queue\r\n        proposalQueue.push(proposalId);\r\n        \r\n        emit SponsorProposal(msg.sender, memberAddress, proposalId, proposalQueue.length.sub(1), startingPeriod);\r\n    }\r\n\r\n\r\n    function submitVote(uint256 proposalIndex, uint8 uintVote) public nonReentrant {\r\n        require(members[msg.sender].exists == true);\r\n        Member storage member = members[msg.sender];\r\n\r\n        require(proposalIndex < proposalQueue.length, \"proposal does not exist\");\r\n        Proposal storage proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        require(uintVote < 3, \"must be less than 3, 1 = yes, 2 = no\");\r\n        Vote vote = Vote(uintVote);\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod, \"voting period has not started\");\r\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \"proposal voting period has expired\");\r\n        require(proposal.votesByMember[msg.sender] == Vote.Null, \"member has already voted\");\r\n        require(vote == Vote.Yes || vote == Vote.No, \"vote must be either Yes or No\");\r\n\r\n        proposal.votesByMember[msg.sender] = vote;\r\n\r\n        if (vote == Vote.Yes) {\r\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\r\n\r\n            // set highest index (latest) yes vote - must be processed for member to ragequit\r\n            if (proposalIndex > member.highestIndexYesVote) {\r\n                member.highestIndexYesVote = proposalIndex;\r\n            }\r\n\r\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\r\n            if (totalShares.add(totalLoot) > proposal.maxTotalSharesAndLootAtYesVote) {\r\n                proposal.maxTotalSharesAndLootAtYesVote = totalShares.add(totalLoot);\r\n            }\r\n\r\n        } else if (vote == Vote.No) {\r\n            proposal.noVotes = proposal.noVotes.add(member.shares);\r\n        }\r\n     \r\n        emit SubmitVote(proposalQueue[proposalIndex], proposalIndex, msg.sender, msg.sender, uintVote);\r\n    }\r\n\r\n    function processProposal(uint256 proposalIndex) public nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n        \r\n        //[sponsored -0 , processed -1, didPass -2, cancelled -3, guildkick -4, spending -5, member -6, governance -7]\r\n        require(!proposal.flags[4] && !proposal.flags[7], \"not standard proposal\"); \r\n\r\n        proposal.flags[1] = true; // processed\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        // Make the proposal fail if the new total number of shares and loot exceeds the limit\r\n        // Make the proposal fail if the new total number of shares and loot exceeds the limit\r\n        if (totalShares.add(totalLoot).add(proposal.sharesRequested).add(proposal.lootRequested) > MAX_INPUT) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if it is requesting more tokens as payment than the available guild bank balance\r\n        if (proposal.paymentRequested > userTokenBalances[GUILD][proposal.paymentToken]) {\r\n            didPass = false;\r\n        }\r\n\r\n        // PROPOSAL PASSED\r\n        if (didPass) {\r\n            proposal.flags[2] = true; // didPass\r\n\r\n            // if the applicant is already a member, add to their existing shares & loot\r\n            if (members[proposal.applicant].exists) {\r\n                members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\r\n                members[proposal.applicant].loot = members[proposal.applicant].loot.add(proposal.lootRequested);\r\n               \r\n               // update member iTB and iVal\r\n                if(proposal.sharesRequested > 0 || proposal.lootRequested > 0 && proposal.tributeToken == address(idleToken)){\r\n                    members[proposal.applicant].iTB += proposal.tributeOffered;\r\n                    members[proposal.applicant].iVal += proposal.tributeOffered;\r\n                }\r\n                \r\n            // the applicant is a new member, create a new record for them\r\n            } else {\r\n                members[proposal.applicant] = Member(proposal.sharesRequested, proposal.lootRequested, proposal.tributeOffered, 0, proposal.tributeOffered, 0, false, true);\r\n                \r\n                if (proposal.tributeToken == address(idleToken)){\r\n                    members[proposal.applicant].iTB += proposal.tributeOffered;\r\n                    members[proposal.applicant].iVal += proposal.tributeOffered; \r\n                }\r\n                memberList.push(proposal.applicant);\r\n            }\r\n\r\n            // mint new shares & loot\r\n            totalShares = totalShares.add(proposal.sharesRequested);\r\n            totalLoot = totalLoot.add(proposal.lootRequested);\r\n\r\n            unsafeInternalTransfer(ESCROW, GUILD, proposal.tributeToken, proposal.tributeOffered);\r\n            unsafeInternalTransfer(GUILD, proposal.applicant, proposal.paymentToken, proposal.paymentRequested);\r\n            \r\n            // update earningsPeg for membership proposals and spending proposals\r\n            if (proposal.sharesRequested > 0 || proposal.lootRequested > 0) {\r\n                totalDeposits += int(proposal.tributeOffered);\r\n            }\r\n            \r\n            if (proposal.paymentRequested > 0 && proposal.sharesRequested < 1) {\r\n                totalDeposits -= int(proposal.paymentRequested);\r\n            }\r\n\r\n        // PROPOSAL FAILED\r\n        } else {\r\n            // return all tokens to the proposer (not the applicant, because funds come from proposer)\r\n            unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        }\r\n\r\n        _returnDeposit();\r\n        \r\n        emit ProcessProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n\r\n\r\n    function processGuildKickProposal(uint256 proposalIndex) public nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[4], \"not guild kick\");\r\n\r\n        proposal.flags[1] = true; //[sponsored, processed, didPass, cancelled, guildkick, spending, member]\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n        if (didPass) {\r\n            proposal.flags[2] = true; // didPass\r\n            Member storage member = members[proposal.applicant];\r\n            member.jailed == true;\r\n\r\n            // transfer shares to loot\r\n            member.loot = member.loot.add(member.shares);\r\n            totalShares = totalShares.sub(member.shares);\r\n            totalLoot = totalLoot.add(member.shares);\r\n            member.shares = 0; // revoke all shares\r\n        }\r\n\r\n        proposedToKick[proposal.applicant] = false;\r\n\r\n        _returnDeposit();\r\n\r\n        emit ProcessGuildKickProposal(proposalIndex, proposalId, didPass);\r\n    }\r\n    \r\n    function processAmendGovernance(uint256 proposalIndex) public nonReentrant {\r\n        _validateProposalForProcessing(proposalIndex);\r\n\r\n        uint256 proposalId = proposalQueue[proposalIndex];\r\n        Proposal storage proposal = proposals[proposalId];\r\n\r\n        require(proposal.flags[7], \"not gov amendment\");\r\n\r\n        proposal.flags[1] = true; //[sponsored, processed, didPass, cancelled, guildkick, spending, member]\r\n\r\n        bool didPass = _didPass(proposalIndex);\r\n\r\n            if (didPass) {\r\n                proposal.flags[2] = true; // didPass\r\n            \r\n            // Updates PartyGoal\r\n            if(proposal.tributeOffered > 0){\r\n                partyGoal = proposal.tributeOffered;\r\n            }\r\n            \r\n            // Update depositRate\r\n            if(proposal.paymentRequested > 0){\r\n                depositRate = proposal.paymentRequested;\r\n            }\r\n            \r\n            // Adds token to whitelist and approvedTokens\r\n            if(proposal.tributeToken != depositToken) {\r\n                require(!tokenWhitelist[proposal.tributeToken], \"cannot already have whitelisted the token\");\r\n                require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"too many tokens already\");\r\n                approvedTokens.push(proposal.tributeToken);\r\n                tokenWhitelist[address(proposal.tributeToken)] = true;\r\n            }\r\n            // Used to upgrade idle address\r\n            if(proposal.paymentToken != address(idleToken) && proposal.paymentToken != depositToken) {\r\n                _setIdle(proposal.paymentToken);\r\n                approvedTokens.push(proposal.paymentToken);\r\n                tokenWhitelist[address(proposal.paymentToken)] = true;\r\n            }\r\n        }\r\n\r\n        _returnDeposit();\r\n        \r\n        emit ProcessAmendGovernance(proposalIndex, proposalId, didPass, proposal.tributeToken, proposal.paymentToken, proposal.tributeOffered, proposal.paymentRequested);\r\n    }\r\n\r\n    function _didPass(uint256 proposalIndex) internal view returns (bool didPass) {\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        didPass = proposal.yesVotes > proposal.noVotes;\r\n\r\n        // Make the proposal fail if the dilutionBound is exceeded\r\n        if ((totalShares.add(totalLoot)).mul(dilutionBound / 100) < proposal.maxTotalSharesAndLootAtYesVote) {\r\n            didPass = false;\r\n        }\r\n\r\n        // Make the proposal fail if the applicant is jailed\r\n        // - for standard proposals, we don't want the applicant to get any shares/loot/payment\r\n        // - for guild kick proposals, we should never be able to propose to kick a jailed member (or have two kick proposals active), so it doesn't matter\r\n        if (members[proposal.applicant].jailed == true) {\r\n            didPass = false;\r\n        }\r\n\r\n        return didPass;\r\n    }\r\n\r\n    function _validateProposalForProcessing(uint256 proposalIndex) internal view {\r\n        require(proposalIndex < proposalQueue.length, \"no such proposal\");\r\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"proposal not ready\");\r\n        require(proposal.flags[1] == false, \"proposal has already been processed\");\r\n        require(proposalIndex == 0 || proposals[proposalQueue[proposalIndex.sub(1)]].flags[1], \"previous proposal unprocessed\");\r\n    }\r\n\r\n    function _returnDeposit() internal {\r\n        unsafeInternalTransfer(ESCROW, msg.sender, depositToken, proposalDepositReward);\r\n    }\r\n\r\n    function ragequit() public nonReentrant {\r\n        /* \r\n        @Dev - to simplify accounting had to set ragequit to an all or nothing proposition.\r\n        Since members who ragequit can always redeposit after the ragequit, it should not \r\n        be to limiting until a better system can be implemented in ModMol v3. \r\n        */\r\n        \r\n        require(members[msg.sender].shares.add(members[msg.sender].loot) > 0, \"only users with balances can ragequit\");\r\n        _ragequit(msg.sender);\r\n    }\r\n\r\n    function _ragequit(address memberAddress) internal returns (uint256) {\r\n        uint256 initialTotalSharesAndLoot = totalShares.add(totalLoot);\r\n\r\n        Member storage member = members[memberAddress];\r\n\r\n        require(canRagequit(member.highestIndexYesVote), \"cannot ragequit until highest index proposal member voted YES on is processed\");\r\n\r\n        // set member shares and loot to \r\n        uint256 sharesToBurn = member.shares;\r\n        uint256 lootToBurn = member.loot;\r\n        uint256 sharesAndLootToBurn = sharesToBurn.add(lootToBurn);\r\n\r\n        // burn shares and loot (obviously sets member shares and loot back to 0)\r\n        member.shares = member.shares.sub(sharesToBurn);\r\n        member.loot = member.loot.sub(lootToBurn);\r\n        totalShares = totalShares.sub(sharesToBurn);\r\n        totalLoot = totalLoot.sub(lootToBurn);\r\n        \r\n\r\n        for (uint256 i = 0; i < approvedTokens.length; i++) {\r\n            uint256 amountToRagequit = fairShare(userTokenBalances[GUILD][approvedTokens[i]], sharesAndLootToBurn, initialTotalSharesAndLoot);\r\n            if (amountToRagequit > 0) { // gas optimization to allow a higher maximum token limit\r\n                userTokenBalances[GUILD][approvedTokens[i]] -= amountToRagequit;\r\n                userTokenBalances[memberAddress][approvedTokens[i]] += amountToRagequit;\r\n                subFees(GUILD, amountToRagequit, approvedTokens[i]);\r\n                totalDeposits -= int(amountToRagequit);\r\n                // Only runs guild bank adjustment if member has withdrawn tokens.\r\n                // Otherwise, adjustment would end up costing member their fair share\r\n                    \r\n                 if(member.iTW > 0) {\r\n                    // @Dev - SafeMath wasn't working here. \r\n                     uint256 iAdj = member.iTW;\r\n                     if(iAdj > 0) {\r\n                        unsafeInternalTransfer(memberAddress, GUILD, address(idleToken), iAdj);\r\n                     }\r\n                 }\r\n                 \r\n                // Reset member-specific internal accting \r\n                member.iTB = 0;\r\n                member.iTW = 0;\r\n                member.iVal = 0;\r\n            }\r\n        }\r\n        emit Ragequit(msg.sender, sharesToBurn, lootToBurn);  \r\n    }\r\n\r\n    function ragekick(address memberToKick) public nonReentrant {\r\n        Member storage member = members[memberToKick];\r\n\r\n        require(member.jailed != true, \"member not jailed\");\r\n        require(member.loot > 0, \"member must have loot\"); // note - should be impossible for jailed member to have shares\r\n        require(canRagequit(member.highestIndexYesVote), \"cannot ragequit until highest index proposal member voted YES on is processed\");\r\n\r\n        _ragequit(memberToKick);\r\n    }\r\n    \r\n    function withdrawEarnings(address memberAddress, uint256 amount) external nonReentrant {\r\n        uint256 initialTotalSharesAndLoot = totalShares.add(totalLoot);\r\n        \r\n        Member storage member = members[memberAddress];\r\n        uint256 sharesM = member.shares;\r\n        uint256 lootM = member.loot;\r\n        uint256 sharesAndLootM = sharesM.add(lootM);\r\n        \r\n        require(member.exists == true, \"not member\");\r\n        require(address(msg.sender) == memberAddress, \"can only be called by member\");\r\n\r\n        //Calculates if user's share of wETH in the pool is creater than their deposit amts (used for potential earnings)\r\n        uint256 iTBVal = fairShare(userTokenBalances[GUILD][idleToken], sharesAndLootM, initialTotalSharesAndLoot);\r\n        uint256 iBase = abs(totalDeposits).div(initialTotalSharesAndLoot).mul(sharesAndLootM).add(member.iTW);\r\n        require(iTBVal.sub(iBase) >= amount, \"not enough earnings to redeem this many tokens\");\r\n        \r\n        uint256 earningsToUser = subFees(GUILD, amount, address(idleToken));\r\n        uint256 redeemedTokens = amount; \r\n        \r\n        emit WithdrawEarnings(msg.sender, address(idleToken), earningsToUser, depositToken, redeemedTokens);\r\n\r\n        // Accounting updates\r\n        member.iTW += amount;\r\n        member.iTB -= amount;\r\n        totalDeposits -= int(amount);\r\n        unsafeInternalTransfer(GUILD, memberAddress, address(idleToken), earningsToUser);\r\n    }\r\n    \r\n\r\n    function withdrawBalance(address token, uint256 amount) public nonReentrant {\r\n        _withdrawBalance(token, amount);\r\n    }\r\n    \r\n\r\n    function withdrawBalances(address[] memory tokens, uint256[] memory amounts, bool max) public nonReentrant {\r\n        require(tokens.length == amounts.length, \"tokens + amounts arrays must match\");\r\n\r\n        for (uint256 i=0; i < tokens.length; i++) {\r\n            uint256 withdrawAmount = amounts[i];\r\n            if (max) { // withdraw the maximum balance\r\n                withdrawAmount = userTokenBalances[msg.sender][tokens[i]];\r\n            }\r\n\r\n            _withdrawBalance(tokens[i], withdrawAmount);\r\n        }\r\n    }\r\n    \r\n    \r\n    function _withdrawBalance(address token, uint256 amount) internal {\r\n        require(userTokenBalances[msg.sender][token] >= amount, \"insufficient balance\");\r\n        unsafeSubtractFromBalance(msg.sender, token, amount);\r\n        require(IERC20(token).transfer(msg.sender, amount), \"transfer failed\");\r\n        emit Withdraw(msg.sender, token, amount);\r\n    }\r\n    \r\n\r\n    // NOTE: gives the DAO the ability to collect payments and also recover tokens just sent to DAO address (if whitelisted)\r\n    function collectTokens(address token) external {\r\n        uint256 amountToCollect = IERC20(token).balanceOf(address(this)) - userTokenBalances[TOTAL][token];\r\n        // only collect if 1) there are tokens to collect and 2) token is whitelisted\r\n        require(amountToCollect > 0, \"no tokens\");\r\n        require(tokenWhitelist[token], \"not whitelisted\");\r\n        \r\n        unsafeAddToBalance(GUILD, token, amountToCollect);\r\n\r\n        emit TokensCollected(token, amountToCollect);\r\n    }\r\n    \r\n\r\n    function cancelProposal(uint256 proposalId) public nonReentrant {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(getCurrentPeriod() <= proposal.startingPeriod, \"voting period has already started\");\r\n        require(!proposal.flags[3], \"proposal already cancelled\");\r\n        require(msg.sender == proposal.proposer, \"only proposer cancels\");\r\n\r\n        proposal.flags[3] = true; // cancelled\r\n        \r\n        unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\r\n        emit CancelProposal(proposalId, msg.sender);\r\n    }\r\n\r\n    // can only ragequit if the latest proposal you voted YES on has been processed\r\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {\r\n        if(proposalQueue.length == 0){\r\n            return true;\r\n        } else {\r\n            require(highestIndexYesVote < proposalQueue.length, \"no such proposal\");\r\n            return proposals[proposalQueue[highestIndexYesVote]].flags[0];\r\n        }\r\n    }\r\n\r\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {\r\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\r\n    }\r\n    \r\n    /***************\r\n    GETTER FUNCTIONS\r\n    ***************/\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    function getCurrentPeriod() public view returns (uint256) {\r\n        return now.sub(summoningTime).div(periodDuration);\r\n    }\r\n\r\n    function getProposalQueueLength() public view returns (uint256) {\r\n        return proposalQueue.length;\r\n    }\r\n\r\n    function getProposalFlags(uint256 proposalId) public view returns (bool[8] memory) {\r\n        return proposals[proposalId].flags;\r\n    }\r\n\r\n    function getUserTokenBalance(address user, address token) public view returns (uint256) {\r\n        return userTokenBalances[user][token];\r\n    }\r\n\r\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) public view returns (Vote) {\r\n        require(members[memberAddress].exists, \"no such member\");\r\n        require(proposalIndex < proposalQueue.length, \"unproposed\");\r\n        return proposals[proposalQueue[proposalIndex]].votesByMember[memberAddress];\r\n    }\r\n\r\n    function getTokenCount() public view returns (uint256) {\r\n        return approvedTokens.length;\r\n    }\r\n\r\n    /***************\r\n    HELPER FUNCTIONS\r\n    ***************/\r\n    function getUserEarnings(uint256 amount) public returns (uint256) {\r\n        uint256 initialTotalSharesAndLoot = totalShares.add(totalLoot);\r\n        \r\n        Member storage member = members[msg.sender];\r\n        uint256 sharesM = member.shares;\r\n        uint256 lootM = member.loot;\r\n        uint256 sharesAndLootM = sharesM.add(lootM);\r\n        \r\n        uint256 iTBVal = fairShare(userTokenBalances[GUILD][idleToken], sharesAndLootM, initialTotalSharesAndLoot);\r\n        uint256 iBase = abs(totalDeposits).div(initialTotalSharesAndLoot).mul(sharesAndLootM).add(member.iTW);\r\n        \r\n        uint256 earnings = iTBVal.sub(iBase);\r\n\r\n        return earnings;\r\n    }\r\n    \r\n    \r\n    function getIdleValue(uint256 amount) public view returns (uint256){\r\n        return 0;\r\n    }\r\n    \r\n\r\n    function subFees(address holder, uint256 amount, address token) internal returns (uint256) {\r\n        /* 10% Fee on earnings\r\n           Earnings here are tokens deposited into the DAO w/o a share request\r\n        */\r\n        uint256 poolFees = amount.div(uint256(1000).div(5)); // 0.5% fee on earnings\r\n        unsafeInternalTransfer(holder, daoFee, address(token), poolFees);\r\n        return amount.sub(poolFees);\r\n    }\r\n\r\n    function makeDeposit(uint256 amount) external nonReentrant {\r\n        require(members[msg.sender].exists == true, 'must be member to deposit shares');\r\n        \r\n        IERC20(address(depositToken)).transferFrom(msg.sender, address(this), amount);\r\n         \r\n        uint256 shares = amount.div(depositRate);\r\n        members[msg.sender].shares += shares;\r\n        require(members[msg.sender].shares <= partyGoal.div(depositRate).div(2), \"can't take over 50% of the shares w/o a proposal\");\r\n        totalShares += shares;\r\n        \r\n        depositToIdle(msg.sender, amount, shares);\r\n    }\r\n    \r\n    // @Dev use better naming conventions next time (actually just updates internal accting)\r\n    function depositToIdle(address depositor, uint256 amount, uint256 shares) internal {\r\n        require(amount != 0, \"no tokens to deposit\");\r\n        totalDeposits += int(amount);\r\n        uint256 mintedTokens = amount;\r\n        \r\n        // Update internal accounting\r\n        members[depositor].iTB += amount;\r\n        members[depositor].iVal += amount;\r\n        unsafeAddToBalance(GUILD, idleToken, mintedTokens);\r\n        \r\n        // Checks to see if goal has been reached with this deposit\r\n         goalHit = checkGoal();\r\n        \r\n        emit MakeDeposit(depositor, amount, mintedTokens, shares, goalHit);\r\n    }\r\n    \r\n    function checkGoal() public returns (uint8) {\r\n        uint256 daoFunds = getUserTokenBalance(GUILD, idleToken);\r\n\r\n        if(daoFunds >= partyGoal){\r\n            return goalHit = 1;\r\n        } else {\r\n            return goalHit = 0;\r\n        }\r\n    }\r\n    \r\n    \r\n    function unsafeAddToBalance(address user, address token, uint256 amount) internal {\r\n        userTokenBalances[user][token] += amount;\r\n        userTokenBalances[TOTAL][token] += amount;\r\n    }\r\n\r\n    function unsafeSubtractFromBalance(address user, address token, uint256 amount) internal {\r\n        userTokenBalances[user][token] -= amount;\r\n        userTokenBalances[TOTAL][token] -= amount;\r\n    }\r\n\r\n    function unsafeInternalTransfer(address from, address to, address token, uint256 amount) internal {\r\n        unsafeSubtractFromBalance(from, token, amount);\r\n        unsafeAddToBalance(to, token, amount);\r\n    }\r\n\r\n    function fairShare(uint256 balance, uint256 shares, uint256 totalSharesAndLoot) internal pure returns (uint256) {\r\n        require(totalSharesAndLoot != 0);\r\n\r\n        if (balance == 0) { return 0; }\r\n\r\n        uint256 prod = balance * shares;\r\n\r\n        if (prod / balance == shares) { // no overflow in multiplication above?\r\n            return prod / totalSharesAndLoot;\r\n        }\r\n\r\n        return (balance / totalSharesAndLoot) * shares;\r\n    }\r\n    \r\n    function abs(int x) internal pure returns (uint) {\r\n        \r\n        return uint(x) >= 0 ? uint(x) : uint(-x);\r\n    }\r\n}\r\n\r\n// File: browser/WETHpartyStarter.sol\r\n\r\n// Kovan Weth Wrapper 0xd0A1E359811322d97991E03f863a0C30C2cF029C\r\n// Mainnet Weth Wrapper 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n\r\n//\"SPDX-License-Identifier: MIT\"\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n// [\"0xd0A1E359811322d97991E03f863a0C30C2cF029C\",\"0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa\"] kWETH, kDAI\r\n// [\"0x0bA6142464b224abE3845b652B65162dBdF2A285\",\"0x7136fbDdD4DFfa2369A9283B6E90A040318011Ca\",\"0x3792acDf2A8658FBaDe0ea70C47b89cB7777A5a5\"] test members\r\n// 1000000000000000000\r\n\r\ncontract NoFiPartyStarter is CloneFactory {\r\n    \r\n    address public template;\r\n    \r\n    constructor (address _template) public {\r\n        template = _template;\r\n    }\r\n\r\n    \r\n    event PartyStarted(address indexed pty, address[] _founders, address[] _approvedTokens, address _daoFees, uint256 _periodDuration, uint256 _votingPeriodLength, uint256 _gracePeriodLength, uint256 _proposalDepositReward, uint256 _depositRate, uint256 _partyGoal, uint256 summoningTime, uint256 _dilutionBound);\r\n\r\n    function startParty(\r\n        address[] memory _founders,\r\n        address[] memory _approvedTokens, //deposit token in 0, WETH in 0\r\n        address _daoFees,\r\n        uint256 _periodDuration,\r\n        uint256 _votingPeriodLength,\r\n        uint256 _gracePeriodLength,\r\n        uint256 _proposalDepositReward,\r\n        uint256 _depositRate,\r\n        uint256 _partyGoal,\r\n        uint256 _dilutionBound\r\n    ) public returns (address) {\r\n       NoFiParty pty = NoFiParty(createClone(template));\r\n      \r\n       pty.init(\r\n            _founders,\r\n            _approvedTokens,\r\n            _daoFees,\r\n            _periodDuration,\r\n            _votingPeriodLength,\r\n            _gracePeriodLength,\r\n            _proposalDepositReward,\r\n            _depositRate,\r\n            _partyGoal,\r\n            _dilutionBound);\r\n        \r\n        emit PartyStarted(address(pty), _founders, _approvedTokens, _daoFees, _periodDuration, _votingPeriodLength, _gracePeriodLength, _proposalDepositReward, _depositRate, _partyGoal, now, _dilutionBound);\r\n        return address(pty);\r\n    }\r\n}"}}}