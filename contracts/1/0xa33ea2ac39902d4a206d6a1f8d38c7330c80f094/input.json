{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/ESM.sol": {
      "content": "// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.7;\n\nabstract contract ESMThresholdSetter {\n    function recomputeThreshold() virtual public;\n}\n\nabstract contract TokenLike {\n    function totalSupply() virtual public view returns (uint256);\n    function balanceOf(address) virtual public view returns (uint256);\n    function transfer(address, uint256) virtual public returns (bool);\n    function transferFrom(address, address, uint256) virtual public returns (bool);\n}\n\nabstract contract GlobalSettlementLike {\n    function shutdownSystem() virtual public;\n}\n\ncontract ESM {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) public isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) public isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"esm/account-not-authorized\");\n        _;\n    }\n\n    TokenLike            public protocolToken;      // collateral\n    GlobalSettlementLike public globalSettlement;   // shutdown module\n    ESMThresholdSetter   public thresholdSetter;    // threshold setter\n\n    address              public tokenBurner;        // burner\n    uint256              public triggerThreshold;   // threshold\n    uint256              public settled;            // flag that indicates whether the shutdown module has been called/triggered\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, uint256 wad);\n    event ModifyParameters(bytes32 parameter, address account);\n    event Shutdown();\n    event FailRecomputeThreshold(bytes revertReason);\n\n    constructor(\n      address protocolToken_,\n      address globalSettlement_,\n      address tokenBurner_,\n      address thresholdSetter_,\n      uint256 triggerThreshold_\n    ) public {\n        require(both(triggerThreshold_ > 0, triggerThreshold_ < TokenLike(protocolToken_).totalSupply()), \"esm/threshold-not-within-bounds\");\n\n        authorizedAccounts[msg.sender] = 1;\n\n        protocolToken    = TokenLike(protocolToken_);\n        globalSettlement = GlobalSettlementLike(globalSettlement_);\n        thresholdSetter  = ESMThresholdSetter(thresholdSetter_);\n        tokenBurner      = tokenBurner_;\n        triggerThreshold = triggerThreshold_;\n\n        emit AddAuthorization(msg.sender);\n        emit ModifyParameters(bytes32(\"triggerThreshold\"), triggerThreshold_);\n        emit ModifyParameters(bytes32(\"thresholdSetter\"), thresholdSetter_);\n    }\n\n    // --- Math ---\n    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x + y;\n        require(z >= x);\n    }\n\n    // --- Utils ---\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- Administration ---\n    /*\n    * @notice Modify a uint256 parameter\n    * @param parameter The name of the parameter to change the value for\n    * @param wad The new parameter value\n    */\n    function modifyParameters(bytes32 parameter, uint256 wad) external {\n        require(settled == 0, \"esm/already-settled\");\n        require(either(address(thresholdSetter) == msg.sender, authorizedAccounts[msg.sender] == 1), \"esm/account-not-authorized\");\n        if (parameter == \"triggerThreshold\") {\n          require(both(wad > 0, wad < protocolToken.totalSupply()), \"esm/threshold-not-within-bounds\");\n          triggerThreshold = wad;\n        }\n        else revert(\"esm/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, wad);\n    }\n    /*\n    * @notice Modify an address parameter\n    * @param parameter The parameter name whose value will be changed\n    * @param account The new address for the parameter\n    */\n    function modifyParameters(bytes32 parameter, address account) external isAuthorized {\n        require(settled == 0, \"esm/already-settled\");\n        if (parameter == \"thresholdSetter\") {\n          thresholdSetter = ESMThresholdSetter(account);\n          // Make sure the update works\n          thresholdSetter.recomputeThreshold();\n        }\n        else revert(\"esm/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, account);\n    }\n\n    /*\n    * @notify Recompute the triggerThreshold using the thresholdSetter\n    */\n    function recomputeThreshold() internal {\n        if (address(thresholdSetter) != address(0)) {\n          try thresholdSetter.recomputeThreshold() {}\n          catch(bytes memory revertReason) {\n            emit FailRecomputeThreshold(revertReason);\n          }\n        }\n    }\n    /*\n    * @notice Sacrifice tokens and trigger settlement\n    * @dev This can only be done once\n    */\n    function shutdown() external {\n        require(settled == 0, \"esm/already-settled\");\n        recomputeThreshold();\n        settled = 1;\n        require(protocolToken.transferFrom(msg.sender, tokenBurner, triggerThreshold), \"esm/transfer-failed\");\n        emit Shutdown();\n        globalSettlement.shutdownSystem();\n    }\n}\n"
    }
  }
}