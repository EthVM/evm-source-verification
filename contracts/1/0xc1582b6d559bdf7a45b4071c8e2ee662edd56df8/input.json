{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 777
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "b.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n/*\r\n███   ██   ██   █     \r\n█  █  █ █  █ █  █     \r\n█ ▀ ▄ █▄▄█ █▄▄█ █     \r\n█  ▄▀ █  █ █  █ ███▄  \r\n███      █    █     ▀ \r\n        █    █        \r\n       ▀    ▀*/\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Interface for Baal {memberAction} that adjusts member `shares` & `loot`.\r\ninterface IShaman {\r\n    function memberAction(address member, uint96 loot, uint96 shares) external payable returns (uint96 lootOut, uint96 sharesOut);\r\n}\r\n\r\n/// @title Baal ';_;'.\r\n/// @notice Flexible guild contract inspired by Moloch DAO framework.\r\ncontract Baal {\r\n    bool public lootPaused; /*tracks transferability of `loot` economic weight - amendable through 'period'[2] proposal*/\r\n    bool public sharesPaused; /*tracks transferability of erc20 `shares` - amendable through 'period'[2] proposal*/\r\n    bool singleSummoner; /*internal flag to gauge speedy proposal processing*/\r\n    \r\n    uint8  constant public decimals = 18; /*unit scaling factor in erc20 `shares` accounting - '18' is default to match ETH & common erc20s*/\r\n    uint16 constant MAX_GUILD_TOKEN_COUNT = 400; /*maximum number of whitelistable tokens subject to {ragequit}*/\r\n    \r\n    uint96 public totalLoot; /*counter for total `loot` economic weight held by `members`*/  \r\n    uint96 public totalSupply; /*counter for total `members` voting `shares` with erc20 accounting*/\r\n    \r\n    uint32 public gracePeriod; /*time delay after proposal voting period for processing*/\r\n    uint32 public minVotingPeriod; /*minimum period for voting in seconds - amendable through 'period'[2] proposal*/\r\n    uint32 public maxVotingPeriod; /*maximum period for voting in seconds - amendable through 'period'[2] proposal*/\r\n    uint public proposalCount; /*counter for total `proposals` submitted*/\r\n    uint status; /*internal reentrancy check tracking value*/\r\n    \r\n    string public name; /*'name' for erc20 `shares` accounting*/\r\n    string public symbol; /*'symbol' for erc20 `shares` accounting*/\r\n    \r\n    bytes32 constant DOMAIN_TYPEHASH = keccak256('EIP712Domain(string name,uint chainId,address verifyingContract)'); /*EIP-712 typehash for Baal domain*/\r\n    bytes32 constant DELEGATION_TYPEHASH = keccak256('Delegation(address delegatee,uint nonce,uint expiry)'); /*EIP-712 typehash for Baal delegation*/\r\n    bytes32 constant PERMIT_TYPEHASH = keccak256('Permit(address owner,address spender,uint value,uint nonce,uint deadline)'); /*EIP-712 typehash for EIP-2612 {permit}*/\r\n    bytes32 constant VOTE_TYPEHASH = keccak256('Vote(uint proposalId,bool support)'); /*EIP-712 typehash for Baal proposal vote*/\r\n    \r\n    address[] guildTokens; /*array list of erc20 tokens approved on summoning or by 'whitelist'[3] `proposals` for {ragequit} claims*/\r\n    \r\n    mapping(address => mapping(address => uint))    public allowance; /*maps approved pulls of `shares` with erc20 accounting*/\r\n    mapping(address => uint)                        public balanceOf; /*maps `members` accounts to `shares` with erc20 accounting*/\r\n    mapping(address => mapping(uint => Checkpoint)) public checkpoints; /*maps record of vote `checkpoints` for each account by index*/\r\n    mapping(address => uint)                        public numCheckpoints; /*maps number of `checkpoints` for each account*/\r\n    mapping(address => address)                     public delegates; /*maps record of each account's `shares` delegate*/\r\n    mapping(address => uint)                        public nonces; /*maps record of states for signing & validating signatures*/\r\n    \r\n    mapping(address => Member) public members; /*maps `members` accounts to struct details*/\r\n    mapping(uint => Proposal)  public proposals; /*maps `proposalCount` to struct details*/\r\n    mapping(uint => bool)      public proposalsPassed; /*maps `proposalCount` to approval status - separated out as struct is deleted, and this value can be used by minion-like contracts*/\r\n    mapping(address => bool)   public shamans; /*maps contracts approved in 'whitelist'[3] proposals for {memberAction} that mint or burn `shares`*/\r\n    \r\n    event SummonComplete(bool lootPaused, bool sharesPaused, uint gracePeriod, uint minVotingPeriod, uint maxVotingPeriod, string name, string symbol, address[] guildTokens, address[] shamans, address[] summoners, uint96[] loot, uint96[] shares); /*emits after Baal summoning*/\r\n    event SubmitProposal(uint8 indexed flag, uint indexed proposal, uint indexed votingPeriod, address[] to, uint96[] value, bytes[] data, string details); /*emits after proposal is submitted*/\r\n    event SponsorProposal(address indexed member, uint indexed proposal, uint indexed votingStarts); /*emits after member has sponsored proposal*/\r\n    event SubmitVote(address indexed member, uint balance, uint indexed proposal, bool indexed approved); /*emits after vote is submitted on proposal*/\r\n    event ProcessProposal(uint indexed proposal); /*emits when proposal is processed & executed*/\r\n    event Ragequit(address indexed member, address to, uint96 indexed lootToBurn, uint96 indexed sharesToBurn); /*emits when users burn Baal `shares` and/or `loot` for given `to` account*/\r\n    event Approval(address indexed owner, address indexed spender, uint amount); /*emits when Baal `shares` are approved for pulls with erc20 accounting*/\r\n    event Transfer(address indexed from, address indexed to, uint amount); /*emits when Baal `shares` are minted, burned or transferred with erc20 accounting*/\r\n    event TransferLoot(address indexed from, address indexed to, uint96 amount); /*emits when Baal `loot` is minted, burned or transferred*/\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate); /*emits when an account changes its voting delegate*/\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance); /*emits when a delegate account's voting balance changes*/\r\n    \r\n    modifier nonReentrant() { /*reentrancy guard*/\r\n        require(status == 1,'reentrant'); \r\n        status = 2; \r\n        _;\r\n        status = 1;\r\n    }\r\n    \r\n    struct Checkpoint { /*Baal checkpoint for marking number of delegated votes*/\r\n        uint32 fromTimeStamp; /*unix time for referencing voting balance*/\r\n        uint96 votes; /*votes at given unix time*/\r\n    }\r\n \r\n    struct Member { /*Baal membership details*/\r\n        uint96 loot; /*economic weight held by `members` - can be set on summoning & adjusted via {memberAction}*/\r\n        uint highestIndexYesVote; /*highest proposal index on which a member `approved`*/\r\n    }\r\n    \r\n    struct Proposal { /*Baal proposal details*/\r\n        uint32 votingPeriod; /*time for voting in seconds*/\r\n        uint32 votingStarts; /*starting time for proposal in seconds since unix epoch*/\r\n        uint32 votingEnds; /*termination time for proposal in seconds since unix epoch - derived from `votingPeriod` set on proposal*/\r\n        uint96 yesVotes; /*counter for `members` `approved` 'votes' to calculate approval on processing*/\r\n        uint96 noVotes; /*counter for `members` 'dis-approved' 'votes' to calculate approval on processing*/\r\n        bool[4] flags; /*flags for proposal type & status - [action, member, period, whitelist]*/\r\n        address[] to; /*account(s) that receive(s) Baal state updates*/\r\n        uint96[] value; /*value(s) associated with Baal state updates (also used to toggle)*/\r\n        bytes[] data; /*raw data associated with Baal state updates (also used to toggle)*/\r\n        string details; /*human-readable context for proposal*/\r\n    }\r\n\r\n    /// @notice Summon Baal with voting configuration & initial array of `members` accounts with `shares` & `loot` weights.\r\n    /// @param _sharesPaused Sets transferability of Baal voting shares on initialization - if 'paused', `loot` will also be 'paused'.\r\n    /// @param _gracePeriod Time delay in seconds after voting period before proposal can be processed.\r\n    /// @param _minVotingPeriod Minimum voting period in seconds for `members` to cast votes on proposals.\r\n    /// @param _maxVotingPeriod Maximum voting period in seconds for `members` to cast votes on proposals.\r\n    /// @param _name Name for erc20 `shares` accounting.\r\n    /// @param _symbol Symbol for erc20 `shares` accounting.\r\n    /// @param _guildTokens Tokens approved for internal accounting - {ragequit} of `shares` &/or `loot`.\r\n    /// @param _shamans External contracts approved for {memberAction} that adjust `shares` & `loot`.\r\n    /// @param _summoners Accounts to add as `members`.\r\n    /// @param _loot Economic weight among `members`.\r\n    /// @param _shares Voting weight among `members` (`shares` also have economic weight & are erc20 tokens).\r\n    constructor(\r\n        bool             _sharesPaused,\r\n        uint32           _gracePeriod,\r\n        uint32           _minVotingPeriod, \r\n        uint32           _maxVotingPeriod,\r\n        string    memory _name, \r\n        string    memory _symbol,\r\n        address[] memory _guildTokens,\r\n        address[] memory _shamans, \r\n        address[] memory _summoners, \r\n        uint96[]  memory _loot, \r\n        uint96[]  memory _shares\r\n    ) {\r\n        require(_minVotingPeriod != 0,'0_min'); /*check min. period isn't null*/\r\n        require(_minVotingPeriod <= _maxVotingPeriod,'min>max'); /*check minimum period doesn't exceed max*/\r\n        require(_guildTokens.length != 0,'0_tokens'); /*check approved tokens are not null*/\r\n        require(_summoners.length != 0,'0_summoners'); /*check that there is at least 1 summoner*/\r\n        require(_summoners.length == _loot.length && _loot.length == _shares.length,'!member array parity'); /*check `members`-related array lengths match*/\r\n        \r\n        unchecked {\r\n            for (uint i; i < _shamans.length; i++) shamans[_shamans[i]] = true; /*update mapping of approved `shamans` in Baal*/\r\n            for (uint i; i < _guildTokens.length; i++) guildTokens.push(_guildTokens[i]); /*update array of `guildTokens` approved for {ragequit}*/\r\n            for (uint i; i < _summoners.length; i++) {\r\n                _mintLoot(_summoners[i], _loot[i]); /*mint Baal `loot` to `summoners`*/\r\n                _mintShares(_summoners[i], _shares[i]); /*mint Baal `shares` to `summoners`*/ \r\n                _delegate(_summoners[i], _summoners[i]); /*delegate `summoners` voting weights to themselves - this saves a step before voting*/\r\n                if (_summoners.length == 1) singleSummoner = true; /*flag if Baal summoned singly for speedy processing*/\r\n            }\r\n        }\r\n        \r\n        gracePeriod = _gracePeriod; /*sets delay for processing proposal*/\r\n        minVotingPeriod = _minVotingPeriod; /*set minimum voting period - adjustable via 'period'[2] proposal*/\r\n        maxVotingPeriod = _maxVotingPeriod; /*set maximum voting period - adjustable via 'period'[2] proposal*/\r\n        if (_sharesPaused) lootPaused = true; /*set initial transferability for `loot` - if `sharesPaused`, transfers are blocked*/\r\n        sharesPaused = _sharesPaused; /*set initial transferability for `shares` tokens - if 'true', transfers are blocked*/\r\n        name = _name; /*initialize Baal `name` with erc20 accounting*/\r\n        symbol = _symbol; /*initialize Baal `symbol` with erc20 accounting*/\r\n        status = 1; /*initialize 'reentrancy guard' status*/\r\n        \r\n        emit SummonComplete(lootPaused, _sharesPaused, _gracePeriod, _minVotingPeriod, _maxVotingPeriod, _name, _symbol, _guildTokens, _shamans, _summoners, _loot, _shares); /*emit event reflecting Baal summoning completed*/\r\n    }\r\n\r\n    /// @notice Execute membership action to mint or burn `shares` and/or `loot` against whitelisted `shamans` in consideration of user & given amounts.\r\n    /// @param shaman Whitelisted contract to trigger action.\r\n    /// @param loot Economic weight involved in external call.\r\n    /// @param shares Voting weight involved in external call.\r\n    /// @param mint Confirm whether action involves 'mint' or 'burn' action - if `false`, perform burn.\r\n    /// @return lootOut sharesOut Membership updates derived from action.\r\n    function memberAction(\r\n        address shaman, \r\n        uint96 loot, \r\n        uint96 shares, \r\n        bool mint\r\n    ) external nonReentrant payable returns (uint96 lootOut, uint96 sharesOut) {\r\n        require(shamans[shaman],'!shaman'); /*check `shaman` is approved*/\r\n        \r\n        (lootOut, sharesOut) = IShaman(shaman).memberAction{value: msg.value}(msg.sender, loot, shares); /*fetch 'reaction' per inputs*/\r\n        \r\n        if (mint) { /*execute `mint` actions*/\r\n            if (lootOut != 0) _mintLoot(msg.sender, lootOut); /*add `loot` to user account & Baal total*/\r\n            if (sharesOut != 0) _mintShares(msg.sender, sharesOut); /*add `shares` to user account & Baal total with erc20 accounting*/\r\n        } else { /*otherwise, execute `burn` actions*/\r\n            if (lootOut != 0) _burnLoot(msg.sender, lootOut); /*subtract `loot` from user account & Baal total*/\r\n            if (sharesOut != 0) _burnShares(msg.sender, sharesOut); /*subtract `shares` from user account & Baal total with erc20 accounting*/\r\n        }\r\n    }\r\n    \r\n    /*****************\r\n    PROPOSAL FUNCTIONS\r\n    *****************/\r\n    /// @notice Submit proposal to Baal `members` for approval within given voting period.\r\n    /// @param flag Index to assign proposal type '[0...3]'.\r\n    /// @param votingPeriod Voting period in seconds.\r\n    /// @param to Account to target for proposal.\r\n    /// @param value Numerical value to bind to proposal.\r\n    /// @param data Data to bind to proposal.\r\n    /// @param details Context for proposal.\r\n    /// @return proposal Count for submitted proposal.\r\n    function submitProposal(\r\n        uint8 flag, \r\n        uint32 votingPeriod, \r\n        address[] calldata to, \r\n        uint96[] calldata value, \r\n        bytes[] calldata data, \r\n        string calldata details\r\n    ) external nonReentrant returns (uint proposal) {\r\n        require(minVotingPeriod <= votingPeriod && votingPeriod <= maxVotingPeriod,'!votingPeriod'); /*check voting period is within Baal bounds*/\r\n        require(to.length <= 10,'array max'); /*limit executable actions to help avoid block gas limit errors on processing*/\r\n        require(flag <= 3,'!flag'); /*check 'flag' is in bounds*/\r\n        \r\n        bool[4] memory flags; /*plant `flags` - [action, member, period, whitelist]*/\r\n        flags[flag] = true; /*flag proposal type for struct storage*/ \r\n        \r\n        if (flag == 2) {\r\n            if (value.length == 1) {\r\n                require(value[0] <= maxVotingPeriod,'over max');\r\n            } else if (value.length == 2) {\r\n                require(value[1] >= minVotingPeriod,'under min');\r\n            }\r\n        } else {\r\n            require(to.length == value.length && value.length == data.length,'!array parity'); /*check array lengths match*/\r\n        }\r\n        \r\n        bool selfSponsor; /*plant sponsor flag*/\r\n        if (balanceOf[msg.sender] != 0) selfSponsor = true; /*if a member, self-sponsor*/\r\n\r\n        unchecked {\r\n            proposalCount++; /*increment proposal counter*/\r\n            proposals[proposalCount] = Proposal( /*push params into proposal struct - start voting period timer if member submission*/\r\n                votingPeriod,\r\n                selfSponsor ? uint32(block.timestamp) : 0, \r\n                selfSponsor ? uint32(block.timestamp) + votingPeriod : 0, \r\n                0, 0, flags, to, value, data, details\r\n            );\r\n        }\r\n        \r\n        emit SubmitProposal(flag, proposal, votingPeriod, to, value, data, details); /*emit event reflecting proposal submission*/\r\n    }\r\n    \r\n    /// @notice Sponsor proposal to Baal `members` for approval within voting period.\r\n    /// @param proposal Number of proposal in `proposals` mapping to sponsor.\r\n    function sponsorProposal(uint proposal) external nonReentrant {\r\n        Proposal storage prop = proposals[proposal]; /*alias proposal storage pointers*/\r\n        \r\n        require(balanceOf[msg.sender] != 0,'!member'); /*check 'membership' - required to sponsor proposal*/\r\n        require(prop.votingPeriod != 0,'!exist'); /*check proposal existence*/\r\n        require(prop.votingStarts == 0,'sponsored'); /*check proposal not already sponsored*/\r\n        \r\n        prop.votingStarts = uint32(block.timestamp);\r\n        \r\n        unchecked {\r\n            prop.votingEnds = uint32(block.timestamp) + prop.votingPeriod;\r\n        }\r\n\r\n        emit SponsorProposal(msg.sender, proposal, block.timestamp);\r\n    }\r\n\r\n    /// @notice Submit vote - proposal must exist & voting period must not have ended.\r\n    /// @param proposal Number of proposal in `proposals` mapping to cast vote on.\r\n    /// @param approved If 'true', member will cast `yesVotes` onto proposal - if 'false', `noVotes` will be counted.\r\n    function submitVote(uint proposal, bool approved) external nonReentrant {\r\n        Proposal storage prop = proposals[proposal]; /*alias proposal storage pointers*/\r\n        \r\n        uint96 balance = getPriorVotes(msg.sender, prop.votingStarts); /*fetch & gas-optimize voting weight at proposal creation time*/\r\n        \r\n        require(prop.votingEnds >= block.timestamp,'ended'); /*check voting period has not ended*/\r\n        \r\n        unchecked {\r\n            if (approved) { /*if `approved`, cast delegated balance `yesVotes` to proposal*/\r\n                prop.yesVotes += balance; \r\n                members[msg.sender].highestIndexYesVote = proposal;\r\n            } else { /*otherwise, cast delegated balance `noVotes` to proposal*/\r\n                prop.noVotes += balance;\r\n            }\r\n        }\r\n\r\n        emit SubmitVote(msg.sender, balance, proposal, approved); /*emit event reflecting vote*/\r\n    }\r\n    \r\n    /// @notice Submit vote with EIP-712 signature - proposal must exist & voting period must not have ended.\r\n    /// @param proposal Number of proposal in `proposals` mapping to cast vote on.\r\n    /// @param approved If 'true', member will cast `yesVotes` onto proposal - if 'false', `noVotes` will be counted.\r\n    /// @param v The recovery byte of the signature.\r\n    /// @param r Half of the ECDSA signature pair.\r\n    /// @param s Half of the ECDSA signature pair.\r\n    function submitVoteWithSig(\r\n        uint proposal, \r\n        bool approved, \r\n        uint8 v, \r\n        bytes32 r, \r\n        bytes32 s\r\n    ) external nonReentrant {\r\n        Proposal storage prop = proposals[proposal]; /*alias proposal storage pointers*/\r\n        \r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), block.chainid, address(this))); /*calculate EIP-712 domain hash*/\r\n        bytes32 structHash = keccak256(abi.encode(VOTE_TYPEHASH, proposal, approved)); /*calculate EIP-712 struct hash*/\r\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash)); /*calculate EIP-712 digest for signature*/\r\n        address signatory = ecrecover(digest, v, r, s); /*recover signer from hash data*/\r\n        \r\n        require(signatory != address(0),'!signatory'); /*check signer is not null*/\r\n        \r\n        uint96 balance = getPriorVotes(signatory, prop.votingStarts); /*fetch & gas-optimize voting weight at proposal creation time*/\r\n        \r\n        require(prop.votingEnds >= block.timestamp,'ended'); /*check voting period has not ended*/\r\n        \r\n        unchecked {\r\n            if (approved) { /*if `approved`, cast delegated balance `yesVotes` to proposal*/\r\n                prop.yesVotes += balance; members[signatory].highestIndexYesVote = proposal;\r\n            } else { /*otherwise, cast delegated balance `noVotes` to proposal*/\r\n                prop.noVotes += balance;\r\n            }\r\n        }\r\n        \r\n        emit SubmitVote(signatory, balance, proposal, approved); /*emit event reflecting vote*/\r\n    }\r\n        \r\n    // ********************\r\n    // PROCESSING FUNCTIONS\r\n    // ********************\r\n    /// @notice Process `proposal` & execute internal functions based on `flag`[#].\r\n    /// @param proposal Number of proposal in `proposals` mapping to process for execution.\r\n    function processProposal(uint proposal) external nonReentrant {\r\n        Proposal storage prop = proposals[proposal]; /*alias `proposal` storage pointers*/\r\n        \r\n        _processingReady(proposal, prop); /*validate `proposal` processing requirements*/\r\n        \r\n        if (prop.yesVotes > prop.noVotes) /*check if `proposal` approved by simple majority of members*/\r\n            proposalsPassed[proposal] = true; /*flag that proposal passed - allows minion-like extensions*/\r\n            if (prop.flags[0]) processActionProposal(prop); /*check `flag`, execute 'action'*/\r\n            else if (prop.flags[1]) processMemberProposal(prop); /*check `flag`, execute 'member'*/\r\n            else if (prop.flags[2]) processPeriodProposal(prop); /*check `flag`, execute 'period'*/\r\n            else processWhitelistProposal(prop); /*otherwise, execute 'whitelist'*/\r\n            \r\n        delete proposals[proposal]; /*delete given proposal struct details for gas refund & the commons*/\r\n        \r\n        emit ProcessProposal(proposal); /*emit event reflecting that given proposal processed*/\r\n    }\r\n    \r\n    /// @notice Internal function to process 'action'[0] proposal.\r\n    function processActionProposal(Proposal memory prop) private {\r\n        unchecked {\r\n            for (uint i; i < prop.to.length; i++) \r\n                prop.to[i].call{value:prop.value[i]} /*pass ETH value(s), if any*/\r\n                (prop.data[i]); /*execute low-level call(s)*/\r\n        }\r\n    }\r\n    \r\n    /// @notice Internal function to process 'member'[1] proposal.\r\n    function processMemberProposal(Proposal memory prop) private {\r\n        unchecked {\r\n            for (uint i; i < prop.to.length; i++) {\r\n                if (prop.data[i].length == 0) {\r\n                    _mintShares(prop.to[i], prop.value[i]); /*grant `to` `value` `shares`*/\r\n                } else {\r\n                    uint96 removedBalance = uint96(balanceOf[prop.to[i]]); /*gas-optimize variable*/\r\n                    _burnShares(prop.to[i], removedBalance); /*burn all of `to` `shares` & convert into `loot`*/\r\n                    _mintLoot(prop.to[i], removedBalance); /*mint equivalent `loot`*/\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// @notice Internal function to process 'period'[2] proposal - state updates are broken up for security.\r\n    function processPeriodProposal(Proposal memory prop) private {\r\n        uint length = prop.value.length;\r\n        \r\n        if (length == 1) {\r\n            if (prop.value[0] != 0) minVotingPeriod = uint32(prop.value[0]); /*if positive, reset min. voting period to first `value`*/ \r\n        } else if (length == 2) {\r\n            if (prop.value[1] != 0) maxVotingPeriod = uint32(prop.value[1]); /*if positive, reset max. voting period to second `value`*/\r\n        } else if (length == 3) {\r\n            if (prop.value[2] != 0) gracePeriod = uint32(prop.value[2]); /*if positive, reset grace period to third `value`*/\r\n        } else if (length == 4) {\r\n            prop.value[3] == 0 ? lootPaused = false : lootPaused = true; /*if positive, pause `loot` transfers on fourth `value`*/\r\n        } else if (length == 5) {\r\n            prop.value[4] == 0 ? sharesPaused = false : sharesPaused = true; /*if positive, pause `shares` transfers on fifth `value`*/\r\n        }\r\n    }  \r\n        \r\n    /// @notice Internal function to process 'whitelist'[3] proposal - toggles included for security.\r\n    function processWhitelistProposal(Proposal memory prop) private {\r\n        unchecked {\r\n            for (uint i; i < prop.to.length; i++) {\r\n                if (prop.value[i] == 0 && prop.data[i].length == 0) { /*if `value` & `data` are null, approve `shamans`*/\r\n                    shamans[prop.to[i]] = true; /*add account(s) to `shamans` extensions*/\r\n                } else if (prop.value[i] == 0 && prop.data[i].length != 0) { /*if `value` is null & `data` is populated, remove `shamans`*/\r\n                    shamans[prop.to[i]] = false; /*remove account(s) from `shamans` extensions*/\r\n                } else if (prop.value[i] != 0 && prop.data[i].length == 0) { /*if `value` is positive & `data` is null, add `guildTokens`*/\r\n                    if (guildTokens.length != MAX_GUILD_TOKEN_COUNT) guildTokens.push(prop.to[i]); /*push account to `guildTokens` array if within 'MAX'*/\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /*******************\r\n    GUILD MGMT FUNCTIONS\r\n    *******************/\r\n    /// @notice Approve `to` to transfer up to `amount`.\r\n    /// @return success Whether or not the approval succeeded.\r\n    function approve(address to, uint amount) external returns (bool success) {\r\n        allowance[msg.sender][to] = amount; /*adjust `allowance`*/\r\n        \r\n        emit Approval(msg.sender, to, amount); /*emit event reflecting approval*/\r\n        \r\n        success = true; /*confirm approval with ERC-20 accounting*/\r\n    }\r\n    \r\n    /// @notice Delegate votes from user to `delegatee`.\r\n    /// @param delegatee The address to delegate votes to.\r\n    function delegate(address delegatee) external {\r\n        _delegate(msg.sender, delegatee);\r\n    }\r\n    \r\n    /// @notice Delegates votes from `signatory` to `delegatee` with EIP-712 signature.\r\n    /// @param delegatee The address to delegate 'votes' to.\r\n    /// @param nonce The contract state required to match the signature.\r\n    /// @param deadline The time at which to expire the signature.\r\n    /// @param v The recovery byte of the signature.\r\n    /// @param r Half of the ECDSA signature pair.\r\n    /// @param s Half of the ECDSA signature pair.\r\n    function delegateBySig(\r\n        address delegatee, \r\n        uint nonce, \r\n        uint deadline, \r\n        uint8 v, \r\n        bytes32 r, \r\n        bytes32 s\r\n    ) external {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), block.chainid, address(this))); /*calculate EIP-712 domain hash*/\r\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, deadline)); /*calculate EIP-712 struct hash*/\r\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash)); /*calculate EIP-712 digest for signature*/\r\n        address signatory = ecrecover(digest, v, r, s); /*recover signer from hash data*/\r\n            \r\n        require(signatory != address(0),'!signatory'); /*check signer is not null*/\r\n        unchecked {\r\n            require(nonce == nonces[signatory]++,'!nonce'); /*check given `nonce` is next in `nonces`*/\r\n        }\r\n        require(block.timestamp <= deadline,'expired'); /*check signature is not expired*/\r\n            \r\n        _delegate(signatory, delegatee); /*execute delegation*/\r\n    }\r\n\r\n    /// @notice Triggers an approval from `owner` to `spender` with EIP-712 signature.\r\n    /// @param owner The address to approve from.\r\n    /// @param spender The address to be approved.\r\n    /// @param amount The number of `shares` tokens that are approved (2^256-1 means infinite).\r\n    /// @param deadline The time at which to expire the signature.\r\n    /// @param v The recovery byte of the signature.\r\n    /// @param r Half of the ECDSA signature pair.\r\n    /// @param s Half of the ECDSA signature pair.\r\n    function permit(\r\n        address owner, \r\n        address spender, \r\n        uint96 amount, \r\n        uint deadline, \r\n        uint8 v, \r\n        bytes32 r, \r\n        bytes32 s\r\n    ) external {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), block.chainid, address(this))); /*calculate EIP-712 domain hash*/\r\n        \r\n        unchecked {\r\n            bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline)); /*calculate EIP-712 struct hash*/\r\n            bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash)); /*calculate EIP-712 digest for signature*/\r\n            address signatory = ecrecover(digest, v, r, s); /*recover signer from hash data*/\r\n            require(signatory != address(0),'!signatory'); /*check signer is not null*/\r\n            require(signatory == owner,'!authorized'); /*check signer is `owner`*/\r\n        }\r\n        \r\n        require(block.timestamp <= deadline,'expired'); /*check signature is not expired*/\r\n        \r\n        allowance[owner][spender] = amount; /*adjust `allowance`*/\r\n        \r\n        emit Approval(owner, spender, amount); /*emit event reflecting approval*/\r\n    }\r\n    \r\n    /// @notice Transfer `amount` tokens from user to `to`.\r\n    /// @param to The address of destination account.\r\n    /// @param amount The number of `shares` tokens to transfer.\r\n    /// @return success Whether or not the transfer succeeded.\r\n    function transfer(address to, uint96 amount) external returns (bool success) {\r\n        require(!sharesPaused,'!transferable');\r\n        \r\n        balanceOf[msg.sender] -= amount;\r\n        \r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n        \r\n        _moveDelegates(delegates[msg.sender], delegates[to], amount);\r\n        \r\n        emit Transfer(msg.sender, to, amount);\r\n        \r\n        success = true;\r\n    }\r\n        \r\n    /// @notice Transfer `amount` tokens from `from` to `to`.\r\n    /// @param from The address of the source account.\r\n    /// @param to The address of the destination account.\r\n    /// @param amount The number of `shares` tokens to transfer.\r\n    /// @return success Whether or not the transfer succeeded.\r\n    function transferFrom(address from, address to, uint96 amount) external returns (bool success) {\r\n        require(!sharesPaused,'!transferable');\r\n        \r\n        if (allowance[from][msg.sender] != type(uint).max) {\r\n            allowance[from][msg.sender] -= amount;\r\n        }\r\n        \r\n        balanceOf[from] -= amount;\r\n        \r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n        \r\n        _moveDelegates(delegates[from], delegates[to], amount);\r\n        \r\n        emit Transfer(from, to, amount);\r\n        \r\n        success = true;\r\n    }\r\n    \r\n    /// @notice Transfer `amount` `loot` from user to `to`.\r\n    /// @param to The address of destination account.\r\n    /// @param amount The sum of loot to transfer.\r\n    function transferLoot(address to, uint96 amount) external {\r\n        require(!lootPaused,'!transferable');\r\n        \r\n        members[msg.sender].loot -= amount;\r\n        \r\n        unchecked {\r\n            members[to].loot += amount;\r\n        }\r\n        \r\n        emit TransferLoot(msg.sender, to, amount);\r\n    }\r\n\r\n    /// @notice Process member burn of `shares` and/or `loot` to claim 'fair share' of `guildTokens`.\r\n    /// @param to Account that receives 'fair share'.\r\n    /// @param lootToBurn Baal pure economic weight to burn.\r\n    /// @param sharesToBurn Baal voting weight to burn.\r\n    function ragequit(address to, uint96 lootToBurn, uint96 sharesToBurn) external nonReentrant {\r\n        require(proposals[members[msg.sender].highestIndexYesVote].votingEnds == 0,'processed'); /*check highest index proposal member approved has processed*/\r\n        \r\n        for (uint i; i < guildTokens.length; i++) {\r\n            (,bytes memory balanceData) = guildTokens[i].staticcall(abi.encodeWithSelector(0x70a08231, address(this))); /*get Baal token balances - 'balanceOf(address)'*/\r\n            uint balance = abi.decode(balanceData, (uint)); /*decode Baal token balances for calculation*/\r\n            \r\n            uint amountToRagequit = ((lootToBurn + sharesToBurn) * balance) / (totalSupply + totalLoot); /*calculate 'fair shair' claims*/\r\n            \r\n            if (amountToRagequit != 0) { /*gas optimization to allow higher maximum token limit*/\r\n                _safeTransfer(guildTokens[i], to, amountToRagequit); /*execute 'safe' token transfer*/\r\n            }\r\n        }\r\n        \r\n        if (lootToBurn != 0) { /*gas optimization*/ \r\n            _burnLoot(msg.sender, lootToBurn); /*subtract `loot` from user account & Baal totals*/\r\n        }\r\n        \r\n        if (sharesToBurn != 0) { /*gas optimization*/ \r\n            _burnShares(msg.sender, sharesToBurn);  /*subtract `shares` from user account & Baal totals with erc20 accounting*/\r\n        }\r\n        \r\n        emit Ragequit(msg.sender, to, lootToBurn, sharesToBurn); /*event reflects claims made against Baal*/\r\n    }\r\n\r\n    /***************\r\n    GETTER FUNCTIONS\r\n    ***************/\r\n    /// @notice Returns the current delegated `vote` balance for `account`.\r\n    /// @param account The user to check delegated `votes` for.\r\n    /// @return votes Current `votes` delegated to `account`.\r\n    function getCurrentVotes(address account) external view returns (uint96 votes) {\r\n        uint nCheckpoints = numCheckpoints[account];\r\n        unchecked { votes = nCheckpoints != 0 ? checkpoints[account][nCheckpoints - 1].votes : 0; }\r\n    }\r\n    \r\n    /// @notice Returns the prior number of `votes` for `account` as of `timeStamp`.\r\n    /// @param account The user to check `votes` for.\r\n    /// @param timeStamp The unix time to check `votes` for.\r\n    /// @return votes Prior `votes` delegated to `account`.\r\n    function getPriorVotes(address account, uint timeStamp) public view returns (uint96 votes) {\r\n        require(timeStamp < block.timestamp,'!determined');\r\n        \r\n        uint nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) return 0;\r\n        \r\n        unchecked {\r\n            if (checkpoints[account][nCheckpoints - 1].fromTimeStamp <= timeStamp)\r\n                return checkpoints[account][nCheckpoints - 1].votes; \r\n            if (checkpoints[account][0].fromTimeStamp > timeStamp) return 0;\r\n            uint lower = 0; \r\n            uint upper = nCheckpoints - 1;\r\n            while (upper > lower) {\r\n                uint center = upper - (upper - lower) / 2;\r\n                Checkpoint memory cp = checkpoints[account][center];\r\n                if (cp.fromTimeStamp == timeStamp) return cp.votes; \r\n                else if (cp.fromTimeStamp < timeStamp) lower = center; \r\n                else upper = center - 1;\r\n            }\r\n            votes = checkpoints[account][lower].votes;\r\n        }\r\n    }\r\n    \r\n    /// @notice Returns array list of approved `guildTokens` in Baal for {ragequit}.\r\n    /// @return tokens ERC-20s approved for {ragequit}.\r\n    function getGuildTokens() external view returns (address[] memory tokens) {\r\n        tokens = guildTokens;\r\n    }\r\n\r\n    /// @notice Returns `flags` for given Baal `proposal` describing type ('action'[0], 'member'[1], 'period'[2], 'whitelist'[3]).\r\n    /// @param proposal The index to check `flags` for.\r\n    /// @return flags The boolean flags describing `proposal` type.\r\n    function getProposalFlags(uint proposal) external view returns (bool[4] memory flags) {\r\n        flags = proposals[proposal].flags;\r\n    }\r\n\r\n    /***************\r\n    HELPER FUNCTIONS\r\n    ***************/\r\n    /// @notice Allows batched calls to Baal.\r\n    /// @param data An array of payloads for each call.\r\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        unchecked {\r\n            for (uint256 i = 0; i < data.length; i++) {\r\n                (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n                if (!success) {\r\n                    if (result.length < 68) revert();\r\n                    assembly { result := add(result, 0x04) }\r\n                    revert(abi.decode(result, (string)));\r\n                }\r\n                results[i] = result;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Returns confirmation for 'safe' ERC-721 (NFT) transfers to Baal.\r\n    function onERC721Received(address, address, uint, bytes calldata) external pure returns (bytes4 sig) {\r\n        sig = 0x150b7a02; /*'onERC721Received(address,address,uint,bytes)'*/\r\n    }\r\n    \r\n    /// @notice Returns confirmation for 'safe' ERC-1155 transfers to Baal.\r\n    function onERC1155Received(address, address, uint, uint, bytes calldata) external pure returns (bytes4 sig) {\r\n        sig = 0xf23a6e61; /*'onERC1155Received(address,address,uint,uint,bytes)'*/\r\n    }\r\n    \r\n    /// @notice Returns confirmation for 'safe' batch ERC-1155 transfers to Baal.\r\n    function onERC1155BatchReceived(address, address, uint[] calldata, uint[] calldata, bytes calldata) external pure returns (bytes4 sig) {\r\n        sig = 0xbc197c81; /*'onERC1155BatchReceived(address,address,uint[],uint[],bytes)'*/\r\n    }\r\n    \r\n    /// @notice Deposits ETH sent to Baal.\r\n    receive() external payable {}\r\n\r\n    /// @notice Delegates Baal voting weight.\r\n    function _delegate(address delegator, address delegatee) private {\r\n        address currentDelegate = delegates[delegator];\r\n        \r\n        delegates[delegator] = delegatee;\r\n        \r\n        _moveDelegates(currentDelegate, delegatee, uint96(balanceOf[delegator]));\r\n        \r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n    }\r\n    \r\n    /// @notice Elaborates delegate update - cf., 'Compound Governance'.\r\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) private {\r\n        unchecked {\r\n            if (srcRep != dstRep && amount != 0) {\r\n                if (srcRep != address(0)) {\r\n                    uint srcRepNum = numCheckpoints[srcRep];\r\n                    uint96 srcRepOld = srcRepNum != 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                    uint96 srcRepNew = srcRepOld - amount;\r\n                    _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n                }\r\n            \r\n                if (dstRep != address(0)) {\r\n                    uint dstRepNum = numCheckpoints[dstRep];\r\n                    uint96 dstRepOld = dstRepNum != 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                    uint96 dstRepNew = dstRepOld + amount;\r\n                    _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// @notice Elaborates delegate update - cf., 'Compound Governance'.\r\n    function _writeCheckpoint(address delegatee, uint nCheckpoints, uint96 oldVotes, uint96 newVotes) private {\r\n        uint32 timeStamp = uint32(block.timestamp);\r\n        \r\n        unchecked {\r\n            if (nCheckpoints != 0 && checkpoints[delegatee][nCheckpoints - 1].fromTimeStamp == timeStamp) {\r\n                checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n            } else {\r\n                checkpoints[delegatee][nCheckpoints] = Checkpoint(timeStamp, newVotes);\r\n                numCheckpoints[delegatee] = nCheckpoints + 1;\r\n            }\r\n        }\r\n        \r\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n    \r\n    /// @notice Burn function for Baal `loot`.\r\n    function _burnLoot(address from, uint96 loot) private {\r\n        members[from].loot -= loot; /*subtract `loot` for `from` account*/\r\n        \r\n        unchecked {\r\n            totalLoot -= loot; /*subtract from total Baal `loot`*/\r\n        }\r\n        \r\n        emit TransferLoot(from, address(0), loot); /*emit event reflecting burn of `loot`*/\r\n    }\r\n    \r\n    /// @notice Burn function for Baal `shares`.\r\n    function _burnShares(address from, uint96 shares) private {\r\n        balanceOf[from] -= shares; /*subtract `shares` for `from` account*/\r\n        \r\n        unchecked {\r\n            totalSupply -= shares; /*subtract from total Baal `shares`*/\r\n        }\r\n        \r\n        _moveDelegates(delegates[from], address(0), shares); /*update delegation*/\r\n        \r\n        emit Transfer(from, address(0), shares); /*emit event reflecting burn of `shares` with erc20 accounting*/\r\n    }\r\n    \r\n    /// @notice Minting function for Baal `loot`.\r\n    function _mintLoot(address to, uint96 loot) private {\r\n        unchecked {\r\n            if (totalSupply + loot <= type(uint96).max / 2) {\r\n                members[to].loot += loot; /*add `loot` for `to` account*/\r\n        \r\n                totalLoot += loot; /*add to total Baal `loot`*/\r\n            \r\n                emit TransferLoot(address(0), to, loot); /*emit event reflecting mint of `loot`*/\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// @notice Minting function for Baal `shares`.\r\n    function _mintShares(address to, uint96 shares) private {\r\n        unchecked {\r\n            if (totalSupply + shares <= type(uint96).max / 2) {\r\n                balanceOf[to] += shares; /*add `shares` for `to` account*/\r\n        \r\n                totalSupply += shares; /*add to total Baal `shares`*/\r\n            \r\n                _moveDelegates(address(0), delegates[to], shares); /*update delegation*/\r\n        \r\n                emit Transfer(address(0), to, shares); /*emit event reflecting mint of `shares` with erc20 accounting*/\r\n            }\r\n        }\r\n    }\r\n \r\n    /// @notice Check to validate proposal processing requirements. \r\n    function _processingReady(uint proposal, Proposal memory prop) private view returns (bool ready) {\r\n        unchecked {\r\n            require(proposal <= proposalCount,'!exist'); /*check proposal exists*/\r\n            require(proposals[proposal - 1].votingEnds == 0,'prev!processed'); /*check previous proposal has processed by deletion*/\r\n            require(proposals[proposal].votingEnds != 0,'processed'); /*check given proposal has been sponsored & not yet processed by deletion*/\r\n            if (singleSummoner) return true; /*if single member, process early*/\r\n            if (prop.yesVotes > totalSupply / 2) return true; /*process early if majority member support*/\r\n            require(prop.votingEnds + gracePeriod <= block.timestamp,'!ended'); /*check voting period has ended*/\r\n            ready = true; /*otherwise, process if voting period done*/\r\n        }\r\n    }\r\n    \r\n    /// @notice Provides 'safe' {transfer} for tokens that do not consistently return 'true/false'.\r\n    function _safeTransfer(address token, address to, uint amount) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, amount)); /*'transfer(address,uint)'*/\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))),'transfer failed'); /*checks success & allows non-conforming transfers*/\r\n    }\r\n}"
    }
  }
}