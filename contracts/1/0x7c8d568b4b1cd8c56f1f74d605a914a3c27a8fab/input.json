{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"NyanVoting.sol":{"content":"// File: node_modules\\@openzeppelin\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: node_modules\\@openzeppelin\\contracts\\math\\SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: node_modules\\@openzeppelin\\contracts\\utils\\Address.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\SafeERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\NyanFund\\ERC20Interface.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\ninterface ERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts\\NyanFund\\NyanVoting.sol\r\n\r\npragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\ninterface NFund {\r\n    function approveSpendERC20(address, uint256) external;\r\n    \r\n    function approveSpendETH(address, uint256) external;\r\n    \r\n    function newVotingRound() external;\r\n    \r\n    function setVotingAddress(address) external;\r\n    \r\n    function setConnectorAddress(address) external;\r\n    \r\n    function setNewFundAddress(address) external;\r\n    \r\n    function setNyanAddress(address) external;\r\n    \r\n    function setCatnipAddress(address) external;\r\n    \r\n    function setDNyanAddress(address) external;\r\n    \r\n    function setBalanceLimit(uint256) external;\r\n    \r\n    function sendToNewContract(address) external;\r\n}\r\n\r\ninterface NVoting {\r\n    function setConnector(address) external;\r\n    \r\n    function setFundAddress(address) external;\r\n    \r\n    function setRewardsContract(address) external;\r\n    \r\n    function setIsRewardingCatnip(bool) external;\r\n    \r\n    function setVotingPeriodBlockLength(uint256) external;\r\n    \r\n    function setNyanAddress(address) external;\r\n    \r\n    function setCatnipAddress(address) external;\r\n    \r\n    function setDNyanAddress(address) external;\r\n    \r\n    function distributeFunds(address, uint256) external;\r\n    \r\n    function burnCatnip() external;\r\n}\r\n\r\ninterface NConnector {\r\n    function executeBid(\r\n        string calldata, \r\n        string calldata, \r\n        address[] calldata , \r\n        uint256[] calldata, \r\n        string[] calldata, \r\n        bytes[] calldata) external;\r\n}\r\n\r\ninterface NyanV2 {\r\n    function swapNyanV1(uint256) external;\r\n    \r\n    function stakeNyanV2LP(uint256) external;\r\n    \r\n    function unstakeNyanV2LP(uint256) external;\r\n    \r\n    function stakeDNyanV2LP(uint256) external;\r\n    \r\n    function unstakeDNyanV2LP(uint256) external;\r\n    \r\n    function addNyanAndETH(uint256) payable external;\r\n    \r\n    function claimETHLP() external;\r\n    \r\n    function initializeV2ETHPool() external;\r\n\r\n}\r\n\r\n\r\n\r\ncontract Proxiable {\r\n    // Code position in storage is keccak256(\"PROXIABLE\") = \"0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\"\r\n\r\n    function updateCodeAddress(address newAddress) internal {\r\n        require(\r\n            bytes32(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7) == Proxiable(newAddress).proxiableUUID(),\r\n            \"Not compatible\"\r\n        );\r\n        assembly { // solium-disable-line\r\n            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, newAddress)\r\n        }\r\n    }\r\n    function proxiableUUID() public pure returns (bytes32) {\r\n        return 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\r\n    }\r\n}\r\n\r\ncontract LibraryLockDataLayout {\r\n  bool public initialized = false;\r\n}\r\n\r\ncontract LibraryLock is LibraryLockDataLayout {\r\n    // Ensures no one can manipulate the Logic Contract once it is deployed.\r\n    // PARITY WALLET HACK PREVENTION\r\n\r\n    modifier delegatedOnly() {\r\n        require(initialized == true, \"The library is locked. No direct 'call' is allowed\");\r\n        _;\r\n    }\r\n    function initialize() internal {\r\n        initialized = true;\r\n    }\r\n}\r\n\r\ncontract VotingDataLayout is LibraryLock {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    \r\n    address public owner;\r\n    \r\n    uint256 public currentVotingStartBlock;\r\n    uint256 public currentVotingEndBlock;\r\n    bool public isVotingPeriod;\r\n    \r\n    uint256 public votingPeriodBlockLength = 6500;\r\n    uint256 public voteDiv;\r\n    \r\n    struct bid {\r\n        string bidId;\r\n        address bidder;\r\n        string functionCode;\r\n        string functionName;\r\n        uint256 votes;\r\n        address[] addresses;\r\n        uint256[] integers;\r\n        string[] strings;\r\n        bytes[] bytesArr;\r\n        string[] chain;\r\n        uint256 votingRound;\r\n    }\r\n    \r\n    mapping(address => bid) public currentBids;\r\n    \r\n    struct bidChain {\r\n        string id;\r\n        string bidId;\r\n        string functionCode;\r\n        string functionName;\r\n        address[] addresses;\r\n        uint256[] integers;\r\n        string[] strings;\r\n        bytes[] bytesArr;\r\n    }\r\n    \r\n    mapping(string => bidChain) public bidChains;\r\n    \r\n    address public topBidAddress;\r\n    uint256 public topBidVotes;\r\n    bool public isTopBid;\r\n    uint256 public requiredVoteCount;\r\n    uint256 public currentVotingRound;\r\n    uint256 public votePropogationBlocks;\r\n    uint256 public lastVotePropogationBlock;\r\n    \r\n    address[] public proposals;\r\n    \r\n    struct voteTracker {\r\n        uint256 defaultVoteCount;\r\n        uint256 lastBlockChecked;\r\n        uint256 votes;\r\n        uint256 votesUsed;\r\n        bool votesInitialized;\r\n    }\r\n    \r\n    mapping(address => voteTracker) public userVoteTracker;\r\n\r\n    uint256 public totalV2LPStaked;\r\n    uint256 public lastDistributionBlock;\r\n    uint256 public currentDistributionEndBlock;\r\n    uint256 public distributionPeriodBuffer = 13000;\r\n    uint256 public distributionPeriodLength = 6500; //measured in blocks\r\n    bool public isDistributing;\r\n    bool public canDistribute;\r\n    bool public isRewardingCatnip;\r\n    \r\n    \r\n    address public currentDistributionAddress;\r\n    uint256 public currentDistributionAmount;\r\n    uint256 public currentDistributionAmountClaimed;\r\n    \r\n    struct distributionClaimed {\r\n        uint256 nyanLocked;\r\n        \r\n    }\r\n    \r\n    mapping(address => distributionClaimed) public claims;\r\n    \r\n    \r\n    address public nyanV2;\r\n    address public nyanV2LP;\r\n    address public catnipV2;\r\n    address public dNyanV2;\r\n    address public nyanV2LPAddress;\r\n    \r\n    address public uniswapRouter;\r\n    \r\n    address public connectorAddress;\r\n    address public fundAddress;\r\n    \r\n    modifier _onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier _onlyNyanV2() {\r\n        require(msg.sender == nyanV2);\r\n        _;\r\n    }\r\n    \r\n    modifier _onlyConnector() {\r\n        require(msg.sender == connectorAddress);\r\n        _;\r\n    }\r\n    \r\n    modifier _onlyFund() {\r\n        require(msg.sender == fundAddress);\r\n        _;\r\n    }\r\n    \r\n    modifier _updateState(address voter) {\r\n        // save return variables\r\n        uint256 currentTotalVotes = userVoteTracker[voter].defaultVoteCount;\r\n        uint256 newTotalVotes;\r\n        uint256 dNyan;\r\n        uint256 rewards;\r\n        uint256 blockChecked;\r\n        uint256 blockStaked;\r\n        (newTotalVotes,dNyan, rewards, blockChecked, blockStaked) = NyanV2Var(nyanV2).userStake(voter);\r\n        userVoteTracker[voter].lastBlockChecked = blockStaked;\r\n        uint256 votesUsed = userVoteTracker[voter].votesUsed;\r\n        \r\n        if (block.number.sub(blockStaked) > 10) {\r\n             if (!userVoteTracker[voter].votesInitialized || block.number.sub(userVoteTracker[voter].lastBlockChecked) > votePropogationBlocks) {\r\n                userVoteTracker[voter].lastBlockChecked = block.number;\r\n                userVoteTracker[voter].votes = newTotalVotes;\r\n            } else {\r\n                if (currentTotalVotes == 0) {\r\n                    userVoteTracker[voter].votes = 0;\r\n                } else {\r\n                    userVoteTracker[voter].votes = currentTotalVotes.sub(votesUsed);\r\n                }\r\n            }\r\n        }\r\n       \r\n        _;\r\n    }\r\n\r\n    mapping(address => bool) public isAdmin;\r\n}\r\n\r\ncontract NyanVoting is Proxiable, VotingDataLayout{\r\n    \r\n    event NewConnector(address indexed connector);\r\n    event logicContractUpdated(address newAddress);\r\n    event IsRewardingCatnip(bool isRewarding);\r\n    event NewVotingPeriodLength(uint256 length, uint256 currentBlock);\r\n    event NewFundingAddress(address indexed fundAddress);\r\n    event NewNyanAddress(address indexed nyanAddress);\r\n    event NewCatnipAddress(address indexed catnipAddress);\r\n    event NewDNyanAddress(address indexed dNyanAddress);\r\n    event NewLPFarmAddress(address indexed nyanLPAddress);\r\n    event SafetyWithdrawalToggled(bool safetyBool);\r\n    event NewBidProposal(address indexed proposer, string bidId, string functionName);\r\n    event NewBidChain(address indexed proposer, string functionName, string bidId, string chainId);\r\n    event NewBidVote(address indexed voter, uint256 votes);\r\n    event VotedNyanWithdrawn(address indexed voter, uint256 nyan);\r\n    event BidExecution(address indexed voter, string bidId);\r\n    event FundsDistribution(address indexed distributedToken, uint256 amount);\r\n    event ClaimDistribution(address indexed claimer, uint256 amountClaimed);\r\n    event WithdrawDistributionNyan(address indexed claimer, uint256 amount);\r\n    event WithdrawDistributionCatnip(address indexed claimer, uint256 amount);\r\n    event CatnipBurn(uint256 catnipBurned);\r\n    \r\n    constructor() public {\r\n       \r\n    }\r\n    \r\n    /** @notice Constructor function for the proxy contract.\r\n      * @param _uniswapRouter  Address of the UniswapV2 contract.\r\n      * @param _nyanV2  Address of the Nyan-2 contract.\r\n      * @param _nyanV2LP  Address of the Nyan-2 LP token contract.\r\n      * @param _voteDiv  Catnip fee per vote.\r\n      */\r\n    function votingConstructor(address _uniswapRouter, address _nyanV2, address _nyanV2LP, uint256 _requiredVoteCount, uint256 _voteDiv) public {\r\n        require(!initialized, \"The contract has been initialized\");\r\n        owner = msg.sender;\r\n        uniswapRouter = _uniswapRouter;\r\n        currentVotingStartBlock = block.number;\r\n        currentVotingEndBlock = block.number.add(votingPeriodBlockLength);\r\n        nyanV2 = _nyanV2;\r\n        nyanV2LP = _nyanV2LP;\r\n        isDistributing = false;\r\n        canDistribute = true;\r\n        voteDiv = _voteDiv;\r\n        votePropogationBlocks = 6500;\r\n        lastVotePropogationBlock = block.number;\r\n        requiredVoteCount = _requiredVoteCount;\r\n        initialized = true;\r\n    }\r\n    \r\n    /** @notice Updates the logic contract.\r\n      * @param newCode  Address of the new logic contract.\r\n      */\r\n    function updateCode(address newCode) public _onlyOwner delegatedOnly  {\r\n        updateCodeAddress(newCode);\r\n        \r\n        emit logicContractUpdated(newCode);\r\n    }\r\n    \r\n    /** @notice Updates the contract owner.\r\n      * @param _owner Address of the new contract owner.\r\n      */\r\n    function setOwner(address _owner) public _onlyOwner  delegatedOnly {\r\n        owner = _owner;\r\n\r\n    }\r\n    \r\n    /** @notice Updates the connector address.\r\n      * @param _connector Address of the new connector address.\r\n      */\r\n    function setConnector(address _connector) public _onlyOwner  delegatedOnly {\r\n        connectorAddress = _connector;\r\n        \r\n        emit NewConnector(_connector);\r\n    }\r\n    \r\n    /** @notice Updates the funds address.\r\n      * @param _fund Address of the new logic contract.\r\n      */\r\n    function setFundAddress(address _fund) public _onlyOwner  delegatedOnly {\r\n        fundAddress = _fund;\r\n        \r\n        emit NewFundingAddress(fundAddress);\r\n    }\r\n    \r\n    /** @notice Updates the voting period block length.\r\n      * @param _blocks Voting period length in blocks.\r\n      */\r\n    function setVotingPeriodBlockLength(uint256 _blocks) public _onlyOwner  delegatedOnly {\r\n        votingPeriodBlockLength = _blocks;\r\n        \r\n        emit NewVotingPeriodLength(votingPeriodBlockLength, block.number);\r\n    }\r\n    \r\n    // /** @notice Updates the NyanV2 address.\r\n    //   * @param _addr Voting period length in blocks.\r\n    //   */\r\n    // function setNyanV2Address(address _addr) public _onlyOwner delegatedOnly {\r\n    //     nyanV2 = _addr;\r\n        \r\n    //     emit NewNyanAddress(nyanV2);\r\n    // }\r\n    \r\n    \r\n    /** @notice Updates the catnip fee divider.\r\n      * @param _val Number to divide votes by.\r\n      */\r\n    function setVoteDiv(uint256 _val) public _onlyOwner delegatedOnly _updateState(msg.sender) {\r\n        voteDiv = _val;\r\n    }\r\n    \r\n    /** @notice Triggers when a user stakes NyanV2 LP tokens.\r\n      * @param totalV2LPStaked Number of LP tokens an address has staked.\r\n      * @param voter Address of the staker\r\n      */\r\n     function nyanV2LPStaked(uint256 totalV2LPStaked, address voter) public _onlyNyanV2 delegatedOnly _updateState(voter) {\r\n        userVoteTracker[voter].defaultVoteCount = totalV2LPStaked;\r\n        userVoteTracker[voter].lastBlockChecked = block.number;\r\n    }\r\n    \r\n    /** @notice Triggers when a user unstakes NyanV2 LP tokens.\r\n      * @param totalV2LPStaked Number of LP tokens an address has staked.\r\n      * @param voter Address of the staker\r\n      */\r\n    function nyanV2LPUnstaked(uint256 totalV2LPStaked, address voter) public _onlyNyanV2 delegatedOnly _updateState(msg.sender) {\r\n        userVoteTracker[voter].defaultVoteCount = totalV2LPStaked;\r\n    }\r\n    \r\n    /** @notice Allows anyone to propose a bid.\r\n      * @param bidId address of the bidder.\r\n      * @param _functionCode Code of the interface to use.\r\n      * @param _functionName Name of the function in the interface to use.\r\n      * @param _addresses Array of addresses to use as params.\r\n      * @param _integers Array of integers to use as params.\r\n      * @param _strings Array of strings to use as params.\r\n      * @param _bytesArr Array of bytes to use as params.\r\n      */\r\n    function proposeBid(\r\n        string memory bidId, \r\n        string memory _functionCode, \r\n        string memory _functionName,\r\n        address[] memory _addresses,\r\n        uint256[] memory _integers, \r\n        string[] memory _strings,\r\n        bytes[] memory _bytesArr\r\n        ) public  {\r\n            // require(isVotingPeriod, \"Voting period has not started.\");\r\n            // require(currentVotingEndBlock >= block.number, \"Voting period has ended.\");\r\n            \r\n            \r\n            //check bidId\r\n            currentBids[msg.sender].bidId = bidId;\r\n            currentBids[msg.sender].bidder = msg.sender;\r\n            currentBids[msg.sender].functionCode = _functionCode;\r\n            currentBids[msg.sender].functionName = _functionName;\r\n            currentBids[msg.sender].addresses = _addresses;\r\n            currentBids[msg.sender].integers = _integers;\r\n            currentBids[msg.sender].strings = _strings;\r\n            currentBids[msg.sender].bytesArr = _bytesArr;\r\n            \r\n            if (currentBids[msg.sender].votingRound < currentVotingRound) {\r\n                delete currentBids[msg.sender].chain;\r\n            }\r\n            currentBids[msg.sender].votingRound = currentVotingRound;\r\n            currentBids[msg.sender].votes = 0;\r\n            \r\n            bool alreadyExists = false;\r\n            for (uint256 i = 0; i < proposals.length; i++) {\r\n                if (proposals[i] == msg.sender) {\r\n                    alreadyExists = true;\r\n                }\r\n            }\r\n            \r\n            if (!alreadyExists) {\r\n                proposals.push(msg.sender);\r\n            }\r\n            \r\n            emit NewBidProposal(msg.sender, bidId, _functionName);\r\n    }\r\n    \r\n    \r\n    /** @notice Allows anyone to propose a bid.\r\n      * @param id Unique string ID for the chain bid.\r\n      * @param bidId address of the bidder.\r\n      * @param _functionCode Code of the interface to use.\r\n      * @param _functionName Name of the function in the interface to use.\r\n      * @param _addresses Array of addresses to use as params.\r\n      * @param _integers Array of integers to use as params.\r\n      * @param _strings Array of strings to use as params.\r\n      * @param _bytesArr Array of bytes to use as params.\r\n      */\r\n    function addChainBid(\r\n        string memory id, \r\n        string memory bidId, \r\n        string memory _functionCode, \r\n        string memory _functionName, \r\n        address[] memory _addresses, \r\n        uint256[] memory _integers, \r\n        string[] memory _strings, \r\n        bytes[] memory _bytesArr) \r\n        public  delegatedOnly {\r\n            //create id internally in the future\r\n            string memory userBid = currentBids[msg.sender].bidId;\r\n            require(keccak256(bytes(userBid)) == keccak256(bytes(bidId)), \"This is not your bid\");\r\n            \r\n            //verify this\r\n            if (keccak256(bytes(bidChains[id].id)) == keccak256(bytes(id))) {\r\n                require(keccak256(bytes(currentBids[msg.sender].bidId)) == keccak256(bytes(bidChains[id].bidId)));\r\n            }\r\n            \r\n            \r\n            bidChains[id].id = id;\r\n            bidChains[id].bidId = bidId;\r\n            bidChains[id].functionCode = _functionCode;\r\n            bidChains[id].functionName = _functionName;\r\n            bidChains[id].addresses = _addresses;\r\n            bidChains[id].integers = _integers;\r\n            bidChains[id].strings = _strings;\r\n            bidChains[id].bytesArr = _bytesArr;\r\n            \r\n            bool bidExists = false;\r\n            for (uint256 i = 0; i < currentBids[msg.sender].chain.length; i++) {\r\n                if (keccak256(bytes(currentBids[msg.sender].chain[i])) == keccak256(bytes(id))) {\r\n                    bidExists = true;\r\n                }\r\n            }\r\n            if (!bidExists) {\r\n                currentBids[msg.sender].chain.push(id);\r\n            }\r\n            currentBids[msg.sender].votes = 0;\r\n            \r\n            emit NewBidChain(msg.sender, _functionName, bidId, id);\r\n    }\r\n    \r\n    /** @notice Return array of current proposal addresses.\r\n      */\r\n    function getProposals() view public returns(address[] memory) {\r\n        return proposals;\r\n    }\r\n    \r\n    /** @notice Vote for an individual proposal.\r\n      * @param _bidAddr Address of the proposal to vote for.\r\n      * @param _votes Number of votes to apply to proposal.\r\n      */\r\n    function voteForBid(address _bidAddr, uint256 _votes) public _updateState(msg.sender) delegatedOnly {\r\n        require(_votes <= userVoteTracker[msg.sender].votes, \"Insufficient amount of votes\");\r\n        IERC20(catnipV2).safeTransferFrom(msg.sender, address(this), determineCatnipCost(_votes));\r\n        \r\n        currentBids[_bidAddr].votes = currentBids[_bidAddr].votes.add(_votes);\r\n        \r\n        if ((currentBids[_bidAddr].votes > topBidVotes) && (topBidAddress != _bidAddr)) {\r\n            topBidAddress = _bidAddr;\r\n            topBidVotes = currentBids[_bidAddr].votes;\r\n            isTopBid = true;\r\n        }\r\n        \r\n        emit NewBidVote(msg.sender, _votes);\r\n        \r\n    }\r\n    \r\n    /** @notice Returns proposal details of a specific proposal.\r\n      * @param _address Address of a specific proposal.\r\n      */\r\n    function getBid(address _address) public view returns(\r\n            string memory,\r\n            string memory,\r\n            address[] memory,\r\n            uint256[] memory,\r\n            string[] memory,\r\n            // // bytes[] memory,\r\n            string[] memory,\r\n            uint256\r\n            )\r\n        {\r\n            return (\r\n                  currentBids[_address].functionCode,\r\n                  currentBids[_address].functionName,\r\n                  currentBids[_address].addresses,\r\n                  currentBids[_address].integers,\r\n                  currentBids[_address].strings,\r\n                // //   currentBids[_address].bytesArr,\r\n                  currentBids[_address].chain,\r\n                  currentBids[_address].votes\r\n                );\r\n    }\r\n    \r\n    /** @notice Returns chain details of a specific chain bid.\r\n      * @param id Id of a specific proposal.\r\n      */\r\n    function getChain(string memory id) public view returns(\r\n        string memory, \r\n        string memory,\r\n        string memory,\r\n        address[] memory,\r\n        uint256[] memory,\r\n        string[] memory\r\n        // bytes[] memory\r\n        ) \r\n        {\r\n            return(\r\n                    bidChains[id].id,\r\n                    bidChains[id].functionCode,\r\n                    bidChains[id].functionName,\r\n                    bidChains[id].addresses,\r\n                    bidChains[id].integers,\r\n                    bidChains[id].strings\r\n                    // bidChains[id].bytesArr\r\n                );\r\n    }\r\n    \r\n    /** @notice Returns amount of votes an address has used.\r\n      * @param _address Address of a specific voter.\r\n      */\r\n    function getVotesUsed(address _address) public view returns(uint256) {\r\n        return userVoteTracker[_address].votesUsed;\r\n    }\r\n    \r\n    /** @notice Returns the cost of an amount of votes.\r\n      * @param _votes Number of votes being used.\r\n      */\r\n    function determineCatnipCost(uint256 _votes) view public returns(uint256) {\r\n        return _votes.div(voteDiv);\r\n    } \r\n\r\n    /** @notice Public function that allows anyone to execute the current top bid.\r\n      */\r\n    function executeBid() public _updateState(msg.sender) {   \r\n        if (!isAdmin[msg.sender]) {\r\n            require(currentVotingEndBlock < block.number, \"Voting period is still active.\");\r\n        }\r\n        currentVotingStartBlock = block.number + 10;\r\n        currentVotingEndBlock = currentVotingStartBlock.add(votingPeriodBlockLength);\r\n        NConnector connectorContract = NConnector(connectorAddress);\r\n        NFund fundContract = NFund(fundAddress);\r\n        if (isTopBid) {\r\n            if (!isAdmin[msg.sender]) {\r\n                require(currentBids[topBidAddress].votes >= requiredVoteCount, \"The top bid needs more votes\");\r\n            }\r\n            connectorContract.executeBid(\r\n                    currentBids[topBidAddress].functionCode,\r\n                    currentBids[topBidAddress].functionName,\r\n                    currentBids[topBidAddress].addresses,\r\n                    currentBids[topBidAddress].integers,\r\n                    currentBids[topBidAddress].strings,\r\n                    currentBids[topBidAddress].bytesArr\r\n                );\r\n                                                 \r\n            \r\n            for (uint256 c = 0; c<currentBids[topBidAddress].chain.length; c++) {\r\n                connectorContract.executeBid(\r\n                    bidChains[currentBids[topBidAddress].chain[c]].functionCode,\r\n                                                                    bidChains[currentBids[topBidAddress].chain[c]].functionName,\r\n                                                                    bidChains[currentBids[topBidAddress].chain[c]].addresses,\r\n                                                                    bidChains[currentBids[topBidAddress].chain[c]].integers,\r\n                                                                    bidChains[currentBids[topBidAddress].chain[c]].strings,\r\n                                                                    bidChains[currentBids[topBidAddress].chain[c]].bytesArr);\r\n                \r\n            }\r\n        }\r\n        \r\n        //move voting round stuff to modifier \r\n        currentVotingRound = currentVotingRound.add(1);\r\n        //increase Round in funding contract\r\n        fundContract.newVotingRound();\r\n        delete proposals;\r\n        topBidAddress = address(0);\r\n        topBidVotes = 0;\r\n        isTopBid = false;\r\n        \r\n        //function to send back leftover tokens to fund from connector\r\n        \r\n        \r\n        emit BidExecution(currentBids[topBidAddress].bidder, currentBids[topBidAddress].bidId);                                               \r\n    }\r\n    \r\n    /** @notice Returns proposal details of a specific proposal.\r\n      * @param _addr Address of the token to distribute.\r\n      * @param _amount Amount of the token to distribute.\r\n      */\r\n    function distributeFunds(address _addr, uint256 _amount) public _onlyConnector _updateState(msg.sender) delegatedOnly {\r\n        NFund fundContract = NFund(fundAddress);\r\n        //Check that isDistributing is false\r\n        require(!isDistributing, \"Already in distribution period\");\r\n        //Check that it has been more than 1 day since last distribution\r\n        require((block.number - currentDistributionEndBlock) > distributionPeriodBuffer, \"Too early for distribution\");\r\n        //Set distribution block to current block\r\n        lastDistributionBlock = block.number;\r\n        //Set end block for current distribution\r\n        currentDistributionEndBlock = block.number + distributionPeriodLength;\r\n        \r\n        currentDistributionAmountClaimed = 0;\r\n        //get funds from NyanFund\r\n        fundContract.approveSpendERC20(_addr, _amount);\r\n        //set current distribution amount\r\n        \r\n        emit FundsDistribution(_addr, _amount);\r\n    }\r\n    \r\n    /** @notice Claims distribution share for the message sender.\r\n      */\r\n    function claimDistribution() public _updateState(msg.sender) delegatedOnly {\r\n        require(isDistributing && currentVotingEndBlock>block.number, \"You are not in a distribution period\");\r\n        uint256 nyanV2LPStakedAmount = userVoteTracker[msg.sender].defaultVoteCount;\r\n        uint256 nyanV2LPSupply = ERC20(nyanV2LPAddress).totalSupply();\r\n        \r\n        uint256 numerator = nyanV2LPStakedAmount.mul(currentDistributionAmount);\r\n        require(numerator > nyanV2LPSupply);\r\n        uint256 claimedAmount = numerator.div(nyanV2LPSupply);\r\n        IERC20(currentDistributionAddress).safeTransfer(msg.sender, claimedAmount);\r\n        currentDistributionAmountClaimed = currentDistributionAmountClaimed.add(claimedAmount);\r\n        \r\n        emit ClaimDistribution(msg.sender, claimedAmount);\r\n    }\r\n    \r\n    /** @notice Ends the distribution period.\r\n      */\r\n    function endDistribution() public _onlyConnector _updateState(msg.sender) delegatedOnly {\r\n        isDistributing = false;\r\n        \r\n        \r\n    }\r\n\r\n    function getVotes(address voter) public view returns(uint256) {\r\n        // save return variables\r\n        uint256 currentTotalVotes = userVoteTracker[voter].defaultVoteCount;\r\n        uint256 newTotalVotes;\r\n        uint256 dNyan;\r\n        uint256 rewards;\r\n        uint256 blockChecked;\r\n        uint256 blockStaked;\r\n        (newTotalVotes,dNyan, rewards, blockChecked, blockStaked) = NyanV2Var(nyanV2).userStake(voter);\r\n        uint256 votesUsed = userVoteTracker[voter].votesUsed;\r\n        if (!userVoteTracker[voter].votesInitialized || block.number.sub(userVoteTracker[voter].lastBlockChecked) > votePropogationBlocks) {\r\n            return newTotalVotes;\r\n        } else {\r\n            if (currentTotalVotes == 0) {\r\n                return 0;\r\n            } else {\r\n                return currentTotalVotes.sub(votesUsed);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setAdmin(address admin, bool setting) public _onlyOwner {\r\n        isAdmin[admin] = setting;\r\n    }\r\n\r\n    function setRequiredVotes(uint256 amount) public _onlyOwner {\r\n        requiredVoteCount = amount;\r\n    }\r\n\r\n    function setTopBid(address bidAddress) public _onlyOwner {\r\n        topBidAddress = bidAddress;\r\n    }\r\n    \r\n    \r\n    receive() external payable {\r\n        \r\n    }\r\n    \r\n\r\n}\r\n\r\ncontract NyanV2Var {\r\n    // Track user's staked Nyan LP\r\n    struct stakeTracker {\r\n        uint256 stakedNyanV2LP;\r\n        uint256 stakedDNyanV2LP;\r\n        uint256 nyanV2Rewards;\r\n        uint256 lastBlockChecked;\r\n        uint256 blockStaked;\r\n    }\r\n    mapping(address => stakeTracker) public userStake;\r\n}"}}}