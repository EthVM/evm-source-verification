{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DharmaTradeReserveV17ImplementationStaging.sol":{"content":"pragma solidity 0.5.17; // optimization runs: 200, evm version: istanbul\r\n\r\n\r\ninterface DharmaTradeReserveV17Interface {\r\n  event Trade(\r\n    address account,\r\n    address suppliedAsset,\r\n    address receivedAsset,\r\n    address retainedAsset,\r\n    uint256 suppliedAmount,\r\n    uint256 recievedAmount, // note: typo\r\n    uint256 retainedAmount\r\n  );\r\n  event RoleModified(Role indexed role, address account);\r\n  event RolePaused(Role indexed role);\r\n  event RoleUnpaused(Role indexed role);\r\n  event EtherReceived(address sender, uint256 amount);\r\n  event GasReserveRefilled(uint256 etherAmount);\r\n\r\n  enum Role {            // #\r\n    DEPOSIT_MANAGER,     // 0\r\n    ADJUSTER,            // 1\r\n    WITHDRAWAL_MANAGER,  // 2\r\n    RESERVE_TRADER,      // 3\r\n    PAUSER,              // 4\r\n    GAS_RESERVE_REFILLER // 5\r\n  }\r\n\r\n  enum TradeType {\r\n    ETH_TO_TOKEN,\r\n    TOKEN_TO_ETH,\r\n    TOKEN_TO_TOKEN,\r\n    ETH_TO_TOKEN_WITH_TRANSFER_FEE,\r\n    TOKEN_TO_ETH_WITH_TRANSFER_FEE,\r\n    TOKEN_TO_TOKEN_WITH_TRANSFER_FEE\r\n  }\r\n\r\n  struct RoleStatus {\r\n    address account;\r\n    bool paused;\r\n  }\r\n\r\n  function tradeTokenForToken(\r\n    ERC20Interface tokenProvided,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmount,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external returns (uint256 totalTokensSold);\r\n\r\n  function tradeTokenForTokenSpecifyingFee(\r\n    ERC20Interface tokenProvided,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmount,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external returns (uint256 totalTokensBought);\r\n\r\n  function tradeTokenForTokenWithFeeOnTransfer(\r\n    ERC20Interface tokenProvided,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmount,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 quotedTokenReceivedAmountAfterTransferFee,\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external returns (uint256 totalTokensBought);\r\n\r\n  function tradeTokenForTokenWithFeeOnTransferSpecifyingFee(\r\n    ERC20Interface tokenProvided,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmount,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 quotedTokenReceivedAmountAfterTransferFee,\r\n    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external returns (uint256 totalTokensBought);\r\n\r\n  function tradeTokenForTokenUsingReservesWithFeeOnTransferSpecifyingFee(\r\n    ERC20Interface tokenProvidedFromReserves,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmountFromReserves,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external returns (uint256 totalTokensBought);\r\n\r\n  function tradeTokenForEther(\r\n    ERC20Interface token,\r\n    uint256 tokenAmount,\r\n    uint256 quotedEtherAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherBought);\r\n\r\n  function tradeTokenForEtherWithFeeOnTransfer(\r\n    ERC20Interface token,\r\n    uint256 tokenAmount,\r\n    uint256 quotedEtherAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherBought);\r\n\r\n  function tradeTokenForEtherWithFeeOnTransferSpecifyingFee(\r\n    ERC20Interface token,\r\n    uint256 tokenAmount,\r\n    uint256 quotedEtherAmount,\r\n    uint256 maximumEtherFeeAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherBought);\r\n\r\n  function tradeTokenForEtherUsingReservesWithFeeOnTransferSpecifyingFee(\r\n    ERC20Interface token,\r\n    uint256 tokenAmountFromReserves,\r\n    uint256 quotedEtherAmount,\r\n    uint256 maximumEtherFeeAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherBought);\r\n\r\n  function tradeTokenForEtherSpecifyingFee(\r\n    ERC20Interface token,\r\n    uint256 tokenAmount,\r\n    uint256 quotedEtherAmount,\r\n    uint256 maximumEtherFeeAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherBought);\r\n\r\n  function tradeEtherForToken(\r\n    address token, uint256 quotedTokenAmount, uint256 deadline\r\n  ) external payable returns (uint256 totalEtherSold);\r\n\r\n  function tradeEtherForTokenWithFeeOnTransfer(\r\n    address token,\r\n    uint256 quotedTokenAmount,\r\n    uint256 quotedTokenAmountAfterTransferFee,\r\n    uint256 deadline\r\n  ) external payable returns (uint256 totalTokensBought);\r\n\r\n  function tradeEtherForTokenSpecifyingFee(\r\n    address token,\r\n    uint256 quotedTokenAmount,\r\n    uint256 etherFeeAmount,\r\n    uint256 deadline\r\n  ) external payable returns (uint256 totalTokensBought);\r\n\r\n  function tradeEtherForTokenWithFeeOnTransferSpecifyingFee(\r\n    address token,\r\n    uint256 quotedTokenAmount,\r\n    uint256 quotedTokenAmountAfterTransferFee,\r\n    uint256 etherFeeAmount,\r\n    uint256 deadline\r\n  ) external payable returns (uint256 totalTokensBought);\r\n\r\n  function tradeEtherForTokenUsingEtherizer(\r\n    address token,\r\n    uint256 etherAmount,\r\n    uint256 quotedTokenAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherSold);\r\n\r\n  function tradeTokenForTokenUsingReserves(\r\n    ERC20Interface tokenProvidedFromReserves,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmountFromReserves,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external returns (uint256 totalTokensSold);\r\n\r\n  function tradeTokenForTokenUsingReservesSpecifyingFee(\r\n    ERC20Interface tokenProvidedFromReserves,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmountFromReserves,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external returns (uint256 totalTokensBought);\r\n\r\n  function tradeEtherForTokenUsingReservesWithFeeOnTransferSpecifyingFee(\r\n    address token,\r\n    uint256 etherAmountFromReserves,\r\n    uint256 quotedTokenAmount,\r\n    uint256 quotedTokenAmountAfterTransferFee,\r\n    uint256 etherFeeAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalTokensBought);\r\n\r\n  function tradeTokenForEtherUsingReserves(\r\n    ERC20Interface token,\r\n    uint256 tokenAmountFromReserves,\r\n    uint256 quotedEtherAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherBought);\r\n\r\n  function tradeTokenForEtherUsingReservesSpecifyingFee(\r\n    ERC20Interface token,\r\n    uint256 tokenAmountFromReserves,\r\n    uint256 quotedEtherAmount,\r\n    uint256 maximumEtherFeeAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherBought);\r\n\r\n  function tradeEtherForTokenUsingReserves(\r\n    address token,\r\n    uint256 etherAmountFromReserves,\r\n    uint256 quotedTokenAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherSold);\r\n\r\n  function tradeEtherForTokenUsingReservesSpecifyingFee(\r\n    address token,\r\n    uint256 etherAmountFromReserves,\r\n    uint256 quotedTokenAmount,\r\n    uint256 etherFeeAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalTokensBought);\r\n\r\n  function finalizeEtherDeposit(\r\n    address payable smartWallet,\r\n    address initialUserSigningKey,\r\n    uint256 etherAmount\r\n  ) external;\r\n\r\n  function finalizeTokenDeposit(\r\n    address smartWallet,\r\n    address initialUserSigningKey,\r\n    ERC20Interface token,\r\n    uint256 amount\r\n  ) external;\r\n\r\n  function redeem(uint256 dDaiAmount) external returns (uint256 daiReceived);\r\n\r\n  function refillGasReserve(uint256 etherAmount) external;\r\n\r\n  function withdrawUSDC(address recipient, uint256 usdcAmount) external;\r\n\r\n  function withdrawDai(address recipient, uint256 daiAmount) external;\r\n\r\n  function withdrawUSDCToPrimaryRecipient(uint256 usdcAmount) external;\r\n\r\n  function withdrawDaiToPrimaryRecipient(uint256 usdcAmount) external;\r\n\r\n  function withdrawEther(\r\n    address payable recipient, uint256 etherAmount\r\n  ) external;\r\n\r\n  function withdraw(\r\n    ERC20Interface token, address recipient, uint256 amount\r\n  ) external returns (bool success);\r\n\r\n  function callAny(\r\n    address payable target, uint256 amount, bytes calldata data\r\n  ) external returns (bool ok, bytes memory returnData);\r\n\r\n  function setPrimaryUSDCRecipient(address recipient) external;\r\n\r\n  function setPrimaryDaiRecipient(address recipient) external;\r\n\r\n  function setRole(Role role, address account) external;\r\n\r\n  function removeRole(Role role) external;\r\n\r\n  function pause(Role role) external;\r\n\r\n  function unpause(Role role) external;\r\n\r\n  function isPaused(Role role) external view returns (bool paused);\r\n\r\n  function isRole(Role role) external view returns (bool hasRole);\r\n\r\n  function isDharmaSmartWallet(\r\n    address smartWallet, address initialUserSigningKey\r\n  ) external view returns (bool dharmaSmartWallet);\r\n\r\n  function getDepositManager() external view returns (address depositManager);\r\n\r\n  function getAdjuster() external view returns (address adjuster);\r\n\r\n  function getReserveTrader() external view returns (address reserveTrader);\r\n\r\n  function getWithdrawalManager() external view returns (\r\n    address withdrawalManager\r\n  );\r\n\r\n  function getPauser() external view returns (address pauser);\r\n\r\n  function getGasReserveRefiller() external view returns (\r\n    address gasReserveRefiller\r\n  );\r\n\r\n  function getReserves() external view returns (\r\n    uint256 dai, uint256 dDai, uint256 dDaiUnderlying\r\n  );\r\n\r\n  function getPrimaryUSDCRecipient() external view returns (\r\n    address recipient\r\n  );\r\n\r\n  function getPrimaryDaiRecipient() external view returns (\r\n    address recipient\r\n  );\r\n\r\n  function getImplementation() external view returns (address implementation);\r\n\r\n  function getInstance() external pure returns (address instance);\r\n\r\n  function getVersion() external view returns (uint256 version);\r\n}\r\n\r\n\r\ninterface ERC20Interface {\r\n  function balanceOf(address) external view returns (uint256);\r\n  function approve(address, uint256) external returns (bool);\r\n  function allowance(address, address) external view returns (uint256);\r\n  function transfer(address, uint256) external returns (bool);\r\n  function transferFrom(address, address, uint256) external returns (bool);\r\n}\r\n\r\n\r\ninterface DTokenInterface {\r\n  function redeem(\r\n    uint256 dTokensToBurn\r\n  ) external returns (uint256 underlyingReceived);\r\n  function balanceOf(address) external view returns (uint256);\r\n  function balanceOfUnderlying(address) external view returns (uint256);\r\n  function transfer(address, uint256) external returns (bool);\r\n  function approve(address, uint256) external returns (bool);\r\n  function exchangeRateCurrent() external view returns (uint256);\r\n}\r\n\r\n\r\ninterface UniswapV2Interface {\r\n  function swapTokensForExactTokens(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapExactTokensForTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapExactTokensForETH(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapTokensForExactETH(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapETHForExactTokens(\r\n    uint256 amountOut,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  function swapExactETHForTokens(\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n\r\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n\r\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable;\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    return a - b;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) return 0;\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    return a / b;\r\n  }\r\n\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n *\r\n * In order to transfer ownership, a recipient must be specified, at which point\r\n * the specified recipient can call `acceptOwnership` and take ownership.\r\n */\r\ncontract TwoStepOwnable {\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  address private _owner;\r\n\r\n  address private _newPotentialOwner;\r\n\r\n  /**\r\n   * @dev Allows a new account (`newOwner`) to accept ownership.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) external onlyOwner {\r\n    require(\r\n      newOwner != address(0),\r\n      \"TwoStepOwnable: new potential owner is the zero address.\"\r\n    );\r\n\r\n    _newPotentialOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancel a transfer of ownership to a new account.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function cancelOwnershipTransfer() external onlyOwner {\r\n    delete _newPotentialOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to the caller.\r\n   * Can only be called by a new potential owner set by the current owner.\r\n   */\r\n  function acceptOwnership() external {\r\n    require(\r\n      msg.sender == _newPotentialOwner,\r\n      \"TwoStepOwnable: current owner must set caller as new potential owner.\"\r\n    );\r\n\r\n    delete _newPotentialOwner;\r\n\r\n    emit OwnershipTransferred(_owner, msg.sender);\r\n\r\n    _owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() external view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the caller is the current owner.\r\n   */\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"TwoStepOwnable: caller is not the owner.\");\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaTradeReserveV17Implementation (staging version)\r\n * @author 0age\r\n * @notice This contract manages Dharma's reserves. It designates a collection of\r\n * \"roles\" - these are dedicated accounts that can be modified by the owner, and\r\n * that can trigger specific functionality on the reserve. These roles are:\r\n *  - depositManager (0): initiates Eth / token transfers to smart wallets\r\n *  - adjuster (1): mints / redeems Dai, and swaps USDC, for dDai\r\n *  - withdrawalManager (2): initiates token transfers to recipients set by owner\r\n *  - reserveTrader (3): initiates trades using funds held in reserve\r\n *  - pauser (4): pauses any role (only the owner is then able to unpause it)\r\n *  - gasReserveRefiller (5): transfers Ether to the Dharma Gas Reserve\r\n *\r\n * When finalizing deposits, the deposit manager must adhere to two constraints:\r\n *  - it must provide \"proof\" that the recipient is a smart wallet by including\r\n *    the initial user signing key used to derive the smart wallet address\r\n *\r\n * Note that \"proofs\" can be validated via `isSmartWallet`.\r\n */\r\ncontract DharmaTradeReserveV17ImplementationStaging is DharmaTradeReserveV17Interface, TwoStepOwnable {\r\n  using SafeMath for uint256;\r\n\r\n  // Maintain a role status mapping with assigned accounts and paused states.\r\n  mapping(uint256 => RoleStatus) private _roles;\r\n\r\n  // Maintain a \"primary recipient\" the withdrawal manager can transfer Dai to.\r\n  address private _primaryDaiRecipient;\r\n\r\n  // Maintain a \"primary recipient\" the withdrawal manager can transfer USDC to.\r\n  address private _primaryUSDCRecipient;\r\n\r\n  // Maintain a maximum allowable transfer size (in Dai) for the deposit manager.\r\n  uint256 private _daiLimit; // unused\r\n\r\n  // Maintain a maximum allowable transfer size (in Ether) for the deposit manager.\r\n  uint256 private _etherLimit; // unused\r\n\r\n  bool private _originatesFromReserveTrader; // unused, don't change storage layout\r\n\r\n  uint256 private constant _VERSION = 1017;\r\n\r\n  address private constant V16_STAGING = address(\r\n    0xCF313bE76Ff33aaf3B69d13d6BE3A3Aeb2f6F781\r\n  );\r\n\r\n  // This contract interacts with USDC, Dai, and Dharma Dai.\r\n  ERC20Interface internal constant _USDC = ERC20Interface(\r\n    0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 // mainnet\r\n  );\r\n\r\n  ERC20Interface internal constant _DAI = ERC20Interface(\r\n    0x6B175474E89094C44Da98b954EedeAC495271d0F // mainnet\r\n  );\r\n\r\n  ERC20Interface internal constant _ETHERIZER = ERC20Interface(\r\n    0x723B51b72Ae89A3d0c2a2760f0458307a1Baa191\r\n  );\r\n\r\n  DTokenInterface internal constant _DDAI = DTokenInterface(\r\n    0x00000000001876eB1444c986fD502e618c587430\r\n  );\r\n\r\n  UniswapV2Interface internal constant _UNISWAP_ROUTER = UniswapV2Interface(\r\n    0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n  );\r\n\r\n  address internal constant _WETH = address(\r\n    0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n  );\r\n\r\n  address internal constant _GAS_RESERVE = address(\r\n    0x09cd826D4ABA4088E1381A1957962C946520952d // staging version\r\n  );\r\n\r\n  // The \"Create2 Header\" is used to compute smart wallet deployment addresses.\r\n  bytes21 internal constant _CREATE2_HEADER = bytes21(\r\n    0xff8D1e00b000e56d5BcB006F3a008Ca6003b9F0033 // control character + factory\r\n  );\r\n\r\n  // The \"Wallet creation code\" header & footer are also used to derive wallets.\r\n  bytes internal constant _WALLET_CREATION_CODE_HEADER = hex\"60806040526040516104423803806104428339818101604052602081101561002657600080fd5b810190808051604051939291908464010000000082111561004657600080fd5b90830190602082018581111561005b57600080fd5b825164010000000081118282018810171561007557600080fd5b82525081516020918201929091019080838360005b838110156100a257818101518382015260200161008a565b50505050905090810190601f1680156100cf5780820380516001836020036101000a031916815260200191505b5060405250505060006100e661019e60201b60201c565b6001600160a01b0316826040518082805190602001908083835b6020831061011f5780518252601f199092019160209182019101610100565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b5050905080610197573d6000803e3d6000fd5b50506102be565b60405160009081906060906eb45d6593312ac9fde193f3d06336449083818181855afa9150503d80600081146101f0576040519150601f19603f3d011682016040523d82523d6000602084013e6101f5565b606091505b509150915081819061029f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561026457818101518382015260200161024c565b50505050905090810190601f1680156102915780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b508080602001905160208110156102b557600080fd5b50519392505050565b610175806102cd6000396000f3fe608060405261001461000f610016565b61011c565b005b60405160009081906060906eb45d6593312ac9fde193f3d06336449083818181855afa9150503d8060008114610068576040519150601f19603f3d011682016040523d82523d6000602084013e61006d565b606091505b50915091508181906100fd5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156100c25781810151838201526020016100aa565b50505050905090810190601f1680156100ef5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5080806020019051602081101561011357600080fd5b50519392505050565b3660008037600080366000845af43d6000803e80801561013b573d6000f35b3d6000fdfea265627a7a723158203c578cc1552f1d1b48134a72934fe12fb89a29ff396bd514b9a4cebcacc5cacc64736f6c634300050b003200000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000024c4d66de8000000000000000000000000\";\r\n  bytes28 internal constant _WALLET_CREATION_CODE_FOOTER = bytes28(\r\n    0x00000000000000000000000000000000000000000000000000000000\r\n  );\r\n\r\n  // Flag to trigger trade for USDC and retain full trade amount\r\n  address internal constant _TRADE_FOR_USDC_AND_RETAIN_FLAG = address(uint160(-1));\r\n\r\n  // Include a payable fallback so that the contract can receive Ether payments.\r\n  function () external payable {\r\n    emit EtherReceived(msg.sender, msg.value);\r\n  }\r\n\r\n  function tradeTokenForToken(\r\n    ERC20Interface tokenProvided,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmount,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external returns (uint256 totalTokensSold) {\r\n    _delegate(V16_STAGING);\r\n  }\r\n\r\n  function tradeTokenForTokenSpecifyingFee(\r\n    ERC20Interface tokenProvided,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmount,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external returns (uint256 totalTokensBought) {\r\n    // Transfer the token from the caller and revert on failure.\r\n    _transferInToken(tokenProvided, msg.sender, tokenProvidedAmount);\r\n\r\n    totalTokensBought = _tradeTokenForToken(\r\n      msg.sender,\r\n      tokenProvided,\r\n      tokenReceived,\r\n      tokenProvidedAmount,\r\n      quotedTokenReceivedAmount,\r\n      maximumFeeAmount,\r\n      deadline,\r\n      routeThroughEther\r\n    );\r\n  }\r\n\r\n  function tradeTokenForTokenWithFeeOnTransfer(\r\n    ERC20Interface tokenProvided,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmount,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 quotedTokenReceivedAmountAfterTransferFee,\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external returns (uint256 totalTokensBought) {\r\n    // Get the balance of this contract of the provided token before transferring.\r\n    uint256 balanceBeforeTransferIn = tokenProvided.balanceOf(address(this));\r\n\r\n    // Transfer the token from the caller and revert on failure.\r\n    _transferInToken(tokenProvided, msg.sender, tokenProvidedAmount);\r\n\r\n    uint256 tokenProvidedAmountAfterTransferFee = tokenProvided.balanceOf(\r\n      address(this)\r\n    ).sub(balanceBeforeTransferIn);\r\n\r\n    totalTokensBought = _tradeTokenForTokenWithFeeOnTransferLegacy(\r\n      msg.sender,\r\n      tokenProvided,\r\n      tokenReceived,\r\n      tokenProvidedAmount,\r\n      tokenProvidedAmountAfterTransferFee,\r\n      quotedTokenReceivedAmount,\r\n      quotedTokenReceivedAmountAfterTransferFee,\r\n      deadline,\r\n      routeThroughEther\r\n    );\r\n  }\r\n\r\n  function tradeTokenForTokenWithFeeOnTransferSpecifyingFee(\r\n    ERC20Interface tokenProvided,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmount,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 quotedTokenReceivedAmountAfterTransferFee,\r\n    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external returns (uint256 totalTokensBought) {\r\n    // Get the balance of this contract of the provided token before transferring.\r\n    uint256 balanceBeforeTransferIn = tokenProvided.balanceOf(address(this));\r\n\r\n    // Transfer the token from the caller and revert on failure.\r\n    _transferInToken(tokenProvided, msg.sender, tokenProvidedAmount);\r\n\r\n    uint256 tokenProvidedAmountAfterTransferFee = tokenProvided.balanceOf(\r\n      address(this)\r\n    ).sub(balanceBeforeTransferIn);\r\n\r\n    totalTokensBought = _tradeTokenForTokenWithFeeOnTransfer(\r\n      msg.sender,\r\n      tokenProvided,\r\n      tokenReceived,\r\n      tokenProvidedAmount,\r\n      tokenProvidedAmountAfterTransferFee,\r\n      quotedTokenReceivedAmount,\r\n      quotedTokenReceivedAmountAfterTransferFee,\r\n      maximumFeeAmount,\r\n      deadline,\r\n      routeThroughEther\r\n    );\r\n  }\r\n\r\n  function tradeTokenForEther(\r\n    ERC20Interface token,\r\n    uint256 tokenAmount,\r\n    uint256 quotedEtherAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherBought) {\r\n    _delegate(V16_STAGING);\r\n  }\r\n\r\n  function tradeTokenForEtherSpecifyingFee(\r\n    ERC20Interface token,\r\n    uint256 tokenAmount,\r\n    uint256 quotedEtherAmount,\r\n    uint256 maximumEtherFeeAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherBought) {\r\n    // Transfer the tokens from the caller and revert on failure.\r\n    _transferInToken(token, msg.sender, tokenAmount);\r\n\r\n    // Trade tokens for Ether.\r\n    totalEtherBought = _tradeTokenForEther(\r\n      token, tokenAmount, tokenAmount, quotedEtherAmount, deadline\r\n    );\r\n\r\n    // Retain the lesser of either max fee or bought amount less quoted amount.\r\n    uint256 retainedEtherAmount = maximumEtherFeeAmount.min(\r\n      totalEtherBought.sub(quotedEtherAmount)\r\n    );\r\n\r\n    // Receive back the total bought Ether less total retained Ether.\r\n    uint256 receivedEtherAmount = totalEtherBought.sub(retainedEtherAmount);\r\n\r\n    _fireTradeEvent(\r\n      false,\r\n      false,\r\n      address(token),\r\n      tokenAmount,\r\n      receivedEtherAmount,\r\n      retainedEtherAmount\r\n    );\r\n\r\n    // Transfer the Ether amount to receive to the caller.\r\n    _transferEther(msg.sender, receivedEtherAmount);\r\n  }\r\n\r\n  function tradeTokenForEtherWithFeeOnTransfer(\r\n    ERC20Interface token,\r\n    uint256 tokenAmount,\r\n    uint256 quotedEtherAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherBought) {\r\n    // Get the balance of this contract of the provided token before transferring.\r\n    uint256 balanceBeforeTransferIn = token.balanceOf(address(this));\r\n\r\n    // Transfer the token from the caller and revert on failure.\r\n    _transferInToken(token, msg.sender, tokenAmount);\r\n\r\n    uint256 tokenAmountAfterTransferFee = token.balanceOf(address(this)).sub(\r\n      balanceBeforeTransferIn\r\n    );\r\n\r\n    // Trade tokens for Ether.\r\n    totalEtherBought = _tradeTokenForEther(\r\n      token,\r\n      tokenAmount,\r\n      tokenAmountAfterTransferFee,\r\n      quotedEtherAmount,\r\n      deadline\r\n    );\r\n\r\n    _fireTradeEvent(\r\n      false,\r\n      false,\r\n      address(token),\r\n      tokenAmount,\r\n      quotedEtherAmount,\r\n      totalEtherBought.sub(quotedEtherAmount)\r\n    );\r\n\r\n    // Transfer the quoted Ether amount to the caller.\r\n    _transferEther(msg.sender, quotedEtherAmount);\r\n  }\r\n\r\n  function tradeTokenForEtherWithFeeOnTransferSpecifyingFee(\r\n    ERC20Interface token,\r\n    uint256 tokenAmount,\r\n    uint256 quotedEtherAmount,\r\n    uint256 maximumEtherFeeAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherBought) {\r\n    // Get balance of this contract of the provided token before transferring.\r\n    uint256 balanceBeforeTransferIn = token.balanceOf(address(this));\r\n\r\n    // Transfer the token from the caller and revert on failure.\r\n    _transferInToken(token, msg.sender, tokenAmount);\r\n\r\n    uint256 tokenAmountAfterTransferFee = token.balanceOf(address(this)).sub(\r\n      balanceBeforeTransferIn\r\n    );\r\n\r\n    // Trade tokens for Ether.\r\n    totalEtherBought = _tradeTokenForEther(\r\n      token,\r\n      tokenAmount,\r\n      tokenAmountAfterTransferFee,\r\n      quotedEtherAmount,\r\n      deadline\r\n    );\r\n\r\n    // Retain the lesser of either max fee or bought amount less quoted amount.\r\n    uint256 retainedEtherAmount = maximumEtherFeeAmount.min(\r\n      totalEtherBought.sub(quotedEtherAmount)\r\n    );\r\n\r\n    // Receive back the total bought Ether less total retained Ether.\r\n    uint256 receivedEtherAmount = totalEtherBought.sub(retainedEtherAmount);\r\n\r\n    _fireTradeEvent(\r\n      false,\r\n      false,\r\n      address(token),\r\n      tokenAmount,\r\n      receivedEtherAmount,\r\n      retainedEtherAmount\r\n    );\r\n\r\n    // Transfer the Ether amount to receive to the caller.\r\n    _transferEther(msg.sender, receivedEtherAmount);\r\n  }\r\n\r\n  function tradeEtherForToken(\r\n    address token, uint256 quotedTokenAmount, uint256 deadline\r\n  ) external payable returns (uint256 totalEtherSold) {\r\n    _delegate(V16_STAGING);\r\n  }\r\n\r\n  function tradeEtherForTokenSpecifyingFee(\r\n    address token,\r\n    uint256 quotedTokenAmount,\r\n    uint256 etherFeeAmount,\r\n    uint256 deadline\r\n  ) external payable returns (uint256 totalTokensBought) {\r\n    // Deduct fee from provided Ether value to determine Ether to supply.\r\n    uint256 suppliedEtherAmount = msg.value.sub(etherFeeAmount);\r\n\r\n    // Trade Ether for the specified token.\r\n    totalTokensBought = _tradeExactEtherForToken(\r\n      token, suppliedEtherAmount, quotedTokenAmount, deadline, false\r\n    );\r\n\r\n    _fireTradeEvent(\r\n      false,\r\n      true,\r\n      token,\r\n      msg.value,\r\n      totalTokensBought,\r\n      etherFeeAmount\r\n    );\r\n  }\r\n\r\n  function tradeEtherForTokenWithFeeOnTransfer(\r\n    address token,\r\n    uint256 quotedTokenAmount,\r\n    uint256 quotedTokenAmountAfterTransferFee,\r\n    uint256 deadline\r\n  ) external payable returns (uint256 totalTokensBought) {\r\n    // Trade Ether for the specified token.\r\n    totalTokensBought = _tradeEtherForTokenWithFeeOnTransferLegacy(\r\n      token,\r\n      msg.value,\r\n      quotedTokenAmount,\r\n      quotedTokenAmountAfterTransferFee,\r\n      deadline,\r\n      false\r\n    );\r\n  }\r\n\r\n  function tradeEtherForTokenWithFeeOnTransferSpecifyingFee(\r\n    address token,\r\n    uint256 quotedTokenAmount,\r\n    uint256 quotedTokenAmountAfterTransferFee,\r\n    uint256 etherFeeAmount,\r\n    uint256 deadline\r\n  ) external payable returns (uint256 totalTokensBought) {\r\n    totalTokensBought = _tradeEtherForTokenWithFeeOnTransfer(\r\n      token,\r\n      msg.value,\r\n      quotedTokenAmount,\r\n      quotedTokenAmountAfterTransferFee,\r\n      etherFeeAmount,\r\n      deadline,\r\n      false\r\n    );\r\n  }\r\n\r\n  function tradeEtherForTokenUsingReservesWithFeeOnTransferSpecifyingFee(\r\n    address token,\r\n    uint256 etherAmountFromReserves,\r\n    uint256 quotedTokenAmount,\r\n    uint256 quotedTokenAmountAfterTransferFee,\r\n    uint256 etherFeeAmount,\r\n    uint256 deadline\r\n  ) external onlyOwnerOr(Role.RESERVE_TRADER) returns (uint256 totalTokensBought) {\r\n    totalTokensBought = _tradeEtherForTokenWithFeeOnTransfer(\r\n      token,\r\n      etherAmountFromReserves,\r\n      quotedTokenAmount,\r\n      quotedTokenAmountAfterTransferFee,\r\n      etherFeeAmount,\r\n      deadline,\r\n      true\r\n    );\r\n  }\r\n\r\n  function tradeEtherForTokenUsingEtherizer(\r\n    address token,\r\n    uint256 etherAmount,\r\n    uint256 quotedTokenAmount,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalEtherSold) {\r\n    _delegate(V16_STAGING);\r\n  }\r\n\r\n  function tradeEtherForTokenWithFeeOnTransferUsingEtherizer(\r\n    address token,\r\n    uint256 etherAmount,\r\n    uint256 quotedTokenAmount,\r\n    uint256 quotedTokenAmountAfterTransferFee,\r\n    uint256 deadline\r\n  ) external returns (uint256 totalTokensBought) {\r\n    // Transfer the Ether from the caller and revert on failure.\r\n    _transferInToken(_ETHERIZER, msg.sender, etherAmount);\r\n\r\n    // Trade Ether for the specified token.\r\n    totalTokensBought = _tradeEtherForTokenWithFeeOnTransferLegacy(\r\n      token,\r\n      etherAmount,\r\n      quotedTokenAmount,\r\n      quotedTokenAmountAfterTransferFee,\r\n      deadline,\r\n      false\r\n    );\r\n  }\r\n\r\n  function tradeTokenForTokenUsingReserves(\r\n    ERC20Interface tokenProvidedFromReserves,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmountFromReserves,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external onlyOwnerOr(Role.RESERVE_TRADER) returns (uint256 totalTokensSold) {\r\n    _delegate(V16_STAGING);\r\n  }\r\n\r\n  function tradeTokenForTokenUsingReservesSpecifyingFee(\r\n    ERC20Interface tokenProvidedFromReserves,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmountFromReserves,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external onlyOwnerOr(Role.RESERVE_TRADER) returns (uint256 totalTokensBought) {\r\n    totalTokensBought = _tradeTokenForToken(\r\n      address(this),\r\n      tokenProvidedFromReserves,\r\n      tokenReceived,\r\n      tokenProvidedAmountFromReserves,\r\n      quotedTokenReceivedAmount,\r\n      maximumFeeAmount,\r\n      deadline,\r\n      routeThroughEther\r\n    );\r\n  }\r\n\r\n  function tradeTokenForTokenUsingReservesWithFeeOnTransferSpecifyingFee(\r\n    ERC20Interface tokenProvidedFromReserves,\r\n    address tokenReceived,\r\n    uint256 tokenProvidedAmountFromReserves,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) external onlyOwnerOr(Role.RESERVE_TRADER) returns (uint256 totalTokensBought) {\r\n    totalTokensBought = _tradeTokenForTokenWithFeeOnTransfer(\r\n      address(this),\r\n      tokenProvidedFromReserves,\r\n      tokenReceived,\r\n      tokenProvidedAmountFromReserves,\r\n      tokenProvidedAmountFromReserves,\r\n      quotedTokenReceivedAmount,\r\n      quotedTokenReceivedAmount,\r\n      maximumFeeAmount,\r\n      deadline,\r\n      routeThroughEther\r\n    );\r\n  }\r\n\r\n  function tradeTokenForEtherUsingReserves(\r\n    ERC20Interface token,\r\n    uint256 tokenAmountFromReserves,\r\n    uint256 quotedEtherAmount,\r\n    uint256 deadline\r\n  ) external onlyOwnerOr(Role.RESERVE_TRADER) returns (uint256 totalEtherBought) {\r\n    _delegate(V16_STAGING);\r\n  }\r\n\r\n  function tradeTokenForEtherUsingReservesSpecifyingFee(\r\n    ERC20Interface token,\r\n    uint256 tokenAmountFromReserves,\r\n    uint256 quotedEtherAmount,\r\n    uint256 maximumEtherFeeAmount,\r\n    uint256 deadline\r\n  ) external onlyOwnerOr(Role.RESERVE_TRADER) returns (uint256 totalEtherBought) {\r\n    // Trade tokens for Ether using reserves.\r\n    totalEtherBought = _tradeTokenForEther(\r\n      token,\r\n      tokenAmountFromReserves,\r\n      tokenAmountFromReserves,\r\n      quotedEtherAmount,\r\n      deadline\r\n    );\r\n\r\n    // Retain the lesser of either max fee or bought amount less quoted amount.\r\n    uint256 retainedEtherAmount = maximumEtherFeeAmount.min(\r\n      totalEtherBought.sub(quotedEtherAmount)\r\n    );\r\n\r\n    _fireTradeEvent(\r\n      true,\r\n      false,\r\n      address(token),\r\n      tokenAmountFromReserves,\r\n      totalEtherBought.sub(retainedEtherAmount),\r\n      retainedEtherAmount\r\n    );\r\n  }\r\n\r\n  function tradeTokenForEtherUsingReservesWithFeeOnTransferSpecifyingFee(\r\n    ERC20Interface token,\r\n    uint256 tokenAmountFromReserves,\r\n    uint256 quotedEtherAmount,\r\n    uint256 maximumEtherFeeAmount,\r\n    uint256 deadline\r\n  ) external onlyOwnerOr(Role.RESERVE_TRADER) returns (uint256 totalEtherBought) {\r\n    // Trade tokens for Ether using reserves.\r\n    totalEtherBought = _tradeTokenForEther(\r\n      token,\r\n      0, // unused, just needs to differ from next argument\r\n      tokenAmountFromReserves,\r\n      quotedEtherAmount,\r\n      deadline\r\n    );\r\n\r\n    // Retain the lesser of either max fee or bought amount less quoted amount.\r\n    uint256 retainedEtherAmount = maximumEtherFeeAmount.min(\r\n      totalEtherBought.sub(quotedEtherAmount)\r\n    );\r\n\r\n    _fireTradeEvent(\r\n      true,\r\n      false,\r\n      address(token),\r\n      tokenAmountFromReserves,\r\n      totalEtherBought.sub(retainedEtherAmount),\r\n      retainedEtherAmount\r\n    );\r\n  }\r\n\r\n  function tradeEtherForTokenUsingReserves(\r\n    address token,\r\n    uint256 etherAmountFromReserves,\r\n    uint256 quotedTokenAmount,\r\n    uint256 deadline\r\n  ) external onlyOwnerOr(Role.RESERVE_TRADER) returns (uint256 totalEtherSold) {\r\n    _delegate(V16_STAGING);\r\n  }\r\n\r\n  function tradeEtherForTokenUsingReservesSpecifyingFee(\r\n    address token,\r\n    uint256 etherAmountFromReserves,\r\n    uint256 quotedTokenAmount,\r\n    uint256 etherFeeAmount,\r\n    uint256 deadline\r\n  ) external onlyOwnerOr(Role.RESERVE_TRADER) returns (\r\n    uint256 totalTokensBought\r\n  ) {\r\n    // Deduct fee from provided Ether value to determine Ether to supply.\r\n    uint256 suppliedEtherAmount = etherAmountFromReserves.sub(etherFeeAmount);\r\n\r\n    // Trade Ether for token using reserves.\r\n    totalTokensBought = _tradeExactEtherForToken(\r\n      token, suppliedEtherAmount, quotedTokenAmount, deadline, true\r\n    );\r\n\r\n    _fireTradeEvent(\r\n      true,\r\n      true,\r\n      token,\r\n      etherAmountFromReserves,\r\n      totalTokensBought,\r\n      etherFeeAmount\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `amount` of token `token` to `smartWallet`, providing the\r\n   * initial user signing key `initialUserSigningKey` as proof that the\r\n   * specified smart wallet is indeed a Dharma Smart Wallet - this assumes that\r\n   * the address is derived and deployed using the Dharma Smart Wallet Factory\r\n   * V1. Only the owner or the designated deposit manager role may call this\r\n   * function.\r\n   * @param smartWallet address The smart wallet to transfer tokens to.\r\n   * @param initialUserSigningKey address The initial user signing key supplied\r\n   * when deriving the smart wallet address - this could be an EOA or a Dharma\r\n   * key ring address.\r\n   * @param token ERC20Interface The token to transfer.\r\n   * @param amount uint256 The amount of tokens to transfer.\r\n   */\r\n  function finalizeTokenDeposit(\r\n    address smartWallet,\r\n    address initialUserSigningKey,\r\n    ERC20Interface token,\r\n    uint256 amount\r\n  ) external onlyOwnerOr(Role.DEPOSIT_MANAGER) {\r\n    // Ensure that the recipient is indeed a smart wallet.\r\n    _ensureSmartWallet(smartWallet, initialUserSigningKey);\r\n\r\n    // Transfer the token to the specified smart wallet.\r\n    _transferToken(token, smartWallet, amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `etherAmount` Ether to `smartWallet`, providing the\r\n   * initial user signing key `initialUserSigningKey` as proof that the\r\n   * specified smart wallet is indeed a Dharma Smart Wallet - this assumes that\r\n   * the address is derived and deployed using the Dharma Smart Wallet Factory\r\n   * V1. In addition, the Ether amount must be less than the configured limit\r\n   * amount. Only the owner or the designated deposit manager role may call this\r\n   * function.\r\n   * @param smartWallet address The smart wallet to transfer Ether to.\r\n   * @param initialUserSigningKey address The initial user signing key supplied\r\n   * when deriving the smart wallet address - this could be an EOA or a Dharma\r\n   * key ring address.\r\n   * @param etherAmount uint256 The amount of Ether to transfer - this amount\r\n   * must be less than the current limit.\r\n   */\r\n  function finalizeEtherDeposit(\r\n    address payable smartWallet,\r\n    address initialUserSigningKey,\r\n    uint256 etherAmount\r\n  ) external onlyOwnerOr(Role.DEPOSIT_MANAGER) {\r\n    // Ensure that the recipient is indeed a smart wallet.\r\n    _ensureSmartWallet(smartWallet, initialUserSigningKey);\r\n\r\n    // Transfer the Ether to the specified smart wallet.\r\n    _transferEther(smartWallet, etherAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Redeem `dDaiAmount` Dharma Dai for Dai. Only the owner or the\r\n   * designated adjuster role may call this function.\r\n   * @param dDaiAmount uint256 The amount of Dharma Dai to supply when redeeming\r\n   * for Dai.\r\n   * @return The amount of Dai received.\r\n   */\r\n  function redeem(\r\n    uint256 dDaiAmount\r\n  ) external onlyOwnerOr(Role.ADJUSTER) returns (uint256 daiReceived) {\r\n    // Redeem the specified amount of dDai for Dai.\r\n    daiReceived = _DDAI.redeem(dDaiAmount);\r\n  }\r\n\r\n  function refillGasReserve(\r\n    uint256 etherAmount\r\n  ) external onlyOwnerOr(Role.GAS_RESERVE_REFILLER) {\r\n    // Transfer the Ether to the gas reserve.\r\n    _transferEther(_GAS_RESERVE, etherAmount);\r\n\r\n    emit GasReserveRefilled(etherAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `usdcAmount` USDC for to the current primary recipient set\r\n   * by the owner. Only the owner or the designated withdrawal manager role may\r\n   * call this function.\r\n   * @param usdcAmount uint256 The amount of USDC to transfer to the primary\r\n   * recipient.\r\n   */\r\n  function withdrawUSDCToPrimaryRecipient(\r\n    uint256 usdcAmount\r\n  ) external onlyOwnerOr(Role.WITHDRAWAL_MANAGER) {\r\n    // Get the current primary recipient.\r\n    address primaryRecipient = _primaryUSDCRecipient;\r\n    require(\r\n      primaryRecipient != address(0), \"No USDC primary recipient currently set.\"\r\n    );\r\n\r\n    // Transfer the supplied USDC amount to the primary recipient.\r\n    _transferToken(_USDC, primaryRecipient, usdcAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `daiAmount` Dai for to the current primary recipient set\r\n   * by the owner. Only the owner or the designated withdrawal manager role may\r\n   * call this function.\r\n   * @param daiAmount uint256 The amount of Dai to transfer to the primary\r\n   * recipient.\r\n   */\r\n  function withdrawDaiToPrimaryRecipient(\r\n    uint256 daiAmount\r\n  ) external onlyOwnerOr(Role.WITHDRAWAL_MANAGER) {\r\n    // Get the current primary recipient.\r\n    address primaryRecipient = _primaryDaiRecipient;\r\n    require(\r\n      primaryRecipient != address(0), \"No Dai primary recipient currently set.\"\r\n    );\r\n\r\n    // Transfer the supplied Dai amount to the primary recipient.\r\n    _transferToken(_DAI, primaryRecipient, daiAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `usdcAmount` USDC to `recipient`. Only the owner may call\r\n   * this function.\r\n   * @param recipient address The account to transfer USDC to.\r\n   * @param usdcAmount uint256 The amount of USDC to transfer.\r\n   */\r\n  function withdrawUSDC(\r\n    address recipient, uint256 usdcAmount\r\n  ) external onlyOwner {\r\n    // Transfer the USDC to the specified recipient.\r\n    _transferToken(_USDC, recipient, usdcAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `daiAmount` Dai to `recipient`. Only the owner may call\r\n   * this function.\r\n   * @param recipient address The account to transfer Dai to.\r\n   * @param daiAmount uint256 The amount of Dai to transfer.\r\n   */\r\n  function withdrawDai(\r\n    address recipient, uint256 daiAmount\r\n  ) external onlyOwner {\r\n    // Transfer the Dai to the specified recipient.\r\n    _transferToken(_DAI, recipient, daiAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `etherAmount` Ether to `recipient`. Only the owner may\r\n   * call this function.\r\n   * @param recipient address The account to transfer Ether to.\r\n   * @param etherAmount uint256 The amount of Ether to transfer.\r\n   */\r\n  function withdrawEther(\r\n    address payable recipient, uint256 etherAmount\r\n  ) external onlyOwner {\r\n    // Transfer the Ether to the specified recipient.\r\n    _transferEther(recipient, etherAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer `amount` of ERC20 token `token` to `recipient`. Only the\r\n   * owner may call this function.\r\n   * @param token ERC20Interface The ERC20 token to transfer.\r\n   * @param recipient address The account to transfer the tokens to.\r\n   * @param amount uint256 The amount of tokens to transfer.\r\n   * @return A boolean to indicate if the transfer was successful - note that\r\n   * unsuccessful ERC20 transfers will usually revert.\r\n   */\r\n  function withdraw(\r\n    ERC20Interface token, address recipient, uint256 amount\r\n  ) external onlyOwner returns (bool success) {\r\n    // Transfer the token to the specified recipient.\r\n    success = token.transfer(recipient, amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Call account `target`, supplying value `amount` and data `data`.\r\n   * Only the owner may call this function.\r\n   * @param target address The account to call.\r\n   * @param amount uint256 The amount of ether to include as an endowment.\r\n   * @param data bytes The data to include along with the call.\r\n   * @return A boolean to indicate if the call was successful, as well as the\r\n   * returned data or revert reason.\r\n   */\r\n  function callAny(\r\n    address payable target, uint256 amount, bytes calldata data\r\n  ) external onlyOwner returns (bool ok, bytes memory returnData) {\r\n    // Call the specified target and supply the specified data.\r\n    (ok, returnData) = target.call.value(amount)(data);\r\n  }\r\n\r\n  /**\r\n   * @notice Set `recipient` as the new primary recipient for USDC withdrawals.\r\n   * Only the owner may call this function.\r\n   * @param recipient address The new primary recipient.\r\n   */\r\n  function setPrimaryUSDCRecipient(address recipient) external onlyOwner {\r\n    // Set the new primary recipient.\r\n    _primaryUSDCRecipient = recipient;\r\n  }\r\n\r\n  /**\r\n   * @notice Set `recipient` as the new primary recipient for Dai withdrawals.\r\n   * Only the owner may call this function.\r\n   * @param recipient address The new primary recipient.\r\n   */\r\n  function setPrimaryDaiRecipient(address recipient) external onlyOwner {\r\n    // Set the new primary recipient.\r\n    _primaryDaiRecipient = recipient;\r\n  }\r\n\r\n  /**\r\n   * @notice Pause a currently unpaused role and emit a `RolePaused` event. Only\r\n   * the owner or the designated pauser may call this function. Also, bear in\r\n   * mind that only the owner may unpause a role once paused.\r\n   * @param role The role to pause.\r\n   */\r\n  function pause(Role role) external onlyOwnerOr(Role.PAUSER) {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n    require(!storedRoleStatus.paused, \"Role in question is already paused.\");\r\n    storedRoleStatus.paused = true;\r\n    emit RolePaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice Unpause a currently paused role and emit a `RoleUnpaused` event.\r\n   * Only the owner may call this function.\r\n   * @param role The role to pause.\r\n   */\r\n  function unpause(Role role) external onlyOwner {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n    require(storedRoleStatus.paused, \"Role in question is already unpaused.\");\r\n    storedRoleStatus.paused = false;\r\n    emit RoleUnpaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice Set a new account on a given role and emit a `RoleModified` event\r\n   * if the role holder has changed. Only the owner may call this function.\r\n   * @param role The role that the account will be set for.\r\n   * @param account The account to set as the designated role bearer.\r\n   */\r\n  function setRole(Role role, address account) external onlyOwner {\r\n    require(account != address(0), \"Must supply an account.\");\r\n    _setRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @notice Remove any current role bearer for a given role and emit a\r\n   * `RoleModified` event if a role holder was previously set. Only the owner\r\n   * may call this function.\r\n   * @param role The role that the account will be removed from.\r\n   */\r\n  function removeRole(Role role) external onlyOwner {\r\n    _setRole(role, address(0));\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check whether or not the functionality\r\n   * associated with a given role is currently paused or not. The owner or the\r\n   * pauser may pause any given role (including the pauser itself), but only the\r\n   * owner may unpause functionality. Additionally, the owner may call paused\r\n   * functions directly.\r\n   * @param role The role to check the pause status on.\r\n   * @return A boolean to indicate if the functionality associated with the role\r\n   * in question is currently paused.\r\n   */\r\n  function isPaused(Role role) external view returns (bool paused) {\r\n    paused = _isPaused(role);\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check whether the caller is the current\r\n   * role holder.\r\n   * @param role The role to check for.\r\n   * @return A boolean indicating if the caller has the specified role.\r\n   */\r\n  function isRole(Role role) external view returns (bool hasRole) {\r\n    hasRole = _isRole(role);\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check whether a \"proof\" that a given\r\n   * smart wallet is actually a Dharma Smart Wallet, based on the initial user\r\n   * signing key, is valid or not. This proof only works when the Dharma Smart\r\n   * Wallet in question is derived using V1 of the Dharma Smart Wallet Factory.\r\n   * @param smartWallet address The smart wallet to check.\r\n   * @param initialUserSigningKey address The initial user signing key supplied\r\n   * when deriving the smart wallet address - this could be an EOA or a Dharma\r\n   * key ring address.\r\n   * @return A boolean indicating if the specified smart wallet account is\r\n   * indeed a smart wallet based on the specified initial user signing key.\r\n   */\r\n  function isDharmaSmartWallet(\r\n    address smartWallet, address initialUserSigningKey\r\n  ) external view returns (bool dharmaSmartWallet) {\r\n    dharmaSmartWallet = _isSmartWallet(smartWallet, initialUserSigningKey);\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * deposit manager role. The deposit manager can process standard deposit\r\n   * finalization via `finalizeDaiDeposit` and `finalizeDharmaDaiDeposit`, but\r\n   * must prove that the recipient is a Dharma Smart Wallet and adhere to the\r\n   * current deposit size limit.\r\n   * @return The address of the current deposit manager, or the null address if\r\n   * none is set.\r\n   */\r\n  function getDepositManager() external view returns (address depositManager) {\r\n    depositManager = _roles[uint256(Role.DEPOSIT_MANAGER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * adjuster role. The adjuster can exchange Dai in reserves for Dharma Dai and\r\n   * vice-versa via minting or redeeming.\r\n   * @return The address of the current adjuster, or the null address if none is\r\n   * set.\r\n   */\r\n  function getAdjuster() external view returns (address adjuster) {\r\n    adjuster = _roles[uint256(Role.ADJUSTER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * reserve trader role. The reserve trader can trigger trades that utilize\r\n   * reserves in addition to supplied funds, if any.\r\n   * @return The address of the current reserve trader, or the null address if\r\n   * none is set.\r\n   */\r\n  function getReserveTrader() external view returns (address reserveTrader) {\r\n    reserveTrader = _roles[uint256(Role.RESERVE_TRADER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * withdrawal manager role. The withdrawal manager can transfer USDC to the\r\n   * \"primary recipient\" address set by the owner.\r\n   * @return The address of the current withdrawal manager, or the null address\r\n   * if none is set.\r\n   */\r\n  function getWithdrawalManager() external view returns (\r\n    address withdrawalManager\r\n  ) {\r\n    withdrawalManager = _roles[uint256(Role.WITHDRAWAL_MANAGER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the account currently holding the\r\n   * pauser role. The pauser can pause any role from taking its standard action,\r\n   * though the owner will still be able to call the associated function in the\r\n   * interim and is the only entity able to unpause the given role once paused.\r\n   * @return The address of the current pauser, or the null address if none is\r\n   * set.\r\n   */\r\n  function getPauser() external view returns (address pauser) {\r\n    pauser = _roles[uint256(Role.PAUSER)].account;\r\n  }\r\n\r\n  function getGasReserveRefiller() external view returns (\r\n    address gasReserveRefiller\r\n  ) {\r\n    gasReserveRefiller = _roles[uint256(Role.GAS_RESERVE_REFILLER)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the current reserves held by this\r\n   * contract.\r\n   * @return The Dai and Dharma Dai reserves held by this contract, as well as\r\n   * the Dai-equivalent value of the Dharma Dai reserves.\r\n   */\r\n  function getReserves() external view returns (\r\n    uint256 dai, uint256 dDai, uint256 dDaiUnderlying\r\n  ) {\r\n    dai = _DAI.balanceOf(address(this));\r\n    dDai = _DDAI.balanceOf(address(this));\r\n    dDaiUnderlying = _DDAI.balanceOfUnderlying(address(this));\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the address of the current\r\n   * primary recipient for USDC.\r\n   * @return The primary recipient for USDC.\r\n   */\r\n  function getPrimaryUSDCRecipient() external view returns (\r\n    address recipient\r\n  ) {\r\n    recipient = _primaryUSDCRecipient;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the address of the current\r\n   * primary recipient for Dai.\r\n   * @return The primary recipient for Dai.\r\n   */\r\n  function getPrimaryDaiRecipient() external view returns (\r\n    address recipient\r\n  ) {\r\n    recipient = _primaryDaiRecipient;\r\n  }\r\n\r\n  /**\r\n   * @notice External view function to check the current implementation\r\n   * of this contract (i.e. the \"logic\" for the contract).\r\n   * @return The current implementation for this contract.\r\n   */\r\n  function getImplementation() external view returns (\r\n    address implementation\r\n  ) {\r\n    (bool ok, bytes memory returnData) = address(\r\n      0x481B1a16E6675D33f8BBb3a6A58F5a9678649718\r\n    ).staticcall(\"\");\r\n    require(ok && returnData.length == 32, \"Invalid implementation.\");\r\n    implementation = abi.decode(returnData, (address));\r\n  }\r\n\r\n  /**\r\n   * @notice External pure function to get the address of the actual\r\n   * contract instance (i.e. the \"storage\" foor this contract).\r\n   * @return The address of this contract instance.\r\n   */\r\n  function getInstance() external pure returns (address instance) {\r\n    instance = address(0x09cd826D4ABA4088E1381A1957962C946520952d);\r\n  }\r\n\r\n  function getVersion() external view returns (uint256 version) {\r\n    version = _VERSION;\r\n  }\r\n\r\n  function _grantUniswapRouterApprovalIfNecessary(\r\n    ERC20Interface token, uint256 amount\r\n  ) internal {\r\n    if (token.allowance(address(this), address(_UNISWAP_ROUTER)) < amount) {\r\n      // Try removing approval first as a workaround for unusual tokens.\r\n      (bool success, bytes memory data) = address(token).call(\r\n        abi.encodeWithSelector(\r\n          token.approve.selector, address(_UNISWAP_ROUTER), uint256(0)\r\n        )\r\n      );\r\n\r\n      // Grant transfer approval to Uniswap router on behalf of this contract.\r\n      (success, data) = address(token).call(\r\n        abi.encodeWithSelector(\r\n          token.approve.selector, address(_UNISWAP_ROUTER), uint256(-1)\r\n        )\r\n      );\r\n\r\n      if (!success) {\r\n        // Some janky tokens only allow setting approval up to current balance.\r\n        (success, data) = address(token).call(\r\n          abi.encodeWithSelector(\r\n            token.approve.selector, address(_UNISWAP_ROUTER), amount\r\n          )\r\n        );\r\n      }\r\n\r\n      require(\r\n        success && (data.length == 0 || abi.decode(data, (bool))),\r\n        \"Token approval for Uniswap router failed.\"\r\n      );\r\n    }\r\n  }\r\n\r\n  function _tradeEtherForTokenWithFeeOnTransfer(\r\n    address tokenReceivedOrUSDCFlag,\r\n    uint256 etherAmount,\r\n    uint256 quotedTokenAmount,\r\n    uint256 quotedTokenAmountAfterTransferFee,\r\n    uint256 etherFeeAmount,\r\n    uint256 deadline,\r\n    bool fromReserves\r\n  ) internal returns (uint256 totalTokensBought) {\r\n    uint256 receivedAmountAfterTransferFee;\r\n\r\n    { // Scope to avoid stack too deep error.\r\n      // Set swap target token.\r\n      ERC20Interface tokenReceived = (\r\n        tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG\r\n          ? _USDC\r\n          : ERC20Interface(tokenReceivedOrUSDCFlag)\r\n      );\r\n\r\n      // Establish path from Ether to token.\r\n      (address[] memory path, ) = _createPathAndAmounts(\r\n        _WETH, address(tokenReceived), false\r\n      );\r\n\r\n      // Get this contract's balance in the output token prior to the trade.\r\n      uint256 priorReserveBalanceOfReceivedToken = tokenReceived.balanceOf(\r\n        address(this)\r\n      );\r\n\r\n      // Trade for the quoted token amount on Uniswap and send to this contract.\r\n      _UNISWAP_ROUTER.swapExactETHForTokensSupportingFeeOnTransferTokens.value(\r\n        etherAmount.sub(etherFeeAmount)\r\n      )(\r\n        quotedTokenAmount,\r\n        path,\r\n        address(this),\r\n        deadline\r\n      );\r\n\r\n      totalTokensBought = tokenReceived.balanceOf(address(this)).sub(\r\n        priorReserveBalanceOfReceivedToken\r\n      );\r\n\r\n      if (!fromReserves) {\r\n        // Get the caller's balance prior to the transfer.\r\n        uint256 priorRecipientBalanceOfReceivedToken = tokenReceived.balanceOf(\r\n          msg.sender\r\n        );\r\n\r\n        // Transfer the received tokens to the recipient.\r\n        _transferToken(tokenReceived, msg.sender, quotedTokenAmount);\r\n\r\n        receivedAmountAfterTransferFee = tokenReceived.balanceOf(msg.sender).sub(\r\n          priorRecipientBalanceOfReceivedToken\r\n        );\r\n\r\n        // Ensure that sufficient tokens were returned to the user.\r\n        require(\r\n          receivedAmountAfterTransferFee >= quotedTokenAmountAfterTransferFee,\r\n          \"Received token amount after transfer fee is less than quoted amount.\"\r\n        );\r\n      }\r\n    }\r\n\r\n    emit Trade(\r\n      fromReserves ? address(this) : msg.sender,\r\n      address(0),\r\n      tokenReceivedOrUSDCFlag,\r\n      address(0),\r\n      etherAmount,\r\n      totalTokensBought,\r\n      etherFeeAmount\r\n    );\r\n  }\r\n\r\n  function _tradeEtherForTokenWithFeeOnTransferLegacy(\r\n    address tokenReceivedOrUSDCFlag,\r\n    uint256 etherAmount,\r\n    uint256 quotedTokenAmount,\r\n    uint256 quotedTokenAmountAfterTransferFee,\r\n    uint256 deadline,\r\n    bool fromReserves\r\n  ) internal returns (uint256 totalTokensBought) {\r\n    uint256 retainedAmount;\r\n    uint256 receivedAmountAfterTransferFee;\r\n\r\n    // Set swap target token.\r\n    ERC20Interface tokenReceived = (\r\n      tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG\r\n        ? _USDC\r\n        : ERC20Interface(tokenReceivedOrUSDCFlag)\r\n    );\r\n\r\n    { // Scope to avoid stack too deep error.\r\n      // Establish path from Ether to token.\r\n      (address[] memory path, ) = _createPathAndAmounts(\r\n        _WETH, address(tokenReceived), false\r\n      );\r\n\r\n      // Get this contract's balance in the output token prior to the trade.\r\n      uint256 priorReserveBalanceOfReceivedToken = tokenReceived.balanceOf(\r\n        address(this)\r\n      );\r\n\r\n      // Trade for the quoted token amount on Uniswap and send to this contract.\r\n      _UNISWAP_ROUTER.swapExactETHForTokensSupportingFeeOnTransferTokens.value(\r\n        etherAmount\r\n      )(\r\n        quotedTokenAmount,\r\n        path,\r\n        address(this),\r\n        deadline\r\n      );\r\n\r\n      totalTokensBought = tokenReceived.balanceOf(address(this)).sub(\r\n        priorReserveBalanceOfReceivedToken\r\n      );\r\n      retainedAmount = totalTokensBought.sub(quotedTokenAmount);\r\n\r\n      if (!fromReserves) {\r\n        // Get the caller's balance prior to the transfer.\r\n        uint256 priorRecipientBalanceOfReceivedToken = tokenReceived.balanceOf(\r\n          msg.sender\r\n        );\r\n\r\n        // Transfer the received tokens to the recipient.\r\n        _transferToken(tokenReceived, msg.sender, quotedTokenAmount);\r\n\r\n        receivedAmountAfterTransferFee = tokenReceived.balanceOf(msg.sender).sub(\r\n          priorRecipientBalanceOfReceivedToken\r\n        );\r\n\r\n        // Ensure that sufficient tokens were returned to the user.\r\n        require(\r\n          receivedAmountAfterTransferFee >= quotedTokenAmountAfterTransferFee,\r\n          \"Received token amount after transfer fee is less than quoted amount.\"\r\n        );\r\n      }\r\n    }\r\n\r\n    emit Trade(\r\n      fromReserves ? address(this) : msg.sender,\r\n      address(0),\r\n      tokenReceivedOrUSDCFlag,\r\n      address(tokenReceived),\r\n      etherAmount,\r\n      quotedTokenAmountAfterTransferFee,\r\n      retainedAmount\r\n    );\r\n  }\r\n\r\n  /**\r\n  * @notice Internal trade function. If token is _TRADE_FOR_USDC_AND_RETAIN_FLAG,\r\n  * trade for USDC and retain the full output amount by replacing the recipient\r\n  * (\"to\" input) on the swapETHForExactTokens call.\r\n  */\r\n  function _tradeEtherForToken(\r\n    address tokenReceivedOrUSDCFlag,\r\n    uint256 etherAmount,\r\n    uint256 quotedTokenAmount,\r\n    uint256 deadline,\r\n    bool fromReserves\r\n  ) internal returns (uint256 totalEtherSold) {\r\n    // Set swap target token.\r\n    address tokenReceived = (\r\n      tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG\r\n        ? address(_USDC)\r\n        : tokenReceivedOrUSDCFlag\r\n    );\r\n\r\n    // Establish path from Ether to token.\r\n    (address[] memory path, uint256[] memory amounts) = _createPathAndAmounts(\r\n      _WETH, tokenReceived, false\r\n    );\r\n\r\n    // Trade Ether for quoted token amount and send to appropriate recipient.\r\n    amounts = _UNISWAP_ROUTER.swapETHForExactTokens.value(etherAmount)(\r\n      quotedTokenAmount,\r\n      path,\r\n      fromReserves || tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG\r\n        ? address(this)\r\n        : msg.sender,\r\n      deadline\r\n    );\r\n    totalEtherSold = amounts[0];\r\n  }\r\n\r\n  /**\r\n  * @notice Internal trade function. If token is _TRADE_FOR_USDC_AND_RETAIN_FLAG,\r\n  * trade for USDC and retain the full output amount by replacing the recipient\r\n  * (\"to\" input) on the swapETHForExactTokens call.\r\n  */\r\n  function _tradeExactEtherForToken(\r\n    address tokenReceivedOrUSDCFlag,\r\n    uint256 etherAmount,\r\n    uint256 quotedTokenAmount,\r\n    uint256 deadline,\r\n    bool fromReserves\r\n  ) internal returns (uint256 totalTokensBought) {\r\n    // Set swap target token.\r\n    address tokenReceived = (\r\n      tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG\r\n        ? address(_USDC)\r\n        : tokenReceivedOrUSDCFlag\r\n    );\r\n\r\n    // Establish path from Ether to token.\r\n    (address[] memory path, uint256[] memory amounts) = _createPathAndAmounts(\r\n      _WETH, tokenReceived, false\r\n    );\r\n\r\n    // Trade Ether for quoted token amount and send to appropriate recipient.\r\n    amounts = _UNISWAP_ROUTER.swapExactETHForTokens.value(etherAmount)(\r\n      quotedTokenAmount,\r\n      path,\r\n      fromReserves || tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG\r\n        ? address(this)\r\n        : msg.sender,\r\n      deadline\r\n    );\r\n    totalTokensBought = amounts[1];\r\n  }\r\n\r\n  function _tradeTokenForEther(\r\n    ERC20Interface token,\r\n    uint256 tokenAmount,\r\n    uint256 tokenAmountAfterTransferFee,\r\n    uint256 quotedEtherAmount,\r\n    uint256 deadline\r\n  ) internal returns (uint256 totalEtherBought) {\r\n    // Approve Uniswap router to transfer tokens on behalf of this contract.\r\n    _grantUniswapRouterApprovalIfNecessary(token, tokenAmount);\r\n\r\n    // Establish path from target token to Ether.\r\n    (address[] memory path, uint256[] memory amounts) = _createPathAndAmounts(\r\n      address(token), _WETH, false\r\n    );\r\n\r\n    // Trade tokens for quoted Ether amount on Uniswap (send to this contract).\r\n    if (tokenAmount == tokenAmountAfterTransferFee) {\r\n      amounts = _UNISWAP_ROUTER.swapExactTokensForETH(\r\n        tokenAmount, quotedEtherAmount, path, address(this), deadline\r\n      );\r\n      totalEtherBought = amounts[1];\r\n    } else {\r\n      uint256 ethBalanceBeforeTrade = address(this).balance;\r\n      _UNISWAP_ROUTER.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        tokenAmountAfterTransferFee,\r\n        quotedEtherAmount,\r\n        path,\r\n        address(this),\r\n        deadline\r\n      );\r\n      totalEtherBought = address(this).balance.sub(ethBalanceBeforeTrade);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Internal trade function. If tokenReceived is _TRADE_FOR_USDC_AND_RETAIN_FLAG,\r\n  * trade for USDC and retain the full output amount by replacing the recipient\r\n  * (\"to\" input) on the swapTokensForExactTokens call.\r\n  */\r\n  function _tradeTokenForToken(\r\n    address account,\r\n    ERC20Interface tokenProvided,\r\n    address tokenReceivedOrUSDCFlag,\r\n    uint256 tokenProvidedAmount,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) internal returns (uint256 totalTokensBought) {\r\n    uint256 retainedAmount;\r\n    uint256 receivedAmount;\r\n    address tokenReceived;\r\n    address recipient;\r\n\r\n    // Approve Uniswap router to transfer tokens on behalf of this contract.\r\n    _grantUniswapRouterApprovalIfNecessary(tokenProvided, tokenProvidedAmount);\r\n\r\n    // Set recipient, swap target token\r\n    if (tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG) {\r\n      recipient = address(this);\r\n      tokenReceived = address(_USDC);\r\n    } else {\r\n      recipient = account;\r\n      tokenReceived = tokenReceivedOrUSDCFlag;\r\n    }\r\n\r\n    if (routeThroughEther == false) {\r\n      // Establish direct path between tokens.\r\n      (address[] memory path, uint256[] memory amounts) = _createPathAndAmounts(\r\n        address(tokenProvided), tokenReceived, false\r\n      );\r\n\r\n      // Trade for the quoted token amount on Uniswap and send to this contract.\r\n      amounts = _UNISWAP_ROUTER.swapExactTokensForTokens(\r\n        tokenProvidedAmount,\r\n        quotedTokenReceivedAmount,\r\n        path,\r\n        address(this),\r\n        deadline\r\n      );\r\n\r\n      totalTokensBought = amounts[1];\r\n\r\n      // Retain the lesser of either max fee or bought amount less quoted amount.\r\n      retainedAmount = maximumFeeAmount.min(\r\n        totalTokensBought.sub(quotedTokenReceivedAmount)\r\n      );\r\n      receivedAmount = totalTokensBought.sub(retainedAmount);\r\n    } else {\r\n      // Establish path between provided token and WETH.\r\n      (address[] memory path, uint256[] memory amounts) = _createPathAndAmounts(\r\n        address(tokenProvided), _WETH, false\r\n      );\r\n\r\n      // Trade all provided tokens for WETH on Uniswap and send to this contract.\r\n      amounts = _UNISWAP_ROUTER.swapExactTokensForTokens(\r\n        tokenProvidedAmount, maximumFeeAmount, path, address(this), deadline\r\n      );\r\n      retainedAmount = amounts[1];\r\n\r\n      // Establish path between WETH and received token.\r\n      (path, amounts) = _createPathAndAmounts(\r\n        _WETH, tokenReceived, false\r\n      );\r\n\r\n      // Trade bought WETH (less fee) for received token, send to this contract.\r\n      amounts = _UNISWAP_ROUTER.swapTokensForExactTokens(\r\n        retainedAmount.sub(maximumFeeAmount),\r\n        quotedTokenReceivedAmount,\r\n        path,\r\n        address(this),\r\n        deadline\r\n      );\r\n\r\n      totalTokensBought = amounts[1];\r\n      retainedAmount = maximumFeeAmount;\r\n      receivedAmount = totalTokensBought;\r\n    }\r\n\r\n    emit Trade(\r\n      account,\r\n      address(tokenProvided),\r\n      tokenReceivedOrUSDCFlag,\r\n      routeThroughEther ? _WETH : address(tokenReceived),\r\n      tokenProvidedAmount,\r\n      receivedAmount,\r\n      retainedAmount\r\n    );\r\n\r\n    if (account != address(this)) {\r\n      _transferToken(ERC20Interface(tokenReceived), account, receivedAmount);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Internal trade function. If tokenReceived is _TRADE_FOR_USDC_AND_RETAIN_FLAG,\r\n  * trade for USDC and retain the full output amount by replacing the recipient\r\n  * (\"to\" input) on the swapTokensForExactTokens call.\r\n  */\r\n  function _tradeTokenForTokenLegacy(\r\n    address account,\r\n    ERC20Interface tokenProvided,\r\n    address tokenReceivedOrUSDCFlag,\r\n    uint256 tokenProvidedAmount,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) internal returns (uint256 totalTokensSold) {\r\n    uint256 retainedAmount;\r\n    address tokenReceived;\r\n    address recipient;\r\n\r\n    // Approve Uniswap router to transfer tokens on behalf of this contract.\r\n    _grantUniswapRouterApprovalIfNecessary(tokenProvided, tokenProvidedAmount);\r\n\r\n    // Set recipient, swap target token\r\n    if (tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG) {\r\n      recipient = address(this);\r\n      tokenReceived = address(_USDC);\r\n    } else {\r\n      recipient = account;\r\n      tokenReceived = tokenReceivedOrUSDCFlag;\r\n    }\r\n\r\n    if (routeThroughEther == false) {\r\n      // Establish direct path between tokens.\r\n      (address[] memory path, uint256[] memory amounts) = _createPathAndAmounts(\r\n        address(tokenProvided), tokenReceived, false\r\n      );\r\n\r\n      // Trade for the quoted token amount on Uniswap and send to recipient.\r\n      amounts = _UNISWAP_ROUTER.swapTokensForExactTokens(\r\n        quotedTokenReceivedAmount,\r\n        tokenProvidedAmount,\r\n        path,\r\n        recipient,\r\n        deadline\r\n      );\r\n\r\n      totalTokensSold = amounts[0];\r\n      retainedAmount = tokenProvidedAmount.sub(totalTokensSold);\r\n    } else {\r\n      // Establish path between provided token and WETH.\r\n      (address[] memory path, uint256[] memory amounts) = _createPathAndAmounts(\r\n        address(tokenProvided), _WETH, false\r\n      );\r\n\r\n      // Trade all provided tokens for WETH on Uniswap and send to this contract.\r\n      amounts = _UNISWAP_ROUTER.swapExactTokensForTokens(\r\n        tokenProvidedAmount, 0, path, address(this), deadline\r\n      );\r\n      retainedAmount = amounts[1];\r\n\r\n      // Establish path between WETH and received token.\r\n      (path, amounts) = _createPathAndAmounts(\r\n        _WETH, tokenReceived, false\r\n      );\r\n\r\n      // Trade bought WETH for received token on Uniswap and send to recipient.\r\n      amounts = _UNISWAP_ROUTER.swapTokensForExactTokens(\r\n        quotedTokenReceivedAmount, retainedAmount, path, recipient, deadline\r\n      );\r\n\r\n      totalTokensSold = amounts[0];\r\n      retainedAmount = retainedAmount.sub(totalTokensSold);\r\n    }\r\n\r\n    emit Trade(\r\n      account,\r\n      address(tokenProvided),\r\n      tokenReceivedOrUSDCFlag,\r\n      routeThroughEther ? _WETH : address(tokenProvided),\r\n      tokenProvidedAmount,\r\n      quotedTokenReceivedAmount,\r\n      retainedAmount\r\n    );\r\n  }\r\n\r\n  /**\r\n  * @notice Internal trade function for cases where one of the tokens in\r\n  * question levies a transfer fee. If tokenReceived is\r\n  * _TRADE_FOR_USDC_AND_RETAIN_FLAG, trade for USDC and retain the full output\r\n  * amount by replacing the recipient (\"to\" input) on the\r\n  * swapTokensForExactTokens call.\r\n  */\r\n  function _tradeTokenForTokenWithFeeOnTransfer(\r\n    address account,\r\n    ERC20Interface tokenProvided,\r\n    address tokenReceivedOrUSDCFlag,\r\n    uint256 tokenProvidedAmount,\r\n    uint256 tokenProvidedAmountAfterTransferFee,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 quotedTokenReceivedAmountAfterTransferFee,\r\n    uint256 maximumFeeAmount,\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) internal returns (uint256 totalTokensBought) {\r\n    uint256 receivedAmountAfterTransferFee;\r\n    ERC20Interface tokenReceived;\r\n\r\n    // Approve Uniswap router to transfer tokens on behalf of this contract.\r\n    _grantUniswapRouterApprovalIfNecessary(\r\n      tokenProvided, tokenProvidedAmountAfterTransferFee\r\n    );\r\n\r\n    { // Scope to avoid stack too deep error.\r\n      address recipient;\r\n      // Set recipient, swap target token\r\n      if (tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG) {\r\n        recipient = address(this);\r\n        tokenReceived = ERC20Interface(_USDC);\r\n      } else {\r\n        recipient = account;\r\n        tokenReceived = ERC20Interface(tokenReceivedOrUSDCFlag);\r\n      }\r\n\r\n      // Establish path between tokens.\r\n      (address[] memory path, ) = _createPathAndAmounts(\r\n        address(tokenProvided), address(tokenReceived), routeThroughEther\r\n      );\r\n\r\n      // Get this contract's balance in the output token prior to the trade.\r\n      uint256 priorReserveBalanceOfReceivedToken = tokenReceived.balanceOf(\r\n        address(this)\r\n      );\r\n\r\n      // Trade for the quoted token amount on Uniswap and send to this contract.\r\n      _UNISWAP_ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        tokenProvidedAmountAfterTransferFee,\r\n        quotedTokenReceivedAmount,\r\n        path,\r\n        address(this),\r\n        deadline\r\n      );\r\n\r\n      totalTokensBought = tokenReceived.balanceOf(address(this)).sub(\r\n        priorReserveBalanceOfReceivedToken\r\n      );\r\n\r\n      if (recipient != address(this)) {\r\n        // Get the receiver's balance prior to the transfer.\r\n        uint256 priorRecipientBalanceOfReceivedToken = tokenReceived.balanceOf(\r\n          recipient\r\n        );\r\n\r\n        // Transfer the received tokens (less the fee) to the recipient.\r\n        _transferToken(\r\n          tokenReceived, recipient, totalTokensBought.sub(maximumFeeAmount)\r\n        );\r\n\r\n        receivedAmountAfterTransferFee = tokenReceived.balanceOf(recipient).sub(\r\n          priorRecipientBalanceOfReceivedToken\r\n        );\r\n\r\n        // Ensure that sufficient tokens were returned to the user.\r\n        require(\r\n          receivedAmountAfterTransferFee >= quotedTokenReceivedAmountAfterTransferFee,\r\n          \"Received token amount after transfer fee is less than quoted amount.\"\r\n        );\r\n      } else {\r\n        receivedAmountAfterTransferFee = totalTokensBought.sub(maximumFeeAmount);\r\n      }\r\n    }\r\n\r\n    emit Trade(\r\n      account,\r\n      address(tokenProvided),\r\n      tokenReceivedOrUSDCFlag,\r\n      address(tokenReceived),\r\n      tokenProvidedAmount,\r\n      receivedAmountAfterTransferFee,\r\n      maximumFeeAmount\r\n    );\r\n  }\r\n\r\n  /**\r\n  * @notice Internal trade function for cases where one of the tokens in\r\n  * question levies a transfer fee. If tokenReceived is\r\n  * _TRADE_FOR_USDC_AND_RETAIN_FLAG, trade for USDC and retain the full output\r\n  * amount by replacing the recipient (\"to\" input) on the\r\n  * swapTokensForExactTokens call.\r\n  */\r\n  function _tradeTokenForTokenWithFeeOnTransferLegacy(\r\n    address account,\r\n    ERC20Interface tokenProvided,\r\n    address tokenReceivedOrUSDCFlag,\r\n    uint256 tokenProvidedAmount,\r\n    uint256 tokenProvidedAmountAfterTransferFee,\r\n    uint256 quotedTokenReceivedAmount,\r\n    uint256 quotedTokenReceivedAmountAfterTransferFee,\r\n    uint256 deadline,\r\n    bool routeThroughEther\r\n  ) internal returns (uint256 totalTokensBought) {\r\n    uint256 retainedAmount;\r\n    uint256 receivedAmountAfterTransferFee;\r\n    ERC20Interface tokenReceived;\r\n\r\n    // Approve Uniswap router to transfer tokens on behalf of this contract.\r\n    _grantUniswapRouterApprovalIfNecessary(\r\n      tokenProvided, tokenProvidedAmountAfterTransferFee\r\n    );\r\n\r\n    { // Scope to avoid stack too deep error.\r\n      address recipient;\r\n      // Set recipient, swap target token\r\n      if (tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG) {\r\n        recipient = address(this);\r\n        tokenReceived = ERC20Interface(_USDC);\r\n      } else {\r\n        recipient = account;\r\n        tokenReceived = ERC20Interface(tokenReceivedOrUSDCFlag);\r\n      }\r\n\r\n      // Establish path between tokens.\r\n      (address[] memory path, ) = _createPathAndAmounts(\r\n        address(tokenProvided), address(tokenReceived), routeThroughEther\r\n      );\r\n\r\n      // Get this contract's balance in the output token prior to the trade.\r\n      uint256 priorReserveBalanceOfReceivedToken = tokenReceived.balanceOf(\r\n        address(this)\r\n      );\r\n\r\n      // Trade for the quoted token amount on Uniswap and send to this contract.\r\n      _UNISWAP_ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        tokenProvidedAmountAfterTransferFee,\r\n        quotedTokenReceivedAmount,\r\n        path,\r\n        address(this),\r\n        deadline\r\n      );\r\n\r\n      totalTokensBought = tokenReceived.balanceOf(address(this)).sub(\r\n        priorReserveBalanceOfReceivedToken\r\n      );\r\n      retainedAmount = totalTokensBought.sub(quotedTokenReceivedAmount);\r\n\r\n      // Get the receiver's balance prior to the transfer.\r\n      uint256 priorRecipientBalanceOfReceivedToken = tokenReceived.balanceOf(\r\n        recipient\r\n      );\r\n\r\n      // Transfer the received tokens to the recipient.\r\n      _transferToken(tokenReceived, recipient, quotedTokenReceivedAmount);\r\n\r\n      receivedAmountAfterTransferFee = tokenReceived.balanceOf(recipient).sub(\r\n        priorRecipientBalanceOfReceivedToken\r\n      );\r\n\r\n      // Ensure that sufficient tokens were returned to the user.\r\n      require(\r\n        receivedAmountAfterTransferFee >= quotedTokenReceivedAmountAfterTransferFee,\r\n        \"Received token amount after transfer fee is less than quoted amount.\"\r\n      );\r\n    }\r\n\r\n    emit Trade(\r\n      account,\r\n      address(tokenProvided),\r\n      tokenReceivedOrUSDCFlag,\r\n      address(tokenReceived),\r\n      tokenProvidedAmount,\r\n      receivedAmountAfterTransferFee,\r\n      retainedAmount\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to set a new account on a given role and emit a\r\n   * `RoleModified` event if the role holder has changed.\r\n   * @param role The role that the account will be set for. Permitted roles are\r\n   * deposit manager (0), adjuster (1), and pauser (2).\r\n   * @param account The account to set as the designated role bearer.\r\n   */\r\n  function _setRole(Role role, address account) internal {\r\n    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\r\n\r\n    if (account != storedRoleStatus.account) {\r\n      storedRoleStatus.account = account;\r\n      emit RoleModified(role, account);\r\n    }\r\n  }\r\n\r\n  function _fireTradeEvent(\r\n    bool fromReserves,\r\n    bool supplyingEther,\r\n    address token,\r\n    uint256 suppliedAmount,\r\n    uint256 receivedAmount,\r\n    uint256 retainedAmount\r\n  ) internal {\r\n    emit Trade(\r\n      fromReserves ? address(this) : msg.sender,\r\n      supplyingEther ? address(0) : token,\r\n      supplyingEther ? token : address(0),\r\n      address(0),\r\n      suppliedAmount,\r\n      receivedAmount,\r\n      retainedAmount\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function to check whether the caller is the current\r\n   * role holder.\r\n   * @param role The role to check for.\r\n   * @return A boolean indicating if the caller has the specified role.\r\n   */\r\n  function _isRole(Role role) internal view returns (bool hasRole) {\r\n    hasRole = msg.sender == _roles[uint256(role)].account;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function to check whether the given role is paused or\r\n   * not.\r\n   * @param role The role to check for.\r\n   * @return A boolean indicating if the specified role is paused or not.\r\n   */\r\n  function _isPaused(Role role) internal view returns (bool paused) {\r\n    paused = _roles[uint256(role)].paused;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function to enforce that the given initial user signing\r\n   * key resolves to the given smart wallet when deployed through the Dharma Smart\r\n   * Wallet Factory V1. (staging version)\r\n   * @param smartWallet address The smart wallet.\r\n   * @param initialUserSigningKey address The initial user signing key.\r\n   */\r\n  function _isSmartWallet(\r\n    address smartWallet, address initialUserSigningKey\r\n  ) internal pure returns (bool) {\r\n    // Derive the keccak256 hash of the smart wallet initialization code.\r\n    bytes32 initCodeHash = keccak256(\r\n      abi.encodePacked(\r\n        _WALLET_CREATION_CODE_HEADER,\r\n        initialUserSigningKey,\r\n        _WALLET_CREATION_CODE_FOOTER\r\n      )\r\n    );\r\n\r\n    // Attempt to derive a smart wallet address that matches the one provided.\r\n    address target;\r\n    for (uint256 nonce = 0; nonce < 10; nonce++) {\r\n      target = address(          // derive the target deployment address.\r\n        uint160(                 // downcast to match the address type.\r\n          uint256(               // cast to uint to truncate upper digits.\r\n            keccak256(           // compute CREATE2 hash using all inputs.\r\n              abi.encodePacked(  // pack all inputs to the hash together.\r\n                _CREATE2_HEADER, // pass in control character + factory address.\r\n                nonce,           // pass in current nonce as the salt.\r\n                initCodeHash     // pass in hash of contract creation code.\r\n              )\r\n            )\r\n          )\r\n        )\r\n      );\r\n\r\n      // Exit early if the provided smart wallet matches derived target address.\r\n      if (target == smartWallet) {\r\n        return true;\r\n      }\r\n\r\n      // Otherwise, increment the nonce and derive a new salt.\r\n      nonce++;\r\n    }\r\n\r\n    // Explicity recognize no target was found matching provided smart wallet.\r\n    return false;\r\n  }\r\n\r\n  function _transferToken(ERC20Interface token, address to, uint256 amount) internal {\r\n    (bool success, bytes memory data) = address(token).call(\r\n      abi.encodeWithSelector(token.transfer.selector, to, amount)\r\n    );\r\n    require(\r\n      success && (data.length == 0 || abi.decode(data, (bool))),\r\n      'Transfer out failed.'\r\n    );\r\n  }\r\n\r\n  function _transferEther(address recipient, uint256 etherAmount) internal {\r\n    // Send quoted Ether amount to recipient and revert with reason on failure.\r\n    (bool ok, ) = recipient.call.value(etherAmount)(\"\");\r\n    if (!ok) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize)\r\n        revert(0, returndatasize)\r\n      }\r\n    }\r\n  }\r\n\r\n  function _transferInToken(ERC20Interface token, address from, uint256 amount) internal {\r\n    (bool success, bytes memory data) = address(token).call(\r\n      abi.encodeWithSelector(token.transferFrom.selector, from, address(this), amount)\r\n    );\r\n\r\n    require(\r\n      success && (data.length == 0 || abi.decode(data, (bool))),\r\n      'Transfer in failed.'\r\n    );\r\n  }\r\n\r\n  function _delegate(address implementation) private {\r\n    assembly {\r\n      calldatacopy(0, 0, calldatasize)\r\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n      returndatacopy(0, 0, returndatasize)\r\n      switch result\r\n      case 0 { revert(0, returndatasize) }\r\n      default { return(0, returndatasize) }\r\n    }\r\n  }\r\n\r\n  function _ensureSmartWallet(\r\n    address smartWallet, address initialUserSigningKey\r\n  ) internal pure {\r\n    require(\r\n      _isSmartWallet(smartWallet, initialUserSigningKey),\r\n      \"Could not resolve smart wallet using provided signing key.\"\r\n    );\r\n  }\r\n\r\n  function _createPathAndAmounts(\r\n    address start, address end, bool routeThroughEther\r\n  ) internal pure returns (address[] memory, uint256[] memory) {\r\n    uint256 pathLength = routeThroughEther ? 3 : 2;\r\n    address[] memory path = new address[](pathLength);\r\n    path[0] = start;\r\n\r\n    if (routeThroughEther) {\r\n      path[1] = _WETH;\r\n    }\r\n\r\n    path[pathLength - 1] = end;\r\n\r\n    return (path, new uint256[](pathLength));\r\n  }\r\n\r\n  /**\r\n   * @notice Modifier that throws if called by any account other than the owner\r\n   * or the supplied role, or if the caller is not the owner and the role in\r\n   * question is paused.\r\n   * @param role The role to require unless the caller is the owner.\r\n   */\r\n  modifier onlyOwnerOr(Role role) {\r\n    if (!isOwner()) {\r\n      require(_isRole(role), \"Caller does not have a required role.\");\r\n      require(!_isPaused(role), \"Role in question is currently paused.\");\r\n    }\r\n    _;\r\n  }\r\n}"}}}