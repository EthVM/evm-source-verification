{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "LockGTON.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./interfaces/ILockGTON.sol\";\n\n/// @title LockGTON\n/// @author Artemij Artamonov - <array.clean@gmail.com>\n/// @author Anton Davydov - <fetsorn@gmail.com>\ncontract LockGTON is ILockGTON {\n    /// @inheritdoc ILockGTON\n    address public override owner;\n\n    modifier isOwner() {\n        require(msg.sender == owner, \"ACW\");\n        _;\n    }\n\n    /// @inheritdoc ILockGTON\n    IERC20 public override governanceToken;\n\n    /// @inheritdoc ILockGTON\n    bool public override canLock;\n\n    constructor(IERC20 _governanceToken) {\n        owner = msg.sender;\n        governanceToken = _governanceToken;\n    }\n\n    /// @inheritdoc ILockGTON\n    function setOwner(address _owner) external override isOwner {\n        address ownerOld = owner;\n        owner = _owner;\n        emit SetOwner(ownerOld, _owner);\n    }\n\n    /// @inheritdoc ILockGTON\n    function setCanLock(bool _canLock) external override isOwner {\n        canLock = _canLock;\n        emit SetCanLock(owner, _canLock);\n    }\n\n    /// @inheritdoc ILockGTON\n    function migrate(address newLock) external override isOwner {\n        uint256 amount = governanceToken.balanceOf(address(this));\n        governanceToken.transfer(newLock, amount);\n        emit Migrate(newLock, amount);\n    }\n\n    /// @inheritdoc ILockGTON\n    function lock(uint256 amount) external override {\n        require(canLock, \"LG1\");\n        governanceToken.transferFrom(msg.sender, address(this), amount);\n        emit LockGTON(address(governanceToken), msg.sender, msg.sender, amount);\n    }\n}\n"
    },
    "interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\ninterface IERC20 {\n    function mint(address _to, uint256 _value) external;\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        external\n        returns (bool);\n\n    function transfer(address _to, uint256 _value)\n        external\n        returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n}\n"
    },
    "interfaces/ILockGTON.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./IERC20.sol\";\n\n/// @title The interface for Graviton governance token lock\n/// @notice Locks governance tokens\n/// @author Artemij Artamonov - <array.clean@gmail.com>\n/// @author Anton Davydov - <fetsorn@gmail.com>\ninterface ILockGTON {\n    /// @notice User that can grant access permissions and perform privileged actions\n    function owner() external view returns (address);\n\n    /// @notice Transfers ownership of the contract to a new account (`_owner`).\n    /// @dev Can only be called by the current owner.\n    function setOwner(address _owner) external;\n\n    /// @notice Look up if locking is allowed\n    function canLock() external view returns (bool);\n\n    /// @notice Sets the permission to lock to `_canLock`\n    function setCanLock(bool _canLock) external;\n\n    /// @notice Address of the governance token\n    function governanceToken() external view returns (IERC20);\n\n    /// @notice Transfers locked governance tokens to the next version of LockGTON\n    function migrate(address newLock) external;\n\n    /// @notice Locks `amount` of governance tokens\n    function lock(uint256 amount) external;\n\n    /// @notice Event emitted when the owner changes via `#setOwner`.\n    /// @param ownerOld The account that was the previous owner of the contract\n    /// @param ownerNew The account that became the owner of the contract\n    event SetOwner(address indexed ownerOld, address indexed ownerNew);\n\n    /// @notice Event emitted when the `sender` locks `amount` of governance tokens\n    /// @dev LockGTON event is not called Lock so the topic0 is different\n    /// from the lp-token locking event when parsed by the oracle parser\n    /// @param governanceToken The address of governance token\n    /// @dev governanceToken is specified so the event has the same number of topics\n    /// as the lp-token locking event when parsed by the oracle parser\n    /// @param sender The account that locked governance tokens\n    /// @param receiver The account to whose governance balance the tokens are added\n    /// @dev receiver is always same as sender, kept for compatibility\n    /// @param amount The amount of governance tokens locked\n    event LockGTON(\n        address indexed governanceToken,\n        address indexed sender,\n        address indexed receiver,\n        uint256 amount\n    );\n\n    /// @notice Event emitted when the permission to lock is updated via `#setCanLock`\n    /// @param owner The owner account at the time of change\n    /// @param newBool Updated permission\n    event SetCanLock(address indexed owner, bool indexed newBool);\n\n    /// @notice Event emitted when the locked governance tokens are transfered the another version of LockGTON\n    /// @param newLock The new Lock contract\n    /// @param amount Amount of tokens migrated\n    event Migrate(address indexed newLock, uint256 amount);\n}\n"
    }
  }
}