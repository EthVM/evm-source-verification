{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Stake.sol": {
      "content": "pragma experimental ABIEncoderV2;\r\npragma solidity >=0.4.22 <0.7.0;\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token SafeMath\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\ncontract TokenStake {\r\n    using SafeMath for uint;\r\n    using SafeMath for uint256;\r\n    \r\n    address public _owner;\r\n    address public _token;\r\n    uint public _apr;\r\n    uint public _aprPerDay;\r\n    uint public  thousand = 1000000;\r\n    uint256 public _poolLimit = 50e18;\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    event NewStake(address indexed account, uint indexed amount, uint indexed year);\r\n    event ClaimStake(address indexed account,uint indexed stakeId, uint indexed amount);\r\n    event UnLockStake(address indexed account, uint indexed stakeId);\r\n    struct Stake {\r\n        uint year; // total year;\r\n        uint256 amount;\r\n        uint timeDeposit;\r\n        uint256 claimed;\r\n        uint256 reward;\r\n        uint256 apr;\r\n        bool locked;\r\n        bool openLockForce;\r\n        \r\n    }\r\n    bool _openLockForce = false;\r\n    mapping(address => Stake[]) public _staker;\r\n    address [] public _activeAddress;\r\n    bool public _freeze = false;\r\n    modifier ownerOnly () {\r\n        require(msg.sender == _owner, \"NO_ACCESS\");\r\n        _;\r\n    }\r\n    \r\n    modifier notFreezing() {\r\n        require(_freeze == false, \"ITS_COLD\");\r\n        _;\r\n    }\r\n    constructor (address tokenERC, uint aprPercentage, uint256 poolLimit) public {\r\n        _token = tokenERC;\r\n        _apr = aprPercentage * thousand;\r\n        _aprPerDay = _apr / 365;\r\n        _owner = msg.sender; \r\n        _poolLimit = poolLimit;\r\n        emit OwnerSet(address(0), _owner);\r\n    }\r\n    function getApr() public view returns(uint256) {\r\n        return _apr;\r\n    }\r\n    function getPoolLimit() public view returns(uint256) {\r\n        return _poolLimit;\r\n    }\r\n    function getPoolLockForce() public view returns(bool) {\r\n        return _openLockForce;\r\n    }\r\n    function startStake(uint256 amount, uint year) public  notFreezing returns (uint) {\r\n        require(amount >= 1 ether, \"MIN_1_TOKEN\");\r\n        require(year > 0, \"MIN_1_YEAR\");\r\n        require((amount % 1 ether) == 0, \"1_INTERVAL\");\r\n        require(totalPoolToken().add(amount) <= _poolLimit, \"POOL_LIMIT\");\r\n        uint reward = (amount * (_apr / 100)) * year;\r\n        if(_staker[msg.sender].length == 0) {\r\n            _activeAddress.push(msg.sender);\r\n        }\r\n        _staker[msg.sender].push(Stake({\r\n            year: year,\r\n            amount: amount,\r\n            timeDeposit: now,\r\n            claimed: 0,\r\n            reward: reward,\r\n            apr: _apr,\r\n            locked: true,\r\n            openLockForce: false\r\n        }));\r\n        ERC20(_token).transferFrom(msg.sender, address(this), amount);\r\n        emit NewStake(msg.sender, amount, year);\r\n        return reward;\r\n    }\r\n    function stakesOf(address account) public view returns(Stake [] memory){\r\n        return _staker[account];\r\n    }\r\n    function claimStake(uint id) public notFreezing returns  (bool) {\r\n        uint claim = stakeCanClaim(msg.sender, id);\r\n        require(claim > 0, \"NOTHING_CAN_CLAIM\");\r\n        require(_staker[msg.sender][id].claimed.add(claim) <= _staker[msg.sender][id].reward  , \"hmm is this bug ?\");\r\n        _staker[msg.sender][id].claimed = _staker[msg.sender][id].claimed.add(claim);\r\n        ERC20(_token).transfer(msg.sender, claim / thousand);\r\n        emit ClaimStake(msg.sender, id, claim);\r\n        return true;\r\n    }\r\n    function unlockStake(uint stakeId) public notFreezing returns (bool) {\r\n        require(_staker[msg.sender][stakeId].locked == true, \"ALREADY_CLAIMED\");\r\n        if(_staker[msg.sender][stakeId].openLockForce == true) {\r\n            ERC20(_token).transfer(msg.sender, _staker[msg.sender][stakeId].amount);\r\n            _staker[msg.sender][stakeId].locked = false;\r\n            emit UnLockStake(msg.sender, stakeId);\r\n            return true;\r\n        }\r\n        uint totalDay = (now - _staker[msg.sender][stakeId].timeDeposit) / 86400;\r\n        if(totalDay > _staker[msg.sender][stakeId].year * 365) {\r\n            ERC20(_token).transfer(msg.sender, _staker[msg.sender][stakeId].amount);\r\n            _staker[msg.sender][stakeId].locked = false;\r\n            emit UnLockStake(msg.sender, stakeId);\r\n            return true;\r\n        }\r\n        \r\n    }\r\n    function stakeCanClaim(address account, uint id) public view returns (uint) {\r\n        require(_staker[account][id].amount > 0, \"NO_CLAIM_AVAILABLE\");\r\n        Stake memory tk = _staker[account][id];\r\n        uint totalDay = (now-tk.timeDeposit) / 1 days;\r\n        uint totalDayReward = (_aprPerDay * totalDay) / 100;\r\n        uint reward = tk.amount * totalDayReward;\r\n        uint claimable = (reward > tk.reward ? tk.reward : reward) - tk.claimed;\r\n        return claimable;\r\n    }\r\n    /*\r\n        get active\r\n    */\r\n    function totalActiveAddressCount() public view returns (uint) {\r\n        return _activeAddress.length;\r\n    }\r\n    function totalPoolToken() public view returns (uint) {\r\n        uint total;\r\n        for(uint a = 0; a < _activeAddress.length; a++){\r\n            for(uint b = 0; b < _staker[_activeAddress[a]].length; b++) {\r\n                total = total + _staker[_activeAddress[a]][b].amount;\r\n            }\r\n        }\r\n        return total;\r\n    }\r\n    /* OWNER FEATURE */\r\n    // ANTI HAZARD WHEN SOMETHING WENT WRONG IN BETA \r\n    function withdrawToken(uint256 amount) public ownerOnly returns (bool) {\r\n        ERC20(_token).transfer(msg.sender, amount);\r\n        return true;\r\n    }\r\n    // SET FREEZE COLD BZZZZZ\r\n    function setFreeze(bool freezeStatus) public ownerOnly returns (bool) {\r\n        _freeze = freezeStatus;\r\n        return true;\r\n    }\r\n    function setOpenLockForce(bool lockForce) public ownerOnly returns (bool) {\r\n        _openLockForce = lockForce;\r\n        return true;\r\n    }\r\n    function setOpenLockForce(address account, uint stakeId, bool lockForce) public ownerOnly returns (bool) {\r\n        _staker[account][stakeId].openLockForce = lockForce;\r\n        return true;\r\n    }\r\n    function setAPR(uint aprPercentage) public ownerOnly returns (bool) {\r\n        _apr = aprPercentage * thousand;\r\n        _aprPerDay = _apr / 365;\r\n        return true;\r\n    }\r\n    function setPoolLimit(uint256 limit) public ownerOnly returns (bool) {\r\n        _poolLimit = limit;\r\n        return true;\r\n    }\r\n    function setOwner(address newOwner) public ownerOnly returns (bool) {\r\n        _owner = newOwner;\r\n        return true;\r\n    }\r\n    \r\n}"
    }
  }
}