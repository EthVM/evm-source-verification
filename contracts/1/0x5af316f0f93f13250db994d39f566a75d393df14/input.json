{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/planckx/XRelease.sol":{"content":"pragma solidity 0.7.0; \r\n\r\ninterface IERC20 {\r\n    function transferFrom(address _token, address _from, address _to, uint256 _value) external returns (bool success);\r\n    function transfer(address _token, address _to, uint256 _value) external returns (bool success);\r\n}\r\n\r\ninterface ERC20 {\r\n    function allowance(address owner, address spender) external returns (uint256 amount);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract Release{\r\n    \r\n    mapping(address => uint256[]) productIdxs;\r\n    \r\n    mapping(uint256 => Lock) locks;\r\n    \r\n    mapping(uint256 => uint256[]) releasess;\r\n    \r\n    mapping(uint256 => uint256[]) amountss;\r\n\r\n    uint256 productIdx = 0;\r\n    \r\n    address immutable auer = msg.sender;\r\n    \r\n    address transferAddress = address(0);\r\n    \r\n    struct Lock{\r\n        address tokenAddress;\r\n        address toAddress;\r\n        uint256 amountMax;\r\n        uint256 amountWithDraw;\r\n    }\r\n    \r\n    constructor(){\r\n        \r\n    }\r\n    \r\n    function initRelease(address transfer) public {\r\n        require(auer == msg.sender, \"no author\");\r\n        require(transferAddress == address(0), \"have init\");\r\n        transferAddress = transfer;\r\n    }\r\n  \r\n    function lockPosition(\r\n        address tokenAddress,\r\n        address toAddress,\r\n        uint256[] memory releases,\r\n        uint256[] memory amounts) public{\r\n        require(auer == msg.sender, \"no author\");\r\n        require(toAddress != address(0),\"no owner\");\r\n        require(releases.length>0 && releases.length == amounts.length,\"releases or amounts error\");\r\n        for(uint256 j = 0;j < releases.length;j++){\r\n            require(releases[j] > block.timestamp,\"releases error\");\r\n        }\r\n        uint256 amountMax = 0;\r\n        for(uint256 i = 0;i < amounts.length;i++){\r\n            amountMax = amountMax + amounts[i]; \r\n        }\r\n        require(amountMax > 0,\"amounts error\");\r\n        require(ERC20(tokenAddress).allowance(msg.sender,transferAddress) >= amountMax,\"approve error\");\r\n        IERC20(transferAddress).transferFrom(tokenAddress,msg.sender, transferAddress , amountMax);\r\n        Lock memory lk = Lock(tokenAddress,toAddress,amountMax,0);\r\n        locks[productIdx] = lk;\r\n        releasess[productIdx] = releases;\r\n        amountss[productIdx] = amounts;\r\n        if(productIdxs[toAddress].length > 0){\r\n            productIdxs[toAddress].push(productIdx);\r\n        }else{\r\n            productIdxs[toAddress] = [productIdx];\r\n        }\r\n        productIdx = productIdx + 1;\r\n    }\r\n\r\n    function withdraw(address tokenAddress) public {\r\n        require(productIdxs[msg.sender].length > 0,\"no release\");\r\n        bool flag = false;\r\n        for(uint256 i = 0;i < getLockLength(msg.sender);i++){\r\n            Lock memory lk = locks[productIdxs[msg.sender][i]];\r\n            if(lk.tokenAddress == tokenAddress){\r\n                uint256 total = ERC20(tokenAddress).balanceOf(transferAddress);\r\n                uint256[] memory releases = releasess[productIdxs[msg.sender][i]];\r\n                uint256[] memory amounts = amountss[productIdxs[msg.sender][i]];\r\n                uint256 amountNow = 0;\r\n                for(uint256 j = 0;j < releases.length;j++){\r\n                    if(block.timestamp >= releases[j]){\r\n                        amountNow = amountNow + amounts[j];\r\n                    }\r\n                }\r\n                if(lk.amountWithDraw < lk.amountMax && lk.amountWithDraw < amountNow && total >= amountNow - lk.amountWithDraw){\r\n                    flag = true;\r\n                    locks[productIdxs[msg.sender][i]].amountWithDraw = amountNow;\r\n                    IERC20(transferAddress).transfer(tokenAddress,msg.sender, amountNow - lk.amountWithDraw);\r\n                }\r\n            }\r\n        }\r\n        require(flag,\"no withdraw\");\r\n    }\r\n    \r\n    function getBlockTime() public view virtual returns (uint256){\r\n        return block.timestamp;\r\n    }\r\n\r\n    function getLockLength(address fromAddress) public view virtual returns (uint256){\r\n        return productIdxs[fromAddress].length;\r\n    }\r\n    \r\n    function getReleases(address fromAddress,uint256 idx) public view virtual returns (uint256[] memory){\r\n        require(getLockLength(fromAddress) > idx,\"no lockPosition\");\r\n        return releasess[productIdxs[fromAddress][idx]];\r\n    }\r\n    \r\n    function getAmounts(address fromAddress,uint256 idx) public view virtual returns (uint256[] memory){\r\n        require(getLockLength(fromAddress) > idx,\"no lockPosition\");\r\n        return amountss[productIdxs[fromAddress][idx]];\r\n    }\r\n     \r\n    function getLocks(address fromAddress,uint256 idx) public view virtual returns (uint256[] memory){\r\n        require(getLockLength(fromAddress) > idx,\"no lockPosition\");\r\n        Lock memory lk = locks[productIdxs[fromAddress][idx]];\r\n        uint256[] memory lock = new uint256[](2);\r\n        lock[0] = lk.amountMax;\r\n        lock[1] = lk.amountWithDraw;\r\n        return lock;\r\n    }\r\n    \r\n    function getTokenAddress(address fromAddress,uint256 idx) public view virtual returns (address){\r\n        require(getLockLength(fromAddress) > idx,\"no lockPosition\");\r\n        Lock memory lk = locks[productIdxs[fromAddress][idx]];\r\n        return lk.tokenAddress;\r\n    }\r\n    \r\n    function getLastRelease(address fromAddress,address tokenAddress) public view virtual returns (uint256){\r\n        uint256 release = 0;\r\n        for(uint256 i = 0;i < getLockLength(fromAddress);i++){\r\n            Lock memory lk = locks[productIdxs[fromAddress][i]];\r\n            if(lk.tokenAddress == tokenAddress){\r\n                if(lk.amountMax > lk.amountWithDraw){\r\n                    release = release + lk.amountMax - lk.amountWithDraw;\r\n                }\r\n            }\r\n        }\r\n        return release;\r\n    }\r\n}"}}}