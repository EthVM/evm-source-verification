{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "HelloKeeperDAO.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\r\n/** MIT License of code referenced:\r\n * \r\n * Copyright (c) 2020 Talo Research Pte. Ltd.\r\n *\r\n *Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n *this software and associated documentation files (the \"Software\"), to deal in\r\n *the Software without restriction, including without limitation the rights to\r\n *use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n *the Software, and to permit persons to whom the Software is furnished to do so,\r\n *subject to the following conditions:\r\n *\r\n *The above copyright notice and this permission notice shall be included in all\r\n *copies or substantial portions of the Software.\r\n *\r\n *THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n *FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n *COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n *IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n *CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n \r\npragma solidity >=0.4.21 <0.7.0;\r\n\r\n/// @dev This interfaces defines the functions of the KeeperDAO liquidity pool\r\n/// that our contract needs to know about. The only function we need is the\r\n/// borrow function, which allows us to take flash loans from the liquidity\r\n/// pool.\r\ninterface LiquidityPool {\r\n    /// @dev Borrow ETH/ERC20s from the liquidity pool. This function will (1)\r\n    /// send an amount of tokens to the `msg.sender`, (2) call\r\n    /// `msg.sender.call(_data)` from the KeeperDAO borrow proxy, and then (3)\r\n    /// check that the balance of the liquidity pool is greater than it was\r\n    /// before the borrow.\r\n    ///\r\n    /// @param _token The address of the ERC20 to be borrowed. ETH can be\r\n    /// borrowed by specifying \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\".\r\n    /// @param _amount The amount of the ERC20 (or ETH) to be borrowed. At least\r\n    /// more than this amount must be returned to the liquidity pool before the\r\n    /// end of the transaction, otherwise the transaction will revert.\r\n    /// @param _data The calldata that encodes the callback to be called on the\r\n    /// `msg.sender`. This is the mechanism through which the borrower is able\r\n    /// to implement their custom keeper logic. The callback will be called from\r\n    /// the KeeperDAO borrow proxy.\r\n    function borrow(\r\n        address _token,\r\n        uint256 _amount,\r\n        bytes calldata _data\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n/// @dev This contract implements a simple keeper. It borrows ETH from the\r\n/// KeeperDAO liquidity pool, and immediately returns all of the borrowed ETH,\r\n/// plus some amount of \"profit\" from its own balance. Instead of returning\r\n/// profits from their own balances, keeper contracts will usually engage in\r\n/// arbitrage or liquidations to earn profits that can be returned.\r\ncontract HelloKeeperDAO {\r\n    /// @dev Owner of the contract.\r\n    address public owner;\r\n\r\n    /// @dev Address of the KeeperDAO borrow proxy. This will be the\r\n    /// `msg.sender` for calls to the `helloCallback` function.\r\n    address public borrowProxy;\r\n\r\n    /// @dev Address of the KeeperDAO liquidity pool. This is will be the\r\n    /// address to which the `helloCallback` function must return all bororwed\r\n    /// assets (and all excess profits).\r\n    address payable public liquidityPool;\r\n\r\n    /// @dev This modifier restricts the caller of a function to the owner of\r\n    /// this contract.\r\n    modifier onlyOwner {\r\n        if (msg.sender == owner) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /// @dev This modifier restricts the caller of a function to the KeeperDAO\r\n    /// borrow proxy.\r\n    modifier onlyBorrowProxy {\r\n        if (msg.sender == borrowProxy) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        borrowProxy = 0x53463cd0b074E5FDafc55DcE7B1C82ADF1a43B2E;\r\n        liquidityPool = 0x53463cd0b074E5FDafc55DcE7B1C82ADF1a43B2E;\r\n    }\r\n\r\n    receive() external payable {\r\n        // Do nothing.\r\n    }\r\n\r\n    /// @dev Set the owner of this contract. This function can only be called by\r\n    /// the current owner.\r\n    ///\r\n    /// @param _newOwner The new owner of this contract.\r\n    function setOwner(address payable _newOwner) external onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    /// @dev Set the borrow proxy expected by this contract. This function can\r\n    /// only be called by the current owner.\r\n    ///\r\n    /// @param _newBorrowProxy The new borrow proxy expected by this contract.\r\n    function setBorrowProxy(address _newBorrowProxy) external onlyOwner {\r\n        borrowProxy = _newBorrowProxy;\r\n    }\r\n\r\n    /// @dev Set the liquidity pool used by this contract. This function can\r\n    /// only be called by the current owner.\r\n    ///\r\n    /// @param _newLiquidityPool The new liquidity pool used by this contract.\r\n    /// It must be a payable address, because this contract needs to be able to\r\n    /// return borrowed assets and profits to the liquidty pool.\r\n    function setLiquidityPool(address payable _newLiquidityPool)\r\n        external\r\n        onlyOwner\r\n    {\r\n        liquidityPool = _newLiquidityPool;\r\n    }\r\n\r\n    /// @dev This function is the entry point of this keeper. An off-chain bot\r\n    /// will call this function whenever it decides that it wants to borrow from\r\n    /// this KeeperDAO liquidity pool. This function is similar to what you\r\n    /// would expect in a \"real\" keeper implementation: it accepts paramters\r\n    /// telling it what / how much to borrow, and which callback on this\r\n    /// contract should be called once the borrowed funds have been transferred.\r\n    function hello(address _token, uint256 _amountToBorrow, uint256 _amountOfProfitToReturn)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(_amountOfProfitToReturn > 0, \"profit is zero\");\r\n        require(\r\n            address(this).balance > _amountOfProfitToReturn,\r\n            \"balance is too low\"\r\n        );\r\n\r\n        // The liquidity pool is guarded from re-entrance, so we can only call\r\n        // this function once per transaction.\r\n        LiquidityPool(liquidityPool).borrow(\r\n            // Address of the token we want to borrow.\r\n            address(_token),\r\n            // The amount of WEI that we will borrow. We have to return at least\r\n            // more than this amount.\r\n            _amountToBorrow,\r\n            // Encode the callback into calldata. This will be used to call a\r\n            // function on this contract.\r\n            abi.encodeWithSelector(\r\n                // Function selector of the callback function.\r\n                this.helloCallback.selector,\r\n                // First parameter of the callback.\r\n                _amountToBorrow,\r\n                // Second parameter of the callback.\r\n                _amountOfProfitToReturn\r\n                // Third paramter, fourth parameter, and so on (our callback\r\n                // only has two paramters).\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @dev This is the callback function that implements our custom keeper\r\n    /// logic. We do not need to call this function directly; it will be called\r\n    /// by the KeeperDAO borrow proxy when we call borrow on the KeeperDAO\r\n    /// liquidity pool. In fact, usually, this function should be restricted so\r\n    /// that is can only be called by the KeeperDAO borrow proxy.\r\n    ///\r\n    /// Just before this callback is called by the KeeperDAO borrow proxy, all\r\n    /// of the assets that we want to borrow will be transferred to this\r\n    /// contract. In this callback, we can do whatever we want with these\r\n    /// assets; we can arbitrage between DEXs, liquidity positions on Compound,\r\n    /// and so on. The only requirement is that at least more than the borrowed\r\n    /// assets is returned.\r\n    ///\r\n    /// For example, imagine that we wanted borrowed 1 ETH. Before this callback\r\n    /// is called, the KeeperDAO liquidity pool will have transferred 1 ETH to\r\n    /// this contract. This callback can then do whatever it wants with that ETH.\r\n    /// However, before the callback returns, it must return at least more than\r\n    /// 1 ETH to the KeeperDAO liquidity pool (even if it is only returning\r\n    /// 1 ETH + 1 WEI).\r\n    ///\r\n    /// In our example, we will not implement a complicated keeper strategy. We\r\n    /// will simply return all of the borrowed ETH, plus a non-zero amount of\r\n    /// profit. The amount of profit is explicitly specified by the owner of\r\n    /// this contract when they initiate the borrow. Of course, this strategy\r\n    /// does not generate profit by interacting with other protocols (like most\r\n    /// keepers do). Instead, it just uses its own balance to return profits to\r\n    /// KeeperDAO.\r\n    function helloCallback(\r\n        uint256 _amountBorrowed,\r\n        uint256 _amountOfProfitToReturn\r\n    ) external onlyBorrowProxy {\r\n        assert(\r\n            address(this).balance >= _amountOfProfitToReturn + _amountBorrowed\r\n        );\r\n        assert(_amountOfProfitToReturn > 0);\r\n\r\n        // Notice that assets are transferred back to the liquidity pool, not to\r\n        // the borrow proxy.\r\n        liquidityPool.call.value(_amountBorrowed + _amountOfProfitToReturn)(\"\");\r\n    }\r\n    \r\n    function sendETH(address payable _address) external onlyOwner {\r\n        uint balance = address(this).balance;\r\n        _address.transfer(balance);\r\n    }\r\n    \r\n    function sendERC20(address _token, address _address, uint256 _amount) external onlyOwner {\r\n        IERC20(_token).transfer(_address, _amount);\r\n    }\r\n\r\n}"
    }
  }
}