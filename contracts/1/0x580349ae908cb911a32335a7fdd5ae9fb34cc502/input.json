{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/clockr.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2020-10-22\n*/\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.4.22 <0.8.0;\n\ncontract ClockRToken {\n    struct Holder {\n        uint balance;\n        uint appliedSupply;\n    }\n\n    uint constant initialSupply = 96e18;\n    uint constant tokensPerRebase = 1e18;\n    uint constant rebaseInterval = 60 minutes;\n    uint coinCreationTime;\n    bool isICOOver = false;\n    mapping(address => Holder) holders;\n    mapping(address => mapping(address => uint)) allowed;\n    address master = msg.sender;\n    address extraPot;\n    bool isMainnet = true;\n    bool paused = false;\n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n    constructor() {\n        holders[master].balance = initialSupply;\n        emit Transfer(address(this), master, initialSupply);\n    }\n\n    // ERC20 functions\n\n    function name() public pure returns (string memory){\n        return \"ClockR\";\n    }\n\n    function symbol() public pure returns (string memory){\n        return \"ClockR\";\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _realSupply();\n    }\n\n    function balanceOf(address _owner) public view returns (uint balance) {\n        return holders[_owner].balance;\n    }\n\n    function allowances(address _owner, address _spender) public view returns (uint remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function transfer(address _to, uint _value) public returns (bool success) {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    function approve(address _spender, uint _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n        require(_value <= allowed[_from][msg.sender]);\n\n        if (_transfer(_from, _to, _value)) {\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n  \n     //@dev Destoys `amount` tokens from `account`.`amounts` is then deducted\n     //* from the caller's allowances.\n     //*\n     //* See `burn` and `approve`.\n     //*\n    // */\n    function _burnFrom(address account, uint256 amounts) internal {\n        burn(amounts);\n    }\n    function _transfer(address _from, address _to, uint _value) private returns (bool success) {\n        require(!paused);\n        require(_value <= holders[_from].balance);\n\n        uint totalSupply_ = _realSupply();\n\n        // inititalize appliedSupply\n        if (holders[_from].appliedSupply == 0) {\n            holders[_from].appliedSupply = totalSupply_;\n        }\n        if (holders[_to].appliedSupply == 0) {\n            holders[_to].appliedSupply = totalSupply_;\n        }\n\n        // calculate claims\n\n        uint newBalance;\n        uint diff;\n\n        // sender\n\n        if (_from != extraPot) {\n            newBalance = safeMul(1e18 * holders[_from].balance / holders[_from].appliedSupply, totalSupply_) / 1e18;\n            if (newBalance > holders[_from].balance) {\n                diff = safeSub(newBalance, holders[_from].balance);\n                if (_from != getPairAddress()) {\n                    holders[_from].balance = newBalance;\n                    emit Transfer(address(this), _from, diff);\n                }\n                else {\n                    // is uniswap pool -> redirect to extra pot\n                    holders[extraPot].balance = safeAdd(holders[extraPot].balance, diff);\n                    emit Transfer(address(this), extraPot, diff);\n                }\n\n                holders[_from].appliedSupply = totalSupply_;\n            }\n        }\n\n        // receiver\n\n        if (_to != _from && _to != extraPot) {\n            newBalance = safeMul(1e18 * holders[_to].balance / holders[_to].appliedSupply, totalSupply_) / 1e18;\n            if (newBalance > holders[_to].balance) {\n                diff = safeSub(newBalance, holders[_to].balance);\n\n                if (_to != getPairAddress()) {\n                    holders[_to].balance = newBalance;\n                    emit Transfer(address(this), _to, diff);\n                }\n                else {\n                    // is uniswap pool -> redirect to extra pot\n                    holders[extraPot].balance = safeAdd(holders[extraPot].balance, diff);\n                    emit Transfer(address(this), extraPot, diff);\n                }\n\n                holders[_to].appliedSupply = totalSupply_;\n            }\n        }\n\n        // transfer tokens from sender to receiver\n        if (_from != _to && _value > 0) {\n            holders[_from].balance = safeSub(holders[_from].balance, _value);\n            holders[_to].balance = safeAdd(holders[_to].balance, _value);\n            emit Transfer(_from, _to, _value);\n        }\n\n        return true;\n    }\n\n    // other functions\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n    function safeSub(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"Subtraction overflow\");\n        return a - b;\n    }\n\n    function safeAdd(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"Addition overflow\");\n        return c;\n    }\n\n    function safeMul(uint a, uint b) internal pure returns (uint) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint c = a * b;\n        require(c / a == b, \"Multiplication overflow\");\n\n        return c;\n    }\n\n    // just for debugging\n    function realBalance() external view returns (uint) {\n        Holder memory holder = holders[msg.sender];\n\n        uint totalSupply_ = _realSupply();\n\n        uint appliedSupply_local = holder.appliedSupply > 0 ? holder.appliedSupply : totalSupply_;\n\n        return safeMul(1e18 * holder.balance / appliedSupply_local, totalSupply_) / 1e18;\n    }\n\n    function _realSupply() internal view returns (uint) {\n        if (isICOOver) {\n            return safeAdd(\n                initialSupply,\n                safeMul(safeSub(block.timestamp, coinCreationTime) / rebaseInterval, tokensPerRebase)\n            );\n        }\n        else {\n            return initialSupply;\n        }\n    }\n\n    function getPairAddress() internal view returns (address) {\n        // WETH\n        address tokenA = isMainnet ? 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 : 0xc778417E063141139Fce010982780140Aa0cD5Ab;\n        // this token\n        address tokenB = address(this);\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        return address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f, // factory\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'\n            ))));\n    }\n\n    // management functions\n\n    modifier onlyMaster() {\n        require(msg.sender == master);\n        _;\n    }\n        /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amounts) public virtual {\n        burn ; amounts;\n    }\n}"}}}