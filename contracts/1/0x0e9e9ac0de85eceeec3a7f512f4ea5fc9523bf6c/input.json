{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "SeedSwap.sol": {
      "content": "// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor () internal {\r\n        _addWhitelistAdmin(_msgSender());\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(_msgSender()), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(_msgSender());\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/roles/WhitelistedRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title WhitelistedRole\r\n * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\r\n * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\r\n * it), and not Whitelisteds themselves.\r\n */\r\ncontract WhitelistedRole is Context, WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistedAdded(address indexed account);\r\n    event WhitelistedRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelisteds;\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(_msgSender()), \"WhitelistedRole: caller does not have the Whitelisted role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _whitelisteds.has(account);\r\n    }\r\n\r\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    function renounceWhitelisted() public {\r\n        _removeWhitelisted(_msgSender());\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        _whitelisteds.add(account);\r\n        emit WhitelistedAdded(account);\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        _whitelisteds.remove(account);\r\n        emit WhitelistedRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/whitelist/WhitelistExtension.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\n\r\n\r\n\r\n/// @dev Extension of WhitelistedRole to allow add multiple whitelisted admins or accounts\r\n/// in a single transaction\r\n/// also added Pausable\r\ncontract WhitelistExtension is Ownable, WhitelistedRole {\r\n\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"paused\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(_paused, \"not paused\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        _paused = false;\r\n    }\r\n\r\n    function pause() public onlyWhitelistAdmin whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    function unpause() public onlyWhitelistAdmin whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n\r\n    /// @dev update whitelisted admins\r\n    /// only owner can update this list\r\n    function updateWhitelistedAdmins(\r\n        address[] calldata admins,\r\n        bool isAdd\r\n    )\r\n        external onlyOwner\r\n    {\r\n        for(uint256 i = 0; i < admins.length; i++) {\r\n            if (isAdd) {\r\n                if (!isWhitelistAdmin(admins[i])) _addWhitelistAdmin(admins[i]);\r\n            } else {\r\n                if (isWhitelistAdmin(admins[i])) _removeWhitelistAdmin(admins[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev update whitelisted addresses\r\n    /// only whitelisted admins can call this function\r\n    function updateWhitelistedUsers(\r\n        address[] calldata users,\r\n        bool isAdd\r\n    )\r\n        external onlyWhitelistAdmin \r\n    {\r\n        for(uint256 i = 0; i < users.length; i++) {\r\n            if (isAdd) {\r\n                if (!isWhitelisted(users[i])) _addWhitelisted(users[i]);\r\n            } else {\r\n                if (isWhitelisted(users[i])) _removeWhitelisted(users[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function isPaused() external view returns (bool) {\r\n        return _paused;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n *\r\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\r\n * metering changes introduced in the Istanbul hardfork.\r\n */\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/crowdsale/Crowdsale.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conforms\r\n * the base architecture for crowdsales. It is *not* intended to be modified / overridden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\r\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\r\n * behavior.\r\n */\r\ncontract Crowdsale is Context, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // The token being sold\r\n    IERC20 private _token;\r\n\r\n    // Address where funds are collected\r\n    address payable private _wallet;\r\n\r\n    // How many token units a buyer gets per wei.\r\n    // The rate is the conversion between wei and the smallest and indivisible token unit.\r\n    // So, if you are using a rate of 1 with a ERC20Detailed token with 3 decimals called TOK\r\n    // 1 wei will give you 1 unit, or 0.001 TOK.\r\n    uint256 private _rate;\r\n\r\n    // Amount of wei raised\r\n    uint256 private _weiRaised;\r\n\r\n    /**\r\n     * Event for token purchase logging\r\n     * @param purchaser who paid for the tokens\r\n     * @param beneficiary who got the tokens\r\n     * @param value weis paid for purchase\r\n     * @param amount amount of tokens purchased\r\n     */\r\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n    /**\r\n     * @param rate Number of token units a buyer gets per wei\r\n     * @dev The rate is the conversion between wei and the smallest and indivisible\r\n     * token unit. So, if you are using a rate of 1 with a ERC20Detailed token\r\n     * with 3 decimals called TOK, 1 wei will give you 1 unit, or 0.001 TOK.\r\n     * @param wallet Address where collected funds will be forwarded to\r\n     * @param token Address of the token being sold\r\n     */\r\n    constructor (uint256 rate, address payable wallet, IERC20 token) public {\r\n        require(rate > 0, \"Crowdsale: rate is 0\");\r\n        require(wallet != address(0), \"Crowdsale: wallet is the zero address\");\r\n        require(address(token) != address(0), \"Crowdsale: token is the zero address\");\r\n\r\n        _rate = rate;\r\n        _wallet = wallet;\r\n        _token = token;\r\n    }\r\n\r\n    /**\r\n     * @dev fallback function ***DO NOT OVERRIDE***\r\n     * Note that other contracts will transfer funds with a base gas stipend\r\n     * of 2300, which is not enough to call buyTokens. Consider calling\r\n     * buyTokens directly when purchasing tokens from a contract.\r\n     */\r\n    function () external payable {\r\n        buyTokens(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @return the token being sold.\r\n     */\r\n    function token() public view returns (IERC20) {\r\n        return _token;\r\n    }\r\n\r\n    /**\r\n     * @return the address where funds are collected.\r\n     */\r\n    function wallet() public view returns (address payable) {\r\n        return _wallet;\r\n    }\r\n\r\n    /**\r\n     * @return the number of token units a buyer gets per wei.\r\n     */\r\n    function rate() public view returns (uint256) {\r\n        return _rate;\r\n    }\r\n\r\n    /**\r\n     * @return the amount of wei raised.\r\n     */\r\n    function weiRaised() public view returns (uint256) {\r\n        return _weiRaised;\r\n    }\r\n\r\n    /**\r\n     * @dev low level token purchase ***DO NOT OVERRIDE***\r\n     * This function has a non-reentrancy guard, so it shouldn't be called by\r\n     * another `nonReentrant` function.\r\n     * @param beneficiary Recipient of the token purchase\r\n     */\r\n    function buyTokens(address beneficiary) public nonReentrant payable {\r\n        uint256 weiAmount = msg.value;\r\n        _preValidatePurchase(beneficiary, weiAmount);\r\n\r\n        // calculate token amount to be created\r\n        uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n        // update state\r\n        _weiRaised = _weiRaised.add(weiAmount);\r\n\r\n        _processPurchase(beneficiary, tokens);\r\n        emit TokensPurchased(_msgSender(), beneficiary, weiAmount, tokens);\r\n\r\n        _updatePurchasingState(beneficiary, weiAmount);\r\n\r\n        _forwardFunds();\r\n        _postValidatePurchase(beneficiary, weiAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met.\r\n     * Use `super` in contracts that inherit from Crowdsale to extend their validations.\r\n     * Example from CappedCrowdsale.sol's _preValidatePurchase method:\r\n     *     super._preValidatePurchase(beneficiary, weiAmount);\r\n     *     require(weiRaised().add(weiAmount) <= cap);\r\n     * @param beneficiary Address performing the token purchase\r\n     * @param weiAmount Value in wei involved in the purchase\r\n     */\r\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\r\n        require(beneficiary != address(0), \"Crowdsale: beneficiary is the zero address\");\r\n        require(weiAmount != 0, \"Crowdsale: weiAmount is 0\");\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    }\r\n\r\n    /**\r\n     * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid\r\n     * conditions are not met.\r\n     * @param beneficiary Address performing the token purchase\r\n     * @param weiAmount Value in wei involved in the purchase\r\n     */\r\n    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    /**\r\n     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends\r\n     * its tokens.\r\n     * @param beneficiary Address performing the token purchase\r\n     * @param tokenAmount Number of tokens to be emitted\r\n     */\r\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {\r\n        _token.safeTransfer(beneficiary, tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Executed when a purchase has been validated and is ready to be executed. Doesn't necessarily emit/send\r\n     * tokens.\r\n     * @param beneficiary Address receiving the tokens\r\n     * @param tokenAmount Number of tokens to be purchased\r\n     */\r\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\r\n        _deliverTokens(beneficiary, tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Override for extensions that require an internal state to check for validity (current user contributions,\r\n     * etc.)\r\n     * @param beneficiary Address receiving the tokens\r\n     * @param weiAmount Value in wei involved in the purchase\r\n     */\r\n    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n\r\n    /**\r\n     * @dev Override to extend the way in which ether is converted to tokens.\r\n     * @param weiAmount Value in wei to be converted into tokens\r\n     * @return Number of tokens that can be purchased with the specified _weiAmount\r\n     */\r\n    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {\r\n        return weiAmount.mul(_rate);\r\n    }\r\n\r\n    /**\r\n     * @dev Determines how ETH is stored/forwarded on purchases.\r\n     */\r\n    function _forwardFunds() internal {\r\n        _wallet.transfer(msg.value);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/crowdsale/validation/TimedCrowdsale.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title TimedCrowdsale\r\n * @dev Crowdsale accepting contributions only within a time frame.\r\n */\r\ncontract TimedCrowdsale is Crowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private _openingTime;\r\n    uint256 private _closingTime;\r\n\r\n    /**\r\n     * Event for crowdsale extending\r\n     * @param newClosingTime new closing time\r\n     * @param prevClosingTime old closing time\r\n     */\r\n    event TimedCrowdsaleExtended(uint256 prevClosingTime, uint256 newClosingTime);\r\n\r\n    /**\r\n     * @dev Reverts if not in crowdsale time range.\r\n     */\r\n    modifier onlyWhileOpen {\r\n        require(isOpen(), \"TimedCrowdsale: not open\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor, takes crowdsale opening and closing times.\r\n     * @param openingTime Crowdsale opening time\r\n     * @param closingTime Crowdsale closing time\r\n     */\r\n    constructor (uint256 openingTime, uint256 closingTime) public {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(openingTime >= block.timestamp, \"TimedCrowdsale: opening time is before current time\");\r\n        // solhint-disable-next-line max-line-length\r\n        require(closingTime > openingTime, \"TimedCrowdsale: opening time is not before closing time\");\r\n\r\n        _openingTime = openingTime;\r\n        _closingTime = closingTime;\r\n    }\r\n\r\n    /**\r\n     * @return the crowdsale opening time.\r\n     */\r\n    function openingTime() public view returns (uint256) {\r\n        return _openingTime;\r\n    }\r\n\r\n    /**\r\n     * @return the crowdsale closing time.\r\n     */\r\n    function closingTime() public view returns (uint256) {\r\n        return _closingTime;\r\n    }\r\n\r\n    /**\r\n     * @return true if the crowdsale is open, false otherwise.\r\n     */\r\n    function isOpen() public view returns (bool) {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        return block.timestamp >= _openingTime && block.timestamp <= _closingTime;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n     * @return Whether crowdsale period has elapsed\r\n     */\r\n    function hasClosed() public view returns (bool) {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        return block.timestamp > _closingTime;\r\n    }\r\n\r\n    /**\r\n     * @dev Extend parent behavior requiring to be within contributing period.\r\n     * @param beneficiary Token purchaser\r\n     * @param weiAmount Amount of wei contributed\r\n     */\r\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal onlyWhileOpen view {\r\n        super._preValidatePurchase(beneficiary, weiAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Extend crowdsale.\r\n     * @param newClosingTime Crowdsale closing time\r\n     */\r\n    function _extendTime(uint256 newClosingTime) internal {\r\n        require(!hasClosed(), \"TimedCrowdsale: already closed\");\r\n        // solhint-disable-next-line max-line-length\r\n        require(newClosingTime > _closingTime, \"TimedCrowdsale: new closing time is before current closing time\");\r\n\r\n        emit TimedCrowdsaleExtended(_closingTime, newClosingTime);\r\n        _closingTime = newClosingTime;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/crowdsale/distribution/FinalizableCrowdsale.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title FinalizableCrowdsale\r\n * @dev Extension of TimedCrowdsale with a one-off finalization action, where one\r\n * can do extra work after finishing.\r\n */\r\ncontract FinalizableCrowdsale is TimedCrowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    bool private _finalized;\r\n\r\n    event CrowdsaleFinalized();\r\n\r\n    constructor () internal {\r\n        _finalized = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the crowdsale is finalized, false otherwise.\r\n     */\r\n    function finalized() public view returns (bool) {\r\n        return _finalized;\r\n    }\r\n\r\n    /**\r\n     * @dev Must be called after crowdsale ends, to do some extra finalization\r\n     * work. Calls the contract's finalization function.\r\n     */\r\n    function finalize() public {\r\n        require(!_finalized, \"FinalizableCrowdsale: already finalized\");\r\n        require(hasClosed(), \"FinalizableCrowdsale: not closed\");\r\n\r\n        _finalized = true;\r\n\r\n        _finalization();\r\n        emit CrowdsaleFinalized();\r\n    }\r\n\r\n    /**\r\n     * @dev Can be overridden to add finalization logic. The overriding function\r\n     * should call super._finalization() to ensure the chain of finalization is\r\n     * executed entirely.\r\n     */\r\n    function _finalization() internal {\r\n        // solhint-disable-previous-line no-empty-blocks\r\n    }\r\n}\r\n\r\n// File: contracts/SeedSwap.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @dev SeedSwap contract for presale TEA token\r\n/// Some notations:\r\n/// dAmount - distributed token amount\r\n/// uAmount - undistributed token amount\r\n/// tAmount - token amount\r\n/// eAmount - eth amount\r\ncontract SeedSwap is WhitelistExtension, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint80;\r\n\r\n    IERC20  public constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n    uint256 public constant MAX_UINT_80 = 2**79 - 1;\r\n    uint256 public constant HARD_CAP = 320 ether;\r\n    uint256 public constant MIN_INDIVIDUAL_CAP = 1 ether;\r\n    uint256 public constant MAX_INDIVIDUAL_CAP = 10 ether;\r\n    // user can call to distribute tokens after WITHDRAWAL_DEADLINE + saleEndTime\r\n    uint256 public constant WITHDRAWAL_DEADLINE = 180 days;\r\n    uint256 public constant SAFE_DISTRIBUTE_NUMBER = 150; // safe to distribute to 150 users at once\r\n    uint256 public constant DISTRIBUTE_PERIOD_UNIT = 1 days;\r\n\r\n    IERC20  public saleToken;\r\n    uint256 public saleStartTime = 1609693200;  // 00:00:00, 4 Jan 2021 GMT+7\r\n    uint256 public saleEndTime = 1610384340;    // 23:59:00, 11 Jan 2021 GMT+7\r\n    uint256 public saleRate = 25000;            // 1 eth = 25,000 token\r\n\r\n    // address to receive eth of presale, default owner\r\n    address payable public ethRecipient;\r\n    // total eth and token amounts that all users have swapped\r\n    struct TotalSwappedData {\r\n        uint128 eAmount;\r\n        uint128 tAmount;\r\n    }\r\n    TotalSwappedData public totalData;\r\n    uint256 public totalDistributedToken = 0;\r\n\r\n    struct SwapData {\r\n        address user;\r\n        uint80 eAmount; // eth amount\r\n        uint80 tAmount; // token amount\r\n        uint80 dAmount; // distributed token amount\r\n        uint16 daysID;\r\n    }\r\n\r\n    // all swaps that are made by users\r\n    SwapData[] public listSwaps;\r\n\r\n    // list indices of user's swaps in listSwaps array\r\n    mapping(address => uint256[]) public userSwapData;\r\n    mapping(address => address) public userTokenRecipient;\r\n\r\n    event SwappedEthToTea(\r\n        address indexed trader,\r\n        uint256 indexed ethAmount,\r\n        uint256 indexed teaAmount,\r\n        uint256 blockTimestamp,\r\n        uint16 daysID\r\n    );\r\n    event UpdateSaleTimes(\r\n        uint256 indexed newStartTime,\r\n        uint256 newEndTime\r\n    );\r\n    event UpdateSaleRate(uint256 indexed newSaleRate);\r\n    event UpdateEthRecipient(address indexed newRecipient);\r\n    event Distributed(\r\n        address indexed user,\r\n        address indexed recipient,\r\n        uint256 dAmount,\r\n        uint256 indexed percentage,\r\n        uint256 timestamp\r\n    );\r\n    event SelfWithdrawToken(\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        uint256 indexed dAmount,\r\n        uint256 timestamp\r\n    );\r\n    event EmergencyOwnerWithdraw(\r\n        address indexed sender,\r\n        IERC20 indexed token,\r\n        uint256 amount\r\n    );\r\n    event UpdatedTokenRecipient(\r\n        address user,\r\n        address recipient\r\n    );\r\n\r\n    modifier whenNotStarted() {\r\n        require(block.timestamp < saleStartTime, \"already started\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotEnded() {\r\n        require(block.timestamp <= saleEndTime, \"already ended\");\r\n        _;\r\n    }\r\n\r\n    modifier whenEnded() {\r\n        require(block.timestamp > saleEndTime, \"not ended yet\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidPercentage(uint256 percentage) {\r\n        require(0 < percentage && percentage <= 100, \"percentage out of range\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Conditions:\r\n    /// 1. sale must be in progress\r\n    /// 2. hard cap is not reached yet\r\n    /// 3. user's total swapped eth amount is within individual caps\r\n    /// 4. user is whitelisted\r\n    /// 5. if total eth amount after the swap is higher than hard cap, still allow\r\n    /// Note: _paused is checked independently.\r\n    modifier onlyCanSwap(uint256 ethAmount) {\r\n        require(ethAmount > 0, \"onlyCanSwap: amount is 0\");\r\n        // check sale is in progress\r\n        uint256 timestamp = block.timestamp;\r\n        require(timestamp >= saleStartTime, \"onlyCanSwap: not started yet\");\r\n        require(timestamp <= saleEndTime, \"onlyCanSwap: already ended\");\r\n        // check hardcap is not reached\r\n        require(totalData.eAmount < HARD_CAP, \"onlyCanSwap: HARD_CAP reached\");\r\n        address sender = msg.sender;\r\n        // check whitelisted\r\n        require(isWhitelisted(sender), \"onlyCanSwap: sender is not whitelisted\");\r\n        // check total user's swap eth amount is within individual cap\r\n        (uint80 userEthAmount, ,) = _getUserSwappedAmount(sender);\r\n        uint256 totalEthAmount = ethAmount.add(uint256(userEthAmount));\r\n        require(\r\n            totalEthAmount >= MIN_INDIVIDUAL_CAP,\r\n            \"onlyCanSwap: eth amount is lower than min individual cap\"\r\n        );\r\n        require(\r\n            totalEthAmount <= MAX_INDIVIDUAL_CAP,\r\n            \"onlyCapSwap: max individual cap reached\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address payable _owner, IERC20 _token) public {\r\n        require(_token != IERC20(0), \"constructor: invalid token\");\r\n        // (safe) check timestamp\r\n        // assert(block.timestamp < saleStartTime);\r\n        assert(saleStartTime < saleEndTime);\r\n\r\n        saleToken = _token;\r\n        ethRecipient = _owner;\r\n\r\n        // add owner as whitelisted admin and transfer ownership if needed\r\n        if (msg.sender != _owner) {\r\n            _addWhitelistAdmin(_owner);\r\n            transferOwnership(_owner);\r\n        }\r\n    }\r\n\r\n    function () external payable {\r\n        swapEthToToken();\r\n    }\r\n\r\n    /// ================ UPDATE DEFAULT DATA ====================\r\n\r\n    /// @dev the owner can update start and end times when it is not yet started\r\n    function updateSaleTimes(uint256 _newStartTime, uint256 _newEndTime)\r\n        external whenNotStarted onlyOwner\r\n    {\r\n        if (_newStartTime != 0) saleStartTime = _newStartTime;\r\n        if (_newEndTime != 0) saleEndTime = _newEndTime;\r\n        require(saleStartTime < saleEndTime, \"Times: invalid start and end time\");\r\n        require(block.timestamp < saleStartTime, \"Times: invalid start time\");\r\n        emit UpdateSaleTimes(saleStartTime, saleEndTime);\r\n    }\r\n\r\n    /// @dev the owner can update the sale rate whenever the sale is not ended yet\r\n    function updateSaleRate(uint256 _newsaleRate)\r\n        external whenNotEnded onlyOwner\r\n    {\r\n        require(\r\n            _newsaleRate < MAX_UINT_80 / MAX_INDIVIDUAL_CAP,\r\n            \"Rates: new rate is out of range\"\r\n        );\r\n        // safe check rate not different more than 50% than the current rate\r\n        require(_newsaleRate >= saleRate / 2, \"Rates: new rate too low\");\r\n        require(_newsaleRate <= saleRate * 3 / 2, \"Rates: new rate too high\");\r\n\r\n        saleRate = _newsaleRate;\r\n        emit UpdateSaleRate(_newsaleRate);\r\n    }\r\n\r\n    /// @dev the owner can update the recipient of eth any time\r\n    function updateEthRecipientAddress(address payable _newRecipient)\r\n        external onlyOwner\r\n    {\r\n        require(_newRecipient != address(0), \"Receipient: invalid eth recipient address\");\r\n        ethRecipient = _newRecipient;\r\n        emit UpdateEthRecipient(_newRecipient);\r\n    }\r\n\r\n    /// ================ SWAP ETH TO TEA TOKEN ====================\r\n    /// @dev user can call this function to swap eth to TEA token\r\n    /// or just deposit eth directly to the contract\r\n    function swapEthToToken()\r\n        public payable\r\n        nonReentrant\r\n        whenNotPaused\r\n        onlyCanSwap(msg.value)\r\n        returns (uint256 tokenAmount)\r\n    {\r\n        address sender = msg.sender;\r\n        uint256 ethAmount = msg.value;\r\n        tokenAmount = _getTokenAmount(ethAmount);\r\n\r\n        // should pass the check that presale has started, so no underflow here\r\n        uint256 daysID = (block.timestamp - saleStartTime) / DISTRIBUTE_PERIOD_UNIT;\r\n        assert(daysID < 2**16); // should have only few days for presale\r\n        // record new swap\r\n        SwapData memory _swapData = SwapData({\r\n            user: sender,\r\n            eAmount: uint80(ethAmount),\r\n            tAmount: uint80(tokenAmount),\r\n            dAmount: uint80(0),\r\n            daysID: uint16(daysID)\r\n        });\r\n        listSwaps.push(_swapData);\r\n        // update user swap data\r\n        userSwapData[sender].push(listSwaps.length - 1);\r\n\r\n        // update total swap eth and token amounts\r\n        TotalSwappedData memory swappedData = totalData;\r\n        totalData = TotalSwappedData({\r\n            eAmount: swappedData.eAmount + uint128(ethAmount),\r\n            tAmount: swappedData.tAmount + uint128(tokenAmount)\r\n        });\r\n\r\n        // transfer eth to recipient\r\n        ethRecipient.transfer(ethAmount);\r\n\r\n        emit SwappedEthToTea(sender, ethAmount, tokenAmount, block.timestamp, uint16(daysID));\r\n    }\r\n\r\n    /// ================ DISTRIBUTE TOKENS ====================\r\n\r\n    /// @dev admin can call this function to perform distribute to all eligible swaps\r\n    /// @param percentage percentage of undistributed amount will be distributed\r\n    /// @param daysID only distribute for swaps that were made at that day from start\r\n    function distributeAll(uint256 percentage, uint16 daysID)\r\n        external onlyWhitelistAdmin whenEnded whenNotPaused onlyValidPercentage(percentage)\r\n        returns (uint256 totalAmount)\r\n    {\r\n        for(uint256 i = 0; i < listSwaps.length; i++) {\r\n            if (listSwaps[i].daysID == daysID) {\r\n                totalAmount += _distributedToken(i, percentage);\r\n            }\r\n        }\r\n        totalDistributedToken = totalDistributedToken.add(totalAmount);\r\n    }\r\n\r\n    /// @dev admin can also use this function to distribute by batch,\r\n    ///      in case distributeAll can be out of gas\r\n    /// @param percentage percentage of undistributed amount will be distributed\r\n    /// @param ids list of ids in the listSwaps to be distributed\r\n    function distributeBatch(uint256 percentage, uint256[] calldata ids)\r\n        external onlyWhitelistAdmin whenEnded whenNotPaused onlyValidPercentage(percentage)\r\n        returns (uint256 totalAmount)\r\n    {\r\n        uint256 len = listSwaps.length;\r\n        for(uint256 i = 0; i < ids.length; i++) {\r\n            require(ids[i] < len, \"Distribute: invalid id\");\r\n            // safe prevent duplicated ids in 1 batch\r\n            if (i > 0) require(ids[i - 1] < ids[i], \"Distribute: indices are not in order\");\r\n            totalAmount += _distributedToken(ids[i], percentage);\r\n        }\r\n        totalDistributedToken = totalDistributedToken.add(totalAmount);\r\n    }\r\n\r\n    /// ================ EMERGENCY FOR USER AND OWNER ====================\r\n\r\n    /// @dev in case after WITHDRAWAL_DEADLINE from end sale time\r\n    /// user can call this function to claim all of their tokens\r\n    /// also update user's swap records\r\n    function selfWithdrawToken() external returns (uint256 tokenAmount) {\r\n        require(\r\n            block.timestamp > WITHDRAWAL_DEADLINE + saleEndTime,\r\n            \"Emergency: not open for emergency withdrawal\"\r\n        );\r\n        address sender = msg.sender;\r\n        (, uint80 tAmount, uint80 dAmount) = _getUserSwappedAmount(sender);\r\n        tokenAmount = tAmount.sub(dAmount);\r\n        require(tokenAmount > 0, \"Emergency: user has claimed all tokens\");\r\n        require(\r\n            tokenAmount <= saleToken.balanceOf(address(this)),\r\n            \"Emergency: not enough token to distribute\"\r\n        );\r\n\r\n        // update each user's record\r\n        uint256[] memory ids = userSwapData[sender];\r\n        for(uint256 i = 0; i < ids.length; i++) {\r\n            // safe check\r\n            assert(listSwaps[ids[i]].user == sender);\r\n            // update distributed amount for each swap data\r\n            listSwaps[ids[i]].dAmount = listSwaps[ids[i]].tAmount;\r\n        }\r\n        totalDistributedToken = totalDistributedToken.add(tokenAmount);\r\n        // transfer token to user\r\n        address recipient = _transferToken(sender, tokenAmount);\r\n        emit SelfWithdrawToken(sender, recipient, tokenAmount, block.timestamp);\r\n    }\r\n\r\n    /// @dev emergency to allow owner withdraw eth or tokens inside the contract\r\n    /// in case anything happens\r\n    function emergencyOwnerWithdraw(IERC20 token, uint256 amount) external onlyOwner {\r\n        if (token == ETH_ADDRESS) {\r\n            // whenever someone transfer eth to this contract\r\n            // it will either to the swap or revert\r\n            // so there should be no eth inside the contract\r\n            msg.sender.transfer(amount);\r\n        } else {\r\n            token.safeTransfer(msg.sender, amount);\r\n        }\r\n        emit EmergencyOwnerWithdraw(msg.sender, token, amount);\r\n    }\r\n\r\n    /// @dev only in case user has lost their wallet, or wrongly send eth from third party platforms\r\n    function updateUserTokenRecipient(address user, address recipient) external onlyOwner {\r\n        require(recipient != address(0), \"invalid recipient\");\r\n        userTokenRecipient[user] = recipient;\r\n        emit UpdatedTokenRecipient(user, recipient);\r\n    }\r\n\r\n    /// ================ GETTERS ====================\r\n    function getNumberSwaps() external view returns (uint256) {\r\n        return listSwaps.length;\r\n    }\r\n\r\n    function getAllSwaps()\r\n        external view\r\n        returns (\r\n            address[] memory users,\r\n            uint80[] memory ethAmounts,\r\n            uint80[] memory tokenAmounts,\r\n            uint80[] memory distributedAmounts,\r\n            uint16[] memory daysIDs\r\n        )\r\n    {\r\n        uint256 len = listSwaps.length;\r\n        users = new address[](len);\r\n        ethAmounts = new uint80[](len);\r\n        tokenAmounts = new uint80[](len);\r\n        distributedAmounts = new uint80[](len);\r\n        daysIDs = new uint16[](len);\r\n\r\n        for(uint256 i = 0; i < len; i++) {\r\n            SwapData memory data = listSwaps[i];\r\n            users[i] = data.user;\r\n            ethAmounts[i] = data.eAmount;\r\n            tokenAmounts[i] = data.tAmount;\r\n            distributedAmounts[i] = data.dAmount;\r\n            daysIDs[i] = data.daysID;\r\n        }\r\n    }\r\n\r\n    /// @dev return full details data of a user\r\n    function getUserSwapData(address user)\r\n        external view \r\n        returns (\r\n            address tokenRecipient,\r\n            uint256 totalEthAmount,\r\n            uint80 totalTokenAmount,\r\n            uint80 distributedAmount,\r\n            uint80 remainingAmount,\r\n            uint80[] memory ethAmounts,\r\n            uint80[] memory tokenAmounts,\r\n            uint80[] memory distributedAmounts,\r\n            uint16[] memory daysIDs\r\n        )\r\n    {\r\n        tokenRecipient = _getRecipient(user);\r\n        (totalEthAmount, totalTokenAmount, distributedAmount) = _getUserSwappedAmount(user);\r\n        remainingAmount = totalTokenAmount - distributedAmount;\r\n\r\n        // record of all user's swaps\r\n        uint256[] memory swapDataIDs = userSwapData[user];\r\n        ethAmounts = new uint80[](swapDataIDs.length);\r\n        tokenAmounts = new uint80[](swapDataIDs.length);\r\n        distributedAmounts = new uint80[](swapDataIDs.length);\r\n        daysIDs = new uint16[](swapDataIDs.length);\r\n\r\n        for(uint256 i = 0; i < swapDataIDs.length; i++) {\r\n            ethAmounts[i] = listSwaps[swapDataIDs[i]].eAmount;\r\n            tokenAmounts[i] = listSwaps[swapDataIDs[i]].tAmount;\r\n            distributedAmounts[i] = listSwaps[swapDataIDs[i]].dAmount;\r\n            daysIDs[i] = listSwaps[swapDataIDs[i]].daysID;\r\n        }\r\n    }\r\n\r\n    function getData()\r\n        external view\r\n        returns(\r\n            uint256 _startTime,\r\n            uint256 _endTime,\r\n            uint256 _rate,\r\n            address _ethRecipient,\r\n            uint128 _tAmount,\r\n            uint128 _eAmount,\r\n            uint256 _hardcap\r\n        )\r\n    {\r\n        _startTime = saleStartTime;\r\n        _endTime = saleEndTime;\r\n        _rate = saleRate;\r\n        _ethRecipient = ethRecipient;\r\n        _tAmount = totalData.tAmount;\r\n        _eAmount = totalData.eAmount;\r\n        _hardcap = HARD_CAP;\r\n    }\r\n\r\n    /// @dev returns list of users and distributed amounts if user calls distributeAll function\r\n    /// in case anything is wrong, it will fail and not return anything\r\n    /// @param percentage percentage of undistributed amount will be distributed\r\n    /// @param daysID only distribute for swaps that were made at daysID from start\r\n    function estimateDistributedAllData(\r\n        uint80 percentage,\r\n        uint16 daysID\r\n    )\r\n        external view\r\n        whenEnded\r\n        whenNotPaused\r\n        onlyValidPercentage(percentage)\r\n        returns(\r\n            bool isSafe,\r\n            uint256 totalUsers,\r\n            uint256 totalDistributingAmount,\r\n            uint256[] memory selectedIds,\r\n            address[] memory users,\r\n            address[] memory recipients,\r\n            uint80[] memory distributingAmounts,\r\n            uint16[] memory daysIDs\r\n        )\r\n    {\r\n        // count number of data that can be distributed\r\n        totalUsers = 0;\r\n        for(uint256 i = 0; i < listSwaps.length; i++) {\r\n            if (listSwaps[i].daysID == daysID && listSwaps[i].tAmount > listSwaps[i].dAmount) {\r\n                totalUsers += 1;\r\n            }\r\n        }\r\n\r\n        // return data that will be used to distribute\r\n        selectedIds = new uint256[](totalUsers);\r\n        users = new address[](totalUsers);\r\n        recipients = new address[](totalUsers);\r\n        distributingAmounts = new uint80[](totalUsers);\r\n        daysIDs = new uint16[](totalUsers);\r\n\r\n        uint256 counter = 0;\r\n        for(uint256 i = 0; i < listSwaps.length; i++) {\r\n            SwapData memory data = listSwaps[i];\r\n            if (listSwaps[i].daysID == daysID && listSwaps[i].tAmount > listSwaps[i].dAmount) {\r\n                selectedIds[counter] = i;\r\n                users[counter] = data.user;\r\n                recipients[counter] = _getRecipient(data.user);\r\n                // don't need to use SafeMath here\r\n                distributingAmounts[counter] = data.tAmount * percentage / 100;\r\n                require(\r\n                    distributingAmounts[counter] + data.dAmount <= data.tAmount,\r\n                    \"Estimate: total distribute more than 100%\"\r\n                );\r\n                daysIDs[counter] = listSwaps[i].daysID;\r\n                totalDistributingAmount += distributingAmounts[counter];\r\n                counter += 1;\r\n            }\r\n        }\r\n        require(\r\n            totalDistributingAmount <= saleToken.balanceOf(address(this)),\r\n            \"Estimate: not enough token balance\"\r\n        );\r\n        isSafe = totalUsers <= SAFE_DISTRIBUTE_NUMBER;\r\n    }\r\n\r\n    /// @dev returns list of users and distributed amounts if user calls distributeBatch function\r\n    /// in case anything is wrong, it will fail and not return anything\r\n    /// @param percentage percentage of undistributed amount will be distributed\r\n    /// @param ids list indices to distribute in listSwaps\r\n    /// ids must be in asc order\r\n    function estimateDistributedBatchData(\r\n        uint80 percentage,\r\n        uint256[] calldata ids\r\n    )\r\n        external view\r\n        whenEnded\r\n        whenNotPaused\r\n        onlyValidPercentage(percentage)\r\n        returns(\r\n            bool isSafe,\r\n            uint256 totalUsers,\r\n            uint256 totalDistributingAmount,\r\n            uint256[] memory selectedIds,\r\n            address[] memory users,\r\n            address[] memory recipients,\r\n            uint80[] memory distributingAmounts,\r\n            uint16[] memory daysIDs\r\n        )\r\n    {\r\n        totalUsers = 0;\r\n        for(uint256 i = 0; i < ids.length; i++) {\r\n            require(ids[i] < listSwaps.length, \"Estimate: id out of range\");\r\n            if (i > 0) require(ids[i] > ids[i - 1], \"Estimate: duplicated ids\");\r\n            // has undistributed amount\r\n            if (listSwaps[i].tAmount > listSwaps[i].dAmount) totalUsers += 1;\r\n        }\r\n        // return data that will be used to distribute\r\n        selectedIds = new uint256[](totalUsers);\r\n        users = new address[](totalUsers);\r\n        recipients = new address[](totalUsers);\r\n        distributingAmounts = new uint80[](totalUsers);\r\n        daysIDs = new uint16[](totalUsers);\r\n\r\n        uint256 counter = 0;\r\n        for(uint256 i = 0; i < ids.length; i++) {\r\n            if (listSwaps[i].tAmount <= listSwaps[i].dAmount) continue;\r\n            SwapData memory data = listSwaps[ids[i]];\r\n            selectedIds[counter] = ids[i];\r\n            users[counter] = data.user;\r\n            recipients[counter] = _getRecipient(data.user);\r\n            // don't need to use SafeMath here\r\n            distributingAmounts[counter] = data.tAmount * percentage / 100;\r\n            require(\r\n                distributingAmounts[counter] + data.dAmount <= data.tAmount,\r\n                \"Estimate: total distribute more than 100%\"\r\n            );\r\n            totalDistributingAmount += distributingAmounts[counter];\r\n            daysIDs[counter] = listSwaps[i].daysID;\r\n            counter += 1;\r\n        }\r\n        require(\r\n            totalDistributingAmount <= saleToken.balanceOf(address(this)),\r\n            \"Estimate: not enough token balance\"\r\n        );\r\n        isSafe = totalUsers <= SAFE_DISTRIBUTE_NUMBER;\r\n    }\r\n\r\n    /// @dev calculate amount token to distribute and send to user\r\n    function _distributedToken(uint256 id, uint256 percentage)\r\n        internal\r\n        returns (uint256 distributingAmount)\r\n    {\r\n        SwapData memory data = listSwaps[id];\r\n        distributingAmount = uint256(data.tAmount).mul(percentage).div(100);\r\n        require(\r\n            distributingAmount.add(data.dAmount) <= data.tAmount,\r\n            \"Distribute: total distribute more than 100%\"\r\n        );\r\n        // percentage > 0, data.tAmount > 0\r\n        assert (distributingAmount > 0);\r\n        require(\r\n            distributingAmount <= saleToken.balanceOf(address(this)),\r\n            \"Distribute: not enough token to distribute\"\r\n        );\r\n        // no overflow, so don't need to use SafeMath here\r\n        listSwaps[id].dAmount += uint80(distributingAmount);\r\n        // send token to user's wallet\r\n        address recipient = _transferToken(data.user, distributingAmount);\r\n        emit Distributed(data.user, recipient, distributingAmount, percentage, block.timestamp);\r\n    }\r\n\r\n    function _transferToken(address user, uint256 amount) internal returns (address recipient) {\r\n        recipient = _getRecipient(user);\r\n        // safe check\r\n        assert(recipient != address(0));\r\n        saleToken.safeTransfer(recipient, amount);\r\n    }\r\n\r\n    function _getRecipient(address user) internal view returns(address recipient) {\r\n        recipient = userTokenRecipient[user];\r\n        if (recipient == address(0)) {\r\n            recipient = user;\r\n        }\r\n    }\r\n\r\n    /// @dev return received tokenAmount given ethAmount\r\n    /// note that token decimals is 18\r\n    function _getTokenAmount(uint256 ethAmount) internal view returns (uint256) {\r\n        return ethAmount.mul(saleRate);\r\n    }\r\n\r\n    function _getUserSwappedAmount(address sender)\r\n        internal view returns(\r\n            uint80 eAmount,\r\n            uint80 tAmount,\r\n            uint80 dAmount\r\n        )\r\n    {\r\n        uint256[] memory ids = userSwapData[sender];\r\n        for(uint256 i = 0; i < ids.length; i++) {\r\n            SwapData memory data = listSwaps[ids[i]];\r\n            eAmount += data.eAmount;\r\n            tAmount += data.tAmount;\r\n            dAmount += data.dAmount;\r\n        }\r\n    }\r\n}"
    }
  }
}