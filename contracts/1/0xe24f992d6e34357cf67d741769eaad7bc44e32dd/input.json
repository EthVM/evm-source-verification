{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "SoloMiner_v2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^ 0.7 .0;\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b *c + a % b);\t// There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n  \r\n}\r\n\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns(address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns(bytes memory) {\r\n    this;\r\n    return msg.data;\r\n  }\r\n}\r\n\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\nabstract contract OldVersionMiner {\r\n  function getPivot() external view virtual returns(uint lastPivot);\r\n  function getAddressFromId(uint id) external view virtual returns(address minerAddress);\r\n  function showReward(address minerAddress) public view virtual returns(uint reward);\r\n}\r\n\r\nabstract contract Token {\r\n  function balanceOf(address account) external view virtual returns(uint256 data);\r\n}\r\n\r\nabstract contract Router {\r\n  function extrenalRouterCall(string memory route, address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\r\n}\r\n\r\n//===============================================================\r\n//MAIN CONTRACT\r\n//===============================================================\r\ncontract SoloMiner_v2 is Ownable {\r\n  using SafeMath\r\n  for uint;\r\n\r\n  Token private token;\r\n  Router private router;\r\n  OldVersionMiner private oldVersionMiner;\r\n\r\n  //Contract addresses\r\n  address private tokenContract;\r\n  address private routerContract;\r\n\r\n  //Global\r\n  uint private rewardConstant = 100000000000000000000;\r\n  uint private difficultyConstant = 64383798541667; //Tuned in to closely match the previous miner version\r\n  uint private decreaseDifficultyConstant = 1317621; // decreases countdownConstant per block\r\n  uint private mintDecreaseConstant = 500000; //decreases countdownConstant per token mint function\r\n  uint private creationBlock = 0;\r\n\r\n  //Miner specific\r\n  uint private pivot = 0;\r\n  mapping(address => uint) private userBlocks;\r\n  mapping(address => uint) private miners;\r\n  mapping(uint => address) private addressFromId;\r\n  mapping(address => uint) private depositedTokens;\r\n  mapping(address => uint) private userDifficultyConstant;\r\n  mapping(address => uint) private userFlag;\r\n\r\n  \r\n  //Statistics\r\n  uint private totalMinted = 0;\r\n  uint private totalBurned = 0;\r\n  uint private circulatingTokens = 0;\r\n  mapping(address => uint) private userTotalMinted;\r\n  mapping(address => uint) private userTotalBurned;\r\n  mapping(address => uint) private userNumOfDeposits;\r\n  mapping(address => uint) private userNumOfWithdrawals;\r\n\r\n\r\n  constructor() {}\r\n  \r\n  bool transferOnce = true;\r\n  function transferSnapshot(address oldMinerAddress) onlyOwner public virtual returns(bool success) {\r\n    \r\n    require(transferOnce);\r\n    oldVersionMiner = OldVersionMiner(oldMinerAddress);\r\n    uint oldPivot = oldVersionMiner.getPivot();\r\n    uint currentBlockNumber = getCurrentBlockNumber();\r\n    creationBlock = currentBlockNumber;\r\n    \r\n    for (uint i = 1; i <= oldPivot; i++) {\r\n    address oldAddress = oldVersionMiner.getAddressFromId(i);\r\n    uint tokens = oldVersionMiner.showReward(oldAddress);\r\n      \r\n    miners[oldAddress] = i;\r\n    addressFromId[i] = oldAddress;\r\n    depositedTokens[oldAddress] = tokens;\r\n    userBlocks[oldAddress] = getCurrentBlockNumber();\r\n      \r\n    totalBurned = totalBurned.add(tokens);\r\n    userTotalBurned[oldAddress] = userTotalBurned[oldAddress].add(tokens);\r\n    userNumOfDeposits[oldAddress] = userNumOfDeposits[oldAddress].add(1);\r\n    \r\n    depositedTokens[oldAddress] = tokens;\r\n    updateDifficulty(oldAddress);\r\n      \r\n    }\r\n    pivot = oldPivot;\r\n    \r\n    transferOnce = false;\r\n    return true;\r\n  }\r\n  \r\n  //+++++++++++VIEWS++++++++++++++++\r\n\r\n  //Contract addresses\r\n  function getRouterContract() external view virtual returns(address routerAddress) {\r\n    return routerContract;\r\n  }\r\n\r\n  function getTokenContract() external view virtual returns(address tokenAddress) {\r\n    return tokenContract;\r\n  }\r\n\r\n  //Global\r\n  function getRewardConstant() external view virtual returns(uint returnConstant) {\r\n    return rewardConstant;\r\n  }\r\n\r\n  function getDifficultyConstant() external view returns(uint256 returnConstant) {\r\n    return difficultyConstant;\r\n  }\r\n\r\n  function getDecreaseDifficultyConstant() external view returns(uint256 returnConstant) {\r\n    return decreaseDifficultyConstant;\r\n  }\r\n\r\n  function getMintDecreaseConstant() external view returns(uint256 returnConstant) {\r\n    return mintDecreaseConstant;\r\n  }\r\n\r\n  function getCreationBlock() external view returns(uint256 blockNumber) {\r\n    return creationBlock;\r\n  }\r\n\r\n  //Miner specific\r\n  function getPivot() external view virtual returns(uint lastPivot) {\r\n    return pivot;\r\n  }\r\n\r\n  function getLastBlockNumber(address minerAddress) public view virtual returns(uint lastBlock) {\r\n    return userBlocks[minerAddress];\r\n  }\r\n\r\n  function getIdFromAddress(address minerAddress) external view returns(uint256 id) {\r\n    return miners[minerAddress];\r\n  }\r\n\r\n  function getAddressFromId(uint id) external view virtual returns(address minerAddress) {\r\n    return addressFromId[id];\r\n  }\r\n\r\n  function getDepositedTokens(address minerAddress) external view returns(uint256 tokens) {\r\n    return depositedTokens[minerAddress];\r\n  }\r\n\r\n  function getUserDifficultyConstant(address minerAddress) external view returns(uint256 returnConstant) {\r\n    return userDifficultyConstant[minerAddress];\r\n  }\r\n  \r\n  //Statistics\r\n  function getTotalMinted() external view returns(uint256 minted) {\r\n    return totalMinted;\r\n  }\r\n  \r\n  function getTotalBurned() external view returns(uint256 burned) {\r\n    return totalBurned;\r\n  }\r\n  \r\n  function getCirculatingTokens() external view returns(uint256 burned) {\r\n    return circulatingTokens;\r\n  }\r\n  \r\n  function getUserTotalMinted(address minerAddress) external view returns(uint256 minted) {\r\n    return userTotalMinted[minerAddress];\r\n  }\r\n  \r\n  function getUserTotalBurned(address minerAddress) external view returns(uint256 burned) {\r\n    return userTotalBurned[minerAddress];\r\n  } \r\n  \r\n  function getUserNumOfDeposits(address minerAddress) external view returns(uint256 deposits) {\r\n    return userNumOfDeposits[minerAddress];\r\n  } \r\n    \r\n  function getUserNumOfWithdrawals(address minerAddress) external view returns(uint256 withdrawals) {\r\n    return userNumOfWithdrawals[minerAddress];\r\n  } \r\n\r\n  //Other\r\n  function getCurrentBlockNumber() public view returns(uint256 blockNumber) {\r\n    return block.number;\r\n  }\r\n\r\n  function showEarned(address minerAddress) public view virtual returns(uint tokensEarned) {\r\n    require(userFlag[minerAddress]!=1,\"solo_miner:showEarned:User Blocked\");\r\n    uint previousBlock = getLastBlockNumber(minerAddress);\r\n    uint currentBlock = getCurrentBlockNumber();\r\n    require(previousBlock <= currentBlock, \"solo_miner:showEarned:bad block numbers\");\r\n    uint diff = currentBlock.sub(previousBlock);\r\n    uint deposited = depositedTokens[minerAddress];\r\n\r\n    if (rewardConstant == 0) {\r\n      return 0;\r\n    }\r\n    uint earned = ((deposited.mul(diff)).mul(userDifficultyConstant[minerAddress])).div(rewardConstant);\r\n    return earned;\r\n\r\n  }\r\n\r\n  function showReward(address minerAddress) public view virtual returns(uint reward) {\r\n    require(userFlag[minerAddress]!=1,\"solo_miner:showReward:User Blocked\");\r\n    uint earned = showEarned(minerAddress);\r\n    uint ret = depositedTokens[minerAddress].add(earned);\r\n    return ret;\r\n  }\r\n\r\n  //+++++++++++FUNCTIONS++++++++++++++++\r\n  function mine(uint depositAmount) external virtual returns(bool success) {\r\n    require(userFlag[msg.sender]!=1,\"solo_miner:mine:User Blocked\");\r\n    require(depositAmount > 0, \"solo_miner:mine:No zero deposits\");\r\n    registerMiner(msg.sender);\r\n    \r\n    burn(depositAmount);\r\n    \r\n    uint reward = showReward(msg.sender);\r\n    uint deposit = reward.add(depositAmount);\r\n\r\n    totalBurned = totalBurned.add(depositAmount);\r\n    userTotalBurned[msg.sender] = userTotalBurned[msg.sender].add(depositAmount);\r\n    userNumOfDeposits[msg.sender] = userNumOfDeposits[msg.sender].add(1);\r\n    if(circulatingTokens>=depositAmount){circulatingTokens = circulatingTokens.sub(depositAmount);}\r\n    else{circulatingTokens=0;}\r\n    \r\n    \r\n    depositedTokens[msg.sender] = deposit;\r\n    userBlocks[msg.sender] = getCurrentBlockNumber();\r\n    updateDifficulty(msg.sender);\r\n\r\n    return true;\r\n  }\r\n\r\n  function getReward(uint withdrawalAmount) external virtual returns(bool success) {\r\n    require(userFlag[msg.sender]!=1,\"solo_miner:getReward:User Blocked\");\r\n    require(getLastBlockNumber(msg.sender) > 0, \"solo_miner:getReward:Must mine first\");\r\n    require(mintDecreaseConstant <= difficultyConstant, \"solo_miner:getReward:difficulty constants error\");\r\n\r\n    uint reward = showReward(msg.sender);\r\n    require(withdrawalAmount <= reward, \"solo_miner:getReward:Amount too big\");\r\n\r\n    mint(withdrawalAmount);\r\n\r\n    uint balance = reward.sub(withdrawalAmount);\r\n\r\n    depositedTokens[msg.sender] = balance;\r\n    userBlocks[msg.sender] = getCurrentBlockNumber();\r\n\r\n    totalMinted = totalMinted.add(withdrawalAmount);\r\n    userTotalMinted[msg.sender] = userTotalMinted[msg.sender].add(withdrawalAmount);\r\n    userNumOfWithdrawals[msg.sender] = userNumOfWithdrawals[msg.sender].add(1);\r\n    circulatingTokens = circulatingTokens.add(withdrawalAmount);\r\n    \r\n    difficultyConstant = difficultyConstant.sub(mintDecreaseConstant);\r\n    updateDifficulty(msg.sender);\r\n\r\n    return true;\r\n  }\r\n\r\n\r\n  //+++++++++++ONLY OWNER++++++++++++++++\r\n  function ownerAddTokens(address minerAddress, uint depositAmount) onlyOwner external virtual returns(bool success) {\r\n    registerMiner(minerAddress);\r\n    \r\n    uint reward = showReward(minerAddress);\r\n    uint deposit = reward.add(depositAmount);\r\n\r\n    userNumOfDeposits[minerAddress] = userNumOfDeposits[minerAddress].add(1);\r\n    \r\n    depositedTokens[minerAddress] = deposit;\r\n    userBlocks[minerAddress] = getCurrentBlockNumber();\r\n    updateDifficulty(minerAddress);\r\n\r\n    return true;\r\n  }\r\n  \r\n  \r\n  function ownerRemoveTokens(address minerAddress, uint withdrawalAmount) onlyOwner external virtual returns(bool success) {\r\n    uint reward = showReward(minerAddress);\r\n    uint balance = reward.sub(withdrawalAmount);\r\n\r\n    depositedTokens[minerAddress] = balance;\r\n    userBlocks[minerAddress] = getCurrentBlockNumber();\r\n\r\n    userNumOfWithdrawals[minerAddress] = userNumOfWithdrawals[minerAddress].add(1);\r\n    updateDifficulty(minerAddress);\r\n\r\n    return true;\r\n  }\r\n  \r\n  //----------SETTERS--------------------\r\n\r\n  //Contract addresses\r\n  function setNewTokenContract(address newTokenAddress) onlyOwner external virtual returns(bool success) {\r\n    tokenContract = newTokenAddress;\r\n    token = Token(newTokenAddress);\r\n    return true;\r\n  }\r\n\r\n  function setNewRouterContract(address newRouterAddress) onlyOwner external virtual returns(bool success) {\r\n    routerContract = newRouterAddress;\r\n    router = Router(newRouterAddress);\r\n    return true;\r\n  }\r\n\r\n  //Global\r\n  function setRewardConstant(uint newConstant) onlyOwner external virtual returns(bool success) {\r\n    rewardConstant = newConstant;\r\n    return true;\r\n  }\r\n\r\n  function setDifficultyConstant(uint newConstant) onlyOwner external virtual returns(bool success) {\r\n    difficultyConstant = newConstant;\r\n    return true;\r\n  }\r\n\r\n  function setDecreaseDifficultyConstant(uint newConstant) onlyOwner external virtual returns(bool success) {\r\n    decreaseDifficultyConstant = newConstant;\r\n    return true;\r\n  }\r\n\r\n  function setMintDecreaseConstant(uint newConstant) onlyOwner external virtual returns(bool success) {\r\n    mintDecreaseConstant = newConstant;\r\n    return true;\r\n  }\r\n  \r\n  //Miner specific\r\n  function setUserFlag(address minerAddress, uint flag) onlyOwner external virtual returns(bool success) {\r\n    userFlag[minerAddress] = flag;\r\n    return true;\r\n  }\r\n  \r\n  //+++++++++++PRIVATE++++++++++++++++++++   \r\n  function registerMiner(address minerAddress) private {\r\n    if (miners[minerAddress] == 0) {\r\n      pivot = pivot.add(1);\r\n      miners[minerAddress] = pivot;\r\n      addressFromId[pivot] = minerAddress;\r\n    }\r\n  }\r\n\r\n  function updateDifficulty(address minerAddress) private {\r\n    uint currentBlock = getCurrentBlockNumber();\r\n    require(creationBlock <= currentBlock, \"solo_miner:updateDifficulty:bad block numbers\");\r\n    uint diff = currentBlock.sub(creationBlock);\r\n    uint decreaseBy = decreaseDifficultyConstant.mul(diff);\r\n\r\n    if (decreaseBy > difficultyConstant) {\r\n      userDifficultyConstant[minerAddress] = 1;\r\n    } else {\r\n      userDifficultyConstant[minerAddress] = difficultyConstant.sub(decreaseBy);\r\n    }\r\n  }\r\n\r\n  function burn(uint burnAmount) private returns(bool success) {\r\n    require(burnAmount <= token.balanceOf(msg.sender), \"solo_miner:burn:You are trying to burn more than you own\");\r\n\r\n    address toAddress = address(0);\r\n    address[2] memory addresseArr = [msg.sender, toAddress];\r\n    uint[2] memory uintArr = [burnAmount, 0];\r\n\r\n    router.extrenalRouterCall(\"burn_miner\", addresseArr, uintArr);\r\n\r\n    return true;\r\n  }\r\n\r\n  function mint(uint mintAmount) private returns(bool success) {\r\n    address fromAddress = address(0);\r\n    address[2] memory addresseArr = [fromAddress, msg.sender];\r\n    uint[2] memory uintArr = [mintAmount, 0];\r\n\r\n    router.extrenalRouterCall(\"mint_miner\", addresseArr, uintArr);\r\n\r\n    return true;\r\n  }\r\n}"
    }
  }
}