{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DBTC.sol":{"content":"/***\r\n* \r\n*           _____                    _____                _____                    _____          \r\n*          /\\    \\                  /\\    \\              /\\    \\                  /\\    \\         \r\n*         /::\\    \\                /::\\    \\            /::\\    \\                /::\\    \\        \r\n*        /::::\\    \\              /::::\\    \\           \\:::\\    \\              /::::\\    \\       \r\n*       /::::::\\    \\            /::::::\\    \\           \\:::\\    \\            /::::::\\    \\      \r\n*      /:::/\\:::\\    \\          /:::/\\:::\\    \\           \\:::\\    \\          /:::/\\:::\\    \\     \r\n*     /:::/  \\:::\\    \\        /:::/__\\:::\\    \\           \\:::\\    \\        /:::/  \\:::\\    \\    \r\n*    /:::/    \\:::\\    \\      /::::\\   \\:::\\    \\          /::::\\    \\      /:::/    \\:::\\    \\   \r\n*   /:::/    / \\:::\\    \\    /::::::\\   \\:::\\    \\        /::::::\\    \\    /:::/    / \\:::\\    \\  \r\n*  /:::/    /   \\:::\\ ___\\  /:::/\\:::\\   \\:::\\ ___\\      /:::/\\:::\\    \\  /:::/    /   \\:::\\    \\ \r\n* /:::/____/     \\:::|    |/:::/__\\:::\\   \\:::|    |    /:::/  \\:::\\____\\/:::/____/     \\:::\\____\\\r\n* \\:::\\    \\     /:::|____|\\:::\\   \\:::\\  /:::|____|   /:::/    \\::/    /\\:::\\    \\      \\::/    /\r\n*  \\:::\\    \\   /:::/    /  \\:::\\   \\:::\\/:::/    /   /:::/    / \\/____/  \\:::\\    \\      \\/____/ \r\n*   \\:::\\    \\ /:::/    /    \\:::\\   \\::::::/    /   /:::/    /            \\:::\\    \\             \r\n*    \\:::\\    /:::/    /      \\:::\\   \\::::/    /   /:::/    /              \\:::\\    \\            \r\n*     \\:::\\  /:::/    /        \\:::\\  /:::/    /    \\::/    /                \\:::\\    \\           \r\n*      \\:::\\/:::/    /          \\:::\\/:::/    /      \\/____/                  \\:::\\    \\          \r\n*       \\::::::/    /            \\::::::/    /                                 \\:::\\    \\         \r\n*        \\::::/    /              \\::::/    /                                   \\:::\\____\\        \r\n*         \\::/____/                \\::/____/                                     \\::/    /        \r\n*          ~~                       ~~                                            \\/____/         \r\n*                                                                                                 \r\n* \r\n*     \r\n* https://dbtc.plus v1.0.1\r\n*/\r\n\r\npragma solidity 0.5.17;   \r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface InterfaceDividend {\r\n    function withdrawDividendsEverything() external returns(bool);\r\n}\r\n\r\n\r\ncontract ownerShip\r\n{\r\n    address payable public owner;\r\n    address payable public newOwner;\r\n\r\n    event OwnershipTransferredEv(uint256 timeOfEv, address payable indexed previousOwner, address payable indexed newOwner);\r\n\r\n    constructor() public \r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() \r\n    {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner \r\n    {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public \r\n    {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferredEv(now, owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n\r\n}\r\n\r\ncontract DBTC is ownerShip {\r\n  \r\n    using SafeMath for uint256;       \r\n    string constant public name=\"Decentralized Bitcoin\";\r\n    string constant public symbol=\"DBTC\";\r\n    uint256 constant public decimals=18;\r\n    uint256 public totalSupply = 210000 * ( 10 ** decimals);\r\n    uint256 public minTotalSupply = 2100 * ( 10 ** decimals);\r\n    uint256 public constant minSupply = 21 * ( 10 ** decimals);\r\n    uint256 public  _burnPercent = 500;  // 500 = 5%\r\n    uint256 public  _burnPercentAll = 1000;  // 1000 = 10%\r\n    uint256 public constant _invite1Percent = 300;  // 300 = 3%\r\n    uint256 public constant _invite2Percent = 200;  // 200 =2%\r\n    address public constant uni = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    address public constant AirdropAddress = address(0x91De8F260f05d0aB3C51911d8B43793D82B84d66);\r\n    address public constant CreateAddress = address(0x4b5d1ebFe85f399B728F655f77142459470549A6);\r\n    address public TradeAddress;\r\n    \r\n    address public dividendContractAdderess;\r\n\r\n    struct Miner {\r\n      address address1;\r\n      address address2;\r\n    }\r\n\r\n    mapping(address => Miner) public miners;\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed approvedBy, address indexed spender, uint256 value);\r\n    event WhitelistFrom(address _addr, bool _whitelisted);\r\n    event WhitelistTo(address _addr, bool _whitelisted);\r\n\r\n    mapping(address => bool) public whitelistFrom;\r\n    mapping(address => bool) public whitelistTo;\r\n  \r\n    constructor( ) public\r\n    {\r\n        balanceOf[CreateAddress] = 170000 * ( 10 ** decimals);\r\n        balanceOf[AirdropAddress] = 40000 * ( 10 ** decimals);\r\n        emit Transfer(address(0), CreateAddress, 170000 * ( 10 ** decimals));\r\n        emit Transfer(address(0), AirdropAddress, 40000 * ( 10 ** decimals));\r\n    }\r\n    \r\n    function () payable external {}\r\n    \r\n\r\n    function _isWhitelisted(address _from, address _to) internal view returns (bool) {\r\n        return whitelistFrom[_from]||whitelistTo[_to];\r\n    }\r\n\r\n    function setWhitelistedTo(address _addr, bool _whitelisted) external onlyOwner {\r\n        emit WhitelistTo(_addr, _whitelisted);\r\n        whitelistTo[_addr] = _whitelisted;\r\n    }\r\n\r\n    function setWhitelistedFrom(address _addr, bool _whitelisted) external onlyOwner {\r\n        emit WhitelistFrom(_addr, _whitelisted);\r\n        whitelistFrom[_addr] = _whitelisted;\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_value <= balanceOf[_from], 'Not enough balance');  \r\n        balanceOf[_from] = balanceOf[_from].sub(_value);    \r\n        balanceOf[_to] = balanceOf[_to].add(_value);        \r\n\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n\r\n        if(totalSupply <= minTotalSupply){\r\n            _burnPercent = 0;\r\n            _burnPercentAll = 0;\r\n        }\r\n\r\n        uint256 invite1to = calculatePercentage(_value,_invite1Percent);\r\n        uint256 invite2to = calculatePercentage(_value,_invite2Percent);\r\n        uint256 tokensToBurn = calculatePercentage(_value,_burnPercent);\r\n        uint256 tokensToBurnAll = calculatePercentage(_value,_burnPercentAll);\r\n\r\n        if(_isWhitelisted(msg.sender, _to)){\r\n            if ( _to != msg.sender && _to != TradeAddress && _to != uni && _to != AirdropAddress && _to != CreateAddress){\r\n                if(miners[_to].address1 == address(0)){\r\n                    miners[_to].address1 = msg.sender;\r\n                }\r\n            }\r\n            _transfer(msg.sender, _to, _value - tokensToBurnAll);\r\n            _burn(msg.sender, tokensToBurnAll);\r\n            return true;\r\n        }\r\n\r\n        if(msg.sender == uni && _to == TradeAddress){\r\n            _transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else if (msg.sender == TradeAddress && _to == uni){\r\n            _transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n\r\n        if(msg.sender == TradeAddress  && _to != uni){\r\n            if (miners[_to].address1 != address(0) && miners[_to].address2 != address(0)){\r\n                if (balanceOf[miners[_to].address1] >= minSupply && balanceOf[miners[_to].address2] >= minSupply){\r\n                    _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\r\n                    _transfer(msg.sender, miners[_to].address1,invite1to);\r\n                    _transfer(msg.sender, miners[_to].address2,invite2to);\r\n                    _burn(msg.sender, tokensToBurn);\r\n                    return true;\r\n                } else if (balanceOf[miners[_to].address1] >= minSupply && balanceOf[miners[_to].address2] < minSupply){\r\n                    _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\r\n                    _transfer(msg.sender, miners[_to].address1,invite1to);\r\n                    _burn(msg.sender, tokensToBurn + invite2to);\r\n                    return true;\r\n                } else if (balanceOf[miners[_to].address1] < minSupply && balanceOf[miners[_to].address2] >= minSupply){\r\n                    _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\r\n                    _transfer(msg.sender, miners[_to].address2,invite2to);\r\n                    _burn(msg.sender, tokensToBurn + invite1to);\r\n                    return true;\r\n                } else {\r\n                    _transfer(msg.sender, _to, _value - tokensToBurnAll);\r\n                    _burn(msg.sender, tokensToBurnAll);\r\n                    return true;\r\n                }\r\n            } else if (miners[_to].address1 != address(0)){\r\n                if (balanceOf[miners[_to].address1] >= minSupply){\r\n                    _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn );\r\n                    _transfer(msg.sender, miners[_to].address1,invite1to);\r\n                    _burn(msg.sender, tokensToBurn + invite2to);\r\n                    return true;\r\n                } else {\r\n                    _transfer(msg.sender, _to, _value - tokensToBurnAll);\r\n                    _burn(msg.sender, tokensToBurnAll);\r\n                    return true;\r\n                }\r\n            }        \r\n        }\r\n\r\n        if (miners[msg.sender].address1 != address(0) && miners[msg.sender].address2 != address(0) && miners[_to].address1 != address(0)){\r\n            if (balanceOf[miners[msg.sender].address1] >= minSupply && balanceOf[miners[msg.sender].address2] >= minSupply){\r\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\r\n                _transfer(msg.sender, miners[msg.sender].address1,invite1to);\r\n                _transfer(msg.sender, miners[msg.sender].address2,invite2to);\r\n                _burn(msg.sender, tokensToBurn);\r\n                return true;\r\n            } else if (balanceOf[miners[msg.sender].address1] >= minSupply && balanceOf[miners[msg.sender].address2] < minSupply){\r\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\r\n                _transfer(msg.sender, miners[msg.sender].address1,invite1to);\r\n                _burn(msg.sender, tokensToBurn + invite2to);\r\n                return true;\r\n            } else if (balanceOf[miners[msg.sender].address1] < minSupply && balanceOf[miners[msg.sender].address2] >= minSupply){\r\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\r\n                _transfer(msg.sender, miners[msg.sender].address2,invite2to);\r\n                _burn(msg.sender, tokensToBurn + invite1to);\r\n                return true;\r\n            } else {\r\n                _transfer(msg.sender, _to, _value - tokensToBurnAll);\r\n                _burn(msg.sender, tokensToBurnAll);\r\n                return true;\r\n            }\r\n        } else if (miners[msg.sender].address1 != address(0) && miners[msg.sender].address2 != address(0) && miners[_to].address1 == address(0)){\r\n            if (balanceOf[miners[msg.sender].address1] >= minSupply && balanceOf[miners[msg.sender].address2] >= minSupply){\r\n\r\n                if ( _to != msg.sender && _to != TradeAddress && _to != uni && _to != AirdropAddress && _to != CreateAddress){\r\n                    if(miners[_to].address1 == address(0)){\r\n                        if(balanceOf[msg.sender] >= minSupply){\r\n                        miners[_to].address1 = msg.sender;\r\n                        miners[_to].address2 = miners[msg.sender].address1;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\r\n                _transfer(msg.sender, miners[msg.sender].address1,invite1to);\r\n                _transfer(msg.sender, miners[msg.sender].address2,invite2to);\r\n                _burn(msg.sender, tokensToBurn);\r\n                return true;\r\n            } else if (balanceOf[miners[msg.sender].address1] >= minSupply && balanceOf[miners[msg.sender].address2] < minSupply){\r\n\r\n                if ( _to != msg.sender && _to != TradeAddress && _to != uni && _to != AirdropAddress && _to != CreateAddress){\r\n                    if(miners[_to].address1 == address(0)){\r\n                        if(balanceOf[msg.sender] >= minSupply){\r\n                        miners[_to].address1 = msg.sender;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\r\n                _transfer(msg.sender, miners[msg.sender].address1,invite1to);\r\n                _burn(msg.sender, tokensToBurn + invite2to);\r\n                return true;\r\n            } else if (balanceOf[miners[msg.sender].address1] < minSupply && balanceOf[miners[msg.sender].address2] >= minSupply){\r\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\r\n                _transfer(msg.sender, miners[msg.sender].address2,invite2to);\r\n                _burn(msg.sender, tokensToBurn + invite1to );\r\n                return true;\r\n            } else {\r\n                _transfer(msg.sender, _to, _value - tokensToBurnAll);\r\n                _burn(msg.sender, tokensToBurnAll);\r\n                return true;\r\n            }\r\n        } else if (miners[msg.sender].address1 != address(0) && miners[msg.sender].address2 == address(0) && miners[_to].address1 == address(0)){\r\n            if (balanceOf[miners[msg.sender].address1] >= minSupply){\r\n\r\n                if ( _to != msg.sender && _to != TradeAddress && _to != uni && _to != AirdropAddress && _to != CreateAddress){\r\n                    if(balanceOf[msg.sender] >= minSupply){\r\n                    miners[_to].address1 = msg.sender;\r\n                    miners[_to].address2 = miners[msg.sender].address1;\r\n                    }\r\n                }\r\n\r\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\r\n                _transfer(msg.sender, miners[msg.sender].address1,invite1to);\r\n                _burn(msg.sender, tokensToBurn + invite2to);\r\n                return true;\r\n            } else {\r\n                _transfer(msg.sender, _to, _value - tokensToBurnAll );\r\n                _burn(msg.sender, tokensToBurnAll);\r\n                return true;\r\n          }\r\n        } else if (miners[msg.sender].address1 == address(0) && miners[msg.sender].address2 == address(0) && miners[_to].address1 == address(0)){\r\n\r\n                if ( _to != msg.sender && _to != TradeAddress && _to != uni && _to != AirdropAddress && _to != CreateAddress){\r\n                    if(balanceOf[msg.sender] >= minSupply){\r\n                    miners[_to].address1 = msg.sender;\r\n                    }\r\n                }\r\n\r\n                _transfer(msg.sender, _to, _value - tokensToBurnAll);\r\n                _burn(msg.sender, tokensToBurnAll);\r\n                return true;\r\n        }\r\n\r\n        if(miners[_to].address1 == address(0)){\r\n            if(balanceOf[msg.sender] >= minSupply){\r\n            miners[_to].address1 = msg.sender;\r\n            }\r\n        }\r\n\r\n        _transfer(msg.sender, _to, _value - tokensToBurnAll);\r\n        _burn(msg.sender, tokensToBurnAll);\r\n        return true;\r\n\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\r\n        if(totalSupply <= minTotalSupply){\r\n            _burnPercent = 0;\r\n            _burnPercentAll = 0;\r\n        }\r\n\r\n        uint256 tokensToBurn = calculatePercentage(_value,_burnPercent);\r\n        uint256 invite1to = calculatePercentage(_value,_invite1Percent);\r\n        uint256 invite2to = calculatePercentage(_value,_invite2Percent);\r\n        uint256 tokensToBurnAll = calculatePercentage(_value,_burnPercentAll);\r\n        \r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n\r\n        if(_isWhitelisted(_from, _to)){\r\n            if ( _to != _from && _to != TradeAddress && _to != uni && _to != AirdropAddress && _to != CreateAddress){\r\n                if ( miners[_to].address1 == address(0) ){\r\n                    miners[_to].address1 = _from;\r\n                }\r\n            }\r\n            _transfer(_from, _to, _value - tokensToBurnAll);\r\n            _burn(_from, tokensToBurnAll);\r\n            return true;\r\n        }\r\n\r\n        if(_from == uni && _to == TradeAddress){\r\n            _transfer(_from, _to, _value);\r\n            return true;\r\n        } else if (_from == TradeAddress && _to == uni){\r\n            _transfer(_from, _to, _value);\r\n            return true;\r\n        } \r\n\r\n        if (miners[_from].address1 != address(0) && miners[_from].address2 != address(0)){\r\n            if (balanceOf[miners[_from].address1] >= minSupply && balanceOf[miners[_from].address2] >= minSupply){\r\n                _transfer(_from, _to, _value - invite1to - invite2to - tokensToBurn);\r\n                _transfer(_from, miners[_from].address1,invite1to);\r\n                _transfer(_from, miners[_from].address2,invite2to);\r\n                _burn(_from, tokensToBurn);\r\n                return true;\r\n            } else if (balanceOf[miners[_from].address1] >= minSupply && balanceOf[miners[_from].address2] < minSupply){\r\n                _transfer(_from, _to, _value - invite1to - invite2to - tokensToBurn);\r\n                _transfer(_from, miners[_from].address1,invite1to);\r\n                _burn(_from, tokensToBurn + invite2to);\r\n                return true;\r\n            } else if (balanceOf[miners[_from].address1] < minSupply && balanceOf[miners[_from].address2] >= minSupply){\r\n                _transfer(_from, _to, _value - invite1to - invite2to - tokensToBurn);\r\n                _transfer(_from, miners[_from].address2,invite2to);\r\n                _burn(_from, tokensToBurn + invite1to);\r\n                return true;\r\n            } else {\r\n                _transfer(_from, _to, _value - tokensToBurnAll);\r\n                _burn(_from, tokensToBurnAll);\r\n                return true;\r\n            }\r\n        } else if (miners[_from].address1 != address(0)){\r\n            if (balanceOf[miners[_from].address1] >= minSupply){\r\n                _transfer(_from, _to, _value - invite1to - invite2to - tokensToBurn );\r\n                _transfer(_from, miners[_from].address1,invite1to);\r\n                _burn(_from, tokensToBurn + invite2to);\r\n                return true;\r\n            } else {\r\n                _transfer(_from, _to, _value - tokensToBurnAll);\r\n                _burn(_from, tokensToBurnAll);\r\n                return true;\r\n            }\r\n        }\r\n        \r\n        _transfer(_from, _to, _value - tokensToBurnAll);\r\n        _burn(_from, tokensToBurnAll);\r\n        return true;\r\n\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        \r\n        address user = msg.sender;  //local variable is gas cheaper than reading from storate multiple time\r\n\r\n        require(_value <= balanceOf[user], 'Not enough balance');\r\n        \r\n        allowance[user][_spender] = _value;\r\n        emit Approval(user, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n    \r\n        uint256 newAmount = allowance[msg.sender][spender].add(addedValue);\r\n        approve(spender, newAmount);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n    \r\n        uint256 newAmount = allowance[msg.sender][spender].sub(subtractedValue);\r\n        approve(spender, newAmount);\r\n        \r\n        return true;\r\n    }\r\n\r\n    function calculatePercentage(uint256 PercentOf, uint256 percentTo ) internal pure returns (uint256) \r\n    {\r\n        uint256 factor = 10000;\r\n        require(percentTo <= factor);\r\n        uint256 c = PercentOf.mul(percentTo).div(factor);\r\n        return c;\r\n    }\r\n\r\n    \r\n    function setBurningRate(uint burnPercent) onlyOwner public returns(bool success)\r\n    {\r\n        _burnPercent = burnPercent;\r\n        return true;\r\n    }\r\n    \r\n    function updateMinimumTotalSupply(uint minimumTotalSupplyWEI) onlyOwner public returns(bool success)\r\n    {\r\n        minTotalSupply = minimumTotalSupplyWEI;\r\n        return true;\r\n    }\r\n    \r\n    \r\n    \r\n    function _burn(address account, uint256 amount) internal returns(bool) {\r\n        if(totalSupply > minTotalSupply)\r\n        {\r\n          totalSupply = totalSupply.sub(amount);\r\n          balanceOf[account] = balanceOf[account].sub(amount);\r\n          emit Transfer(account, address(0), amount);\r\n          return true;\r\n        }\r\n    }\r\n\r\n    function burnToken(uint256 amount) public onlyOwner {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    function setTradeAddress(address addr) public onlyOwner {\r\n        TradeAddress = addr;\r\n    }\r\n\r\n    function manualWithdrawTokens(uint256 tokenAmount) public onlyOwner returns(string memory){\r\n        _transfer(address(this), owner, tokenAmount);\r\n        return \"Tokens withdrawn to owner wallet\";\r\n    }\r\n\r\n\r\n    function manualWithdrawEther(uint256 amount) public onlyOwner returns(string memory){\r\n        owner.transfer(amount);\r\n        return \"Ether withdrawn to owner wallet\";\r\n    }\r\n\r\n    function updateDividendContractAddress(address dividendContract) public onlyOwner returns(string memory){\r\n        dividendContractAdderess = dividendContract;\r\n        return \"dividend conract address updated successfully\";\r\n    }\r\n\r\n    function airDrop(address[] memory recipients,uint[] memory tokenAmount) public onlyOwner returns (bool) {\r\n        uint reciversLength  = recipients.length;\r\n        require(reciversLength <= 150);\r\n        for(uint i = 0; i < reciversLength; i++)\r\n        {\r\n            if (gasleft() < 100000)\r\n            {\r\n                break;\r\n            }\r\n              _transfer(owner, recipients[i], tokenAmount[i]);\r\n              miners[recipients[i]].address1 = msg.sender;\r\n        }\r\n        return true;\r\n    }\r\n}"}}}