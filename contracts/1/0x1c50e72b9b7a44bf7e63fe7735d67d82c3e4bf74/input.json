{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "PresaleKredEth.sol": {
      "content": "pragma solidity ^0.8.9;\r\n\r\n//SPDX-License-Identifier: MIT Licensed\r\n\r\ninterface IBEP20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n}\r\n\r\ncontract VerifySignature {\r\n    address internal signer;\r\n\r\n    function verify(\r\n        address _user,\r\n        uint256[3] memory _slotsQty,\r\n        uint256 _nonce,\r\n        bytes memory _sign\r\n    ) public view returns (bool) {\r\n        bytes32 messageHash = getMessageHash(\r\n            _user,\r\n            uint2str(_slotsQty[0]),\r\n            uint2str(_slotsQty[1]),\r\n            uint2str(_slotsQty[2]),\r\n            uint2str(_nonce)\r\n        );\r\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\r\n\r\n        return recoverSigner(ethSignedMessageHash, _sign) == signer;\r\n    }\r\n\r\n    function getMessageHash(\r\n        address _user,\r\n        string memory _slotsQty1,\r\n        string memory _slotsQty2,\r\n        string memory _slotsQty3,\r\n        string memory _nonce\r\n    ) private pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    _user,\r\n                    _slotsQty1,\r\n                    _slotsQty2,\r\n                    _slotsQty3,\r\n                    _nonce\r\n                )\r\n            );\r\n    }\r\n\r\n    function getEthSignedMessageHash(bytes32 _messageHash)\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /*\r\n        Signature is produced by signing a keccak256 hash with the following format:\r\n        \"\\x19Ethereum Signed Message\\n\" + len(msg) + msg\r\n        */\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19Ethereum Signed Message:\\n32\",\r\n                    _messageHash\r\n                )\r\n            );\r\n    }\r\n\r\n    function recoverSigner(\r\n        bytes32 _ethSignedMessageHash,\r\n        bytes memory _signature\r\n    ) private pure returns (address) {\r\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\r\n\r\n        return ecrecover(_ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    function splitSignature(bytes memory sig)\r\n        private\r\n        pure\r\n        returns (\r\n            bytes32 r,\r\n            bytes32 s,\r\n            uint8 v\r\n        )\r\n    {\r\n        require(sig.length == 65, \"invalid signature length\");\r\n\r\n        assembly {\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n    }\r\n\r\n    function uint2str(uint256 _i)\r\n        private\r\n        pure\r\n        returns (string memory _uintAsString)\r\n    {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 j = _i;\r\n        uint256 len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint256 k = len;\r\n        while (_i != 0) {\r\n            k = k - 1;\r\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\r\n\r\ncontract PresaleKredEth is VerifySignature {\r\n\r\n    // mainnet\r\n    address[2] public coins = [\r\n        0xdAC17F958D2ee523a2206206994597C13D831ec7, // USDT\r\n        0x6B175474E89094C44Da98b954EedeAC495271d0F // DAI\r\n    ];\r\n    AggregatorV3Interface internal priceFeed =\r\n        AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n\r\n    address payable public owner;\r\n    uint256 public preSaleStartTime;\r\n    uint256 public preSaleEndTime;\r\n    uint256 public soldToken;\r\n    uint256 public amountRaised;\r\n\r\n    // Public Presale\r\n    uint256[5] public usdSlots = [4000, 2000, 800];\r\n    uint256[3] public tokensPerSlot = [100000000e18, 33333333e18, 10000000e18];\r\n    address[] public buyers;\r\n\r\n    mapping(address => mapping(uint256 => uint256)) public users;\r\n    mapping(address => uint256) public nonce;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"PreSale: Not an owner\");\r\n        _;\r\n    }\r\n\r\n    modifier isVerified(\r\n        address _user,\r\n        uint256[3] memory _slotsQty,\r\n        uint256 _nonce,\r\n        bytes memory _sign\r\n    ) {\r\n        require(_nonce > nonce[msg.sender], \"Presale: invalid nonce\");\r\n        require(\r\n            verify(_user, _slotsQty, _nonce, _sign),\r\n            \"Presale: Unverified.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    event BuyToken(address _user, uint256 _amount);\r\n    event ClaimToken(address _user, uint256 _amount);\r\n\r\n    constructor(address _signer) {\r\n        owner = payable(msg.sender);\r\n        signer = _signer;\r\n\r\n        // Setting presale time.\r\n        preSaleStartTime = block.timestamp;\r\n        preSaleEndTime = block.timestamp + 30 days;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    // to buy token during public preSale time => for web3 use\r\n    function buyTokenETH(\r\n        uint256[3] memory _slotsQty,\r\n        uint256 _nonce,\r\n        bytes memory _sign\r\n    ) public payable isVerified(msg.sender, _slotsQty, _nonce, _sign) {\r\n        require(_slotsQty.length == 3, \"PreSale: Invalid Slots\");\r\n        require(\r\n            block.timestamp >= preSaleStartTime,\r\n            \"PreSale: PreSale not started yet\"\r\n        );\r\n        require(block.timestamp < preSaleEndTime, \"PreSale: PreSale over\");\r\n        if (getUserTotalTokens(msg.sender) == 0) {\r\n            buyers.push(msg.sender);\r\n        }\r\n        // Check requried eth for slot.\r\n        uint256 totalUsd = usdSlots[0] * (_slotsQty[0]);\r\n        totalUsd = totalUsd + (usdSlots[1] * (_slotsQty[1]));\r\n        totalUsd = totalUsd + (usdSlots[2] * (_slotsQty[2]));\r\n        require(msg.value >= usdToETH(totalUsd), \"PreSale: Invalid Amount\");\r\n        amountRaised = amountRaised + (totalUsd);\r\n\r\n        uint256 totalTokens;\r\n        for (uint256 i = 0; i < 3; i++) {\r\n            if (_slotsQty[i] > 0) {\r\n                _updateUserData(msg.sender, i, _slotsQty[i]);\r\n                totalTokens = totalTokens + (\r\n                    tokensPerSlot[i] * (_slotsQty[i])\r\n                );\r\n            }\r\n        }\r\n\r\n        require(totalTokens > 0, \"Presale: not buy any slot.\");\r\n        nonce[msg.sender] = _nonce;\r\n        emit BuyToken(msg.sender, totalTokens);\r\n    }\r\n\r\n    // to buy token during public preSale time => for web3 use\r\n    function buyToken(\r\n        uint256 choice,\r\n        uint256[3] memory _slotsQty,\r\n        uint256 _nonce,\r\n        bytes memory _sign\r\n    ) public isVerified(msg.sender, _slotsQty, _nonce, _sign) {\r\n        require(_slotsQty.length == 3, \"PreSale: Invalid Slots\");\r\n        require(choice < coins.length, \"PreSale: Invalid token\");\r\n        require(\r\n            block.timestamp >= preSaleStartTime,\r\n            \"PreSale: PreSale not started yet\"\r\n        );\r\n        require(block.timestamp < preSaleEndTime, \"PreSale: PreSale over\");\r\n        if (getUserTotalTokens(msg.sender) == 0) {\r\n            buyers.push(msg.sender);\r\n        }\r\n        uint256 totalUsd = usdSlots[0] * (_slotsQty[0]);\r\n        totalUsd = totalUsd + (usdSlots[1] * (_slotsQty[1]));\r\n        totalUsd = totalUsd + (usdSlots[2] * (_slotsQty[2]));\r\n        uint256 tokenDecimals = 10**IBEP20(coins[choice]).decimals();\r\n        IBEP20(coins[choice]).transferFrom(\r\n            msg.sender,\r\n            owner,\r\n            totalUsd * (tokenDecimals)\r\n        );\r\n        amountRaised = amountRaised + (totalUsd);\r\n\r\n        uint256 totalTokens;\r\n        for (uint256 i = 0; i < 3; i++) {\r\n            if (_slotsQty[i] > 0) {\r\n                _updateUserData(msg.sender, i, _slotsQty[i]);\r\n                totalTokens = totalTokens + (\r\n                    tokensPerSlot[i] * (_slotsQty[i])\r\n                );\r\n            }\r\n        }\r\n\r\n        require(totalTokens > 0, \"Presale: not buy any slot.\");\r\n        nonce[msg.sender] = _nonce;\r\n        emit BuyToken(msg.sender, totalTokens);\r\n    }\r\n\r\n    function _updateUserData(\r\n        address _user,\r\n        uint256 slotIndex,\r\n        uint256 _qty\r\n    ) private {\r\n        // Set User data.\r\n        users[_user][slotIndex] = users[_user][slotIndex] + (\r\n            tokensPerSlot[slotIndex] * (_qty)\r\n        );\r\n\r\n        // Set total info\r\n        soldToken = soldToken + (tokensPerSlot[slotIndex] * (_qty));\r\n    }\r\n\r\n    //this code assumes that 1usd is equal to 1 unit.\r\n    function usdToETH(uint256 value) public view returns (uint256) {\r\n        return value * (1e18) * (10**priceFeed.decimals()) / (getLatestPriceETH());\r\n    }\r\n\r\n    function getLatestPriceETH() public view returns (uint256) {\r\n        (, int256 price, , , ) = priceFeed.latestRoundData();\r\n        return uint256(price);\r\n    }\r\n\r\n    function getUserTotalTokens(address _user)\r\n        public\r\n        view\r\n        returns (uint256 total)\r\n    {\r\n        for (uint256 i = 0; i < usdSlots.length; i++) {\r\n            total = total + (users[_user][i]);\r\n        }\r\n    }\r\n\r\n    function updatePriceAggregator(address _feedAddress) public onlyOwner {\r\n        priceFeed = AggregatorV3Interface(_feedAddress);\r\n    }\r\n\r\n    function setPublicPreSale(uint256 _startTime, uint256 _endTime)\r\n        external\r\n        onlyOwner\r\n    {\r\n        preSaleStartTime = _startTime;\r\n        preSaleEndTime = _endTime;\r\n    }\r\n\r\n    function changeOwner(address payable _newOwner) external onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function changeSigner(address _newSigner) external onlyOwner {\r\n        signer = _newSigner;\r\n    }\r\n\r\n    function updateCoinAddress(uint256 choice, address _token)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(choice < coins.length, \"Invalid token\");\r\n        coins[choice] = _token;\r\n    }\r\n\r\n    function withdrawEth(uint256 _amount) external onlyOwner {\r\n        owner.transfer(_amount);\r\n    }\r\n\r\n    function withdrawToken(address _token, uint256 _amount) external onlyOwner {\r\n        IBEP20(_token).transfer(owner, _amount);\r\n    }\r\n}"
    }
  }
}