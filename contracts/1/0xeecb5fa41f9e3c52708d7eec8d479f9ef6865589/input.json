{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DosCommasClub.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation.\r\nabstract contract ERC721 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERC-721 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    uint256 public totalSupply;\r\n    \r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(uint256 => address) public ownerOf;\r\n\r\n    mapping(uint256 => string) public tokenURI;\r\n\r\n    mapping(uint256 => address) public getApproved;\r\n\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            EIP-2612-LIKE STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        keccak256('Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)');\r\n\r\n    bytes32 public constant PERMIT_ALL_TYPEHASH = \r\n        keccak256('Permit(address owner,address spender,uint256 nonce,uint256 deadline)');\r\n    \r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(uint256 => uint256) public nonces;\r\n\r\n    mapping(address => uint256) public noncesForAll;\r\n    \r\n    /*///////////////////////////////////////////////////////////////\r\n                            CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    constructor(string memory _name, string memory _symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        \r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERC-721 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool supported) {\r\n        supported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f || interfaceId == 0x01ffc9a7;\r\n    }\r\n    \r\n    function approve(address spender, uint256 tokenId) public virtual {\r\n        address owner = ownerOf[tokenId];\r\n        \r\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], 'NOT_APPROVED');\r\n        \r\n        getApproved[tokenId] = spender;\r\n        \r\n        emit Approval(owner, spender, tokenId); \r\n    }\r\n    \r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n        \r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n    \r\n    function transfer(address to, uint256 tokenId) public virtual returns (bool success) {\r\n        require(msg.sender == ownerOf[tokenId], 'NOT_OWNER');\r\n        \r\n        // this is safe because ownership is checked\r\n        // against decrement, and sum of all user\r\n        // balances can't exceed 'type(uint256).max'\r\n        unchecked {\r\n            balanceOf[msg.sender]--; \r\n        \r\n            balanceOf[to]++;\r\n        }\r\n        \r\n        delete getApproved[tokenId];\r\n        \r\n        ownerOf[tokenId] = to;\r\n        \r\n        emit Transfer(msg.sender, to, tokenId); \r\n        \r\n        success = true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from, \r\n        address to, \r\n        uint256 tokenId\r\n    ) public virtual {\r\n        require(from == ownerOf[tokenId], 'NOT_OWNER');\r\n        \r\n        require(\r\n            msg.sender == from \r\n            || msg.sender == getApproved[tokenId]\r\n            || isApprovedForAll[from][msg.sender], \r\n            'NOT_APPROVED'\r\n        );\r\n        \r\n        // this is safe because ownership is checked\r\n        // against decrement, and sum of all user\r\n        // balances can't exceed 'type(uint256).max'\r\n        unchecked { \r\n            balanceOf[from]--; \r\n        \r\n            balanceOf[to]++;\r\n        }\r\n        \r\n        delete getApproved[tokenId];\r\n        \r\n        ownerOf[tokenId] = to;\r\n        \r\n        emit Transfer(from, to, tokenId); \r\n    }\r\n    \r\n    function safeTransferFrom(\r\n        address from, \r\n        address to, \r\n        uint256 tokenId\r\n    ) public virtual {\r\n        safeTransferFrom(from, to, tokenId, '');\r\n    }\r\n    \r\n    function safeTransferFrom(\r\n        address from, \r\n        address to, \r\n        uint256 tokenId, \r\n        bytes memory data\r\n    ) public virtual {\r\n        transferFrom(from, to, tokenId); \r\n        \r\n        if (to.code.length != 0) {\r\n            // selector = `onERC721Received(address,address,uint256,bytes)`\r\n            (, bytes memory returned) = to.staticcall(abi.encodeWithSelector(0x150b7a02,\r\n                msg.sender, from, tokenId, data));\r\n                \r\n            bytes4 selector = abi.decode(returned, (bytes4));\r\n            \r\n            require(selector == 0x150b7a02, 'NOT_ERC721_RECEIVER');\r\n        }\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            EIP-2612-LIKE LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 domainSeparator) {\r\n        domainSeparator = block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : _computeDomainSeparator();\r\n    }\r\n\r\n    function _computeDomainSeparator() internal view virtual returns (bytes32 domainSeparator) {\r\n        domainSeparator = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                block.chainid,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n    \r\n    function permit(\r\n        address spender,\r\n        uint256 tokenId,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(block.timestamp <= deadline, 'PERMIT_DEADLINE_EXPIRED');\r\n        \r\n        address owner = ownerOf[tokenId];\r\n        \r\n        // this is reasonably safe from overflow because incrementing `nonces` beyond\r\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    '\\x19\\x01',\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, nonces[tokenId]++, deadline))\r\n                )\r\n            );\r\n\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n\r\n            require(recoveredAddress != address(0), 'INVALID_PERMIT_SIGNATURE');\r\n\r\n            require(recoveredAddress == owner || isApprovedForAll[owner][recoveredAddress], 'INVALID_SIGNER');\r\n        }\r\n        \r\n        getApproved[tokenId] = spender;\r\n\r\n        emit Approval(owner, spender, tokenId);\r\n    }\r\n    \r\n    function permitAll(\r\n        address owner,\r\n        address operator,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(block.timestamp <= deadline, 'PERMIT_DEADLINE_EXPIRED');\r\n        \r\n        // this is reasonably safe from overflow because incrementing `nonces` beyond\r\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    '\\x19\\x01',\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(PERMIT_ALL_TYPEHASH, owner, operator, noncesForAll[owner]++, deadline))\r\n                )\r\n            );\r\n\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n            \r\n            require(\r\n                (recoveredAddress != address(0) && recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress],\r\n                'INVALID_PERMIT_SIGNATURE'\r\n            );\r\n        }\r\n        \r\n        isApprovedForAll[owner][operator] = true;\r\n\r\n        emit ApprovalForAll(owner, operator, true);\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    function _mint(\r\n        address to, \r\n        uint256 tokenId, \r\n        string memory tokenURI_\r\n    ) internal virtual { \r\n        require(ownerOf[tokenId] == address(0), 'ALREADY_MINTED');\r\n  \r\n        // this is reasonably safe from overflow because incrementing `totalSupply` beyond\r\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits,\r\n        // and because the sum of all user balances can't exceed 'type(uint256).max'\r\n        unchecked {\r\n            totalSupply++;\r\n            \r\n            balanceOf[to]++;\r\n        }\r\n        \r\n        ownerOf[tokenId] = to;\r\n        \r\n        tokenURI[tokenId] = tokenURI_;\r\n        \r\n        emit Transfer(address(0), to, tokenId); \r\n    }\r\n    \r\n    function _burn(uint256 tokenId) internal virtual { \r\n        address owner = ownerOf[tokenId];\r\n        \r\n        require(ownerOf[tokenId] != address(0), 'NOT_MINTED');\r\n        \r\n        // this is safe because a user won't ever\r\n        // have a balance larger than `totalSupply`\r\n        unchecked {\r\n            totalSupply--;\r\n        \r\n            balanceOf[owner]--;\r\n        }\r\n        \r\n        delete ownerOf[tokenId];\r\n        \r\n        delete tokenURI[tokenId];\r\n        \r\n        emit Transfer(owner, address(0), tokenId); \r\n    }\r\n}\r\n\r\n/// @notice Limited accreditation NFT registry for Kalicos and public.\r\ncontract DosCommasClub is ERC721 {\r\n    event Mint(address indexed to, string details);\r\n\r\n    string public baseURI;\r\n\r\n    uint256 public mintCap;\r\n\r\n    address public dao;\r\n\r\n    mapping(uint256 => string) public details;\r\n\r\n    mapping(uint256 => bool) public valid;\r\n\r\n    modifier onlyDAO {\r\n        require(msg.sender == dao, 'NOT_DAO');\r\n\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string memory name_, \r\n        string memory symbol_, \r\n        string memory baseURI_, \r\n        uint256 mintCap_\r\n    ) ERC721(name_, symbol_) {\r\n        baseURI = baseURI_;\r\n\r\n        mintCap = mintCap_;\r\n\r\n        dao = msg.sender;\r\n    }\r\n    \r\n    function mint(address to, string calldata details_) external onlyDAO { \r\n        require(totalSupply < mintCap, 'CAPPED');\r\n\r\n        uint256 tokenId = totalSupply;\r\n\r\n        _mint(\r\n            to, \r\n            tokenId, \r\n            baseURI\r\n        );\r\n\r\n        details[tokenId] = details_;\r\n\r\n        valid[tokenId] = true;\r\n\r\n        emit Mint(to, details_);\r\n    }\r\n\r\n    function burn(uint256 tokenId) external {\r\n        require(msg.sender == ownerOf[tokenId], 'NOT_OWNER');\r\n\r\n        _burn(tokenId);\r\n    }\r\n\r\n    function daoBurn(uint256 tokenId) external onlyDAO {\r\n        _burn(tokenId);\r\n    }\r\n\r\n    function updateDAO(address dao_) external onlyDAO {\r\n        dao = dao_;\r\n    }\r\n\r\n    function updateBaseURI(string calldata baseURI_) external onlyDAO {\r\n        baseURI = baseURI_;\r\n    }\r\n\r\n    function updateDetails(uint256 tokenId, string calldata details_) external onlyDAO {\r\n        details[tokenId] = details_;\r\n    }\r\n\r\n    function flipValidity(uint256 tokenId) external onlyDAO {\r\n        valid[tokenId] = !valid[tokenId];\r\n    }\r\n\r\n    /// **** NON-TRANSFERABILITY OVERRIDES\r\n\r\n    /// @notice Disables transferability by overriding {transfer}.\r\n    function transfer(address, uint256) public pure override returns (bool) {\r\n        revert();\r\n    }\r\n    \r\n    /// @notice Disables transferability by overriding {transferFrom}.\r\n    function transferFrom(address, address, uint256) public pure override {\r\n        revert();\r\n    }\r\n    \r\n    /// @notice Disables transferability by overriding {safeTransferFrom}.\r\n    function safeTransferFrom(address, address, uint256) public pure override {\r\n        revert();\r\n    }\r\n    \r\n    /// @notice Disables transferability by overriding {safeTransferFrom}.\r\n    function safeTransferFrom(address, address, uint256, bytes calldata) public pure override {\r\n        revert();\r\n    }\r\n}"}}}