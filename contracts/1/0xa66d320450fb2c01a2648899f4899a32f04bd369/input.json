{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"feesProtocolProxy.sol":{"content":"pragma solidity ^0.5.11;\r\n\r\ninterface Token {\r\n  function transfer(address _to, uint256 _value) external returns (bool success);\r\n  function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n  \r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, \"Safe Math Error-Add!\");\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a, \"Safe Math Error-Sub!\");\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"Safe Math Error-Mul!\");\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0, \"Safe Math Error-Div!\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ninterface DEXplatform { \r\n  function changeProtocol(address _newProtocol, address[] calldata _tokens) external; \r\n  function distributeFeesPool(address[] calldata _tokens, address[] calldata _benficiaries, uint[] calldata _amounts) external;\r\n  function getProtocol() external view returns (address prtocol);\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"only admin\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract feesProtocolStorage is Owned{\r\n    /* Groups default Array\r\n        1 Founders    2 Team    3 investors\r\n        4 community    5 development & Expenses    6 insurance\r\n    */\r\n    \r\n    //------------------------------------------------------------------------\r\n    // 0. Logic Contracts Storages\r\n    //------------------------------------------------------------------------\r\n    uint public funcN;\r\n    mapping(bytes4 => address) public funDelegates;\r\n    \r\n    //------------------------------------------------------------------------\r\n    // 1. Protocol Storages  \r\n    //------------------------------------------------------------------------\r\n    \r\n    address public admin; // will be set by the address that send the Token\r\n    address public projectToken;\r\n    address public dex;\r\n    uint public propertyAmount; // Total Token to be Locked\r\n    uint public propertyAmountETH;\r\n    bool public tokenIsRecieved =  false; // Protocol Will not work unless he recieve the token\r\n    \r\n    mapping(uint=>address) public groupsAdmin;\r\n    \r\n    uint public upcomingLevel = 1;\r\n    uint public upcomingRound = 1;\r\n    uint public usedVolume = 0; // To store used volume \r\n    \r\n    address[] public founders;\r\n    address[] public team;\r\n    address[] public investors;\r\n    \r\n    mapping(address=>uint) public platformVolumeUsed;\r\n    mapping(address=>uint) public platformVolumeUsedInETH;\r\n    \r\n    mapping(address=>mapping(address=>uint)) public tradersVolumeUsed;\r\n    mapping(address=>mapping(address=>uint)) public tradersVolumeUsedInETH;\r\n    \r\n    //-----------------------------------------------------\r\n    // Rounds Mapping \r\n    //-----------------------------------------------------\r\n    mapping(uint=>mapping(uint=>uint)) public roundsTargetedFees;\r\n    mapping(uint=>mapping(uint=>uint)) public roundsTargetedVolume;\r\n    \r\n    //-----------------------------------------------------\r\n    // Locked Token mapping and owndership of the token\r\n    //-----------------------------------------------------\r\n    // Groups - address - balance\r\n    uint public OwnershipTotalAllocation;\r\n    uint public OwnershipTotalAllocated;\r\n    uint public unloackedTokenBalance;\r\n    uint public withdrewTokenBalance;\r\n    \r\n    mapping(uint=>uint) public tokenGroupsOwnershipAllocation;\r\n    mapping(uint=>uint) public tokenGroupsOwnershipAlloced;\r\n    \r\n    mapping(uint=>mapping(address=>uint)) public tokenOwnersBalance;\r\n    \r\n    mapping(address=>uint) public unlockedBalance;\r\n    mapping(address=>uint) public withdrawBalance;\r\n    \r\n    // level-round-ownergroups-ownerAddress-balance\r\n    mapping(uint=>mapping(uint=>mapping(uint=>\r\n            mapping(address=>uint)))\r\n            ) public unlockedRoundsBalance;\r\n    \r\n    //-----------------------------------------------------\r\n    // Fees management Mappings\r\n    //-----------------------------------------------------\r\n    mapping(address=>uint) public platformFeesDeserved;\r\n    mapping(address=>uint) public platformFeesDeservedInEth;\r\n    mapping(address=>mapping(address=>uint)) public tradersFeesDeserved;\r\n    mapping(address=>mapping(address=>uint)) public tradersFeesDeservedInEth;\r\n   \r\n    //-----------------------------------------------------\r\n    // Events \r\n    event Deposit(address token, address user, uint256 amount, uint256 balance);\r\n    event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance);\r\n    event ChangeProtocol(address oldProtocol, address newProtocol); \r\n    event FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\r\n    \r\n}\r\n\r\ncontract feesProtocolProxy is feesProtocolStorage{\r\n    // every called functions of premissoned delegates must be added \r\n    function addFunctions(address _delegate, bytes4 _function, string memory _signiture) public onlyOwner{\r\n        require(funDelegates[_function] == address(0), \"Function is already exist!\" );\r\n        funDelegates[_function]= _delegate; \r\n        funcN++;\r\n        emit FunctionUpdate(_function, address(0), _delegate, string(_signiture));\r\n    }\r\n    \r\n    function updateFunctions(address _delegate, bytes4 _function) public onlyOwner{\r\n        require(funDelegates[_function] != address(0), \"Function Not found!\" );\r\n        require(funDelegates[_function] == _delegate, \"Function doesn't match delegate!\" );\r\n        funDelegates[_function]= address(0); \r\n        funcN--;\r\n        emit FunctionUpdate(_function, _delegate, address(0), string('Function disabled'));\r\n    }\r\n    \r\n    function () external payable {\r\n        address delegate = funDelegates[msg.sig];\r\n        require(delegate != address(0), \"Delegate does not exist.\");\r\n        \r\n        assembly {\r\n          let ptr := mload(0x40)\r\n          // (1) copy incoming call data\r\n          calldatacopy(ptr, 0, calldatasize)\r\n          \r\n          // (2) forward call to logic contract\r\n          let result := delegatecall(gas, delegate, ptr, calldatasize, 0, 0)\r\n          let size := returndatasize\r\n          \r\n          // (3) retrieve return data\r\n          returndatacopy(ptr, 0, size)\r\n          \r\n          // (4) forward return data back to caller\r\n          switch result\r\n          case 0 {revert(ptr, size)}\r\n          default {return (ptr, size)}\r\n        } \r\n    }\r\n    \r\n    function getFounders() public view onlyOwner returns(address[] memory foundersA){\r\n        return founders;\r\n    }\r\n    \r\n    function getTeam() public view onlyOwner returns(address[] memory foundersA){\r\n        return team;\r\n    }\r\n    \r\n    function getInvestors() public view onlyOwner returns(address[] memory foundersA){\r\n        return investors;\r\n    }\r\n    \r\n    \r\n}\r\n\r\ncontract feesProtocolSetup is feesProtocolStorage{\r\n    \r\n    function changeProtocolOnDex(address _newAddress, address[] memory _tokens) public onlyOwner{\r\n        address old = address(this); \r\n        require(dex != address(0), \"DEX address not found!\"); \r\n        require(old == address(this), \"Old Protocol Error!\"); \r\n        \r\n        DEXplatform(dex).changeProtocol(_newAddress, _tokens);\r\n        emit ChangeProtocol(old, _newAddress); \r\n    }\r\n    \r\n    function setTokenDetails(address _token, uint _amount, uint _ether) public onlyOwner{\r\n        require(tokenIsRecieved==false, \"token is already unlocked and cant changed\");\r\n        require(_amount>0, \"Invalid Token Amount\");\r\n        require(_ether>0, \"Invalid Ether Amount\");\r\n        projectToken = _token;\r\n        propertyAmount = _amount;\r\n        propertyAmountETH = _ether;\r\n    }\r\n    \r\n    function setDex(address _dex) public onlyOwner{\r\n        dex = _dex; \r\n    }\r\n    \r\n    // Deposit and Lock => Must be called receiveApproval not lockToken\r\n    function receiveApproval(address _spender, uint _amount, address _reciver) public payable {\r\n        require(tokenIsRecieved==false, \"Token is already recieved!\"); \r\n        require(projectToken != address(0), \"Token Address hasn't set yet!\");\r\n        require(projectToken == msg.sender, \"Deposting incorrect Token!\");\r\n        require(dex != address(0), \"DEX is not set!\"); \r\n        require(propertyAmount>0, \"Locked amount is not set!\"); \r\n        require(propertyAmountETH>0, \"ETH amount is not set!\");\r\n        require(propertyAmount==_amount, \"Recieved amount Error!\");\r\n        require(_reciver == address(this), \"Approved failed!\");\r\n        require(_spender == owner, \"only owner!\");\r\n        \r\n        if (!Token(projectToken).transferFrom(_spender, address(this), _amount)) { revert(\"Amoount not recieved!\"); }\r\n        \r\n        admin = _spender;\r\n        tokenIsRecieved=true;\r\n        \r\n        groupsAdmin[1]=_spender;\r\n        groupsAdmin[2]=_spender;\r\n        groupsAdmin[3]=_spender;\r\n        groupsAdmin[4]=_spender;\r\n        groupsAdmin[5]=_spender;\r\n        groupsAdmin[6]=_spender;\r\n        \r\n        OwnershipTotalAllocation= _amount; \r\n        tokenGroupsOwnershipAllocation[1]= _amount; \r\n        \r\n        emit Deposit(projectToken, _spender, _amount, tokenOwnersBalance[1][_spender]);\r\n        \r\n    }\r\n    \r\n    //-----------------------------------------------------\r\n    // Token Owndership Management \r\n    //-----------------------------------------------------\r\n    \r\n    function setGroupsAllocation(uint _amount, uint _group)public onlyOwner{\r\n        uint freeAllocation = propertyAmount-OwnershipTotalAllocation;\r\n        require(freeAllocation >= _amount, \"Insufficient amount!\"); \r\n        tokenGroupsOwnershipAllocation[_group]= SafeMath.safeAdd(tokenGroupsOwnershipAllocation[_group], _amount);\r\n        OwnershipTotalAllocation = SafeMath.safeAdd(OwnershipTotalAllocation, _amount);\r\n    }\r\n    \r\n    function setGroupsReAllocation(uint _amount, uint _group, uint _groupSpender)public onlyOwner{\r\n        uint freeAllocated = tokenGroupsOwnershipAllocation[_groupSpender] - tokenGroupsOwnershipAlloced[_groupSpender]; // for re-allocating free amount not allocated\r\n        require(groupsAdmin[_groupSpender] == msg.sender, \"group admin Error!\");\r\n        require(freeAllocated >= _amount, \"amount exceeding!\");\r\n        tokenGroupsOwnershipAllocation[_groupSpender]= SafeMath.safeSub(tokenGroupsOwnershipAllocation[_groupSpender], _amount);\r\n        tokenGroupsOwnershipAllocation[_group]= SafeMath.safeAdd(tokenGroupsOwnershipAllocation[_group], _amount);\r\n    }\r\n    \r\n    function allocateOwnershipToAddress(uint _amount, uint _group, address _reciver)public onlyOwner{\r\n        // Get the amount that hasnot allocted to address [free to re-allocate]\r\n        uint freeAllocation = tokenGroupsOwnershipAllocation[_group] - tokenGroupsOwnershipAlloced[_group];\r\n        // Revert allocated from passing Total amount that set to be allocating\r\n        require(SafeMath.safeAdd(OwnershipTotalAllocated, _amount) <= OwnershipTotalAllocation, \"Insufficient amount!\"); \r\n        require(groupsAdmin[_group] == msg.sender, \"permission error!\");\r\n        require(freeAllocation >= _amount, \"Insufficient free balance!\");\r\n        \r\n        tokenOwnersBalance[_group][_reciver] = SafeMath.safeAdd(tokenOwnersBalance[_group][_reciver], _amount);\r\n        tokenGroupsOwnershipAlloced[_group]= SafeMath.safeAdd(tokenGroupsOwnershipAlloced[_group], _amount);\r\n        OwnershipTotalAllocated= SafeMath.safeAdd(OwnershipTotalAllocated, _amount);\r\n        \r\n        if(_group == 1){\r\n            founders.push(_reciver);\r\n        } else if(_group == 2){\r\n            team.push(_reciver);\r\n        } else if(_group == 3){\r\n            investors.push(_reciver);\r\n        }\r\n    }\r\n    \r\n    \r\n}\r\n\r\ncontract feesProtocolOwnershipProcesses is feesProtocolStorage{\r\n    //-----------------------------------------------------\r\n    // Ownership processes \r\n    //-----------------------------------------------------\r\n    function cancelOwnership(uint _amount, uint _group, address _sender)public { // for re-allocation purpose\r\n        require(_sender == msg.sender, \"not allowed!\");\r\n        // since allocating is require sufficient balance for \r\n        // tokenGroupsOwnershipAlloced & OwnershipTotalAllocated\r\n        // so no need to re-check their sufficent balance \r\n        require(tokenOwnersBalance[_group][_sender] >= _amount, \"Insufficient balance!\");\r\n        \r\n        tokenOwnersBalance[_group][_sender] = SafeMath.safeSub(tokenOwnersBalance[_group][_sender], _amount);\r\n        tokenGroupsOwnershipAlloced[_group]= SafeMath.safeSub(tokenGroupsOwnershipAlloced[_group], _amount);\r\n        OwnershipTotalAllocated= SafeMath.safeSub(OwnershipTotalAllocated, _amount);\r\n    }\r\n    \r\n    function sendOwnershipInsideTheGroup(uint _amount, uint _group, address _reciver, address _sender)public {\r\n        require(_sender == msg.sender, \"not Allowed!\");\r\n        require(tokenOwnersBalance[_group][_sender] >= _amount, \"Insufficient balance!\");\r\n        \r\n        tokenOwnersBalance[_group][_reciver] = SafeMath.safeAdd(tokenOwnersBalance[_group][_reciver], _amount);\r\n        tokenOwnersBalance[_group][_sender] = SafeMath.safeSub(tokenOwnersBalance[_group][_sender], _amount);\r\n    }\r\n    \r\n    function sendOwnershipOutTheGroup(uint _amount, uint _groupSender, uint _groupReciver, address _reciver, address _sender)public {\r\n        require(_sender == msg.sender, \"not allowed!\");\r\n        \r\n        require(tokenOwnersBalance[_groupSender][_sender] >= _amount, \"Insufficient balance!\");\r\n        \r\n        tokenOwnersBalance[_groupReciver][_reciver] = SafeMath.safeAdd(tokenOwnersBalance[_groupReciver][_reciver], _amount);\r\n        tokenOwnersBalance[_groupSender][_sender] = SafeMath.safeSub(tokenOwnersBalance[_groupSender][_sender], _amount);\r\n        \r\n        tokenGroupsOwnershipAlloced[_groupReciver] = SafeMath.safeAdd(tokenGroupsOwnershipAlloced[_groupReciver], _amount);\r\n        tokenGroupsOwnershipAlloced[_groupSender] = SafeMath.safeSub(tokenGroupsOwnershipAlloced[_groupSender], _amount);\r\n        \r\n        tokenGroupsOwnershipAllocation[_groupReciver] = SafeMath.safeAdd(tokenGroupsOwnershipAllocation[_groupReciver], _amount);\r\n        tokenGroupsOwnershipAllocation[_groupSender] = SafeMath.safeSub(tokenGroupsOwnershipAllocation[_groupSender], _amount);\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n}\r\n\r\ncontract feesProtocolProcesses is feesProtocolStorage{\r\n    function withdrawUnlockedToken(uint _amount, address _benficiary) public{\r\n        require(_benficiary == msg.sender, \"Sender Approval Error!\"); \r\n        require(SafeMath.safeAdd(withdrewTokenBalance, _amount) <= unloackedTokenBalance, \"Insufficient Total Unlocked Balance!\");\r\n        require(SafeMath.safeAdd(withdrawBalance[_benficiary], _amount) <= unlockedBalance[_benficiary], \"Insufficient User Unlocked Balance!\");\r\n        \r\n        if (!Token(projectToken).transfer(msg.sender, _amount)) { revert(\"withdraw failed!\"); }\r\n        \r\n        emit Withdraw(projectToken, msg.sender, _amount, withdrawBalance[msg.sender]); // _benficiary\r\n        withdrawBalance[_benficiary] = SafeMath.safeAdd(withdrawBalance[_benficiary], _amount);\r\n        withdrewTokenBalance = SafeMath.safeAdd(withdrewTokenBalance, _amount);\r\n    }\r\n    \r\n    function distributingPrepration(address[] memory _tokens, address[] memory _traders, \r\n        address[] memory _tradersToken, uint[] memory _tokensV, uint[] memory _tokensVeth, \r\n        uint[] memory _tradersV, uint[] memory _tradersVeth,\r\n        address[] memory _tradersF, address[] memory _tradersTokenF,\r\n        uint[] memory _tradersFees, uint[] memory _tradersFeth\r\n    ) public onlyOwner{\r\n        \r\n        // _tokens _traders  _tradersToken  _tokensV  _tokensVeth  _tradersV  _tradersVeth\r\n        require(usedVolume == 0, \"distribution is already done!\");\r\n        require(_tokens.length == _tokensV.length, \"inputs not matched 1!\");\r\n        require(_tokens.length == _tokensVeth.length, \"inputs not matched 2!\");\r\n        require(_traders.length == _tradersV.length, \"inputs not matched 3!\");\r\n        require(_traders.length == _tradersVeth.length, \"inputs not matched 4!\"); \r\n        require(_traders.length == _tradersToken.length, \"inputs not matched 5!\");\r\n        require(_tradersF.length == _tradersTokenF.length, \"inputs not matched 6!\");\r\n        require(_tradersF.length == _tradersFees.length, \"inputs not matched 7!\"); \r\n        require(_tradersF.length == _tradersFeth.length, \"inputs not matched 8!\");\r\n        \r\n        // first for tokens \r\n        for(uint i=0; i<_tokens.length; i++){\r\n            platformVolumeUsed[_tokens[i]] = SafeMath.safeAdd(platformVolumeUsed[_tokens[i]], _tokensV[i]);\r\n            platformVolumeUsedInETH[_tokens[i]] = SafeMath.safeAdd(platformVolumeUsedInETH[_tokens[i]], _tokensVeth[i]);\r\n            if(_tokens[i] != address(0)){\r\n                platformVolumeUsedInETH[address(0)] = SafeMath.safeAdd(platformVolumeUsedInETH[address(0)], _tokensVeth[i]);\r\n            }\r\n        }\r\n        \r\n        // Second for traders \r\n        for(uint i=0; i<_traders.length; i++){\r\n            tradersVolumeUsed[_tradersToken[i]][_traders[i]] = SafeMath.safeAdd(tradersVolumeUsed[_tradersToken[i]][_traders[i]] , _tradersV[i]);\r\n            tradersVolumeUsedInETH[_tradersToken[i]][_traders[i]] = SafeMath.safeAdd(tradersVolumeUsedInETH[_tradersToken[i]][_traders[i]], _tradersVeth[i]);\r\n            if(_tradersToken[i] != address(0)){\r\n                tradersVolumeUsedInETH[address(0)][_traders[i]] = SafeMath.safeAdd(tradersVolumeUsedInETH[address(0)][_traders[i]], _tradersVeth[i]);\r\n            }\r\n            \r\n            // I think there is no need to save this data since it can be get off-chain \r\n            //traderTotalVolume[upcomingLevel][upcomingRound][_tradersToken[i]][_traders[i]] = SafeMath.safeAdd( traderTotalVolume[upcomingLevel][upcomingRound][_tradersToken[i]][_traders[i]] , _tradersV[i]);\r\n            //traderTotalVolumeInEth[upcomingLevel][upcomingRound][_tradersToken[i]][_traders[i]] = SafeMath.safeAdd(traderTotalVolumeInEth[upcomingLevel][upcomingRound][_tradersToken[i]][_traders[i]], _tradersVeth[i]);\r\n            \r\n        }\r\n        \r\n        // third for fees \r\n        for(uint i=0; i<_tradersF.length; i++){\r\n            // fees for Eth is saved inside tradersFeesDeserved for address(0)\r\n            // fees for Tokens are save indside tradersFeesDeservedInEth all under one address(0) \r\n            platformFeesDeserved[_tradersTokenF[i]] = SafeMath.safeAdd(platformFeesDeserved[_tradersTokenF[i]], _tradersFees[i]);\r\n            platformFeesDeservedInEth[_tradersTokenF[i]] = SafeMath.safeAdd(platformFeesDeservedInEth[_tradersTokenF[i]], _tradersFeth[i]);\r\n            \r\n            tradersFeesDeserved[_tradersTokenF[i]][_tradersF[i]] = SafeMath.safeAdd(tradersFeesDeserved[_tradersTokenF[i]][_tradersF[i]] , _tradersFees[i]);\r\n            tradersFeesDeservedInEth[_tradersTokenF[i]][_tradersF[i]] = SafeMath.safeAdd(tradersFeesDeservedInEth[_tradersTokenF[i]][_tradersF[i]], _tradersFeth[i]);\r\n            \r\n            // safe fees valued in ETH for all traded token using one Token only for each user \r\n            if(_tradersTokenF[i] != address(0)){\r\n                platformFeesDeservedInEth[address(0)] = SafeMath.safeAdd(platformFeesDeservedInEth[address(0)], _tradersFeth[i]);\r\n                tradersFeesDeservedInEth[address(0)][_tradersF[i]] = SafeMath.safeAdd(tradersFeesDeservedInEth[address(0)][_tradersF[i]], _tradersFeth[i]);\r\n            }\r\n            \r\n        }\r\n        \r\n        usedVolume = 1;  \r\n        \r\n    }\r\n    \r\n    // benficiaries (1) for distributing  || benficiaries2 for unlocking \r\n    function distributingAndUnlocking(address[] memory _tokens, address[] memory _benficiaries, \r\n        uint[] memory _groups, uint[] memory _amounts, \r\n        address[] memory _benficiaries2, uint[] memory _groups2, uint[] memory _amounts2, \r\n        uint _nextLevel, uint _nextRound\r\n    ) public payable onlyOwner{ // payable\r\n        \r\n        require(usedVolume == 1, \"do prepration first!\");\r\n        require(_tokens.length == _benficiaries.length, \"inputs not matched 1!\");\r\n        require(_tokens.length == _groups.length, \"inputs not matched 2!\");\r\n        require(_tokens.length == _amounts.length, \"inputs not matched 3!\");\r\n        require(_benficiaries2.length == _groups2.length, \"inputs not matched 4!\");\r\n        require(_benficiaries2.length == _amounts2.length, \"inputs not matched 5!\");\r\n        \r\n        // first we unlock Project token \r\n        for(uint i=0; i<_benficiaries2.length; i++){\r\n            require(SafeMath.safeAdd(unloackedTokenBalance, _amounts2[i])  <= propertyAmount, \"there isn't enough balance to unlock!\");\r\n            \r\n            unloackedTokenBalance = SafeMath.safeAdd(unloackedTokenBalance, _amounts2[i]);\r\n            unlockedBalance[_benficiaries2[i]] = SafeMath.safeAdd(unlockedBalance[_benficiaries2[i]], _amounts2[i]);\r\n            unlockedRoundsBalance[upcomingLevel][upcomingRound][_groups2[i]][_benficiaries2[i]] = SafeMath.safeAdd(unlockedRoundsBalance[upcomingLevel][upcomingRound][_groups2[i]][_benficiaries2[i]], _amounts2[i]);\r\n            \r\n            if(_groups2[i] == 4){\r\n                OwnershipTotalAllocated = SafeMath.safeAdd(OwnershipTotalAllocated, _amounts2[i]);\r\n                tokenGroupsOwnershipAlloced[4] = SafeMath.safeAdd(tokenGroupsOwnershipAlloced[4], _amounts2[i]);\r\n                tokenOwnersBalance[4][_benficiaries2[i]] = SafeMath.safeAdd(tokenOwnersBalance[4][_benficiaries2[i]], _amounts2[i]);\r\n            }\r\n        }\r\n        \r\n        // Second we distribute fees \r\n        DEXplatform(dex).distributeFeesPool(_tokens, _benficiaries, _amounts);\r\n        \r\n        // Third we update basic virables \r\n        upcomingLevel = _nextLevel;\r\n        upcomingRound = _nextRound; \r\n        usedVolume = 0;\r\n    }\r\n    \r\n}"}}}