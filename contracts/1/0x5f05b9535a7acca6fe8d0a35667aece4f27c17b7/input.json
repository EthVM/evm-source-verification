{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Etherland.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n* @title IERC165\r\n* @dev https://eips.ethereum.org/EIPS/eip-165\r\n* @dev source : openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n*/\r\ninterface IERC165 {\r\n    /**\r\n    * @notice Query if a contract implements an interface\r\n    * @param interfaceId The interface identifier, as specified in ERC-165\r\n    * @dev Interface identification is specified in ERC-165. This function\r\n    * uses less than 30,000 gas.\r\n    */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Unsigned math operations with safety checks that revert on error\r\n* @dev source : openzeppelin-solidity/contracts/math/SafeMath.sol\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"error\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"cannot divide by 0 or negative\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"result cannot be lower than 0\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"both numbers have to be positive\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"cannot divide by 0\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n* @title Counters\r\n* @author Matt Condon (@shrugs)\r\n* @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n* of elements in a mapping, issuing ERC721 ids, or counting request ids\r\n*\r\n* Include with `using Counters for Counters.Counter;`\r\n* Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\r\n* overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n* directly accessed.\r\n* @dev source : openzeppelin-solidity/contracts/drafts/Counters.sol\r\n*/\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\ncontract Storage {\r\n    using Counters for Counters.Counter;\r\n\r\n    // Token name\r\n    string internal _name;\r\n    // Token symbol\r\n    string internal _symbol;\r\n    // Token base uri\r\n    string internal _baseTokenURI;\r\n\r\n    // ERC165 supported interfaces\r\n    bytes4 internal constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\r\n    bytes4 internal constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    bytes4 internal constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n    bytes4 internal constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n    \r\n    // OpenSea proxy registry\r\n    address public proxyRegistryAddress;\r\n\r\n    // token id tracker\r\n    uint256 internal _currentTokenId = 0;\r\n    \r\n    // Array with all token ids, used for enumeration\r\n    uint256[] internal _allTokens;\r\n\r\n    // mapping of interface id to whether or not it's supported    \r\n    mapping(bytes4 => bool) internal _supportedInterfaces;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) internal _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) internal _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => Counters.Counter) internal _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) internal _operatorApprovals;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) internal _tokenURIs;\r\n\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint256[]) internal _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) internal _ownedTokensIndex;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) internal _allTokensIndex;\r\n\r\n    \r\n}\r\n\r\n/**\r\n* @title ERC165\r\n* @author Matt Condon (@shrugs)\r\n* @dev Implements ERC165 using a lookup table.\r\n* @dev source : openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n*/\r\ncontract ERC165 is IERC165, Storage {\r\n\r\n    /**\r\n    * @dev implement supportsInterface(bytes4) using a lookup table\r\n    */\r\n    function supportsInterface(bytes4 interfaceId) external override view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n    * @dev internal method for registering an interface\r\n    */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"bad interface\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n/**\r\n* @title ERC721 Non-Fungible Token Standard basic interface\r\n* @dev see https://eips.ethereum.org/EIPS/eip-721\r\n* @dev source : openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n*/\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    function safeTransferFromWithData(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n/**\r\n* @title ERC721 token receiver interface\r\n* @dev Interface for any contract that wants to support safeTransfers\r\n* from ERC721 asset contracts.\r\n* @dev source : openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n*/\r\ninterface IERC721Receiver {\r\n    /**\r\n    * @notice Handle the receipt of an NFT\r\n    * @dev The ERC721 smart contract calls this function on the recipient\r\n    * after a `safeTransfer`. This function MUST return the function selector,\r\n    * otherwise the caller will revert the transaction. The selector to be\r\n    * returned can be obtained as `this.onERC721Received.selector`. This\r\n    * function MAY throw to revert and reject the transfer.\r\n    * Note: the ERC721 contract address is always the message sender.\r\n    * @param operator The address which called `safeTransferFrom` function\r\n    * @param from The address which previously owned the token\r\n    * @param tokenId The NFT identifier which is being transferred\r\n    * @param data Additional data with no specified format\r\n    * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\r\n    external returns (bytes4);\r\n}\r\n\r\n/**\r\n* Utility library of inline functions on addresses\r\n* @dev source : openzeppelin-solidity/contracts/utils/Address.sol\r\n*/\r\nlibrary Address {\r\n    /**\r\n    * Returns whether the target address is a contract\r\n    * @dev This function will return false if invoked during the constructor of a contract,\r\n    * as the code is not actually created until after the constructor finishes.\r\n    * @param account address of the account to check\r\n    * @return whether the target address is a contract\r\n    */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/**\r\n* @title ERC721 Non-Fungible Token Standard basic implementation\r\n* @dev see https://eips.ethereum.org/EIPS/eip-721\r\n* @dev source : openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n*/\r\ncontract ERC721 is ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    /**\r\n    * @dev Event emitting when a NFT transfer occured\r\n    */\r\n    event Transfer(address indexed from, address indexed to, uint256 tokenId);\r\n\r\n    /**\r\n    * @dev Event emitting when an address has been approved by an owner for spending a specific NFT\r\n    */\r\n    event Approval(address indexed owner, address indexed approved, uint256 tokenId);\r\n\r\n    /**\r\n    * @dev Event emitting when an address has been approved by an owner for spending any of its NFT\r\n    */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address\r\n    * @param owner address to query the balance of\r\n    * @return uint256 representing the amount owned by the passed address\r\n    */\r\n    function balanceOf(address owner) public override view returns (uint256) {\r\n        require(owner != address(0), \"owner cannot be address 0\");\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the owner of the specified token ID\r\n    * @param tokenId uint256 ID of the token to query the owner of\r\n    * @return address currently marked as the owner of the given token ID\r\n    */\r\n    function ownerOf(uint256 tokenId) public override view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0), \"owner cannot be address 0\");\r\n        return owner;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Approves another address to transfer the given token ID\r\n    * The zero address indicates there is no approved address.\r\n    * There can only be one approved address per token at a given time.\r\n    * Can only be called by the token owner or an approved operator.\r\n    * @param to address to be approved for the given token ID\r\n    * @param tokenId uint256 ID of the token to be approved\r\n    */\r\n    function approve(address to, uint256 tokenId) public override {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \"cannot approve yourself\");\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"permission denied\");\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the approved address for a token ID, or zero if no address set\r\n    * Reverts if the token ID does not exist.\r\n    * @param tokenId uint256 ID of the token to query the approval of\r\n    * @return address currently approved for the given token ID\r\n    */\r\n    function getApproved(uint256 tokenId) public override view returns (address) {\r\n        require(_exists(tokenId), \"tokenID doesn't exist\");\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n    * @dev Sets or unsets the approval of a given operator\r\n    * An operator is allowed to transfer all tokens of the sender on their behalf\r\n    * @param to operator address to set the approval\r\n    * @param approved representing the status of the approval to be set\r\n    */\r\n    function setApprovalForAll(address to, bool approved) public override {\r\n        require(to != msg.sender, \"cannot approve yourself\");\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /**\r\n    * @dev Tells whether an operator is approved by a given owner\r\n    * @param owner owner address which you want to query the approval of\r\n    * @param operator operator address which you want to query the approval of\r\n    * @return bool whether the given operator is approved by the given owner\r\n    */\r\n    function isApprovedForAll(address owner, address operator) public override virtual view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers the ownership of a given token ID to another address\r\n    * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n    * Requires the msg.sender to be the owner, approved, or operator\r\n    * @param from current owner of the token\r\n    * @param to address to receive the ownership of the given token ID\r\n    * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function transferFrom(address from, address to, uint256 tokenId) public override {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"spender is not approved\");\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Safely transfers the ownership of a given token ID to another address\r\n    * If the target address is a contract, it must implement `onERC721Received`,\r\n    * which is called upon a safe transfer, and return the magic value\r\n    * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n    * the transfer is reverted.\r\n    * Requires the msg.sender to be the owner, approved, or operator\r\n    * @param from current owner of the token\r\n    * @param to address to receive the ownership of the given token ID\r\n    * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public override {\r\n        safeTransferFromWithData(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n    * @dev Safely transfers the ownership of a given token ID to another address\r\n    * If the target address is a contract, it must implement `onERC721Received`,\r\n    * which is called upon a safe transfer, and return the magic value\r\n    * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n    * the transfer is reverted.\r\n    * Requires the msg.sender to be the owner, approved, or operator\r\n    * @param from current owner of the token\r\n    * @param to address to receive the ownership of the given token ID\r\n    * @param tokenId uint256 ID of the token to be transferred\r\n    * @param _data bytes data to send along with a safe transfer check\r\n    */\r\n    function safeTransferFromWithData(address from, address to, uint256 tokenId, bytes memory _data) public override {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"data check is not ok\");\r\n    }\r\n\r\n    /**\r\n    * @dev Returns whether the specified token exists\r\n    * @param tokenId uint256 ID of the token to query the existence of\r\n    * @return bool whether the token exists\r\n    */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns whether the given spender can transfer a given token ID\r\n    * @param spender address of the spender to query\r\n    * @param tokenId uint256 ID of the token to be transferred\r\n    * @return bool whether the msg.sender is approved for the given token ID,\r\n    * is an operator of the owner, or is the owner of the token\r\n    */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to mint a new token\r\n    * Reverts if the given token ID already exists\r\n    * @param to The address that will own the minted token\r\n    * @param tokenId uint256 ID of the token to be minted\r\n    */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"cannot mint to address 0\");\r\n        require(!_exists(tokenId), \"token already exists\");\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to burn a specific token\r\n    * Reverts if the token does not exist\r\n    * Deprecated, use _burn(uint256) instead.\r\n    * @param owner owner of the token to burn\r\n    * @param tokenId uint256 ID of the token being burned\r\n    */\r\n    function _burn(address owner, uint256 tokenId) internal virtual {\r\n        require(ownerOf(tokenId) == owner, \"address is not owner of tokenID\");\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[owner].decrement();\r\n        _tokenOwner[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to burn a specific token\r\n    * Reverts if the token does not exist\r\n    * @param tokenId uint256 ID of the token being burned\r\n    */\r\n    function _burn(uint256 tokenId) internal {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to transfer ownership of a given token ID to another address.\r\n    * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n    * @param from current owner of the token\r\n    * @param to address to receive the ownership of the given token ID\r\n    * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal virtual {\r\n        require(ownerOf(tokenId) == from, \"sender is not owner of the token\");\r\n        require(to != address(0), \"cannot send to 0 address\");\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to invoke `onERC721Received` on a target address\r\n    * The call is not executed if the target address is not a contract\r\n    * @param from address representing the previous owner of the given token ID\r\n    * @param to target address that will receive the tokens\r\n    * @param tokenId uint256 ID of the token to be transferred\r\n    * @param _data bytes optional data to send along with the call\r\n    * @return bool whether the call correctly returned the expected magic value\r\n    */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n    internal returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to clear current approval of a given token ID\r\n    * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n* @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n* @dev See https://eips.ethereum.org/EIPS/eip-721\r\n* @dev source : openzeppelin-solidity/contracts/token/ERC721/IERC721Full.sol\r\n*/\r\ninterface IERC721Full is IERC721 {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n}\r\n\r\n\r\n/**\r\n* @title Full ERC721 Token\r\n* This implementation includes all the required and some optional functionality of the ERC721 standard\r\n* Moreover, it includes approve all functionality using operator terminology\r\n* @dev see https://eips.ethereum.org/EIPS/eip-721\r\n* @dev source : openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol\r\n*/\r\ncontract ERC721Full is ERC721, IERC721Full {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    function init (string memory name, string memory symbol) internal {\r\n        _name = name;\r\n        _symbol = symbol;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token name\r\n    * @return string representing the token name\r\n    */\r\n    function name() external override view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token symbol\r\n    * @return string representing the token symbol\r\n    */\r\n    function symbol() external override view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n    * @param owner address owning the tokens list to be accessed\r\n    * @param index uint256 representing the index to be accessed of the requested tokens list\r\n    * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n    */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public override view returns (uint256) {\r\n        require(index < balanceOf(owner), \"index is too high\");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the total amount of tokens stored by the contract\r\n    * @return uint256 representing the total amount of tokens\r\n    */\r\n    function totalSupply() public override view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token ID at a given index of all the tokens in this contract\r\n    * Reverts if the index is greater or equal to the total number of tokens\r\n    * @param index uint256 representing the index to be accessed of the tokens list\r\n    * @return uint256 token ID at the given index of the tokens list\r\n    */\r\n    function tokenByIndex(uint256 index) public override view returns (uint256) {\r\n        require(index < totalSupply(), \"index is too high\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to transfer ownership of a given token ID to another address.\r\n    * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n    * @param from current owner of the token\r\n    * @param to address to receive the ownership of the given token ID\r\n    * @param tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal override {\r\n        super._transferFrom(from, to, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(from, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to mint a new token\r\n    * Reverts if the given token ID already exists\r\n    * @param to address the beneficiary that will own the minted token\r\n    * @param tokenId uint256 ID of the token to be minted\r\n    */\r\n    function _mint(address to, uint256 tokenId) internal override {\r\n        super._mint(to, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n\r\n        _addTokenToAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to burn a specific token\r\n    * Reverts if the token does not exist\r\n    * Deprecated, use _burn(uint256) instead\r\n    * @param owner owner of the token to burn\r\n    * @param tokenId uint256 ID of the token being burned\r\n    */\r\n    function _burn(address owner, uint256 tokenId) internal override {\r\n        super._burn(owner, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\r\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\r\n        _ownedTokensIndex[tokenId] = 0;\r\n\r\n        _removeTokenFromAllTokensEnumeration(tokenId);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the list of token IDs of the requested owner\r\n    * @param owner address owning the tokens\r\n    * @return uint256[] List of token IDs owned by the requested address\r\n    */\r\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\r\n        return _ownedTokens[owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n    * @param to address representing the new owner of the given token ID\r\n    * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n    */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\r\n        _ownedTokens[to].push(tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to add a token to this extension's token tracking data structures.\r\n    * @param tokenId uint256 ID of the token to be added to the tokens list\r\n    */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n    * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\r\n    * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n    * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n    * @param from address representing the previous owner of the given token ID\r\n    * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n    */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; \r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; \r\n        }\r\n\r\n        _ownedTokens[from].pop();\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to remove a token from this extension's token tracking data structures.\r\n    * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n    * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n    */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; \r\n        _allTokensIndex[lastTokenId] = tokenIndex; \r\n\r\n        _allTokens.pop();\r\n        _allTokensIndex[tokenId] = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev\r\n     * @notice Non-Standard method to retrieve all NFTs that specific owner owns\r\n     * @return uint[] containing all NFTs that owner owns\r\n     */\r\n    function tokensOf(address owner) public view returns (uint[] memory) {\r\n        return _tokensOfOwner(owner);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n* @dev source : openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n*/\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @return the address of the owner.\r\n    */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"sender is not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @return true if `msg.sender` is the owner of the contract.\r\n    */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    * It will not be possible to call the functions with the `onlyOwner`\r\n    * modifier anymore.\r\n    * @notice Renouncing ownership will leave the contract without an owner,\r\n    * thereby removing any functionality that is only available to the owner.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"new owner cannot be address 0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Administrable\r\n * @dev Handle allowances for NFTs administration :\r\n *      - minting\r\n *      - burning\r\n *      - access to admin web interfaces\r\n * @dev ADMINS STORAGE \r\n * @dev rights are integer(int16) defined as follow :\r\n *       1 : address can only mint tokens \r\n *       2 : address can mint AND burn tokens\r\n*/\r\ncontract Administrable is Ownable {\r\n    \r\n    mapping(address => int16) private admins;\r\n\r\n    event AdminRightsGranted(address indexed newAdmin, int16 adminRights);\r\n    event AdminRightsRevoked(address indexed noAdmin);\r\n\r\n    /**\r\n    * @dev know if an address has admin rights and its type of rights\r\n    * @param _admin the address to find admin rights of\r\n    * @return int16 the admin right for _admin :\r\n    *       1 : address can only mint tokens \r\n    *       2 : address can mint AND burn tokens \r\n    */\r\n    function adminRightsOf(address _admin) public view returns(int16) {\r\n        if (_admin == owner()) return 2;\r\n        else return admins[_admin];\r\n    }\r\n\r\n    /**\r\n    * @dev verifiy if an address can mint new tokens\r\n    * @param _admin : the address to verify minting rights of\r\n    * @return a boolean, truthy when _admin has rights to mint new tokens\r\n    */\r\n    function isMinter(address _admin) public view returns (bool) {\r\n        if (_admin == owner()) return true;\r\n        else return(\r\n            admins[_admin] > 0\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev verifiy if an address has rights to mint and burn new tokens\r\n    * @param _admin : the address to verify minter-burner rights of\r\n    * @return a boolean, truthy when _admin has rights to mint and burn new tokens\r\n    */\r\n    function isMinterBurner(address _admin) public view returns (bool) {\r\n        if (_admin == owner()) return true;\r\n        else return(\r\n            admins[_admin] == 2\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev canMint external \r\n    * @return bool : truthy if msg.sender has admin rights to mint new tokens\r\n    */\r\n    function canMint() public view returns(bool) {\r\n        return(\r\n            isMinter(msg.sender)\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev canBurn external\r\n    * @return bool : truthy if msg.sender has admin rights to mint new tokens and burn existing tokens\r\n    */\r\n    function canMintBurn() public view returns(bool) {\r\n        return(\r\n            isMinterBurner(msg.sender)\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev onlyMinter internal\r\n    */\r\n    modifier onlyMinter() {\r\n        require(\r\n            canMint(),\r\n            \"denied : no admin minting rights\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev onlyBurner internal\r\n    */\r\n    modifier onlyMinterBurner() {\r\n        require(\r\n            canMintBurn(),\r\n            \"denied : no admin burning rights\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier validAddress(address _admin) {\r\n        require(_admin != address(0), \"invalid admin address\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev owner can grant admin access to allow any address to mint new tokens\r\n    * @dev Restricted to CONTRACT OWNER ONLY\r\n    * @param _admin : address to grant admin minter rights to\r\n    */\r\n    function grantMinterRights(address _admin) external onlyOwner validAddress(_admin) {\r\n        admins[_admin] = 1;\r\n        emit AdminRightsGranted(_admin, 1);\r\n    }\r\n\r\n    /**\r\n    * @dev owner can grant admin access to allow any address to mint new tokens and to burn existing tokens\r\n    * @dev Restricted to CONTRACT OWNER ONLY\r\n    * @param _admin : address to grant admin minter and burner rights to\r\n    */\r\n    function grantMinterBurnerRights(address _admin) external onlyOwner validAddress(_admin) {\r\n        admins[_admin] = 2;\r\n        emit AdminRightsGranted(_admin, 2);\r\n    }\r\n\r\n    /**\r\n    * @dev owner can revoke admin right of any admin address\r\n    * @dev Restricted to CONTRACT OWNER ONLY\r\n    * @param _admin : address to revoke admin access to\r\n    */\r\n    function revokeAdminRights(address _admin) external onlyOwner validAddress(_admin) {\r\n        admins[_admin] = 0;\r\n        emit AdminRightsRevoked(_admin);\r\n    }\r\n\r\n}\r\n\r\nlibrary Strings {\r\n    // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (uint i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (uint i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (uint i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function fromAddress(address addr) internal pure returns(string memory) {\r\n        bytes20 addrBytes = bytes20(addr);\r\n        bytes16 hexAlphabet = \"0123456789abcdef\";\r\n        bytes memory result = new bytes(42);\r\n        result[0] = \"0\";\r\n        result[1] = \"x\";\r\n        for (uint i = 0; i < 20; i++) {\r\n            result[i * 2 + 2] = hexAlphabet[uint8(addrBytes[i] >> 4)];\r\n            result[i * 2 + 3] = hexAlphabet[uint8(addrBytes[i] & 0x0f)];\r\n        }\r\n        return string(result);\r\n    }\r\n}\r\n\r\n/**\r\n* @title OwnableDelegateProxy\r\n* @dev OpenSea compliant feature\r\n*/\r\ncontract OwnableDelegateProxy { }\r\n\r\n/**\r\n* @title ProxyRegistry\r\n* @dev OpenSea compliant feature\r\n*/\r\ncontract ProxyRegistry {\r\n    mapping(address => OwnableDelegateProxy) public proxies;\r\n}\r\n\r\n\r\n/**\r\n* @title TradeableERC721Token\r\n* ERC721 contract that whitelists a trading address, and has minting functionalities.\r\n* @notice an external 'burn' function restricted to owner as been added\r\n*/\r\ncontract TradeableERC721Token is ERC721Full, Administrable {\r\n    using Strings for string;\r\n    using SafeMath for uint256;\r\n\r\n    function init(string memory _name, string memory _symbol, address _proxyRegistryAddress) internal {\r\n        ERC721Full.init(_name, _symbol);\r\n        proxyRegistryAddress = _proxyRegistryAddress;\r\n    }\r\n\r\n    /**\r\n    * @dev Mints a token to an address.\r\n    * @param _to address of the future owner of the token\r\n    */\r\n    function mintTo(address _to) public onlyMinter {\r\n        require(_to != address(0), \"cannot mint to address 0\");\r\n        uint256 newTokenId = _getNextTokenId();\r\n        _mint(_to, newTokenId);\r\n        _incrementTokenId();\r\n    }\r\n\r\n    /**\r\n     * @dev Mint several tokens to an address.\r\n     * @param _total total number of NFT to mint (reverts if <= 0)\r\n     * @param _to default owner of the new created NFT (reverts if a zero address)\r\n     */\r\n    function batchMintTo(uint _total, address _to) public onlyMinter {\r\n        require(_total > 0, \"mint minimum 1 token\");\r\n        for (uint i = 0; i < _total; i++) mintTo(_to);\r\n    }\r\n\r\n    /**\r\n    * @dev External Burn NFT method\r\n    */\r\n    function burn(uint _tokenId) public onlyMinterBurner {\r\n        super._burn(_tokenId);\r\n    }\r\n\r\n    /**\r\n        * @dev calculates the next token ID based on value of _currentTokenId\r\n        * @return uint256 for the next token ID\r\n        */\r\n    function _getNextTokenId() private view returns (uint256) {\r\n        return _currentTokenId.add(1);\r\n    }\r\n\r\n    /**\r\n        * @dev increments the value of _currentTokenId\r\n        */\r\n    function _incrementTokenId() private  {\r\n        _currentTokenId++;\r\n    }\r\n\r\n    /**\r\n    * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-less listings.\r\n    */\r\n    function isApprovedForAll(\r\n        address owner,\r\n        address operator\r\n    )\r\n    public override\r\n    view\r\n    returns (bool)\r\n    {\r\n        // Whitelist OpenSea proxy contract for easy trading.\r\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\r\n        if (address(proxyRegistry.proxies(owner)) == operator) {\r\n            return true;\r\n        }\r\n\r\n        return super.isApprovedForAll(owner, operator);\r\n    }\r\n}\r\n\r\n/**\r\n* @title IpfsHashs\r\n* @dev Provide methods to store and retrieve tokens IPFS CIDs\r\n*/\r\ncontract IpfsHashs is Administrable {\r\n\r\n    mapping (uint => mapping(string => string)) internal ipfsHashs;\r\n\r\n    function setIpfsHash(uint tokenId, string memory docType, string memory _hash) public onlyMinter {\r\n        require(tokenId > 0, \"denied : token zero cant be used\");\r\n        ipfsHashs[tokenId][docType] = _hash;\r\n    }\r\n\r\n    function removeIpfsHash(uint tokenId, string memory docType) public onlyMinterBurner {\r\n        ipfsHashs[tokenId][docType] = \"\";\r\n    }\r\n\r\n    function getIpfsHash(uint tokenId, string memory docType) public view returns (string memory) {\r\n        return ipfsHashs[tokenId][docType];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n* @title Proxiable\r\n* @dev Etherland - EIP-1822 Proxiable contract implementation\r\n* @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1822.md\r\n*/\r\ncontract Proxiable {\r\n    // Code position in storage is keccak256(\"PROXIABLE\") = \"0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\"\r\n\r\n    function updateCodeAddress(address newAddress) internal {\r\n        require(\r\n            bytes32(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7) == Proxiable(newAddress).proxiableUUID(),\r\n            \"Not compatible\"\r\n        );\r\n        assembly { // solium-disable-line\r\n            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, newAddress)\r\n        }\r\n    }\r\n    function proxiableUUID() public pure returns (bytes32) {\r\n        return 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Etherland NFT Assets\r\n * @author Mathieu Lecoq\r\n * september 3rd 2020 \r\n *\r\n * @dev Property\r\n * all rights are reserved to EtherLand ltd\r\n *\r\n * @dev deployed with compiler version 0.6.2\r\n*/\r\ncontract Etherland is TradeableERC721Token, IpfsHashs, Proxiable {\r\n    /**\r\n    * @dev initialized state MUST remain set to false on Implementation Contract \r\n    */\r\n    bool public initialized = false;\r\n\r\n    /**\r\n    * @dev event emitting when the `_baseTokenUri` is updated by owner\r\n    */\r\n    event BaseTokenUriUpdated(string newUri);\r\n\r\n    /**\r\n    * @dev Logic code implementation contact constructor\r\n    * @dev MUST be called by deployer only if contract has not been initialized before\r\n    */\r\n    function init(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _proxyRegistryAddress,\r\n        string memory baseURI,\r\n        address _owner\r\n    ) public {\r\n        if (initialized != true) {\r\n            initialized = true;\r\n\r\n            TradeableERC721Token.init(_name, _symbol, _proxyRegistryAddress);\r\n\r\n            _baseTokenURI = baseURI;\r\n\r\n            // register the supported interfaces to conform to ERC721 via ERC165\r\n            _registerInterface(_INTERFACE_ID_ERC165);\r\n            _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n            _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\r\n            _registerInterface(_INTERFACE_ID_ERC721);\r\n\r\n            _transferOwnership(_owner);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieve all NFTs base token uri \r\n    */\r\n    function baseTokenURI() public view returns (string memory) {\r\n        return _baseTokenURI;\r\n    }\r\n\r\n    /**\r\n    * @dev Set the base token uri for all NFTs\r\n    */\r\n    function setBaseTokenURI(string memory uri) public onlyOwner {\r\n        _baseTokenURI = uri;\r\n        emit BaseTokenUriUpdated(uri);\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieve the uri of a specific token \r\n    * @param _tokenId the id of the token to retrieve the uri of\r\n    * @return computed uri string pointing to a specific _tokenId\r\n    */\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory) {\r\n        return Strings.strConcat(\r\n            baseTokenURI(),\r\n            Strings.uint2str(_tokenId)\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev EIP-1822 feature\r\n    * @dev Realize an update of the Etherland logic code \r\n    * @dev calls the proxy contract to update stored logic code contract address at keccak256(\"PROXIABLE\")\r\n    */\r\n    function updateCode(address newCode) public onlyOwner {\r\n        updateCodeAddress(newCode);\r\n    }\r\n\r\n    /**\r\n    * @dev Mint a new token with document hash corresponding to an IPFS CID\r\n    * @param _to address of the future owner of the token\r\n    * @param docType string representing the type of document that is stored to IPFS (can be \"pdf\" or any other token related document)\r\n    * @param _hash string representing the hash of a document with type equals to `docType`\r\n    */\r\n    function mintWithIpfsHash(address _to, string memory docType, string memory _hash) public onlyMinter {\r\n        mintTo(_to);\r\n        setIpfsHash(_currentTokenId, docType, _hash);\r\n    }\r\n\r\n}"
    }
  }
}