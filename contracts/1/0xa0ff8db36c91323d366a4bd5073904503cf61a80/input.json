{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/EtherStorm.sol":{"content":"//EtherStorm::Augmentation of EtherWave\r\n//Official site : https://etherwave.io/EtherStorm\r\n\r\npragma solidity ^0.6.1;\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n        contract EtherStorm{\r\n                address payable public owner;\r\n                address payable creator1;\r\n                address payable creator2;\r\n                address payable creator3;\r\n                using SafeMath for uint256;\r\n                uint256 commission;\r\n                string public session;\r\n        struct user\r\n        {\r\n        uint256 id;           \r\n        uint256 recomendation;\r\n        uint256 creationTime; \r\n        uint256 total_Days;   \r\n        uint256 total_Amount; \r\n        uint256 level;         \r\n        uint256 referBy;      \r\n        bool expirePeriod;    \r\n        uint256 visit;        \r\n        uint256 ref_Income; \r\n        address[] reffrals;   \r\n        uint256 total_Withdraw;\r\n        }\r\n        user[] userList;      \r\n        uint256 cuurUserID=0;\r\n        mapping(address=>user)public users; \r\n        mapping(address=>address payable)public recomendators;\r\n        mapping(address=>uint256)public invested;           \r\n        mapping(uint256=>address payable)public userAddress; \r\n        mapping(address=>bool)public isRecomended;\r\n        mapping(uint256=>uint256)public level_price;\r\n        mapping(address=>uint256)public amount;\r\n        \r\n       constructor() payable public{\r\n            owner=msg.sender;\r\n            creator1=0xcA7EE1Aa80a0c5781D3b664D881c29D12Ae80448;\r\n            creator2=0x81205CE7C24Dd5FE71107048a096F4B552F5F30f;\r\n            creator3=0x00A1F03381c4137b9c3d59750021c36F5a1eA35e;\r\n            cuurUserID++;\r\n            user memory obj =user({recomendation:0,creationTime:0,total_Days:0,id:cuurUserID,\r\n            total_Amount:0,level:0,referBy:0,expirePeriod:false,visit:1,ref_Income:0,total_Withdraw:0,reffrals:new address[](0)});\r\n            userList.push(obj);\r\n            users[msg.sender]= obj;\r\n            userAddress[cuurUserID]=msg.sender;\r\n            isRecomended[msg.sender]=false;\r\n            \r\n            level_price[1]=50;\r\n            level_price[2]=30;\r\n            level_price[3]=20;\r\n            level_price[4]=10;\r\n            level_price[5]=10;\r\n            level_price[6]=10;\r\n            level_price[7]=10;\r\n            level_price[8]=10;\r\n            level_price[9]=10;\r\n            level_price[10]=10;\r\n            }\r\n       modifier onlyOwner(){\r\n        require(msg.sender==owner,\"only owner can run this\");\r\n        _;\r\n    }\r\n    modifier onlyFirst(uint256 _refference){\r\n    address a=userAddress[_refference];\r\n        require(_refference<=cuurUserID);\r\n        require(users[a].expirePeriod==false); \r\n        require(a!=msg.sender);   \r\n        require(users[msg.sender].visit==0); \r\n        _;\r\n    }\r\n    modifier reinvest(){\r\n            user memory obj=users[msg.sender];\r\n        require(obj.visit>0,\"visit should be above 0\");\r\n        require(obj.total_Withdraw==0,\"You have to withdraw all your money\");\r\n        _;\r\n    }\r\n    modifier investAmount(){\r\n       require(msg.value==0.25 ether || msg.value==0.50 ether|| msg.value==0.75 ether || msg.value==1 ether,\"you have to enter right amount\");\r\n       _;\r\n    }\r\n    \r\n    function Reinvest()public  payable reinvest investAmount returns(bool){\r\n                require(users[msg.sender].expirePeriod==true,\"your session should be new\");\r\n    invested[msg.sender]= msg.value;\r\n     users[msg.sender].creationTime=now;\r\n     users[msg.sender].expirePeriod=false;\r\n     users[msg.sender].visit+=1;\r\n      amount[msg.sender]=(invested[msg.sender].mul(1)).div(100);\r\n            return true;\r\n        \r\n    }\r\n    //recommend function\r\n    function join(uint256 _refference)public payable  onlyFirst(_refference) investAmount   returns(bool){\r\n            require(users[msg.sender].visit==0,\"you are already investor\");\r\n            cuurUserID++;\r\n            userAddress[cuurUserID]=msg.sender;\r\n            invested[msg.sender]= msg.value;\r\n            user memory obj =user({recomendation:0,creationTime:now,total_Days:0,id:cuurUserID,\r\n            total_Amount:0,level:0,referBy:_refference,expirePeriod:false,visit:1,ref_Income:0,total_Withdraw:0,reffrals:new address[](0)});\r\n            userList.push(obj);\r\n            users[msg.sender]= obj;\r\n            isRecomended[msg.sender]=true;\r\n            commission=(msg.value.mul(10)).div(100);\r\n            Creators(commission); \r\n            address payable a=userAddress[_refference];\r\n            recomendators[msg.sender]=a;\r\n            users[a].reffrals.push(msg.sender);\r\n            users[a].recomendation+=1;\r\n            if(users[a].level<1){\r\n               users[a].level=1;\r\n            }\r\n             amount[msg.sender]=(invested[msg.sender].mul(1)).div(100);\r\n            return true;\r\n    }\r\n    //distribute function\r\n    function down_Income(address  add,uint256 _depth,uint256 _f)private  returns (bool){\r\n        if(_depth>10){\r\n            return true;\r\n        }\r\n        if(isRecomended[add]){\r\n          uint256  f=(_f.mul(level_price[_depth]))/100;\r\n             address payable add1=recomendators[add];\r\n             user memory obj2=users[add1];\r\n             if(obj2.recomendation>=_depth){\r\n                 if(obj2.expirePeriod==false){\r\n                 users[add1].ref_Income+=f;\r\n                 }\r\n                 if(obj2.level<_depth){\r\n                 users[add1].level=_depth;\r\n                 }\r\n             }\r\n             _depth++;\r\n                 down_Income(add1,_depth,_f);\r\n        }\r\n        return true;\r\n    }\r\n    //withDrawl function\r\n    function withDraw()public payable returns(string memory){\r\n        \r\n        uint256 d;\r\n        address payable r=msg.sender;\r\n        user memory obj=users[r];     \r\n        require(obj.expirePeriod==false);\r\n        uint256  t=obj.total_Days;\r\n      \r\n        uint256 time=now - obj.creationTime;\r\n      uint256 daysCount=time.div(86400);\r\n      users[msg.sender].total_Days+=daysCount;\r\n      t+=daysCount;\r\n          if(t>=401){\r\n            return session_Expire();\r\n        }\r\n       d=amount[msg.sender].mul(daysCount);\r\n       uint256  p=obj.total_Amount;\r\n        users[msg.sender].total_Amount+=d;\r\n        p+=d;\r\n        p+=obj.ref_Income;\r\n         if(daysCount>0){\r\n                 uint256 depth=1;\r\n        down_Income(msg.sender,depth,d);\r\n        users[msg.sender].creationTime=now;\r\n        }\r\n        // require(obj.total_Withdraw<invested[msg.sender].mul(4) ,\"you are already withdraw all amount\");\r\n          d=obj.ref_Income.add(d);\r\n                  if(p>invested[msg.sender].mul(4)){\r\n                     uint256 x=(invested[msg.sender].mul(4)).sub(obj.total_Withdraw);\r\n                      r.transfer(x);\r\n                session=session_Expire();\r\n                  return \"you have WithDraw all your profit\";\r\n                  }\r\n                  else{\r\n                        users[msg.sender].total_Withdraw=obj.total_Withdraw.add(d);\r\n                        // users[msg.sender].earning=obj.earning.sub(_value);\r\n                        r.transfer(d);   \r\n                        return \"you have succesfully WithDrawl your money\";\r\n                  }\r\n               \r\n                      }\r\n        receive () external payable{\r\n        }\r\n    function session_Expire()private  returns(string memory){ //to invest again you have to expire first\r\n     users[msg.sender].total_Days=0;\r\n     users[msg.sender].total_Amount=0; \r\n     users[msg.sender].expirePeriod=true;\r\n     users[msg.sender].ref_Income=0;\r\n    users[msg.sender].total_Withdraw=0;\r\n     invested[msg.sender]=0;\r\n        return \"your session has expired\";\r\n    }\r\n    // forCreators function\r\n    function Creators(uint256 _value)private returns(bool ){\r\n        uint256 p=_value.div(3);\r\n        creator1.transfer(p);\r\n        creator2.transfer(p);\r\n        creator3.transfer(p);\r\n        return true;\r\n    }\r\n    //Owner functions\r\n       function changeOwnership(address payable newOwner)public onlyOwner returns(bool){\r\n        owner=newOwner;\r\n        return true;\r\n    }    \r\n    function owner_fund()public payable onlyOwner returns (bool){\r\n        owner.transfer(address(this).balance);\r\n        return true;\r\n    }\r\n    function get_Tree(address wallet)public view returns(address[] memory){\r\n        user memory obj=users[wallet];\r\n        return obj.reffrals;\r\n    }\r\n    function change_creator(address payable _newAddress,address _oldAddress)public onlyOwner returns(string memory){\r\n        if(creator1==_oldAddress){\r\n            creator1=_newAddress;\r\n        }\r\n        else if(creator2==_oldAddress){\r\n            creator2=_newAddress;\r\n        }\r\n        else if(creator3==_oldAddress){\r\n            creator3=_newAddress;\r\n        }\r\n        else{\r\n            return \"your address does not found\";\r\n        }\r\n        return \"your address succesfuly changed\";\r\n    }\r\n    function close() public payable onlyOwner { \r\n  selfdestruct(owner);\r\n}\r\nfunction owner_withdraw()public payable onlyOwner returns (bool){\r\n    user memory obj=users[owner];\r\n    require(obj.ref_Income>0,\"your earnings are less than 0\");\r\n    owner.transfer(obj.ref_Income);\r\n    users[owner].ref_Income=0;\r\n    return true;\r\n}\r\n \r\n}"}}}