{"language":"Solidity","settings":{"evmVersion":"london","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":999999},"remappings":[],"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}},"sources":{"contracts/interfaces/IRandomnessProvider.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IRandomnessProvider {\n    function newRandomnessRequest() external returns (bytes32);\n\n    function updateFee(uint256) external;\n\n    function rescueLINK(address to, uint256 amount) external;\n}\n"},"contracts/libraries/VRFLibrary.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../interfaces/IRandomnessProvider.sol';\n\nlibrary VRFLibrary {\n    struct VRFData {\n        IRandomnessProvider randomnessProvider;\n        bytes32 lastRequestId;\n        mapping(uint256 => uint256) highestIdForRandomness;\n        mapping(uint256 => uint256) randomResults;\n        uint256 lastRequest;\n        uint256 minResultIndex;\n        uint256 resultsReceived;\n    }\n\n    modifier onlyRandomnessProvider(VRFData storage self) {\n        require(\n            msg.sender == address(self.randomnessProvider),\n            'Required to be randomnessProvider'\n        );\n        _;\n    }\n\n    function processingStats(\n        VRFData storage self,\n        uint256 maxId,\n        uint256 processedId,\n        uint256 interval\n    )\n        public\n        view\n        returns (\n            bool requestPending,\n            uint256 maxIdAvailableToProcess,\n            uint256 readyForProcessing,\n            uint256 waitingToBeProcessed,\n            uint256 timeTellNextRandomnessRequest\n        )\n    {\n        timeTellNextRandomnessRequest = self.lastRequest + interval < block.timestamp\n                ? 0\n                : (self.lastRequest + interval) - block.timestamp;\n\n        return (\n            self.lastRequestId != '' && timeTellNextRandomnessRequest > interval / 2,\n            self.highestIdForRandomness[self.resultsReceived],\n            self.highestIdForRandomness[self.resultsReceived] - processedId,\n            maxId - self.highestIdForRandomness[self.resultsReceived],\n            timeTellNextRandomnessRequest\n        );\n    }\n\n    function checkRandomness(\n        VRFData storage self,\n        uint256 maxId,\n        uint256 processedId,\n        uint256 interval,\n        uint256 needed,\n        uint256 minimum\n    ) external {\n        (\n            bool requested,\n            ,\n            ,\n            uint256 processingNeeded,\n            uint256 timeTellNext\n        ) = processingStats(self, maxId, processedId, interval);\n\n        if (\n            !requested &&\n            (processingNeeded >= needed ||\n                (timeTellNext == 0 && processingNeeded > minimum))\n        ) {\n            newRequest(self);\n        }\n    }\n\n    function newRequest(VRFData storage self) public {\n        bytes32 requestId = self.randomnessProvider.newRandomnessRequest();\n\n        if (requestId != '') {\n            self.lastRequest = block.timestamp;\n            self.lastRequestId = requestId;\n        }\n    }\n\n    function setRequestResults(\n        VRFData storage self,\n        bytes32 requestId,\n        uint256 randomness,\n        uint256 maxId\n    ) public onlyRandomnessProvider(self) {\n        if (self.lastRequestId == requestId) {\n            self.resultsReceived++;\n            self.randomResults[self.resultsReceived] = randomness;\n            self.highestIdForRandomness[self.resultsReceived] = maxId;\n            self.lastRequestId = '';\n        }\n    }\n\n    function randomnessForId(VRFData storage self, uint256 id)\n        public\n        returns (bool available, uint256 randomness)\n    {\n        while (\n            self.highestIdForRandomness[self.minResultIndex] < id &&\n            self.minResultIndex < self.resultsReceived\n        ) {\n            delete self.randomResults[self.minResultIndex];\n            delete self.highestIdForRandomness[self.minResultIndex];\n            self.minResultIndex++;\n        }\n\n        if (self.highestIdForRandomness[self.minResultIndex] >= id) {\n            return (true, self.randomResults[self.minResultIndex]);\n        }\n\n        return (false, 0);\n    }\n\n    function setRandomnessProvider(\n        VRFData storage self,\n        address randomnessProvider\n    ) public {\n        self.randomnessProvider = IRandomnessProvider(randomnessProvider);\n    }\n\n    function updateFee(VRFData storage self, uint256 fee) public {\n        self.randomnessProvider.updateFee(fee);\n    }\n\n    function rescueLINK(\n        VRFData storage self,\n        address to,\n        uint256 amount\n    ) public {\n        self.randomnessProvider.rescueLINK(to, amount);\n    }\n}\n"}}}