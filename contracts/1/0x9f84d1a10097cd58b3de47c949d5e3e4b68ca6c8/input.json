{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"MVDFunctionalityProposal.sol":{"content":"// File: contracts\\ProposalData.sol\r\n\r\n// SPDX-License-Identifier: BSD-2\r\npragma solidity ^0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nstruct ProposalData {\r\n    address proxy;\r\n    string codeName;\r\n    bool emergency;\r\n    address sourceLocation;\r\n    uint256 sourceLocationId;\r\n    address location;\r\n    bool submitable;\r\n    string methodSignature;\r\n    string returnAbiParametersArray;\r\n    bool isInternal;\r\n    bool needsSender;\r\n    string replaces;\r\n    uint256 surveyEndBlock;\r\n    address proposer;\r\n    address getItemProposalWeightFunctionalityAddress;\r\n    address dfoItemCollectionAddress;\r\n    address emergencyTokenAddress;\r\n    uint256 votesHardCap;\r\n}\r\n\r\n// File: contracts\\interfaces\\IMVDFunctionalityProposal.sol\r\n\r\n// SPDX_License_Identifier: BSD-2\r\npragma solidity ^0.7.0;\r\n\r\n\r\ninterface IMVDFunctionalityProposal {\r\n\r\n    function init(ProposalData calldata proposalData) external returns(address);\r\n\r\n    function getProposalData() external view returns(ProposalData memory);\r\n    function getVote(address addr) external view returns(uint256 accept, uint256 refuse);\r\n    function getVotes() external view returns(uint256, uint256);\r\n    function start() external;\r\n    function disable() external;\r\n    function isVotesHardCapReached() external view returns(bool);\r\n    function isDisabled() external view returns(bool);\r\n    function isTerminated() external view returns(bool);\r\n    function batchRetireAccept(uint256[] calldata amounts, uint256[] calldata objectIds) external;\r\n    function moveToAccept(uint256 amount, uint256 objectId) external;\r\n    function batchRetireRefuse(uint256[] calldata amounts, uint256[] calldata objectIds) external;\r\n    function moveToRefuse(uint256 amount, uint256 objectId) external;\r\n    function retireAll(uint256[] calldata objectIds) external;\r\n    function withdraw() external;\r\n    function terminate() external;\r\n    function set() external;\r\n\r\n    event Accept(address indexed voter, uint256 amount);\r\n    event RetireAccept(address indexed voter, uint256 amount);\r\n    event MoveToAccept(address indexed voter, uint256 amount);\r\n    event Refuse(address indexed voter, uint256 amount);\r\n    event RetireRefuse(address indexed voter, uint256 amount);\r\n    event MoveToRefuse(address indexed voter, uint256 amount);\r\n    event RetireAll(address indexed voter, uint256 amount);\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC1155Receiver.sol\r\n\r\n// SPDX_License_Identifier: BSD-2\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver {\r\n\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n}\r\n\r\n// File: contracts\\interfaces\\IERC1155.sol\r\n\r\n// SPDX_License_Identifier: BSD-2\r\npragma solidity ^0.7.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts\\MVDFunctionalityProposal.sol\r\n\r\n// SPDX_License_Identifier: BSD-2\r\npragma solidity ^0.7.0;\r\n\r\n\r\n\r\n\r\ncontract MVDFunctionalityProposal is IMVDFunctionalityProposal, IERC1155Receiver {\r\n\r\n    // Core proposal data as struct\r\n    ProposalData private _proposalData;\r\n\r\n    // Mapping for address => objectid => weighted accept votes\r\n    mapping(address => mapping(uint256 => uint256)) private _accept;\r\n    // Mapping for address => objectid => weighted refuse votes\r\n    mapping(address => mapping(uint256 => uint256)) private _refuse;\r\n    // Total number of accept and refuse votes\r\n    uint256 private _totalAccept;\r\n    uint256 private _totalRefuse;\r\n    // If the address has withdrawed or not the given objectId\r\n    mapping(address => mapping(uint256 => bool)) private _withdrawed;\r\n    // Mapping for list of \"used\" objectId for a given address\r\n    mapping(address => uint256[]) private _userObjectIds;\r\n    // Check if the user has voted or not with the given objectId\r\n    mapping(address => mapping(uint256 => bool)) private _hasVotedWith;\r\n\r\n    // Proposal survey duration\r\n    uint256 private _surveyDuration;\r\n    // If the proposal is terminated\r\n    bool private _terminated;\r\n    // If the proposal is disabled\r\n    bool private _disabled;\r\n    // If the votes hard cap has been reached\r\n    bool private _votesHardCapReached;\r\n\r\n    constructor(ProposalData memory proposalData) {\r\n        init(proposalData);\r\n    }\r\n\r\n    function init(ProposalData memory proposalData) public override returns(address) {\r\n        require(_proposalData.proxy == address(0), \"Already initialized!\");\r\n        require(proposalData.proxy != address(0), \"Invalid proxy address\");\r\n        _proposalData = proposalData;\r\n        //_surveyDuration = toUint256(IMVDProxy(_proposalData.proxy).read((_proposalData.emergency) ? \"getMinimumBlockNumberForEmergencySurvey\" : \"getMinimumBlockNumberForSurvey\", bytes(\"\")));\r\n        return address(this);\r\n    }\r\n\r\n    function start() public override {\r\n        require(msg.sender == _proposalData.proxy, \"Only Proxy can call this function!\");\r\n        require(_proposalData.surveyEndBlock == 0, \"Already started!\");\r\n        require(!_disabled, \"Already disabled!\");\r\n        _proposalData.surveyEndBlock = block.number + _surveyDuration;\r\n    }\r\n\r\n    function disable() public override {\r\n        require(msg.sender == _proposalData.proxy, \"Only Proxy can call this function!\");\r\n        require(_proposalData.surveyEndBlock == 0, \"Already started!\");\r\n        _disabled = true;\r\n        _terminated = true;\r\n    }\r\n\r\n    modifier duringSurvey() {\r\n        require(!_disabled, \"Survey disabled!\");\r\n        require(!_terminated, \"Survey Terminated!\");\r\n        require(!_votesHardCapReached, \"Votes Hard Cap reached!\");\r\n        require(_proposalData.surveyEndBlock > 0, \"Survey Not Started!\");\r\n        require(block.number < _proposalData.surveyEndBlock, \"Survey ended!\");\r\n        _;\r\n    }\r\n\r\n    modifier onSurveyEnd() {\r\n        require(!_disabled, \"Survey disabled!\");\r\n        require(_proposalData.surveyEndBlock > 0, \"Survey Not Started!\");\r\n        if (!_votesHardCapReached) {\r\n            require(block.number >= _proposalData.surveyEndBlock, \"Survey is still running!\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    function _checkVotesHardCap() private {\r\n        if (_proposalData.votesHardCap == 0 || (_totalAccept < _proposalData.votesHardCap && _totalRefuse < _proposalData.votesHardCap)) {\r\n            return;\r\n        }\r\n        _votesHardCapReached = true;\r\n        terminate();\r\n    }\r\n\r\n    /** @dev Allows a user to batch retire the given amounts of objectIds from the accept votes.\r\n      * @param amounts array containing all the amounts.\r\n      * @param objectIds array containing all the ETHItem object ids.\r\n     */\r\n    function batchRetireAccept(uint256[] memory amounts, uint256[] memory objectIds) public override duringSurvey {\r\n        IGetItemProposalWeightFunctionality functionality = IGetItemProposalWeightFunctionality(_proposalData.getItemProposalWeightFunctionalityAddress);\r\n        uint256[] memory weightedAmounts = new uint256[](amounts.length);\r\n        for (uint256 i = 0; i < objectIds.length; i++) {\r\n            uint256 tokenWeight = functionality.getItemProposalWeight(objectIds[i]);\r\n            uint256 weightedAmount = amounts[i] * tokenWeight;\r\n            require(_accept[msg.sender][objectIds[i]] >= weightedAmount, \"Insufficient funds!\");\r\n            weightedAmounts[i] = weightedAmount;\r\n        }\r\n        IEthItemCollection(_proposalData.dfoItemCollectionAddress).safeBatchTransferFrom(address(this), msg.sender, amounts, objectIds, \"\");\r\n        for (uint256 i = 0; i < objectIds.length; i++) {\r\n            uint256 vote = _accept[msg.sender][objectIds[i]];\r\n            vote -= weightedAmounts[i];\r\n            _accept[msg.sender][objectIds[i]] = vote;\r\n            _totalAccept -= weightedAmounts[i];\r\n        }\r\n    }\r\n\r\n    /** @dev Allows a user to batch retire the given amounts of objectIds from the refuse votes.\r\n      * @param amounts array containing all the amounts.\r\n      * @param objectIds array containing all the ETHItem object ids.\r\n     */\r\n    function batchRetireRefuse(uint256[] memory amounts, uint256[] memory objectIds) public override duringSurvey {\r\n        IGetItemProposalWeightFunctionality functionality = IGetItemProposalWeightFunctionality(_proposalData.getItemProposalWeightFunctionalityAddress);\r\n        uint256[] memory weightedAmounts = new uint256[](amounts.length);\r\n        for (uint256 i = 0; i < objectIds.length; i++) {\r\n            uint256 tokenWeight = functionality.getItemProposalWeight(objectIds[i]);\r\n            uint256 weightedAmount = amounts[i] * tokenWeight;\r\n            require(_refuse[msg.sender][objectIds[i]] >= weightedAmount, \"Insufficient funds!\");\r\n            weightedAmounts[i] = weightedAmount;\r\n        }\r\n        IEthItemCollection(_proposalData.dfoItemCollectionAddress).safeBatchTransferFrom(address(this), msg.sender, amounts, objectIds, \"\");\r\n        // TODO batchSafeTransferFrom\r\n        for (uint256 i = 0; i < objectIds.length; i++) {\r\n            uint256 vote = _refuse[msg.sender][objectIds[i]];\r\n            vote -= weightedAmounts[i];\r\n            _refuse[msg.sender][objectIds[i]] = vote;\r\n            _totalRefuse -= weightedAmounts[i];\r\n        }\r\n    }\r\n\r\n    /** @dev Allows the sender to retire all the tokens used for voting in this proposal.\r\n      * @param objectIds array containing all the ETHItem object ids.\r\n     */\r\n    function retireAll(uint256[] memory objectIds) public override duringSurvey {\r\n        IGetItemProposalWeightFunctionality functionality = IGetItemProposalWeightFunctionality(_proposalData.getItemProposalWeightFunctionalityAddress);\r\n        uint256 total = 0;\r\n        uint256[] memory amounts = new uint256[](objectIds.length);\r\n        for (uint256 i = 0; i < objectIds.length; i++) {\r\n            require(_accept[msg.sender][objectIds[i]] + _refuse[msg.sender][objectIds[i]] > 0, \"No votes for the object id!\");\r\n        }\r\n        for (uint256 i = 0; i < objectIds.length; i++) {\r\n            uint256 tokenWeight = functionality.getItemProposalWeight(objectIds[i]);\r\n            if (tokenWeight > 0) {\r\n                uint256 acpt = _accept[msg.sender][objectIds[i]];\r\n                uint256 rfs = _refuse[msg.sender][objectIds[i]];\r\n                uint256 wAcpt = acpt / tokenWeight;\r\n                uint256 wRfs = rfs / tokenWeight;\r\n                amounts[i] = wAcpt + wRfs;\r\n                _accept[msg.sender][objectIds[i]] = 0;\r\n                _refuse[msg.sender][objectIds[i]] = 0;\r\n                _totalAccept -= acpt;\r\n                _totalRefuse -= rfs;\r\n                total += (acpt + rfs);\r\n            } else {\r\n                amounts[i] = 0;\r\n            }\r\n        }\r\n        IEthItemCollection(_proposalData.dfoItemCollectionAddress).safeBatchTransferFrom(address(this), msg.sender, amounts, objectIds, \"\");\r\n        // TODO safeBatchTransferFrom\r\n        emit RetireAll(msg.sender, total);\r\n    }\r\n\r\n    /** @dev Moves the given amount of the token with the given object id to the accept count.\r\n      * @param amount total amount of tokens to use for the vote.\r\n      * @param objectId ETHItem ERC-1155 object id.\r\n     */\r\n    function moveToAccept(uint256 amount, uint256 objectId) public override duringSurvey {\r\n        require(_refuse[msg.sender][objectId] >= amount, \"Insufficient funds!\");\r\n        uint256 vote = _refuse[msg.sender][objectId];\r\n        vote -= amount;\r\n        _refuse[msg.sender][objectId] = vote;\r\n        _totalRefuse -= amount;\r\n\r\n        vote = _accept[msg.sender][objectId];\r\n        vote += amount;\r\n        _accept[msg.sender][objectId] = vote;\r\n        _totalAccept += amount;\r\n        emit MoveToAccept(msg.sender, amount);\r\n        _checkVotesHardCap();\r\n    }\r\n\r\n    /** @dev Moves the given amount of the token with the given object id to the refuse count.\r\n      * @param amount total amount of tokens to use for the vote.\r\n      * @param objectId ETHItem ERC-1155 object id.\r\n     */\r\n    function moveToRefuse(uint256 amount, uint256 objectId) public override duringSurvey {\r\n        require(_accept[msg.sender][objectId] >= amount, \"Insufficient funds!\");\r\n        uint256 vote = _accept[msg.sender][objectId];\r\n        vote -= amount;\r\n        _accept[msg.sender][objectId] = vote;\r\n        _totalAccept -= amount;\r\n\r\n        vote = _refuse[msg.sender][objectId];\r\n        vote += amount;\r\n        _refuse[msg.sender][objectId] = vote;\r\n        _totalRefuse += amount;\r\n        emit MoveToRefuse(msg.sender, amount);\r\n        _checkVotesHardCap();\r\n    }\r\n\r\n    /** @dev Allows the sender to withdraw all the tokens inside the proposal.\r\n     */\r\n    function withdraw() public override onSurveyEnd {\r\n        // Check if the proposal is not terminated nor disabled\r\n        if (!_terminated && !_disabled) {\r\n            terminate();\r\n            return;\r\n        }\r\n        // Withdraw all the tokens\r\n        _withdraw(true);\r\n    }\r\n\r\n    /** @dev Allows the sender to terminate the proposal (only on survey end).\r\n     */\r\n    function terminate() public override onSurveyEnd {\r\n        require(!_terminated, \"Already terminated!\");\r\n        IMVDProxy(_proposalData.proxy).setProposal();\r\n        _withdraw(false);\r\n    }\r\n\r\n    /** @dev Private function used for token withdrawal.\r\n      * @param launchError ??\r\n     */\r\n    function _withdraw(bool launchError) private {\r\n        IGetItemProposalWeightFunctionality functionality = IGetItemProposalWeightFunctionality(_proposalData.getItemProposalWeightFunctionalityAddress);\r\n        uint256[] memory amounts = new uint256[](_userObjectIds[msg.sender].length);\r\n        for (uint256 i = 0; i < _userObjectIds[msg.sender].length; i++) {\r\n            require(!launchError || _accept[msg.sender][_userObjectIds[msg.sender][i]] + _refuse[msg.sender][_userObjectIds[msg.sender][i]] > 0, \"Nothing to Withdraw!\");\r\n            require(!launchError || !_withdrawed[msg.sender][_userObjectIds[msg.sender][i]], \"Already Withdrawed!\");\r\n            if (_accept[msg.sender][_userObjectIds[msg.sender][i]] + _refuse[msg.sender][_userObjectIds[msg.sender][i]] > 0 && !_withdrawed[msg.sender][_userObjectIds[msg.sender][i]]) {\r\n                uint256 tokenWeight = functionality.getItemProposalWeight(_userObjectIds[msg.sender][i]);\r\n                if (tokenWeight > 0) {\r\n                    uint256 wAccept = _accept[msg.sender][_userObjectIds[msg.sender][i]] / tokenWeight;\r\n                    uint256 wRefuse = _refuse[msg.sender][_userObjectIds[msg.sender][i]] / tokenWeight;\r\n                    amounts[i] = wAccept + wRefuse;\r\n                } else {\r\n                    amounts[i] = 0;\r\n                }\r\n                _withdrawed[msg.sender][_userObjectIds[msg.sender][i]] = true;\r\n            }\r\n        }\r\n        IEthItemCollection(_proposalData.dfoItemCollectionAddress).safeBatchTransferFrom(address(this), msg.sender, amounts, _userObjectIds[msg.sender], \"\");\r\n    }\r\n\r\n    /** @dev Allows the proxy to terminate this proposal.\r\n     */\r\n    function set() public override onSurveyEnd {\r\n        require(msg.sender == _proposalData.proxy, \"Unauthorized Access!\");\r\n        require(!_terminated, \"Already terminated!\");\r\n        _terminated = true;\r\n    }\r\n\r\n    /** @dev Returns the proposal data struct.\r\n      * @return proposal data struct.\r\n      */\r\n    function getProposalData() public override view returns(ProposalData memory) {\r\n        return _proposalData;\r\n    }\r\n\r\n    /** @dev Returns all the votes for the given address. It calculates the values\r\n      * by iterating on all the tokens that the address used.\r\n      * @param addr address votes.\r\n      * @return addrAccept accept amount of votes for the accept.\r\n      * @return addrRefuse refuse amount of votes for the refuse.\r\n     */\r\n    function getVote(address addr) public override view returns(uint256 addrAccept, uint256 addrRefuse) {\r\n        for (uint256 i = 0; i < _userObjectIds[addr].length; i++) {\r\n            addrAccept += _accept[addr][_userObjectIds[addr][i]];\r\n            addrRefuse += _refuse[addr][_userObjectIds[addr][i]];\r\n        }\r\n    }\r\n\r\n    function getVotes() public override view returns(uint256, uint256) {\r\n        return (_totalAccept, _totalRefuse);\r\n    }\r\n\r\n    function isTerminated() public override view returns(bool) {\r\n        return _terminated;\r\n    }\r\n\r\n    function isDisabled() public override view returns(bool) {\r\n        return _disabled;\r\n    }\r\n\r\n    function isVotesHardCapReached() public override view returns(bool) {\r\n        return _votesHardCapReached;\r\n    }\r\n\r\n    function toUint256(bytes memory bs) public pure returns(uint256 x) {\r\n        if (bs.length >= 32) {\r\n            assembly {\r\n                x := mload(add(bs, add(0x20, 0)))\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev Function called after a ERC1155 has been received by this contract.\r\n      * @return 0xf23a6e61.\r\n      */\r\n    function onERC1155Received(address operator, address from, uint256 objectId, uint256 amount, bytes memory data) public override returns(bytes4) {\r\n        require(operator == _proposalData.dfoItemCollectionAddress, \"Invalid operator\");\r\n        bool isAccept = _compareStrings(string(data), \"accept\");\r\n        require(isAccept || _compareStrings(string(data), \"refuse\"), \"Invalid type\");\r\n        IGetItemProposalWeightFunctionality functionality = IGetItemProposalWeightFunctionality(_proposalData.getItemProposalWeightFunctionalityAddress);\r\n        uint256 tokenWeight = functionality.getItemProposalWeight(objectId);\r\n        uint256 objectIdVotes = isAccept ? _accept[from][objectId] :  _refuse[from][objectId];\r\n        uint256 weightedAmount = amount * tokenWeight;\r\n        if (weightedAmount > 0) {\r\n            if (!_hasVotedWith[from][objectId]) {\r\n                _hasVotedWith[from][objectId] = true;\r\n                _userObjectIds[from].push(objectId);\r\n            }\r\n            objectIdVotes += weightedAmount;\r\n            isAccept ? _accept[from][objectId] = objectIdVotes : _refuse[from][objectId] = objectIdVotes;\r\n            isAccept ? _totalAccept += weightedAmount : _totalRefuse += weightedAmount;\r\n            if (isAccept) {\r\n                emit Accept(from, weightedAmount);\r\n            } else {\r\n                emit Refuse(from, weightedAmount);\r\n            }\r\n            _checkVotesHardCap();\r\n        }\r\n        return 0xf23a6e61;\r\n    }\r\n    \r\n    /** @dev Function called after a batch of ERC1155 has been received by this contract.\r\n      * @return 0xbc197c81.\r\n      */\r\n    function onERC1155BatchReceived(address operator, address from, uint256[] memory objectIds, uint256[] memory amounts, bytes memory data) public override returns (bytes4) {\r\n        require(operator == _proposalData.dfoItemCollectionAddress, \"Invalid operator\");\r\n        bool isAccept = _compareStrings(string(data), \"accept\");\r\n        require(isAccept || _compareStrings(string(data), \"refuse\"), \"Invalid type\");\r\n        IGetItemProposalWeightFunctionality functionality = IGetItemProposalWeightFunctionality(_proposalData.getItemProposalWeightFunctionalityAddress);\r\n        for (uint256 i = 0; i < objectIds.length; i++) {\r\n            uint256 currentTokenVote = isAccept ? _accept[from][objectIds[i]] : _refuse[from][objectIds[i]];\r\n            uint256 currentTokenWeight = functionality.getItemProposalWeight(objectIds[i]);\r\n            uint256 currentTokenWeightedAmount = amounts[i] * currentTokenWeight;\r\n            require(currentTokenWeightedAmount > 0, \"Token weight must not be 0 in batch vote!\");\r\n            if (!_hasVotedWith[from][objectIds[i]]) {\r\n                _hasVotedWith[from][objectIds[i]] = true;\r\n                _userObjectIds[from].push(objectIds[i]);\r\n            }\r\n            currentTokenVote += currentTokenWeightedAmount;\r\n            isAccept ? _accept[from][objectIds[i]] = currentTokenVote : _refuse[from][objectIds[i]] = currentTokenVote;\r\n            isAccept ? _totalAccept += currentTokenWeightedAmount : _totalRefuse += currentTokenWeightedAmount;\r\n        }\r\n        _checkVotesHardCap();\r\n        return 0xbc197c81;\r\n    }\r\n\r\n    function _compareStrings(string memory a, string memory b) private pure returns(bool) {\r\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\r\n    }\r\n}\r\n\r\ninterface IEthItemCollection {\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\r\n}\r\n\r\ninterface IGetItemProposalWeightFunctionality {\r\n    function getItemProposalWeight(uint256 itemAddress) external returns (uint256);\r\n}\r\n\r\ninterface IMVDProxy {\r\n    function setProposal() external;\r\n    function read(string calldata codeName, bytes calldata data) external view returns(bytes memory returnData);\r\n    function getMVDFunctionalitiesManagerAddress() external view returns(address);\r\n}"}}}