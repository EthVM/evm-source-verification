{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1500},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Kaiba_IVC.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.7;\r\n\r\nlibrary SafeMath {\r\n\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory  errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory  errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (bytes32 );\r\n    function symbol() external pure returns (bytes32 );\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// IVC (Internal Virtual Chain)\r\n// (c) Kaiba DeFi DAO 2021\r\n\r\n// This source code is distributed under the CC-BY-ND-4.0 License https://spdx.org/licenses/CC-BY-ND-4.0.html#licenseText\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n\r\n    function symbol() external view returns (bytes32 );\r\n    function name() external view returns (bytes32 );\r\n    function decimals() external view returns (uint8);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n /////////////////////////////////////////////////////// Plugin interface\r\n\r\n    interface IVC_Plugin {\r\n        // pay extreme attention to these methods\r\n        function exists() external view returns (bool success);      \r\n        function svt_plugin_initialize() external view returns (bool, uint256[] memory, bytes32[] memory);\r\n        function svt_method_call_id(uint256 mid) external returns (bool, bytes32 );  \r\n        function svt_method_call_name(bytes32  mname) external returns (bool, bytes32 );  \r\n  }\r\n\r\n  /// @notice the following method is implemented externally\r\n\r\n  interface IVC_Pair_Adding {\r\n      function create_svt_pair_existing(uint256 orig_qty1, uint256 orig_qty2,  address to_bridge, address to_pair, uint256 qty_1, uint256 qty_2) external returns(bool);\r\n      function create_svt_pair_from_eth_existing(uint256 orig_qty1, uint256 orig_qty2, address to_bridge, uint256 qty_1, uint256 qty_2) external returns(bool);\r\n  }\r\n\r\ncontract Kaiba_IVC {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // Pair manipulation\r\n    IVC_Pair_Adding pair_adder;\r\n    bool create_svt_pair_existing_enabled;\r\n\r\n    /// @notice Fees balances\r\n    uint256 tax_multiplier = 995; //0.05%\r\n    uint256 taxes_eth_total;\r\n    mapping(address => uint256) taxes_token_total;\r\n    mapping (uint256 => uint256) taxes_native_total;\r\n    address kaiba_address = 0x8BB048845Ee0d75BE8e07954b2e1E5b51B64b442;\r\n    address owner;\r\n    // Rinkeby: 0xc778417E063141139Fce010982780140Aa0cD5Ab\r\n    // Mainnet: 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address constant ZERO = 0x000000000000000000000000000000000000dEaD;\r\n    ERC20 kaiba = ERC20(kaiba_address);\r\n\r\n    // Constructor\r\n    constructor () {\r\n        is_team[msg.sender] = true;\r\n        owner = msg.sender;\r\n        is_locked[841] = true;\r\n        /// @notice defining WETH -> KVETH\r\n        SVT_address[0].deployed = true;\r\n        SVT_address[0].tokenOwner = owner;\r\n        SVT_address[0].totalSupply = 0;\r\n        SVT_address[0].circulatingSupply = 0;\r\n        SVT_address[0].fees.push(10000000000000000);\r\n        SVT_address[0].name = \"Kaiba Virtual ETH\";\r\n        SVT_address[0].ticker = \"WETH\";\r\n        SVT_address[0].isBridged = true;\r\n        SVT_address[0].original_token = WETH; \r\n        SVT_address[0].SVT_Liquidity_storage = 0;\r\n        /// @notice also defining the liquidity\r\n        SVT_Liquidity_index[0].deployed = true;\r\n        SVT_Liquidity_index[0].active = true;\r\n        SVT_Liquidity_index[0].liq_mode = 4;\r\n        SVT_Liquidity_index[0].token_1 = ERC20(SVT_address[0].original_token);\r\n        SVT_Liquidity_index[0].SVT_token_id = 0;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////// Access control\r\n\r\n    mapping (address => bool) is_team;\r\n\r\n    struct auth_control {\r\n        mapping(address => bool) is_auth;\r\n    }\r\n\r\n    mapping(address => auth_control) bridge_is_auth;\r\n\r\n    mapping(uint256 => bool) is_locked;\r\n\r\n    bool internal locked;\r\n    bool internal open_bridge;\r\n\r\n    modifier safe() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    modifier Unlocked(uint256 name) {\r\n        require(!is_locked[name]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuth(address to_bridge) {\r\n        require(bridge_is_auth[msg.sender].is_auth[to_bridge] ||  msg.sender==owner || open_bridge, \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTeam {\r\n        require(is_team[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(owner==msg.sender);\r\n        _;\r\n    }\r\n\r\n    function acl_add_team(address addy) public onlyTeam {\r\n        is_team[addy] = true;\r\n    }\r\n\r\n    function acl_remove_team(address addy) public onlyTeam {\r\n        is_team[addy] = false;\r\n    }\r\n\r\n    function acl_locked_function(uint256 name, bool booly) public onlyTeam {\r\n        is_locked[name] = booly;\r\n    }\r\n\r\n    function acl_open_bridge(bool booly) public onlyTeam {\r\n        open_bridge = booly;\r\n    }\r\n\r\n    function acl_set_kaiba(address addy) public onlyTeam {\r\n        kaiba_address = addy;\r\n    }\r\n    \r\n    function acl_set_tax_multiplier(uint256 multiplier) public onlyTeam {\r\n        tax_multiplier = multiplier;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////// Structures\r\n\r\n    struct SVTLiquidity {  // This struct defines the types of liquidity and the relative properties\r\n        bool active;\r\n        bool deployed;\r\n        bool native_pair;\r\n        ERC20 token_1; // Always the native or the paired\r\n        ERC20 token_2; // Always the SVT token\r\n        uint256 token_1_qty; \r\n        uint256 token_2_qty;\r\n        uint256 SVT_token_id;\r\n        uint256 liq_mode; // 1: Direct pair, 2: LP token (on token_1), 3: Synthetic, 4: WETH\r\n        // Mode specific variables\r\n        IUniswapV2Factory factory; // Needed in mode 2, 3\r\n        IUniswapV2Pair pair; // Needed in mode 2, 3\r\n    }\r\n\r\n    mapping (uint256 => SVTLiquidity) SVT_Liquidity_index;\r\n    uint256 svt_liquidity_last_id = 0;\r\n\r\n    struct SVT { // This struct defines a typical SVT token\r\n        bool deployed;\r\n        address tokenOwner;\r\n        uint256 totalSupply;\r\n        uint256 circulatingSupply;\r\n        mapping (address => uint256) balance;\r\n        uint256[] fees;\r\n        mapping(uint256 => uint256) fees_storage;\r\n        bytes32 name;\r\n        bytes32 ticker;\r\n        bool isBridged;\r\n        address original_token;\r\n        uint256 SVT_Liquidity_storage;\r\n    }\r\n\r\n    mapping (uint256 => SVT) SVT_address;\r\n    uint256 svt_last_id = 0;\r\n\r\n    struct SVNFT { // And this one defines a NFT on IVC (aka SVNFT)\r\n        uint256 totalSupply;\r\n        uint256 circulatingSupply;\r\n        mapping (address => uint256[]) owned_ids;\r\n        mapping(uint256 => address) id_owner;\r\n        uint256[] ids;\r\n    }\r\n\r\n    /// @notice Manage the imported status of ERC20 tokens \r\n    mapping (address => bool) imported;\r\n    mapping (address => uint256) imported_id;\r\n\r\n    /// @notice Tracking imported balances of IVC addresses\r\n    uint256 IVC_native_decimals = 18;\r\n    mapping (address => uint256) IVC_native_balance;\r\n    uint256 IVC_native_balance_total;\r\n\r\n    /////////////////////////////////////////////////////// Get endpoints\r\n\r\n    // List of deployed tokens\r\n    function get_svt_pools() external view returns (uint256) {\r\n        return svt_last_id;\r\n    }\r\n\r\n    // Address to SVT id\r\n    function get_svt_id(address addy) external  view returns(bool, uint256) {\r\n        if(imported[addy]) {\r\n            return (true, imported_id[addy]);\r\n        } else {\r\n            return (false, 0);\r\n        }\r\n    }\r\n\r\n    // Get the internal liquidity of a SVT token\r\n\r\n    function get_svt_liquidity(uint256 svt_id) external  view returns (bool, bool, address, address, uint256, uint256, uint256, address, address, bool) {\r\n        require(SVT_address[svt_id].deployed, \"SVT Token does not exist\");\r\n        uint256 liq_index = SVT_address[svt_id].SVT_Liquidity_storage;\r\n        require(SVT_Liquidity_index[liq_index].deployed, \"SVT Token has no liquidity\");\r\n        return (SVT_Liquidity_index[liq_index].active,\r\n                SVT_Liquidity_index[liq_index].deployed,\r\n                address(SVT_Liquidity_index[liq_index].token_1),\r\n                address(SVT_Liquidity_index[liq_index].token_2),\r\n                SVT_Liquidity_index[liq_index].token_1_qty,\r\n                SVT_Liquidity_index[liq_index].token_2_qty,\r\n                SVT_Liquidity_index[liq_index].liq_mode,\r\n                address(SVT_Liquidity_index[liq_index].factory),\r\n                address(SVT_Liquidity_index[liq_index].pair),\r\n                SVT_Liquidity_index[liq_index].native_pair); \r\n    }\r\n\r\n\r\n    // Get the price of a token in eth\r\n\r\n    function get_token_price(address pairAddress, uint amount) external  view returns(uint)\r\n    {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\r\n        address token1_frompair = pair.token1();\r\n        ERC20 token1 = ERC20(token1_frompair);\r\n        (uint Res0, uint Res1,) = pair.getReserves();\r\n\r\n        // decimals\r\n        uint res0 = Res0*(10**token1.decimals());\r\n        return((amount*res0)/Res1); // return amount of token0 needed to buy token1\r\n    }\r\n\r\n    // Return the SVT balance of an address\r\n\r\n    function get_svt_address_balance(address addy, uint256 svt_id) public  view returns(uint256) {\r\n        require(SVT_address[svt_id].deployed, \"This token does not exists\");\r\n        return SVT_address[svt_id].balance[addy];\r\n    }\r\n\r\n    // Return the IVC balance of an address\r\n    function get_ivc_balance(address addy) external  view returns(uint256) {\r\n        return(IVC_native_balance[addy]);\r\n    }\r\n\r\n    function get_ivc_stats() external  view returns(uint256) {\r\n        return(IVC_native_balance_total);\r\n    }\r\n\r\n    // Return the properties of a SVT token\r\n\r\n    function get_svt(uint256 addy) external  view returns (address, uint256, uint256, uint256[] memory, bytes32 , bytes32 ) {\r\n        require(SVT_address[addy].deployed, \"Token not deployed\");\r\n        address tokenOwner = SVT_address[addy].tokenOwner;\r\n        uint256 supply = SVT_address[addy].totalSupply;\r\n        uint256 circulatingSupply = SVT_address[addy].circulatingSupply;\r\n        uint256[] memory fees = SVT_address[addy].fees;\r\n        bytes32  name = SVT_address[addy].name;\r\n        bytes32  ticker = SVT_address[addy].ticker;\r\n        return (tokenOwner, supply, circulatingSupply, fees, name, ticker);\r\n\r\n    }\r\n\r\n    // Return bridged status of a SVT token \r\n\r\n    function get_svt_bridge_status(uint256 addy) external  view returns (bool, address) {\r\n        return(_isBridged(addy), _originalToken(addy));\r\n    }\r\n\r\n    \r\n    // Return KVETH balance of an address\r\n\r\n    function get_svt_kveth_balance(address addy) external  view returns (uint256) {\r\n        return(IVC_native_balance[addy]);\r\n    }\r\n\r\n     /////////////////////////////////////////////////////// Transfer functions\r\n\r\n    function operate_svt_to_native(uint256 svt_id, uint256 qty, address receiver, bool simulation) public \r\n        returns (uint256, uint256, uint256, uint256) {\r\n        /// @notice Sanity checks\r\n        require(SVT_address[svt_id].deployed, \"SVT token does not exist\");\r\n        uint256 liq_index = SVT_address[svt_id].SVT_Liquidity_storage;\r\n        require(SVT_Liquidity_index[liq_index].active, \"SVT liquidity does not exist\");\r\n        require(get_svt_address_balance(msg.sender, svt_id) >= qty, \"Balance is too low\");\r\n        /// @notice Getting taxes\r\n        uint256 local_whole_tax = calculate_taxes(svt_id, qty);\r\n        require(local_whole_tax<qty, \"Taxes too high\");\r\n        qty -= local_whole_tax;\r\n        /// @notice Getting liquidity\r\n        uint256 to_withdraw_liq = SVT_Liquidity_index[liq_index].token_1_qty;\r\n        uint256 to_deposit_liq = SVT_Liquidity_index[liq_index].token_2_qty;\r\n        /// @notice Getting output amount\r\n        uint256 amount_out = operate_ivc_get_amount_out(qty, to_deposit_liq, to_withdraw_liq);\r\n        /// @notice Updating liquidity and balances if it is not a simulation\r\n        if (!simulation) {\r\n            SVT_Liquidity_index[liq_index].token_2_qty += amount_out;\r\n            SVT_address[svt_id].balance[receiver] -= amount_out;\r\n            SVT_Liquidity_index[liq_index].token_1_qty -= qty;\r\n            IVC_native_balance[msg.sender] += qty;\r\n            IVC_native_balance_total += qty;\r\n        }\r\n        /// @notice return the amount\r\n        return (amount_out,\r\n                SVT_address[svt_id].balance[receiver],\r\n                IVC_native_balance[msg.sender], svt_id);\r\n\r\n    }\r\n    \r\n    function operate_native_to_svt(uint256 svt_id, address receiver, uint256 qty, bool simulation) public \r\n    returns (uint256, uint256, uint256, uint256){\r\n        /// @notice Sanity checks\r\n        require(SVT_address[svt_id].deployed, \"SVT token does not exist\");\r\n        uint256 liq_index = SVT_address[svt_id].SVT_Liquidity_storage;\r\n        require(SVT_Liquidity_index[liq_index].active, \"SVT liquidity does not exist\");\r\n        require(IVC_native_balance[msg.sender] >= qty, \"Balance is too low\");\r\n        /// @notice Getting liquidity\r\n        uint256 to_deposit_liq = SVT_Liquidity_index[liq_index].token_1_qty;\r\n        uint256 to_withdraw_liq = SVT_Liquidity_index[liq_index].token_2_qty;\r\n        /// @notice Getting output amount\r\n        uint256 amount_out = operate_ivc_get_amount_out(qty, to_deposit_liq, to_withdraw_liq);\r\n        /// @notice Getting taxes\r\n        uint256 local_whole_tax = calculate_taxes(svt_id, amount_out);\r\n        require(local_whole_tax<amount_out, \"Taxes too high\");\r\n        amount_out -= local_whole_tax;\r\n        /// @notice Updating liquidity and balances if it is not a simulation\r\n        if (!simulation) {\r\n            SVT_Liquidity_index[liq_index].token_2_qty -= amount_out;\r\n            SVT_address[svt_id].balance[receiver] += amount_out;\r\n            SVT_Liquidity_index[liq_index].token_1_qty += amount_out;\r\n            IVC_native_balance[msg.sender] -= qty;\r\n            IVC_native_balance_total -= qty;\r\n        }\r\n        /// @notice return the amount\r\n        return (amount_out,\r\n                SVT_address[svt_id].balance[receiver],\r\n                IVC_native_balance[msg.sender],svt_id);\r\n    }\r\n\r\n    \r\n\r\n    /////////////////////////////////////////////////////// Entry and exit point functions\r\n\r\n    uint256 exit_lock_time = 5 minutes;\r\n    uint256 entry_lock_time = 2 minutes;\r\n    mapping(address => bool) exit_suspended;\r\n    mapping(address => bool) entry_suspended;\r\n    mapping(address => uint256) exit_lock;\r\n    mapping(address => uint256) entry_lock;\r\n\r\n    function entry_from_eth() public payable safe returns (uint256){\r\n        require(msg.value >= 10000000000000000, \"Unpayable\");\r\n        require(!entry_suspended[msg.sender], \"Suspended\");\r\n        require(entry_lock[msg.sender] + entry_lock_time < block.timestamp, \"Please wait\");\r\n        uint256 qty_to_credit = msg.value;\r\n        SVT_address[0].balance[msg.sender] += taxes_include_fee(qty_to_credit);\r\n        IVC_native_balance[msg.sender] += taxes_include_fee(qty_to_credit);\r\n        IVC_native_balance_total += qty_to_credit;\r\n        taxes_eth_total += qty_to_credit - taxes_include_fee(qty_to_credit);\r\n        entry_lock[msg.sender] = block.timestamp;\r\n        return qty_to_credit;\r\n    }\r\n\r\n    function exit_to_eth(uint256 qty, address recv) public safe returns (uint256) {\r\n        require(address(this).balance > qty, \"Unpayable: No liq?\");\r\n        require(IVC_native_balance[msg.sender] >= qty, \"No KVETH\");\r\n        require(SVT_address[0].balance[msg.sender] >= qty, \"No KVETH\");\r\n        require(!exit_suspended[msg.sender], \"Suspended\");\r\n        require(!exit_suspended[recv], \"Suspended\");\r\n        require(exit_lock[msg.sender] + exit_lock_time < block.timestamp, \"Please wait\");\r\n        require(exit_lock[recv] + exit_lock_time < block.timestamp, \"Please wait\");\r\n        exit_lock[msg.sender] = block.timestamp;\r\n        IVC_native_balance[msg.sender] -= qty;\r\n        IVC_native_balance_total -= taxes_include_fee(qty);\r\n        SVT_address[0].balance[msg.sender] -= qty;\r\n        payable(recv).transfer(taxes_include_fee(qty));\r\n        taxes_native_total[0] += qty - taxes_include_fee(qty);\r\n        return qty;\r\n    }\r\n\r\n    /// @notice Unbridge to ETH a quantity of SVT token\r\n\r\n    function exit_to_token(address token, uint256 qty) public safe {\r\n        ERC20 from_token = ERC20(token);\r\n        // Security and uniqueness checks\r\n        require(imported[token], \"This token is not imported\");\r\n        uint256 unbridge_id = imported_id[token];\r\n        require(SVT_address[unbridge_id].balance[msg.sender] >= qty, \"You don't have enough tokens\");\r\n        require(from_token.balanceOf(address(this)) >= qty, \"There aren't enough tokens\");\r\n        from_token.transfer(msg.sender, taxes_include_fee(qty));\r\n        if (SVT_address[unbridge_id].circulatingSupply < 0) {\r\n            SVT_address[unbridge_id].circulatingSupply = 0;\r\n        }\r\n        SVT_address[unbridge_id].balance[msg.sender] -= qty;\r\n        taxes_native_total[unbridge_id] += qty - taxes_include_fee(qty);\r\n    }\r\n\r\n    /////////////////////////////////////////////////////// Public functions\r\n\r\n    function operate_transfer_svt(uint256 svt_id, address sender, address receiver, uint256 qty) public {\r\n        require(SVT_address[svt_id].deployed, \"This token does not exists\");\r\n        require(SVT_address[svt_id].balance[sender] >= qty, \"You don't own enough tokens\");\r\n        uint256 local_whole_tax = calculate_taxes(svt_id, qty);\r\n        require(local_whole_tax<qty, \"Taxes too high\");\r\n        qty -= local_whole_tax;\r\n        SVT_address[svt_id].balance[sender] -= taxes_include_fee(qty) ;\r\n        delete sender;\r\n        SVT_address[svt_id].balance[receiver] += taxes_include_fee(qty);\r\n        delete receiver;\r\n        delete qty;\r\n        taxes_native_total[svt_id] += taxes_include_fee(qty);\r\n    }\r\n\r\n\r\n    /////////////////////////////////////////////////////// Plugins functions\r\n\r\n    mapping(uint256 => IVC_Plugin) plugin_loaded;\r\n    uint256 plugin_free_id = 0;\r\n    mapping(uint256 => uint256[]) plugins_methods_id;\r\n    mapping(uint256 => bytes32[]) plugins_methods_strings;\r\n\r\n    function pair_adder_implementation(bool booly, address addy) public onlyTeam {\r\n        pair_adder = IVC_Pair_Adding(addy);\r\n        create_svt_pair_existing_enabled = booly;\r\n    }\r\n\r\n    function add_svt_plugin(address plugin_address) public onlyTeam returns (uint256){\r\n        plugin_loaded[plugin_free_id] = IVC_Plugin(plugin_address);\r\n        plugin_free_id += 1;\r\n        return (plugin_free_id -1);\r\n    }\r\n\r\n    /// @notice This method executes the content of svt_plugin_initialize if a plugin has been added and is enabled\r\n    /// @dev Extremely important, only trusted team members should be able to write and execute plugins as they can run basically everything\r\n    /// @dev This method returns a bool indicating the plugin status and two possible arrays that can be used  to call the plugins methods at will\r\n\r\n    function initialize_ivc_plugin(uint256 plugin_id) public view onlyTeam returns (bool, uint256[] memory, bytes32[] memory) {\r\n        require(plugin_loaded[plugin_id].exists(), \"Plugin not loaded or not existant\");\r\n        return plugin_loaded[plugin_id].svt_plugin_initialize();\r\n    }\r\n\r\n\r\n    /// @notice The next two functions are responsible to check against the initialized plugin methods ids or names. Require is used to avoid tx execution with gas if fails\r\n\r\n    function check_ivc_plugin_method_id(uint256 plugin, uint256 id) public view onlyTeam returns (bool) {\r\n        require(plugin_loaded[plugin].exists(), \"Plugin not loaded or not existant\");\r\n        bool found = false;\r\n        for (uint256 i = 0; i < plugins_methods_id[plugin].length; i++) {\r\n            if (plugins_methods_id[plugin][i] == id) {\r\n                return true;\r\n            }\r\n        }\r\n        require(found);\r\n        return false;\r\n    }\r\n\r\n    function check_ivc_plugin_method_name(uint256 plugin, bytes32 name) public view onlyTeam returns (bool) {\r\n        require(plugin_loaded[plugin].exists(), \"Plugin not loaded or not existant\");\r\n        bool found = false;\r\n        for (uint256 i = 0; i < plugins_methods_id[plugin].length; i++) {\r\n            if (plugins_methods_strings[plugin][i] == name) {\r\n                return true;\r\n            }\r\n        }\r\n        require(found);\r\n        return false;\r\n    }\r\n\r\n    /// @notice The following methods are able to call either a method id or method name from a given plugin\r\n\r\n    function execute_ivc_plugin_method_id(uint256 plugin, uint256 id) public onlyTeam returns (bool, bytes32 ) {\r\n        require(check_ivc_plugin_method_id(plugin, id), \"Error in verifying method\");\r\n        return plugin_loaded[plugin].svt_method_call_id(id);\r\n    }\r\n\r\n    function execute_ivc_plugin_method_id(uint256 plugin, bytes32  name) public onlyTeam returns (bool, bytes32 ) {\r\n        require(check_ivc_plugin_method_name(plugin, name), \"Error in verifying method\");\r\n        return plugin_loaded[plugin].svt_method_call_name(name);\r\n    }\r\n\r\n\r\n    /////////////////////////////////////////////////////// Utility functions\r\n\r\n    function taxes_include_fee(uint256 initial) private view returns (uint256) {\r\n        return( (initial*tax_multiplier) / 1000 );\r\n    }\r\n\r\n    function calculate_taxes(uint256 svt_id, uint256 qty) private returns (uint256) {\r\n        uint256 local_whole_tax = 0;\r\n        for(uint i=0; i<SVT_address[svt_id].fees.length; i++) {\r\n            SVT_address[svt_id].fees_storage[i] += (qty * SVT_address[svt_id].fees[i])/100;\r\n            local_whole_tax += (qty * SVT_address[svt_id].fees[i])/100;\r\n        }\r\n        return local_whole_tax;\r\n    }\r\n\r\n    function operate_ivc_get_amount_out(uint256 to_deposit, uint256 to_deposit_liq, uint256 to_withdraw_liq) public pure returns (uint256 out_qty) {\r\n        require(to_deposit > 0, 'KaibaSwap: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(to_deposit_liq > 0 && to_withdraw_liq > 0, 'KaibaSwap: INSUFFICIENT_LIQUIDITY');\r\n        uint to_deposit_with_fee = to_deposit.mul(997);\r\n        uint numerator = to_deposit_with_fee.mul(to_withdraw_liq);\r\n        uint denominator = to_deposit_liq.mul(1000).add(to_deposit_with_fee);\r\n        out_qty = numerator / denominator;\r\n        return out_qty;\r\n    }\r\n\r\n    /// @notice Authorize a specific address to operate on a token\r\n    function authorize_on_token(address to_authorize, address to_bridge) public onlyTeam {\r\n        bridge_is_auth[to_authorize].is_auth[to_bridge] = true;\r\n    }\r\n\r\n\r\n    /// @notice This function allows issuance of native coins\r\n    function issue_native_svt(\r\n        bytes32  name,\r\n        bytes32  ticker,\r\n        uint256 max_supply,\r\n        uint256[] calldata fees) \r\n    public Unlocked(1553) safe {\r\n        uint256 thisAddress = svt_last_id+1;\r\n        SVT_address[thisAddress].deployed = true;\r\n        SVT_address[thisAddress].circulatingSupply = max_supply;\r\n        SVT_address[thisAddress].totalSupply = max_supply;\r\n        SVT_address[thisAddress].fees = fees;\r\n        SVT_address[thisAddress].name = name;\r\n        SVT_address[thisAddress].ticker = ticker;\r\n        SVT_address[thisAddress].isBridged = true;\r\n        SVT_address[thisAddress].original_token = ZERO;\r\n        SVT_address[thisAddress].balance[msg.sender] = taxes_include_fee(max_supply);\r\n        SVT_address[thisAddress].SVT_Liquidity_storage = svt_liquidity_last_id + 1;\r\n        svt_liquidity_last_id += 1;\r\n        taxes_native_total[thisAddress] += max_supply - taxes_include_fee(max_supply);\r\n    }\r\n\r\n    function native_add_liq(uint256 svt_id, uint256 qty) payable public safe { \r\n        require(msg.value > 10000000000000000, \"Too low\");\r\n        require(SVT_address[svt_id].deployed, \"SVT does not exists\");\r\n        uint256 thisLiquidity = SVT_address[svt_id].SVT_Liquidity_storage;\r\n        require(!SVT_Liquidity_index[thisLiquidity].active, \"Pair is already alive\");\r\n        SVT_Liquidity_index[thisLiquidity].active = true;\r\n        SVT_Liquidity_index[thisLiquidity].deployed = true;\r\n        SVT_Liquidity_index[thisLiquidity].token_1 = ERC20(WETH);\r\n        SVT_Liquidity_index[thisLiquidity].token_2 = ERC20(ZERO);\r\n        SVT_Liquidity_index[thisLiquidity].token_1_qty += msg.value;\r\n        SVT_Liquidity_index[thisLiquidity].token_2_qty += qty;\r\n        SVT_Liquidity_index[thisLiquidity].SVT_token_id = svt_id;\r\n        SVT_Liquidity_index[thisLiquidity].liq_mode = 1;\r\n    }\r\n\r\n    function get_taxes_for_address(uint256 token) public  view returns(uint256) {\r\n        require(SVT_address[token].deployed, \"Non existant\");\r\n        if (SVT_address[token].fees.length == 0) {\r\n            return 0;\r\n        } else {\r\n            uint256 total_taxes;\r\n            for (uint256 i = 0; i < SVT_address[token].fees.length; i++) {\r\n                total_taxes += SVT_address[token].fees[i];\r\n            }\r\n            return total_taxes;\r\n        }\r\n    }\r\n\r\n    /// @notice If authorized, allows to pair two ERC20 tokens to an SVT Liquidity Pair\r\n    /// @dev remember to approve beforehand\r\n\r\n    function create_svt_pair(address to_bridge, address to_pair,  uint256 qty_1, uint256 qty_2) public Unlocked(841) safe onlyAuth(to_bridge) {\r\n        ERC20 from_token = ERC20(to_bridge);\r\n        ERC20 from_pair = ERC20(to_pair);\r\n        delete to_bridge;\r\n        delete to_pair;\r\n        require(from_token.balanceOf(msg.sender) >= qty_1, \"You don't have enough tokens (1)\");\r\n        require(from_pair.balanceOf(msg.sender) >= qty_2, \"You don't have enough tokens (2)\");\r\n        // Approve and transfer tokens, keeping 1% as fee\r\n        from_token.transferFrom(msg.sender, address(this), qty_1);\r\n        from_pair.transferFrom(msg.sender, address(this), qty_2);\r\n        uint256 thisAddress;\r\n        uint256 thisLiquidity;\r\n        if (imported[to_bridge]) {\r\n            require(create_svt_pair_existing_enabled, \"Not yet enabled (pair adding)\");\r\n            bool success;\r\n            thisAddress = imported_id[to_bridge];\r\n            thisLiquidity = SVT_address[thisAddress].SVT_Liquidity_storage;\r\n            require(to_pair==address(SVT_Liquidity_index[thisLiquidity].token_2), \"Wrong pair\");\r\n            success = pair_adder.create_svt_pair_existing(SVT_Liquidity_index[thisLiquidity].token_1_qty, SVT_Liquidity_index[thisLiquidity].token_2_qty, to_bridge, to_pair, qty_1, qty_2);\r\n            require(success, \"Failed pairing\");\r\n            delete success;\r\n        } else {\r\n            svt_last_id +=1;\r\n            svt_liquidity_last_id += 1;\r\n            thisAddress = svt_last_id;\r\n            thisLiquidity = svt_liquidity_last_id;\r\n            imported[to_bridge] = true;\r\n            imported_id[to_bridge] = thisAddress;\r\n        }\r\n\r\n        // Liquidity add\r\n        if (to_pair == WETH) { \r\n            SVT_Liquidity_index[thisLiquidity].native_pair = true;\r\n        }\r\n        SVT_Liquidity_index[thisLiquidity].active = true;\r\n        SVT_Liquidity_index[thisLiquidity].deployed = true;\r\n        SVT_Liquidity_index[thisLiquidity].token_1 = ERC20(to_bridge);\r\n        SVT_Liquidity_index[thisLiquidity].token_2 = ERC20(to_pair);\r\n        delete to_pair;\r\n        SVT_Liquidity_index[thisLiquidity].token_1_qty += taxes_include_fee(qty_1);\r\n        SVT_Liquidity_index[thisLiquidity].token_2_qty += taxes_include_fee(qty_2);\r\n        SVT_Liquidity_index[thisLiquidity].SVT_token_id = thisAddress;\r\n        SVT_Liquidity_index[thisLiquidity].liq_mode = 1;\r\n\r\n        // Token definition\r\n        SVT_address[thisAddress].deployed = true;\r\n        SVT_address[thisAddress].circulatingSupply += qty_1;\r\n        SVT_address[thisAddress].totalSupply = from_token.totalSupply();\r\n        SVT_address[thisAddress].name = from_token.name();\r\n        SVT_address[thisAddress].ticker = from_token.symbol();\r\n        SVT_address[thisAddress].isBridged = true;\r\n        SVT_address[thisAddress].original_token = to_bridge;\r\n        //SVT_address[thisAddress].balance[msg.sender] = (qty_1*99)/100;\r\n        SVT_address[thisAddress].SVT_Liquidity_storage = thisLiquidity;\r\n        taxes_token_total[to_bridge] += ( qty_1 - taxes_include_fee(qty_1) );\r\n        taxes_token_total[to_pair] += ( qty_2 - taxes_include_fee(qty_2) );\r\n\r\n    }\r\n\r\n    function create_svt_pair_from_eth(address to_bridge, uint256 qty_1) public safe payable onlyAuth(to_bridge) {\r\n        ERC20 from_token = ERC20(to_bridge);\r\n        ERC20 from_pair = ERC20(WETH);\r\n        require(from_token.balanceOf(msg.sender) >= qty_1, \"You don't have enough tokens (1)\");\r\n        // Approve and transfer tokens, keeping 1% as fee\r\n        from_token.transferFrom(msg.sender, address(this), qty_1);\r\n        uint256 thisAddress;\r\n        uint256 thisLiquidity;\r\n        if (imported[to_bridge]) {\r\n            require(create_svt_pair_existing_enabled, \"Not yet enabled (pair adding)\");\r\n            bool success;\r\n            thisAddress = imported_id[to_bridge];\r\n            thisLiquidity = SVT_address[thisAddress].SVT_Liquidity_storage;\r\n            require(WETH==address(SVT_Liquidity_index[thisLiquidity].token_2), \"Wrong pair\");\r\n            success = pair_adder.create_svt_pair_from_eth_existing(SVT_Liquidity_index[thisLiquidity].token_1_qty, SVT_Liquidity_index[thisLiquidity].token_2_qty, to_bridge, qty_1, msg.value);\r\n            require(success, \"Failed pairing\");\r\n            delete success;\r\n        } else {\r\n            svt_last_id +=1;\r\n            svt_liquidity_last_id += 1;\r\n            thisAddress = svt_last_id;\r\n            thisLiquidity = svt_liquidity_last_id;\r\n        }\r\n        imported[to_bridge] = true;\r\n        imported_id[to_bridge] = thisAddress;\r\n\r\n        // Liquidity add\r\n        SVT_Liquidity_index[thisLiquidity].native_pair = true;\r\n        SVT_Liquidity_index[thisLiquidity].active = true;\r\n        SVT_Liquidity_index[thisLiquidity].deployed = true;\r\n        SVT_Liquidity_index[thisLiquidity].token_1 = from_token;\r\n        SVT_Liquidity_index[thisLiquidity].token_2 = from_pair;\r\n        SVT_Liquidity_index[thisLiquidity].token_1_qty += taxes_include_fee(qty_1);\r\n        SVT_Liquidity_index[thisLiquidity].token_2_qty += taxes_include_fee(msg.value);\r\n        SVT_Liquidity_index[thisLiquidity].SVT_token_id = thisAddress;\r\n        SVT_Liquidity_index[thisLiquidity].liq_mode = 1;\r\n\r\n        // Token definition\r\n        SVT_address[thisAddress].deployed = true;\r\n        SVT_address[thisAddress].circulatingSupply += qty_1;\r\n        SVT_address[thisAddress].totalSupply = from_token.totalSupply();\r\n        SVT_address[thisAddress].name = from_token.name();\r\n        SVT_address[thisAddress].ticker = from_token.symbol();\r\n        SVT_address[thisAddress].isBridged = true;\r\n        SVT_address[thisAddress].original_token = to_bridge;\r\n        //SVT_address[thisAddress].balance[msg.sender] = (qty_1*995)/1000;\r\n        SVT_address[thisAddress].SVT_Liquidity_storage = thisLiquidity;\r\n        taxes_token_total[to_bridge] += ( qty_1 - taxes_include_fee(qty_1) );\r\n        taxes_eth_total += ( msg.value - taxes_include_fee(msg.value) );\r\n\r\n    }\r\n\r\n    function collect_taxes_eth() public onlyTeam {\r\n        if (address(this).balance < taxes_eth_total) {\r\n            payable(owner).transfer(address(this).balance);\r\n        } else {\r\n            payable(owner).transfer(taxes_eth_total);\r\n        }\r\n        taxes_eth_total = 0;\r\n    }\r\n\r\n    function collect_taxes_token(address addy) public onlyTeam {\r\n        ERC20 token_erc = ERC20(addy);\r\n        if (token_erc.balanceOf(address(this)) < taxes_token_total[addy]) {\r\n            token_erc.transfer(owner, token_erc.balanceOf(address(this)));\r\n        } else {\r\n            token_erc.transfer(owner, taxes_token_total[addy]);\r\n        }\r\n        taxes_token_total[addy] = 0;\r\n    }\r\n\r\n    function collect_taxes_native(uint256 svt_id) public onlyTeam {\r\n        require(SVT_address[svt_id].deployed, \"Not a valid token\");\r\n        SVT_address[svt_id].balance[owner] += taxes_native_total[svt_id];\r\n        taxes_native_total[svt_id] = 0;\r\n    }\r\n\r\n\r\n    /// Returns the status, if exists, of a SVT Token\r\n    function _isBridged(uint256 addy) private view returns (bool) {\r\n        return SVT_address[addy].isBridged;\r\n    }\r\n\r\n    /// Gets the original token on ETH\r\n    function _originalToken(uint256 addy) private view returns (address) {\r\n        return SVT_address[addy].original_token;\r\n    }\r\n\r\n}"}}}