{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/hedgehog/hedgehog.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity =0.6.11;\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function div(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0);\n        z = x / y;\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    //rounds to zero if x*y < RAY / 2\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    //rounds to zero if x*y < RAY / 2\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ncontract HedgehogERC20 is IERC20 {\n    using SafeMath for uint;\n    \n    string public override name;\n    string public override symbol;\n    uint8 public override decimals;\n    uint  public override totalSupply;\n    mapping(address => uint) public override balanceOf;\n    mapping(address => mapping(address => uint)) public override allowance;\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n}\n\ncontract Hedgehog is HedgehogERC20{\n  using SafeMath for uint256;\n\n  bool public initialized;\n  address public asset;\n\n  uint256 public timestamp;\n  uint256 public oracle;\n  uint256 public oracle_prev;\n\n  event Deposit(address indexed from, uint256 asset_value, uint256 token_value);\n  event Withdraw(address indexed from, uint256 asset_value, uint256 token_value);\n  event Oracle(uint256 timestamp, uint256 new_price, uint256 old_price);\n\n  uint256 private unlocked = 1;\n  modifier lock() {\n      require(unlocked == 1, 'Hedgehog: LOCKED');\n      unlocked = 0;\n      _;\n      unlocked = 1;\n  }\n\n  function initialize(address _asset) public {\n      require(initialized == false, \"Hedgehog_initialize: already initialized\");\n      asset = _asset;\n      initialized = true;\n      string memory _name = IERC20(asset).name();\n      name = append(\"Hedgehog \", _name);\n      string memory _symbol = IERC20(asset).symbol();\n      symbol = append(\"h\", _symbol);\n      decimals = 5;\n  }\n\n  function price() public view returns (uint256) {\n      uint256 token_price = calculateAssetIn(1e5);\n      return token_price;\n  }\n  \n  function deposit(uint256 token_amount, uint256 expected_assets) public lock {\n      uint256 asset_deposit = calculateAssetIn(token_amount);\n      require(asset_deposit > 0, \"Hedgehog_Deposit: zero asset deposit\"); \n      require(asset_deposit <= expected_assets, \"Hedgehog_Deposit: deposit assets above expected\");\n      _oracle();\n      TransferHelper.safeTransferFrom(asset, msg.sender, address(this), asset_deposit); \n      _mint(msg.sender, token_amount);\n      Deposit(msg.sender, asset_deposit, token_amount);\n  }\n\n  function withdraw(uint256 token_amount, uint256 expected_assets) public lock {\n      uint256 asset_withdraw = calculateAssetOut(token_amount);\n      require(asset_withdraw > 0, \"Hedgehog_withdraw: zero asset withdraw\"); \n      require(asset_withdraw >= expected_assets, \"Hedgehog_Deposit: withdraw assets below expected\");\n      _oracle();\n      _burn(msg.sender, token_amount);\n      TransferHelper.safeTransfer(asset, msg.sender, asset_withdraw);\n      Withdraw(msg.sender, asset_withdraw, token_amount);\n  }\n\n  function calculateAssetIn(uint256 token_amount) public view returns (uint256) {\n      uint256 asset_balance = IERC20(asset).balanceOf(address(this));\n      uint256 token_balance_new = totalSupply.add(token_amount);\n      uint256 asset_balance_new = token_balance_new.mul(token_balance_new);\n      return asset_balance_new.sub(asset_balance);\n  }\n\n  function calculateAssetOut(uint256 token_amount) public view returns (uint256) {\n      uint256 asset_balance = IERC20(asset).balanceOf(address(this));\n      uint256 token_balance_new = totalSupply.sub(token_amount);\n      uint256 asset_balance_new = token_balance_new.mul(token_balance_new);\n      return asset_balance.sub(asset_balance_new);\n  }\n\n  function _oracle() internal {\n      if (timestamp < block.timestamp && totalSupply > 0){\n          timestamp = block.timestamp;\n          oracle_prev = oracle;\n          oracle = price();\n          Oracle(timestamp, oracle, oracle_prev);\n      }\n  }\n\n  function append(string memory a, string memory b) internal pure returns (string memory) {\n      return string(abi.encodePacked(a, b));\n  }\n}\n\ncontract HedgehogFactory {\n\n    mapping(address =>  address) public hedgehog;\n    address[] public allHedgehogs;\n \n    function allHedgehogsLength() external view returns (uint) {\n        return allHedgehogs.length;\n    }\n    function createHedgehog(address asset) public returns (address) {\n        require(asset != address(0), \"HedgehogFactory: zero asset\");\n        require(hedgehog[asset] == address(0), \"HedgehogFactory: existing hedgehog\");\n        Hedgehog _hedgehog = new Hedgehog();\n        hedgehog[asset] = address(_hedgehog);\n        allHedgehogs.push(address(_hedgehog));\n        _hedgehog.initialize(asset);\n        return address(_hedgehog);\n    }\n}"
    }
  }
}