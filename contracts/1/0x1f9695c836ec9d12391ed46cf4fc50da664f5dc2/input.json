{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/souls.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.7.1;\r\n\r\ncontract Souls{\r\n\r\n\r\n    constructor(){\r\n        supportedInterfaces[0x80ac58cd] = true;\r\n        supportedInterfaces[0x5b5e139f] = true;\r\n        supportedInterfaces[0x01ffc9a7] = true;\r\n\r\n    }\r\n\r\n\r\n    //////===721 Standard\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    //////===721 Implementation\r\n    mapping(address => uint256) internal BALANCES;\r\n    mapping (uint256 => address) internal ALLOWANCE;\r\n    mapping (address => mapping (address => bool)) internal AUTHORISED;\r\n\r\n    uint[] SOULS;  //Array of all souls [tokenId,tokenId,...]\r\n    mapping(uint256 => address) OWNERS;  //Mapping of soul owners\r\n\r\n    //    METADATA VARS\r\n    string private __name = \"EtherSouls\";\r\n    string private __symbol = \"SOUL\";\r\n    bytes private __uriBase = bytes(\"https://www.ethersouls.xyz/tokenData/metadata?id=\");\r\n\r\n\r\n    //    ENUMERABLE VARS\r\n    mapping(address => uint[]) internal OWNER_INDEX_TO_ID;\r\n    mapping(uint => uint) internal OWNER_ID_TO_INDEX;\r\n    mapping(uint => uint) internal ID_TO_INDEX;\r\n\r\n    address constant VITALIK = 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B;\r\n\r\n    function isValidToken(uint256 _tokenId) internal view returns(bool){\r\n        return OWNERS[_tokenId] != address(0);\r\n    }\r\n\r\n\r\n    function balanceOf(address _owner) external view returns (uint256){\r\n        return BALANCES[_owner];\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns(address){\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return OWNERS[_tokenId];\r\n    }\r\n\r\n\r\n    //Separate your immortal soul from your physical body and store it on the blockchain\r\n    function separate() external {\r\n        uint tokenId = uint(msg.sender);\r\n\r\n        require(OWNERS[tokenId] == address(0),\"exists\");\r\n\r\n\r\n        OWNERS[tokenId] = msg.sender;\r\n        BALANCES[msg.sender]++;\r\n\r\n        OWNER_ID_TO_INDEX[tokenId] = OWNER_INDEX_TO_ID[msg.sender].length;\r\n        OWNER_INDEX_TO_ID[msg.sender].push(tokenId);\r\n\r\n        ID_TO_INDEX[tokenId] = SOULS.length;\r\n        SOULS.push(tokenId);\r\n\r\n        emit Transfer(address(0),VITALIK,tokenId);\r\n        emit Transfer(VITALIK,msg.sender,tokenId);\r\n    }\r\n\r\n\r\n    function approve(address _approved, uint256 _tokenId)  external{\r\n        address owner = ownerOf(_tokenId);\r\n        require( owner == msg.sender                    //Require Sender Owns Token\r\n            || AUTHORISED[owner][msg.sender]                //  or is approved for all.\r\n        ,\"permission\");\r\n        emit Approval(owner, _approved, _tokenId);\r\n        ALLOWANCE[_tokenId] = _approved;\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) external view returns (address) {\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return ALLOWANCE[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return AUTHORISED[_owner][_operator];\r\n    }\r\n\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        emit ApprovalForAll(msg.sender,_operator, _approved);\r\n        AUTHORISED[msg.sender][_operator] = _approved;\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\r\n\r\n        //Check Transferable\r\n        //There is a token validity check in ownerOf\r\n        address owner = ownerOf(_tokenId);\r\n\r\n        require ( owner == msg.sender             //Require sender owns token\r\n        //Doing the two below manually instead of referring to the external methods saves gas\r\n        || ALLOWANCE[_tokenId] == msg.sender      //or is approved for this token\r\n            || AUTHORISED[owner][msg.sender]          //or is approved for all\r\n        ,\"permission\");\r\n        require(owner == _from,\"owner\");\r\n        require(_to != address(0),\"zero\");\r\n        //require(isValidToken(_tokenId)); <-- done by ownerOf\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n\r\n\r\n        OWNERS[_tokenId] =_to;\r\n\r\n        BALANCES[_from]--;\r\n        BALANCES[_to]++;\r\n\r\n        //Reset approved if there is one\r\n        if(ALLOWANCE[_tokenId] != address(0)){\r\n            delete ALLOWANCE[_tokenId];\r\n        }\r\n\r\n        //Enumerable Additions\r\n        uint oldIndex = OWNER_ID_TO_INDEX[_tokenId];\r\n        //If the token isn't the last one in the owner's index\r\n        if(oldIndex != OWNER_INDEX_TO_ID[_from].length - 1){\r\n            //Move the old one in the index list\r\n            OWNER_INDEX_TO_ID[_from][oldIndex] = OWNER_INDEX_TO_ID[_from][OWNER_INDEX_TO_ID[_from].length - 1];\r\n            //Update the token's reference to its place in the index list\r\n            OWNER_ID_TO_INDEX[OWNER_INDEX_TO_ID[_from][oldIndex]] = oldIndex;\r\n        }\r\n        //OWNER_INDEX_TO_ID[_from].length--;\r\n        OWNER_INDEX_TO_ID[_from].pop();\r\n\r\n        OWNER_ID_TO_INDEX[_tokenId] = OWNER_INDEX_TO_ID[_to].length;\r\n        OWNER_INDEX_TO_ID[_to].push(_tokenId);\r\n\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {\r\n        transferFrom(_from, _to, _tokenId);\r\n\r\n        //Get size of \"_to\" address, if 0 it's a wallet\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_to)\r\n        }\r\n        if(size > 0){\r\n            ERC721TokenReceiver receiver = ERC721TokenReceiver(_to);\r\n            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")),\"receiver\");\r\n        }\r\n\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        safeTransferFrom(_from,_to,_tokenId,\"\");\r\n    }\r\n\r\n\r\n\r\n\r\n    // METADATA FUNCTIONS\r\n    function tokenURI(uint256 _tokenId) public view returns (string memory){\r\n        //Note: changed visibility to public\r\n        require(isValidToken(_tokenId));\r\n\r\n//        uint maxLength = 50;\r\n        uint[50] memory reversed;\r\n//        uint i = 0;\r\n\r\n        string memory uri = string(__uriBase);\r\n\r\n\r\n        string[10] memory lib;\r\n        lib[0] = \"0\";\r\n        lib[1] = \"1\";\r\n        lib[2] = \"2\";\r\n        lib[3] = \"3\";\r\n        lib[4] = \"4\";\r\n        lib[5] = \"5\";\r\n        lib[6] = \"6\";\r\n        lib[7] = \"7\";\r\n        lib[8] = \"8\";\r\n        lib[9] = \"9\";\r\n\r\n        uint len = 0;\r\n        while (_tokenId != 0) {\r\n            uint remainder = _tokenId % 10;\r\n            _tokenId /= 10;\r\n            reversed[len] = remainder;\r\n            len++;\r\n        }\r\n\r\n        for(uint j = len; j > 0; j--){\r\n            uri = string(abi.encodePacked(uri,lib[reversed[j-1]]));\r\n        }\r\n\r\n        return uri;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction name() external view returns (string memory _name){\r\n        //_name = \"Name must be hard coded\";\r\n        return __name;\r\n    }\r\n\r\n    function symbol() external view returns (string memory _symbol){\r\n        //_symbol = \"Symbol must be hard coded\";\r\n        return __symbol;\r\n    }\r\n\r\n\r\n    // ENUMERABLE FUNCTIONS\r\n\r\n    function totalSupply() external view returns (uint256){\r\n        return SOULS.length;\r\n    }\r\n\r\n    function tokenByIndex(uint256 _index) external view returns(uint256){\r\n        require(_index < SOULS.length,\"index\");\r\n        return SOULS[_index];\r\n\r\n\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256){\r\n        require(_index < BALANCES[_owner],\"index\");\r\n        return OWNER_INDEX_TO_ID[_owner][_index];\r\n    }\r\n\r\n    // End 721 Implementation\r\n\r\n    ///////===165 Implementation\r\n    mapping (bytes4 => bool) internal supportedInterfaces;\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool){\r\n        return supportedInterfaces[interfaceID];\r\n    }\r\n    ///==End 165\r\n}\r\n\r\n\r\n\r\n\r\ninterface ERC721TokenReceiver {\r\n    //TODO: this\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\n"
    }
  }
}