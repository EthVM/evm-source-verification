{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"settle.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nenum DepositActionType {\r\n    // No deposit action\r\n    None,\r\n    // Deposit asset cash, depositActionAmount is specified in asset cash external precision\r\n    DepositAsset,\r\n    // Deposit underlying tokens that are mintable to asset cash, depositActionAmount is specified in underlying token\r\n    // external precision\r\n    DepositUnderlying,\r\n    // Deposits specified asset cash external precision amount into an nToken and mints the corresponding amount of\r\n    // nTokens into the account\r\n    DepositAssetAndMintNToken,\r\n    // Deposits specified underlying in external precision, mints asset cash, and uses that asset cash to mint nTokens\r\n    DepositUnderlyingAndMintNToken,\r\n    // Redeems an nToken balance to asset cash. depositActionAmount is specified in nToken precision. Considered a deposit action\r\n    // because it deposits asset cash into an account. If there are fCash residuals that cannot be sold off, will revert.\r\n    RedeemNToken,\r\n    // Converts specified amount of asset cash balance already in Notional to nTokens. depositActionAmount is specified in\r\n    // Notional internal 8 decimal precision.\r\n    ConvertCashToNToken\r\n}\r\n\r\nenum TradeActionType {\r\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 minImpliedRate, uint120 unused)\r\n    Lend, \r\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate, uint128 unused)\r\n    Borrow,\r\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 assetCashAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\r\n    AddLiquidity,\r\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 tokenAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\r\n    RemoveLiquidity,\r\n    // (uint8 TradeActionType, uint32 Maturity, int88 fCashResidualAmount, uint128 unused)\r\n    PurchaseNTokenResidual,\r\n    // (uint8 TradeActionType, address CounterpartyAddress, int88 fCashAmountToSettle)\r\n    SettleCashDebt\r\n}\r\n\r\n/// @dev Market object as represented in memory\r\nstruct MarketParameters {\r\n    bytes32 storageSlot;\r\n    uint256 maturity;  //到期日\r\n    // Total amount of fCash available for purchase in the market.\r\n    int256 totalfCash;  \r\n    // Total amount of cash available for purchase in the market.\r\n    int256 totalAssetCash;\r\n    // Total amount of liquidity tokens (representing a claim on liquidity) in the market.\r\n    int256 totalLiquidity;\r\n    // This is the previous annualized interest rate in RATE_PRECISION that the market traded\r\n    // at. This is used to calculate the rate anchor to smooth interest rates over time.\r\n    \r\n    uint256 lastImpliedRate; //fcash的兑换率\r\n    // Time lagged version of lastImpliedRate, used to value fCash assets at market rates while\r\n    // remaining resistent to flash loan attacks.\r\n\r\n    //lastImpliedRate的时滞版本，用于以市场利率对fCash资产进行估值，同时保持对闪电贷款攻击的抵抗力。\r\n    uint256 oracleRate;\r\n\r\n    // This is the timestamp of the previous trade\r\n    uint256 previousTradeTime;\r\n}\r\n\r\ninterface AssetRateAdapter {\r\n    function token() external view returns (address);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function description() external view returns (string memory);\r\n\r\n    function version() external view returns (uint256);\r\n\r\n    function underlying() external view returns (address);\r\n\r\n    function getExchangeRateStateful() external returns (int256);\r\n\r\n    function getExchangeRateView() external view returns (int256);\r\n\r\n    function getAnnualizedSupplyRate() external view returns (uint256);\r\n}\r\n\r\ninterface AggregatorInterface {\r\n  function latestAnswer() external view returns (int256);\r\n  function latestTimestamp() external view returns (uint256);\r\n  function latestRound() external view returns (uint256);\r\n  function getAnswer(uint256 roundId) external view returns (int256);\r\n  function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\r\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface{\r\n\r\n}\r\n\r\n\r\ninterface Notional {\r\n\r\n\t//得到用户cash余额 注意是ctoken!!!!\r\n\tfunction getAccountBalance(uint16 currencyId, address account) external view returns (\r\n            int256 cashBalance,\r\n            int256 nTokenBalance,\r\n            uint256 lastClaimTime\r\n    );\r\n\r\n\tfunction getRateStorage(uint16 currencyId) external view returns (ETHRateStorage memory ethRate, AssetRateStorage memory assetRate);\r\n   \r\n    \r\n\tfunction getAccountContext(address account) external view returns (AccountContext memory);\r\n    \r\n\tfunction settleAccount(address account) external returns (AccountContext memory);\r\n\r\n\tfunction getfCashAmountGivenCashAmount(uint16 currencyId,int88 netCashToAccount,uint256 marketIndex,uint256 blockTime) external view returns (int256);\r\n\r\n\tfunction batchBalanceAndTradeAction(address account, BalanceActionWithTrades[] calldata actions) external payable;\r\n        \r\n\tfunction initializeMarkets(uint16 currencyId, bool isFirstInit) external;\r\n    \r\n}\r\n\r\ninterface ICERC20 {\r\n    function transfer(address dst, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);  \r\n}\r\n\r\nstruct AssetRateParameters {\r\n    // Address of the asset rate oracle\r\n    AssetRateAdapter rateOracle;\r\n    // The exchange rate from base to quote (if invert is required it is already done)\r\n    int256 rate;//从底层资产到合成资产的汇率（如果需要反转，则已完成）\r\n    // The decimals of the underlying, the rate converts to the underlying decimals\r\n    int256 underlyingDecimals; //底层资产的精度，转换为底层资产的比列\r\n}\r\n\r\nstruct AccountContext {\r\n    // Used to check when settlement must be triggered on an account\r\n    //下一次结算时间\r\n    uint40 nextSettleTime;\r\n    // For lenders that never incur debt, we use this flag to skip the free collateral check.\r\n    //是否有过贷款\r\n    bytes1 hasDebt;\r\n    // Length of the account's asset array\r\n    // 用户资产数量\r\n    uint8 assetArrayLength;\r\n    // If this account has bitmaps set, this is the corresponding currency id\r\n    //  未知\r\n    uint16 bitmapCurrencyId;\r\n    //  未知\r\n    // 9 total active currencies possible (2 bytes each)\r\n    bytes18 activeCurrencies;\r\n}\r\n\r\nenum AssetStorageState {NoChange, Update, Delete, RevertIfStored}\r\n\r\nstruct PortfolioAsset {\r\n    // Asset currency id\r\n    uint256 currencyId;\r\n    uint256 maturity; //到期日\r\n    // Asset type, fCash or liquidity token.\r\n    uint256 assetType; //资产类型，有LT 也有fcash\r\n    // fCash amount or liquidity token amount\r\n    int256 notional;      //资产数量，有正数有负数\r\n    // Used for managing portfolio asset state\r\n    uint256 storageSlot;\r\n    // The state of the asset for when it is written to storage\r\n    AssetStorageState storageState;\r\n}\r\n\r\nstruct BalanceActionWithTrades {\r\n\tDepositActionType actionType;\r\n\tuint16 currencyId;\r\n\tuint256 depositActionAmount;\r\n\tuint256 withdrawAmountInternalPrecision;\r\n\tbool withdrawEntireCashBalance;\r\n\tbool redeemToUnderlying;\r\n\t// Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\r\n\tbytes32[] trades;\r\n}\r\n\r\n\r\n/// @notice In memory ETH exchange rate used during free collateral calculation.\r\nstruct ETHRate {\r\n    // The decimals (i.e. 10^rateDecimalPlaces) of the exchange rate, defined by the rate oracle\r\n    int256 rateDecimals;\r\n    // The exchange rate from base to ETH (if rate invert is required it is already done)\r\n    int256 rate;\r\n    // Amount of buffer as a multiple with a basis of 100 applied to negative balances.\r\n    int256 buffer;\r\n    // Amount of haircut as a multiple with a basis of 100 applied to positive balances\r\n    int256 haircut;\r\n    // Liquidation discount as a multiple with a basis of 100 applied to the exchange rate\r\n    // as an incentive given to liquidators.\r\n    int256 liquidationDiscount;\r\n}\r\n\r\nenum TokenType {UnderlyingToken, cToken, cETH, Ether, NonMintable}\r\n\r\n/// @notice Internal object that represents a token\r\nstruct Token {\r\n    address tokenAddress;\r\n    bool hasTransferFee;\r\n    int256 decimals;\r\n    TokenType tokenType;\r\n    uint256 maxCollateralBalance;\r\n}\r\n\r\n/// @dev Exchange rate object as it is represented in storage, total storage is 25 bytes.\r\nstruct ETHRateStorage {\r\n    // Address of the rate oracle\r\n    AggregatorV2V3Interface rateOracle;\r\n    // The decimal places of precision that the rate oracle uses\r\n    uint8 rateDecimalPlaces;\r\n    // True of the exchange rate must be inverted\r\n    bool mustInvert;\r\n    // NOTE: both of these governance values are set with BUFFER_DECIMALS precision\r\n    // Amount of buffer to apply to the exchange rate for negative balances.\r\n    uint8 buffer;\r\n    // Amount of haircut to apply to the exchange rate for positive balances\r\n    uint8 haircut;\r\n    // Liquidation discount in percentage point terms, 106 means a 6% discount\r\n    uint8 liquidationDiscount;\r\n}\r\n\r\n/// @dev Asset rate oracle object as it is represented in storage, total storage is 21 bytes.\r\nstruct AssetRateStorage {\r\n    // Address of the rate oracle\r\n    AssetRateAdapter rateOracle;\r\n    // The decimal places of the underlying asset\r\n    uint8 underlyingDecimalPlaces;\r\n}\r\n\r\n\r\n\r\nlibrary SafeInt256 {\r\n    int256 private constant _INT256_MIN = type(int256).min;\r\n\r\n    \r\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\r\n        c = a * b;\r\n        if (a == -1) require (b == 0 || c / b == a);\r\n        else require (a == 0 || c / a == b);\r\n    }\r\n\r\n   \r\n    function div(int256 a, int256 b) internal pure returns (int256 c) {\r\n        require(!(b == -1 && a == _INT256_MIN)); // dev: int256 div overflow\r\n        // NOTE: solidity will automatically revert on divide by zero\r\n        c = a / b;\r\n    }\r\n \r\n}\r\n\r\ncontract Owner {\r\n\r\n    address private owner;\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier isOwner() {\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public isOwner {\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ncontract settle  is Owner  {\r\n\tuint256 internal constant DAY = 86400;\r\n    // We use six day weeks to ensure that all time references divide evenly\r\n    uint256 internal constant WEEK = DAY * 6;\r\n    uint256 internal constant MONTH = WEEK * 5;\r\n    uint256 internal constant QUARTER = MONTH * 3;\r\n\r\n\taddress constant NotionalAddress = 0x1344A36A1B56144C3Bc62E7757377D288fDE0369;\r\n\tusing SafeInt256 for int256;\r\n\r\n\tconstructor(){\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\tfunction convertToUnderlying(uint16 currencyId,int256 assetBalance) public view returns (int256) {\r\n\r\n\t\t(,AssetRateStorage memory assetRate) = Notional(NotionalAddress).getRateStorage(currencyId);\r\n\r\n\t\tint256 rate = AssetRateAdapter(assetRate.rateOracle).getExchangeRateView(); //从外部地址获取兑换率 ctoken与底层资产的兑换率\r\n\r\n        // Calculation here represents:\r\n        // rate * balance * internalPrecision / rateDecimals * underlyingPrecision\r\n        int256 underlyingBalance = rate\r\n            .mul(assetBalance)\r\n            .div(1e10)\r\n            .div(int256(uint256(assetRate.underlyingDecimalPlaces)));\r\n\r\n        return underlyingBalance;\r\n    }\r\n\r\n\t//marketIndex 为要兑换的市场，这里千万注意 因为下个市场会变化\r\n\t//cashBalance为负数,fcashAmount为负数\r\n\tfunction getPayCashAndFcash(address account,uint16 currencyId,uint256 marketIndex) public view  returns(int256 ,int256) {\r\n\t\t//在这之前市场必须要进行初始化\t\r\n\t\tint256 fcashAmount = 0;\r\n\r\n\t\tuint256 blockTime = block.timestamp;\r\n\t\t(int256 cashBalanceAsset,,) = Notional(NotionalAddress).getAccountBalance(currencyId,account);\r\n\t\tif(cashBalanceAsset >= 0) { //已经被结算过了\r\n\t\t\treturn (cashBalanceAsset,fcashAmount);  //这里就不继续转换成底层资产了,因为已经不需要结算了\r\n\t\t}\r\n\r\n\t\t//注意cashBalanceAsset是ctoken,这里做一次转换\r\n\t\tint256 cashBalance = convertToUnderlying(currencyId,cashBalanceAsset);\r\n\r\n\t\t//注意fcashAmount的符号,这里cashBalance为负数 fcashAmount就为正数。如果传错了滑点就会滑向相反的方向，与实际情况不符\r\n\t\t//所以要传入负数 最终结果fcash为负数。这里表示用户要得到正的cash,账户会累计多少负的fcash\r\n\t\t//此处的含义是结算人为了帮助 欠款人 结算 需要付出cashBalance的资金，从而自己需要从市场上借多少fcash\r\n\t\tfcashAmount = Notional(NotionalAddress).getfCashAmountGivenCashAmount(currencyId,int88(-cashBalance),marketIndex,blockTime);\r\n\r\n\t\t//因为最终得到正的fcash会稍微有盈余，所以这里可以适当增加fcash的数量\r\n\r\n\t\treturn (cashBalance,fcashAmount);\r\n\t}\r\n\r\n\tfunction executeTradesByMultiUser(address[] memory accounts,uint16 currencyId,uint256 maturity) isOwner external {\r\n\t\t//判断时间是否到了可以初始化与清算的时候, maturity为到期日\r\n\t\tuint256 blockTime = block.timestamp;\r\n\t\trequire(blockTime >= maturity,\"please settle later\");\r\n\t\t//判断市场是否需要初始化. 这个必须在getPayCashAndFcash 之前\r\n\t\t_initMaketIfRequired(currencyId);\r\n\r\n\t\tfor (uint i = 0; i < accounts.length; i++) {\r\n\t\t\t_executeTrade(accounts[i],currencyId);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction executeTradesBySingleUser(address account,uint16 currencyId,uint256 maturity) isOwner external {\r\n\t\t//判断时间是否到了可以初始化与清算的时候, maturity为到期日\r\n\t\tuint256 blockTime = block.timestamp;\r\n\t\trequire(blockTime >= maturity,\"please settle later\");\r\n\t\t//判断市场是否需要初始化. 这个必须在getPayCashAndFcash 之前\r\n\t\t_initMaketIfRequired(currencyId);\r\n\r\n\t\t_executeTrade(account,currencyId);\r\n\t}\r\n\r\n\t//用来与合约进行交互, 方便后续提款.\r\n\tfunction executeTradesBatch(BalanceActionWithTrades[] memory tradeBatch) isOwner external {\r\n\t\tNotional(NotionalAddress).batchBalanceAndTradeAction(address(this),tradeBatch);\r\n\t}\r\n\r\n\tfunction ERC20Transfer(address token,address to,uint256 amount) isOwner external {\r\n        ICERC20(token).transfer(to,amount);\r\n    }\r\n\r\n    function ERC20TransferFrom(address token,address to,uint256 amount) isOwner external {\r\n        ICERC20(token).transferFrom(address(this),to,amount);\r\n    }\r\n\r\n\tfunction ETHTransfer() isOwner external {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n\r\n\t//结算单个用户\r\n\tfunction _executeTrade(address account,uint16 currencyId) internal {\r\n\t\t\r\n\t\t//得到是否需要结算\r\n\t\t_settleAccountIfRequired(account);\r\n\r\n\t\tuint256 marketIndex = 1; //这里marketIndex永远是1,表示在市场初始化之后的 第一个市场\r\n\r\n        //这里fcashAmount也为负数\r\n\t\t(int256 cashBalance,int256 fcashAmount) = getPayCashAndFcash(account,currencyId,marketIndex);\r\n\r\n\t\tif(cashBalance >= 0){ //已经被结算了\r\n\t\t\treturn ;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tbytes memory tradeBorrowItem = new bytes(32);\r\n\t\ttradeBorrowItem = abi.encodePacked(uint8(TradeActionType.Borrow),uint8(marketIndex),uint88(uint256(-fcashAmount)),uint32(0));\r\n\t\t\r\n\t\r\n\r\n\t\tbytes memory tradeSettleItem = new bytes(32);\r\n\t\ttradeSettleItem = abi.encodePacked(uint8(TradeActionType.SettleCashDebt),account,uint88(0));\r\n\t\t\r\n\t\t\r\n\t\tbytes32[] memory trades = new bytes32[](2);\r\n\t\t\r\n\t\ttrades[0] = _bytesToBytes32(tradeBorrowItem);\r\n\t\ttrades[1] = _bytesToBytes32(tradeSettleItem);\r\n\t\t\r\n\t\tBalanceActionWithTrades memory tradeItem = BalanceActionWithTrades(\r\n\t\t\tDepositActionType.None,\r\n\t\t\tcurrencyId,\r\n\t\t\t0, //depositActionAmount\r\n\t\t\t0,//withdrawAmountInternalPrecision 提款数量\r\n\t\t\tfalse,//withdrawEntireCashBalance 是否将cash全部提出 ;\r\n\t\t\tfalse,//redeemToUnderlying 是否赎回底层资产\r\n\t\t\t// Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\r\n\t\t\ttrades\r\n\t\t);\r\n\t\t\r\n\t\tBalanceActionWithTrades[] memory tradeBatch = new BalanceActionWithTrades[](1);\r\n\t\ttradeBatch[0] = tradeItem;\r\n\r\n\t\tNotional(NotionalAddress).batchBalanceAndTradeAction(address(this),tradeBatch);\r\n\r\n\t}\r\n\r\n\tfunction _settleAccountIfRequired(address account) internal {\r\n\t\tuint256 blockTime = block.timestamp;\r\n\r\n\t\tAccountContext memory accContext = Notional(NotionalAddress).getAccountContext(account);\r\n\t\tbool mustSettle =  0 < accContext.nextSettleTime && accContext.nextSettleTime <= blockTime;\r\n\r\n\t\tif (mustSettle) { //开始结算\r\n\t\t\tNotional(NotionalAddress).settleAccount(account);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _getReferenceTime(uint256 blockTime) internal pure returns (uint256) {\r\n        require(blockTime >= QUARTER);\r\n        return blockTime - (blockTime % QUARTER);\r\n    }\r\n\r\n\t//查看是否需要初始化\r\n\tfunction _initMaketIfRequired(uint16 currencyId) internal {\r\n\t\tuint256 blockTime = block.timestamp;\r\n\t\tuint256 threeMonthMaturity = _getReferenceTime(blockTime) + QUARTER;\r\n\t\t//(bool ok,bytes memory returndata) =   address(notional).staticcall(abi.encodeWithSignature(\"getMarket(uint16,uint256,uint256)\",currencyId,maturity,settlementDate)) ;\r\n      \t(bool success,bytes memory returndata) = address(NotionalAddress).staticcall(abi.encodeWithSignature(\"getMarket(uint16,uint256,uint256)\",currencyId,threeMonthMaturity,threeMonthMaturity));\r\n\r\n        MarketParameters   memory market ;\r\n        \r\n        if(success){\r\n            ( market) =  abi.decode(returndata,(MarketParameters))  ;\r\n            if(market.oracleRate==0){\r\n                Notional(NotionalAddress).initializeMarkets(currencyId,false);\r\n            }\r\n        }else{\r\n            Notional(NotionalAddress).initializeMarkets(currencyId,false);\r\n        }\r\n\r\n\t} \r\n\r\n\t//转换\r\n\tfunction _bytesToBytes32(bytes memory source) internal pure returns (bytes32 result) {\r\n        if (source.length == 0) {\r\n            return 0x0;\r\n        }\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n     }\r\n\r\n}"}}}