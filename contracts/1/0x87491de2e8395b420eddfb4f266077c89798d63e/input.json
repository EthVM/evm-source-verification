{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/xETHGRebaser.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-12-14\n*/\n\n// SPDX-License-Identifier: UNLICENSED\n/**\n *\n * ██╗  ██╗███████╗████████╗██╗  ██╗\n * ╚██╗██╔╝██╔════╝╚══██╔══╝██║  ██║\n *  ╚███╔╝ █████╗     ██║   ███████║\n *  ██╔██╗ ██╔══╝     ██║   ██╔══██║\n * ██╔╝ ██╗███████╗   ██║   ██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝\n *\n *    An Ethereum pegged\n * base-down, burn-up currency.\n *\n *  https://xEth.finance\n *\n *\n**/\n\n\npragma solidity 0.6.6;\n\n\n        \ninterface UniswapPairContract {\n  \n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n  }\n        \n\ninterface xETHGTokenInterface {\n   \n    //Public functions\n    function maxScalingFactor() external view returns (uint256);\n    function xETHScalingFactor() external view returns (uint256);\n    //rebase permissioned\n    function setTxFee(uint16 fee) external ;\n    function setSellFee(uint16 fee) external ;\n    function rebase(uint256 epoch, uint256 indexDelta, bool positive) external returns (uint256);\n}\n\ncontract xETHGRebaser {\n\n    using SafeMath for uint256;\n\n    modifier onlyGov() {\n        require(msg.sender == gov);\n        _;\n    }\n\n \n    /// @notice an event emitted when deviationThreshold is changed\n    event NewDeviationThreshold(uint256 oldDeviationThreshold, uint256 newDeviationThreshold);\n\n    /// @notice Governance address\n    address public gov;\n\n  \n    /// @notice Spreads out getting to the target price\n    uint256 public rebaseLag;\n\n    /// @notice Peg target\n    uint256 public targetRate;\n    \n      /// @notice Peg target\n    uint public xValue;\n  \n    // If the current exchange rate is within this fractional distance from the target, no supply\n    // update is performed. Fixed point number--same format as the rate.\n    // (ie) abs(rate - targetRate) / targetRate < deviationThreshold, then no supply change.\n    uint256 public deviationThreshold;\n\n    /// @notice More than this much time must pass between rebase operations.\n    uint256 public minRebaseTimeIntervalSec;\n\n    /// @notice Block timestamp of last rebase operation\n    uint256 public lastRebaseTimestampSec;\n\n    /// @notice The rebase window begins this many seconds into the minRebaseTimeInterval period.\n    // For example if minRebaseTimeInterval is 24hrs, it represents the time of day in seconds.\n    uint256 public rebaseWindowOffsetSec;\n\n    /// @notice The length of the time window where a rebase operation is allowed to execute, in seconds.\n    uint256 public rebaseWindowLengthSec;\n\n    /// @notice The number of rebase cycles since inception\n    uint256 public epoch;\n\n    /// @notice delays rebasing activation to facilitate liquidity\n    uint256 public constant rebaseDelay = 0;\n\n    address public xETHAddress;\n   \n    address public uniswap_xeth_eth_pair;\n    \n    mapping(address => bool) public whitelistFrom;\n    \n   \n\n    constructor(\n        address xETHAddress_,\n        address xEthEthPair_\n    )\n        public\n    {\n          minRebaseTimeIntervalSec = 1 days;\n          rebaseWindowOffsetSec = 0; // 00:00 UTC rebases\n       \n          // Default Target Rate Set For 1 ETH \n          targetRate = 10**18;\n\n          // daily rebase, with targeting reaching peg\n          rebaseLag = 10;\n\n          // 5%\n          deviationThreshold = 5 * 10**15;\n\n          // 24 hours\n          rebaseWindowLengthSec = 24 hours;\n          \n          uniswap_xeth_eth_pair = xEthEthPair_;\n          xETHAddress = xETHAddress_;\n\n          gov = msg.sender;\n    }\n\n  \n  \n  \n    \n     function setWhitelistedFrom(address _addr, bool _whitelisted) external onlyGov {\n        whitelistFrom[_addr] = _whitelisted;\n    }\n    \n    \n     function _isWhitelisted(address _from) internal view returns (bool) {\n        return whitelistFrom[_from];\n    }\n    \n    /**\n     * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\n     *\n     * @dev The supply adjustment equals (_totalSupply * DeviationFromTargetRate) / rebaseLag\n     *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\n     *      and targetRate is 1e18\n     */\n    function rebase()\n        public\n    {\n        // EOA only\n        require(msg.sender == tx.origin);\n        require(_isWhitelisted(msg.sender));\n        // ensure rebasing at correct time\n        _inRebaseWindow();\n        \n\n        require(lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) < now);\n\n        // Snap the rebase time to the start of this window.\n        lastRebaseTimestampSec = now;\n\n        epoch = epoch.add(1);\n\n        // get price from uniswap v2;\n        uint256 exchangeRate = getPrice();\n\n        // calculates % change to supply\n        (uint256 offPegPerc, bool positive) = computeOffPegPerc(exchangeRate);\n\n        uint256 indexDelta = offPegPerc;\n\n        // Apply the Dampening factor.\n        indexDelta = indexDelta.div(rebaseLag);\n\n        xETHGTokenInterface xETH = xETHGTokenInterface(xETHAddress);\n\n        if (positive) {\n            require(xETH.xETHScalingFactor().mul(uint256(10**18).add(indexDelta)).div(10**18) < xETH.maxScalingFactor(), \"new scaling factor will be too big\");\n        }\n\n\n        // rebase\n        xETH.rebase(epoch, indexDelta, positive);\n        assert(xETH.xETHScalingFactor() <= xETH.maxScalingFactor());\n\n  }\n  \n  \n  \n  function setTimesXvalue ( uint _xValue) external onlyGov returns (uint) {\n    xValue = _xValue; \n    return xValue;  \n  }\n  \n  /**\n   * @dev Use Circuit Breakers (Prevents some un godly amount of XETHG to be minted)\n   * 1.xETHG Price Marker\n   * 2.Set Rebase 20% treashold\n   * 3.Calculate Uni Pair Price\n   * 4.Target Price + Circuit Breaker\n   * 5.Accepted xETHprice Price For Rebase\n   * 6.Is Uniswap Price Over Circuit Breaker?\n   * 7.Yes, Use Rebase xETHCircuit Breaker Price\n   * 8.No, Use Uniswap Price \n   */\n      function getPrice()\n        public\n        view\n        returns (uint256)\n    {\n        (uint xethReserve, uint ethReserve, ) = UniswapPairContract(uniswap_xeth_eth_pair).getReserves();\n        uint xEthPrice; \n        uint ETHER = 1 ether;\n        uint ETHER_X = xValue;\n        uint BASE_PERCENT = ETHER.sub(ETHER_X); \n        uint uniPrice = ethReserve.mul(ETHER).div(xethReserve); \n        uint circuitBreaker = (targetRate.mul(BASE_PERCENT)).div(ETHER);\n        uint xEthCircuitBreakerPrice = targetRate.add(circuitBreaker);\n        if (uniPrice > xEthCircuitBreakerPrice  ) { \n        return xEthPrice = xEthCircuitBreakerPrice;\n        } else {\n        return xEthPrice = uniPrice;\n       }      \n    }\n\n    function setDeviationThreshold(uint256 deviationThreshold_)\n        external\n        onlyGov\n    {\n        require(deviationThreshold > 0);\n        uint256 oldDeviationThreshold = deviationThreshold;\n        deviationThreshold = deviationThreshold_;\n        emit NewDeviationThreshold(oldDeviationThreshold, deviationThreshold_);\n    }\n\n\n    /**\n     * @notice Sets the rebase lag parameter.\n               It is used to dampen the applied supply adjustment by 1 / rebaseLag\n               If the rebase lag R, equals 1, the smallest value for R, then the full supply\n               correction is applied on each rebase cycle.\n               If it is greater than 1, then a correction of 1/R of is applied on each rebase.\n     * @param rebaseLag_ The new rebase lag parameter.\n     */\n     \n     \n    function setRebaseLag(uint256 rebaseLag_)\n        external\n        onlyGov\n    {\n        require(rebaseLag_ > 0);\n        rebaseLag = rebaseLag_;\n    }\n    \n    \n    \n    /**\n     * @notice Sets the targetRate parameter.\n     * @param targetRate_ The new target rate parameter.\n     */\n     \n     \n    function setTargetRate(uint256 targetRate_)\n        external\n        onlyGov\n    {\n        require(targetRate_ > 0);\n        targetRate = targetRate_;\n    }\n    \n    \n\n    /**\n     * @notice Sets the parameters which control the timing and frequency of\n     *         rebase operations.\n     *         a) the minimum time period that must elapse between rebase cycles.\n     *         b) the rebase window offset parameter.\n     *         c) the rebase window length parameter.\n     * @param minRebaseTimeIntervalSec_ More than this much time must pass between rebase\n     *        operations, in seconds.\n     * @param rebaseWindowOffsetSec_ The number of seconds from the beginning of\n              the rebase interval, where the rebase window begins.\n     * @param rebaseWindowLengthSec_ The length of the rebase window in seconds.\n     */\n    function setRebaseTimingParameters(\n        uint256 minRebaseTimeIntervalSec_,\n        uint256 rebaseWindowOffsetSec_,\n        uint256 rebaseWindowLengthSec_)\n        external\n        onlyGov\n    {\n        require(minRebaseTimeIntervalSec_ > 0);\n        require(rebaseWindowOffsetSec_ < minRebaseTimeIntervalSec_);\n\n        minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;\n        rebaseWindowOffsetSec = rebaseWindowOffsetSec_;\n        rebaseWindowLengthSec = rebaseWindowLengthSec_;\n    }\n\n    /**\n     * @return If the latest block timestamp is within the rebase time window it, returns true.\n     *         Otherwise, returns false.\n     */\n    function inRebaseWindow() public view returns (bool) {\n\n        // rebasing is delayed until there is a liquid market\n        _inRebaseWindow();\n        return true;\n    }\n\n    function _inRebaseWindow() internal view {\n        require(now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec, \"too early\");\n        require(now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec)), \"too late\");\n    }\n\n    /**\n     * @return Computes in % how far off market is from peg\n     */\n    function computeOffPegPerc(uint256 rate)\n        private\n        view\n        returns (uint256, bool)\n    {\n        if (withinDeviationThreshold(rate)) {\n            return (0, false);\n        }\n\n        // indexDelta =  (rate - targetRate) / targetRate\n        if (rate > targetRate) {\n            return (rate.sub(targetRate).mul(10**18).div(targetRate), true);\n        } else {\n            return (targetRate.sub(rate).mul(10**18).div(targetRate), false);\n        }\n    }\n\n    /**\n     * @param rate The current exchange rate, an 18 decimal fixed point number.\n     * @return If the rate is within the deviation threshold from the target rate, returns true.\n     *         Otherwise, returns false.\n     */\n    function withinDeviationThreshold(uint256 rate)\n        private\n        view\n        returns (bool)\n    {\n        uint256 absoluteDeviationThreshold = targetRate.mul(deviationThreshold)\n            .div(10 ** 18);\n\n        return (rate >= targetRate && rate.sub(targetRate) < absoluteDeviationThreshold)\n            || (rate < targetRate && targetRate.sub(rate) < absoluteDeviationThreshold);\n    }\n}\n\n  library SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n \n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n \n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  \n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n  \n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n    uint256 c = add(a,m);\n    uint256 d = sub(c,1);\n    return mul(div(d,m),m);\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n  \n  function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0, \"Div by zero\");\n        uint256 r = x / y;\n        if (x % y != 0) {\n            r = r + 1;\n        }\n\n        return r;\n    }\n}"
    }
  }
}