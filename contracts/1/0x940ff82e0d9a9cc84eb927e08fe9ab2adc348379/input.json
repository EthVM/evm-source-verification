{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "UserInfo.sol": {
      "content": "/*\r\nB.PROTOCOL TERMS OF USE\r\n=======================\r\n\r\nTHE TERMS OF USE CONTAINED HEREIN (THESE “TERMS”) GOVERN YOUR USE OF B.PROTOCOL, WHICH IS A DECENTRALIZED PROTOCOL ON THE ETHEREUM BLOCKCHAIN (the “PROTOCOL”) THAT enables a backstop liquidity mechanism FOR DECENTRALIZED LENDING PLATFORMS (“DLPs”).  \r\nPLEASE READ THESE TERMS CAREFULLY AT https://github.com/backstop-protocol/Terms-and-Conditions, INCLUDING ALL DISCLAIMERS AND RISK FACTORS, BEFORE USING THE PROTOCOL. BY USING THE PROTOCOL, YOU ARE IRREVOCABLY CONSENTING TO BE BOUND BY THESE TERMS. \r\nIF YOU DO NOT AGREE TO ALL OF THESE TERMS, DO NOT USE THE PROTOCOL. YOUR RIGHT TO USE THE PROTOCOL IS SUBJECT AND DEPENDENT BY YOUR AGREEMENT TO ALL TERMS AND CONDITIONS SET FORTH HEREIN, WHICH AGREEMENT SHALL BE EVIDENCED BY YOUR USE OF THE PROTOCOL.\r\nMinors Prohibited: The Protocol is not directed to individuals under the age of eighteen (18) or the age of majority in your jurisdiction if the age of majority is greater. If you are under the age of eighteen or the age of majority (if greater), you are not authorized to access or use the Protocol. By using the Protocol, you represent and warrant that you are above such age.\r\n\r\nLicense; No Warranties; Limitation of Liability;\r\n(a) The software underlying the Protocol is licensed for use in accordance with the 3-clause BSD License, which can be accessed here: https://opensource.org/licenses/BSD-3-Clause.\r\n(b) THE PROTOCOL IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\", “WITH ALL FAULTS” and “AS AVAILABLE” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \r\n(c) IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \r\n*/\r\n\r\n\r\npragma solidity ^0.5.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract Math {\r\n    // --- Math ---\r\n    function add(uint x, int y) internal pure returns (uint z) {\r\n        z = x + uint(y);\r\n        require(y >= 0 || z <= x);\r\n        require(y <= 0 || z >= x);\r\n    }\r\n    function sub(uint x, int y) internal pure returns (uint z) {\r\n        z = x - uint(y);\r\n        require(y <= 0 || z <= x);\r\n        require(y >= 0 || z >= x);\r\n    }\r\n    function mul(uint x, int y) internal pure returns (int z) {\r\n        z = int(x) * y;\r\n        require(int(x) >= 0);\r\n        require(y == 0 || z / y == int(x));\r\n    }\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, RAY) / y;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, y) / RAY;\r\n    }\r\n    function rpow(uint x, uint n, uint b) internal pure returns (uint z) {\r\n      assembly {\r\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\r\n        default {\r\n          switch mod(n, 2) case 0 { z := b } default { z := x }\r\n          let half := div(b, 2)  // for rounding.\r\n          for { n := div(n, 2) } n { n := div(n,2) } {\r\n            let xx := mul(x, x)\r\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n            let xxRound := add(xx, half)\r\n            if lt(xxRound, xx) { revert(0,0) }\r\n            x := div(xxRound, b)\r\n            if mod(n,2) {\r\n              let zx := mul(z, x)\r\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n              let zxRound := add(zx, half)\r\n              if lt(zxRound, zx) { revert(0,0) }\r\n              z := div(zxRound, b)\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    function toInt(uint x) internal pure returns (int y) {\r\n        y = int(x);\r\n        require(y >= 0);\r\n    }\r\n}\r\n\r\n\r\ncontract LibNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  usr,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an 'anonymous' event with a constant 6 words of calldata\r\n            // and four indexed topics: selector, caller, arg1 and arg2\r\n            let mark := msize()                       // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 caller(),                            // msg.sender\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36)                     // arg2\r\n                )\r\n        }\r\n    }\r\n}\r\n\r\ncontract BCdpScoreLike {\r\n    function updateScore(uint cdp, bytes32 ilk, int dink, int dart, uint time) external;\r\n}\r\n\r\ncontract BCdpScoreConnector {\r\n    BCdpScoreLike public score;\r\n    mapping(uint => uint) public left;\r\n\r\n    constructor(BCdpScoreLike score_) public {\r\n        score = score_;\r\n    }\r\n\r\n    function setScore(BCdpScoreLike bcdpScore) internal {\r\n        score = bcdpScore;\r\n    }\r\n\r\n    function updateScore(uint cdp, bytes32 ilk, int dink, int dart, uint time) internal {\r\n        if(left[cdp] == 0) score.updateScore(cdp, ilk, dink, dart, time);\r\n    }\r\n\r\n    function quitScore(uint cdp) internal {\r\n        if(left[cdp] == 0) left[cdp] = now;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract UrnHandler {\r\n    constructor(address vat) public {\r\n        VatLike(vat).hope(msg.sender);\r\n    }\r\n}\r\n\r\ncontract DssCdpManager is LibNote {\r\n    address                   public vat;\r\n    uint                      public cdpi;      // Auto incremental\r\n    mapping (uint => address) public urns;      // CDPId => UrnHandler\r\n    mapping (uint => List)    public list;      // CDPId => Prev & Next CDPIds (double linked list)\r\n    mapping (uint => address) public owns;      // CDPId => Owner\r\n    mapping (uint => bytes32) public ilks;      // CDPId => Ilk\r\n\r\n    mapping (address => uint) public first;     // Owner => First CDPId\r\n    mapping (address => uint) public last;      // Owner => Last CDPId\r\n    mapping (address => uint) public count;     // Owner => Amount of CDPs\r\n\r\n    mapping (\r\n        address => mapping (\r\n            uint => mapping (\r\n                address => uint\r\n            )\r\n        )\r\n    ) public cdpCan;                            // Owner => CDPId => Allowed Addr => True/False\r\n\r\n    mapping (\r\n        address => mapping (\r\n            address => uint\r\n        )\r\n    ) public urnCan;                            // Urn => Allowed Addr => True/False\r\n\r\n    struct List {\r\n        uint prev;\r\n        uint next;\r\n    }\r\n\r\n    event NewCdp(address indexed usr, address indexed own, uint indexed cdp);\r\n\r\n    modifier cdpAllowed(\r\n        uint cdp\r\n    ) {\r\n        require(msg.sender == owns[cdp] || cdpCan[owns[cdp]][cdp][msg.sender] == 1, \"cdp-not-allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier urnAllowed(\r\n        address urn\r\n    ) {\r\n        require(msg.sender == urn || urnCan[urn][msg.sender] == 1, \"urn-not-allowed\");\r\n        _;\r\n    }\r\n\r\n    constructor(address vat_) public {\r\n        vat = vat_;\r\n    }\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    function toInt(uint x) internal pure returns (int y) {\r\n        y = int(x);\r\n        require(y >= 0);\r\n    }\r\n\r\n    // Allow/disallow a usr address to manage the cdp.\r\n    function cdpAllow(\r\n        uint cdp,\r\n        address usr,\r\n        uint ok\r\n    ) public cdpAllowed(cdp) {\r\n        cdpCan[owns[cdp]][cdp][usr] = ok;\r\n    }\r\n\r\n    // Allow/disallow a usr address to quit to the the sender urn.\r\n    function urnAllow(\r\n        address usr,\r\n        uint ok\r\n    ) public {\r\n        urnCan[msg.sender][usr] = ok;\r\n    }\r\n\r\n    // Open a new cdp for a given usr address.\r\n    function open(\r\n        bytes32 ilk,\r\n        address usr\r\n    ) public note returns (uint) {\r\n        require(usr != address(0), \"usr-address-0\");\r\n\r\n        cdpi = add(cdpi, 1);\r\n        urns[cdpi] = address(new UrnHandler(vat));\r\n        owns[cdpi] = usr;\r\n        ilks[cdpi] = ilk;\r\n\r\n        // Add new CDP to double linked list and pointers\r\n        if (first[usr] == 0) {\r\n            first[usr] = cdpi;\r\n        }\r\n        if (last[usr] != 0) {\r\n            list[cdpi].prev = last[usr];\r\n            list[last[usr]].next = cdpi;\r\n        }\r\n        last[usr] = cdpi;\r\n        count[usr] = add(count[usr], 1);\r\n\r\n        emit NewCdp(msg.sender, usr, cdpi);\r\n        return cdpi;\r\n    }\r\n\r\n    // Give the cdp ownership to a dst address.\r\n    function give(\r\n        uint cdp,\r\n        address dst\r\n    ) public note cdpAllowed(cdp) {\r\n        require(dst != address(0), \"dst-address-0\");\r\n        require(dst != owns[cdp], \"dst-already-owner\");\r\n\r\n        // Remove transferred CDP from double linked list of origin user and pointers\r\n        if (list[cdp].prev != 0) {\r\n            list[list[cdp].prev].next = list[cdp].next;         // Set the next pointer of the prev cdp (if exists) to the next of the transferred one\r\n        }\r\n        if (list[cdp].next != 0) {                              // If wasn't the last one\r\n            list[list[cdp].next].prev = list[cdp].prev;         // Set the prev pointer of the next cdp to the prev of the transferred one\r\n        } else {                                                // If was the last one\r\n            last[owns[cdp]] = list[cdp].prev;                   // Update last pointer of the owner\r\n        }\r\n        if (first[owns[cdp]] == cdp) {                          // If was the first one\r\n            first[owns[cdp]] = list[cdp].next;                  // Update first pointer of the owner\r\n        }\r\n        count[owns[cdp]] = sub(count[owns[cdp]], 1);\r\n\r\n        // Transfer ownership\r\n        owns[cdp] = dst;\r\n\r\n        // Add transferred CDP to double linked list of destiny user and pointers\r\n        list[cdp].prev = last[dst];\r\n        list[cdp].next = 0;\r\n        if (last[dst] != 0) {\r\n            list[last[dst]].next = cdp;\r\n        }\r\n        if (first[dst] == 0) {\r\n            first[dst] = cdp;\r\n        }\r\n        last[dst] = cdp;\r\n        count[dst] = add(count[dst], 1);\r\n    }\r\n\r\n    // Frob the cdp keeping the generated DAI or collateral freed in the cdp urn address.\r\n    function frob(\r\n        uint cdp,\r\n        int dink,\r\n        int dart\r\n    ) public note cdpAllowed(cdp) {\r\n        address urn = urns[cdp];\r\n        VatLike(vat).frob(\r\n            ilks[cdp],\r\n            urn,\r\n            urn,\r\n            urn,\r\n            dink,\r\n            dart\r\n        );\r\n    }\r\n\r\n    // Transfer wad amount of cdp collateral from the cdp address to a dst address.\r\n    function flux(\r\n        uint cdp,\r\n        address dst,\r\n        uint wad\r\n    ) public note cdpAllowed(cdp) {\r\n        VatLike(vat).flux(ilks[cdp], urns[cdp], dst, wad);\r\n    }\r\n\r\n    // Transfer wad amount of any type of collateral (ilk) from the cdp address to a dst address.\r\n    // This function has the purpose to take away collateral from the system that doesn't correspond to the cdp but was sent there wrongly.\r\n    function flux(\r\n        bytes32 ilk,\r\n        uint cdp,\r\n        address dst,\r\n        uint wad\r\n    ) public note cdpAllowed(cdp) {\r\n        VatLike(vat).flux(ilk, urns[cdp], dst, wad);\r\n    }\r\n\r\n    // Transfer wad amount of DAI from the cdp address to a dst address.\r\n    function move(\r\n        uint cdp,\r\n        address dst,\r\n        uint rad\r\n    ) public note cdpAllowed(cdp) {\r\n        VatLike(vat).move(urns[cdp], dst, rad);\r\n    }\r\n\r\n    // Quit the system, migrating the cdp (ink, art) to a different dst urn\r\n    function quit(\r\n        uint cdp,\r\n        address dst\r\n    ) public note cdpAllowed(cdp) urnAllowed(dst) {\r\n        (uint ink, uint art) = VatLike(vat).urns(ilks[cdp], urns[cdp]);\r\n        VatLike(vat).fork(\r\n            ilks[cdp],\r\n            urns[cdp],\r\n            dst,\r\n            toInt(ink),\r\n            toInt(art)\r\n        );\r\n    }\r\n\r\n    // Import a position from src urn to the urn owned by cdp\r\n    function enter(\r\n        address src,\r\n        uint cdp\r\n    ) public note urnAllowed(src) cdpAllowed(cdp) {\r\n        (uint ink, uint art) = VatLike(vat).urns(ilks[cdp], src);\r\n        VatLike(vat).fork(\r\n            ilks[cdp],\r\n            src,\r\n            urns[cdp],\r\n            toInt(ink),\r\n            toInt(art)\r\n        );\r\n    }\r\n\r\n    // Move a position from cdpSrc urn to the cdpDst urn\r\n    function shift(\r\n        uint cdpSrc,\r\n        uint cdpDst\r\n    ) public note cdpAllowed(cdpSrc) cdpAllowed(cdpDst) {\r\n        require(ilks[cdpSrc] == ilks[cdpDst], \"non-matching-cdps\");\r\n        (uint ink, uint art) = VatLike(vat).urns(ilks[cdpSrc], urns[cdpSrc]);\r\n        VatLike(vat).fork(\r\n            ilks[cdpSrc],\r\n            urns[cdpSrc],\r\n            urns[cdpDst],\r\n            toInt(ink),\r\n            toInt(art)\r\n        );\r\n    }\r\n}\r\n\r\n\r\ninterface DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) external view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract VatLike {\r\n    function urns(bytes32, address) public view returns (uint, uint);\r\n    function hope(address) external;\r\n    function flux(bytes32, address, address, uint) public;\r\n    function move(address, address, uint) public;\r\n    function frob(bytes32, address, address, address, int, int) public;\r\n    function fork(bytes32, address, address, int, int) public;\r\n    function ilks(bytes32 ilk) public view returns(uint Art, uint rate, uint spot, uint line, uint dust);\r\n    function gem(bytes32 ilk, address user) external view returns(uint);\r\n}\r\n\r\ncontract CatLike {\r\n    function ilks(bytes32) public returns(address flip, uint256 chop, uint256 lump);\r\n}\r\n\r\ncontract EndLike {\r\n    function cat() public view returns(CatLike);\r\n}\r\n\r\ncontract PriceFeedLike {\r\n    function read(bytes32 ilk) external view returns(bytes32);\r\n}\r\n\r\ncontract LiquidationMachine is DssCdpManager, BCdpScoreConnector, Math {\r\n    VatLike                   public vat;\r\n    EndLike                   public end;\r\n    address                   public pool;\r\n    PriceFeedLike             public real;\r\n\r\n    mapping(uint => uint)     public tic;  // time of bite\r\n    mapping(uint => uint)     public cushion; // how much was topped in art units\r\n\r\n    uint constant             public GRACE = 1 hours;\r\n    uint constant             public WAD = 1e18;\r\n\r\n    mapping (uint => bool)    public out;\r\n\r\n    modifier onlyPool {\r\n        require(msg.sender == pool, \"not-pool\");\r\n        _;\r\n    }\r\n\r\n    constructor(VatLike vat_, EndLike end_, address pool_, PriceFeedLike real_) public {\r\n        vat = vat_;\r\n        end = end_;\r\n        pool = pool_;\r\n        real = real_;\r\n    }\r\n\r\n    function setPool(address newPool) internal {\r\n        pool = newPool;\r\n    }\r\n\r\n    function quitBLiquidation(uint cdp) internal {\r\n        untop(cdp);\r\n        out[cdp] = true;\r\n    }\r\n\r\n    function topup(uint cdp, uint dtopup) external onlyPool {\r\n        if(out[cdp]) return;\r\n\r\n        address urn = urns[cdp];\r\n        bytes32 ilk = ilks[cdp];\r\n\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        uint dtab = mul(rate, dtopup);\r\n\r\n        vat.move(pool, address(this), dtab);\r\n        vat.frob(ilk, urn, urn, address(this), 0, -toInt(dtopup));\r\n\r\n        cushion[cdp] = add(cushion[cdp], dtopup);\r\n    }\r\n\r\n    function bitten(uint cdp) public view returns(bool) {\r\n        return tic[cdp] + GRACE > now;\r\n    }\r\n\r\n    function untop(uint cdp) internal {\r\n        require(! bitten(cdp), \"untop: cdp was already bitten\");\r\n\r\n        uint top = cushion[cdp];\r\n        if(top == 0) return; // nothing to do\r\n\r\n        bytes32 ilk = ilks[cdp];\r\n        address urn = urns[cdp];\r\n\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        uint dtab = mul(rate, top);\r\n\r\n        cushion[cdp] = 0;\r\n\r\n        // move topping to pool\r\n        vat.frob(ilk, urn, urn, urn, 0, toInt(top));\r\n        vat.move(urn, pool, dtab);\r\n    }\r\n\r\n    function untopByPool(uint cdp) external onlyPool {\r\n        untop(cdp);\r\n    }\r\n\r\n    function doBite(uint dart, bytes32 ilk, address urn, uint dink) internal {\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        uint dtab = mul(rate, dart);\r\n\r\n        vat.move(pool, address(this), dtab);\r\n\r\n        vat.frob(ilk, urn, urn, address(this), 0, -toInt(dart));\r\n        vat.frob(ilk, urn, msg.sender, urn, -toInt(dink), 0);\r\n    }\r\n\r\n    function calcDink(uint dart, uint rate, bytes32 ilk) internal returns(uint dink) {\r\n        (, uint chop,) = end.cat().ilks(ilk);\r\n        uint tab = mul(mul(dart, rate), chop) / WAD;\r\n        bytes32 realtimePrice = real.read(ilk);\r\n\r\n        dink = rmul(tab, WAD) / uint(realtimePrice);\r\n    }\r\n\r\n    function bite(uint cdp, uint dart) external onlyPool returns(uint dink){\r\n        address urn = urns[cdp];\r\n        bytes32 ilk = ilks[cdp];\r\n\r\n        (uint ink, uint art) = vat.urns(ilk, urn);\r\n        art = add(art, cushion[cdp]);\r\n        (, uint rate, uint spotValue,,) = vat.ilks(ilk);\r\n\r\n        require(dart <= art, \"debt is too low\");\r\n\r\n        // verify cdp is unsafe now\r\n        if(! bitten(cdp)) {\r\n            require(mul(art, rate) > mul(ink, spotValue), \"bite: cdp is safe\");\r\n            require(cushion[cdp] > 0, \"bite: not-topped\");\r\n            tic[cdp] = now;\r\n        }\r\n\r\n        dink = calcDink(dart, rate, ilk);\r\n        updateScore(cdp, ilk, -toInt(dink), -toInt(dart), now);\r\n\r\n        uint usedCushion = mul(cushion[cdp], dart) / art;\r\n        cushion[cdp] = sub(cushion[cdp], usedCushion);\r\n        uint bart = sub(dart, usedCushion);\r\n\r\n        doBite(bart, ilk, urn, dink);\r\n    }\r\n}\r\n\r\n\r\ncontract BCdpManager is BCdpScoreConnector, LiquidationMachine, DSAuth {\r\n    constructor(address vat_, address end_, address pool_, address real_, address score_) public\r\n        DssCdpManager(vat_)\r\n        LiquidationMachine(VatLike(vat_), EndLike(end_), pool_, PriceFeedLike(real_))\r\n        BCdpScoreConnector(BCdpScoreLike(score_))\r\n    {\r\n\r\n    }\r\n\r\n    // Frob the cdp keeping the generated DAI or collateral freed in the cdp urn address.\r\n    function frob(\r\n        uint cdp,\r\n        int dink,\r\n        int dart\r\n    ) public cdpAllowed(cdp) {\r\n        bytes32 ilk = ilks[cdp];\r\n\r\n        untop(cdp);\r\n        updateScore(cdp, ilk, dink, dart, now);\r\n\r\n        super.frob(cdp, dink, dart);\r\n    }\r\n\r\n    // Quit the system, migrating the cdp (ink, art) to a different dst urn\r\n    function quit(\r\n        uint cdp,\r\n        address dst\r\n    ) public cdpAllowed(cdp) urnAllowed(dst) {\r\n        address urn = urns[cdp];\r\n        bytes32 ilk = ilks[cdp];\r\n\r\n        untop(cdp);\r\n        (uint ink, uint art) = vat.urns(ilk, urn);\r\n        updateScore(cdp, ilk, -toInt(ink), -toInt(art), now);\r\n\r\n        super.quit(cdp, dst);\r\n    }\r\n\r\n    // Import a position from src urn to the urn owned by cdp\r\n    function enter(\r\n        address src,\r\n        uint cdp\r\n    ) public urnAllowed(src) cdpAllowed(cdp) {\r\n        bytes32 ilk = ilks[cdp];\r\n\r\n        untop(cdp);\r\n        (uint ink, uint art) = vat.urns(ilk, src);\r\n        updateScore(cdp, ilk, toInt(ink), toInt(art), now);\r\n\r\n        super.enter(src, cdp);\r\n    }\r\n\r\n    // Move a position from cdpSrc urn to the cdpDst urn\r\n    function shift(\r\n        uint cdpSrc,\r\n        uint cdpDst\r\n    ) public cdpAllowed(cdpSrc) cdpAllowed(cdpDst) {\r\n        bytes32 ilkSrc = ilks[cdpSrc];\r\n\r\n        untop(cdpSrc);\r\n        untop(cdpDst);\r\n\r\n        address src = urns[cdpSrc];\r\n\r\n        (uint inkSrc, uint artSrc) = vat.urns(ilkSrc, src);\r\n\r\n        updateScore(cdpSrc, ilkSrc, -toInt(inkSrc), -toInt(artSrc), now);\r\n        updateScore(cdpDst, ilkSrc, toInt(inkSrc), toInt(artSrc), now);\r\n\r\n        super.shift(cdpSrc, cdpDst);\r\n    }\r\n\r\n    ///////////////// B specific control functions /////////////////////////////\r\n\r\n    function quitB(uint cdp) external cdpAllowed(cdp) note {\r\n        quitScore(cdp);\r\n        quitBLiquidation(cdp);\r\n    }\r\n\r\n    function setScoreContract(BCdpScoreLike _score) external auth {\r\n        super.setScore(_score);\r\n    }\r\n\r\n    function setPoolContract(address _pool) external auth {\r\n        super.setPool(_pool);\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ScoringMachine is Ownable {\r\n    struct AssetScore {\r\n        // total score so far\r\n        uint score;\r\n\r\n        // current balance\r\n        uint balance;\r\n\r\n        // time when last update was\r\n        uint last;\r\n    }\r\n\r\n    // user is bytes32 (will be the sha3 of address or cdp number)\r\n    mapping(bytes32 => mapping(bytes32 => AssetScore[])) public checkpoints;\r\n\r\n    mapping(bytes32 => mapping(bytes32 => AssetScore)) public userScore;\r\n\r\n    bytes32 constant public GLOBAL_USER = bytes32(0x0);\r\n\r\n    uint public start; // start time of the campaign;\r\n\r\n    function spin() external onlyOwner { // start a new round\r\n        start = now;\r\n    }\r\n\r\n    function assetScore(AssetScore storage score, uint time, uint spinStart) internal view returns(uint) {\r\n        uint last = score.last;\r\n        uint currentScore = score.score;\r\n        if(last < spinStart) {\r\n            last = spinStart;\r\n            currentScore = 0;\r\n        }\r\n\r\n        return add(currentScore, mul(score.balance, sub(time, last)));\r\n    }\r\n\r\n    function addCheckpoint(bytes32 user, bytes32 asset) internal {\r\n        checkpoints[user][asset].push(userScore[user][asset]);\r\n    }\r\n\r\n    function updateAssetScore(bytes32 user, bytes32 asset, int dbalance, uint time) internal {\r\n        AssetScore storage score = userScore[user][asset];\r\n\r\n        if(score.last < start) addCheckpoint(user, asset);\r\n\r\n        score.score = assetScore(score, time, start);\r\n        score.balance = add(score.balance, dbalance);\r\n        \r\n        score.last = time;\r\n    }\r\n\r\n    function updateScore(bytes32 user, bytes32 asset, int dbalance, uint time) internal {\r\n        updateAssetScore(user, asset, dbalance, time);\r\n        updateAssetScore(GLOBAL_USER, asset, dbalance, time);\r\n    }\r\n\r\n    function getScore(bytes32 user, bytes32 asset, uint time, uint spinStart, uint checkPointHint) public view returns(uint score) {\r\n        if(time >= userScore[user][asset].last) return assetScore(userScore[user][asset], time, spinStart);\r\n\r\n        // else - check the checkpoints\r\n        uint checkpointsLen = checkpoints[user][asset].length;\r\n        if(checkpointsLen == 0) return 0;\r\n\r\n        // hint is invalid\r\n        if(checkpoints[user][asset][checkPointHint].last < time) checkPointHint = checkpointsLen - 1;\r\n\r\n        for(uint i = checkPointHint ; ; i--){\r\n            if(checkpoints[user][asset][i].last <= time) return assetScore(checkpoints[user][asset][i], time, spinStart);\r\n        }\r\n\r\n        // this supposed to be unreachable\r\n        return 0;\r\n    }\r\n\r\n    function getCurrentBalance(bytes32 user, bytes32 asset) public view returns(uint balance) {\r\n        balance = userScore[user][asset].balance;\r\n    }\r\n\r\n    // Math functions without errors\r\n    // ==============================\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        z = x + y;\r\n        if(!(z >= x)) return 0;\r\n\r\n        return z;\r\n    }\r\n\r\n    function add(uint x, int y) internal pure returns (uint z) {\r\n        z = x + uint(y);\r\n        if(!(y >= 0 || z <= x)) return 0;\r\n        if(!(y <= 0 || z >= x)) return 0;\r\n\r\n        return z;\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        if(!(y <= x)) return 0;\r\n        z = x - y;\r\n\r\n        return z;\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        if (x == 0) return 0;\r\n\r\n        z = x * y;\r\n        if(!(z / x == y)) return 0;\r\n\r\n        return z;\r\n    }\r\n}\r\n\r\n\r\ncontract BCdpScore is ScoringMachine {\r\n    BCdpManager public manager;\r\n\r\n    modifier onlyManager {\r\n        require(msg.sender == address(manager), \"not-manager\");\r\n        _;\r\n    }\r\n\r\n    function setManager(address newManager) external onlyOwner {\r\n        manager = BCdpManager(newManager);\r\n    }\r\n\r\n    function user(uint cdp) public pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(\"BCdpScore\", cdp));\r\n    }\r\n\r\n    function artAsset(bytes32 ilk) public pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(\"BCdpScore\", \"art\", ilk));\r\n    }\r\n\r\n    function updateScore(uint cdp, bytes32 ilk, int dink, int dart, uint time) external onlyManager {\r\n        dink; // shh compiler warning\r\n        updateScore(user(cdp), artAsset(ilk), dart, time);\r\n    }\r\n\r\n    function slashScore(uint maliciousCdp) external {\r\n        address urn = manager.urns(maliciousCdp);\r\n        bytes32 ilk = manager.ilks(maliciousCdp);\r\n\r\n        (, uint realArt) = manager.vat().urns(ilk, urn);\r\n\r\n        bytes32 maliciousUser = user(maliciousCdp);\r\n        bytes32 asset = artAsset(ilk);\r\n\r\n        uint left = BCdpScoreConnector(address(manager)).left(maliciousCdp);\r\n\r\n        realArt = left > 0 ? 0 : realArt;\r\n        uint startTime = left > 0 ? left : now;\r\n\r\n        uint calculatedArt = getCurrentBalance(maliciousUser, asset);\r\n        require(realArt < calculatedArt, \"slashScore-cdp-is-ok\");\r\n        int dart = int(realArt) - int(calculatedArt);\r\n        uint time = sub(startTime, 30 days);\r\n        if(time < start) time = start;\r\n        \r\n        updateScore(maliciousUser, asset, dart, time);\r\n    }\r\n\r\n    function getArtScore(uint cdp, bytes32 ilk, uint time, uint spinStart) public view returns(uint) {\r\n        return getScore(user(cdp), artAsset(ilk), time, spinStart, 0);\r\n    }\r\n\r\n    function getArtGlobalScore(bytes32 ilk, uint time, uint spinStart) public view returns(uint) {\r\n        return getScore(GLOBAL_USER, artAsset(ilk), time, spinStart, 0);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract JarConnector is Math {\r\n    BCdpScore   public score;\r\n    BCdpManager public man;\r\n    bytes32[]   public ilks;\r\n    // ilk => supported\r\n    mapping(bytes32 => bool) public milks;\r\n\r\n    // end of every round\r\n    uint[2] public end;\r\n    // start time of every round\r\n    uint[2] public start;\r\n\r\n    uint public round;\r\n\r\n    constructor(\r\n        bytes32[] memory _ilks,\r\n        uint[2] memory _duration\r\n    ) public {\r\n        ilks = _ilks;\r\n\r\n        for(uint i = 0; i < _ilks.length; i++) {\r\n            milks[_ilks[i]] = true;\r\n        }\r\n\r\n        end[0] = now + _duration[0];\r\n        end[1] = now + _duration[0] + _duration[1];\r\n\r\n        round = 0;\r\n    }\r\n\r\n    function setManager(address _manager) public {\r\n        require(man == BCdpManager(0), \"manager-already-set\");\r\n        man = BCdpManager(_manager);\r\n        score = BCdpScore(address(man.score()));\r\n    }\r\n\r\n    // callable by anyone\r\n    function spin() public {\r\n        if(round == 0) {\r\n            round++;\r\n            score.spin();\r\n            start[0] = score.start();\r\n        }\r\n        if(round == 1 && now > end[0]) {\r\n            round++;\r\n            score.spin();\r\n            start[1] = score.start();\r\n        }\r\n        if(round == 2 && now > end[1]) {\r\n            round++;        \r\n            // score is not counted anymore, and this must be followed by contract upgrade\r\n            score.spin();\r\n        }\r\n    }\r\n\r\n    function getUserScore(bytes32 user) external view returns (uint) {\r\n        if(round == 0) return 0;\r\n\r\n        uint cdp = uint(user);\r\n        bytes32 ilk = man.ilks(cdp);\r\n\r\n        // Should return 0 score for unsupported ilk\r\n        if( ! milks[ilk]) return 0;\r\n\r\n        if(round == 1) return 2 * score.getArtScore(cdp, ilk, now, start[0]);\r\n\r\n        uint firstRoundScore = 2 * score.getArtScore(cdp, ilk, start[1], start[0]);\r\n        uint time = now;\r\n        if(round > 2) time = end[1];\r\n\r\n        return add(score.getArtScore(cdp, ilk, time, start[1]), firstRoundScore);\r\n    }\r\n\r\n    function getGlobalScore() external view returns (uint) {\r\n        if(round == 0) return 0;\r\n\r\n        if(round == 1) return 2 * getArtGlobalScore(now, start[0]);\r\n\r\n        uint firstRoundScore = 2 * getArtGlobalScore(start[1], start[0]);\r\n        uint time = now;\r\n        if(round > 2) time = end[1];\r\n\r\n        return add(getArtGlobalScore(time, start[1]), firstRoundScore);\r\n    }\r\n\r\n    function getGlobalScore(bytes32 ilk) external view returns (uint) {\r\n        if(round == 0) return 0;\r\n\r\n        if(round == 1) return 2 * score.getArtGlobalScore(ilk, now, start[0]);\r\n\r\n        uint firstRoundScore = 2 * score.getArtGlobalScore(ilk, start[1], start[0]);\r\n        uint time = now;\r\n        if(round > 2) time = end[1];\r\n\r\n        return add(score.getArtGlobalScore(ilk, time, start[1]), firstRoundScore);\r\n    }\r\n\r\n    function getArtGlobalScore(uint time, uint spinStart) internal view returns (uint totalScore) {\r\n        for(uint i = 0; i < ilks.length; i++) {\r\n            totalScore = add(totalScore, score.getArtGlobalScore(ilks[i], time, spinStart));\r\n        }\r\n    }\r\n\r\n    function toUser(bytes32 user) external view returns (address) {\r\n        return man.owns(uint(user));\r\n    }\r\n}\r\n\r\ncontract DSProxyLike {\r\n    function owner() public view returns(address);\r\n}\r\n\r\ncontract ProxyRegistryLike {\r\n    function proxies(address u) public view returns(DSProxyLike);\r\n}\r\n\r\ncontract SpotLike {\r\n    function par() external view returns (uint256);\r\n    function ilks(bytes32 ilk) external view returns (address pip, uint mat);\r\n}\r\n\r\ncontract ERC20Like {\r\n    function balanceOf(address guy) public view returns(uint);\r\n    function allowance(address owner, address spender) public view returns (uint);\r\n}\r\n\r\ncontract JarConnectorLike {\r\n    function getUserScore(bytes32 user) external view returns (uint);\r\n    function getGlobalScore() external view returns (uint);\r\n}\r\n\r\ncontract JarLike {\r\n    function connector() external view returns (address);\r\n}\r\n\r\n// this is just something to help avoiding solidity quirks\r\ncontract UserInfoStorage {\r\n    struct ProxyInfo {\r\n        bool hasProxy;\r\n        DSProxyLike userProxy;\r\n    }\r\n\r\n    struct CdpInfo {\r\n        bool hasCdp;\r\n        bool bitten;\r\n        uint cdp;\r\n        uint ethDeposit;\r\n        uint daiDebt; // in wad - not in rad\r\n        uint maxDaiDebt;\r\n        uint unlockedEth;\r\n        bool expectedDebtMissmatch;\r\n    }\r\n\r\n    struct UserRatingInfo {\r\n        uint userRating;\r\n        uint userRatingProgressPerSec;\r\n        uint totalRating;\r\n        uint totalRatingProgressPerSec;\r\n        uint jarBalance;\r\n    }\r\n\r\n    struct MiscInfo {\r\n        uint spotPrice;\r\n        uint dustInWei;\r\n        uint blockNumber;\r\n    }\r\n\r\n    struct UserWalletInfo {\r\n        uint ethBalance;\r\n        uint daiBalance;\r\n        uint daiAllowance;\r\n    }\r\n\r\n    struct UserState {\r\n        ProxyInfo proxyInfo;\r\n        CdpInfo bCdpInfo;\r\n        CdpInfo makerdaoCdpInfo;\r\n        UserRatingInfo userRatingInfo;\r\n        MiscInfo miscInfo;\r\n        UserWalletInfo userWalletInfo;\r\n    }\r\n\r\n    UserState userState;\r\n\r\n    bool public hasProxy;\r\n    address public userProxy;\r\n\r\n    // CdpInfo of B\r\n    bool public hasCdp;\r\n    bool public bitten;\r\n    uint public cdp;\r\n    uint public ethDeposit;\r\n    uint public daiDebt; // in wad - not in rad\r\n    uint public maxDaiDebt;\r\n    uint public unlockedEth;\r\n    bool public expectedDebtMissmatch;\r\n\r\n    // CdpInfo of Mkr\r\n    bool public makerdaoHasCdp;\r\n    uint public makerdaoCdp;\r\n    uint public makerdaoEthDeposit;\r\n    uint public makerdaoDaiDebt; // in wad - not in rad\r\n    uint public makerdaoMaxDaiDebt;\r\n\r\n    uint public userRating;\r\n    uint public userRatingProgressPerSec;\r\n    uint public totalRating;\r\n    uint public totalRatingProgressPerSec;\r\n    uint public jarBalance;\r\n\r\n    uint public spotPrice;\r\n    uint public dustInWei;\r\n    uint public blockNumber;\r\n\r\n    uint public ethBalance;\r\n    uint public daiBalance;\r\n    uint public daiAllowance;\r\n\r\n    function set(UserState memory state) public {\r\n        hasProxy = state.proxyInfo.hasProxy;\r\n        userProxy = address(state.proxyInfo.userProxy);\r\n\r\n        hasCdp = state.bCdpInfo.hasCdp;\r\n        bitten = state.bCdpInfo.bitten;\r\n        cdp = state.bCdpInfo.cdp;\r\n        ethDeposit = state.bCdpInfo.ethDeposit;\r\n        daiDebt = state.bCdpInfo.daiDebt;\r\n        maxDaiDebt = state.bCdpInfo.maxDaiDebt;\r\n        unlockedEth = state.bCdpInfo.unlockedEth;\r\n        expectedDebtMissmatch = state.bCdpInfo.expectedDebtMissmatch;\r\n\r\n        makerdaoHasCdp = state.makerdaoCdpInfo.hasCdp;\r\n        makerdaoCdp = state.makerdaoCdpInfo.cdp;\r\n        makerdaoEthDeposit = state.makerdaoCdpInfo.ethDeposit;\r\n        makerdaoDaiDebt = state.makerdaoCdpInfo.daiDebt;\r\n        makerdaoMaxDaiDebt = state.makerdaoCdpInfo.maxDaiDebt;\r\n\r\n        spotPrice = state.miscInfo.spotPrice;\r\n        dustInWei = state.miscInfo.dustInWei;\r\n        blockNumber = state.miscInfo.blockNumber;\r\n\r\n        ethBalance = state.userWalletInfo.ethBalance;\r\n        daiBalance = state.userWalletInfo.daiBalance;\r\n        daiAllowance = state.userWalletInfo.daiAllowance;\r\n\r\n        userRating = state.userRatingInfo.userRating;\r\n        userRatingProgressPerSec = state.userRatingInfo.userRatingProgressPerSec;\r\n        totalRating = state.userRatingInfo.totalRating;\r\n        totalRatingProgressPerSec = state.userRatingInfo.totalRatingProgressPerSec;\r\n        jarBalance = state.userRatingInfo.jarBalance;\r\n\r\n        userState = state;\r\n    }\r\n}\r\n\r\ncontract UserInfo is Math, UserInfoStorage {\r\n\r\n\r\n    uint constant ONE = 1e27;\r\n    address public dai;\r\n    address public weth;\r\n\r\n    constructor(\r\n        address dai_,\r\n        address weth_\r\n    ) public {\r\n        dai = dai_;\r\n        weth = weth_;\r\n    }\r\n\r\n    function getFirstCdp(GetCdps getCdp, address manager, address guy, bytes32 ilk) internal view returns(uint) {\r\n        (uint[] memory ids,, bytes32[] memory ilks) = getCdp.getCdpsAsc(manager, guy);\r\n\r\n        for(uint i = 0 ; i < ilks.length ; i++) {\r\n            if(ilks[i] == ilk) return ids[i];\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function artToDaiDebt(VatLike vat, bytes32 ilk, uint art) internal view returns(uint) {\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        return mul(rate, art) / ONE;\r\n    }\r\n\r\n    function calcMaxDebt(VatLike vat, bytes32 ilk, uint ink) internal view returns(uint) {\r\n        (, uint rate, uint spot,,) = vat.ilks(ilk);\r\n        // mul(art, rate) = mul(ink, spot)\r\n\r\n        uint maxArt = mul(ink, spot)/rate;\r\n        return artToDaiDebt(vat, ilk, maxArt);\r\n    }\r\n\r\n    function calcSpotPrice(VatLike vat, SpotLike spot, bytes32 ilk) internal view returns(uint) {\r\n        (,, uint spotVal,,) = vat.ilks(ilk);\r\n        (, uint mat) = spot.ilks(ilk);\r\n        uint par = spot.par();\r\n\r\n        // spotVal = rdiv(rdiv(mul(uint(peep), uint(10 ** 9)), par), mat);\r\n        uint peep = rmul(rmul(spotVal, mat), par) / uint(1e9);\r\n\r\n        return peep;\r\n    }\r\n\r\n    function getProxyInfo(ProxyRegistryLike registry, address user) public view returns(ProxyInfo memory info) {\r\n        if(registry.proxies(user) == DSProxyLike(0x0) || registry.proxies(user).owner() != user) return info;\r\n\r\n        info.hasProxy = true;\r\n        info.userProxy = registry.proxies(user);\r\n    }\r\n\r\n    function getCdpInfo(\r\n        address guy,\r\n        address manager,\r\n        bytes32 ilk,\r\n        VatLike vat,\r\n        GetCdps getCdp,\r\n        bool b\r\n    ) public view returns(CdpInfo memory info) {\r\n        if(b) {\r\n            // B.Protocol\r\n            info.cdp = getFirstCdp(getCdp, manager, guy, ilk);\r\n            info.hasCdp = info.cdp > 0;\r\n            if(info.hasCdp) {\r\n                (uint ink, uint art) = vat.urns(ilk, DssCdpManager(manager).urns(info.cdp));\r\n                art = add(art, LiquidationMachine(manager).cushion(info.cdp));\r\n                info.bitten = LiquidationMachine(manager).bitten(info.cdp);\r\n                info.ethDeposit = ink;\r\n                info.daiDebt = artToDaiDebt(vat, ilk, art);\r\n                info.maxDaiDebt = calcMaxDebt(vat, ilk, ink);\r\n\r\n                info.unlockedEth = vat.gem(ilk, DssCdpManager(manager).urns(info.cdp));\r\n                bytes32 assetArtId = BCdpScore(address(BCdpManager(manager).score())).artAsset(ilk);\r\n                bytes32 userId = BCdpScore(address(BCdpManager(manager).score())).user(info.cdp);\r\n                uint artBalance = BCdpScore(address(BCdpManager(manager).score())).getCurrentBalance(userId, assetArtId);\r\n                info.expectedDebtMissmatch = (artBalance != art);\r\n            }\r\n        } else {\r\n            // MakerDAO\r\n            info.cdp = findFirstNonZeroInkCdp(manager, guy, ilk, vat, getCdp);\r\n            info.hasCdp = info.cdp > 0;\r\n            if(info.hasCdp) {\r\n                (uint ink, uint art) = vat.urns(ilk, DssCdpManager(manager).urns(info.cdp));\r\n                info.ethDeposit = ink;\r\n                info.daiDebt = artToDaiDebt(vat, ilk, art);\r\n                info.maxDaiDebt = calcMaxDebt(vat, ilk, ink);\r\n            }\r\n        }\r\n    }\r\n\r\n    function findFirstNonZeroInkCdp(\r\n        address manager,\r\n        address guy,\r\n        bytes32 ilk,\r\n        VatLike vat,\r\n        GetCdps getCdp\r\n    ) public view returns (uint) {\r\n        (uint[] memory ids,, bytes32[] memory ilks) = getCdp.getCdpsAsc(manager, guy);\r\n        for(uint i = 0 ; i < ilks.length ; i++) {\r\n            if(ilks[i] == ilk) {\r\n                (uint ink,) = vat.urns(ilk, DssCdpManager(manager).urns(ids[i]));\r\n                if(ink > 0) return ids[i];\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getUserRatingInfo(\r\n        bytes32 ilk,\r\n        address urn,\r\n        VatLike vat,\r\n        uint cdp,\r\n        address jar\r\n    ) public view returns(UserRatingInfo memory info) {\r\n        JarConnectorLike jarConnector = JarConnectorLike(address(JarLike(jar).connector()));\r\n        info.userRating = jarConnector.getUserScore(bytes32(cdp));\r\n        (, info.userRatingProgressPerSec) = vat.urns(ilk, urn);\r\n        info.totalRating = jarConnector.getGlobalScore();\r\n        info.totalRatingProgressPerSec = 13e18; // TODO\r\n        uint wethBalance = ERC20Like(weth).balanceOf(jar);\r\n        info.jarBalance = add(wethBalance, vat.gem(ilk, jar));\r\n    }\r\n\r\n    function setInfo(\r\n        address user,\r\n        bytes32 ilk,\r\n        BCdpManager manager,\r\n        DssCdpManager makerDAOManager,\r\n        GetCdps getCdp,\r\n        VatLike vat,\r\n        SpotLike spot,\r\n        ProxyRegistryLike registry,\r\n        address jar\r\n    ) public {\r\n        UserState memory state;\r\n\r\n        // fill proxy info\r\n        state.proxyInfo = getProxyInfo(registry, user);\r\n\r\n        address guy = address(state.proxyInfo.userProxy);\r\n\r\n        // fill bprotocol info\r\n        state.bCdpInfo = getCdpInfo(guy, address(manager), ilk, vat, getCdp, true);\r\n\r\n        // fill makerdao info\r\n        state.makerdaoCdpInfo = getCdpInfo(guy, address(makerDAOManager), ilk, vat, getCdp, false);\r\n\r\n        state.miscInfo.spotPrice = calcSpotPrice(vat, spot, ilk);\r\n        (,,,, uint dust) = vat.ilks(ilk);\r\n        state.miscInfo.dustInWei = dust / ONE;\r\n        state.miscInfo.blockNumber = block.number;\r\n\r\n        state.userWalletInfo.ethBalance = user.balance;\r\n        state.userWalletInfo.daiBalance = ERC20Like(dai).balanceOf(user);\r\n        state.userWalletInfo.daiAllowance = ERC20Like(dai).allowance(user, guy);\r\n\r\n        uint cdp = state.bCdpInfo.cdp;\r\n        address urn = manager.urns(cdp);\r\n\r\n        state.userRatingInfo = getUserRatingInfo(ilk, urn, vat, cdp, jar);\r\n\r\n        set(state);\r\n    }\r\n\r\n    function getInfo(\r\n        address user,\r\n        bytes32 ilk,\r\n        BCdpManager manager,\r\n        DssCdpManager makerDAOManager,\r\n        GetCdps getCdp,\r\n        VatLike vat,\r\n        SpotLike spot,\r\n        ProxyRegistryLike registry,\r\n        address jar\r\n    ) public returns(UserState memory state) {\r\n        setInfo(user, ilk, manager, makerDAOManager, getCdp, vat, spot, registry, jar);\r\n        return userState;\r\n    }\r\n}\r\n\r\ncontract GetCdps {\r\n    function getCdpsAsc(address manager, address guy) external view returns (uint[] memory ids, address[] memory urns, bytes32[] memory ilks) {\r\n        uint count = DssCdpManager(manager).count(guy);\r\n        ids = new uint[](count);\r\n        urns = new address[](count);\r\n        ilks = new bytes32[](count);\r\n        uint i = 0;\r\n        uint id = DssCdpManager(manager).first(guy);\r\n\r\n        while (id > 0) {\r\n            ids[i] = id;\r\n            urns[i] = DssCdpManager(manager).urns(id);\r\n            ilks[i] = DssCdpManager(manager).ilks(id);\r\n            (, id) = DssCdpManager(manager).list(id);\r\n            i++;\r\n        }\r\n    }\r\n\r\n    function getCdpsDesc(address manager, address guy) external view returns (uint[] memory ids, address[] memory urns, bytes32[] memory ilks) {\r\n        uint count = DssCdpManager(manager).count(guy);\r\n        ids = new uint[](count);\r\n        urns = new address[](count);\r\n        ilks = new bytes32[](count);\r\n        uint i = 0;\r\n        uint id = DssCdpManager(manager).last(guy);\r\n\r\n        while (id > 0) {\r\n            ids[i] = id;\r\n            urns[i] = DssCdpManager(manager).urns(id);\r\n            ilks[i] = DssCdpManager(manager).ilks(id);\r\n            (id,) = DssCdpManager(manager).list(id);\r\n            i++;\r\n        }\r\n    }\r\n}"
    }
  }
}