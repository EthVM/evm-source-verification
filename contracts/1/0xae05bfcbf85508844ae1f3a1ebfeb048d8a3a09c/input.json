{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "CAFE.sol": {
      "content": "// File: @fairmint/c-org-contracts/contracts/interfaces/IWhitelist.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * Source: https://raw.githubusercontent.com/simple-restricted-token/reference-implementation/master/contracts/token/ERC1404/ERC1404.sol\r\n * With ERC-20 APIs removed (will be implemented as a separate contract).\r\n * And adding authorizeTransfer.\r\n */\r\ninterface IWhitelist {\r\n  /**\r\n   * @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\r\n   * @param from Sending address\r\n   * @param to Receiving address\r\n   * @param value Amount of tokens being transferred\r\n   * @return Code by which to reference message for rejection reasoning\r\n   * @dev Overwrite with your custom transfer restriction logic\r\n   */\r\n  function detectTransferRestriction(\r\n    address from,\r\n    address to,\r\n    uint value\r\n  ) external view returns (uint8);\r\n\r\n  /**\r\n   * @notice Returns a human-readable message for a given restriction code\r\n   * @param restrictionCode Identifier for looking up a message\r\n   * @return Text showing the restriction's reasoning\r\n   * @dev Overwrite with your custom message and restrictionCode handling\r\n   */\r\n  function messageForTransferRestriction(uint8 restrictionCode)\r\n    external\r\n    pure\r\n    returns (string memory);\r\n\r\n  /**\r\n   * @notice Called by the DAT contract before a transfer occurs.\r\n   * @dev This call will revert when the transfer is not authorized.\r\n   * This is a mutable call to allow additional data to be recorded,\r\n   * such as when the user aquired their tokens.\r\n   */\r\n  function authorizeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint _value,\r\n    bool _isSell\r\n  ) external;\r\n\r\n  function walletActivated(\r\n    address _wallet\r\n  ) external returns(bool);\r\n}\r\n\r\n// File: @fairmint/c-org-contracts/contracts/interfaces/IERC20Detailed.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IERC20Detailed {\r\n  /**\r\n   * @dev Returns the number of decimals used to get its user representation.\r\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n   *\r\n   * Tokens usually opt for a value of 18, imitating the relationship between\r\n   * Ether and Wei.\r\n   *\r\n   * NOTE: This information is only used for _display_ purposes: it in\r\n   * no way affects any of the arithmetic of the contract, including\r\n   * {IERC20-balanceOf} and {IERC20-transfer}.\r\n   */\r\n  function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @fairmint/c-org-contracts/contracts/math/BigDiv.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title Reduces the size of terms before multiplication, to avoid an overflow, and then\r\n * restores the proper size after division.\r\n * @notice This effectively allows us to overflow values in the numerator and/or denominator\r\n * of a fraction, so long as the end result does not overflow as well.\r\n * @dev Results may be off by 1 + 0.000001% for 2x1 calls and 2 + 0.00001% for 2x2 calls.\r\n * Do not use if your contract expects very small result values to be accurate.\r\n */\r\nlibrary BigDiv {\r\n  using SafeMath for uint;\r\n\r\n  /// @notice The max possible value\r\n  uint private constant MAX_UINT = 2**256 - 1;\r\n\r\n  /// @notice When multiplying 2 terms <= this value the result won't overflow\r\n  uint private constant MAX_BEFORE_SQUARE = 2**128 - 1;\r\n\r\n  /// @notice The max error target is off by 1 plus up to 0.000001% error\r\n  /// for bigDiv2x1 and that `* 2` for bigDiv2x2\r\n  uint private constant MAX_ERROR = 100000000;\r\n\r\n  /// @notice A larger error threshold to use when multiple rounding errors may apply\r\n  uint private constant MAX_ERROR_BEFORE_DIV = MAX_ERROR * 2;\r\n\r\n  /**\r\n   * @notice Returns the approx result of `a * b / d` so long as the result is <= MAX_UINT\r\n   * @param _numA the first numerator term\r\n   * @param _numB the second numerator term\r\n   * @param _den the denominator\r\n   * @return the approx result with up to off by 1 + MAX_ERROR, rounding down if needed\r\n   */\r\n  function bigDiv2x1(\r\n    uint _numA,\r\n    uint _numB,\r\n    uint _den\r\n  ) internal pure returns (uint) {\r\n    if (_numA == 0 || _numB == 0) {\r\n      // would div by 0 or underflow if we don't special case 0\r\n      return 0;\r\n    }\r\n\r\n    uint value;\r\n\r\n    if (MAX_UINT / _numA >= _numB) {\r\n      // a*b does not overflow, return exact math\r\n      value = _numA * _numB;\r\n      value /= _den;\r\n      return value;\r\n    }\r\n\r\n    // Sort numerators\r\n    uint numMax = _numB;\r\n    uint numMin = _numA;\r\n    if (_numA > _numB) {\r\n      numMax = _numA;\r\n      numMin = _numB;\r\n    }\r\n\r\n    value = numMax / _den;\r\n    if (value > MAX_ERROR) {\r\n      // _den is small enough to be MAX_ERROR or better w/o a factor\r\n      value = value.mul(numMin);\r\n      return value;\r\n    }\r\n\r\n    // formula = ((a / f) * b) / (d / f)\r\n    // factor >= a / sqrt(MAX) * (b / sqrt(MAX))\r\n    uint factor = numMin - 1;\r\n    factor /= MAX_BEFORE_SQUARE;\r\n    factor += 1;\r\n    uint temp = numMax - 1;\r\n    temp /= MAX_BEFORE_SQUARE;\r\n    temp += 1;\r\n    if (MAX_UINT / factor >= temp) {\r\n      factor *= temp;\r\n      value = numMax / factor;\r\n      if (value > MAX_ERROR_BEFORE_DIV) {\r\n        value = value.mul(numMin);\r\n        temp = _den - 1;\r\n        temp /= factor;\r\n        temp = temp.add(1);\r\n        value /= temp;\r\n        return value;\r\n      }\r\n    }\r\n\r\n    // formula: (a / (d / f)) * (b / f)\r\n    // factor: b / sqrt(MAX)\r\n    factor = numMin - 1;\r\n    factor /= MAX_BEFORE_SQUARE;\r\n    factor += 1;\r\n    value = numMin / factor;\r\n    temp = _den - 1;\r\n    temp /= factor;\r\n    temp += 1;\r\n    temp = numMax / temp;\r\n    value = value.mul(temp);\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the approx result of `a * b / d` so long as the result is <= MAX_UINT\r\n   * @param _numA the first numerator term\r\n   * @param _numB the second numerator term\r\n   * @param _den the denominator\r\n   * @return the approx result with up to off by 1 + MAX_ERROR, rounding down if needed\r\n   * @dev roundUp is implemented by first rounding down and then adding the max error to the result\r\n   */\r\n  function bigDiv2x1RoundUp(\r\n    uint _numA,\r\n    uint _numB,\r\n    uint _den\r\n  ) internal pure returns (uint) {\r\n    // first get the rounded down result\r\n    uint value = bigDiv2x1(_numA, _numB, _den);\r\n\r\n    if (value == 0) {\r\n      // when the value rounds down to 0, assume up to an off by 1 error\r\n      return 1;\r\n    }\r\n\r\n    // round down has a max error of MAX_ERROR, add that to the result\r\n    // for a round up error of <= MAX_ERROR\r\n    uint temp = value - 1;\r\n    temp /= MAX_ERROR;\r\n    temp += 1;\r\n    if (MAX_UINT - value < temp) {\r\n      // value + error would overflow, return MAX\r\n      return MAX_UINT;\r\n    }\r\n\r\n    value += temp;\r\n\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the approx result of `a * b / (c * d)` so long as the result is <= MAX_UINT\r\n   * @param _numA the first numerator term\r\n   * @param _numB the second numerator term\r\n   * @param _denA the first denominator term\r\n   * @param _denB the second denominator term\r\n   * @return the approx result with up to off by 2 + MAX_ERROR*10 error, rounding down if needed\r\n   * @dev this uses bigDiv2x1 and adds additional rounding error so the max error of this\r\n   * formula is larger\r\n   */\r\n  function bigDiv2x2(\r\n    uint _numA,\r\n    uint _numB,\r\n    uint _denA,\r\n    uint _denB\r\n  ) internal pure returns (uint) {\r\n    if (MAX_UINT / _denA >= _denB) {\r\n      // denA*denB does not overflow, use bigDiv2x1 instead\r\n      return bigDiv2x1(_numA, _numB, _denA * _denB);\r\n    }\r\n\r\n    if (_numA == 0 || _numB == 0) {\r\n      // would div by 0 or underflow if we don't special case 0\r\n      return 0;\r\n    }\r\n\r\n    // Sort denominators\r\n    uint denMax = _denB;\r\n    uint denMin = _denA;\r\n    if (_denA > _denB) {\r\n      denMax = _denA;\r\n      denMin = _denB;\r\n    }\r\n\r\n    uint value;\r\n\r\n    if (MAX_UINT / _numA >= _numB) {\r\n      // a*b does not overflow, use `a / d / c`\r\n      value = _numA * _numB;\r\n      value /= denMin;\r\n      value /= denMax;\r\n      return value;\r\n    }\r\n\r\n    // `ab / cd` where both `ab` and `cd` would overflow\r\n\r\n    // Sort numerators\r\n    uint numMax = _numB;\r\n    uint numMin = _numA;\r\n    if (_numA > _numB) {\r\n      numMax = _numA;\r\n      numMin = _numB;\r\n    }\r\n\r\n    // formula = (a/d) * b / c\r\n    uint temp = numMax / denMin;\r\n    if (temp > MAX_ERROR_BEFORE_DIV) {\r\n      return bigDiv2x1(temp, numMin, denMax);\r\n    }\r\n\r\n    // formula: ((a/f) * b) / d then either * f / c or / c * f\r\n    // factor >= a / sqrt(MAX) * (b / sqrt(MAX))\r\n    uint factor = numMin - 1;\r\n    factor /= MAX_BEFORE_SQUARE;\r\n    factor += 1;\r\n    temp = numMax - 1;\r\n    temp /= MAX_BEFORE_SQUARE;\r\n    temp += 1;\r\n    if (MAX_UINT / factor >= temp) {\r\n      factor *= temp;\r\n\r\n      value = numMax / factor;\r\n      if (value > MAX_ERROR_BEFORE_DIV) {\r\n        value = value.mul(numMin);\r\n        value /= denMin;\r\n        if (value > 0 && MAX_UINT / value >= factor) {\r\n          value *= factor;\r\n          value /= denMax;\r\n          return value;\r\n        }\r\n      }\r\n    }\r\n\r\n    // formula: (a/f) * b / ((c*d)/f)\r\n    // factor >= c / sqrt(MAX) * (d / sqrt(MAX))\r\n    factor = denMin;\r\n    factor /= MAX_BEFORE_SQUARE;\r\n    temp = denMax;\r\n    // + 1 here prevents overflow of factor*temp\r\n    temp /= MAX_BEFORE_SQUARE + 1;\r\n    factor *= temp;\r\n    return bigDiv2x1(numMax / factor, numMin, MAX_UINT);\r\n  }\r\n}\r\n\r\n// File: @fairmint/c-org-contracts/contracts/math/Sqrt.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Calculates the square root of a given value.\r\n * @dev Results may be off by 1.\r\n */\r\nlibrary Sqrt {\r\n  /// @notice The max possible value\r\n  uint private constant MAX_UINT = 2**256 - 1;\r\n\r\n  // Source: https://github.com/ethereum/dapp-bin/pull/50\r\n  function sqrt(uint x) internal pure returns (uint y) {\r\n    if (x == 0) {\r\n      return 0;\r\n    } else if (x <= 3) {\r\n      return 1;\r\n    } else if (x == MAX_UINT) {\r\n      // Without this we fail on x + 1 below\r\n      return 2**128 - 1;\r\n    }\r\n\r\n    uint z = (x + 1) / 2;\r\n    y = x;\r\n    while (z < y) {\r\n      y = z;\r\n      z = (x / z + z) / 2;\r\n    }\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context is Initializable {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Initializable, Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is Initializable, IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/CAFE.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Continuous Agreement for Future Equity\r\n */\r\ncontract CAFE\r\n  is ERC20, ERC20Detailed\r\n{\r\n  using SafeMath for uint;\r\n  using Sqrt for uint;\r\n  using SafeERC20 for IERC20;\r\n  event Buy(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint _currencyValue,\r\n    uint _fairValue\r\n  );\r\n  event Sell(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint _currencyValue,\r\n    uint _fairValue\r\n  );\r\n  event Burn(\r\n    address indexed _from,\r\n    uint _fairValue\r\n  );\r\n  event StateChange(\r\n    uint _previousState,\r\n    uint _newState\r\n  );\r\n  event Close();\r\n  event UpdateConfig(\r\n    address _whitelistAddress,\r\n    address indexed _beneficiary,\r\n    address indexed _control,\r\n    address indexed _feeCollector,\r\n    uint _feeBasisPoints,\r\n    uint _minInvestment,\r\n    uint _minDuration,\r\n    uint _stakeholdersPoolAuthorized\r\n  );\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  /// @notice The default state\r\n  uint internal constant STATE_INIT = 0;\r\n\r\n  /// @notice The state after initGoal has been reached\r\n  uint internal constant STATE_RUN = 1;\r\n\r\n  /// @notice The state after closed by the `beneficiary` account from STATE_RUN\r\n  uint internal constant STATE_CLOSE = 2;\r\n\r\n  /// @notice The state after closed by the `beneficiary` account from STATE_INIT\r\n  uint internal constant STATE_CANCEL = 3;\r\n\r\n  /// @notice When multiplying 2 terms, the max value is 2^128-1\r\n  uint internal constant MAX_BEFORE_SQUARE = 2**128 - 1;\r\n\r\n  /// @notice The denominator component for values specified in basis points.\r\n  uint internal constant BASIS_POINTS_DEN = 10000;\r\n\r\n  /// @notice The max `totalSupply() + burnedSupply`\r\n  /// @dev This limit ensures that the DAT's formulas do not overflow (<MAX_BEFORE_SQUARE/2)\r\n  uint internal constant MAX_SUPPLY = 10 ** 38;\r\n\r\n  /**\r\n   * Data specific to our token business logic\r\n   */\r\n\r\n  /// @notice The contract for transfer authorizations, if any.\r\n  IWhitelist public whitelist;\r\n\r\n  /// @notice The total number of burned FAIR tokens, excluding tokens burned from a `Sell` action in the DAT.\r\n  uint public burnedSupply;\r\n\r\n  /**\r\n   * Data for DAT business logic\r\n   */\r\n\r\n  /// @dev unused slot which remains to ensure compatible upgrades\r\n  bool private __autoBurn;\r\n\r\n  /// @notice The address of the beneficiary organization which receives the investments.\r\n  /// Points to the wallet of the organization.\r\n  address payable public beneficiary;\r\n\r\n  /// @notice The buy slope of the bonding curve.\r\n  /// Does not affect the financial model, only the granularity of FAIR.\r\n  /// @dev This is the numerator component of the fractional value.\r\n  uint public buySlopeNum;\r\n\r\n  /// @notice The buy slope of the bonding curve.\r\n  /// Does not affect the financial model, only the granularity of FAIR.\r\n  /// @dev This is the denominator component of the fractional value.\r\n  uint public buySlopeDen;\r\n\r\n  /// @notice The address from which the updatable variables can be updated\r\n  address public control;\r\n\r\n  /// @notice The address of the token used as reserve in the bonding curve\r\n  /// (e.g. the DAI contract). Use ETH if 0.\r\n  IERC20 public currency;\r\n\r\n  /// @notice The address where fees are sent.\r\n  address payable public feeCollector;\r\n\r\n  /// @notice The percent fee collected each time new FAIR are issued expressed in basis points.\r\n  uint public feeBasisPoints;\r\n\r\n  /// @notice The initial fundraising goal (expressed in FAIR) to start the c-org.\r\n  /// `0` means that there is no initial fundraising and the c-org immediately moves to run state.\r\n  uint public initGoal;\r\n\r\n  /// @notice A map with all investors in init state using address as a key and amount as value.\r\n  /// @dev This structure's purpose is to make sure that only investors can withdraw their money if init_goal is not reached.\r\n  mapping(address => uint) public initInvestors;\r\n\r\n  /// @notice The initial number of FAIR created at initialization for the beneficiary.\r\n  /// Technically however, this variable is not a constant as we must always have\r\n  ///`init_reserve>=total_supply+burnt_supply` which means that `init_reserve` will be automatically\r\n  /// decreased to equal `total_supply+burnt_supply` in case `init_reserve>total_supply+burnt_supply`\r\n  /// after an investor sells his FAIRs.\r\n  /// @dev Organizations may move these tokens into vesting contract(s)\r\n  uint public initReserve;\r\n\r\n  /// @notice The investment reserve of the c-org. Defines the percentage of the value invested that is\r\n  /// automatically funneled and held into the buyback_reserve expressed in basis points.\r\n  /// Internal since this is n/a to all derivative contracts.\r\n  uint internal __investmentReserveBasisPoints;\r\n\r\n  /// @dev unused slot which remains to ensure compatible upgrades\r\n  uint private __openUntilAtLeast;\r\n\r\n  /// @notice The minimum amount of `currency` investment accepted.\r\n  uint public minInvestment;\r\n\r\n  /// @dev The revenue commitment of the organization. Defines the percentage of the value paid through the contract\r\n  /// that is automatically funneled and held into the buyback_reserve expressed in basis points.\r\n  /// Internal since this is n/a to all derivative contracts.\r\n  uint internal __revenueCommitmentBasisPoints;\r\n\r\n  /// @notice The current state of the contract.\r\n  /// @dev See the constants above for possible state values.\r\n  uint public state;\r\n\r\n  /// @dev If this value changes we need to reconstruct the DOMAIN_SEPARATOR\r\n  string public constant version = \"cafe-1.0\";\r\n  // --- EIP712 niceties ---\r\n  // Original source: https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f#code\r\n  mapping (address => uint) public nonces;\r\n  bytes32 public DOMAIN_SEPARATOR;\r\n  // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n  bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n  // The success fee (expressed in currency) that will be earned by setupFeeRecipient as soon as initGoal\r\n  // is reached. We must have setup_fee <= buy_slope*init_goal^(2)/2\r\n  uint public setupFee;\r\n\r\n  // The recipient of the setup_fee once init_goal is reached\r\n  address payable public setupFeeRecipient;\r\n\r\n  /// @notice The minimum time before which the c-org contract cannot be closed once the contract has\r\n  /// reached the `run` state.\r\n  /// @dev When updated, the new value of `minimum_duration` cannot be earlier than the previous value.\r\n  uint public minDuration;\r\n\r\n  /// @dev Initialized at `0` and updated when the contract switches from `init` state to `run` state\r\n  /// or when the initial trial period ends.\r\n  uint public __startedOn;\r\n\r\n  /// @notice The max possible value\r\n  uint internal constant MAX_UINT = 2**256 - 1;\r\n\r\n  // keccak256(\"PermitBuy(address from,address to,uint256 currencyValue,uint256 minTokensBought,uint256 nonce,uint256 deadline)\");\r\n  bytes32 public constant PERMIT_BUY_TYPEHASH = 0xaf42a244b3020d6a2253d9f291b4d3e82240da42b22129a8113a58aa7a3ddb6a;\r\n\r\n  // keccak256(\"PermitSell(address from,address to,uint256 quantityToSell,uint256 minCurrencyReturned,uint256 nonce,uint256 deadline)\");\r\n  bytes32 public constant PERMIT_SELL_TYPEHASH = 0x5dfdc7fb4c68a4c249de5e08597626b84fbbe7bfef4ed3500f58003e722cc548;\r\n\r\n  // stkaeholdersPool struct separated\r\n  uint public stakeholdersPoolIssued;\r\n\r\n  uint public stakeholdersPoolAuthorized;\r\n\r\n  // The orgs commitement that backs the value of CAFEs.\r\n  // This value may be increased but not decreased.\r\n  uint public equityCommitment;\r\n\r\n  // Total number of tokens that have been attributed to current shareholders\r\n  uint public shareholdersPool;\r\n\r\n  // The max number of CAFEs investors can purchase (excludes the stakeholdersPool)\r\n  uint public maxGoal;\r\n\r\n  // The amount of CAFE to be sold to exit the trial mode.\r\n  // 0 means there is no trial.\r\n  uint public initTrial;\r\n\r\n  uint public fundraisingGoal;\r\n\r\n  modifier authorizeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint _value,\r\n    bool _isSell\r\n  )\r\n  {\r\n    require(state != STATE_CLOSE, \"INVALID_STATE\");\r\n    if(address(whitelist) != address(0))\r\n    {\r\n      // This is not set for the minting of initialReserve\r\n      whitelist.authorizeTransfer(_from, _to, _value, _isSell);\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Stakeholders Pool\r\n   */\r\n  function stakeholdersPool() public view returns (uint256 issued, uint256 authorized) {\r\n    return (stakeholdersPoolIssued, stakeholdersPoolAuthorized);\r\n  }\r\n\r\n  /**\r\n   * Buyback reserve\r\n   */\r\n\r\n  /// @notice The total amount of currency value currently locked in the contract and available to sellers.\r\n  function buybackReserve() public view returns (uint)\r\n  {\r\n    uint reserve = address(this).balance;\r\n    if(address(currency) != address(0))\r\n    {\r\n      reserve = currency.balanceOf(address(this));\r\n    }\r\n\r\n    if(reserve > MAX_BEFORE_SQUARE)\r\n    {\r\n      /// Math: If the reserve becomes excessive, cap the value to prevent overflowing in other formulas\r\n      return MAX_BEFORE_SQUARE;\r\n    }\r\n\r\n    return reserve;\r\n  }\r\n\r\n  /**\r\n   * Functions required by the ERC-20 token standard\r\n   */\r\n\r\n  /// @dev Moves tokens from one account to another if authorized.\r\n  function _transfer(\r\n    address _from,\r\n    address _to,\r\n    uint _amount\r\n  ) internal\r\n    authorizeTransfer(_from, _to, _amount, false)\r\n  {\r\n    require(state != STATE_INIT || _from == beneficiary, \"ONLY_BENEFICIARY_DURING_INIT\");\r\n    super._transfer(_from, _to, _amount);\r\n  }\r\n\r\n  /// @dev Removes tokens from the circulating supply.\r\n  function _burn(\r\n    address _from,\r\n    uint _amount,\r\n    bool _isSell\r\n  ) internal\r\n    authorizeTransfer(_from, address(0), _amount, _isSell)\r\n  {\r\n    super._burn(_from, _amount);\r\n\r\n    if(!_isSell)\r\n    {\r\n      // This is a burn\r\n      // SafeMath not required as we cap how high this value may get during mint\r\n      burnedSupply += _amount;\r\n      emit Burn(_from, _amount);\r\n    }\r\n  }\r\n\r\n  /// @notice Called to mint tokens on `buy`.\r\n  function _mint(\r\n    address _to,\r\n    uint _quantity\r\n  ) internal\r\n    authorizeTransfer(address(0), _to, _quantity, false)\r\n  {\r\n    super._mint(_to, _quantity);\r\n\r\n    // Math: If this value got too large, the DAT may overflow on sell\r\n    require(totalSupply().add(burnedSupply) <= MAX_SUPPLY, \"EXCESSIVE_SUPPLY\");\r\n  }\r\n\r\n  /**\r\n   * Transaction Helpers\r\n   */\r\n\r\n  /// @notice Confirms the transfer of `_quantityToInvest` currency to the contract.\r\n  function _collectInvestment(\r\n    address payable _from,\r\n    uint _quantityToInvest,\r\n    uint _msgValue\r\n  ) internal\r\n  {\r\n    if(address(currency) == address(0))\r\n    {\r\n      // currency is ETH\r\n      require(_quantityToInvest == _msgValue, \"INCORRECT_MSG_VALUE\");\r\n    }\r\n    else\r\n    {\r\n      // currency is ERC20\r\n      require(_msgValue == 0, \"DO_NOT_SEND_ETH\");\r\n\r\n      currency.safeTransferFrom(_from, address(this), _quantityToInvest);\r\n    }\r\n  }\r\n\r\n  /// @dev Send `_amount` currency from the contract to the `_to` account.\r\n  function _transferCurrency(\r\n    address payable _to,\r\n    uint _amount\r\n  ) internal\r\n  {\r\n    if(_amount > 0)\r\n    {\r\n      if(address(currency) == address(0))\r\n      {\r\n        Address.sendValue(_to, _amount);\r\n      }\r\n      else\r\n      {\r\n        currency.safeTransfer(_to, _amount);\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Config / Control\r\n   */\r\n\r\n  /// @notice Called once after deploy to set the initial configuration.\r\n  /// None of the values provided here may change once initially set.\r\n  /// @dev using the init pattern in order to support zos upgrades\r\n  function initialize(\r\n    uint _initReserve,\r\n    address _currencyAddress,\r\n    uint _initGoal,\r\n    uint _buySlopeNum,\r\n    uint _buySlopeDen,\r\n    uint _setupFee,\r\n    address payable _setupFeeRecipient,\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint _maxGoal,\r\n    uint _initTrial,\r\n    uint _stakeholdersAuthorized,\r\n    uint _equityCommitment\r\n  ) public\r\n  {\r\n    // _initialize will enforce this is only called once\r\n    // The ERC-20 implementation will confirm initialize is only run once\r\n    ERC20Detailed.initialize(_name, _symbol, 18);\r\n\r\n    require(_buySlopeNum > 0, \"INVALID_SLOPE_NUM\");\r\n    require(_buySlopeDen > 0, \"INVALID_SLOPE_DEN\");\r\n    require(_buySlopeNum < MAX_BEFORE_SQUARE, \"EXCESSIVE_SLOPE_NUM\");\r\n    require(_buySlopeDen < MAX_BEFORE_SQUARE, \"EXCESSIVE_SLOPE_DEN\");\r\n    buySlopeNum = _buySlopeNum;\r\n    buySlopeDen = _buySlopeDen;\r\n\r\n    // Setup Fee\r\n    require(_setupFee == 0 || _setupFeeRecipient != address(0), \"MISSING_SETUP_FEE_RECIPIENT\");\r\n    require(_setupFeeRecipient == address(0) || _setupFee != 0, \"MISSING_SETUP_FEE\");\r\n    // setup_fee <= (n/d)*(g^2)/2\r\n    uint initGoalInCurrency = _initGoal * _initGoal;\r\n    initGoalInCurrency = initGoalInCurrency.mul(_buySlopeNum);\r\n    initGoalInCurrency /= 2 * _buySlopeDen;\r\n    require(_setupFee <= initGoalInCurrency, \"EXCESSIVE_SETUP_FEE\");\r\n    setupFee = _setupFee;\r\n    setupFeeRecipient = _setupFeeRecipient;\r\n\r\n    // Set default values (which may be updated using `updateConfig`)\r\n    uint decimals = 18;\r\n    if(_currencyAddress != address(0))\r\n    {\r\n      decimals = IERC20Detailed(_currencyAddress).decimals();\r\n    }\r\n    minInvestment = 100 * (10 ** decimals);\r\n    beneficiary = msg.sender;\r\n    control = msg.sender;\r\n    feeCollector = msg.sender;\r\n\r\n    // Save currency\r\n    currency = IERC20(_currencyAddress);\r\n\r\n    // Mint the initial reserve\r\n    if(_initReserve > 0)\r\n    {\r\n      initReserve = _initReserve;\r\n      _mint(beneficiary, initReserve);\r\n    }\r\n\r\n    initializeDomainSeparator();\r\n\r\n    // new settings for CAFE\r\n    require(_maxGoal == 0 || _initGoal == 0 || _maxGoal >= _initGoal, \"MAX_GOAL_SMALLER_THAN_INIT_GOAL\");\r\n    require(_initGoal == 0 || _initTrial == 0 || _initGoal >= _initTrial, \"INIT_GOAL_SMALLER_THAN_INIT_TRIAL\");\r\n    maxGoal = _maxGoal;\r\n    initTrial = _initTrial;\r\n    stakeholdersPoolIssued = _initReserve;\r\n    stakeholdersPoolAuthorized = _stakeholdersAuthorized;\r\n    require(_equityCommitment > 0, \"EQUITY_COMMITMENT_CANNOT_BE_ZERO\");\r\n    require(_equityCommitment <= BASIS_POINTS_DEN, \"EQUITY_COMMITMENT_SHOULD_BE_LESS_THAN_100%\");\r\n    equityCommitment = _equityCommitment;\r\n    // Set initGoal, which in turn defines the initial state\r\n    if(_initGoal == 0)\r\n    {\r\n      emit StateChange(state, STATE_RUN);\r\n      state = STATE_RUN;\r\n      __startedOn = block.timestamp;\r\n    }\r\n    else\r\n    {\r\n      // Math: If this value got too large, the DAT would overflow on sell\r\n      require(_initGoal < MAX_SUPPLY, \"EXCESSIVE_GOAL\");\r\n      initGoal = _initGoal;\r\n    }\r\n  }\r\n\r\n  function updateConfig(\r\n    address _whitelistAddress,\r\n    address payable _beneficiary,\r\n    address _control,\r\n    address payable _feeCollector,\r\n    uint _feeBasisPoints,\r\n    uint _minInvestment,\r\n    uint _minDuration,\r\n    uint _stakeholdersAuthorized\r\n  ) public\r\n  {\r\n    // This require(also confirms that initialize has been called.\r\n    require(msg.sender == control, \"CONTROL_ONLY\");\r\n\r\n    // address(0) is okay\r\n    whitelist = IWhitelist(_whitelistAddress);\r\n\r\n    require(_control != address(0), \"INVALID_ADDRESS\");\r\n    control = _control;\r\n\r\n    require(_feeCollector != address(0), \"INVALID_ADDRESS\");\r\n    feeCollector = _feeCollector;\r\n\r\n    require(_feeBasisPoints <= BASIS_POINTS_DEN, \"INVALID_FEE\");\r\n    feeBasisPoints = _feeBasisPoints;\r\n\r\n    require(_minInvestment > 0, \"INVALID_MIN_INVESTMENT\");\r\n    minInvestment = _minInvestment;\r\n\r\n    require(_minDuration >= minDuration, \"MIN_DURATION_MAY_NOT_BE_REDUCED\");\r\n    minDuration = _minDuration;\r\n\r\n    if(beneficiary != _beneficiary)\r\n    {\r\n      require(_beneficiary != address(0), \"INVALID_ADDRESS\");\r\n      uint tokens = balanceOf(beneficiary);\r\n      initInvestors[_beneficiary] = initInvestors[_beneficiary].add(initInvestors[beneficiary]);\r\n      initInvestors[beneficiary] = 0;\r\n      if(tokens > 0)\r\n      {\r\n        _transfer(beneficiary, _beneficiary, tokens);\r\n      }\r\n      beneficiary = _beneficiary;\r\n    }\r\n\r\n    // new settings for CAFE\r\n    require(_stakeholdersAuthorized <= BASIS_POINTS_DEN, \"STAKEHOLDERS_POOL_AUTHORIZED_SHOULD_BE_SMALLER_THAN_BASIS_POINTS_DEN\");\r\n    stakeholdersPoolAuthorized = _stakeholdersAuthorized;\r\n\r\n    emit UpdateConfig(\r\n      _whitelistAddress,\r\n      _beneficiary,\r\n      _control,\r\n      _feeCollector,\r\n      _feeBasisPoints,\r\n      _minInvestment,\r\n      _minDuration,\r\n      _stakeholdersAuthorized\r\n    );\r\n  }\r\n\r\n  /// @notice Used to initialize the domain separator used in meta-transactions\r\n  /// @dev This is separate from `initialize` to allow upgraded contracts to update the version\r\n  /// There is no harm in calling this multiple times / no permissions required\r\n  function initializeDomainSeparator() public\r\n  {\r\n    uint id;\r\n    // solium-disable-next-line\r\n    assembly\r\n    {\r\n      id := chainid()\r\n    }\r\n    DOMAIN_SEPARATOR = keccak256(\r\n      abi.encode(\r\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n        keccak256(bytes(name())),\r\n        keccak256(bytes(version)),\r\n        id,\r\n        address(this)\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Functions for our business logic\r\n   */\r\n\r\n  /// @notice Burn the amount of tokens from the address msg.sender if authorized.\r\n  /// @dev Note that this is not the same as a `sell` via the DAT.\r\n  function burn(\r\n    uint _amount\r\n  ) public\r\n  {\r\n    require(state == STATE_RUN, \"INVALID_STATE\");\r\n    require(msg.sender == beneficiary, \"BENEFICIARY_ONLY\");\r\n    _burn(msg.sender, _amount, false);\r\n  }\r\n\r\n  // Buy\r\n\r\n  /// @notice Purchase FAIR tokens with the given amount of currency.\r\n  /// @param _to The account to receive the FAIR tokens from this purchase.\r\n  /// @param _currencyValue How much currency to spend in order to buy FAIR.\r\n  /// @param _minTokensBought Buy at least this many FAIR tokens or the transaction reverts.\r\n  /// @dev _minTokensBought is necessary as the price will change if some elses transaction mines after\r\n  /// yours was submitted.\r\n  function buy(\r\n    address _to,\r\n    uint _currencyValue,\r\n    uint _minTokensBought\r\n  ) public payable\r\n  {\r\n    _buy(msg.sender, _to, _currencyValue, _minTokensBought);\r\n  }\r\n\r\n  /// @notice Allow users to sign a message authorizing a buy\r\n  function permitBuy(\r\n    address payable _from,\r\n    address _to,\r\n    uint _currencyValue,\r\n    uint _minTokensBought,\r\n    uint _deadline,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s\r\n  ) external\r\n  {\r\n    require(_deadline >= block.timestamp, \"EXPIRED\");\r\n    bytes32 digest = keccak256(abi.encode(PERMIT_BUY_TYPEHASH, _from, _to, _currencyValue, _minTokensBought, nonces[_from]++, _deadline));\r\n    digest = keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        digest\r\n      )\r\n    );\r\n    address recoveredAddress = ecrecover(digest, _v, _r, _s);\r\n    require(recoveredAddress != address(0) && recoveredAddress == _from, \"INVALID_SIGNATURE\");\r\n    _buy(_from, _to, _currencyValue, _minTokensBought);\r\n  }\r\n\r\n  function _buy(\r\n    address payable _from,\r\n    address _to,\r\n    uint _currencyValue,\r\n    uint _minTokensBought\r\n  ) internal\r\n  {\r\n    require(_to != address(0), \"INVALID_ADDRESS\");\r\n    require(_to != beneficiary, \"BENEFICIARY_CANNOT_BUY\");\r\n    require(_minTokensBought > 0, \"MUST_BUY_AT_LEAST_1\");\r\n    require(state == STATE_INIT || state == STATE_RUN, \"ONLY_BUY_IN_INIT_OR_RUN\");\r\n\r\n    _collectInvestment(_from, _currencyValue, msg.value);\r\n    // Calculate the tokenValue for this investment\r\n    // returns zero if _currencyValue < minInvestment\r\n    uint tokenValue = estimateBuyValue(_currencyValue);\r\n    require(tokenValue >= _minTokensBought, \"PRICE_SLIPPAGE\");\r\n    if(state == STATE_INIT){\r\n      if(tokenValue < initTrial - shareholdersPool){\r\n        //already received all currency from _collectInvestment\r\n        initInvestors[_to] = initInvestors[_to].add(tokenValue);\r\n        initTrial = initTrial.sub(tokenValue);\r\n      }\r\n      else if (initTrial > shareholdersPool){\r\n        //already received all currency from _collectInvestment\r\n        //send setup fee to beneficiary\r\n        if(setupFee > 0){\r\n          _transferCurrency(setupFeeRecipient, setupFee);\r\n        }\r\n        _distributeInvestment(buybackReserve());\r\n        initTrial = shareholdersPool;\r\n        __startedOn = block.timestamp;\r\n      }\r\n      else{\r\n        _distributeInvestment(buybackReserve());\r\n      }\r\n    }\r\n    else { //state == STATE_RUN\r\n      require(maxGoal == 0 || tokenValue.add(totalSupply()).sub(stakeholdersPoolIssued) <= maxGoal, \"EXCEEDING_MAX_GOAL\");\r\n      _distributeInvestment(_currencyValue);\r\n      if(fundraisingGoal != 0){\r\n        if (tokenValue >= fundraisingGoal){\r\n          buySlopeNum = BigDiv.bigDiv2x1(\r\n            buySlopeNum,\r\n            totalSupply() - stakeholdersPoolIssued,\r\n            fundraisingGoal + totalSupply() - stakeholdersPoolIssued\r\n          );\r\n          fundraisingGoal = 0;\r\n        } else { //if (tokenValue < fundraisingGoal) {\r\n          buySlopeNum = BigDiv.bigDiv2x1(\r\n            buySlopeNum,\r\n            totalSupply() - stakeholdersPoolIssued,\r\n            tokenValue + totalSupply() - stakeholdersPoolIssued\r\n          );\r\n          fundraisingGoal -= tokenValue;\r\n        }\r\n      }\r\n    }\r\n\r\n    emit Buy(_from, _to, _currencyValue, tokenValue);\r\n    _mint(_to, tokenValue);\r\n\r\n    if(state == STATE_INIT && totalSupply() - stakeholdersPoolIssued >= initGoal){\r\n      state = STATE_RUN;\r\n      emit StateChange(STATE_INIT, STATE_RUN);\r\n    }\r\n  }\r\n\r\n  /// @dev Distributes _value currency between the beneficiary and feeCollector.\r\n  function _distributeInvestment(\r\n    uint _value\r\n  ) internal\r\n  {\r\n    uint fee = _value.mul(feeBasisPoints);\r\n    fee /= BASIS_POINTS_DEN;\r\n\r\n    // Math: since feeBasisPoints is <= BASIS_POINTS_DEN, this will never underflow.\r\n    _transferCurrency(beneficiary, _value - fee);\r\n    _transferCurrency(feeCollector, fee);\r\n  }\r\n\r\n  /// @notice Calculate how many FAIR tokens you would buy with the given amount of currency if `buy` was called now.\r\n  /// @param _currencyValue How much currency to spend in order to buy FAIR.\r\n  function estimateBuyValue(\r\n    uint _currencyValue\r\n  ) public view\r\n  returns(uint)\r\n  {\r\n    if(_currencyValue < minInvestment){\r\n      return 0;\r\n    }\r\n    if(state == STATE_INIT){\r\n      uint currencyValue = _currencyValue;\r\n      uint _totalSupply = totalSupply();\r\n      uint max = BigDiv.bigDiv2x1(\r\n        initGoal * buySlopeNum,\r\n        initGoal - _totalSupply + stakeholdersPoolIssued,\r\n        buySlopeDen\r\n      );\r\n\r\n      if(currencyValue > max)\r\n      {\r\n        currencyValue = max;\r\n      }\r\n\r\n      uint256 tokenAmount = BigDiv.bigDiv2x1(\r\n        currencyValue,\r\n        buySlopeDen,\r\n        initGoal * buySlopeNum\r\n      );\r\n      if(currencyValue != _currencyValue)\r\n      {\r\n        currencyValue = _currencyValue - max;\r\n        // ((2*next_amount/buy_slope)+init_goal^2)^(1/2)-init_goal\r\n        // a: next_amount | currencyValue\r\n        // n/d: buy_slope (MAX_BEFORE_SQUARE / MAX_BEFORE_SQUARE)\r\n        // g: init_goal (MAX_BEFORE_SQUARE/2)\r\n        // r: init_reserve (MAX_BEFORE_SQUARE/2)\r\n        // sqrt(((2*a/(n/d))+g^2)-g\r\n        // sqrt((2 d a + n g^2)/n) - g\r\n\r\n        // currencyValue == 2 d a\r\n        uint temp = 2 * buySlopeDen;\r\n        currencyValue = temp.mul(currencyValue);\r\n\r\n        // temp == g^2\r\n        temp = initGoal;\r\n        temp *= temp;\r\n\r\n        // temp == n g^2\r\n        temp = temp.mul(buySlopeNum);\r\n\r\n        // temp == (2 d a) + n g^2\r\n        temp = currencyValue.add(temp);\r\n\r\n        // temp == (2 d a + n g^2)/n\r\n        temp /= buySlopeNum;\r\n\r\n        // temp == sqrt((2 d a + n g^2)/n)\r\n        temp = temp.sqrt();\r\n\r\n        // temp == sqrt((2 d a + n g^2)/n) - g\r\n        temp -= initGoal;\r\n\r\n        tokenAmount = tokenAmount.add(temp);\r\n      }\r\n      return tokenAmount;\r\n    }\r\n    else {//state == STATE_RUN{\r\n      uint supply = totalSupply() - stakeholdersPoolIssued;\r\n      // calculate fundraising amount (static price)\r\n      uint currencyValue = _currencyValue;\r\n      uint fundraisedAmount;\r\n      if(fundraisingGoal > 0){\r\n        uint max = BigDiv.bigDiv2x1(\r\n          supply,\r\n          fundraisingGoal * buySlopeNum,\r\n          buySlopeDen\r\n        );\r\n        if(currencyValue > max){\r\n          currencyValue = max;\r\n        }\r\n        fundraisedAmount = BigDiv.bigDiv2x2(\r\n          currencyValue,\r\n          buySlopeDen,\r\n          supply,\r\n          buySlopeNum\r\n        );\r\n        //forward leftover currency to be used as normal buy\r\n        currencyValue = _currencyValue - currencyValue;\r\n      }\r\n\r\n      // initReserve is reduced on sell as necessary to ensure that this line will not overflow\r\n      // Math: worst case\r\n      // MAX * 2 * MAX_BEFORE_SQUARE\r\n      // / MAX_BEFORE_SQUARE\r\n      uint tokenAmount = BigDiv.bigDiv2x1(\r\n        currencyValue,\r\n        2 * buySlopeDen,\r\n        buySlopeNum\r\n      );\r\n\r\n      // Math: worst case MAX + (MAX_BEFORE_SQUARE * MAX_BEFORE_SQUARE)\r\n      tokenAmount = tokenAmount.add(supply * supply);\r\n      tokenAmount = tokenAmount.sqrt();\r\n\r\n      // Math: small chance of underflow due to possible rounding in sqrt\r\n      tokenAmount = tokenAmount.sub(supply);\r\n      return fundraisedAmount.add(tokenAmount);\r\n    }\r\n  }\r\n\r\n  // Sell\r\n\r\n  /// @notice Sell FAIR tokens for at least the given amount of currency.\r\n  /// @param _to The account to receive the currency from this sale.\r\n  /// @param _quantityToSell How many FAIR tokens to sell for currency value.\r\n  /// @param _minCurrencyReturned Get at least this many currency tokens or the transaction reverts.\r\n  /// @dev _minCurrencyReturned is necessary as the price will change if some elses transaction mines after\r\n  /// yours was submitted.\r\n  function sell(\r\n    address payable _to,\r\n    uint _quantityToSell,\r\n    uint _minCurrencyReturned\r\n  ) public\r\n  {\r\n    _sell(msg.sender, _to, _quantityToSell, _minCurrencyReturned);\r\n  }\r\n\r\n  /// @notice Allow users to sign a message authorizing a sell\r\n  function permitSell(\r\n    address _from,\r\n    address payable _to,\r\n    uint _quantityToSell,\r\n    uint _minCurrencyReturned,\r\n    uint _deadline,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s\r\n  ) external\r\n  {\r\n    require(_deadline >= block.timestamp, \"EXPIRED\");\r\n    bytes32 digest = keccak256(abi.encode(PERMIT_SELL_TYPEHASH, _from, _to, _quantityToSell, _minCurrencyReturned, nonces[_from]++, _deadline));\r\n    digest = keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        digest\r\n      )\r\n    );\r\n    address recoveredAddress = ecrecover(digest, _v, _r, _s);\r\n    require(recoveredAddress != address(0) && recoveredAddress == _from, \"INVALID_SIGNATURE\");\r\n    _sell(_from, _to, _quantityToSell, _minCurrencyReturned);\r\n  }\r\n\r\n  function _sell(\r\n    address _from,\r\n    address payable _to,\r\n    uint _quantityToSell,\r\n    uint _minCurrencyReturned\r\n  ) internal\r\n  {\r\n    require(_from != beneficiary, \"BENEFICIARY_CANNOT_SELL\");\r\n    require(state != STATE_INIT || initTrial != shareholdersPool, \"INIT_TRIAL_ENDED\");\r\n    require(state == STATE_INIT || state == STATE_CANCEL, \"ONLY_SELL_IN_INIT_OR_CANCEL\");\r\n    require(_minCurrencyReturned > 0, \"MUST_SELL_AT_LEAST_1\");\r\n    // check for slippage\r\n    uint currencyValue = estimateSellValue(_quantityToSell);\r\n    require(currencyValue >= _minCurrencyReturned, \"PRICE_SLIPPAGE\");\r\n    // it will work as checking _from has morethan _quantityToSell as initInvestors\r\n    initInvestors[_from] = initInvestors[_from].sub(_quantityToSell);\r\n    _burn(_from, _quantityToSell, true);\r\n    _transferCurrency(_to, currencyValue);\r\n    if(state == STATE_INIT && initTrial != 0){\r\n      // this can only happen if initTrial is set to zero from day one\r\n      initTrial = initTrial.add(_quantityToSell);\r\n    }\r\n    emit Sell(_from, _to, currencyValue, _quantityToSell);\r\n  }\r\n\r\n  function estimateSellValue(\r\n    uint _quantityToSell\r\n  ) public view\r\n    returns(uint)\r\n  {\r\n    if(state != STATE_INIT && state != STATE_CANCEL){\r\n      return 0;\r\n    }\r\n    uint reserve = buybackReserve();\r\n\r\n    // Calculate currencyValue for this sale\r\n    uint currencyValue;\r\n    // STATE_INIT or STATE_CANCEL\r\n    // Math worst case:\r\n    // MAX * MAX_BEFORE_SQUARE\r\n    currencyValue = _quantityToSell.mul(reserve);\r\n    // Math: FAIR blocks initReserve from being burned unless we reach the RUN state which prevents an underflow\r\n    currencyValue /= totalSupply() - stakeholdersPoolIssued - shareholdersPool;\r\n\r\n    return currencyValue;\r\n  }\r\n\r\n\r\n  // Close\r\n\r\n  /// @notice Called by the beneficiary account to STATE_CLOSE or STATE_CANCEL the c-org,\r\n  /// preventing any more tokens from being minted.\r\n  function close() public\r\n  {\r\n    _close();\r\n    emit Close();\r\n  }\r\n\r\n  /// @notice Called by the beneficiary account to STATE_CLOSE or STATE_CANCEL the c-org,\r\n  /// preventing any more tokens from being minted.\r\n  /// @dev Requires an `exitFee` to be paid.  If the currency is ETH, include a little more than\r\n  /// what appears to be required and any remainder will be returned to your account.  This is\r\n  /// because another user may have a transaction mined which changes the exitFee required.\r\n  /// For other `currency` types, the beneficiary account will be billed the exact amount required.\r\n  function _close() internal\r\n  {\r\n    require(msg.sender == beneficiary, \"BENEFICIARY_ONLY\");\r\n\r\n    if(state == STATE_INIT)\r\n    {\r\n      // Allow the org to cancel anytime if the initGoal was not reached.\r\n      require(initTrial > shareholdersPool,\"CANNOT_CANCEL_IF_INITTRIAL_IS_ZERO\");\r\n      emit StateChange(state, STATE_CANCEL);\r\n      state = STATE_CANCEL;\r\n    }\r\n    else if(state == STATE_RUN)\r\n    {\r\n      require(MAX_UINT - minDuration > __startedOn, \"MAY_NOT_CLOSE\");\r\n      require(minDuration + __startedOn <= block.timestamp, \"TOO_EARLY\");\r\n\r\n      emit StateChange(state, STATE_CLOSE);\r\n      state = STATE_CLOSE;\r\n    }\r\n    else\r\n    {\r\n      revert(\"INVALID_STATE\");\r\n    }\r\n  }\r\n\r\n  /// @notice mint new CAFE and send them to `wallet`\r\n  function mint(\r\n    address _wallet,\r\n    uint256 _amount,\r\n    bool _investment\r\n  ) external\r\n  {\r\n    require(msg.sender == beneficiary, \"ONLY_BENEFICIARY_CAN_MINT\");\r\n    if(!_investment){\r\n      require(\r\n        _amount.add(stakeholdersPoolIssued) <= stakeholdersPoolAuthorized.mul(totalSupply().add(_amount)).div(BASIS_POINTS_DEN),\r\n        \"CANNOT_MINT_MORE_THAN_AUTHORIZED_PERCENTAGE\"\r\n      );\r\n      //update stakeholdersPool issued value\r\n      stakeholdersPoolIssued = stakeholdersPoolIssued.add(_amount);\r\n    }\r\n    address to = _wallet == address(0) ? beneficiary : _wallet;\r\n    //check if wallet is whitelist in the _mint() function\r\n    _mint(to, _amount);\r\n  }\r\n\r\n  function increaseCommitment(\r\n    uint256 _newCommitment,\r\n    uint256 _amount,\r\n    address _wallet\r\n  ) external\r\n  {\r\n    require(state == STATE_INIT || state == STATE_RUN, \"ONLY_IN_INIT_OR_RUN\");\r\n    require(msg.sender == beneficiary, \"ONLY_BENEFICIARY_CAN_INCREASE_COMMITMENT\");\r\n    require(_newCommitment > 0, \"COMMITMENT_CANT_BE_ZERO\");\r\n    require(equityCommitment.add(_newCommitment) <= BASIS_POINTS_DEN, \"EQUITY_COMMITMENT_SHOULD_BE_LESS_THAN_100%\");\r\n    equityCommitment = equityCommitment.add(_newCommitment);\r\n    address wallet = _wallet == address(0) ? beneficiary : _wallet;\r\n    if(_amount > 0 ){\r\n      if(wallet == beneficiary){\r\n        if(state == STATE_INIT){\r\n          buySlopeNum = BigDiv.bigDiv2x1(\r\n            buySlopeNum,\r\n            initGoal,\r\n            _amount + initGoal\r\n          );\r\n          initGoal = initGoal.add(_amount);\r\n        } else {\r\n          fundraisingGoal = _amount;\r\n        }\r\n      }\r\n      else {\r\n        shareholdersPool = shareholdersPool.add(_amount);\r\n        if(state == STATE_INIT){\r\n          buySlopeNum = BigDiv.bigDiv2x1(\r\n            buySlopeNum,\r\n            initGoal,\r\n            _amount + initGoal\r\n          );\r\n          initGoal = initGoal.add(_amount);\r\n          if(initTrial != 0){\r\n            initTrial = initTrial.add(_amount);\r\n          }\r\n        }\r\n        else {\r\n          buySlopeNum = BigDiv.bigDiv2x1(\r\n            buySlopeNum,\r\n            totalSupply() - stakeholdersPoolIssued,\r\n            _amount + totalSupply() - stakeholdersPoolIssued\r\n          );\r\n        }\r\n        _mint(wallet, _amount);\r\n      }\r\n      if(maxGoal != 0){\r\n        maxGoal = maxGoal.add(_amount);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice Pay the organization on-chain without minting any tokens.\r\n  /// @dev This allows you to add funds directly to the buybackReserve.\r\n  function() external payable {\r\n    require(address(currency) == address(0), \"ONLY_FOR_CURRENCY_ETH\");\r\n  }\r\n\r\n\r\n  // --- Approve by signature ---\r\n  // EIP-2612\r\n  // Original source: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol\r\n  function permit(\r\n    address owner,\r\n    address spender,\r\n    uint value,\r\n    uint deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external\r\n  {\r\n    require(deadline >= block.timestamp, \"EXPIRED\");\r\n    bytes32 digest = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\r\n    digest = keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        digest\r\n      )\r\n    );\r\n    address recoveredAddress = ecrecover(digest, v, r, s);\r\n    require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNATURE\");\r\n    _approve(owner, spender, value);\r\n  }\r\n\r\n  uint256[50] private __gap;\r\n}"
    }
  }
}