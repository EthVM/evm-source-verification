{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{"RibbonVolatility.sol":{"ProtocolAdapter":"0xff51ca3ba8cb5d289deb56dfcba50c7cc100d949"}},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"RibbonVolatility.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// \n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\n\n// \n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\n\n// \n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    //rounds to zero if x*y < RAY / 2\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        require(\n            initializing || isConstructor() || !initialized,\n            \"Contract instance has already been initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        assembly {\n            cs := extcodesize(self)\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n\ninterface IRibbonFactory {\n    function isInstrument(address instrument) external returns (bool);\n\n    function getAdapter(string calldata protocolName)\n        external\n        view\n        returns (address);\n\n    function getAdapters()\n        external\n        view\n        returns (address[] memory adaptersArray);\n}\n\nenum OptionType {Invalid, Put, Call}\n\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize(address newOwner) public {\n        _owner = newOwner;\n        emit OwnershipTransferred(address(0), newOwner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract InstrumentStorageV1 is Initializable, Ownable, ReentrancyGuard {\n    IRibbonFactory public factory;\n    address public underlying;\n    address public strikeAsset;\n    address public collateralAsset;\n    uint256 public expiry;\n    string public name;\n    string public symbol;\n    mapping(address => InstrumentPosition[]) public instrumentPositions;\n\n    uint256[100] private __instrumentGap;\n\n    struct InstrumentPosition {\n        bool exercised;\n        OptionType[] optionTypes;\n        uint32[] optionIDs;\n        uint256[] amounts;\n        uint256[] strikePrices;\n        string[] venues;\n    }\n\n    /**\n     * @notice Returns the symbol of the instrument\n     * @param _account is the address which has opened InstrumentPositions\n     */\n    function numOfPositions(address _account) public view returns (uint256) {\n        return instrumentPositions[_account].length;\n    }\n\n    function getInstrumentPositions(address account)\n        external\n        view\n        returns (InstrumentPosition[] memory positions)\n    {\n        return instrumentPositions[account];\n    }\n\n    function instrumentPosition(address account, uint256 positionID)\n        external\n        view\n        returns (InstrumentPosition memory position)\n    {\n        return instrumentPositions[account][positionID];\n    }\n}\n\nenum PurchaseMethod {Invalid, Contract, ZeroEx}\n\nstruct OptionTerms {\n    address underlying;\n    address strikeAsset;\n    address collateralAsset;\n    uint256 expiry;\n    uint256 strikePrice;\n    OptionType optionType;\n}\n\nstruct ZeroExOrder {\n    address exchangeAddress;\n    address buyTokenAddress;\n    address sellTokenAddress;\n    address allowanceTarget;\n    uint256 protocolFee;\n    uint256 makerAssetAmount;\n    uint256 takerAssetAmount;\n    bytes swapData;\n}\n\ninterface IProtocolAdapter {\n    /**\n     * @notice Emitted when a new option contract is purchased\n     */\n    event Purchased(\n        address indexed caller,\n        string indexed protocolName,\n        address indexed underlying,\n        address strikeAsset,\n        uint256 expiry,\n        uint256 strikePrice,\n        OptionType optionType,\n        uint256 amount,\n        uint256 premium,\n        uint256 optionID\n    );\n\n    /**\n     * @notice Emitted when an option contract is exercised\n     */\n    event Exercised(\n        address indexed caller,\n        address indexed options,\n        uint256 indexed optionID,\n        uint256 amount,\n        uint256 exerciseProfit\n    );\n\n    /**\n     * @notice Name of the adapter. E.g. \"HEGIC\", \"OPYN_V1\". Used as index key for adapter addresses\n     */\n    function protocolName() external pure returns (string memory);\n\n    /**\n     * @notice Boolean flag to indicate whether to use option IDs or not.\n     * Fungible protocols normally use tokens to represent option contracts.\n     */\n    function nonFungible() external pure returns (bool);\n\n    /**\n     * @notice Returns the purchase method used to purchase options\n     */\n    function purchaseMethod() external pure returns (PurchaseMethod);\n\n    /**\n     * @notice Check if an options contract exist based on the passed parameters.\n     * @param optionTerms is the terms of the option contract\n     */\n    function optionsExist(OptionTerms calldata optionTerms)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Get the options contract's address based on the passed parameters\n     * @param optionTerms is the terms of the option contract\n     */\n    function getOptionsAddress(OptionTerms calldata optionTerms)\n        external\n        view\n        returns (address);\n\n    /**\n     * @notice Gets the premium to buy `purchaseAmount` of the option contract in ETH terms.\n     * @param optionTerms is the terms of the option contract\n     * @param purchaseAmount is the number of options purchased\n     */\n    function premium(OptionTerms calldata optionTerms, uint256 purchaseAmount)\n        external\n        view\n        returns (uint256 cost);\n\n    /**\n     * @notice Amount of profit made from exercising an option contract (current price - strike price). 0 if exercising out-the-money.\n     * @param options is the address of the options contract\n     * @param optionID is the ID of the option position in non fungible protocols like Hegic.\n     * @param amount is the amount of tokens or options contract to exercise. Only relevant for fungle protocols like Opyn\n     */\n    function exerciseProfit(\n        address options,\n        uint256 optionID,\n        uint256 amount\n    ) external view returns (uint256 profit);\n\n    function canExercise(\n        address options,\n        uint256 optionID,\n        uint256 amount\n    ) external view returns (bool);\n\n    /**\n     * @notice Purchases the options contract.\n     * @param optionTerms is the terms of the option contract\n     * @param amount is the purchase amount in Wad units (10**18)\n     */\n    function purchase(OptionTerms calldata optionTerms, uint256 amount)\n        external\n        payable\n        returns (uint256 optionID);\n\n    /**\n     * @notice Exercises the options contract.\n     * @param options is the address of the options contract\n     * @param optionID is the ID of the option position in non fungible protocols like Hegic.\n     * @param amount is the amount of tokens or options contract to exercise. Only relevant for fungle protocols like Opyn\n     * @param recipient is the account that receives the exercised profits. This is needed since the adapter holds all the positions and the msg.sender is an instrument contract.\n     */\n    function exercise(\n        address options,\n        uint256 optionID,\n        uint256 amount,\n        address recipient\n    ) external payable;\n}\n\nlibrary ProtocolAdapter {\n    function delegateProtocolName(IProtocolAdapter adapter)\n        external\n        view\n        returns (string memory)\n    {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\"protocolName()\")\n            );\n        require(success, \"protocolName staticcall failed\");\n        return abi.decode(result, (string));\n    }\n\n    function delegateNonFungible(IProtocolAdapter adapter)\n        external\n        view\n        returns (bool)\n    {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\"nonFungible()\")\n            );\n        require(success, \"nonFungible staticcall failed\");\n        return abi.decode(result, (bool));\n    }\n\n    function delegateOptionsExist(\n        IProtocolAdapter adapter,\n        OptionTerms calldata optionTerms\n    ) external view returns (bool) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"optionsExist((address,address,address,uint256,uint256,uint8))\",\n                    optionTerms\n                )\n            );\n        require(success, \"optionsExist staticcall failed\");\n        return abi.decode(result, (bool));\n    }\n\n    function delegateGetOptionsAddress(\n        IProtocolAdapter adapter,\n        OptionTerms calldata optionTerms\n    ) external view returns (address) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"getOptionsAddress((address,address,address,uint256,uint256,uint8))\",\n                    optionTerms\n                )\n            );\n        require(success, getRevertMsg(result));\n        require(success, \"getOptionsAddress staticcall failed\");\n        return abi.decode(result, (address));\n    }\n\n    function delegatePremium(\n        IProtocolAdapter adapter,\n        OptionTerms calldata optionTerms,\n        uint256 purchaseAmount\n    ) external view returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"premium((address,address,address,uint256,uint256,uint8),uint256)\",\n                    optionTerms,\n                    purchaseAmount\n                )\n            );\n        require(success, \"premium staticcall failed\");\n        return abi.decode(result, (uint256));\n    }\n\n    function delegateExerciseProfit(\n        IProtocolAdapter adapter,\n        address options,\n        uint256 optionID,\n        uint256 amount\n    ) external view returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).staticcall(\n                abi.encodeWithSignature(\n                    \"exerciseProfit(address,uint256,uint256)\",\n                    options,\n                    optionID,\n                    amount\n                )\n            );\n        require(success, getRevertMsg(result));\n        require(success, \"exerciseProfit staticcall failed\");\n        return abi.decode(result, (uint256));\n    }\n\n    function delegatePurchase(\n        IProtocolAdapter adapter,\n        OptionTerms calldata optionTerms,\n        uint256 purchaseAmount\n    ) external returns (uint256) {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    \"purchase((address,address,address,uint256,uint256,uint8),uint256)\",\n                    optionTerms,\n                    purchaseAmount\n                )\n            );\n        require(success, getRevertMsg(result));\n        return abi.decode(result, (uint256));\n    }\n\n    function delegatePurchaseWithZeroEx(\n        IProtocolAdapter adapter,\n        OptionTerms calldata optionTerms,\n        ZeroExOrder calldata zeroExOrder\n    ) external {\n        (bool success, bytes memory result) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    \"purchaseWithZeroEx((address,address,address,uint256,uint256,uint8),(address,address,address,address,uint256,uint256,uint256,bytes))\",\n                    optionTerms,\n                    zeroExOrder\n                )\n            );\n        require(success, getRevertMsg(result));\n    }\n\n    function delegateExercise(\n        IProtocolAdapter adapter,\n        address options,\n        uint256 optionID,\n        uint256 amount,\n        address recipient\n    ) external {\n        (bool success, bytes memory res) =\n            address(adapter).delegatecall(\n                abi.encodeWithSignature(\n                    \"exercise(address,uint256,uint256,address)\",\n                    options,\n                    optionID,\n                    amount,\n                    recipient\n                )\n            );\n        require(success, getRevertMsg(res));\n        require(success, \"exercise delegatecall failed\");\n    }\n\n    function getRevertMsg(bytes memory _returnData)\n        internal\n        pure\n        returns (string memory)\n    {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n}\n\n// \ncontract RibbonVolatility is DSMath, InstrumentStorageV1 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using ProtocolAdapter for IProtocolAdapter;\n\n    event PositionCreated(\n        address indexed account,\n        uint256 indexed positionID,\n        string[] venues,\n        OptionType[] optionTypes,\n        uint256[] amounts,\n        uint32[] optionIDs\n    );\n    event Exercised(\n        address indexed account,\n        uint256 indexed positionID,\n        uint256 totalProfit,\n        bool[] optionsExercised\n    );\n\n    receive() external payable {}\n\n    function initialize(\n        address _owner,\n        address _factory,\n        string memory _name,\n        string memory _symbol,\n        address _underlying,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _expiry\n    ) public initializer {\n        require(block.timestamp < _expiry, \"Expiry has already passed\");\n\n        Ownable.initialize(_owner);\n        factory = IRibbonFactory(_factory);\n        name = _name;\n        symbol = _symbol;\n        expiry = _expiry;\n        underlying = _underlying;\n        strikeAsset = _strikeAsset;\n        collateralAsset = _collateralAsset;\n    }\n\n    function cost(\n        string[] memory venues,\n        OptionType[] memory optionTypes,\n        uint256[] memory amounts,\n        uint256[] memory strikePrices\n    ) public view returns (uint256 totalPremium) {\n        for (uint256 i = 0; i < venues.length; i++) {\n            address adapterAddress = factory.getAdapter(venues[i]);\n            require(adapterAddress != address(0), \"Adapter does not exist\");\n            IProtocolAdapter adapter = IProtocolAdapter(adapterAddress);\n\n            if (adapter.purchaseMethod() == PurchaseMethod.ZeroEx) {\n                continue;\n            }\n\n            bool exists =\n                adapter.delegateOptionsExist(\n                    OptionTerms(\n                        underlying,\n                        strikeAsset,\n                        collateralAsset,\n                        expiry,\n                        strikePrices[i],\n                        optionTypes[i]\n                    )\n                );\n            require(exists, \"Options does not exist\");\n\n            totalPremium += adapter.delegatePremium(\n                OptionTerms(\n                    underlying,\n                    strikeAsset,\n                    collateralAsset,\n                    expiry,\n                    strikePrices[i],\n                    optionTypes[i]\n                ),\n                amounts[i]\n            );\n        }\n    }\n\n    function exerciseProfit(address account, uint256 positionID)\n        external\n        view\n        returns (uint256)\n    {\n        InstrumentPosition storage position =\n            instrumentPositions[account][positionID];\n\n        if (position.exercised) return 0;\n\n        uint256 profit = 0;\n\n        for (uint256 i = 0; i < position.venues.length; i++) {\n            string memory venue = position.venues[i];\n            uint256 strikePrice = position.strikePrices[i];\n            OptionType optionType = position.optionTypes[i];\n            uint256 optionID = position.optionIDs[i];\n            uint256 amount = position.amounts[i];\n\n            address adapterAddress = factory.getAdapter(venue);\n            require(adapterAddress != address(0), \"Adapter does not exist\");\n            IProtocolAdapter adapter = IProtocolAdapter(adapterAddress);\n            address options =\n                adapter.getOptionsAddress(\n                    OptionTerms(\n                        underlying,\n                        strikeAsset,\n                        collateralAsset,\n                        expiry,\n                        strikePrice,\n                        optionType\n                    )\n                );\n\n            bool exercisable = adapter.canExercise(options, optionID, amount);\n            if (!exercisable) {\n                continue;\n            }\n\n            profit += adapter.delegateExerciseProfit(options, optionID, amount);\n        }\n        return profit;\n    }\n\n    function canExercise(address account, uint256 positionID)\n        external\n        view\n        returns (bool)\n    {\n        InstrumentPosition storage position =\n            instrumentPositions[account][positionID];\n\n        if (position.exercised) return false;\n\n        bool eitherOneCanExercise = false;\n\n        for (uint256 i = 0; i < position.venues.length; i++) {\n            string memory venue = position.venues[i];\n            uint256 strikePrice = position.strikePrices[i];\n            OptionType optionType = position.optionTypes[i];\n            uint256 optionID = position.optionIDs[i];\n            uint256 amount = position.amounts[i];\n\n            address adapterAddress = factory.getAdapter(venue);\n            require(adapterAddress != address(0), \"Adapter does not exist\");\n            IProtocolAdapter adapter = IProtocolAdapter(adapterAddress);\n            address options =\n                adapter.getOptionsAddress(\n                    OptionTerms(\n                        underlying,\n                        strikeAsset,\n                        collateralAsset,\n                        expiry,\n                        strikePrice,\n                        optionType\n                    )\n                );\n\n            bool canExerciseOptions =\n                adapter.canExercise(options, optionID, amount);\n\n            if (canExerciseOptions) {\n                eitherOneCanExercise = true;\n            }\n        }\n        return eitherOneCanExercise;\n    }\n\n    /**\n     * @notice Buy instrument and create the underlying options positions\n     * @param venues array of venue names, e.g. \"HEGIC\", \"OPYN_V1\"\n     * @param amounts array of option purchase amounts\n     */\n    function buyInstrument(\n        string[] memory venues,\n        OptionType[] memory optionTypes,\n        uint256[] memory amounts,\n        uint256[] memory strikePrices,\n        bytes[] memory buyData\n    ) public payable nonReentrant returns (uint256 positionID) {\n        // require(venues.length >= 2, \"Must have at least 2 venues\");\n        require(block.timestamp < expiry, \"Cannot purchase after expiry\");\n\n        uint32[] memory optionIDs = new uint32[](venues.length);\n        bool seenCall = false;\n        bool seenPut = false;\n\n        for (uint256 i = 0; i < venues.length; i++) {\n            uint32 optionID =\n                purchaseOptionAtVenue(\n                    venues[i],\n                    optionTypes[i],\n                    amounts[i],\n                    strikePrices[i],\n                    buyData[i]\n                );\n\n            if (!seenPut && optionTypes[i] == OptionType.Put) {\n                seenPut = true;\n            } else if (!seenCall && optionTypes[i] == OptionType.Call) {\n                seenCall = true;\n            }\n            optionIDs[i] = optionID;\n        }\n\n        // require(seenCall && seenPut, \"Must have both put and call options\");\n\n        InstrumentPosition memory position =\n            InstrumentPosition(\n                false,\n                optionTypes,\n                optionIDs,\n                amounts,\n                strikePrices,\n                venues\n            );\n        positionID = instrumentPositions[msg.sender].length;\n        instrumentPositions[msg.sender].push(position);\n\n        emit PositionCreated(\n            msg.sender,\n            positionID,\n            venues,\n            optionTypes,\n            amounts,\n            optionIDs\n        );\n    }\n\n    function purchaseOptionAtVenue(\n        string memory venue,\n        OptionType optionType,\n        uint256 amount,\n        uint256 strikePrice,\n        bytes memory buyData\n    ) private returns (uint32 optionID) {\n        address adapterAddress = factory.getAdapter(venue);\n        require(adapterAddress != address(0), \"Adapter does not exist\");\n        IProtocolAdapter adapter = IProtocolAdapter(adapterAddress);\n\n        require(optionType != OptionType.Invalid, \"Invalid option type\");\n\n        PurchaseMethod purchaseMethod = adapter.purchaseMethod();\n\n        require(\n            purchaseMethod != PurchaseMethod.Invalid,\n            \"Invalid purchase method\"\n        );\n\n        if (purchaseMethod == PurchaseMethod.Contract) {\n            optionID = purchaseWithContract(\n                adapter,\n                optionType,\n                amount,\n                strikePrice\n            );\n        } else if (purchaseMethod == PurchaseMethod.ZeroEx) {\n            purchaseWithZeroEx(adapter, optionType, strikePrice, buyData);\n        }\n    }\n\n    function purchaseWithContract(\n        IProtocolAdapter adapter,\n        OptionType optionType,\n        uint256 amount,\n        uint256 strikePrice\n    ) private returns (uint32 optionID) {\n        OptionTerms memory optionTerms =\n            OptionTerms(\n                underlying,\n                strikeAsset,\n                collateralAsset,\n                expiry,\n                strikePrice,\n                optionType\n            );\n\n        uint256 premium = adapter.delegatePremium(optionTerms, amount);\n\n        // This only applies to ETH payments for now\n        // We have not enabled purchases using the underlying asset.\n        if (underlying == address(0)) {\n            require(\n                address(this).balance >= premium,\n                \"Value cannot cover premium\"\n            );\n        }\n\n        uint256 optionID256 = adapter.delegatePurchase(optionTerms, amount);\n        optionID = adapter.delegateNonFungible() ? uint32(optionID256) : 0;\n    }\n\n    function purchaseWithZeroEx(\n        IProtocolAdapter adapter,\n        OptionType optionType,\n        uint256 strikePrice,\n        bytes memory buyData\n    ) private {\n        OptionTerms memory optionTerms =\n            OptionTerms(\n                underlying,\n                strikeAsset,\n                collateralAsset,\n                expiry,\n                strikePrice,\n                optionType\n            );\n\n        ZeroExOrder memory zeroExOrder = abi.decode(buyData, (ZeroExOrder));\n\n        adapter.delegatePurchaseWithZeroEx(optionTerms, zeroExOrder);\n    }\n\n    function exercisePosition(uint256 positionID)\n        public\n        nonReentrant\n        returns (uint256 totalProfit)\n    {\n        InstrumentPosition storage position =\n            instrumentPositions[msg.sender][positionID];\n        require(!position.exercised, \"Already exercised\");\n\n        bool[] memory optionsExercised = new bool[](position.venues.length);\n\n        for (uint256 i = 0; i < position.venues.length; i++) {\n            IProtocolAdapter adapter =\n                IProtocolAdapter(factory.getAdapter(position.venues[i]));\n            OptionType optionType = position.optionTypes[i];\n            uint256 strikePrice = position.strikePrices[i];\n\n            address optionsAddress =\n                adapter.getOptionsAddress(\n                    OptionTerms(\n                        underlying,\n                        strikeAsset,\n                        collateralAsset,\n                        expiry,\n                        strikePrice,\n                        optionType\n                    )\n                );\n\n            require(optionsAddress != address(0), \"Options address must exist\");\n\n            uint256 profit =\n                adapter.delegateExerciseProfit(\n                    optionsAddress,\n                    position.optionIDs[i],\n                    position.amounts[i]\n                );\n            if (profit > 0) {\n                adapter.delegateExercise(\n                    optionsAddress,\n                    position.optionIDs[i],\n                    position.amounts[i],\n                    msg.sender\n                );\n                optionsExercised[i] = true;\n            } else {\n                optionsExercised[i] = false;\n            }\n            totalProfit += profit;\n        }\n        position.exercised = true;\n\n        emit Exercised(msg.sender, positionID, totalProfit, optionsExercised);\n    }\n\n    function dToken() external pure returns (address) {\n        return address(0);\n    }\n}"}}}