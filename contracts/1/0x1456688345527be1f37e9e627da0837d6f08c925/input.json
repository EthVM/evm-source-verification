{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"USDP.sol":{"content":"// File: contracts/VaultParameters.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n\r\n/**\r\n * @title Auth\r\n * @author Unit Protocol: Ivan Zakharov (@34x4p08)\r\n * @dev Manages USDP's system access\r\n **/\r\ncontract Auth {\r\n\r\n    // address of the the contract with vault parameters\r\n    VaultParameters public vaultParameters;\r\n\r\n    constructor(address _parameters) public {\r\n        vaultParameters = VaultParameters(_parameters);\r\n    }\r\n\r\n    // ensures tx's sender is a manager\r\n    modifier onlyManager() {\r\n        require(vaultParameters.isManager(msg.sender), \"Unit Protocol: AUTH_FAILED\");\r\n        _;\r\n    }\r\n\r\n    // ensures tx's sender is able to modify the Vault\r\n    modifier hasVaultAccess() {\r\n        require(vaultParameters.canModifyVault(msg.sender), \"Unit Protocol: AUTH_FAILED\");\r\n        _;\r\n    }\r\n\r\n    // ensures tx's sender is the Vault\r\n    modifier onlyVault() {\r\n        require(msg.sender == vaultParameters.vault(), \"Unit Protocol: AUTH_FAILED\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title VaultParameters\r\n * @author Unit Protocol: Ivan Zakharov (@34x4p08)\r\n **/\r\ncontract VaultParameters is Auth {\r\n\r\n    // map token to stability fee percentage; 3 decimals\r\n    mapping(address => uint) public stabilityFee;\r\n\r\n    // map token to liquidation fee percentage, 0 decimals\r\n    mapping(address => uint) public liquidationFee;\r\n\r\n    // map token to USDP mint limit\r\n    mapping(address => uint) public tokenDebtLimit;\r\n\r\n    // permissions to modify the Vault\r\n    mapping(address => bool) public canModifyVault;\r\n\r\n    // managers\r\n    mapping(address => bool) public isManager;\r\n\r\n    // enabled oracle types\r\n    mapping(uint => mapping (address => bool)) public isOracleTypeEnabled;\r\n\r\n    // address of the Vault\r\n    address payable public vault;\r\n\r\n    // The foundation address\r\n    address public foundation;\r\n\r\n    /**\r\n     * The address for an Ethereum contract is deterministically computed from the address of its creator (sender)\r\n     * and how many transactions the creator has sent (nonce). The sender and nonce are RLP encoded and then\r\n     * hashed with Keccak-256.\r\n     * Therefore, the Vault address can be pre-computed and passed as an argument before deployment.\r\n    **/\r\n    constructor(address payable _vault, address _foundation) public Auth(address(this)) {\r\n        require(_vault != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n        require(_foundation != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n\r\n        isManager[msg.sender] = true;\r\n        vault = _vault;\r\n        foundation = _foundation;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Grants and revokes manager's status of any address\r\n     * @param who The target address\r\n     * @param permit The permission flag\r\n     **/\r\n    function setManager(address who, bool permit) external onlyManager {\r\n        isManager[who] = permit;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the foundation address\r\n     * @param newFoundation The new foundation address\r\n     **/\r\n    function setFoundation(address newFoundation) external onlyManager {\r\n        require(newFoundation != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n        foundation = newFoundation;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets ability to use token as the main collateral\r\n     * @param asset The address of the main collateral token\r\n     * @param stabilityFeeValue The percentage of the year stability fee (3 decimals)\r\n     * @param liquidationFeeValue The liquidation fee percentage (0 decimals)\r\n     * @param usdpLimit The USDP token issue limit\r\n     * @param oracles The enables oracle types\r\n     **/\r\n    function setCollateral(\r\n        address asset,\r\n        uint stabilityFeeValue,\r\n        uint liquidationFeeValue,\r\n        uint usdpLimit,\r\n        uint[] calldata oracles\r\n    ) external onlyManager {\r\n        setStabilityFee(asset, stabilityFeeValue);\r\n        setLiquidationFee(asset, liquidationFeeValue);\r\n        setTokenDebtLimit(asset, usdpLimit);\r\n        for (uint i=0; i < oracles.length; i++) {\r\n            setOracleType(oracles[i], asset, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets a permission for an address to modify the Vault\r\n     * @param who The target address\r\n     * @param permit The permission flag\r\n     **/\r\n    function setVaultAccess(address who, bool permit) external onlyManager {\r\n        canModifyVault[who] = permit;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the percentage of the year stability fee for a particular collateral\r\n     * @param asset The address of the main collateral token\r\n     * @param newValue The stability fee percentage (3 decimals)\r\n     **/\r\n    function setStabilityFee(address asset, uint newValue) public onlyManager {\r\n        stabilityFee[asset] = newValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets the percentage of the liquidation fee for a particular collateral\r\n     * @param asset The address of the main collateral token\r\n     * @param newValue The liquidation fee percentage (0 decimals)\r\n     **/\r\n    function setLiquidationFee(address asset, uint newValue) public onlyManager {\r\n        require(newValue <= 100, \"Unit Protocol: VALUE_OUT_OF_RANGE\");\r\n        liquidationFee[asset] = newValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Enables/disables oracle types\r\n     * @param _type The type of the oracle\r\n     * @param asset The address of the main collateral token\r\n     * @param enabled The control flag\r\n     **/\r\n    function setOracleType(uint _type, address asset, bool enabled) public onlyManager {\r\n        isOracleTypeEnabled[_type][asset] = enabled;\r\n    }\r\n\r\n    /**\r\n     * @notice Only manager is able to call this function\r\n     * @dev Sets USDP limit for a specific collateral\r\n     * @param asset The address of the main collateral token\r\n     * @param limit The limit number\r\n     **/\r\n    function setTokenDebtLimit(address asset, uint limit) public onlyManager {\r\n        tokenDebtLimit[asset] = limit;\r\n    }\r\n}\r\n\r\n// File: contracts/helpers/SafeMath.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/USDP.sol\r\n\r\n/*\r\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\r\n*/\r\npragma solidity ^0.7.1;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title USDP token implementation\r\n * @author Unit Protocol: Ivan Zakharov (@34x4p08)\r\n * @dev ERC20 token\r\n **/\r\ncontract USDP is Auth {\r\n    using SafeMath for uint;\r\n\r\n    // name of the token\r\n    string public constant name = \"USDP Stablecoin\";\r\n\r\n    // symbol of the token\r\n    string public constant symbol = \"USDP\";\r\n\r\n    // version of the token\r\n    string public constant version = \"1\";\r\n\r\n    // number of decimals the token uses\r\n    uint8 public constant decimals = 18;\r\n\r\n    // total token supply\r\n    uint public totalSupply;\r\n\r\n    // balance information map\r\n    mapping(address => uint) public balanceOf;\r\n\r\n    // token allowance mapping\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    /**\r\n     * @dev Trigger on any successful call to approve(address spender, uint amount)\r\n    **/\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    /**\r\n     * @dev Trigger when tokens are transferred, including zero value transfers\r\n    **/\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    /**\r\n      * @param _parameters The address of system parameters contract\r\n     **/\r\n    constructor(address _parameters) public Auth(_parameters) {}\r\n\r\n    /**\r\n      * @notice Only Vault can mint USDP\r\n      * @dev Mints 'amount' of tokens to address 'to', and MUST fire the\r\n      * Transfer event\r\n      * @param to The address of the recipient\r\n      * @param amount The amount of token to be minted\r\n     **/\r\n    function mint(address to, uint amount) external onlyVault {\r\n        require(to != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n\r\n        balanceOf[to] = balanceOf[to].add(amount);\r\n        totalSupply = totalSupply.add(amount);\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    /**\r\n      * @notice Only manager can burn tokens from manager's balance\r\n      * @dev Burns 'amount' of tokens, and MUST fire the Transfer event\r\n      * @param amount The amount of token to be burned\r\n     **/\r\n    function burn(uint amount) external onlyManager {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n      * @notice Only Vault can burn tokens from any balance\r\n      * @dev Burns 'amount' of tokens from 'from' address, and MUST fire the Transfer event\r\n      * @param from The address of the balance owner\r\n      * @param amount The amount of token to be burned\r\n     **/\r\n    function burn(address from, uint amount) external onlyVault {\r\n        _burn(from, amount);\r\n    }\r\n\r\n    /**\r\n      * @dev Transfers 'amount' of tokens to address 'to', and MUST fire the Transfer event. The\r\n      * function SHOULD throw if the _from account balance does not have enough tokens to spend.\r\n      * @param to The address of the recipient\r\n      * @param amount The amount of token to be transferred\r\n     **/\r\n    function transfer(address to, uint amount) external returns (bool) {\r\n        return transferFrom(msg.sender, to, amount);\r\n    }\r\n\r\n    /**\r\n      * @dev Transfers 'amount' of tokens from address 'from' to address 'to', and MUST fire the\r\n      * Transfer event\r\n      * @param from The address of the sender\r\n      * @param to The address of the recipient\r\n      * @param amount The amount of token to be transferred\r\n     **/\r\n    function transferFrom(address from, address to, uint amount) public returns (bool) {\r\n        require(to != address(0), \"Unit Protocol: ZERO_ADDRESS\");\r\n        require(balanceOf[from] >= amount, \"Unit Protocol: INSUFFICIENT_BALANCE\");\r\n\r\n        if (from != msg.sender) {\r\n            require(allowance[from][msg.sender] >= amount, \"Unit Protocol: INSUFFICIENT_ALLOWANCE\");\r\n            _approve(from, msg.sender, allowance[from][msg.sender].sub(amount));\r\n        }\r\n        balanceOf[from] = balanceOf[from].sub(amount);\r\n        balanceOf[to] = balanceOf[to].add(amount);\r\n\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev Allows 'spender' to withdraw from your account multiple times, up to the 'amount' amount. If\r\n      * this function is called again it overwrites the current allowance with 'amount'.\r\n      * @param spender The address of the account able to transfer the tokens\r\n      * @param amount The amount of tokens to be approved for transfer\r\n     **/\r\n    function approve(address spender, uint amount) external returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint amount) internal virtual {\r\n        require(owner != address(0), \"Unit Protocol: approve from the zero address\");\r\n        require(spender != address(0), \"Unit Protocol: approve to the zero address\");\r\n\r\n        allowance[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _burn(address from, uint amount) internal virtual {\r\n        balanceOf[from] = balanceOf[from].sub(amount);\r\n        totalSupply = totalSupply.sub(amount);\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}"}}}