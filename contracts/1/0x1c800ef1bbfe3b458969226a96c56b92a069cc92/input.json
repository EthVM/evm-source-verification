{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/DSA/curveGaugeMapping.sol":{"content":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface ConnectorsInterface {\n  function chief(address) external view returns (bool);\n}\n\ninterface IndexInterface {\n  function master() external view returns (address);\n}\n\ncontract BytesHelper {\n  /**\n  * @dev Convert String to bytes32.\n  */\n  function stringToBytes32(string memory str) internal pure returns (bytes32 result) {\n    require(bytes(str).length != 0, \"String-Empty\");\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      result := mload(add(str, 32))\n    }\n  }\n}\n\ncontract Helpers is BytesHelper {\n  address public constant connectors = 0xD6A602C01a023B98Ecfb29Df02FBA380d3B21E0c;\n  address public constant instaIndex = 0x2971AdFa57b20E5a416aE5a708A8655A9c74f723;\n  uint public version = 1;\n\n  mapping (bytes32 => GaugeData) public gaugeMapping;\n\n  struct GaugeData {\n    address gaugeAddress;\n    bool rewardToken;\n  }\n\n  event LogAddGaugeMapping(\n    string gaugeName,\n    address gaugeAddress,\n    bool rewardToken\n  );\n\n  event LogRemoveGaugeMapping(\n    string gaugeName,\n    address gaugeAddress\n  );\n\n  modifier isChief virtual {\n    require(\n      ConnectorsInterface(connectors).chief(msg.sender) ||\n      IndexInterface(instaIndex).master() == msg.sender, \"not-Chief\");\n      _;\n  }\n\n  function _addGaugeMapping(\n    string memory gaugeName,\n    address gaugeAddress,\n    bool rewardToken\n  ) internal {\n    require(gaugeAddress != address(0), \"gaugeAddress-not-vaild\");\n    require(bytes(gaugeName).length <= 32, \"Length-exceeds\");\n    bytes32 gaugeType = stringToBytes32(gaugeName);\n    require(gaugeMapping[gaugeType].gaugeAddress == address(0), \"gaugePool-already-added\");\n\n    gaugeMapping[gaugeType].gaugeAddress = gaugeAddress;\n    gaugeMapping[gaugeType].rewardToken = rewardToken;\n\n    emit LogAddGaugeMapping(gaugeName, gaugeAddress, rewardToken);\n  }\n\n  function addGaugeMappings(\n    string[] memory gaugeNames,\n    address[] memory gaugeAddresses,\n    bool[] memory rewardTokens\n  ) public isChief {\n    require(gaugeNames.length == gaugeAddresses.length && gaugeAddresses.length == rewardTokens.length, \"length-not-match\");\n    for (uint32 i; i < gaugeNames.length; i++) {\n      _addGaugeMapping(gaugeNames[i], gaugeAddresses[i], rewardTokens[i]);\n    }\n  }\n\n  function removeGaugeMapping(string memory gaugeName, address gaugeAddress) public isChief {\n    require(gaugeAddress != address(0), \"gaugeAddress-not-vaild\");\n    bytes32 gaugeType = stringToBytes32(gaugeName);\n    require(gaugeMapping[gaugeType].gaugeAddress == gaugeAddress, \"different-gauge-pool\");\n\n    delete gaugeMapping[gaugeType];\n\n    emit LogRemoveGaugeMapping(\n      gaugeName,\n      gaugeAddress\n    );\n  }\n}\n\ncontract CurveGaugeMapping is Helpers {\n  string constant public name = \"Curve-Gauge-Mapping-v1\";\n\n  constructor (\n    string[] memory gaugeNames,\n    address[] memory gaugeAddresses,\n    bool[] memory rewardTokens\n  ) public {\n    require(gaugeNames.length == gaugeAddresses.length && gaugeAddresses.length == rewardTokens.length, \"length-not-match\");\n    for (uint32 i; i < gaugeNames.length; i++) {\n      _addGaugeMapping(gaugeNames[i], gaugeAddresses[i], rewardTokens[i]);\n    }\n  }\n}\n"}}}