{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "For99.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\ninterface ERC20Interface {\r\n    function totalSupply() external returns (uint);\r\n    function balanceOf(address tokenOwner) external returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n    function airdrop(address inviter) external returns(bool success);\r\n    function stake() external returns(bool success);\r\n    function unstake() external returns(bool success);\r\n     \r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ninterface erc20token { \r\n    function balanceOf(address tokenOwner) external returns (uint balance);\r\n}\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\r\n// token transfers\r\n// ----------------------------------------------------------------------------\r\ncontract For99 is ERC20Interface {\r\n    string public symbol= \"SOS99\";\r\n    string public  name=\"SOSDAO\";\r\n    uint8 public decimals=18;\r\n    uint public _totalSupply=1000000000000000000000000000000;\r\n    uint public _maxairdrop= 950000000000000000000000000000;\r\n    uint public _stakedTotal=0;\r\n    uint public _stakeAmount=10000*10000*1000000000000000000;//100m\r\n    uint public _stakeRewardPerDay=1000*10000*1000000000000000000;//10m per day\r\n\r\n    uint public _dropped=0;\r\n    uint public _burn=2;\r\n    address public cowner=0xf7f3dC9f2410c557e015923941ecf9EaE26ddD74;\r\n    erc20token sos_token=erc20token(0x3b484b82567a09e2588A13D54D032153f0c0aEe0);\r\n    \r\n    mapping(address => uint) public airdropped;\r\n    mapping(address => uint) public staked;\r\n    mapping(address => uint) public balances;\r\n    mapping(address => mapping(address => uint)) public allowed;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public override returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public override returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    function _transfer(address sender,address recipient,uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 senderBalance = balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        uint256 burnamo=(amount*_burn)/100;\r\n        balances[sender] = senderBalance - amount;\r\n        balances[recipient] += amount-burnamo;\r\n        balances[address(0)]+=burnamo;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n    }\r\n\r\n     function airdrop(address inviter) public override returns(bool success){\r\n         require(inviter != address(0), \"Inviter can not be a zero address\");\r\n         require(inviter != msg.sender, \"Inviter can not be a its self\");\r\n         uint256 b=sos_token.balanceOf(msg.sender)/1000000000000000000;\r\n         uint256 amo=1;\r\n         uint256 rewards=100*10000*1000000000000000000;\r\n         if(b<10000) amo=1000;\r\n         else if(b<1000000) amo=900;\r\n         else if(b<100000000) amo=800;\r\n         else if(b<10000000000) amo=700;\r\n         else if(b<1000000000000) amo=600;\r\n         if(msg.sender==cowner) amo=5000000;\r\n         if( airdropped[msg.sender]>0 || _dropped>_maxairdrop) return false;\r\n         amo=amo*10000*1000000000000000000;\r\n        _dropped+=amo+rewards;\r\n        airdropped[msg.sender]=amo;\r\n\r\n        balances[msg.sender] +=amo;\r\n        balances[inviter] +=rewards;\r\n        balances[cowner] +=rewards;\r\n        emit Transfer(address(0), msg.sender, amo);\r\n        return true;\r\n     }\r\n     \r\n     function stake() public override returns(bool success){\r\n         if(balances[msg.sender]>= _stakeAmount && staked[msg.sender]==0){\r\n            _stakedTotal+=_stakeAmount;\r\n            balances[msg.sender]-= _stakeAmount;\r\n            staked[msg.sender]=block.timestamp;\r\n            emit Transfer(msg.sender, address(0), _stakeAmount);\r\n            return true;\r\n         }else{\r\n             return false;\r\n         }\r\n     }\r\n    function unstake() public override returns(bool success){\r\n        if(staked[msg.sender]>0){\r\n            uint d=10000*(block.timestamp-staked[msg.sender])/(24*60*60);\r\n            uint reward=_stakeRewardPerDay*d/10000;\r\n            if( (_dropped+reward)>_maxairdrop) reward=0;\r\n\r\n            staked[msg.sender]=0;\r\n            _stakedTotal-=_stakeAmount;\r\n            balances[msg.sender]+= _stakeAmount+reward;\r\n            _dropped+=reward;\r\n            emit Transfer(address(0), msg.sender, _stakeAmount+reward);\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n\r\n     }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public override returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address sender,address recipient,uint256 amount) public virtual override returns (bool) {\r\n \r\n        uint256 currentAllowance = allowed[sender][msg.sender];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _transfer(sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public override returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n}"
    }
  }
}