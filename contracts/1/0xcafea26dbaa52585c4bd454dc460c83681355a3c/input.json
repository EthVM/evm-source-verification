{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"PooledStaking.sol":{"content":"\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts/abstract/INXMMaster.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\ncontract INXMMaster {\n\n  address public tokenAddress;\n\n  address public owner;\n\n  uint public pauseTime;\n\n  function delegateCallBack(bytes32 myid) external;\n\n  function masterInitialized() public view returns (bool);\n\n  function isInternal(address _add) public view returns (bool);\n\n  function isPause() public view returns (bool check);\n\n  function isOwner(address _add) public view returns (bool);\n\n  function isMember(address _add) public view returns (bool);\n\n  function checkIsAuthToGoverned(address _add) public view returns (bool);\n\n  function updatePauseTime(uint _time) public;\n\n  function dAppLocker() public view returns (address _add);\n\n  function dAppToken() public view returns (address _add);\n\n  function getLatestAddress(bytes2 _contractName) public view returns (address payable contractAddress);\n}\n\n// File: contracts/abstract/MasterAware.sol\n\n/*\n    Copyright (C) 2020 NexusMutual.io\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/\n*/\n\npragma solidity ^0.5.0;\n\n\ncontract MasterAware {\n\n  INXMMaster public master;\n\n  modifier onlyMember {\n    require(master.isMember(msg.sender), \"Caller is not a member\");\n    _;\n  }\n\n  modifier onlyInternal {\n    require(master.isInternal(msg.sender), \"Caller is not an internal contract\");\n    _;\n  }\n\n  modifier onlyMaster {\n    if (address(master) != address(0)) {\n      require(address(master) == msg.sender, \"Not master\");\n    }\n    _;\n  }\n\n  modifier onlyGovernance {\n    require(\n      master.checkIsAuthToGoverned(msg.sender),\n      \"Caller is not authorized to govern\"\n    );\n    _;\n  }\n\n  modifier whenPaused {\n    require(master.isPause(), \"System is not paused\");\n    _;\n  }\n\n  modifier whenNotPaused {\n    require(!master.isPause(), \"System is paused\");\n    _;\n  }\n\n  function changeMasterAddress(address masterAddress) public onlyMaster {\n    master = INXMMaster(masterAddress);\n  }\n}\n\n// File: contracts/interfaces/IPooledStaking.sol\n\npragma solidity ^0.5.0;\n\n\ninterface IPooledStaking {\n\n  function accumulateReward(address contractAddress, uint amount) external;\n\n  function pushBurn(address contractAddress, uint amount) external;\n\n  function hasPendingActions() external view returns (bool);\n\n  function contractStake(address contractAddress) external view returns (uint);\n\n  function stakerReward(address staker) external view returns (uint);\n\n  function stakerDeposit(address staker) external view returns (uint);\n\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint);\n\n  function withdraw(uint amount) external;\n\n  function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);\n\n  function withdrawReward(address stakerAddress) external;\n}\n\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/abstract/Iupgradable.sol\n\npragma solidity ^0.5.0;\n\n\ncontract Iupgradable {\n\n  INXMMaster public ms;\n  address public nxMasterAddress;\n\n  modifier onlyInternal {\n    require(ms.isInternal(msg.sender));\n    _;\n  }\n\n  modifier isMemberAndcheckPause {\n    require(ms.isPause() == false && ms.isMember(msg.sender) == true);\n    _;\n  }\n\n  modifier onlyOwner {\n    require(ms.isOwner(msg.sender));\n    _;\n  }\n\n  modifier checkPause {\n    require(ms.isPause() == false);\n    _;\n  }\n\n  modifier isMember {\n    require(ms.isMember(msg.sender), \"Not member\");\n    _;\n  }\n\n  /**\n   * @dev Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public;\n\n  /**\n   * @dev change master address\n   * @param _masterAddress is the new address\n   */\n  function changeMasterAddress(address _masterAddress) public {\n    if (address(ms) != address(0)) {\n      require(address(ms) == msg.sender, \"Not master\");\n    }\n\n    ms = INXMMaster(_masterAddress);\n    nxMasterAddress = _masterAddress;\n  }\n\n}\n\n// File: contracts/modules/cover/QuotationData.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\n\ncontract QuotationData is Iupgradable {\n  using SafeMath for uint;\n\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\n\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\n\n  struct Cover {\n    address payable memberAddress;\n    bytes4 currencyCode;\n    uint sumAssured;\n    uint16 coverPeriod;\n    uint validUntil;\n    address scAddress;\n    uint premiumNXM;\n  }\n\n  struct HoldCover {\n    uint holdCoverId;\n    address payable userAddress;\n    address scAddress;\n    bytes4 coverCurr;\n    uint[] coverDetails;\n    uint16 coverPeriod;\n  }\n\n  address public authQuoteEngine;\n\n  mapping(bytes4 => uint) internal currencyCSA;\n  mapping(address => uint[]) internal userCover;\n  mapping(address => uint[]) public userHoldedCover;\n  mapping(address => bool) public refundEligible;\n  mapping(address => mapping(bytes4 => uint)) internal currencyCSAOfSCAdd;\n  mapping(uint => uint8) public coverStatus;\n  mapping(uint => uint) public holdedCoverIDStatus;\n  mapping(uint => bool) public timestampRepeated;\n\n\n  Cover[] internal allCovers;\n  HoldCover[] internal allCoverHolded;\n\n  uint public stlp;\n  uint public stl;\n  uint public pm;\n  uint public minDays;\n  uint public tokensRetained;\n  address public kycAuthAddress;\n\n  event CoverDetailsEvent(\n    uint indexed cid,\n    address scAdd,\n    uint sumAssured,\n    uint expiry,\n    uint premium,\n    uint premiumNXM,\n    bytes4 curr\n  );\n\n  event CoverStatusEvent(uint indexed cid, uint8 statusNum);\n\n  constructor(address _authQuoteAdd, address _kycAuthAdd) public {\n    authQuoteEngine = _authQuoteAdd;\n    kycAuthAddress = _kycAuthAdd;\n    stlp = 90;\n    stl = 100;\n    pm = 30;\n    minDays = 30;\n    tokensRetained = 10;\n    allCovers.push(Cover(address(0), \"0x00\", 0, 0, 0, address(0), 0));\n    uint[] memory arr = new uint[](1);\n    allCoverHolded.push(HoldCover(0, address(0), address(0), 0x00, arr, 0));\n\n  }\n\n  /// @dev Adds the amount in Total Sum Assured of a given currency of a given smart contract address.\n  /// @param _add Smart Contract Address.\n  /// @param _amount Amount to be added.\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].add(_amount);\n  }\n\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency and smart contract address.\n  /// @param _add Smart Contract Address.\n  /// @param _amount Amount to be subtracted.\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\n    currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].sub(_amount);\n  }\n\n  /// @dev Subtracts the amount from Total Sum Assured of a given currency.\n  /// @param _curr Currency Name.\n  /// @param _amount Amount to be subtracted.\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\n    currencyCSA[_curr] = currencyCSA[_curr].sub(_amount);\n  }\n\n  /// @dev Adds the amount in Total Sum Assured of a given currency.\n  /// @param _curr Currency Name.\n  /// @param _amount Amount to be added.\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\n    currencyCSA[_curr] = currencyCSA[_curr].add(_amount);\n  }\n\n  /// @dev sets bit for timestamp to avoid replay attacks.\n  function setTimestampRepeated(uint _timestamp) external onlyInternal {\n    timestampRepeated[_timestamp] = true;\n  }\n\n  /// @dev Creates a blank new cover.\n  function addCover(\n    uint16 _coverPeriod,\n    uint _sumAssured,\n    address payable _userAddress,\n    bytes4 _currencyCode,\n    address _scAddress,\n    uint premium,\n    uint premiumNXM\n  )\n  external\n  onlyInternal\n  {\n    uint expiryDate = now.add(uint(_coverPeriod).mul(1 days));\n    allCovers.push(Cover(_userAddress, _currencyCode,\n      _sumAssured, _coverPeriod, expiryDate, _scAddress, premiumNXM));\n    uint cid = allCovers.length.sub(1);\n    userCover[_userAddress].push(cid);\n    emit CoverDetailsEvent(cid, _scAddress, _sumAssured, expiryDate, premium, premiumNXM, _currencyCode);\n  }\n\n  /// @dev create holded cover which will process after verdict of KYC.\n  function addHoldCover(\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] calldata coverDetails,\n    uint16 coverPeriod\n  )\n  external\n  onlyInternal\n  {\n    uint holdedCoverLen = allCoverHolded.length;\n    holdedCoverIDStatus[holdedCoverLen] = uint(HCIDStatus.kycPending);\n    allCoverHolded.push(HoldCover(holdedCoverLen, from, scAddress,\n      coverCurr, coverDetails, coverPeriod));\n    userHoldedCover[from].push(allCoverHolded.length.sub(1));\n\n  }\n\n  ///@dev sets refund eligible bit.\n  ///@param _add user address.\n  ///@param status indicates if user have pending kyc.\n  function setRefundEligible(address _add, bool status) external onlyInternal {\n    refundEligible[_add] = status;\n  }\n\n  /// @dev to set current status of particular holded coverID (1 for not completed KYC,\n  /// 2 for KYC passed, 3 for failed KYC or full refunded,\n  /// 4 for KYC completed but cover not processed)\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external onlyInternal {\n    holdedCoverIDStatus[holdedCoverID] = status;\n  }\n\n  /**\n   * @dev to set address of kyc authentication\n   * @param _add is the new address\n   */\n  function setKycAuthAddress(address _add) external onlyInternal {\n    kycAuthAddress = _add;\n  }\n\n  /// @dev Changes authorised address for generating quote off chain.\n  function changeAuthQuoteEngine(address _add) external onlyInternal {\n    authQuoteEngine = _add;\n  }\n\n  /**\n   * @dev Gets Uint Parameters of a code\n   * @param code whose details we want\n   * @return string value of the code\n   * @return associated amount (time or perc or value) to the code\n   */\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\n    codeVal = code;\n\n    if (code == \"STLP\") {\n      val = stlp;\n\n    } else if (code == \"STL\") {\n\n      val = stl;\n\n    } else if (code == \"PM\") {\n\n      val = pm;\n\n    } else if (code == \"QUOMIND\") {\n\n      val = minDays;\n\n    } else if (code == \"QUOTOK\") {\n\n      val = tokensRetained;\n\n    }\n\n  }\n\n  /// @dev Gets Product details.\n  /// @return  _minDays minimum cover period.\n  /// @return  _PM Profit margin.\n  /// @return  _STL short term Load.\n  /// @return  _STLP short term load period.\n  function getProductDetails()\n  external\n  view\n  returns (\n    uint _minDays,\n    uint _pm,\n    uint _stl,\n    uint _stlp\n  )\n  {\n\n    _minDays = minDays;\n    _pm = pm;\n    _stl = stl;\n    _stlp = stlp;\n  }\n\n  /// @dev Gets total number covers created till date.\n  function getCoverLength() external view returns (uint len) {\n    return (allCovers.length);\n  }\n\n  /// @dev Gets Authorised Engine address.\n  function getAuthQuoteEngine() external view returns (address _add) {\n    _add = authQuoteEngine;\n  }\n\n  /// @dev Gets the Total Sum Assured amount of a given currency.\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount) {\n    amount = currencyCSA[_curr];\n  }\n\n  /// @dev Gets all the Cover ids generated by a given address.\n  /// @param _add User's address.\n  /// @return allCover array of covers.\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover) {\n    return (userCover[_add]);\n  }\n\n  /// @dev Gets total number of covers generated by a given address\n  function getUserCoverLength(address _add) external view returns (uint len) {\n    len = userCover[_add].length;\n  }\n\n  /// @dev Gets the status of a given cover.\n  function getCoverStatusNo(uint _cid) external view returns (uint8) {\n    return coverStatus[_cid];\n  }\n\n  /// @dev Gets the Cover Period (in days) of a given cover.\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp) {\n    cp = allCovers[_cid].coverPeriod;\n  }\n\n  /// @dev Gets the Sum Assured Amount of a given cover.\n  function getCoverSumAssured(uint _cid) external view returns (uint sa) {\n    sa = allCovers[_cid].sumAssured;\n  }\n\n  /// @dev Gets the Currency Name in which a given cover is assured.\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr) {\n    curr = allCovers[_cid].currencyCode;\n  }\n\n  /// @dev Gets the validity date (timestamp) of a given cover.\n  function getValidityOfCover(uint _cid) external view returns (uint date) {\n    date = allCovers[_cid].validUntil;\n  }\n\n  /// @dev Gets Smart contract address of cover.\n  function getscAddressOfCover(uint _cid) external view returns (uint, address) {\n    return (_cid, allCovers[_cid].scAddress);\n  }\n\n  /// @dev Gets the owner address of a given cover.\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add) {\n    _add = allCovers[_cid].memberAddress;\n  }\n\n  /// @dev Gets the premium amount of a given cover in NXM.\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM) {\n    _premiumNXM = allCovers[_cid].premiumNXM;\n  }\n\n  /// @dev Provides the details of a cover Id\n  /// @param _cid cover Id\n  /// @return memberAddress cover user address.\n  /// @return scAddress smart contract Address\n  /// @return currencyCode currency of cover\n  /// @return sumAssured sum assured of cover\n  /// @return premiumNXM premium in NXM\n  function getCoverDetailsByCoverID1(\n    uint _cid\n  )\n  external\n  view\n  returns (\n    uint cid,\n    address _memberAddress,\n    address _scAddress,\n    bytes4 _currencyCode,\n    uint _sumAssured,\n    uint premiumNXM\n  )\n  {\n    return (\n    _cid,\n    allCovers[_cid].memberAddress,\n    allCovers[_cid].scAddress,\n    allCovers[_cid].currencyCode,\n    allCovers[_cid].sumAssured,\n    allCovers[_cid].premiumNXM\n    );\n  }\n\n  /// @dev Provides details of a cover Id\n  /// @param _cid cover Id\n  /// @return status status of cover.\n  /// @return sumAssured Sum assurance of cover.\n  /// @return coverPeriod Cover Period of cover (in days).\n  /// @return validUntil is validity of cover.\n  function getCoverDetailsByCoverID2(\n    uint _cid\n  )\n  external\n  view\n  returns (\n    uint cid,\n    uint8 status,\n    uint sumAssured,\n    uint16 coverPeriod,\n    uint validUntil\n  )\n  {\n\n    return (\n    _cid,\n    coverStatus[_cid],\n    allCovers[_cid].sumAssured,\n    allCovers[_cid].coverPeriod,\n    allCovers[_cid].validUntil\n    );\n  }\n\n  /// @dev Provides details of a holded cover Id\n  /// @param _hcid holded cover Id\n  /// @return scAddress SmartCover address of cover.\n  /// @return coverCurr currency of cover.\n  /// @return coverPeriod Cover Period of cover (in days).\n  function getHoldedCoverDetailsByID1(\n    uint _hcid\n  )\n  external\n  view\n  returns (\n    uint hcid,\n    address scAddress,\n    bytes4 coverCurr,\n    uint16 coverPeriod\n  )\n  {\n    return (\n    _hcid,\n    allCoverHolded[_hcid].scAddress,\n    allCoverHolded[_hcid].coverCurr,\n    allCoverHolded[_hcid].coverPeriod\n    );\n  }\n\n  /// @dev Gets total number holded covers created till date.\n  function getUserHoldedCoverLength(address _add) external view returns (uint) {\n    return userHoldedCover[_add].length;\n  }\n\n  /// @dev Gets holded cover index by index of user holded covers.\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint) {\n    return userHoldedCover[_add][index];\n  }\n\n  /// @dev Provides the details of a holded cover Id\n  /// @param _hcid holded cover Id\n  /// @return memberAddress holded cover user address.\n  /// @return coverDetails array contains SA, Cover Currency Price,Price in NXM, Expiration time of Qoute.\n  function getHoldedCoverDetailsByID2(\n    uint _hcid\n  )\n  external\n  view\n  returns (\n    uint hcid,\n    address payable memberAddress,\n    uint[] memory coverDetails\n  )\n  {\n    return (\n    _hcid,\n    allCoverHolded[_hcid].userAddress,\n    allCoverHolded[_hcid].coverDetails\n    );\n  }\n\n  /// @dev Gets the Total Sum Assured amount of a given currency and smart contract address.\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount) {\n    amount = currencyCSAOfSCAdd[_add][_curr];\n  }\n\n  //solhint-disable-next-line\n  function changeDependentContractAddress() public {}\n\n  /// @dev Changes the status of a given cover.\n  /// @param _cid cover Id.\n  /// @param _stat New status.\n  function changeCoverStatusNo(uint _cid, uint8 _stat) public onlyInternal {\n    coverStatus[_cid] = _stat;\n    emit CoverStatusEvent(_cid, _stat);\n  }\n\n  /**\n   * @dev Updates Uint Parameters of a code\n   * @param code whose details we want to update\n   * @param val value to set\n   */\n  function updateUintParameters(bytes8 code, uint val) public {\n\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    if (code == \"STLP\") {\n      _changeSTLP(val);\n\n    } else if (code == \"STL\") {\n\n      _changeSTL(val);\n\n    } else if (code == \"PM\") {\n\n      _changePM(val);\n\n    } else if (code == \"QUOMIND\") {\n\n      _changeMinDays(val);\n\n    } else if (code == \"QUOTOK\") {\n\n      _setTokensRetained(val);\n\n    } else {\n\n      revert(\"Invalid param code\");\n    }\n\n  }\n\n  /// @dev Changes the existing Profit Margin value\n  function _changePM(uint _pm) internal {\n    pm = _pm;\n  }\n\n  /// @dev Changes the existing Short Term Load Period (STLP) value.\n  function _changeSTLP(uint _stlp) internal {\n    stlp = _stlp;\n  }\n\n  /// @dev Changes the existing Short Term Load (STL) value.\n  function _changeSTL(uint _stl) internal {\n    stl = _stl;\n  }\n\n  /// @dev Changes the existing Minimum cover period (in days)\n  function _changeMinDays(uint _days) internal {\n    minDays = _days;\n  }\n\n  /**\n   * @dev to set the the amount of tokens retained\n   * @param val is the amount retained\n   */\n  function _setTokensRetained(uint val) internal {\n    tokensRetained = val;\n  }\n}\n\n// File: contracts/modules/token/external/OZIERC20.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface OZIERC20 {\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value)\n  external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value)\n  external returns (bool);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external view returns (uint256);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: contracts/modules/token/external/OZSafeMath.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary OZSafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n// File: contracts/modules/token/NXMToken.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\n\ncontract NXMToken is OZIERC20 {\n  using OZSafeMath for uint256;\n\n  event WhiteListed(address indexed member);\n\n  event BlackListed(address indexed member);\n\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowed;\n\n  mapping(address => bool) public whiteListed;\n\n  mapping(address => uint) public isLockedForMV;\n\n  uint256 private _totalSupply;\n\n  string public name = \"NXM\";\n  string public symbol = \"NXM\";\n  uint8 public decimals = 18;\n  address public operator;\n\n  modifier canTransfer(address _to) {\n    require(whiteListed[_to]);\n    _;\n  }\n\n  modifier onlyOperator() {\n    if (operator != address(0))\n      require(msg.sender == operator);\n    _;\n  }\n\n  constructor(address _founderAddress, uint _initialSupply) public {\n    _mint(_founderAddress, _initialSupply);\n  }\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param owner The address to query the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n  /**\n  * @dev Function to check the amount of tokens that an owner allowed to a spender.\n  * @param owner address The address which owns the funds.\n  * @param spender address The address which will spend the funds.\n  * @return A uint256 specifying the amount of tokens still available for the spender.\n  */\n  function allowance(\n    address owner,\n    address spender\n  )\n  public\n  view\n  returns (uint256)\n  {\n    return _allowed[owner][spender];\n  }\n\n  /**\n  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n  * Beware that changing an allowance with this method brings the risk that someone may use both the old\n  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n  * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n  * @param spender The address which will spend the funds.\n  * @param value The amount of tokens to be spent.\n  */\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n  * @dev Increase the amount of tokens that an owner allowed to a spender.\n  * approve should be called when allowed_[_spender] == 0. To increment\n  * allowed value is better to use this function to avoid 2 calls (and wait until\n  * the first transaction is mined)\n  * From MonolithDAO Token.sol\n  * @param spender The address which will spend the funds.\n  * @param addedValue The amount of tokens to increase the allowance by.\n  */\n  function increaseAllowance(\n    address spender,\n    uint256 addedValue\n  )\n  public\n  returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n    _allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n  * @dev Decrease the amount of tokens that an owner allowed to a spender.\n  * approve should be called when allowed_[_spender] == 0. To decrement\n  * allowed value is better to use this function to avoid 2 calls (and wait until\n  * the first transaction is mined)\n  * From MonolithDAO Token.sol\n  * @param spender The address which will spend the funds.\n  * @param subtractedValue The amount of tokens to decrease the allowance by.\n  */\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  )\n  public\n  returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n    _allowed[msg.sender][spender].sub(subtractedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n  * @dev Adds a user to whitelist\n  * @param _member address to add to whitelist\n  */\n  function addToWhiteList(address _member) public onlyOperator returns (bool) {\n    whiteListed[_member] = true;\n    emit WhiteListed(_member);\n    return true;\n  }\n\n  /**\n  * @dev removes a user from whitelist\n  * @param _member address to remove from whitelist\n  */\n  function removeFromWhiteList(address _member) public onlyOperator returns (bool) {\n    whiteListed[_member] = false;\n    emit BlackListed(_member);\n    return true;\n  }\n\n  /**\n  * @dev change operator address\n  * @param _newOperator address of new operator\n  */\n  function changeOperator(address _newOperator) public onlyOperator returns (bool) {\n    operator = _newOperator;\n    return true;\n  }\n\n  /**\n  * @dev burns an amount of the tokens of the message sender\n  * account.\n  * @param amount The amount that will be burnt.\n  */\n  function burn(uint256 amount) public returns (bool) {\n    _burn(msg.sender, amount);\n    return true;\n  }\n\n  /**\n  * @dev Burns a specific amount of tokens from the target address and decrements allowance\n  * @param from address The address which you want to send tokens from\n  * @param value uint256 The amount of token to be burned\n  */\n  function burnFrom(address from, uint256 value) public returns (bool) {\n    _burnFrom(from, value);\n    return true;\n  }\n\n  /**\n  * @dev function that mints an amount of the token and assigns it to\n  * an account.\n  * @param account The account that will receive the created tokens.\n  * @param amount The amount that will be created.\n  */\n  function mint(address account, uint256 amount) public onlyOperator {\n    _mint(account, amount);\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function transfer(address to, uint256 value) public canTransfer(to) returns (bool) {\n\n    require(isLockedForMV[msg.sender] < now); // if not voted under governance\n    require(value <= _balances[msg.sender]);\n    _transfer(to, value);\n    return true;\n  }\n\n  /**\n  * @dev Transfer tokens to the operator from the specified address\n  * @param from The address to transfer from.\n  * @param value The amount to be transferred.\n  */\n  function operatorTransfer(address from, uint256 value) public onlyOperator returns (bool) {\n    require(value <= _balances[from]);\n    _transferFrom(from, operator, value);\n    return true;\n  }\n\n  /**\n  * @dev Transfer tokens from one address to another\n  * @param from address The address which you want to send tokens from\n  * @param to address The address which you want to transfer to\n  * @param value uint256 the amount of tokens to be transferred\n  */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n  public\n  canTransfer(to)\n  returns (bool)\n  {\n    require(isLockedForMV[from] < now); // if not voted under governance\n    require(value <= _balances[from]);\n    require(value <= _allowed[from][msg.sender]);\n    _transferFrom(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Lock the user's tokens\n   * @param _of user's address.\n   */\n  function lockForMemberVote(address _of, uint _days) public onlyOperator {\n    if (_days.add(now) > isLockedForMV[_of])\n      isLockedForMV[_of] = _days.add(now);\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function _transfer(address to, uint256 value) internal {\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(msg.sender, to, value);\n  }\n\n  /**\n  * @dev Transfer tokens from one address to another\n  * @param from address The address which you want to send tokens from\n  * @param to address The address which you want to transfer to\n  * @param value uint256 the amount of tokens to be transferred\n  */\n  function _transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n  internal\n  {\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    emit Transfer(from, to, value);\n  }\n\n  /**\n  * @dev Internal function that mints an amount of the token and assigns it to\n  * an account. This encapsulates the modification of balances such that the\n  * proper events are emitted.\n  * @param account The account that will receive the created tokens.\n  * @param amount The amount that will be created.\n  */\n  function _mint(address account, uint256 amount) internal {\n    require(account != address(0));\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n  * @dev Internal function that burns an amount of the token of a given\n  * account.\n  * @param account The account whose tokens will be burnt.\n  * @param amount The amount that will be burnt.\n  */\n  function _burn(address account, uint256 amount) internal {\n    require(amount <= _balances[account]);\n\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[account] = _balances[account].sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n  * @dev Internal function that burns an amount of the token of a given\n  * account, deducting from the sender's allowance for said account. Uses the\n  * internal burn function.\n  * @param account The account whose tokens will be burnt.\n  * @param value The amount that will be burnt.\n  */\n  function _burnFrom(address account, uint256 value) internal {\n    require(value <= _allowed[account][msg.sender]);\n\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n    // this function needs to emit an event with the updated approval.\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n      value);\n    _burn(account, value);\n  }\n}\n\n// File: contracts/modules/token/external/IERC1132.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title ERC1132 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1132\n */\n\ncontract IERC1132 {\n  /**\n   * @dev Reasons why a user's tokens have been locked\n   */\n  mapping(address => bytes32[]) public lockReason;\n\n  /**\n   * @dev locked token structure\n   */\n  struct LockToken {\n    uint256 amount;\n    uint256 validity;\n    bool claimed;\n  }\n\n  /**\n   * @dev Holds number & validity of tokens locked for a given reason for\n   *      a specified address\n   */\n  mapping(address => mapping(bytes32 => LockToken)) public locked;\n\n  /**\n   * @dev Records data of all the tokens Locked\n   */\n  event Locked(\n    address indexed _of,\n    bytes32 indexed _reason,\n    uint256 _amount,\n    uint256 _validity\n  );\n\n  /**\n   * @dev Records data of all the tokens unlocked\n   */\n  event Unlocked(\n    address indexed _of,\n    bytes32 indexed _reason,\n    uint256 _amount\n  );\n\n  /**\n   * @dev Locks a specified amount of tokens against an address,\n   *      for a specified reason and time\n   * @param _reason The reason to lock tokens\n   * @param _amount Number of tokens to be locked\n   * @param _time Lock time in seconds\n   */\n  function lock(bytes32 _reason, uint256 _amount, uint256 _time)\n  public returns (bool);\n\n  /**\n   * @dev Returns tokens locked for a specified address for a\n   *      specified reason\n   *\n   * @param _of The address whose tokens are locked\n   * @param _reason The reason to query the lock tokens for\n   */\n  function tokensLocked(address _of, bytes32 _reason)\n  public view returns (uint256 amount);\n\n  /**\n   * @dev Returns tokens locked for a specified address for a\n   *      specified reason at a specific time\n   *\n   * @param _of The address whose tokens are locked\n   * @param _reason The reason to query the lock tokens for\n   * @param _time The timestamp to query the lock tokens for\n   */\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\n  public view returns (uint256 amount);\n\n  /**\n   * @dev Returns total tokens held by an address (locked + transferable)\n   * @param _of The address to query the total balance of\n   */\n  function totalBalanceOf(address _of)\n  public view returns (uint256 amount);\n\n  /**\n   * @dev Extends lock for a specified reason and time\n   * @param _reason The reason to lock tokens\n   * @param _time Lock extension time in seconds\n   */\n  function extendLock(bytes32 _reason, uint256 _time)\n  public returns (bool);\n\n  /**\n   * @dev Increase number of tokens locked for a specified reason\n   * @param _reason The reason to lock tokens\n   * @param _amount Number of tokens to be increased\n   */\n  function increaseLockAmount(bytes32 _reason, uint256 _amount)\n  public returns (bool);\n\n  /**\n   * @dev Returns unlockable tokens for a specified address for a specified reason\n   * @param _of The address to query the the unlockable token count of\n   * @param _reason The reason to query the unlockable tokens for\n   */\n  function tokensUnlockable(address _of, bytes32 _reason)\n  public view returns (uint256 amount);\n\n  /**\n   * @dev Unlocks the unlockable tokens of a specified address\n   * @param _of Address of user, claiming back unlockable tokens\n   */\n  function unlock(address _of)\n  public returns (uint256 unlockableTokens);\n\n  /**\n   * @dev Gets the unlockable tokens of a specified address\n   * @param _of The address to query the the unlockable token count of\n   */\n  function getUnlockableTokens(address _of)\n  public view returns (uint256 unlockableTokens);\n\n}\n\n// File: contracts/modules/token/TokenController.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\ncontract TokenController is IERC1132, Iupgradable {\n  using SafeMath for uint256;\n\n  event Burned(address indexed member, bytes32 lockedUnder, uint256 amount);\n\n  NXMToken public token;\n  IPooledStaking public pooledStaking;\n  uint public minCALockTime = uint(30).mul(1 days);\n  bytes32 private constant CLA = bytes32(\"CLA\");\n\n  /**\n  * @dev Just for interface\n  */\n  function changeDependentContractAddress() public {\n    token = NXMToken(ms.tokenAddress());\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\"PS\"));\n  }\n\n  /**\n   * @dev to change the operator address\n   * @param _newOperator is the new address of operator\n   */\n  function changeOperator(address _newOperator) public onlyInternal {\n    token.changeOperator(_newOperator);\n  }\n\n  /**\n   * @dev Proxies token transfer through this contract to allow staking when members are locked for voting\n   * @param _from   Source address\n   * @param _to     Destination address\n   * @param _value  Amount to transfer\n   */\n  function operatorTransfer(address _from, address _to, uint _value) onlyInternal external returns (bool) {\n    require(msg.sender == address(pooledStaking), \"Call is only allowed from PooledStaking address\");\n    require(token.operatorTransfer(_from, _value), \"Operator transfer failed\");\n    require(token.transfer(_to, _value), \"Internal transfer failed\");\n    return true;\n  }\n\n  /**\n  * @dev Locks a specified amount of tokens,\n  *    for CLA reason and for a specified time\n  * @param _reason The reason to lock tokens, currently restricted to CLA\n  * @param _amount Number of tokens to be locked\n  * @param _time Lock time in seconds\n  */\n  function lock(bytes32 _reason, uint256 _amount, uint256 _time) public checkPause returns (bool)\n  {\n    require(_reason == CLA, \"Restricted to reason CLA\");\n    require(minCALockTime <= _time, \"Should lock for minimum time\");\n    // If tokens are already locked, then functions extendLock or\n    // increaseLockAmount should be used to make any changes\n    _lock(msg.sender, _reason, _amount, _time);\n    return true;\n  }\n\n  /**\n  * @dev Locks a specified amount of tokens against an address,\n  *    for a specified reason and time\n  * @param _reason The reason to lock tokens\n  * @param _amount Number of tokens to be locked\n  * @param _time Lock time in seconds\n  * @param _of address whose tokens are to be locked\n  */\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time)\n  public\n  onlyInternal\n  returns (bool)\n  {\n    // If tokens are already locked, then functions extendLock or\n    // increaseLockAmount should be used to make any changes\n    _lock(_of, _reason, _amount, _time);\n    return true;\n  }\n\n  /**\n  * @dev Extends lock for reason CLA for a specified time\n  * @param _reason The reason to lock tokens, currently restricted to CLA\n  * @param _time Lock extension time in seconds\n  */\n  function extendLock(bytes32 _reason, uint256 _time)\n  public\n  checkPause\n  returns (bool)\n  {\n    require(_reason == CLA, \"Restricted to reason CLA\");\n    _extendLock(msg.sender, _reason, _time);\n    return true;\n  }\n\n  /**\n  * @dev Extends lock for a specified reason and time\n  * @param _reason The reason to lock tokens\n  * @param _time Lock extension time in seconds\n  */\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time)\n  public\n  onlyInternal\n  returns (bool)\n  {\n    _extendLock(_of, _reason, _time);\n    return true;\n  }\n\n  /**\n  * @dev Increase number of tokens locked for a CLA reason\n  * @param _reason The reason to lock tokens, currently restricted to CLA\n  * @param _amount Number of tokens to be increased\n  */\n  function increaseLockAmount(bytes32 _reason, uint256 _amount)\n  public\n  checkPause\n  returns (bool)\n  {\n    require(_reason == CLA, \"Restricted to reason CLA\");\n    require(_tokensLocked(msg.sender, _reason) > 0);\n    token.operatorTransfer(msg.sender, _amount);\n\n    locked[msg.sender][_reason].amount = locked[msg.sender][_reason].amount.add(_amount);\n    emit Locked(msg.sender, _reason, _amount, locked[msg.sender][_reason].validity);\n    return true;\n  }\n\n  /**\n   * @dev burns tokens of an address\n   * @param _of is the address to burn tokens of\n   * @param amount is the amount to burn\n   * @return the boolean status of the burning process\n   */\n  function burnFrom(address _of, uint amount) public onlyInternal returns (bool) {\n    return token.burnFrom(_of, amount);\n  }\n\n  /**\n  * @dev Burns locked tokens of a user\n  * @param _of address whose tokens are to be burned\n  * @param _reason lock reason for which tokens are to be burned\n  * @param _amount amount of tokens to burn\n  */\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) public onlyInternal {\n    _burnLockedTokens(_of, _reason, _amount);\n  }\n\n  /**\n  * @dev reduce lock duration for a specified reason and time\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to lock tokens\n  * @param _time Lock reduction time in seconds\n  */\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) public onlyInternal {\n    _reduceLock(_of, _reason, _time);\n  }\n\n  /**\n  * @dev Released locked tokens of an address locked for a specific reason\n  * @param _of address whose tokens are to be released from lock\n  * @param _reason reason of the lock\n  * @param _amount amount of tokens to release\n  */\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount)\n  public\n  onlyInternal\n  {\n    _releaseLockedTokens(_of, _reason, _amount);\n  }\n\n  /**\n  * @dev Adds an address to whitelist maintained in the contract\n  * @param _member address to add to whitelist\n  */\n  function addToWhitelist(address _member) public onlyInternal {\n    token.addToWhiteList(_member);\n  }\n\n  /**\n  * @dev Removes an address from the whitelist in the token\n  * @param _member address to remove\n  */\n  function removeFromWhitelist(address _member) public onlyInternal {\n    token.removeFromWhiteList(_member);\n  }\n\n  /**\n  * @dev Mints new token for an address\n  * @param _member address to reward the minted tokens\n  * @param _amount number of tokens to mint\n  */\n  function mint(address _member, uint _amount) public onlyInternal {\n    token.mint(_member, _amount);\n  }\n\n  /**\n   * @dev Lock the user's tokens\n   * @param _of user's address.\n   */\n  function lockForMemberVote(address _of, uint _days) public onlyInternal {\n    token.lockForMemberVote(_of, _days);\n  }\n\n  /**\n  * @dev Unlocks the unlockable tokens against CLA of a specified address\n  * @param _of Address of user, claiming back unlockable tokens against CLA\n  */\n  function unlock(address _of)\n  public\n  checkPause\n  returns (uint256 unlockableTokens)\n  {\n    unlockableTokens = _tokensUnlockable(_of, CLA);\n    if (unlockableTokens > 0) {\n      locked[_of][CLA].claimed = true;\n      emit Unlocked(_of, CLA, unlockableTokens);\n      require(token.transfer(_of, unlockableTokens));\n    }\n  }\n\n  /**\n   * @dev Updates Uint Parameters of a code\n   * @param code whose details we want to update\n   * @param val value to set\n   */\n  function updateUintParameters(bytes8 code, uint val) public {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    if (code == \"MNCLT\") {\n      minCALockTime = val.mul(1 days);\n    } else {\n      revert(\"Invalid param code\");\n    }\n  }\n\n  /**\n  * @dev Gets the validity of locked tokens of a specified address\n  * @param _of The address to query the validity\n  * @param reason reason for which tokens were locked\n  */\n  function getLockedTokensValidity(address _of, bytes32 reason)\n  public\n  view\n  returns (uint256 validity)\n  {\n    validity = locked[_of][reason].validity;\n  }\n\n  /**\n  * @dev Gets the unlockable tokens of a specified address\n  * @param _of The address to query the the unlockable token count of\n  */\n  function getUnlockableTokens(address _of)\n  public\n  view\n  returns (uint256 unlockableTokens)\n  {\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\n      unlockableTokens = unlockableTokens.add(_tokensUnlockable(_of, lockReason[_of][i]));\n    }\n  }\n\n  /**\n  * @dev Returns tokens locked for a specified address for a\n  *    specified reason\n  *\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to query the lock tokens for\n  */\n  function tokensLocked(address _of, bytes32 _reason)\n  public\n  view\n  returns (uint256 amount)\n  {\n    return _tokensLocked(_of, _reason);\n  }\n\n  /**\n  * @dev Returns unlockable tokens for a specified address for a specified reason\n  * @param _of The address to query the the unlockable token count of\n  * @param _reason The reason to query the unlockable tokens for\n  */\n  function tokensUnlockable(address _of, bytes32 _reason)\n  public\n  view\n  returns (uint256 amount)\n  {\n    return _tokensUnlockable(_of, _reason);\n  }\n\n  function totalSupply() public view returns (uint256)\n  {\n    return token.totalSupply();\n  }\n\n  /**\n  * @dev Returns tokens locked for a specified address for a\n  *    specified reason at a specific time\n  *\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to query the lock tokens for\n  * @param _time The timestamp to query the lock tokens for\n  */\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\n  public\n  view\n  returns (uint256 amount)\n  {\n    return _tokensLockedAtTime(_of, _reason, _time);\n  }\n\n  /**\n  * @dev Returns the total amount of tokens held by an address:\n  *   transferable + locked + staked for pooled staking - pending burns.\n  *   Used by Claims and Governance in member voting to calculate the user's vote weight.\n  *\n  * @param _of The address to query the total balance of\n  * @param _of The address to query the total balance of\n  */\n  function totalBalanceOf(address _of) public view returns (uint256 amount) {\n\n    amount = token.balanceOf(_of);\n\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\n      amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\n    }\n\n    uint stakerReward = pooledStaking.stakerReward(_of);\n    uint stakerDeposit = pooledStaking.stakerDeposit(_of);\n\n    amount = amount.add(stakerDeposit).add(stakerReward);\n  }\n\n  /**\n  * @dev Returns the total locked tokens at time\n  *   Returns the total amount of locked and staked tokens at a given time. Used by MemberRoles to check eligibility\n  *   for withdraw / switch membership. Includes tokens locked for Claim Assessment and staked for Risk Assessment.\n  *   Does not take into account pending burns.\n  *\n  * @param _of member whose locked tokens are to be calculate\n  * @param _time timestamp when the tokens should be locked\n  */\n  function totalLockedBalance(address _of, uint256 _time) public view returns (uint256 amount) {\n\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\n      amount = amount.add(_tokensLockedAtTime(_of, lockReason[_of][i], _time));\n    }\n\n    amount = amount.add(pooledStaking.stakerDeposit(_of));\n  }\n\n  /**\n  * @dev Locks a specified amount of tokens against an address,\n  *    for a specified reason and time\n  * @param _of address whose tokens are to be locked\n  * @param _reason The reason to lock tokens\n  * @param _amount Number of tokens to be locked\n  * @param _time Lock time in seconds\n  */\n  function _lock(address _of, bytes32 _reason, uint256 _amount, uint256 _time) internal {\n    require(_tokensLocked(_of, _reason) == 0);\n    require(_amount != 0);\n\n    if (locked[_of][_reason].amount == 0) {\n      lockReason[_of].push(_reason);\n    }\n\n    require(token.operatorTransfer(_of, _amount));\n\n    uint256 validUntil = now.add(_time); // solhint-disable-line\n    locked[_of][_reason] = LockToken(_amount, validUntil, false);\n    emit Locked(_of, _reason, _amount, validUntil);\n  }\n\n  /**\n  * @dev Returns tokens locked for a specified address for a\n  *    specified reason\n  *\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to query the lock tokens for\n  */\n  function _tokensLocked(address _of, bytes32 _reason)\n  internal\n  view\n  returns (uint256 amount)\n  {\n    if (!locked[_of][_reason].claimed) {\n      amount = locked[_of][_reason].amount;\n    }\n  }\n\n  /**\n  * @dev Returns tokens locked for a specified address for a\n  *    specified reason at a specific time\n  *\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to query the lock tokens for\n  * @param _time The timestamp to query the lock tokens for\n  */\n  function _tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\n  internal\n  view\n  returns (uint256 amount)\n  {\n    if (locked[_of][_reason].validity > _time) {\n      amount = locked[_of][_reason].amount;\n    }\n  }\n\n  /**\n  * @dev Extends lock for a specified reason and time\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to lock tokens\n  * @param _time Lock extension time in seconds\n  */\n  function _extendLock(address _of, bytes32 _reason, uint256 _time) internal {\n    require(_tokensLocked(_of, _reason) > 0);\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\n    locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\n  }\n\n  /**\n  * @dev reduce lock duration for a specified reason and time\n  * @param _of The address whose tokens are locked\n  * @param _reason The reason to lock tokens\n  * @param _time Lock reduction time in seconds\n  */\n  function _reduceLock(address _of, bytes32 _reason, uint256 _time) internal {\n    require(_tokensLocked(_of, _reason) > 0);\n    emit Unlocked(_of, _reason, locked[_of][_reason].amount);\n    locked[_of][_reason].validity = locked[_of][_reason].validity.sub(_time);\n    emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\n  }\n\n  /**\n  * @dev Returns unlockable tokens for a specified address for a specified reason\n  * @param _of The address to query the the unlockable token count of\n  * @param _reason The reason to query the unlockable tokens for\n  */\n  function _tokensUnlockable(address _of, bytes32 _reason) internal view returns (uint256 amount)\n  {\n    if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) {\n      amount = locked[_of][_reason].amount;\n    }\n  }\n\n  /**\n  * @dev Burns locked tokens of a user\n  * @param _of address whose tokens are to be burned\n  * @param _reason lock reason for which tokens are to be burned\n  * @param _amount amount of tokens to burn\n  */\n  function _burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal {\n    uint256 amount = _tokensLocked(_of, _reason);\n    require(amount >= _amount);\n\n    if (amount == _amount) {\n      locked[_of][_reason].claimed = true;\n    }\n\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\n    if (locked[_of][_reason].amount == 0) {\n      _removeReason(_of, _reason);\n    }\n    token.burn(_amount);\n    emit Burned(_of, _reason, _amount);\n  }\n\n  /**\n  * @dev Released locked tokens of an address locked for a specific reason\n  * @param _of address whose tokens are to be released from lock\n  * @param _reason reason of the lock\n  * @param _amount amount of tokens to release\n  */\n  function _releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal\n  {\n    uint256 amount = _tokensLocked(_of, _reason);\n    require(amount >= _amount);\n\n    if (amount == _amount) {\n      locked[_of][_reason].claimed = true;\n    }\n\n    locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\n    if (locked[_of][_reason].amount == 0) {\n      _removeReason(_of, _reason);\n    }\n    require(token.transfer(_of, _amount));\n    emit Unlocked(_of, _reason, _amount);\n  }\n\n  function _removeReason(address _of, bytes32 _reason) internal {\n    uint len = lockReason[_of].length;\n    for (uint i = 0; i < len; i++) {\n      if (lockReason[_of][i] == _reason) {\n        lockReason[_of][i] = lockReason[_of][len.sub(1)];\n        lockReason[_of].pop();\n        break;\n      }\n    }\n  }\n}\n\n// File: contracts/modules/token/TokenData.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\n\ncontract TokenData is Iupgradable {\n  using SafeMath for uint;\n\n  address payable public walletAddress;\n  uint public lockTokenTimeAfterCoverExp;\n  uint public bookTime;\n  uint public lockCADays;\n  uint public lockMVDays;\n  uint public scValidDays;\n  uint public joiningFee;\n  uint public stakerCommissionPer;\n  uint public stakerMaxCommissionPer;\n  uint public tokenExponent;\n  uint public priceStep;\n\n  struct StakeCommission {\n    uint commissionEarned;\n    uint commissionRedeemed;\n  }\n\n  struct Stake {\n    address stakedContractAddress;\n    uint stakedContractIndex;\n    uint dateAdd;\n    uint stakeAmount;\n    uint unlockedAmount;\n    uint burnedAmount;\n    uint unLockableBeforeLastBurn;\n  }\n\n  struct Staker {\n    address stakerAddress;\n    uint stakerIndex;\n  }\n\n  struct CoverNote {\n    uint amount;\n    bool isDeposited;\n  }\n\n  /**\n   * @dev mapping of uw address to array of sc address to fetch\n   * all staked contract address of underwriter, pushing\n   * data into this array of Stake returns stakerIndex\n   */\n  mapping(address => Stake[]) public stakerStakedContracts;\n\n  /**\n   * @dev mapping of sc address to array of UW address to fetch\n   * all underwritters of the staked smart contract\n   * pushing data into this mapped array returns scIndex\n   */\n  mapping(address => Staker[]) public stakedContractStakers;\n\n  /**\n   * @dev mapping of staked contract Address to the array of StakeCommission\n   * here index of this array is stakedContractIndex\n   */\n  mapping(address => mapping(uint => StakeCommission)) public stakedContractStakeCommission;\n\n  mapping(address => uint) public lastCompletedStakeCommission;\n\n  /**\n   * @dev mapping of the staked contract address to the current\n   * staker index who will receive commission.\n   */\n  mapping(address => uint) public stakedContractCurrentCommissionIndex;\n\n  /**\n   * @dev mapping of the staked contract address to the\n   * current staker index to burn token from.\n   */\n  mapping(address => uint) public stakedContractCurrentBurnIndex;\n\n  /**\n   * @dev mapping to return true if Cover Note deposited against coverId\n   */\n  mapping(uint => CoverNote) public depositedCN;\n\n  mapping(address => uint) internal isBookedTokens;\n\n  event Commission(\n    address indexed stakedContractAddress,\n    address indexed stakerAddress,\n    uint indexed scIndex,\n    uint commissionAmount\n  );\n\n  constructor(address payable _walletAdd) public {\n    walletAddress = _walletAdd;\n    bookTime = 12 hours;\n    joiningFee = 2000000000000000; // 0.002 Ether\n    lockTokenTimeAfterCoverExp = 35 days;\n    scValidDays = 250;\n    lockCADays = 7 days;\n    lockMVDays = 2 days;\n    stakerCommissionPer = 20;\n    stakerMaxCommissionPer = 50;\n    tokenExponent = 4;\n    priceStep = 1000;\n  }\n\n  /**\n   * @dev Change the wallet address which receive Joining Fee\n   */\n  function changeWalletAddress(address payable _address) external onlyInternal {\n    walletAddress = _address;\n  }\n\n  /**\n   * @dev Gets Uint Parameters of a code\n   * @param code whose details we want\n   * @return string value of the code\n   * @return associated amount (time or perc or value) to the code\n   */\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\n    codeVal = code;\n    if (code == \"TOKEXP\") {\n\n      val = tokenExponent;\n\n    } else if (code == \"TOKSTEP\") {\n\n      val = priceStep;\n\n    } else if (code == \"RALOCKT\") {\n\n      val = scValidDays;\n\n    } else if (code == \"RACOMM\") {\n\n      val = stakerCommissionPer;\n\n    } else if (code == \"RAMAXC\") {\n\n      val = stakerMaxCommissionPer;\n\n    } else if (code == \"CABOOKT\") {\n\n      val = bookTime / (1 hours);\n\n    } else if (code == \"CALOCKT\") {\n\n      val = lockCADays / (1 days);\n\n    } else if (code == \"MVLOCKT\") {\n\n      val = lockMVDays / (1 days);\n\n    } else if (code == \"QUOLOCKT\") {\n\n      val = lockTokenTimeAfterCoverExp / (1 days);\n\n    } else if (code == \"JOINFEE\") {\n\n      val = joiningFee;\n\n    }\n  }\n\n  /**\n  * @dev Just for interface\n  */\n  function changeDependentContractAddress() public {//solhint-disable-line\n  }\n\n  /**\n   * @dev to get the contract staked by a staker\n   * @param _stakerAddress is the address of the staker\n   * @param _stakerIndex is the index of staker\n   * @return the address of staked contract\n   */\n  function getStakerStakedContractByIndex(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (address stakedContractAddress)\n  {\n    stakedContractAddress = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractAddress;\n  }\n\n  /**\n   * @dev to get the staker's staked burned\n   * @param _stakerAddress is the address of the staker\n   * @param _stakerIndex is the index of staker\n   * @return amount burned\n   */\n  function getStakerStakedBurnedByIndex(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint burnedAmount)\n  {\n    burnedAmount = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].burnedAmount;\n  }\n\n  /**\n   * @dev to get the staker's staked unlockable before the last burn\n   * @param _stakerAddress is the address of the staker\n   * @param _stakerIndex is the index of staker\n   * @return unlockable staked tokens\n   */\n  function getStakerStakedUnlockableBeforeLastBurnByIndex(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint unlockable)\n  {\n    unlockable = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].unLockableBeforeLastBurn;\n  }\n\n  /**\n   * @dev to get the staker's staked contract index\n   * @param _stakerAddress is the address of the staker\n   * @param _stakerIndex is the index of staker\n   * @return is the index of the smart contract address\n   */\n  function getStakerStakedContractIndex(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint scIndex)\n  {\n    scIndex = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractIndex;\n  }\n\n  /**\n   * @dev to get the staker index of the staked contract\n   * @param _stakedContractAddress is the address of the staked contract\n   * @param _stakedContractIndex is the index of staked contract\n   * @return is the index of the staker\n   */\n  function getStakedContractStakerIndex(\n    address _stakedContractAddress,\n    uint _stakedContractIndex\n  )\n  public\n  view\n  returns (uint sIndex)\n  {\n    sIndex = stakedContractStakers[\n    _stakedContractAddress][_stakedContractIndex].stakerIndex;\n  }\n\n  /**\n   * @dev to get the staker's initial staked amount on the contract\n   * @param _stakerAddress is the address of the staker\n   * @param _stakerIndex is the index of staker\n   * @return staked amount\n   */\n  function getStakerInitialStakedAmountOnContract(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint amount)\n  {\n    amount = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakeAmount;\n  }\n\n  /**\n   * @dev to get the staker's staked contract length\n   * @param _stakerAddress is the address of the staker\n   * @return length of staked contract\n   */\n  function getStakerStakedContractLength(\n    address _stakerAddress\n  )\n  public\n  view\n  returns (uint length)\n  {\n    length = stakerStakedContracts[_stakerAddress].length;\n  }\n\n  /**\n   * @dev to get the staker's unlocked tokens which were staked\n   * @param _stakerAddress is the address of the staker\n   * @param _stakerIndex is the index of staker\n   * @return amount\n   */\n  function getStakerUnlockedStakedTokens(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint amount)\n  {\n    amount = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].unlockedAmount;\n  }\n\n  /**\n   * @dev pushes the unlocked staked tokens by a staker.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker to distribute commission.\n   * @param _amount amount to be given as commission.\n   */\n  function pushUnlockedStakedTokens(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  )\n  public\n  onlyInternal\n  {\n    stakerStakedContracts[_stakerAddress][\n    _stakerIndex].unlockedAmount = stakerStakedContracts[_stakerAddress][\n    _stakerIndex].unlockedAmount.add(_amount);\n  }\n\n  /**\n   * @dev pushes the Burned tokens for a staker.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker.\n   * @param _amount amount to be burned.\n   */\n  function pushBurnedTokens(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  )\n  public\n  onlyInternal\n  {\n    stakerStakedContracts[_stakerAddress][\n    _stakerIndex].burnedAmount = stakerStakedContracts[_stakerAddress][\n    _stakerIndex].burnedAmount.add(_amount);\n  }\n\n  /**\n   * @dev pushes the unLockable tokens for a staker before last burn.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker.\n   * @param _amount amount to be added to unlockable.\n   */\n  function pushUnlockableBeforeLastBurnTokens(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  )\n  public\n  onlyInternal\n  {\n    stakerStakedContracts[_stakerAddress][\n    _stakerIndex].unLockableBeforeLastBurn = stakerStakedContracts[_stakerAddress][\n    _stakerIndex].unLockableBeforeLastBurn.add(_amount);\n  }\n\n  /**\n   * @dev sets the unLockable tokens for a staker before last burn.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker.\n   * @param _amount amount to be added to unlockable.\n   */\n  function setUnlockableBeforeLastBurnTokens(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  )\n  public\n  onlyInternal\n  {\n    stakerStakedContracts[_stakerAddress][\n    _stakerIndex].unLockableBeforeLastBurn = _amount;\n  }\n\n  /**\n   * @dev pushes the earned commission earned by a staker.\n   * @param _stakerAddress address of staker.\n   * @param _stakedContractAddress address of smart contract.\n   * @param _stakedContractIndex index of the staker to distribute commission.\n   * @param _commissionAmount amount to be given as commission.\n   */\n  function pushEarnedStakeCommissions(\n    address _stakerAddress,\n    address _stakedContractAddress,\n    uint _stakedContractIndex,\n    uint _commissionAmount\n  )\n  public\n  onlyInternal\n  {\n    stakedContractStakeCommission[_stakedContractAddress][_stakedContractIndex].\n    commissionEarned = stakedContractStakeCommission[_stakedContractAddress][\n    _stakedContractIndex].commissionEarned.add(_commissionAmount);\n\n    emit Commission(\n      _stakerAddress,\n      _stakedContractAddress,\n      _stakedContractIndex,\n      _commissionAmount\n    );\n  }\n\n  /**\n   * @dev pushes the redeemed commission redeemed by a staker.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker to distribute commission.\n   * @param _amount amount to be given as commission.\n   */\n  function pushRedeemedStakeCommissions(\n    address _stakerAddress,\n    uint _stakerIndex,\n    uint _amount\n  )\n  public\n  onlyInternal\n  {\n    uint stakedContractIndex = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractIndex;\n    address stakedContractAddress = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractAddress;\n    stakedContractStakeCommission[stakedContractAddress][stakedContractIndex].\n    commissionRedeemed = stakedContractStakeCommission[\n    stakedContractAddress][stakedContractIndex].commissionRedeemed.add(_amount);\n  }\n\n  /**\n   * @dev Gets stake commission given to an underwriter\n   * for particular stakedcontract on given index.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker commission.\n   */\n  function getStakerEarnedStakeCommission(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint)\n  {\n    return _getStakerEarnedStakeCommission(_stakerAddress, _stakerIndex);\n  }\n\n  /**\n   * @dev Gets stake commission redeemed by an underwriter\n   * for particular staked contract on given index.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker commission.\n   * @return commissionEarned total amount given to staker.\n   */\n  function getStakerRedeemedStakeCommission(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  public\n  view\n  returns (uint)\n  {\n    return _getStakerRedeemedStakeCommission(_stakerAddress, _stakerIndex);\n  }\n\n  /**\n   * @dev Gets total stake commission given to an underwriter\n   * @param _stakerAddress address of staker.\n   * @return totalCommissionEarned total commission earned by staker.\n   */\n  function getStakerTotalEarnedStakeCommission(\n    address _stakerAddress\n  )\n  public\n  view\n  returns (uint totalCommissionEarned)\n  {\n    totalCommissionEarned = 0;\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\n      totalCommissionEarned = totalCommissionEarned.\n      add(_getStakerEarnedStakeCommission(_stakerAddress, i));\n    }\n  }\n\n  /**\n   * @dev Gets total stake commission given to an underwriter\n   * @param _stakerAddress address of staker.\n   * @return totalCommissionEarned total commission earned by staker.\n   */\n  function getStakerTotalReedmedStakeCommission(\n    address _stakerAddress\n  )\n  public\n  view\n  returns (uint totalCommissionRedeemed)\n  {\n    totalCommissionRedeemed = 0;\n    for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\n      totalCommissionRedeemed = totalCommissionRedeemed.add(\n        _getStakerRedeemedStakeCommission(_stakerAddress, i));\n    }\n  }\n\n  /**\n   * @dev set flag to deposit/ undeposit cover note\n   * against a cover Id\n   * @param coverId coverId of Cover\n   * @param flag true/false for deposit/undeposit\n   */\n  function setDepositCN(uint coverId, bool flag) public onlyInternal {\n\n    if (flag == true) {\n      require(!depositedCN[coverId].isDeposited, \"Cover note already deposited\");\n    }\n\n    depositedCN[coverId].isDeposited = flag;\n  }\n\n  /**\n   * @dev set locked cover note amount\n   * against a cover Id\n   * @param coverId coverId of Cover\n   * @param amount amount of nxm to be locked\n   */\n  function setDepositCNAmount(uint coverId, uint amount) public onlyInternal {\n\n    depositedCN[coverId].amount = amount;\n  }\n\n  /**\n   * @dev to get the staker address on a staked contract\n   * @param _stakedContractAddress is the address of the staked contract in concern\n   * @param _stakedContractIndex is the index of staked contract's index\n   * @return address of staker\n   */\n  function getStakedContractStakerByIndex(\n    address _stakedContractAddress,\n    uint _stakedContractIndex\n  )\n  public\n  view\n  returns (address stakerAddress)\n  {\n    stakerAddress = stakedContractStakers[\n    _stakedContractAddress][_stakedContractIndex].stakerAddress;\n  }\n\n  /**\n   * @dev to get the length of stakers on a staked contract\n   * @param _stakedContractAddress is the address of the staked contract in concern\n   * @return length in concern\n   */\n  function getStakedContractStakersLength(\n    address _stakedContractAddress\n  )\n  public\n  view\n  returns (uint length)\n  {\n    length = stakedContractStakers[_stakedContractAddress].length;\n  }\n\n  /**\n   * @dev Adds a new stake record.\n   * @param _stakerAddress staker address.\n   * @param _stakedContractAddress smart contract address.\n   * @param _amount amountof NXM to be staked.\n   */\n  function addStake(\n    address _stakerAddress,\n    address _stakedContractAddress,\n    uint _amount\n  )\n  public\n  onlyInternal\n  returns (uint scIndex)\n  {\n    scIndex = (stakedContractStakers[_stakedContractAddress].push(\n      Staker(_stakerAddress, stakerStakedContracts[_stakerAddress].length))).sub(1);\n    stakerStakedContracts[_stakerAddress].push(\n      Stake(_stakedContractAddress, scIndex, now, _amount, 0, 0, 0));\n  }\n\n  /**\n   * @dev books the user's tokens for maintaining Assessor Velocity,\n   * i.e. once a token is used to cast a vote as a Claims assessor,\n   * @param _of user's address.\n   */\n  function bookCATokens(address _of) public onlyInternal {\n    require(!isCATokensBooked(_of), \"Tokens already booked\");\n    isBookedTokens[_of] = now.add(bookTime);\n  }\n\n  /**\n   * @dev to know if claim assessor's tokens are booked or not\n   * @param _of is the claim assessor's address in concern\n   * @return boolean representing the status of tokens booked\n   */\n  function isCATokensBooked(address _of) public view returns (bool res) {\n    if (now < isBookedTokens[_of])\n      res = true;\n  }\n\n  /**\n   * @dev Sets the index which will receive commission.\n   * @param _stakedContractAddress smart contract address.\n   * @param _index current index.\n   */\n  function setStakedContractCurrentCommissionIndex(\n    address _stakedContractAddress,\n    uint _index\n  )\n  public\n  onlyInternal\n  {\n    stakedContractCurrentCommissionIndex[_stakedContractAddress] = _index;\n  }\n\n  /**\n   * @dev Sets the last complete commission index\n   * @param _stakerAddress smart contract address.\n   * @param _index current index.\n   */\n  function setLastCompletedStakeCommissionIndex(\n    address _stakerAddress,\n    uint _index\n  )\n  public\n  onlyInternal\n  {\n    lastCompletedStakeCommission[_stakerAddress] = _index;\n  }\n\n  /**\n   * @dev Sets the index till which commission is distrubuted.\n   * @param _stakedContractAddress smart contract address.\n   * @param _index current index.\n   */\n  function setStakedContractCurrentBurnIndex(\n    address _stakedContractAddress,\n    uint _index\n  )\n  public\n  onlyInternal\n  {\n    stakedContractCurrentBurnIndex[_stakedContractAddress] = _index;\n  }\n\n  /**\n   * @dev Updates Uint Parameters of a code\n   * @param code whose details we want to update\n   * @param val value to set\n   */\n  function updateUintParameters(bytes8 code, uint val) public {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    if (code == \"TOKEXP\") {\n\n      _setTokenExponent(val);\n\n    } else if (code == \"TOKSTEP\") {\n\n      _setPriceStep(val);\n\n    } else if (code == \"RALOCKT\") {\n\n      _changeSCValidDays(val);\n\n    } else if (code == \"RACOMM\") {\n\n      _setStakerCommissionPer(val);\n\n    } else if (code == \"RAMAXC\") {\n\n      _setStakerMaxCommissionPer(val);\n\n    } else if (code == \"CABOOKT\") {\n\n      _changeBookTime(val * 1 hours);\n\n    } else if (code == \"CALOCKT\") {\n\n      _changelockCADays(val * 1 days);\n\n    } else if (code == \"MVLOCKT\") {\n\n      _changelockMVDays(val * 1 days);\n\n    } else if (code == \"QUOLOCKT\") {\n\n      _setLockTokenTimeAfterCoverExp(val * 1 days);\n\n    } else if (code == \"JOINFEE\") {\n\n      _setJoiningFee(val);\n\n    } else {\n      revert(\"Invalid param code\");\n    }\n  }\n\n  /**\n   * @dev Internal function to get stake commission given to an\n   * underwriter for particular stakedcontract on given index.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker commission.\n   */\n  function _getStakerEarnedStakeCommission(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  internal\n  view\n  returns (uint amount)\n  {\n    uint _stakedContractIndex;\n    address _stakedContractAddress;\n    _stakedContractAddress = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractAddress;\n    _stakedContractIndex = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractIndex;\n    amount = stakedContractStakeCommission[\n    _stakedContractAddress][_stakedContractIndex].commissionEarned;\n  }\n\n  /**\n   * @dev Internal function to get stake commission redeemed by an\n   * underwriter for particular stakedcontract on given index.\n   * @param _stakerAddress address of staker.\n   * @param _stakerIndex index of the staker commission.\n   */\n  function _getStakerRedeemedStakeCommission(\n    address _stakerAddress,\n    uint _stakerIndex\n  )\n  internal\n  view\n  returns (uint amount)\n  {\n    uint _stakedContractIndex;\n    address _stakedContractAddress;\n    _stakedContractAddress = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractAddress;\n    _stakedContractIndex = stakerStakedContracts[\n    _stakerAddress][_stakerIndex].stakedContractIndex;\n    amount = stakedContractStakeCommission[\n    _stakedContractAddress][_stakedContractIndex].commissionRedeemed;\n  }\n\n  /**\n   * @dev to set the percentage of staker commission\n   * @param _val is new percentage value\n   */\n  function _setStakerCommissionPer(uint _val) internal {\n    stakerCommissionPer = _val;\n  }\n\n  /**\n   * @dev to set the max percentage of staker commission\n   * @param _val is new percentage value\n   */\n  function _setStakerMaxCommissionPer(uint _val) internal {\n    stakerMaxCommissionPer = _val;\n  }\n\n  /**\n   * @dev to set the token exponent value\n   * @param _val is new value\n   */\n  function _setTokenExponent(uint _val) internal {\n    tokenExponent = _val;\n  }\n\n  /**\n   * @dev to set the price step\n   * @param _val is new value\n   */\n  function _setPriceStep(uint _val) internal {\n    priceStep = _val;\n  }\n\n  /**\n   * @dev Changes number of days for which NXM needs to staked in case of underwriting\n   */\n  function _changeSCValidDays(uint _days) internal {\n    scValidDays = _days;\n  }\n\n  /**\n   * @dev Changes the time period up to which tokens will be locked.\n   *      Used to generate the validity period of tokens booked by\n   *      a user for participating in claim's assessment/claim's voting.\n   */\n  function _changeBookTime(uint _time) internal {\n    bookTime = _time;\n  }\n\n  /**\n   * @dev Changes lock CA days - number of days for which tokens\n   * are locked while submitting a vote.\n   */\n  function _changelockCADays(uint _val) internal {\n    lockCADays = _val;\n  }\n\n  /**\n   * @dev Changes lock MV days - number of days for which tokens are locked\n   * while submitting a vote.\n   */\n  function _changelockMVDays(uint _val) internal {\n    lockMVDays = _val;\n  }\n\n  /**\n   * @dev Changes extra lock period for a cover, post its expiry.\n   */\n  function _setLockTokenTimeAfterCoverExp(uint time) internal {\n    lockTokenTimeAfterCoverExp = time;\n  }\n\n  /**\n   * @dev Set the joining fee for membership\n   */\n  function _setJoiningFee(uint _amount) internal {\n    joiningFee = _amount;\n  }\n}\n\n// File: contracts/modules/capital/PoolData.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\n\ncontract DSValue {\n  function peek() public view returns (bytes32, bool);\n\n  function read() public view returns (bytes32);\n}\n\ncontract PoolData is Iupgradable {\n  using SafeMath for uint;\n\n  struct ApiId {\n    bytes4 typeOf;\n    bytes4 currency;\n    uint id;\n    uint64 dateAdd;\n    uint64 dateUpd;\n  }\n\n  struct CurrencyAssets {\n    address currAddress;\n    uint baseMin;\n    uint varMin;\n  }\n\n  struct InvestmentAssets {\n    address currAddress;\n    bool status;\n    uint64 minHoldingPercX100;\n    uint64 maxHoldingPercX100;\n    uint8 decimals;\n  }\n\n  struct IARankDetails {\n    bytes4 maxIACurr;\n    uint64 maxRate;\n    bytes4 minIACurr;\n    uint64 minRate;\n  }\n\n  struct McrData {\n    uint mcrPercx100;\n    uint mcrEther;\n    uint vFull; //Pool funds\n    uint64 date;\n  }\n\n  IARankDetails[] internal allIARankDetails;\n  McrData[] public allMCRData;\n\n  bytes4[] internal allInvestmentCurrencies;\n  bytes4[] internal allCurrencies;\n  bytes32[] public allAPIcall;\n  mapping(bytes32 => ApiId) public allAPIid;\n  mapping(uint64 => uint) internal datewiseId;\n  mapping(bytes16 => uint) internal currencyLastIndex;\n  mapping(bytes4 => CurrencyAssets) internal allCurrencyAssets;\n  mapping(bytes4 => InvestmentAssets) internal allInvestmentAssets;\n  mapping(bytes4 => uint) internal caAvgRate;\n  mapping(bytes4 => uint) internal iaAvgRate;\n\n  address public notariseMCR;\n  address public daiFeedAddress;\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\n  uint public uniswapDeadline;\n  uint public liquidityTradeCallbackTime;\n  uint public lastLiquidityTradeTrigger;\n  uint64 internal lastDate;\n  uint public variationPercX100;\n  uint public iaRatesTime;\n  uint public minCap;\n  uint public mcrTime;\n  uint public a;\n  uint public shockParameter;\n  uint public c;\n  uint public mcrFailTime;\n  uint public ethVolumeLimit;\n  uint public capReached;\n  uint public capacityLimit;\n\n  constructor(address _notariseAdd, address _daiFeedAdd, address _daiAdd) public {\n    notariseMCR = _notariseAdd;\n    daiFeedAddress = _daiFeedAdd;\n    c = 5800000;\n    a = 1028;\n    mcrTime = 24 hours;\n    mcrFailTime = 6 hours;\n    allMCRData.push(McrData(0, 0, 0, 0));\n    minCap = 12000 * DECIMAL1E18;\n    shockParameter = 50;\n    variationPercX100 = 100; // 1%\n    iaRatesTime = 24 hours; // 24 hours in seconds\n    uniswapDeadline = 20 minutes;\n    liquidityTradeCallbackTime = 4 hours;\n    ethVolumeLimit = 4;\n    capacityLimit = 10;\n    allCurrencies.push(\"ETH\");\n    allCurrencyAssets[\"ETH\"] = CurrencyAssets(address(0), 1000 * DECIMAL1E18, 0);\n    allCurrencies.push(\"DAI\");\n    allCurrencyAssets[\"DAI\"] = CurrencyAssets(_daiAdd, 50000 * DECIMAL1E18, 0);\n    allInvestmentCurrencies.push(\"ETH\");\n    allInvestmentAssets[\"ETH\"] = InvestmentAssets(address(0), true, 2500, 10000, 18);\n    allInvestmentCurrencies.push(\"DAI\");\n    allInvestmentAssets[\"DAI\"] = InvestmentAssets(_daiAdd, true, 250, 1500, 18);\n  }\n\n  /**\n   * @dev to set the maximum cap allowed\n   * @param val is the new value\n   */\n  function setCapReached(uint val) external onlyInternal {\n    capReached = val;\n  }\n\n  /// @dev Updates the 3 day average rate of a IA currency.\n  /// To be replaced by MakerDao's on chain rates\n  /// @param curr IA Currency Name.\n  /// @param rate Average exchange rate X 100 (of last 3 days).\n  function updateIAAvgRate(bytes4 curr, uint rate) external onlyInternal {\n    iaAvgRate[curr] = rate;\n  }\n\n  /// @dev Updates the 3 day average rate of a CA currency.\n  /// To be replaced by MakerDao's on chain rates\n  /// @param curr Currency Name.\n  /// @param rate Average exchange rate X 100 (of last 3 days).\n  function updateCAAvgRate(bytes4 curr, uint rate) external onlyInternal {\n    caAvgRate[curr] = rate;\n  }\n\n  /// @dev Adds details of (Minimum Capital Requirement)MCR.\n  /// @param mcrp Minimum Capital Requirement percentage (MCR% * 100 ,Ex:for 54.56% ,given 5456)\n  /// @param vf Pool fund value in Ether used in the last full daily calculation from the Capital model.\n  function pushMCRData(uint mcrp, uint mcre, uint vf, uint64 time) external onlyInternal {\n    allMCRData.push(McrData(mcrp, mcre, vf, time));\n  }\n\n  /**\n   * @dev Updates the Timestamp at which result of oracalize call is received.\n   */\n  function updateDateUpdOfAPI(bytes32 myid) external onlyInternal {\n    allAPIid[myid].dateUpd = uint64(now);\n  }\n\n  /**\n   * @dev Saves the details of the Oraclize API.\n   * @param myid Id return by the oraclize query.\n   * @param _typeof type of the query for which oraclize call is made.\n   * @param id ID of the proposal,quote,cover etc. for which oraclize call is made\n   */\n  function saveApiDetails(bytes32 myid, bytes4 _typeof, uint id) external onlyInternal {\n    allAPIid[myid] = ApiId(_typeof, \"\", id, uint64(now), uint64(now));\n  }\n\n  /**\n   * @dev Stores the id return by the oraclize query.\n   * Maintains record of all the Ids return by oraclize query.\n   * @param myid Id return by the oraclize query.\n   */\n  function addInAllApiCall(bytes32 myid) external onlyInternal {\n    allAPIcall.push(myid);\n  }\n\n  /**\n   * @dev Saves investment asset rank details.\n   * @param maxIACurr Maximum ranked investment asset currency.\n   * @param maxRate Maximum ranked investment asset rate.\n   * @param minIACurr Minimum ranked investment asset currency.\n   * @param minRate Minimum ranked investment asset rate.\n   * @param date in yyyymmdd.\n   */\n  function saveIARankDetails(\n    bytes4 maxIACurr,\n    uint64 maxRate,\n    bytes4 minIACurr,\n    uint64 minRate,\n    uint64 date\n  )\n  external\n  onlyInternal\n  {\n    allIARankDetails.push(IARankDetails(maxIACurr, maxRate, minIACurr, minRate));\n    datewiseId[date] = allIARankDetails.length.sub(1);\n  }\n\n  /**\n   * @dev to get the time for the laste liquidity trade trigger\n   */\n  function setLastLiquidityTradeTrigger() external onlyInternal {\n    lastLiquidityTradeTrigger = now;\n  }\n\n  /**\n   * @dev Updates Last Date.\n   */\n  function updatelastDate(uint64 newDate) external onlyInternal {\n    lastDate = newDate;\n  }\n\n  /**\n   * @dev Adds currency asset currency.\n   * @param curr currency of the asset\n   * @param currAddress address of the currency\n   * @param baseMin base minimum in 10^18.\n   */\n  function addCurrencyAssetCurrency(\n    bytes4 curr,\n    address currAddress,\n    uint baseMin\n  )\n  external\n  {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allCurrencies.push(curr);\n    allCurrencyAssets[curr] = CurrencyAssets(currAddress, baseMin, 0);\n  }\n\n  /**\n   * @dev Adds investment asset.\n   */\n  function addInvestmentAssetCurrency(\n    bytes4 curr,\n    address currAddress,\n    bool status,\n    uint64 minHoldingPercX100,\n    uint64 maxHoldingPercX100,\n    uint8 decimals\n  )\n  external\n  {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allInvestmentCurrencies.push(curr);\n    allInvestmentAssets[curr] = InvestmentAssets(currAddress, status,\n      minHoldingPercX100, maxHoldingPercX100, decimals);\n  }\n\n  /**\n   * @dev Changes base minimum of a given currency asset.\n   */\n  function changeCurrencyAssetBaseMin(bytes4 curr, uint baseMin) external {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allCurrencyAssets[curr].baseMin = baseMin;\n  }\n\n  /**\n   * @dev changes variable minimum of a given currency asset.\n   */\n  function changeCurrencyAssetVarMin(bytes4 curr, uint varMin) external onlyInternal {\n    allCurrencyAssets[curr].varMin = varMin;\n  }\n\n  /**\n   * @dev Changes the investment asset status.\n   */\n  function changeInvestmentAssetStatus(bytes4 curr, bool status) external {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allInvestmentAssets[curr].status = status;\n  }\n\n  /**\n   * @dev Changes the investment asset Holding percentage of a given currency.\n   */\n  function changeInvestmentAssetHoldingPerc(\n    bytes4 curr,\n    uint64 minPercX100,\n    uint64 maxPercX100\n  )\n  external\n  {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allInvestmentAssets[curr].minHoldingPercX100 = minPercX100;\n    allInvestmentAssets[curr].maxHoldingPercX100 = maxPercX100;\n  }\n\n  /**\n   * @dev Gets Currency asset token address.\n   */\n  function changeCurrencyAssetAddress(bytes4 curr, address currAdd) external {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allCurrencyAssets[curr].currAddress = currAdd;\n  }\n\n  /**\n   * @dev Changes Investment asset token address.\n   */\n  function changeInvestmentAssetAddressAndDecimal(\n    bytes4 curr,\n    address currAdd,\n    uint8 newDecimal\n  )\n  external\n  {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    allInvestmentAssets[curr].currAddress = currAdd;\n    allInvestmentAssets[curr].decimals = newDecimal;\n  }\n\n  /// @dev Changes address allowed to post MCR.\n  function changeNotariseAddress(address _add) external onlyInternal {\n    notariseMCR = _add;\n  }\n\n  /// @dev updates daiFeedAddress address.\n  /// @param _add address of DAI feed.\n  function changeDAIfeedAddress(address _add) external onlyInternal {\n    daiFeedAddress = _add;\n  }\n\n  /**\n   * @dev Gets Uint Parameters of a code\n   * @param code whose details we want\n   * @return string value of the code\n   * @return associated amount (time or perc or value) to the code\n   */\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\n    codeVal = code;\n    if (code == \"MCRTIM\") {\n      val = mcrTime / (1 hours);\n\n    } else if (code == \"MCRFTIM\") {\n\n      val = mcrFailTime / (1 hours);\n\n    } else if (code == \"MCRMIN\") {\n\n      val = minCap;\n\n    } else if (code == \"MCRSHOCK\") {\n\n      val = shockParameter;\n\n    } else if (code == \"MCRCAPL\") {\n\n      val = capacityLimit;\n\n    } else if (code == \"IMZ\") {\n\n      val = variationPercX100;\n\n    } else if (code == \"IMRATET\") {\n\n      val = iaRatesTime / (1 hours);\n\n    } else if (code == \"IMUNIDL\") {\n\n      val = uniswapDeadline / (1 minutes);\n\n    } else if (code == \"IMLIQT\") {\n\n      val = liquidityTradeCallbackTime / (1 hours);\n\n    } else if (code == \"IMETHVL\") {\n\n      val = ethVolumeLimit;\n\n    } else if (code == \"C\") {\n      val = c;\n\n    } else if (code == \"A\") {\n\n      val = a;\n\n    }\n\n  }\n\n  /// @dev Checks whether a given address can notaise MCR data or not.\n  /// @param _add Address.\n  /// @return res Returns 0 if address is not authorized, else 1.\n  function isnotarise(address _add) external view returns (bool res) {\n    res = false;\n    if (_add == notariseMCR)\n      res = true;\n  }\n\n  /// @dev Gets the details of last added MCR.\n  /// @return mcrPercx100 Total Minimum Capital Requirement percentage of that month of year(multiplied by 100).\n  /// @return vFull Total Pool fund value in Ether used in the last full daily calculation.\n  function getLastMCR() external view returns (uint mcrPercx100, uint mcrEtherx1E18, uint vFull, uint64 date) {\n    uint index = allMCRData.length.sub(1);\n    return (\n    allMCRData[index].mcrPercx100,\n    allMCRData[index].mcrEther,\n    allMCRData[index].vFull,\n    allMCRData[index].date\n    );\n  }\n\n  /// @dev Gets last Minimum Capital Requirement percentage of Capital Model\n  /// @return val MCR% value,multiplied by 100.\n  function getLastMCRPerc() external view returns (uint) {\n    return allMCRData[allMCRData.length.sub(1)].mcrPercx100;\n  }\n\n  /// @dev Gets last Ether price of Capital Model\n  /// @return val ether value,multiplied by 100.\n  function getLastMCREther() external view returns (uint) {\n    return allMCRData[allMCRData.length.sub(1)].mcrEther;\n  }\n\n  /// @dev Gets Pool fund value in Ether used in the last full daily calculation from the Capital model.\n  function getLastVfull() external view returns (uint) {\n    return allMCRData[allMCRData.length.sub(1)].vFull;\n  }\n\n  /// @dev Gets last Minimum Capital Requirement in Ether.\n  /// @return date of MCR.\n  function getLastMCRDate() external view returns (uint64 date) {\n    date = allMCRData[allMCRData.length.sub(1)].date;\n  }\n\n  /// @dev Gets details for token price calculation.\n  function getTokenPriceDetails(bytes4 curr) external view returns (uint _a, uint _c, uint rate) {\n    _a = a;\n    _c = c;\n    rate = _getAvgRate(curr, false);\n  }\n\n  /// @dev Gets the total number of times MCR calculation has been made.\n  function getMCRDataLength() external view returns (uint len) {\n    len = allMCRData.length;\n  }\n\n  /**\n   * @dev Gets investment asset rank details by given date.\n   */\n  function getIARankDetailsByDate(\n    uint64 date\n  )\n  external\n  view\n  returns (\n    bytes4 maxIACurr,\n    uint64 maxRate,\n    bytes4 minIACurr,\n    uint64 minRate\n  )\n  {\n    uint index = datewiseId[date];\n    return (\n    allIARankDetails[index].maxIACurr,\n    allIARankDetails[index].maxRate,\n    allIARankDetails[index].minIACurr,\n    allIARankDetails[index].minRate\n    );\n  }\n\n  /**\n   * @dev Gets Last Date.\n   */\n  function getLastDate() external view returns (uint64 date) {\n    return lastDate;\n  }\n\n  /**\n   * @dev Gets investment currency for a given index.\n   */\n  function getInvestmentCurrencyByIndex(uint index) external view returns (bytes4 currName) {\n    return allInvestmentCurrencies[index];\n  }\n\n  /**\n   * @dev Gets count of investment currency.\n   */\n  function getInvestmentCurrencyLen() external view returns (uint len) {\n    return allInvestmentCurrencies.length;\n  }\n\n  /**\n   * @dev Gets all the investment currencies.\n   */\n  function getAllInvestmentCurrencies() external view returns (bytes4[] memory currencies) {\n    return allInvestmentCurrencies;\n  }\n\n  /**\n   * @dev Gets All currency for a given index.\n   */\n  function getCurrenciesByIndex(uint index) external view returns (bytes4 currName) {\n    return allCurrencies[index];\n  }\n\n  /**\n   * @dev Gets count of All currency.\n   */\n  function getAllCurrenciesLen() external view returns (uint len) {\n    return allCurrencies.length;\n  }\n\n  /**\n   * @dev Gets all currencies\n   */\n  function getAllCurrencies() external view returns (bytes4[] memory currencies) {\n    return allCurrencies;\n  }\n\n  /**\n   * @dev Gets currency asset details for a given currency.\n   */\n  function getCurrencyAssetVarBase(\n    bytes4 curr\n  )\n  external\n  view\n  returns (\n    bytes4 currency,\n    uint baseMin,\n    uint varMin\n  )\n  {\n    return (\n    curr,\n    allCurrencyAssets[curr].baseMin,\n    allCurrencyAssets[curr].varMin\n    );\n  }\n\n  /**\n   * @dev Gets minimum variable value for currency asset.\n   */\n  function getCurrencyAssetVarMin(bytes4 curr) external view returns (uint varMin) {\n    return allCurrencyAssets[curr].varMin;\n  }\n\n  /**\n   * @dev Gets base minimum of  a given currency asset.\n   */\n  function getCurrencyAssetBaseMin(bytes4 curr) external view returns (uint baseMin) {\n    return allCurrencyAssets[curr].baseMin;\n  }\n\n  /**\n   * @dev Gets investment asset maximum and minimum holding percentage of a given currency.\n   */\n  function getInvestmentAssetHoldingPerc(\n    bytes4 curr\n  )\n  external\n  view\n  returns (\n    uint64 minHoldingPercX100,\n    uint64 maxHoldingPercX100\n  )\n  {\n    return (\n    allInvestmentAssets[curr].minHoldingPercX100,\n    allInvestmentAssets[curr].maxHoldingPercX100\n    );\n  }\n\n  /**\n   * @dev Gets investment asset decimals.\n   */\n  function getInvestmentAssetDecimals(bytes4 curr) external view returns (uint8 decimal) {\n    return allInvestmentAssets[curr].decimals;\n  }\n\n  /**\n   * @dev Gets investment asset maximum holding percentage of a given currency.\n   */\n  function getInvestmentAssetMaxHoldingPerc(bytes4 curr) external view returns (uint64 maxHoldingPercX100) {\n    return allInvestmentAssets[curr].maxHoldingPercX100;\n  }\n\n  /**\n   * @dev Gets investment asset minimum holding percentage of a given currency.\n   */\n  function getInvestmentAssetMinHoldingPerc(bytes4 curr) external view returns (uint64 minHoldingPercX100) {\n    return allInvestmentAssets[curr].minHoldingPercX100;\n  }\n\n  /**\n   * @dev Gets investment asset details of a given currency\n   */\n  function getInvestmentAssetDetails(\n    bytes4 curr\n  )\n  external\n  view\n  returns (\n    bytes4 currency,\n    address currAddress,\n    bool status,\n    uint64 minHoldingPerc,\n    uint64 maxHoldingPerc,\n    uint8 decimals\n  )\n  {\n    return (\n    curr,\n    allInvestmentAssets[curr].currAddress,\n    allInvestmentAssets[curr].status,\n    allInvestmentAssets[curr].minHoldingPercX100,\n    allInvestmentAssets[curr].maxHoldingPercX100,\n    allInvestmentAssets[curr].decimals\n    );\n  }\n\n  /**\n   * @dev Gets Currency asset token address.\n   */\n  function getCurrencyAssetAddress(bytes4 curr) external view returns (address) {\n    return allCurrencyAssets[curr].currAddress;\n  }\n\n  /**\n   * @dev Gets investment asset token address.\n   */\n  function getInvestmentAssetAddress(bytes4 curr) external view returns (address) {\n    return allInvestmentAssets[curr].currAddress;\n  }\n\n  /**\n   * @dev Gets investment asset active Status of a given currency.\n   */\n  function getInvestmentAssetStatus(bytes4 curr) external view returns (bool status) {\n    return allInvestmentAssets[curr].status;\n  }\n\n  /**\n   * @dev Gets type of oraclize query for a given Oraclize Query ID.\n   * @param myid Oraclize Query ID identifying the query for which the result is being received.\n   * @return _typeof It could be of type \"quote\",\"quotation\",\"cover\",\"claim\" etc.\n   */\n  function getApiIdTypeOf(bytes32 myid) external view returns (bytes4) {\n    return allAPIid[myid].typeOf;\n  }\n\n  /**\n   * @dev Gets ID associated to oraclize query for a given Oraclize Query ID.\n   * @param myid Oraclize Query ID identifying the query for which the result is being received.\n   * @return id1 It could be the ID of \"proposal\",\"quotation\",\"cover\",\"claim\" etc.\n   */\n  function getIdOfApiId(bytes32 myid) external view returns (uint) {\n    return allAPIid[myid].id;\n  }\n\n  /**\n   * @dev Gets the Timestamp of a oracalize call.\n   */\n  function getDateAddOfAPI(bytes32 myid) external view returns (uint64) {\n    return allAPIid[myid].dateAdd;\n  }\n\n  /**\n   * @dev Gets the Timestamp at which result of oracalize call is received.\n   */\n  function getDateUpdOfAPI(bytes32 myid) external view returns (uint64) {\n    return allAPIid[myid].dateUpd;\n  }\n\n  /**\n   * @dev Gets currency by oracalize id.\n   */\n  function getCurrOfApiId(bytes32 myid) external view returns (bytes4) {\n    return allAPIid[myid].currency;\n  }\n\n  /**\n   * @dev Gets ID return by the oraclize query of a given index.\n   * @param index Index.\n   * @return myid ID return by the oraclize query.\n   */\n  function getApiCallIndex(uint index) external view returns (bytes32 myid) {\n    myid = allAPIcall[index];\n  }\n\n  /**\n   * @dev Gets Length of API call.\n   */\n  function getApilCallLength() external view returns (uint) {\n    return allAPIcall.length;\n  }\n\n  /**\n   * @dev Get Details of Oraclize API when given Oraclize Id.\n   * @param myid ID return by the oraclize query.\n   * @return _typeof ype of the query for which oraclize\n   * call is made.(\"proposal\",\"quote\",\"quotation\" etc.)\n   */\n  function getApiCallDetails(\n    bytes32 myid\n  )\n  external\n  view\n  returns (\n    bytes4 _typeof,\n    bytes4 curr,\n    uint id,\n    uint64 dateAdd,\n    uint64 dateUpd\n  )\n  {\n    return (\n    allAPIid[myid].typeOf,\n    allAPIid[myid].currency,\n    allAPIid[myid].id,\n    allAPIid[myid].dateAdd,\n    allAPIid[myid].dateUpd\n    );\n  }\n\n  /**\n   * @dev Updates Uint Parameters of a code\n   * @param code whose details we want to update\n   * @param val value to set\n   */\n  function updateUintParameters(bytes8 code, uint val) public {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    if (code == \"MCRTIM\") {\n      _changeMCRTime(val * 1 hours);\n\n    } else if (code == \"MCRFTIM\") {\n\n      _changeMCRFailTime(val * 1 hours);\n\n    } else if (code == \"MCRMIN\") {\n\n      _changeMinCap(val);\n\n    } else if (code == \"MCRSHOCK\") {\n\n      _changeShockParameter(val);\n\n    } else if (code == \"MCRCAPL\") {\n\n      _changeCapacityLimit(val);\n\n    } else if (code == \"IMZ\") {\n\n      _changeVariationPercX100(val);\n\n    } else if (code == \"IMRATET\") {\n\n      _changeIARatesTime(val * 1 hours);\n\n    } else if (code == \"IMUNIDL\") {\n\n      _changeUniswapDeadlineTime(val * 1 minutes);\n\n    } else if (code == \"IMLIQT\") {\n\n      _changeliquidityTradeCallbackTime(val * 1 hours);\n\n    } else if (code == \"IMETHVL\") {\n\n      _setEthVolumeLimit(val);\n\n    } else if (code == \"C\") {\n      _changeC(val);\n\n    } else if (code == \"A\") {\n\n      _changeA(val);\n\n    } else {\n      revert(\"Invalid param code\");\n    }\n\n  }\n\n  /**\n   * @dev to get the average rate of currency rate\n   * @param curr is the currency in concern\n   * @return required rate\n   */\n  function getCAAvgRate(bytes4 curr) public view returns (uint rate) {\n    return _getAvgRate(curr, false);\n  }\n\n  /**\n   * @dev to get the average rate of investment rate\n   * @param curr is the investment in concern\n   * @return required rate\n   */\n  function getIAAvgRate(bytes4 curr) public view returns (uint rate) {\n    return _getAvgRate(curr, true);\n  }\n\n  function changeDependentContractAddress() public onlyInternal {}\n\n  /// @dev Gets the average rate of a CA currency.\n  /// @param curr Currency Name.\n  /// @return rate Average rate X 100(of last 3 days).\n  function _getAvgRate(bytes4 curr, bool isIA) internal view returns (uint rate) {\n    if (curr == \"DAI\") {\n      DSValue ds = DSValue(daiFeedAddress);\n      rate = uint(ds.read()).div(uint(10) ** 16);\n    } else if (isIA) {\n      rate = iaAvgRate[curr];\n    } else {\n      rate = caAvgRate[curr];\n    }\n  }\n\n  /**\n   * @dev to set the ethereum volume limit\n   * @param val is the new limit value\n   */\n  function _setEthVolumeLimit(uint val) internal {\n    ethVolumeLimit = val;\n  }\n\n  /// @dev Sets minimum Cap.\n  function _changeMinCap(uint newCap) internal {\n    minCap = newCap;\n  }\n\n  /// @dev Sets Shock Parameter.\n  function _changeShockParameter(uint newParam) internal {\n    shockParameter = newParam;\n  }\n\n  /// @dev Changes time period for obtaining new MCR data from external oracle query.\n  function _changeMCRTime(uint _time) internal {\n    mcrTime = _time;\n  }\n\n  /// @dev Sets MCR Fail time.\n  function _changeMCRFailTime(uint _time) internal {\n    mcrFailTime = _time;\n  }\n\n  /**\n   * @dev to change the uniswap deadline time\n   * @param newDeadline is the value\n   */\n  function _changeUniswapDeadlineTime(uint newDeadline) internal {\n    uniswapDeadline = newDeadline;\n  }\n\n  /**\n   * @dev to change the liquidity trade call back time\n   * @param newTime is the new value to be set\n   */\n  function _changeliquidityTradeCallbackTime(uint newTime) internal {\n    liquidityTradeCallbackTime = newTime;\n  }\n\n  /**\n   * @dev Changes time after which investment asset rates need to be fed.\n   */\n  function _changeIARatesTime(uint _newTime) internal {\n    iaRatesTime = _newTime;\n  }\n\n  /**\n   * @dev Changes the variation range percentage.\n   */\n  function _changeVariationPercX100(uint newPercX100) internal {\n    variationPercX100 = newPercX100;\n  }\n\n  /// @dev Changes Growth Step\n  function _changeC(uint newC) internal {\n    c = newC;\n  }\n\n  /// @dev Changes scaling factor.\n  function _changeA(uint val) internal {\n    a = val;\n  }\n\n  /**\n   * @dev to change the capacity limit\n   * @param val is the new value\n   */\n  function _changeCapacityLimit(uint val) internal {\n    capacityLimit = val;\n  }\n}\n\n// File: contracts/modules/governance/external/Governed.sol\n\n/* Copyright (C) 2017 GovBlocks.io\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\ninterface IMaster {\n  function getLatestAddress(bytes2 _module) external view returns (address);\n}\n\ncontract Governed {\n\n  address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\n\n  /// @dev modifier that allows only the authorized addresses to execute the function\n  modifier onlyAuthorizedToGovern() {\n    IMaster ms = IMaster(masterAddress);\n    require(ms.getLatestAddress(\"GV\") == msg.sender, \"Not authorized\");\n    _;\n  }\n\n  /// @dev checks if an address is authorized to govern\n  function isAuthorizedToGovern(address _toCheck) public view returns (bool) {\n    IMaster ms = IMaster(masterAddress);\n    return (ms.getLatestAddress(\"GV\") == _toCheck);\n  }\n\n}\n\n// File: contracts/modules/governance/external/IProposalCategory.sol\n\n/* Copyright (C) 2017 GovBlocks.io\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\ncontract IProposalCategory {\n\n  event Category(\n    uint indexed categoryId,\n    string categoryName,\n    string actionHash\n  );\n\n  /// @dev Adds new category\n  /// @param _name Category name\n  /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  /// @param _allowedToCreateProposal Member roles allowed to create the proposal\n  /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  /// @param _closingTime Vote closing time for Each voting layer\n  /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  /// @param _contractAddress address of contract to call after proposal is accepted\n  /// @param _contractName name of contract to be called after proposal is accepted\n  /// @param _incentives rewards to distributed after proposal is accepted\n  function addCategory(\n    string calldata _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] calldata _allowedToCreateProposal,\n    uint _closingTime,\n    string calldata _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] calldata _incentives\n  )\n  external;\n\n  /// @dev gets category details\n  function category(uint _categoryId)\n  external\n  view\n  returns (\n    uint categoryId,\n    uint memberRoleToVote,\n    uint majorityVotePerc,\n    uint quorumPerc,\n    uint[] memory allowedToCreateProposal,\n    uint closingTime,\n    uint minStake\n  );\n\n  ///@dev gets category action details\n  function categoryAction(uint _categoryId)\n  external\n  view\n  returns (\n    uint categoryId,\n    address contractAddress,\n    bytes2 contractName,\n    uint defaultIncentive\n  );\n\n  /// @dev Gets Total number of categories added till now\n  function totalCategories() external view returns (uint numberOfCategories);\n\n  /// @dev Updates category details\n  /// @param _categoryId Category id that needs to be updated\n  /// @param _name Category name\n  /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  /// @param _allowedToCreateProposal Member roles allowed to create the proposal\n  /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  /// @param _closingTime Vote closing time for Each voting layer\n  /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  /// @param _contractAddress address of contract to call after proposal is accepted\n  /// @param _contractName name of contract to be called after proposal is accepted\n  /// @param _incentives rewards to distributed after proposal is accepted\n  function updateCategory(\n    uint _categoryId,\n    string memory _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] memory _allowedToCreateProposal,\n    uint _closingTime,\n    string memory _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] memory _incentives\n  )\n  public;\n\n}\n\n// File: contracts/modules/governance/ProposalCategory.sol\n\n/* Copyright (C) 2017 GovBlocks.io\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\npragma solidity ^0.5.0;\n\n\n\n\n\ncontract ProposalCategory is Governed, IProposalCategory, Iupgradable {\n\n  bool public constructorCheck;\n  MemberRoles internal mr;\n\n  struct CategoryStruct {\n    uint memberRoleToVote;\n    uint majorityVotePerc;\n    uint quorumPerc;\n    uint[] allowedToCreateProposal;\n    uint closingTime;\n    uint minStake;\n  }\n\n  struct CategoryAction {\n    uint defaultIncentive;\n    address contractAddress;\n    bytes2 contractName;\n  }\n\n  CategoryStruct[] internal allCategory;\n  mapping(uint => CategoryAction) internal categoryActionData;\n  mapping(uint => uint) public categoryABReq;\n  mapping(uint => uint) public isSpecialResolution;\n  mapping(uint => bytes) public categoryActionHashes;\n\n  bool public categoryActionHashUpdated;\n\n  /**\n  * @dev Adds new category (Discontinued, moved functionality to newCategory)\n  * @param _name Category name\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\n  * @param _closingTime Vote closing time for Each voting layer\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  * @param _contractAddress address of contract to call after proposal is accepted\n  * @param _contractName name of contract to be called after proposal is accepted\n  * @param _incentives rewards to distributed after proposal is accepted\n  */\n  function addCategory(\n    string calldata _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] calldata _allowedToCreateProposal,\n    uint _closingTime,\n    string calldata _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] calldata _incentives\n  ) external {}\n\n  /**\n  * @dev Initiates Default settings for Proposal Category contract (Adding default categories)\n  */\n  function proposalCategoryInitiate() external {}\n\n  /**\n  * @dev Initiates Default action function hashes for existing categories\n  * To be called after the contract has been upgraded by governance\n  */\n  function updateCategoryActionHashes() external onlyOwner {\n\n    require(!categoryActionHashUpdated, \"Category action hashes already updated\");\n    categoryActionHashUpdated = true;\n    categoryActionHashes[1] = abi.encodeWithSignature(\"addRole(bytes32,string,address)\");\n    categoryActionHashes[2] = abi.encodeWithSignature(\"updateRole(address,uint256,bool)\");\n    categoryActionHashes[3] = abi.encodeWithSignature(\"newCategory(string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\"); // solhint-disable-line\n    categoryActionHashes[4] = abi.encodeWithSignature(\"editCategory(uint256,string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\"); // solhint-disable-line\n    categoryActionHashes[5] = abi.encodeWithSignature(\"upgradeContractImplementation(bytes2,address)\");\n    categoryActionHashes[6] = abi.encodeWithSignature(\"startEmergencyPause()\");\n    categoryActionHashes[7] = abi.encodeWithSignature(\"addEmergencyPause(bool,bytes4)\");\n    categoryActionHashes[8] = abi.encodeWithSignature(\"burnCAToken(uint256,uint256,address)\");\n    categoryActionHashes[9] = abi.encodeWithSignature(\"setUserClaimVotePausedOn(address)\");\n    categoryActionHashes[12] = abi.encodeWithSignature(\"transferEther(uint256,address)\");\n    categoryActionHashes[13] = abi.encodeWithSignature(\"addInvestmentAssetCurrency(bytes4,address,bool,uint64,uint64,uint8)\"); // solhint-disable-line\n    categoryActionHashes[14] = abi.encodeWithSignature(\"changeInvestmentAssetHoldingPerc(bytes4,uint64,uint64)\");\n    categoryActionHashes[15] = abi.encodeWithSignature(\"changeInvestmentAssetStatus(bytes4,bool)\");\n    categoryActionHashes[16] = abi.encodeWithSignature(\"swapABMember(address,address)\");\n    categoryActionHashes[17] = abi.encodeWithSignature(\"addCurrencyAssetCurrency(bytes4,address,uint256)\");\n    categoryActionHashes[20] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[21] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[22] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[23] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[24] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[25] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[26] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\n    categoryActionHashes[27] = abi.encodeWithSignature(\"updateAddressParameters(bytes8,address)\");\n    categoryActionHashes[28] = abi.encodeWithSignature(\"updateOwnerParameters(bytes8,address)\");\n    categoryActionHashes[29] = abi.encodeWithSignature(\"upgradeContract(bytes2,address)\");\n    categoryActionHashes[30] = abi.encodeWithSignature(\"changeCurrencyAssetAddress(bytes4,address)\");\n    categoryActionHashes[31] = abi.encodeWithSignature(\"changeCurrencyAssetBaseMin(bytes4,uint256)\");\n    categoryActionHashes[32] = abi.encodeWithSignature(\"changeInvestmentAssetAddressAndDecimal(bytes4,address,uint8)\"); // solhint-disable-line\n    categoryActionHashes[33] = abi.encodeWithSignature(\"externalLiquidityTrade()\");\n  }\n\n  /**\n  * @dev Gets Total number of categories added till now\n  */\n  function totalCategories() external view returns (uint) {\n    return allCategory.length;\n  }\n\n  /**\n  * @dev Gets category details\n  */\n  function category(uint _categoryId) external view returns (uint, uint, uint, uint, uint[] memory, uint, uint) {\n    return (\n    _categoryId,\n    allCategory[_categoryId].memberRoleToVote,\n    allCategory[_categoryId].majorityVotePerc,\n    allCategory[_categoryId].quorumPerc,\n    allCategory[_categoryId].allowedToCreateProposal,\n    allCategory[_categoryId].closingTime,\n    allCategory[_categoryId].minStake\n    );\n  }\n\n  /**\n  * @dev Gets category ab required and isSpecialResolution\n  * @return the category id\n  * @return if AB voting is required\n  * @return is category a special resolution\n  */\n  function categoryExtendedData(uint _categoryId) external view returns (uint, uint, uint) {\n    return (\n    _categoryId,\n    categoryABReq[_categoryId],\n    isSpecialResolution[_categoryId]\n    );\n  }\n\n  /**\n   * @dev Gets the category acion details\n   * @param _categoryId is the category id in concern\n   * @return the category id\n   * @return the contract address\n   * @return the contract name\n   * @return the default incentive\n   */\n  function categoryAction(uint _categoryId) external view returns (uint, address, bytes2, uint) {\n\n    return (\n    _categoryId,\n    categoryActionData[_categoryId].contractAddress,\n    categoryActionData[_categoryId].contractName,\n    categoryActionData[_categoryId].defaultIncentive\n    );\n  }\n\n  /**\n   * @dev Gets the category acion details of a category id\n   * @param _categoryId is the category id in concern\n   * @return the category id\n   * @return the contract address\n   * @return the contract name\n   * @return the default incentive\n   * @return action function hash\n   */\n  function categoryActionDetails(uint _categoryId) external view returns (uint, address, bytes2, uint, bytes memory) {\n    return (\n    _categoryId,\n    categoryActionData[_categoryId].contractAddress,\n    categoryActionData[_categoryId].contractName,\n    categoryActionData[_categoryId].defaultIncentive,\n    categoryActionHashes[_categoryId]\n    );\n  }\n\n  /**\n  * @dev Updates dependant contract addresses\n  */\n  function changeDependentContractAddress() public {\n    mr = MemberRoles(ms.getLatestAddress(\"MR\"));\n  }\n\n  /**\n  * @dev Adds new category\n  * @param _name Category name\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\n  * @param _closingTime Vote closing time for Each voting layer\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  * @param _contractAddress address of contract to call after proposal is accepted\n  * @param _contractName name of contract to be called after proposal is accepted\n  * @param _incentives rewards to distributed after proposal is accepted\n  * @param _functionHash function signature to be executed\n  */\n  function newCategory(\n    string memory _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] memory _allowedToCreateProposal,\n    uint _closingTime,\n    string memory _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] memory _incentives,\n    string memory _functionHash\n  )\n  public\n  onlyAuthorizedToGovern\n  {\n\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n    require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n    require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n    //If category is special resolution role authorized should be member\n    if (_incentives[3] == 1) {\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n      _majorityVotePerc = 0;\n      _quorumPerc = 0;\n    }\n\n    _addCategory(\n      _name,\n      _memberRoleToVote,\n      _majorityVotePerc,\n      _quorumPerc,\n      _allowedToCreateProposal,\n      _closingTime,\n      _actionHash,\n      _contractAddress,\n      _contractName,\n      _incentives\n    );\n\n\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n      categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\n    }\n  }\n\n  /**\n   * @dev Changes the master address and update it's instance\n   * @param _masterAddress is the new master address\n   */\n  function changeMasterAddress(address _masterAddress) public {\n    if (masterAddress != address(0))\n      require(masterAddress == msg.sender);\n    masterAddress = _masterAddress;\n    ms = INXMMaster(_masterAddress);\n    nxMasterAddress = _masterAddress;\n\n  }\n\n  /**\n  * @dev Updates category details (Discontinued, moved functionality to editCategory)\n  * @param _categoryId Category id that needs to be updated\n  * @param _name Category name\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  * @param _closingTime Vote closing time for Each voting layer\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  * @param _contractAddress address of contract to call after proposal is accepted\n  * @param _contractName name of contract to be called after proposal is accepted\n  * @param _incentives rewards to distributed after proposal is accepted\n  */\n  function updateCategory(\n    uint _categoryId,\n    string memory _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] memory _allowedToCreateProposal,\n    uint _closingTime,\n    string memory _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] memory _incentives\n  ) public {}\n\n  /**\n  * @dev Updates category details\n  * @param _categoryId Category id that needs to be updated\n  * @param _name Category name\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  * @param _closingTime Vote closing time for Each voting layer\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  * @param _contractAddress address of contract to call after proposal is accepted\n  * @param _contractName name of contract to be called after proposal is accepted\n  * @param _incentives rewards to distributed after proposal is accepted\n  * @param _functionHash function signature to be executed\n  */\n  function editCategory(\n    uint _categoryId,\n    string memory _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] memory _allowedToCreateProposal,\n    uint _closingTime,\n    string memory _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] memory _incentives,\n    string memory _functionHash\n  )\n  public\n  onlyAuthorizedToGovern\n  {\n    require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n    require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n    require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n    //If category is special resolution role authorized should be member\n    if (_incentives[3] == 1) {\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n      _majorityVotePerc = 0;\n      _quorumPerc = 0;\n    }\n\n    delete categoryActionHashes[_categoryId];\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n      categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\n    }\n    allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n    allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n    allCategory[_categoryId].closingTime = _closingTime;\n    allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n    allCategory[_categoryId].minStake = _incentives[0];\n    allCategory[_categoryId].quorumPerc = _quorumPerc;\n    categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n    categoryActionData[_categoryId].contractName = _contractName;\n    categoryActionData[_categoryId].contractAddress = _contractAddress;\n    categoryABReq[_categoryId] = _incentives[2];\n    isSpecialResolution[_categoryId] = _incentives[3];\n    emit Category(_categoryId, _name, _actionHash);\n  }\n\n  /**\n  * @dev Internal call to add new category\n  * @param _name Category name\n  * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n  * @param _majorityVotePerc Majority Vote threshold for Each voting layer\n  * @param _quorumPerc minimum threshold percentage required in voting to calculate result\n  * @param _allowedToCreateProposal Member roles allowed to create the proposal\n  * @param _closingTime Vote closing time for Each voting layer\n  * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n  * @param _contractAddress address of contract to call after proposal is accepted\n  * @param _contractName name of contract to be called after proposal is accepted\n  * @param _incentives rewards to distributed after proposal is accepted\n  */\n  function _addCategory(\n    string memory _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] memory _allowedToCreateProposal,\n    uint _closingTime,\n    string memory _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] memory _incentives\n  )\n  internal\n  {\n    require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n    allCategory.push(\n      CategoryStruct(\n        _memberRoleToVote,\n        _majorityVotePerc,\n        _quorumPerc,\n        _allowedToCreateProposal,\n        _closingTime,\n        _incentives[0]\n      )\n    );\n    uint categoryId = allCategory.length - 1;\n    categoryActionData[categoryId] = CategoryAction(_incentives[1], _contractAddress, _contractName);\n    categoryABReq[categoryId] = _incentives[2];\n    isSpecialResolution[categoryId] = _incentives[3];\n    emit Category(categoryId, _name, _actionHash);\n  }\n\n  /**\n  * @dev Internal call to check if given roles are valid or not\n  */\n  function _verifyMemberRoles(uint _memberRoleToVote, uint[] memory _allowedToCreateProposal)\n  internal view returns (uint) {\n    uint totalRoles = mr.totalRoles();\n    if (_memberRoleToVote >= totalRoles) {\n      return 0;\n    }\n    for (uint i = 0; i < _allowedToCreateProposal.length; i++) {\n      if (_allowedToCreateProposal[i] >= totalRoles) {\n        return 0;\n      }\n    }\n    return 1;\n  }\n\n}\n\n// File: contracts/modules/governance/external/IGovernance.sol\n\n/* Copyright (C) 2017 GovBlocks.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\ncontract IGovernance {\n\n  event Proposal(\n    address indexed proposalOwner,\n    uint256 indexed proposalId,\n    uint256 dateAdd,\n    string proposalTitle,\n    string proposalSD,\n    string proposalDescHash\n  );\n\n  event Solution(\n    uint256 indexed proposalId,\n    address indexed solutionOwner,\n    uint256 indexed solutionId,\n    string solutionDescHash,\n    uint256 dateAdd\n  );\n\n  event Vote(\n    address indexed from,\n    uint256 indexed proposalId,\n    uint256 indexed voteId,\n    uint256 dateAdd,\n    uint256 solutionChosen\n  );\n\n  event RewardClaimed(\n    address indexed member,\n    uint gbtReward\n  );\n\n  /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal.\n  event VoteCast (uint256 proposalId);\n\n  /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can\n  ///      call any offchain actions\n  event ProposalAccepted (uint256 proposalId);\n\n  /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\n  event CloseProposalOnTime (\n    uint256 indexed proposalId,\n    uint256 time\n  );\n\n  /// @dev ActionSuccess event is called whenever an onchain action is executed.\n  event ActionSuccess (\n    uint256 proposalId\n  );\n\n  /// @dev Creates a new proposal\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\n  function createProposal(\n    string calldata _proposalTitle,\n    string calldata _proposalSD,\n    string calldata _proposalDescHash,\n    uint _categoryId\n  )\n  external;\n\n  /// @dev Edits the details of an existing proposal and creates new version\n  /// @param _proposalId Proposal id that details needs to be updated\n  /// @param _proposalDescHash Proposal description hash having long and short description of proposal.\n  function updateProposal(\n    uint _proposalId,\n    string calldata _proposalTitle,\n    string calldata _proposalSD,\n    string calldata _proposalDescHash\n  )\n  external;\n\n  /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\n  function categorizeProposal(\n    uint _proposalId,\n    uint _categoryId,\n    uint _incentives\n  )\n  external;\n\n  /// @dev Submit proposal with solution\n  /// @param _proposalId Proposal id\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\n  function submitProposalWithSolution(\n    uint _proposalId,\n    string calldata _solutionHash,\n    bytes calldata _action\n  )\n  external;\n\n  /// @dev Creates a new proposal with solution and votes for the solution\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\n  function createProposalwithSolution(\n    string calldata _proposalTitle,\n    string calldata _proposalSD,\n    string calldata _proposalDescHash,\n    uint _categoryId,\n    string calldata _solutionHash,\n    bytes calldata _action\n  )\n  external;\n\n  /// @dev Casts vote\n  /// @param _proposalId Proposal id\n  /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\n  function submitVote(uint _proposalId, uint _solutionChosen) external;\n\n  function closeProposal(uint _proposalId) external;\n\n  function claimReward(address _memberAddress, uint _maxRecords) external returns (uint pendingDAppReward);\n\n  function proposal(uint _proposalId)\n  external\n  view\n  returns (\n    uint proposalId,\n    uint category,\n    uint status,\n    uint finalVerdict,\n    uint totalReward\n  );\n\n  function canCloseProposal(uint _proposalId) public view returns (uint closeValue);\n\n  function allowedToCatgorize() public view returns (uint roleId);\n\n}\n\n// File: contracts/modules/governance/Governance.sol\n\n// /* Copyright (C) 2017 GovBlocks.io\r\n\r\n//   This program is free software: you can redistribute it and/or modify\r\n//     it under the terms of the GNU General Public License as published by\r\n//     the Free Software Foundation, either version 3 of the License, or\r\n//     (at your option) any later version.\r\n\r\n//   This program is distributed in the hope that it will be useful,\r\n//     but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n//     GNU General Public License for more details.\r\n\r\n//   You should have received a copy of the GNU General Public License\r\n//     along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity ^0.5.0;\r\r\r\r\r\r\n\r\ncontract Governance is IGovernance, Iupgradable {\r\n\r\n  using SafeMath for uint;\r\n\r\n  enum ProposalStatus {\r\n    Draft,\r\n    AwaitingSolution,\r\n    VotingStarted,\r\n    Accepted,\r\n    Rejected,\r\n    Majority_Not_Reached_But_Accepted,\r\n    Denied\r\n  }\r\n\r\n  struct ProposalData {\r\n    uint propStatus;\r\n    uint finalVerdict;\r\n    uint category;\r\n    uint commonIncentive;\r\n    uint dateUpd;\r\n    address owner;\r\n  }\r\n\r\n  struct ProposalVote {\r\n    address voter;\r\n    uint proposalId;\r\n    uint dateAdd;\r\n  }\r\n\r\n  struct VoteTally {\r\n    mapping(uint => uint) memberVoteValue;\r\n    mapping(uint => uint) abVoteValue;\r\n    uint voters;\r\n  }\r\n\r\n  struct DelegateVote {\r\n    address follower;\r\n    address leader;\r\n    uint lastUpd;\r\n  }\r\n\r\n  ProposalVote[] internal allVotes;\r\n  DelegateVote[] public allDelegation;\r\n\r\n  mapping(uint => ProposalData) internal allProposalData;\r\n  mapping(uint => bytes[]) internal allProposalSolutions;\r\n  mapping(address => uint[]) internal allVotesByMember;\r\n  mapping(uint => mapping(address => bool)) public rewardClaimed;\r\n  mapping(address => mapping(uint => uint)) public memberProposalVote;\r\n  mapping(address => uint) public followerDelegation;\r\n  mapping(address => uint) internal followerCount;\r\n  mapping(address => uint[]) internal leaderDelegation;\r\n  mapping(uint => VoteTally) public proposalVoteTally;\r\n  mapping(address => bool) public isOpenForDelegation;\r\n  mapping(address => uint) public lastRewardClaimed;\r\n\r\n  bool internal constructorCheck;\r\n  uint public tokenHoldingTime;\r\n  uint internal roleIdAllowedToCatgorize;\r\n  uint internal maxVoteWeigthPer;\r\n  uint internal specialResolutionMajPerc;\r\n  uint internal maxFollowers;\r\n  uint internal totalProposals;\r\n  uint internal maxDraftTime;\r\n\r\n  MemberRoles internal memberRole;\r\n  ProposalCategory internal proposalCategory;\r\n  TokenController internal tokenInstance;\r\n\r\n  mapping(uint => uint) public proposalActionStatus;\r\n  mapping(uint => uint) internal proposalExecutionTime;\r\n  mapping(uint => mapping(address => bool)) public proposalRejectedByAB;\r\n  mapping(uint => uint) internal actionRejectedCount;\r\n\r\n  bool internal actionParamsInitialised;\r\n  uint internal actionWaitingTime;\r\n  uint constant internal AB_MAJ_TO_REJECT_ACTION = 3;\r\n\r\n  enum ActionStatus {\r\n    Pending,\r\n    Accepted,\r\n    Rejected,\r\n    Executed,\r\n    NoAction\r\n  }\r\n\r\n  /**\r\n  * @dev Called whenever an action execution is failed.\r\n  */\r\n  event ActionFailed (\r\n    uint256 proposalId\r\n  );\r\n\r\n  /**\r\n  * @dev Called whenever an AB member rejects the action execution.\r\n  */\r\n  event ActionRejected (\r\n    uint256 indexed proposalId,\r\n    address rejectedBy\r\n  );\r\n\r\n  /**\r\n  * @dev Checks if msg.sender is proposal owner\r\n  */\r\n  modifier onlyProposalOwner(uint _proposalId) {\r\n    require(msg.sender == allProposalData[_proposalId].owner, \"Not allowed\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if proposal is opened for voting\r\n  */\r\n  modifier voteNotStarted(uint _proposalId) {\r\n    require(allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted));\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if msg.sender is allowed to create proposal under given category\r\n  */\r\n  modifier isAllowed(uint _categoryId) {\r\n    require(allowedToCreateProposal(_categoryId), \"Not allowed\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if msg.sender is allowed categorize proposal under given category\r\n  */\r\n  modifier isAllowedToCategorize() {\r\n    require(memberRole.checkRole(msg.sender, roleIdAllowedToCatgorize), \"Not allowed\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if msg.sender had any pending rewards to be claimed\r\n  */\r\n  modifier checkPendingRewards {\r\n    require(getPendingReward(msg.sender) == 0, \"Claim reward\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Event emitted whenever a proposal is categorized\r\n  */\r\n  event ProposalCategorized(\r\n    uint indexed proposalId,\r\n    address indexed categorizedBy,\r\n    uint categoryId\r\n  );\r\n\r\n  /**\r\n   * @dev Removes delegation of an address.\r\n   * @param _add address to undelegate.\r\n   */\r\n  function removeDelegation(address _add) external onlyInternal {\r\n    _unDelegate(_add);\r\n  }\r\n\r\n  /**\r\n  * @dev Creates a new proposal\r\n  * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n  * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n  */\r\n  function createProposal(\r\n    string calldata _proposalTitle,\r\n    string calldata _proposalSD,\r\n    string calldata _proposalDescHash,\r\n    uint _categoryId\r\n  )\r\n  external isAllowed(_categoryId)\r\n  {\r\n    require(ms.isMember(msg.sender), \"Not Member\");\r\n\r\n    _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\r\n  }\r\n\r\n  /**\r\n  * @dev Edits the details of an existing proposal\r\n  * @param _proposalId Proposal id that details needs to be updated\r\n  * @param _proposalDescHash Proposal description hash having long and short description of proposal.\r\n  */\r\n  function updateProposal(\r\n    uint _proposalId,\r\n    string calldata _proposalTitle,\r\n    string calldata _proposalSD,\r\n    string calldata _proposalDescHash\r\n  )\r\n  external onlyProposalOwner(_proposalId)\r\n  {\r\n    require(\r\n      allProposalSolutions[_proposalId].length < 2,\r\n      \"Not allowed\"\r\n    );\r\n    allProposalData[_proposalId].propStatus = uint(ProposalStatus.Draft);\r\n    allProposalData[_proposalId].category = 0;\r\n    allProposalData[_proposalId].commonIncentive = 0;\r\n    emit Proposal(\r\n      allProposalData[_proposalId].owner,\r\n      _proposalId,\r\n      now,\r\n      _proposalTitle,\r\n      _proposalSD,\r\n      _proposalDescHash\r\n    );\r\n  }\r\n\r\n  /**\r\n  * @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\r\n  */\r\n  function categorizeProposal(\r\n    uint _proposalId,\r\n    uint _categoryId,\r\n    uint _incentive\r\n  )\r\n  external\r\n  voteNotStarted(_proposalId) isAllowedToCategorize\r\n  {\r\n    _categorizeProposal(_proposalId, _categoryId, _incentive);\r\n  }\r\n\r\n  /**\r\n  * @dev Submit proposal with solution\r\n  * @param _proposalId Proposal id\r\n  * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n  */\r\n  function submitProposalWithSolution(\r\n    uint _proposalId,\r\n    string calldata _solutionHash,\r\n    bytes calldata _action\r\n  )\r\n  external\r\n  onlyProposalOwner(_proposalId)\r\n  {\r\n\r\n    require(allProposalData[_proposalId].propStatus == uint(ProposalStatus.AwaitingSolution));\r\n\r\n    _proposalSubmission(_proposalId, _solutionHash, _action);\r\n  }\r\n\r\n  /**\r\n  * @dev Creates a new proposal with solution\r\n  * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n  * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n  * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n  */\r\n  function createProposalwithSolution(\r\n    string calldata _proposalTitle,\r\n    string calldata _proposalSD,\r\n    string calldata _proposalDescHash,\r\n    uint _categoryId,\r\n    string calldata _solutionHash,\r\n    bytes calldata _action\r\n  )\r\n  external isAllowed(_categoryId)\r\n  {\r\n\r\n\r\n    uint proposalId = totalProposals;\r\n\r\n    _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\r\n\r\n    require(_categoryId > 0);\r\n\r\n    _proposalSubmission(\r\n      proposalId,\r\n      _solutionHash,\r\n      _action\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Submit a vote on the proposal.\r\n   * @param _proposalId to vote upon.\r\n   * @param _solutionChosen is the chosen vote.\r\n   */\r\n  function submitVote(uint _proposalId, uint _solutionChosen) external {\r\n\r\n    require(allProposalData[_proposalId].propStatus ==\r\n      uint(Governance.ProposalStatus.VotingStarted), \"Not allowed\");\r\n\r\n    require(_solutionChosen < allProposalSolutions[_proposalId].length);\r\n\r\n\r\n    _submitVote(_proposalId, _solutionChosen);\r\n  }\r\n\r\n  /**\r\n   * @dev Closes the proposal.\r\n   * @param _proposalId of proposal to be closed.\r\n   */\r\n  function closeProposal(uint _proposalId) external {\r\n    uint category = allProposalData[_proposalId].category;\r\n\r\n\r\n    uint _memberRole;\r\n    if (allProposalData[_proposalId].dateUpd.add(maxDraftTime) <= now &&\r\n      allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted)) {\r\n      _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n    } else {\r\n      require(canCloseProposal(_proposalId) == 1);\r\n      (, _memberRole,,,,,) = proposalCategory.category(allProposalData[_proposalId].category);\r\n      if (_memberRole == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n        _closeAdvisoryBoardVote(_proposalId, category);\r\n      } else {\r\n        _closeMemberVote(_proposalId, category);\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Claims reward for member.\r\n   * @param _memberAddress to claim reward of.\r\n   * @param _maxRecords maximum number of records to claim reward for.\r\n   _proposals list of proposals of which reward will be claimed.\r\n   * @return amount of pending reward.\r\n   */\r\n  function claimReward(address _memberAddress, uint _maxRecords)\r\n  external returns (uint pendingDAppReward)\r\n  {\r\n\r\n    uint voteId;\r\n    address leader;\r\n    uint lastUpd;\r\n\r\n    require(msg.sender == ms.getLatestAddress(\"CR\"));\r\n\r\n    uint delegationId = followerDelegation[_memberAddress];\r\n    DelegateVote memory delegationData = allDelegation[delegationId];\r\n    if (delegationId > 0 && delegationData.leader != address(0)) {\r\n      leader = delegationData.leader;\r\n      lastUpd = delegationData.lastUpd;\r\n    } else\r\n      leader = _memberAddress;\r\n\r\n    uint proposalId;\r\n    uint totalVotes = allVotesByMember[leader].length;\r\n    uint lastClaimed = totalVotes;\r\n    uint j;\r\n    uint i;\r\n    for (i = lastRewardClaimed[_memberAddress]; i < totalVotes && j < _maxRecords; i++) {\r\n      voteId = allVotesByMember[leader][i];\r\n      proposalId = allVotes[voteId].proposalId;\r\n      if (proposalVoteTally[proposalId].voters > 0 && (allVotes[voteId].dateAdd > (\r\n      lastUpd.add(tokenHoldingTime)) || leader == _memberAddress)) {\r\n        if (allProposalData[proposalId].propStatus > uint(ProposalStatus.VotingStarted)) {\r\n          if (!rewardClaimed[voteId][_memberAddress]) {\r\n            pendingDAppReward = pendingDAppReward.add(\r\n              allProposalData[proposalId].commonIncentive.div(\r\n                proposalVoteTally[proposalId].voters\r\n              )\r\n            );\r\n            rewardClaimed[voteId][_memberAddress] = true;\r\n            j++;\r\n          }\r\n        } else {\r\n          if (lastClaimed == totalVotes) {\r\n            lastClaimed = i;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (lastClaimed == totalVotes) {\r\n      lastRewardClaimed[_memberAddress] = i;\r\n    } else {\r\n      lastRewardClaimed[_memberAddress] = lastClaimed;\r\n    }\r\n\r\n    if (j > 0) {\r\n      emit RewardClaimed(\r\n        _memberAddress,\r\n        pendingDAppReward\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets delegation acceptance status of individual user\r\n   * @param _status delegation acceptance status\r\n   */\r\n  function setDelegationStatus(bool _status) external isMemberAndcheckPause checkPendingRewards {\r\n    isOpenForDelegation[msg.sender] = _status;\r\n  }\r\n\r\n  /**\r\n   * @dev Delegates vote to an address.\r\n   * @param _add is the address to delegate vote to.\r\n   */\r\n  function delegateVote(address _add) external isMemberAndcheckPause checkPendingRewards {\r\n\r\n    require(ms.masterInitialized());\r\n\r\n    require(allDelegation[followerDelegation[_add]].leader == address(0));\r\n\r\n    if (followerDelegation[msg.sender] > 0) {\r\n      require((allDelegation[followerDelegation[msg.sender]].lastUpd).add(tokenHoldingTime) < now);\r\n    }\r\n\r\n    require(!alreadyDelegated(msg.sender));\r\n    require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.Owner)));\r\n    require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)));\r\n\r\n\r\n    require(followerCount[_add] < maxFollowers);\r\n\r\n    if (allVotesByMember[msg.sender].length > 0) {\r\n      require((allVotes[allVotesByMember[msg.sender][allVotesByMember[msg.sender].length - 1]].dateAdd).add(tokenHoldingTime)\r\n        < now);\r\n    }\r\n\r\n    require(ms.isMember(_add));\r\n\r\n    require(isOpenForDelegation[_add]);\r\n\r\n    allDelegation.push(DelegateVote(msg.sender, _add, now));\r\n    followerDelegation[msg.sender] = allDelegation.length - 1;\r\n    leaderDelegation[_add].push(allDelegation.length - 1);\r\n    followerCount[_add]++;\r\n    lastRewardClaimed[msg.sender] = allVotesByMember[_add].length;\r\n  }\r\n\r\n  /**\r\n   * @dev Undelegates the sender\r\n   */\r\n  function unDelegate() external isMemberAndcheckPause checkPendingRewards {\r\n    _unDelegate(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Triggers action of accepted proposal after waiting time is finished\r\n   */\r\n  function triggerAction(uint _proposalId) external {\r\n    require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted) && proposalExecutionTime[_proposalId] <= now, \"Cannot trigger\");\r\n    _triggerAction(_proposalId, allProposalData[_proposalId].category);\r\n  }\r\n\r\n  /**\r\n   * @dev Provides option to Advisory board member to reject proposal action execution within actionWaitingTime, if found suspicious\r\n   */\r\n  function rejectAction(uint _proposalId) external {\r\n    require(memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && proposalExecutionTime[_proposalId] > now);\r\n\r\n    require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted));\r\n\r\n    require(!proposalRejectedByAB[_proposalId][msg.sender]);\r\n\r\n    require(\r\n      keccak256(proposalCategory.categoryActionHashes(allProposalData[_proposalId].category))\r\n      != keccak256(abi.encodeWithSignature(\"swapABMember(address,address)\"))\r\n    );\r\n\r\n    proposalRejectedByAB[_proposalId][msg.sender] = true;\r\n    actionRejectedCount[_proposalId]++;\r\n    emit ActionRejected(_proposalId, msg.sender);\r\n    if (actionRejectedCount[_proposalId] == AB_MAJ_TO_REJECT_ACTION) {\r\n      proposalActionStatus[_proposalId] = uint(ActionStatus.Rejected);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets intial actionWaitingTime value\r\n   * To be called after governance implementation has been updated\r\n   */\r\n  function setInitialActionParameters() external onlyOwner {\r\n    require(!actionParamsInitialised);\r\n    actionParamsInitialised = true;\r\n    actionWaitingTime = 24 * 1 hours;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Uint Parameters of a code\r\n   * @param code whose details we want\r\n   * @return string value of the code\r\n   * @return associated amount (time or perc or value) to the code\r\n   */\r\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\r\n\r\n    codeVal = code;\r\n\r\n    if (code == \"GOVHOLD\") {\r\n\r\n      val = tokenHoldingTime / (1 days);\r\n\r\n    } else if (code == \"MAXFOL\") {\r\n\r\n      val = maxFollowers;\r\n\r\n    } else if (code == \"MAXDRFT\") {\r\n\r\n      val = maxDraftTime / (1 days);\r\n\r\n    } else if (code == \"EPTIME\") {\r\n\r\n      val = ms.pauseTime() / (1 days);\r\n\r\n    } else if (code == \"ACWT\") {\r\n\r\n      val = actionWaitingTime / (1 hours);\r\n\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets all details of a propsal\r\n   * @param _proposalId whose details we want\r\n   * @return proposalId\r\n   * @return category\r\n   * @return status\r\n   * @return finalVerdict\r\n   * @return totalReward\r\n   */\r\n  function proposal(uint _proposalId)\r\n  external\r\n  view\r\n  returns (\r\n    uint proposalId,\r\n    uint category,\r\n    uint status,\r\n    uint finalVerdict,\r\n    uint totalRewar\r\n  )\r\n  {\r\n    return (\r\n    _proposalId,\r\n    allProposalData[_proposalId].category,\r\n    allProposalData[_proposalId].propStatus,\r\n    allProposalData[_proposalId].finalVerdict,\r\n    allProposalData[_proposalId].commonIncentive\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets some details of a propsal\r\n   * @param _proposalId whose details we want\r\n   * @return proposalId\r\n   * @return number of all proposal solutions\r\n   * @return amount of votes\r\n   */\r\n  function proposalDetails(uint _proposalId) external view returns (uint, uint, uint) {\r\n    return (\r\n    _proposalId,\r\n    allProposalSolutions[_proposalId].length,\r\n    proposalVoteTally[_proposalId].voters\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets solution action on a proposal\r\n   * @param _proposalId whose details we want\r\n   * @param _solution whose details we want\r\n   * @return action of a solution on a proposal\r\n   */\r\n  function getSolutionAction(uint _proposalId, uint _solution) external view returns (uint, bytes memory) {\r\n    return (\r\n    _solution,\r\n    allProposalSolutions[_proposalId][_solution]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets length of propsal\r\n   * @return length of propsal\r\n   */\r\n  function getProposalLength() external view returns (uint) {\r\n    return totalProposals;\r\n  }\r\n\r\n  /**\r\n   * @dev Get followers of an address\r\n   * @return get followers of an address\r\n   */\r\n  function getFollowers(address _add) external view returns (uint[] memory) {\r\n    return leaderDelegation[_add];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets pending rewards of a member\r\n   * @param _memberAddress in concern\r\n   * @return amount of pending reward\r\n   */\r\n  function getPendingReward(address _memberAddress)\r\n  public view returns (uint pendingDAppReward)\r\n  {\r\n    uint delegationId = followerDelegation[_memberAddress];\r\n    address leader;\r\n    uint lastUpd;\r\n    DelegateVote memory delegationData = allDelegation[delegationId];\r\n\r\n    if (delegationId > 0 && delegationData.leader != address(0)) {\r\n      leader = delegationData.leader;\r\n      lastUpd = delegationData.lastUpd;\r\n    } else\r\n      leader = _memberAddress;\r\n\r\n    uint proposalId;\r\n    for (uint i = lastRewardClaimed[_memberAddress]; i < allVotesByMember[leader].length; i++) {\r\n      if (allVotes[allVotesByMember[leader][i]].dateAdd > (\r\n      lastUpd.add(tokenHoldingTime)) || leader == _memberAddress) {\r\n        if (!rewardClaimed[allVotesByMember[leader][i]][_memberAddress]) {\r\n          proposalId = allVotes[allVotesByMember[leader][i]].proposalId;\r\n          if (proposalVoteTally[proposalId].voters > 0 && allProposalData[proposalId].propStatus\r\n          > uint(ProposalStatus.VotingStarted)) {\r\n            pendingDAppReward = pendingDAppReward.add(\r\n              allProposalData[proposalId].commonIncentive.div(\r\n                proposalVoteTally[proposalId].voters\r\n              )\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Updates Uint Parameters of a code\r\n   * @param code whose details we want to update\r\n   * @param val value to set\r\n   */\r\n  function updateUintParameters(bytes8 code, uint val) public {\r\n\r\n    require(ms.checkIsAuthToGoverned(msg.sender));\r\n    if (code == \"GOVHOLD\") {\r\n\r\n      tokenHoldingTime = val * 1 days;\r\n\r\n    } else if (code == \"MAXFOL\") {\r\n\r\n      maxFollowers = val;\r\n\r\n    } else if (code == \"MAXDRFT\") {\r\n\r\n      maxDraftTime = val * 1 days;\r\n\r\n    } else if (code == \"EPTIME\") {\r\n\r\n      ms.updatePauseTime(val * 1 days);\r\n\r\n    } else if (code == \"ACWT\") {\r\n\r\n      actionWaitingTime = val * 1 hours;\r\n\r\n    } else {\r\n\r\n      revert(\"Invalid code\");\r\n\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Updates all dependency addresses to latest ones from Master\r\n  */\r\n  function changeDependentContractAddress() public {\r\n    tokenInstance = TokenController(ms.dAppLocker());\r\n    memberRole = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n    proposalCategory = ProposalCategory(ms.getLatestAddress(\"PC\"));\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if msg.sender is allowed to create a proposal under given category\r\n  */\r\n  function allowedToCreateProposal(uint category) public view returns (bool check) {\r\n    if (category == 0)\r\n      return true;\r\n    uint[] memory mrAllowed;\r\n    (,,,, mrAllowed,,) = proposalCategory.category(category);\r\n    for (uint i = 0; i < mrAllowed.length; i++) {\r\n      if (mrAllowed[i] == 0 || memberRole.checkRole(msg.sender, mrAllowed[i]))\r\n        return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if an address is already delegated\r\n   * @param _add in concern\r\n   * @return bool value if the address is delegated or not\r\n   */\r\n  function alreadyDelegated(address _add) public view returns (bool delegated) {\r\n    for (uint i = 0; i < leaderDelegation[_add].length; i++) {\r\n      if (allDelegation[leaderDelegation[_add][i]].leader == _add) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Checks If the proposal voting time is up and it's ready to close\r\n  *      i.e. Closevalue is 1 if proposal is ready to be closed, 2 if already closed, 0 otherwise!\r\n  * @param _proposalId Proposal id to which closing value is being checked\r\n  */\r\n  function canCloseProposal(uint _proposalId)\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    uint dateUpdate;\r\n    uint pStatus;\r\n    uint _closingTime;\r\n    uint _roleId;\r\n    uint majority;\r\n    pStatus = allProposalData[_proposalId].propStatus;\r\n    dateUpdate = allProposalData[_proposalId].dateUpd;\r\n    (, _roleId, majority, , , _closingTime,) = proposalCategory.category(allProposalData[_proposalId].category);\r\n    if (\r\n      pStatus == uint(ProposalStatus.VotingStarted)\r\n    ) {\r\n      uint numberOfMembers = memberRole.numberOfMembers(_roleId);\r\n      if (_roleId == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n        if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers) >= majority\r\n        || proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0]) == numberOfMembers\r\n          || dateUpdate.add(_closingTime) <= now) {\r\n\r\n          return 1;\r\n        }\r\n      } else {\r\n        if (numberOfMembers == proposalVoteTally[_proposalId].voters\r\n          || dateUpdate.add(_closingTime) <= now)\r\n          return 1;\r\n      }\r\n    } else if (pStatus > uint(ProposalStatus.VotingStarted)) {\r\n      return 2;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets Id of member role allowed to categorize the proposal\r\n   * @return roleId allowed to categorize the proposal\r\n   */\r\n  function allowedToCatgorize() public view returns (uint roleId) {\r\n    return roleIdAllowedToCatgorize;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets vote tally data\r\n   * @param _proposalId in concern\r\n   * @param _solution of a proposal id\r\n   * @return member vote value\r\n   * @return advisory board vote value\r\n   * @return amount of votes\r\n   */\r\n  function voteTallyData(uint _proposalId, uint _solution) public view returns (uint, uint, uint) {\r\n    return (proposalVoteTally[_proposalId].memberVoteValue[_solution],\r\n    proposalVoteTally[_proposalId].abVoteValue[_solution], proposalVoteTally[_proposalId].voters);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to create proposal\r\n   * @param _proposalTitle of proposal\r\n   * @param _proposalSD is short description of proposal\r\n   * @param _proposalDescHash IPFS hash value of propsal\r\n   * @param _categoryId of proposal\r\n   */\r\n  function _createProposal(\r\n    string memory _proposalTitle,\r\n    string memory _proposalSD,\r\n    string memory _proposalDescHash,\r\n    uint _categoryId\r\n  )\r\n  internal\r\n  {\r\n    require(proposalCategory.categoryABReq(_categoryId) == 0 || _categoryId == 0);\r\n    uint _proposalId = totalProposals;\r\n    allProposalData[_proposalId].owner = msg.sender;\r\n    allProposalData[_proposalId].dateUpd = now;\r\n    allProposalSolutions[_proposalId].push(\"\");\r\n    totalProposals++;\r\n\r\n    emit Proposal(\r\n      msg.sender,\r\n      _proposalId,\r\n      now,\r\n      _proposalTitle,\r\n      _proposalSD,\r\n      _proposalDescHash\r\n    );\r\n\r\n    if (_categoryId > 0)\r\n      _categorizeProposal(_proposalId, _categoryId, 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to categorize a proposal\r\n   * @param _proposalId of proposal\r\n   * @param _categoryId of proposal\r\n   * @param _incentive is commonIncentive\r\n   */\r\n  function _categorizeProposal(\r\n    uint _proposalId,\r\n    uint _categoryId,\r\n    uint _incentive\r\n  )\r\n  internal\r\n  {\r\n    require(\r\n      _categoryId > 0 && _categoryId < proposalCategory.totalCategories(),\r\n      \"Invalid category\"\r\n    );\r\n    allProposalData[_proposalId].category = _categoryId;\r\n    allProposalData[_proposalId].commonIncentive = _incentive;\r\n    allProposalData[_proposalId].propStatus = uint(ProposalStatus.AwaitingSolution);\r\n\r\n    emit ProposalCategorized(_proposalId, msg.sender, _categoryId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to add solution to a proposal\r\n   * @param _proposalId in concern\r\n   * @param _action on that solution\r\n   * @param _solutionHash string value\r\n   */\r\n  function _addSolution(uint _proposalId, bytes memory _action, string memory _solutionHash)\r\n  internal\r\n  {\r\n    allProposalSolutions[_proposalId].push(_action);\r\n    emit Solution(_proposalId, msg.sender, allProposalSolutions[_proposalId].length - 1, _solutionHash, now);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal call to add solution and open proposal for voting\r\n  */\r\n  function _proposalSubmission(\r\n    uint _proposalId,\r\n    string memory _solutionHash,\r\n    bytes memory _action\r\n  )\r\n  internal\r\n  {\r\n\r\n    uint _categoryId = allProposalData[_proposalId].category;\r\n    if (proposalCategory.categoryActionHashes(_categoryId).length == 0) {\r\n      require(keccak256(_action) == keccak256(\"\"));\r\n      proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);\r\n    }\r\n\r\n    _addSolution(\r\n      _proposalId,\r\n      _action,\r\n      _solutionHash\r\n    );\r\n\r\n    _updateProposalStatus(_proposalId, uint(ProposalStatus.VotingStarted));\r\n    (, , , , , uint closingTime,) = proposalCategory.category(_categoryId);\r\n    emit CloseProposalOnTime(_proposalId, closingTime.add(now));\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to submit vote\r\n   * @param _proposalId of proposal in concern\r\n   * @param _solution for that proposal\r\n   */\r\n  function _submitVote(uint _proposalId, uint _solution) internal {\r\n\r\n    uint delegationId = followerDelegation[msg.sender];\r\n    uint mrSequence;\r\n    uint majority;\r\n    uint closingTime;\r\n    (, mrSequence, majority, , , closingTime,) = proposalCategory.category(allProposalData[_proposalId].category);\r\n\r\n    require(allProposalData[_proposalId].dateUpd.add(closingTime) > now, \"Closed\");\r\n\r\n    require(memberProposalVote[msg.sender][_proposalId] == 0, \"Not allowed\");\r\n    require((delegationId == 0) || (delegationId > 0 && allDelegation[delegationId].leader == address(0) &&\r\n    _checkLastUpd(allDelegation[delegationId].lastUpd)));\r\n\r\n    require(memberRole.checkRole(msg.sender, mrSequence), \"Not Authorized\");\r\n    uint totalVotes = allVotes.length;\r\n\r\n    allVotesByMember[msg.sender].push(totalVotes);\r\n    memberProposalVote[msg.sender][_proposalId] = totalVotes;\r\n\r\n    allVotes.push(ProposalVote(msg.sender, _proposalId, now));\r\n\r\n    emit Vote(msg.sender, _proposalId, totalVotes, now, _solution);\r\n    if (mrSequence == uint(MemberRoles.Role.Owner)) {\r\n      if (_solution == 1)\r\n        _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), allProposalData[_proposalId].category, 1, MemberRoles.Role.Owner);\r\n      else\r\n        _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\r\n\r\n    } else {\r\n      uint numberOfMembers = memberRole.numberOfMembers(mrSequence);\r\n      _setVoteTally(_proposalId, _solution, mrSequence);\r\n\r\n      if (mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n        if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers)\r\n        >= majority\r\n          || (proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0])) == numberOfMembers) {\r\n          emit VoteCast(_proposalId);\r\n        }\r\n      } else {\r\n        if (numberOfMembers == proposalVoteTally[_proposalId].voters)\r\n          emit VoteCast(_proposalId);\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to set vote tally of a proposal\r\n   * @param _proposalId of proposal in concern\r\n   * @param _solution of proposal in concern\r\n   * @param mrSequence number of members for a role\r\n   */\r\n  function _setVoteTally(uint _proposalId, uint _solution, uint mrSequence) internal\r\n  {\r\n    uint categoryABReq;\r\n    uint isSpecialResolution;\r\n    (, categoryABReq, isSpecialResolution) = proposalCategory.categoryExtendedData(allProposalData[_proposalId].category);\r\n    if (memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && (categoryABReq > 0) ||\r\n      mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n      proposalVoteTally[_proposalId].abVoteValue[_solution]++;\r\n    }\r\n    tokenInstance.lockForMemberVote(msg.sender, tokenHoldingTime);\r\n    if (mrSequence != uint(MemberRoles.Role.AdvisoryBoard)) {\r\n      uint voteWeight;\r\n      uint voters = 1;\r\n      uint tokenBalance = tokenInstance.totalBalanceOf(msg.sender);\r\n      uint totalSupply = tokenInstance.totalSupply();\r\n      if (isSpecialResolution == 1) {\r\n        voteWeight = tokenBalance.add(10 ** 18);\r\n      } else {\r\n        voteWeight = (_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10 ** 18);\r\n      }\r\n      DelegateVote memory delegationData;\r\n      for (uint i = 0; i < leaderDelegation[msg.sender].length; i++) {\r\n        delegationData = allDelegation[leaderDelegation[msg.sender][i]];\r\n        if (delegationData.leader == msg.sender &&\r\n          _checkLastUpd(delegationData.lastUpd)) {\r\n          if (memberRole.checkRole(delegationData.follower, mrSequence)) {\r\n            tokenBalance = tokenInstance.totalBalanceOf(delegationData.follower);\r\n            tokenInstance.lockForMemberVote(delegationData.follower, tokenHoldingTime);\r\n            voters++;\r\n            if (isSpecialResolution == 1) {\r\n              voteWeight = voteWeight.add(tokenBalance.add(10 ** 18));\r\n            } else {\r\n              voteWeight = voteWeight.add((_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10 ** 18));\r\n            }\r\n          }\r\n        }\r\n      }\r\n      proposalVoteTally[_proposalId].memberVoteValue[_solution] = proposalVoteTally[_proposalId].memberVoteValue[_solution].add(voteWeight);\r\n      proposalVoteTally[_proposalId].voters = proposalVoteTally[_proposalId].voters + voters;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets minimum of two numbers\r\n   * @param a one of the two numbers\r\n   * @param b one of the two numbers\r\n   * @return minimum number out of the two\r\n   */\r\n  function _minOf(uint a, uint b) internal pure returns (uint res) {\r\n    res = a;\r\n    if (res > b)\r\n      res = b;\r\n  }\r\n\r\n  /**\r\n   * @dev Check the time since last update has exceeded token holding time or not\r\n   * @param _lastUpd is last update time\r\n   * @return the bool which tells if the time since last update has exceeded token holding time or not\r\n   */\r\n  function _checkLastUpd(uint _lastUpd) internal view returns (bool) {\r\n    return (now - _lastUpd) > tokenHoldingTime;\r\n  }\r\n\r\n  /**\r\n  * @dev Checks if the vote count against any solution passes the threshold value or not.\r\n  */\r\n  function _checkForThreshold(uint _proposalId, uint _category) internal view returns (bool check) {\r\n    uint categoryQuorumPerc;\r\n    uint roleAuthorized;\r\n    (, roleAuthorized, , categoryQuorumPerc, , ,) = proposalCategory.category(_category);\r\n    check = ((proposalVoteTally[_proposalId].memberVoteValue[0]\r\n    .add(proposalVoteTally[_proposalId].memberVoteValue[1]))\r\n    .mul(100))\r\n    .div(\r\n      tokenInstance.totalSupply().add(\r\n        memberRole.numberOfMembers(roleAuthorized).mul(10 ** 18)\r\n      )\r\n    ) >= categoryQuorumPerc;\r\n  }\r\n\r\n  /**\r\n   * @dev Called when vote majority is reached\r\n   * @param _proposalId of proposal in concern\r\n   * @param _status of proposal in concern\r\n   * @param category of proposal in concern\r\n   * @param max vote value of proposal in concern\r\n   */\r\n  function _callIfMajReached(uint _proposalId, uint _status, uint category, uint max, MemberRoles.Role role) internal {\r\n\r\n    allProposalData[_proposalId].finalVerdict = max;\r\n    _updateProposalStatus(_proposalId, _status);\r\n    emit ProposalAccepted(_proposalId);\r\n    if (proposalActionStatus[_proposalId] != uint(ActionStatus.NoAction)) {\r\n      if (role == MemberRoles.Role.AdvisoryBoard) {\r\n        _triggerAction(_proposalId, category);\r\n      } else {\r\n        proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);\r\n        proposalExecutionTime[_proposalId] = actionWaitingTime.add(now);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to trigger action of accepted proposal\r\n   */\r\n  function _triggerAction(uint _proposalId, uint _categoryId) internal {\r\n    proposalActionStatus[_proposalId] = uint(ActionStatus.Executed);\r\n    bytes2 contractName;\r\n    address actionAddress;\r\n    bytes memory _functionHash;\r\n    (, actionAddress, contractName, , _functionHash) = proposalCategory.categoryActionDetails(_categoryId);\r\n    if (contractName == \"MS\") {\r\n      actionAddress = address(ms);\r\n    } else if (contractName != \"EX\") {\r\n      actionAddress = ms.getLatestAddress(contractName);\r\n    }\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool actionStatus,) = actionAddress.call(abi.encodePacked(_functionHash, allProposalSolutions[_proposalId][1]));\r\n    if (actionStatus) {\r\n      emit ActionSuccess(_proposalId);\r\n    } else {\r\n      proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);\r\n      emit ActionFailed(_proposalId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to update proposal status\r\n   * @param _proposalId of proposal in concern\r\n   * @param _status of proposal to set\r\n   */\r\n  function _updateProposalStatus(uint _proposalId, uint _status) internal {\r\n    if (_status == uint(ProposalStatus.Rejected) || _status == uint(ProposalStatus.Denied)) {\r\n      proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);\r\n    }\r\n    allProposalData[_proposalId].dateUpd = now;\r\n    allProposalData[_proposalId].propStatus = _status;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to undelegate a follower\r\n   * @param _follower is address of follower to undelegate\r\n   */\r\n  function _unDelegate(address _follower) internal {\r\n    uint followerId = followerDelegation[_follower];\r\n    if (followerId > 0) {\r\n\r\n      followerCount[allDelegation[followerId].leader] = followerCount[allDelegation[followerId].leader].sub(1);\r\n      allDelegation[followerId].leader = address(0);\r\n      allDelegation[followerId].lastUpd = now;\r\n\r\n      lastRewardClaimed[_follower] = allVotesByMember[_follower].length;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to close member voting\r\n   * @param _proposalId of proposal in concern\r\n   * @param category of proposal in concern\r\n   */\r\n  function _closeMemberVote(uint _proposalId, uint category) internal {\r\n    uint isSpecialResolution;\r\n    uint abMaj;\r\n    (, abMaj, isSpecialResolution) = proposalCategory.categoryExtendedData(category);\r\n    if (isSpecialResolution == 1) {\r\n      uint acceptedVotePerc = proposalVoteTally[_proposalId].memberVoteValue[1].mul(100)\r\n      .div(\r\n        tokenInstance.totalSupply().add(\r\n          memberRole.numberOfMembers(uint(MemberRoles.Role.Member)).mul(10 ** 18)\r\n        ));\r\n      if (acceptedVotePerc >= specialResolutionMajPerc) {\r\n        _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\r\n      } else {\r\n        _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n      }\r\n    } else {\r\n      if (_checkForThreshold(_proposalId, category)) {\r\n        uint majorityVote;\r\n        (,, majorityVote,,,,) = proposalCategory.category(category);\r\n        if (\r\n          ((proposalVoteTally[_proposalId].memberVoteValue[1].mul(100))\r\n          .div(proposalVoteTally[_proposalId].memberVoteValue[0]\r\n          .add(proposalVoteTally[_proposalId].memberVoteValue[1])\r\n          ))\r\n          >= majorityVote\r\n        ) {\r\n          _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\r\n        } else {\r\n          _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\r\n        }\r\n      } else {\r\n        if (abMaj > 0 && proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\r\n        .div(memberRole.numberOfMembers(uint(MemberRoles.Role.AdvisoryBoard))) >= abMaj) {\r\n          _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\r\n        } else {\r\n          _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (proposalVoteTally[_proposalId].voters > 0) {\r\n      tokenInstance.mint(ms.getLatestAddress(\"CR\"), allProposalData[_proposalId].commonIncentive);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal call to close advisory board voting\r\n   * @param _proposalId of proposal in concern\r\n   * @param category of proposal in concern\r\n   */\r\n  function _closeAdvisoryBoardVote(uint _proposalId, uint category) internal {\r\n    uint _majorityVote;\r\n    MemberRoles.Role _roleId = MemberRoles.Role.AdvisoryBoard;\r\n    (,, _majorityVote,,,,) = proposalCategory.category(category);\r\n    if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\r\n    .div(memberRole.numberOfMembers(uint(_roleId))) >= _majorityVote) {\r\n      _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, _roleId);\r\n    } else {\r\n      _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n    }\r\n\r\n  }\r\n\r\n}\n\n// File: contracts/modules/token/TokenFunctions.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenFunctions is Iupgradable {\n  using SafeMath for uint;\n\n  MCR internal m1;\n  MemberRoles internal mr;\n  NXMToken public tk;\n  TokenController internal tc;\n  TokenData internal td;\n  QuotationData internal qd;\n  ClaimsReward internal cr;\n  Governance internal gv;\n  PoolData internal pd;\n  IPooledStaking pooledStaking;\n\n  event BurnCATokens(uint claimId, address addr, uint amount);\n\n  /**\n   * @dev Rewards stakers on purchase of cover on smart contract.\n   * @param _contractAddress smart contract address.\n   * @param _coverPriceNXM cover price in NXM.\n   */\n  function pushStakerRewards(address _contractAddress, uint _coverPriceNXM) external onlyInternal {\n    uint rewardValue = _coverPriceNXM.mul(td.stakerCommissionPer()).div(100);\n    pooledStaking.accumulateReward(_contractAddress, rewardValue);\n  }\n\n  /**\n  * @dev Deprecated in favor of burnStakedTokens\n  */\n  function burnStakerLockedToken(uint, bytes4, uint) external {\n    // noop\n  }\n\n  /**\n  * @dev Burns tokens staked on smart contract covered by coverId. Called when a payout is succesfully executed.\n  * @param coverId cover id\n  * @param coverCurrency cover currency\n  * @param sumAssured amount of $curr to burn\n  */\n  function burnStakedTokens(uint coverId, bytes4 coverCurrency, uint sumAssured) external onlyInternal {\n    (, address scAddress) = qd.getscAddressOfCover(coverId);\n    uint tokenPrice = m1.calculateTokenPrice(coverCurrency);\n    uint burnNXMAmount = sumAssured.mul(1e18).div(tokenPrice);\n    pooledStaking.pushBurn(scAddress, burnNXMAmount);\n  }\n\n  /**\n   * @dev Gets the total staked NXM tokens against\n   * Smart contract by all stakers\n   * @param _stakedContractAddress smart contract address.\n   * @return amount total staked NXM tokens.\n   */\n  function deprecated_getTotalStakedTokensOnSmartContract(\n    address _stakedContractAddress\n  )\n  external\n  view\n  returns (uint)\n  {\n    uint stakedAmount = 0;\n    address stakerAddress;\n    uint staketLen = td.getStakedContractStakersLength(_stakedContractAddress);\n\n    for (uint i = 0; i < staketLen; i++) {\n      stakerAddress = td.getStakedContractStakerByIndex(_stakedContractAddress, i);\n      uint stakerIndex = td.getStakedContractStakerIndex(\n        _stakedContractAddress, i);\n      uint currentlyStaked;\n      (, currentlyStaked) = _deprecated_unlockableBeforeBurningAndCanBurn(stakerAddress,\n        _stakedContractAddress, stakerIndex);\n      stakedAmount = stakedAmount.add(currentlyStaked);\n    }\n\n    return stakedAmount;\n  }\n\n  /**\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\n   * @param _of address of the coverHolder.\n   * @param _coverId coverId of the cover.\n   */\n  function getUserLockedCNTokens(address _of, uint _coverId) external view returns (uint) {\n    return _getUserLockedCNTokens(_of, _coverId);\n  }\n\n  /**\n   * @dev to get the all the cover locked tokens of a user\n   * @param _of is the user address in concern\n   * @return amount locked\n   */\n  function getUserAllLockedCNTokens(address _of) external view returns (uint amount) {\n    for (uint i = 0; i < qd.getUserCoverLength(_of); i++) {\n      amount = amount.add(_getUserLockedCNTokens(_of, qd.getAllCoversOfUser(_of)[i]));\n    }\n  }\n\n  /**\n   * @dev Returns amount of NXM Tokens locked as Cover Note against given coverId.\n   * @param _coverId coverId of the cover.\n   */\n  function getLockedCNAgainstCover(uint _coverId) external view returns (uint) {\n    return _getLockedCNAgainstCover(_coverId);\n  }\n\n  /**\n   * @dev Returns total amount of staked NXM Tokens on all smart contracts.\n   * @param _stakerAddress address of the Staker.\n   */\n  function deprecated_getStakerAllLockedTokens(address _stakerAddress) external view returns (uint amount) {\n    uint stakedAmount = 0;\n    address scAddress;\n    uint scIndex;\n    for (uint i = 0; i < td.getStakerStakedContractLength(_stakerAddress); i++) {\n      scAddress = td.getStakerStakedContractByIndex(_stakerAddress, i);\n      scIndex = td.getStakerStakedContractIndex(_stakerAddress, i);\n      uint currentlyStaked;\n      (, currentlyStaked) = _deprecated_unlockableBeforeBurningAndCanBurn(_stakerAddress, scAddress, i);\n      stakedAmount = stakedAmount.add(currentlyStaked);\n    }\n    amount = stakedAmount;\n  }\n\n  /**\n   * @dev Returns total unlockable amount of staked NXM Tokens on all smart contract .\n   * @param _stakerAddress address of the Staker.\n   */\n  function deprecated_getStakerAllUnlockableStakedTokens(\n    address _stakerAddress\n  )\n  external\n  view\n  returns (uint amount)\n  {\n    uint unlockableAmount = 0;\n    address scAddress;\n    uint scIndex;\n    for (uint i = 0; i < td.getStakerStakedContractLength(_stakerAddress); i++) {\n      scAddress = td.getStakerStakedContractByIndex(_stakerAddress, i);\n      scIndex = td.getStakerStakedContractIndex(_stakerAddress, i);\n      unlockableAmount = unlockableAmount.add(\n        _deprecated_getStakerUnlockableTokensOnSmartContract(_stakerAddress, scAddress,\n        scIndex));\n    }\n    amount = unlockableAmount;\n  }\n\n  /**\n   * @dev Change Dependent Contract Address\n   */\n  function changeDependentContractAddress() public {\n    tk = NXMToken(ms.tokenAddress());\n    td = TokenData(ms.getLatestAddress(\"TD\"));\n    tc = TokenController(ms.getLatestAddress(\"TC\"));\n    cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\n    m1 = MCR(ms.getLatestAddress(\"MC\"));\n    gv = Governance(ms.getLatestAddress(\"GV\"));\n    mr = MemberRoles(ms.getLatestAddress(\"MR\"));\n    pd = PoolData(ms.getLatestAddress(\"PD\"));\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\"PS\"));\n  }\n\n  /**\n   * @dev Gets the Token price in a given currency\n   * @param curr Currency name.\n   * @return price Token Price.\n   */\n  function getTokenPrice(bytes4 curr) public view returns (uint price) {\n    price = m1.calculateTokenPrice(curr);\n  }\n\n  /**\n   * @dev Set the flag to check if cover note is deposited against the cover id\n   * @param coverId Cover Id.\n   */\n  function depositCN(uint coverId) public onlyInternal returns (bool success) {\n    require(_getLockedCNAgainstCover(coverId) > 0, \"No cover note available\");\n    td.setDepositCN(coverId, true);\n    success = true;\n  }\n\n  /**\n   * @param _of address of Member\n   * @param _coverId Cover Id\n   * @param _lockTime Pending Time + Cover Period 7*1 days\n   */\n  function extendCNEPOff(address _of, uint _coverId, uint _lockTime) public onlyInternal {\n    uint timeStamp = now.add(_lockTime);\n    uint coverValidUntil = qd.getValidityOfCover(_coverId);\n    if (timeStamp >= coverValidUntil) {\n      bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, _coverId));\n      tc.extendLockOf(_of, reason, timeStamp);\n    }\n  }\n\n  /**\n   * @dev to burn the deposited cover tokens\n   * @param coverId is id of cover whose tokens have to be burned\n   * @return the status of the successful burning\n   */\n  function burnDepositCN(uint coverId) public onlyInternal returns (bool success) {\n    address _of = qd.getCoverMemberAddress(coverId);\n    uint amount;\n    (amount,) = td.depositedCN(coverId);\n    amount = (amount.mul(50)).div(100);\n    bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, coverId));\n    tc.burnLockedTokens(_of, reason, amount);\n    success = true;\n  }\n\n  /**\n   * @dev Unlocks covernote locked against a given cover\n   * @param coverId id of cover\n   */\n  function unlockCN(uint coverId) public onlyInternal {\n    (, bool isDeposited) = td.depositedCN(coverId);\n    require(!isDeposited, \"Cover note is deposited and can not be released\");\n    uint lockedCN = _getLockedCNAgainstCover(coverId);\n    if (lockedCN != 0) {\n      address coverHolder = qd.getCoverMemberAddress(coverId);\n      bytes32 reason = keccak256(abi.encodePacked(\"CN\", coverHolder, coverId));\n      tc.releaseLockedTokens(coverHolder, reason, lockedCN);\n    }\n  }\n\n  /**\n   * @dev Burns tokens used for fraudulent voting against a claim\n   * @param claimid Claim Id.\n   * @param _value number of tokens to be burned\n   * @param _of Claim Assessor's address.\n   */\n  function burnCAToken(uint claimid, uint _value, address _of) public {\n\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    tc.burnLockedTokens(_of, \"CLA\", _value);\n    emit BurnCATokens(claimid, _of, _value);\n  }\n\n  /**\n   * @dev to lock cover note tokens\n   * @param coverNoteAmount is number of tokens to be locked\n   * @param coverPeriod is cover period in concern\n   * @param coverId is the cover id of cover in concern\n   * @param _of address whose tokens are to be locked\n   */\n  function lockCN(\n    uint coverNoteAmount,\n    uint coverPeriod,\n    uint coverId,\n    address _of\n  )\n  public\n  onlyInternal\n  {\n    uint validity = (coverPeriod * 1 days).add(td.lockTokenTimeAfterCoverExp());\n    bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, coverId));\n    td.setDepositCNAmount(coverId, coverNoteAmount);\n    tc.lockOf(_of, reason, coverNoteAmount, validity);\n  }\n\n  /**\n   * @dev to check if a  member is locked for member vote\n   * @param _of is the member address in concern\n   * @return the boolean status\n   */\n  function isLockedForMemberVote(address _of) public view returns (bool) {\n    return now < tk.isLockedForMV(_of);\n  }\n\n  /**\n   * @dev Internal function to gets amount of locked NXM tokens,\n   * staked against smartcontract by index\n   * @param _stakerAddress address of user\n   * @param _stakedContractAddress staked contract address\n   * @param _stakedContractIndex index of staking\n   */\n  function deprecated_getStakerLockedTokensOnSmartContract(\n    address _stakerAddress,\n    address _stakedContractAddress,\n    uint _stakedContractIndex\n  )\n  public\n  view\n  returns\n  (uint amount)\n  {\n    amount = _deprecated_getStakerLockedTokensOnSmartContract(_stakerAddress,\n      _stakedContractAddress, _stakedContractIndex);\n  }\n\n  /**\n   * @dev Function to gets unlockable amount of locked NXM\n   * tokens, staked against smartcontract by index\n   * @param stakerAddress address of staker\n   * @param stakedContractAddress staked contract address\n   * @param stakerIndex index of staking\n   */\n  function deprecated_getStakerUnlockableTokensOnSmartContract(\n    address stakerAddress,\n    address stakedContractAddress,\n    uint stakerIndex\n  )\n  public\n  view\n  returns (uint)\n  {\n    return _deprecated_getStakerUnlockableTokensOnSmartContract(stakerAddress, stakedContractAddress,\n      td.getStakerStakedContractIndex(stakerAddress, stakerIndex));\n  }\n\n  /**\n   * @dev releases unlockable staked tokens to staker\n   */\n  function deprecated_unlockStakerUnlockableTokens(address _stakerAddress) public checkPause {\n    uint unlockableAmount;\n    address scAddress;\n    bytes32 reason;\n    uint scIndex;\n    for (uint i = 0; i < td.getStakerStakedContractLength(_stakerAddress); i++) {\n      scAddress = td.getStakerStakedContractByIndex(_stakerAddress, i);\n      scIndex = td.getStakerStakedContractIndex(_stakerAddress, i);\n      unlockableAmount = _deprecated_getStakerUnlockableTokensOnSmartContract(\n        _stakerAddress, scAddress,\n        scIndex);\n      td.setUnlockableBeforeLastBurnTokens(_stakerAddress, i, 0);\n      td.pushUnlockedStakedTokens(_stakerAddress, i, unlockableAmount);\n      reason = keccak256(abi.encodePacked(\"UW\", _stakerAddress, scAddress, scIndex));\n      tc.releaseLockedTokens(_stakerAddress, reason, unlockableAmount);\n    }\n  }\n\n  /**\n   * @dev to get tokens of staker locked before burning that are allowed to burn\n   * @param stakerAdd is the address of the staker\n   * @param stakedAdd is the address of staked contract in concern\n   * @param stakerIndex is the staker index in concern\n   * @return amount of unlockable tokens\n   * @return amount of tokens that can burn\n   */\n  function _deprecated_unlockableBeforeBurningAndCanBurn(\n    address stakerAdd,\n    address stakedAdd,\n    uint stakerIndex\n  )\n  public\n  view\n  returns\n  (uint amount, uint canBurn) {\n\n    uint dateAdd;\n    uint initialStake;\n    uint totalBurnt;\n    uint ub;\n    (, , dateAdd, initialStake, , totalBurnt, ub) = td.stakerStakedContracts(stakerAdd, stakerIndex);\n    canBurn = _deprecated_calculateStakedTokens(initialStake, now.sub(dateAdd).div(1 days), td.scValidDays());\n    // Can't use SafeMaths for int.\n    int v = int(initialStake - (canBurn) - (totalBurnt) - (\n    td.getStakerUnlockedStakedTokens(stakerAdd, stakerIndex)) - (ub));\n    uint currentLockedTokens = _deprecated_getStakerLockedTokensOnSmartContract(\n      stakerAdd, stakedAdd, td.getStakerStakedContractIndex(stakerAdd, stakerIndex));\n    if (v < 0) {\n      v = 0;\n    }\n    amount = uint(v);\n    if (canBurn > currentLockedTokens.sub(amount).sub(ub)) {\n      canBurn = currentLockedTokens.sub(amount).sub(ub);\n    }\n  }\n\n  /**\n   * @dev to get tokens of staker that are unlockable\n   * @param _stakerAddress is the address of the staker\n   * @param _stakedContractAddress is the address of staked contract in concern\n   * @param _stakedContractIndex is the staked contract index in concern\n   * @return amount of unlockable tokens\n   */\n  function _deprecated_getStakerUnlockableTokensOnSmartContract(\n    address _stakerAddress,\n    address _stakedContractAddress,\n    uint _stakedContractIndex\n  )\n  public\n  view\n  returns\n  (uint amount)\n  {\n    uint initialStake;\n    uint stakerIndex = td.getStakedContractStakerIndex(\n      _stakedContractAddress, _stakedContractIndex);\n    uint burnt;\n    (, , , initialStake, , burnt,) = td.stakerStakedContracts(_stakerAddress, stakerIndex);\n    uint alreadyUnlocked = td.getStakerUnlockedStakedTokens(_stakerAddress, stakerIndex);\n    uint currentStakedTokens;\n    (, currentStakedTokens) = _deprecated_unlockableBeforeBurningAndCanBurn(_stakerAddress,\n      _stakedContractAddress, stakerIndex);\n    amount = initialStake.sub(currentStakedTokens).sub(alreadyUnlocked).sub(burnt);\n  }\n\n  /**\n   * @dev Internal function to get the amount of locked NXM tokens,\n   * staked against smartcontract by index\n   * @param _stakerAddress address of user\n   * @param _stakedContractAddress staked contract address\n   * @param _stakedContractIndex index of staking\n   */\n  function _deprecated_getStakerLockedTokensOnSmartContract(\n    address _stakerAddress,\n    address _stakedContractAddress,\n    uint _stakedContractIndex\n  )\n  internal\n  view\n  returns\n  (uint amount)\n  {\n    bytes32 reason = keccak256(abi.encodePacked(\"UW\", _stakerAddress,\n      _stakedContractAddress, _stakedContractIndex));\n    amount = tc.tokensLocked(_stakerAddress, reason);\n  }\n\n  /**\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\n   * @param _coverId coverId of the cover.\n   */\n  function _getLockedCNAgainstCover(uint _coverId) internal view returns (uint) {\n    address coverHolder = qd.getCoverMemberAddress(_coverId);\n    bytes32 reason = keccak256(abi.encodePacked(\"CN\", coverHolder, _coverId));\n    return tc.tokensLockedAtTime(coverHolder, reason, now);\n  }\n\n  /**\n   * @dev Returns amount of NXM Tokens locked as Cover Note for given coverId.\n   * @param _of address of the coverHolder.\n   * @param _coverId coverId of the cover.\n   */\n  function _getUserLockedCNTokens(address _of, uint _coverId) internal view returns (uint) {\n    bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, _coverId));\n    return tc.tokensLockedAtTime(_of, reason, now);\n  }\n\n  /**\n   * @dev Internal function to gets remaining amount of staked NXM tokens,\n   * against smartcontract by index\n   * @param _stakeAmount address of user\n   * @param _stakeDays staked contract address\n   * @param _validDays index of staking\n   */\n  function _deprecated_calculateStakedTokens(\n    uint _stakeAmount,\n    uint _stakeDays,\n    uint _validDays\n  )\n  internal\n  pure\n  returns (uint amount)\n  {\n    if (_validDays > _stakeDays) {\n      uint rf = ((_validDays.sub(_stakeDays)).mul(100000)).div(_validDays);\n      amount = (rf.mul(_stakeAmount)).div(100000);\n    } else {\n      amount = 0;\n    }\n  }\n\n  /**\n   * @dev Gets the total staked NXM tokens against Smart contract\n   * by all stakers\n   * @param _stakedContractAddress smart contract address.\n   * @return amount total staked NXM tokens.\n   */\n  function _deprecated_burnStakerTokenLockedAgainstSmartContract(\n    address _stakerAddress,\n    address _stakedContractAddress,\n    uint _stakedContractIndex,\n    uint _amount\n  )\n  internal\n  {\n    uint stakerIndex = td.getStakedContractStakerIndex(\n      _stakedContractAddress, _stakedContractIndex);\n    td.pushBurnedTokens(_stakerAddress, stakerIndex, _amount);\n    bytes32 reason = keccak256(abi.encodePacked(\"UW\", _stakerAddress,\n      _stakedContractAddress, _stakedContractIndex));\n    tc.burnLockedTokens(_stakerAddress, reason, _amount);\n  }\n}\n\n// File: contracts/modules/governance/MemberRoles.sol\n\n/* Copyright (C) 2017 GovBlocks.io\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n\n\ncontract MemberRoles is Governed, Iupgradable {\n\n  TokenController public dAppToken;\n  TokenData internal td;\n  QuotationData internal qd;\n  ClaimsReward internal cr;\n  Governance internal gv;\n  TokenFunctions internal tf;\n  NXMToken public tk;\n\n  struct MemberRoleDetails {\n    uint memberCounter;\n    mapping(address => bool) memberActive;\n    address[] memberAddress;\n    address authorized;\n  }\n\n  enum Role {UnAssigned, AdvisoryBoard, Member, Owner}\n\n  event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\n\n  event switchedMembership(address indexed previousMember, address indexed newMember, uint timeStamp);\n\n  event ClaimPayoutAddressSet(address indexed member, address indexed payoutAddress);\n\n  MemberRoleDetails[] internal memberRoleData;\n  bool internal constructorCheck;\n  uint public maxABCount;\n  bool public launched;\n  uint public launchedOn;\n\n  mapping (address => address payable) internal claimPayoutAddress;\n\n  modifier checkRoleAuthority(uint _memberRoleId) {\n    if (memberRoleData[_memberRoleId].authorized != address(0))\n      require(msg.sender == memberRoleData[_memberRoleId].authorized);\n    else\n      require(isAuthorizedToGovern(msg.sender), \"Not Authorized\");\n    _;\n  }\n\n  /**\n   * @dev to swap advisory board member\n   * @param _newABAddress is address of new AB member\n   * @param _removeAB is advisory board member to be removed\n   */\n  function swapABMember(\n    address _newABAddress,\n    address _removeAB\n  )\n  external\n  checkRoleAuthority(uint(Role.AdvisoryBoard)) {\n\n    _updateRole(_newABAddress, uint(Role.AdvisoryBoard), true);\n    _updateRole(_removeAB, uint(Role.AdvisoryBoard), false);\n\n  }\n\n  /**\n   * @dev to swap the owner address\n   * @param _newOwnerAddress is the new owner address\n   */\n  function swapOwner(\n    address _newOwnerAddress\n  )\n  external {\n    require(msg.sender == address(ms));\n    _updateRole(ms.owner(), uint(Role.Owner), false);\n    _updateRole(_newOwnerAddress, uint(Role.Owner), true);\n  }\n\n  /**\n   * @dev is used to add initital advisory board members\n   * @param abArray is the list of initial advisory board members\n   */\n  function addInitialABMembers(address[] calldata abArray) external onlyOwner {\n\n    //Ensure that NXMaster has initialized.\n    require(ms.masterInitialized());\n\n    require(maxABCount >=\n      SafeMath.add(numberOfMembers(uint(Role.AdvisoryBoard)), abArray.length)\n    );\n    //AB count can't exceed maxABCount\n    for (uint i = 0; i < abArray.length; i++) {\n      require(checkRole(abArray[i], uint(MemberRoles.Role.Member)));\n      _updateRole(abArray[i], uint(Role.AdvisoryBoard), true);\n    }\n  }\n\n  /**\n   * @dev to change max number of AB members allowed\n   * @param _val is the new value to be set\n   */\n  function changeMaxABCount(uint _val) external onlyInternal {\n    maxABCount = _val;\n  }\n\n  /**\n   * @dev Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public {\n    td = TokenData(ms.getLatestAddress(\"TD\"));\n    cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\n    gv = Governance(ms.getLatestAddress(\"GV\"));\n    tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\n    tk = NXMToken(ms.tokenAddress());\n    dAppToken = TokenController(ms.getLatestAddress(\"TC\"));\n\n    // rescue future yNFT claim payouts as per gov proposal #113\n    address payable yNFT = 0x181Aea6936B407514ebFC0754A37704eB8d98F91;\n    address payable arNFT = 0x1337DEF1e9c7645352D93baf0b789D04562b4185;\n\n    if (claimPayoutAddress[yNFT] == address(0)) {\n      claimPayoutAddress[yNFT] = arNFT;\n      emit ClaimPayoutAddressSet(yNFT, arNFT);\n    }\n  }\n\n  /**\n   * @dev to change the master address\n   * @param _masterAddress is the new master address\n   */\n  function changeMasterAddress(address _masterAddress) public {\n\n    if (masterAddress != address(0)) {\n      require(masterAddress == msg.sender);\n    }\n\n    masterAddress = _masterAddress;\n    ms = INXMMaster(_masterAddress);\n    nxMasterAddress = _masterAddress;\n  }\n\n  /**\n   * @dev to initiate the member roles\n   * @param _firstAB is the address of the first AB member\n   * @param memberAuthority is the authority (role) of the member\n   */\n  function memberRolesInitiate(address _firstAB, address memberAuthority) public {\n    require(!constructorCheck);\n    _addInitialMemberRoles(_firstAB, memberAuthority);\n    constructorCheck = true;\n  }\n\n  /// @dev Adds new member role\n  /// @param _roleName New role name\n  /// @param _roleDescription New description hash\n  /// @param _authorized Authorized member against every role id\n  function addRole(//solhint-disable-line\n    bytes32 _roleName,\n    string memory _roleDescription,\n    address _authorized\n  )\n  public\n  onlyAuthorizedToGovern {\n    _addRole(_roleName, _roleDescription, _authorized);\n  }\n\n  /// @dev Assign or Delete a member from specific role.\n  /// @param _memberAddress Address of Member\n  /// @param _roleId RoleId to update\n  /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\n  function updateRole(//solhint-disable-line\n    address _memberAddress,\n    uint _roleId,\n    bool _active\n  )\n  public\n  checkRoleAuthority(_roleId) {\n    _updateRole(_memberAddress, _roleId, _active);\n  }\n\n  /**\n   * @dev to add members before launch\n   * @param userArray is list of addresses of members\n   * @param tokens is list of tokens minted for each array element\n   */\n  function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {\n    require(!launched);\n\n    for (uint i = 0; i < userArray.length; i++) {\n      require(!ms.isMember(userArray[i]));\n      dAppToken.addToWhitelist(userArray[i]);\n      _updateRole(userArray[i], uint(Role.Member), true);\n      dAppToken.mint(userArray[i], tokens[i]);\n    }\n    launched = true;\n    launchedOn = now;\n\n  }\n\n  /**\n    * @dev Called by user to pay joining membership fee\n    */\n  function payJoiningFee(address _userAddress) public payable {\n    require(_userAddress != address(0));\n    require(!ms.isPause(), \"Emergency Pause Applied\");\n    if (msg.sender == address(ms.getLatestAddress(\"QT\"))) {\n      require(td.walletAddress() != address(0), \"No walletAddress present\");\n      dAppToken.addToWhitelist(_userAddress);\n      _updateRole(_userAddress, uint(Role.Member), true);\n      td.walletAddress().transfer(msg.value);\n    } else {\n      require(!qd.refundEligible(_userAddress));\n      require(!ms.isMember(_userAddress));\n      require(msg.value == td.joiningFee());\n      qd.setRefundEligible(_userAddress, true);\n    }\n  }\n\n  /**\n   * @dev to perform kyc verdict\n   * @param _userAddress whose kyc is being performed\n   * @param verdict of kyc process\n   */\n  function kycVerdict(address payable _userAddress, bool verdict) public {\n\n    require(msg.sender == qd.kycAuthAddress());\n    require(!ms.isPause());\n    require(_userAddress != address(0));\n    require(!ms.isMember(_userAddress));\n    require(qd.refundEligible(_userAddress));\n    if (verdict) {\n      qd.setRefundEligible(_userAddress, false);\n      uint fee = td.joiningFee();\n      dAppToken.addToWhitelist(_userAddress);\n      _updateRole(_userAddress, uint(Role.Member), true);\n      td.walletAddress().transfer(fee); // solhint-disable-line\n\n    } else {\n      qd.setRefundEligible(_userAddress, false);\n      _userAddress.transfer(td.joiningFee()); // solhint-disable-line\n    }\n  }\n\n  /**\n   * @dev Called by existed member if wish to Withdraw membership.\n   */\n  function withdrawMembership() public {\n\n    require(!ms.isPause() && ms.isMember(msg.sender));\n    require(dAppToken.totalLockedBalance(msg.sender, now) == 0); // solhint-disable-line\n    require(!tf.isLockedForMemberVote(msg.sender)); // No locked tokens for Member/Governance voting\n    require(cr.getAllPendingRewardOfUser(msg.sender) == 0); // No pending reward to be claimed(claim assesment).\n    require(dAppToken.tokensUnlockable(msg.sender, \"CLA\") == 0, \"Member should have no CLA unlockable tokens\");\n\n    gv.removeDelegation(msg.sender);\n    dAppToken.burnFrom(msg.sender, tk.balanceOf(msg.sender));\n    _updateRole(msg.sender, uint(Role.Member), false);\n    dAppToken.removeFromWhitelist(msg.sender); // need clarification on whitelist\n\n    if (claimPayoutAddress[msg.sender] != address(0)) {\n      claimPayoutAddress[msg.sender] = address(0);\n      emit ClaimPayoutAddressSet(msg.sender, address(0));\n    }\n  }\n\n  /**\n   * @dev Called by existed member if wish to switch membership to other address.\n   * @param _add address of user to forward membership.\n   */\n  function switchMembership(address _add) external {\n\n    require(!ms.isPause() && ms.isMember(msg.sender) && !ms.isMember(_add));\n    require(dAppToken.totalLockedBalance(msg.sender, now) == 0); // solhint-disable-line\n    require(!tf.isLockedForMemberVote(msg.sender)); // No locked tokens for Member/Governance voting\n    require(cr.getAllPendingRewardOfUser(msg.sender) == 0); // No pending reward to be claimed(claim assesment).\n    require(dAppToken.tokensUnlockable(msg.sender, \"CLA\") == 0, \"Member should have no CLA unlockable tokens\");\n\n    gv.removeDelegation(msg.sender);\n    dAppToken.addToWhitelist(_add);\n    _updateRole(_add, uint(Role.Member), true);\n    tk.transferFrom(msg.sender, _add, tk.balanceOf(msg.sender));\n    _updateRole(msg.sender, uint(Role.Member), false);\n    dAppToken.removeFromWhitelist(msg.sender);\n\n    address payable previousPayoutAddress = claimPayoutAddress[msg.sender];\n\n    if (previousPayoutAddress != address(0)) {\n\n      address payable storedAddress = previousPayoutAddress == _add ? address(0) : previousPayoutAddress;\n\n      claimPayoutAddress[msg.sender] = address(0);\n      claimPayoutAddress[_add] = storedAddress;\n\n      // emit event for old address reset\n      emit ClaimPayoutAddressSet(msg.sender, address(0));\n\n      if (storedAddress != address(0)) {\n        // emit event for setting the payout address on the new member address if it's non zero\n        emit ClaimPayoutAddressSet(_add, storedAddress);\n      }\n    }\n\n    emit switchedMembership(msg.sender, _add, now);\n  }\n\n  function getClaimPayoutAddress(address payable _member) external view returns (address payable) {\n    address payable payoutAddress = claimPayoutAddress[_member];\n    return payoutAddress != address(0) ? payoutAddress : _member;\n  }\n\n  function setClaimPayoutAddress(address payable _address) external {\n\n    require(!ms.isPause(), \"system is paused\");\n    require(ms.isMember(msg.sender), \"sender is not a member\");\n    require(_address != msg.sender, \"should be different than the member address\");\n\n    claimPayoutAddress[msg.sender] = _address;\n    emit ClaimPayoutAddressSet(msg.sender, _address);\n  }\n\n  /// @dev Return number of member roles\n  function totalRoles() public view returns (uint256) {//solhint-disable-line\n    return memberRoleData.length;\n  }\n\n  /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\n  /// @param _roleId roleId to update its Authorized Address\n  /// @param _newAuthorized New authorized address against role id\n  function changeAuthorized(uint _roleId, address _newAuthorized) public checkRoleAuthority(_roleId) {//solhint-disable-line\n    memberRoleData[_roleId].authorized = _newAuthorized;\n  }\n\n  /// @dev Gets the member addresses assigned by a specific role\n  /// @param _memberRoleId Member role id\n  /// @return roleId Role id\n  /// @return allMemberAddress Member addresses of specified role id\n  function members(uint _memberRoleId) public view returns (uint, address[] memory memberArray) {//solhint-disable-line\n    uint length = memberRoleData[_memberRoleId].memberAddress.length;\n    uint i;\n    uint j = 0;\n    memberArray = new address[](memberRoleData[_memberRoleId].memberCounter);\n    for (i = 0; i < length; i++) {\n      address member = memberRoleData[_memberRoleId].memberAddress[i];\n      if (memberRoleData[_memberRoleId].memberActive[member] && !_checkMemberInArray(member, memberArray)) {//solhint-disable-line\n        memberArray[j] = member;\n        j++;\n      }\n    }\n\n    return (_memberRoleId, memberArray);\n  }\n\n  /// @dev Gets all members' length\n  /// @param _memberRoleId Member role id\n  /// @return memberRoleData[_memberRoleId].memberCounter Member length\n  function numberOfMembers(uint _memberRoleId) public view returns (uint) {//solhint-disable-line\n    return memberRoleData[_memberRoleId].memberCounter;\n  }\n\n  /// @dev Return member address who holds the right to add/remove any member from specific role.\n  function authorized(uint _memberRoleId) public view returns (address) {//solhint-disable-line\n    return memberRoleData[_memberRoleId].authorized;\n  }\n\n  /// @dev Get All role ids array that has been assigned to a member so far.\n  function roles(address _memberAddress) public view returns (uint[] memory) {//solhint-disable-line\n    uint length = memberRoleData.length;\n    uint[] memory assignedRoles = new uint[](length);\n    uint counter = 0;\n    for (uint i = 1; i < length; i++) {\n      if (memberRoleData[i].memberActive[_memberAddress]) {\n        assignedRoles[counter] = i;\n        counter++;\n      }\n    }\n    return assignedRoles;\n  }\n\n  /// @dev Returns true if the given role id is assigned to a member.\n  /// @param _memberAddress Address of member\n  /// @param _roleId Checks member's authenticity with the roleId.\n  /// i.e. Returns true if this roleId is assigned to member\n  function checkRole(address _memberAddress, uint _roleId) public view returns (bool) {//solhint-disable-line\n    if (_roleId == uint(Role.UnAssigned))\n      return true;\n    else\n      if (memberRoleData[_roleId].memberActive[_memberAddress]) //solhint-disable-line\n        return true;\n      else\n        return false;\n  }\n\n  /// @dev Return total number of members assigned against each role id.\n  /// @return totalMembers Total members in particular role id\n  function getMemberLengthForAllRoles() public view returns (uint[] memory totalMembers) {//solhint-disable-line\n    totalMembers = new uint[](memberRoleData.length);\n    for (uint i = 0; i < memberRoleData.length; i++) {\n      totalMembers[i] = numberOfMembers(i);\n    }\n  }\n\n  /**\n   * @dev to update the member roles\n   * @param _memberAddress in concern\n   * @param _roleId the id of role\n   * @param _active if active is true, add the member, else remove it\n   */\n  function _updateRole(address _memberAddress,\n    uint _roleId,\n    bool _active) internal {\n    // require(_roleId != uint(Role.TokenHolder), \"Membership to Token holder is detected automatically\");\n    if (_active) {\n      require(!memberRoleData[_roleId].memberActive[_memberAddress]);\n      memberRoleData[_roleId].memberCounter = SafeMath.add(memberRoleData[_roleId].memberCounter, 1);\n      memberRoleData[_roleId].memberActive[_memberAddress] = true;\n      memberRoleData[_roleId].memberAddress.push(_memberAddress);\n    } else {\n      require(memberRoleData[_roleId].memberActive[_memberAddress]);\n      memberRoleData[_roleId].memberCounter = SafeMath.sub(memberRoleData[_roleId].memberCounter, 1);\n      delete memberRoleData[_roleId].memberActive[_memberAddress];\n    }\n  }\n\n  /// @dev Adds new member role\n  /// @param _roleName New role name\n  /// @param _roleDescription New description hash\n  /// @param _authorized Authorized member against every role id\n  function _addRole(\n    bytes32 _roleName,\n    string memory _roleDescription,\n    address _authorized\n  ) internal {\n    emit MemberRole(memberRoleData.length, _roleName, _roleDescription);\n    memberRoleData.push(MemberRoleDetails(0, new address[](0), _authorized));\n  }\n\n  /**\n   * @dev to check if member is in the given member array\n   * @param _memberAddress in concern\n   * @param memberArray in concern\n   * @return boolean to represent the presence\n   */\n  function _checkMemberInArray(\n    address _memberAddress,\n    address[] memory memberArray\n  )\n  internal\n  pure\n  returns (bool memberExists)\n  {\n    uint i;\n    for (i = 0; i < memberArray.length; i++) {\n      if (memberArray[i] == _memberAddress) {\n        memberExists = true;\n        break;\n      }\n    }\n  }\n\n  /**\n   * @dev to add initial member roles\n   * @param _firstAB is the member address to be added\n   * @param memberAuthority is the member authority(role) to be added for\n   */\n  function _addInitialMemberRoles(address _firstAB, address memberAuthority) internal {\n    maxABCount = 5;\n    _addRole(\"Unassigned\", \"Unassigned\", address(0));\n    _addRole(\n      \"Advisory Board\",\n      \"Selected few members that are deeply entrusted by the dApp. An ideal advisory board should be a mix of skills of domain, governance, research, technology, consulting etc to improve the performance of the dApp.\", //solhint-disable-line\n      address(0)\n    );\n    _addRole(\n      \"Member\",\n      \"Represents all users of Mutual.\", //solhint-disable-line\n      memberAuthority\n    );\n    _addRole(\n      \"Owner\",\n      \"Represents Owner of Mutual.\", //solhint-disable-line\n      address(0)\n    );\n    // _updateRole(_firstAB, uint(Role.AdvisoryBoard), true);\n    _updateRole(_firstAB, uint(Role.Owner), true);\n    // _updateRole(_firstAB, uint(Role.Member), true);\n    launchedOn = 0;\n  }\n\n  function memberAtIndex(uint _memberRoleId, uint index) external view returns (address, bool) {\n    address memberAddress = memberRoleData[_memberRoleId].memberAddress[index];\n    return (memberAddress, memberRoleData[_memberRoleId].memberActive[memberAddress]);\n  }\n\n  function membersLength(uint _memberRoleId) external view returns (uint) {\n    return memberRoleData[_memberRoleId].memberAddress.length;\n  }\n}\n\n// File: contracts/modules/capital/MCR.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n\n\n\n\ncontract MCR is Iupgradable {\n  using SafeMath for uint;\n\n  Pool1 internal p1;\n  PoolData internal pd;\n  NXMToken internal tk;\n  QuotationData internal qd;\n  MemberRoles internal mr;\n  TokenData internal td;\n  ProposalCategory internal proposalCategory;\n\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\n  uint private constant DECIMAL1E05 = uint(10) ** 5;\n  uint private constant DECIMAL1E19 = uint(10) ** 19;\n  uint private constant minCapFactor = uint(10) ** 21;\n\n  uint public variableMincap;\n  uint public dynamicMincapThresholdx100 = 13000;\n  uint public dynamicMincapIncrementx100 = 100;\n\n  event MCREvent(\n    uint indexed date,\n    uint blockNumber,\n    bytes4[] allCurr,\n    uint[] allCurrRates,\n    uint mcrEtherx100,\n    uint mcrPercx100,\n    uint vFull\n  );\n\n  /**\n   * @dev Adds new MCR data.\n   * @param mcrP  Minimum Capital Requirement in percentage.\n   * @param vF Pool1 fund value in Ether used in the last full daily calculation of the Capital model.\n   * @param onlyDate  Date(yyyymmdd) at which MCR details are getting added.\n   */\n  function addMCRData(\n    uint mcrP,\n    uint mcrE,\n    uint vF,\n    bytes4[] calldata curr,\n    uint[] calldata _threeDayAvg,\n    uint64 onlyDate\n  )\n  external\n  checkPause\n  {\n    require(proposalCategory.constructorCheck());\n    require(pd.isnotarise(msg.sender));\n    if (mr.launched() && pd.capReached() != 1) {\n\n      if (mcrP >= 10000)\n        pd.setCapReached(1);\n\n    }\n    uint len = pd.getMCRDataLength();\n    _addMCRData(len, onlyDate, curr, mcrE, mcrP, vF, _threeDayAvg);\n  }\n\n  /**\n   * @dev Adds MCR Data for last failed attempt.\n   */\n  function addLastMCRData(uint64 date) external checkPause onlyInternal {\n    uint64 lastdate = uint64(pd.getLastMCRDate());\n    uint64 failedDate = uint64(date);\n    if (failedDate >= lastdate) {\n      uint mcrP;\n      uint mcrE;\n      uint vF;\n      (mcrP, mcrE, vF,) = pd.getLastMCR();\n      uint len = pd.getAllCurrenciesLen();\n      pd.pushMCRData(mcrP, mcrE, vF, date);\n      for (uint j = 0; j < len; j++) {\n        bytes4 currName = pd.getCurrenciesByIndex(j);\n        pd.updateCAAvgRate(currName, pd.getCAAvgRate(currName));\n      }\n\n      emit MCREvent(date, block.number, new bytes4[](0), new uint[](0), mcrE, mcrP, vF);\n      // Oraclize call for next MCR calculation\n      _callOracliseForMCR();\n    }\n  }\n\n  /**\n   * @dev Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public onlyInternal {\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\n    p1 = Pool1(ms.getLatestAddress(\"P1\"));\n    pd = PoolData(ms.getLatestAddress(\"PD\"));\n    tk = NXMToken(ms.tokenAddress());\n    mr = MemberRoles(ms.getLatestAddress(\"MR\"));\n    td = TokenData(ms.getLatestAddress(\"TD\"));\n    proposalCategory = ProposalCategory(ms.getLatestAddress(\"PC\"));\n  }\n\n  /**\n   * @dev Gets total sum assured(in ETH).\n   * @return amount of sum assured\n   */\n  function getAllSumAssurance() public view returns (uint amount) {\n    uint len = pd.getAllCurrenciesLen();\n    for (uint i = 0; i < len; i++) {\n      bytes4 currName = pd.getCurrenciesByIndex(i);\n      if (currName == \"ETH\") {\n        amount = amount.add(qd.getTotalSumAssured(currName));\n      } else {\n        if (pd.getCAAvgRate(currName) > 0)\n          amount = amount.add((qd.getTotalSumAssured(currName).mul(100)).div(pd.getCAAvgRate(currName)));\n      }\n    }\n  }\n\n  /**\n   * @dev Calculates V(Tp) and MCR%(Tp), i.e, Pool Fund Value in Ether\n   * and MCR% used in the Token Price Calculation.\n   * @return vtp  Pool Fund Value in Ether used for the Token Price Model\n   * @return mcrtp MCR% used in the Token Price Model.\n   */\n  function _calVtpAndMCRtp(uint poolBalance) public view returns (uint vtp, uint mcrtp) {\n    vtp = 0;\n    IERC20 erc20;\n    uint currTokens = 0;\n    uint i;\n    for (i = 1; i < pd.getAllCurrenciesLen(); i++) {\n      bytes4 currency = pd.getCurrenciesByIndex(i);\n      erc20 = IERC20(pd.getCurrencyAssetAddress(currency));\n      currTokens = erc20.balanceOf(address(p1));\n      if (pd.getCAAvgRate(currency) > 0)\n        vtp = vtp.add((currTokens.mul(100)).div(pd.getCAAvgRate(currency)));\n    }\n\n    vtp = vtp.add(poolBalance).add(p1.getInvestmentAssetBalance());\n    uint mcrFullperc;\n    uint vFull;\n    (mcrFullperc, , vFull,) = pd.getLastMCR();\n    if (vFull > 0) {\n      mcrtp = (mcrFullperc.mul(vtp)).div(vFull);\n    }\n  }\n\n  /**\n   * @dev Calculates the Token Price of NXM in a given currency.\n   * @param curr Currency name.\n\n   */\n  function calculateStepTokenPrice(\n    bytes4 curr,\n    uint mcrtp\n  )\n  public\n  view\n  onlyInternal\n  returns (uint tokenPrice)\n  {\n    return _calculateTokenPrice(curr, mcrtp);\n  }\n\n  /**\n   * @dev Calculates the Token Price of NXM in a given currency\n   * with provided token supply for dynamic token price calculation\n   * @param curr Currency name.\n   */\n  function calculateTokenPrice(bytes4 curr) public view returns (uint tokenPrice) {\n    uint mcrtp;\n    (, mcrtp) = _calVtpAndMCRtp(address(p1).balance);\n    return _calculateTokenPrice(curr, mcrtp);\n  }\n\n  function calVtpAndMCRtp() public view returns (uint vtp, uint mcrtp) {\n    return _calVtpAndMCRtp(address(p1).balance);\n  }\n\n  function calculateVtpAndMCRtp(uint poolBalance) public view returns (uint vtp, uint mcrtp) {\n    return _calVtpAndMCRtp(poolBalance);\n  }\n\n  function getThresholdValues(uint vtp, uint vF, uint totalSA, uint minCap) public view returns (uint lowerThreshold, uint upperThreshold)\n  {\n    minCap = (minCap.mul(minCapFactor)).add(variableMincap);\n    uint lower = 0;\n    if (vtp >= vF) {\n      // Max Threshold = [MAX(Vtp, Vfull) x 120] / mcrMinCap\n      upperThreshold = vtp.mul(120).mul(100).div((minCap));\n    } else {\n      upperThreshold = vF.mul(120).mul(100).div((minCap));\n    }\n\n    if (vtp > 0) {\n      lower = totalSA.mul(DECIMAL1E18).mul(pd.shockParameter()).div(100);\n      if (lower < minCap.mul(11).div(10))\n        lower = minCap.mul(11).div(10);\n    }\n    if (lower > 0) {\n      // Min Threshold = [Vtp / MAX(TotalActiveSA x ShockParameter, mcrMinCap x 1.1)] x 100\n      lowerThreshold = vtp.mul(100).mul(100).div(lower);\n    }\n  }\n\n  /**\n   * @dev Gets max numbers of tokens that can be sold at the moment.\n   */\n  function getMaxSellTokens() public view returns (uint maxTokens) {\n    uint baseMin = pd.getCurrencyAssetBaseMin(\"ETH\");\n    uint maxTokensAccPoolBal;\n    if (address(p1).balance > baseMin.mul(50).div(100)) {\n      maxTokensAccPoolBal = address(p1).balance.sub(\n        (baseMin.mul(50)).div(100));\n    }\n    maxTokensAccPoolBal = (maxTokensAccPoolBal.mul(DECIMAL1E18)).div(\n      (calculateTokenPrice(\"ETH\").mul(975)).div(1000));\n    uint lastMCRPerc = pd.getLastMCRPerc();\n    if (lastMCRPerc > 10000)\n      maxTokens = (((uint(lastMCRPerc).sub(10000)).mul(2000)).mul(DECIMAL1E18)).div(10000);\n    if (maxTokens > maxTokensAccPoolBal)\n      maxTokens = maxTokensAccPoolBal;\n  }\n\n  /**\n   * @dev Gets Uint Parameters of a code\n   * @param code whose details we want\n   * @return string value of the code\n   * @return associated amount (time or perc or value) to the code\n   */\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\n    codeVal = code;\n    if (code == \"DMCT\") {\n      val = dynamicMincapThresholdx100;\n\n    } else if (code == \"DMCI\") {\n\n      val = dynamicMincapIncrementx100;\n\n    }\n\n  }\n\n  /**\n   * @dev Updates Uint Parameters of a code\n   * @param code whose details we want to update\n   * @param val value to set\n   */\n  function updateUintParameters(bytes8 code, uint val) public {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    if (code == \"DMCT\") {\n      dynamicMincapThresholdx100 = val;\n\n    } else if (code == \"DMCI\") {\n\n      dynamicMincapIncrementx100 = val;\n\n    }\n    else {\n      revert(\"Invalid param code\");\n    }\n\n  }\n\n  /**\n   * @dev Calls oraclize query to calculate MCR details after 24 hours.\n   */\n  function _callOracliseForMCR() internal {\n    p1.mcrOraclise(pd.mcrTime());\n  }\n\n  /**\n   * @dev Calculates the Token Price of NXM in a given currency\n   * with provided token supply for dynamic token price calculation\n   * @param _curr Currency name.\n   * @return tokenPrice Token price.\n   */\n  function _calculateTokenPrice(\n    bytes4 _curr,\n    uint mcrtp\n  )\n  internal\n  view\n  returns (uint tokenPrice)\n  {\n    uint getA;\n    uint getC;\n    uint getCAAvgRate;\n    uint tokenExponentValue = td.tokenExponent();\n    // uint max = (mcrtp.mul(mcrtp).mul(mcrtp).mul(mcrtp));\n    uint max = mcrtp ** tokenExponentValue;\n    uint dividingFactor = tokenExponentValue.mul(4);\n    (getA, getC, getCAAvgRate) = pd.getTokenPriceDetails(_curr);\n    uint mcrEth = pd.getLastMCREther();\n    getC = getC.mul(DECIMAL1E18);\n    tokenPrice = (mcrEth.mul(DECIMAL1E18).mul(max).div(getC)).div(10 ** dividingFactor);\n    tokenPrice = tokenPrice.add(getA.mul(DECIMAL1E18).div(DECIMAL1E05));\n    tokenPrice = tokenPrice.mul(getCAAvgRate * 10);\n    tokenPrice = (tokenPrice).div(10 ** 3);\n  }\n\n  /**\n   * @dev Adds MCR Data. Checks if MCR is within valid\n   * thresholds in order to rule out any incorrect calculations\n   */\n  function _addMCRData(\n    uint len,\n    uint64 newMCRDate,\n    bytes4[] memory curr,\n    uint mcrE,\n    uint mcrP,\n    uint vF,\n    uint[] memory _threeDayAvg\n  )\n  internal\n  {\n    uint vtp = 0;\n    uint lowerThreshold = 0;\n    uint upperThreshold = 0;\n    if (len > 1) {\n      (vtp,) = _calVtpAndMCRtp(address(p1).balance);\n      (lowerThreshold, upperThreshold) = getThresholdValues(vtp, vF, getAllSumAssurance(), pd.minCap());\n\n    }\n    if (mcrP > dynamicMincapThresholdx100)\n      variableMincap = (variableMincap.mul(dynamicMincapIncrementx100.add(10000)).add(minCapFactor.mul(pd.minCap().mul(dynamicMincapIncrementx100)))).div(10000);\n\n\n    // Explanation for above formula :-\n    // actual formula -> variableMinCap =  variableMinCap + (variableMinCap+minCap)*dynamicMincapIncrement/100\n    // Implemented formula is simplified form of actual formula.\n    // Let consider above formula as b = b + (a+b)*c/100\n    // here, dynamicMincapIncrement is in x100 format.\n    // so b+(a+b)*cx100/10000 can be written as => (10000.b + b.cx100 + a.cx100)/10000.\n    // It can further simplify to (b.(10000+cx100) + a.cx100)/10000.\n    if (len == 1 || (mcrP) >= lowerThreshold\n    && (mcrP) <= upperThreshold) {\n      // due to stack to deep error,we are reusing already declared variable\n      vtp = pd.getLastMCRDate();\n      pd.pushMCRData(mcrP, mcrE, vF, newMCRDate);\n      for (uint i = 0; i < curr.length; i++) {\n        pd.updateCAAvgRate(curr[i], _threeDayAvg[i]);\n      }\n      emit MCREvent(newMCRDate, block.number, curr, _threeDayAvg, mcrE, mcrP, vF);\n      // Oraclize call for next MCR calculation\n      if (vtp < newMCRDate) {\n        _callOracliseForMCR();\n      }\n    } else {\n      p1.mcrOracliseFail(newMCRDate, pd.mcrFailTime());\n    }\n  }\n\n}\n\n// File: contracts/interfaces/Exchange.sol\n\npragma solidity ^0.5.0;\n\n\ninterface Factory {\n  function getExchange(address token) external view returns (address);\n\n  function getToken(address exchange) external view returns (address);\n}\n\n\ninterface Exchange {\n\n  function getEthToTokenInputPrice(uint256 ethSold) external view returns (uint256);\n\n  function getTokenToEthInputPrice(uint256 tokensSold) external view returns (uint256);\n\n  function ethToTokenSwapInput(uint256 minTokens, uint256 deadline) external payable returns (uint256);\n\n  function ethToTokenTransferInput(uint256 minTokens, uint256 deadline, address recipient) external payable returns (uint256);\n\n  function tokenToEthSwapInput(uint256 tokensSold, uint256 minEth, uint256 deadline) external payable returns (uint256);\n\n  function tokenToEthTransferInput(uint256 tokensSold, uint256 minEth, uint256 deadline, address recipient) external payable returns (uint256);\n\n  function tokenToTokenSwapInput(\n    uint256 tokensSold,\n    uint256 minTokensBought,\n    uint256 minEthBought,\n    uint256 deadline,\n    address tokenAddress\n  ) external returns (uint256);\n\n  function tokenToTokenTransferInput(\n    uint256 tokensSold,\n    uint256 minTokensBought,\n    uint256 minEthBought,\n    uint256 deadline,\n    address recipient,\n    address tokenAddress\n  ) external returns (uint256);\n}\n\n// File: contracts/modules/cover/Quotation.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n\n\n\n\ncontract Quotation is Iupgradable {\n  using SafeMath for uint;\n\n  TokenFunctions internal tf;\n  TokenController internal tc;\n  TokenData internal td;\n  Pool1 internal p1;\n  PoolData internal pd;\n  QuotationData internal qd;\n  MCR internal m1;\n  MemberRoles internal mr;\n  bool internal locked;\n\n  event RefundEvent(address indexed user, bool indexed status, uint holdedCoverID, bytes32 reason);\n\n  modifier noReentrancy() {\n    require(!locked, \"Reentrant call.\");\n    locked = true;\n    _;\n    locked = false;\n  }\n\n  /**\n   * @dev Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public onlyInternal {\n    m1 = MCR(ms.getLatestAddress(\"MC\"));\n    tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\n    tc = TokenController(ms.getLatestAddress(\"TC\"));\n    td = TokenData(ms.getLatestAddress(\"TD\"));\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\n    p1 = Pool1(ms.getLatestAddress(\"P1\"));\n    pd = PoolData(ms.getLatestAddress(\"PD\"));\n    mr = MemberRoles(ms.getLatestAddress(\"MR\"));\n  }\n\n  function sendEther() public payable {\n\n  }\n\n  /**\n   * @dev Expires a cover after a set period of time.\n   * Changes the status of the Cover and reduces the current\n   * sum assured of all areas in which the quotation lies\n   * Unlocks the CN tokens of the cover. Updates the Total Sum Assured value.\n   * @param _cid Cover Id.\n   */\n  function expireCover(uint _cid) public {\n    require(checkCoverExpired(_cid) && qd.getCoverStatusNo(_cid) != uint(QuotationData.CoverStatus.CoverExpired));\n\n    tf.unlockCN(_cid);\n    bytes4 curr;\n    address scAddress;\n    uint sumAssured;\n    (,, scAddress, curr, sumAssured,) = qd.getCoverDetailsByCoverID1(_cid);\n    if (qd.getCoverStatusNo(_cid) != uint(QuotationData.CoverStatus.ClaimAccepted))\n      _removeSAFromCSA(_cid, sumAssured);\n    qd.changeCoverStatusNo(_cid, uint8(QuotationData.CoverStatus.CoverExpired));\n  }\n\n  /**\n   * @dev Checks if a cover should get expired/closed or not.\n   * @param _cid Cover Index.\n   * @return expire true if the Cover's time has expired, false otherwise.\n   */\n  function checkCoverExpired(uint _cid) public view returns (bool expire) {\n\n    expire = qd.getValidityOfCover(_cid) < uint64(now);\n\n  }\n\n  /**\n   * @dev Updates the Sum Assured Amount of all the quotation.\n   * @param _cid Cover id\n   * @param _amount that will get subtracted Current Sum Assured\n   * amount that comes under a quotation.\n   */\n  function removeSAFromCSA(uint _cid, uint _amount) public onlyInternal {\n    _removeSAFromCSA(_cid, _amount);\n  }\n\n  /**\n   * @dev Makes Cover funded via NXM tokens.\n   * @param smartCAdd Smart Contract Address\n   */\n  function makeCoverUsingNXMTokens(\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    bytes4 coverCurr,\n    address smartCAdd,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  )\n  public\n  isMemberAndcheckPause\n  {\n\n    tc.burnFrom(msg.sender, coverDetails[2]); // need burn allowance\n    _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n  }\n\n  /**\n   * @dev Verifies cover details signed off chain.\n   * @param from address of funder.\n   * @param scAddress Smart Contract Address\n   */\n  function verifyCoverDetails(\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  )\n  public\n  onlyInternal\n  {\n    _verifyCoverDetails(\n      from,\n      scAddress,\n      coverCurr,\n      coverDetails,\n      coverPeriod,\n      _v,\n      _r,\n      _s\n    );\n  }\n\n  /**\n   * @dev Verifies signature.\n   * @param coverDetails details related to cover.\n   * @param coverPeriod validity of cover.\n   * @param smaratCA smarat contract address.\n   * @param _v argument from vrs hash.\n   * @param _r argument from vrs hash.\n   * @param _s argument from vrs hash.\n   */\n  function verifySign(\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    bytes4 curr,\n    address smaratCA,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  )\n  public\n  view\n  returns (bool)\n  {\n    require(smaratCA != address(0));\n    require(pd.capReached() == 1, \"Can not buy cover until cap reached for 1st time\");\n    bytes32 hash = getOrderHash(coverDetails, coverPeriod, curr, smaratCA);\n    return isValidSignature(hash, _v, _r, _s);\n  }\n\n  /**\n   * @dev Gets order hash for given cover details.\n   * @param coverDetails details realted to cover.\n   * @param coverPeriod validity of cover.\n   * @param smaratCA smarat contract address.\n   */\n  function getOrderHash(\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    bytes4 curr,\n    address smaratCA\n  )\n  public\n  view\n  returns (bytes32)\n  {\n    return keccak256(\n      abi.encodePacked(\n        coverDetails[0],\n        curr, coverPeriod,\n        smaratCA,\n        coverDetails[1],\n        coverDetails[2],\n        coverDetails[3],\n        coverDetails[4],\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @dev Verifies signature.\n   * @param hash order hash\n   * @param v argument from vrs hash.\n   * @param r argument from vrs hash.\n   * @param s argument from vrs hash.\n   */\n  function isValidSignature(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n    bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\n    address a = ecrecover(prefixedHash, v, r, s);\n    return (a == qd.getAuthQuoteEngine());\n  }\n\n  /**\n   * @dev to get the status of recently holded coverID\n   * @param userAdd is the user address in concern\n   * @return the status of the concerned coverId\n   */\n  function getRecentHoldedCoverIdStatus(address userAdd) public view returns (int) {\n\n    uint holdedCoverLen = qd.getUserHoldedCoverLength(userAdd);\n    if (holdedCoverLen == 0) {\n      return - 1;\n    } else {\n      uint holdedCoverID = qd.getUserHoldedCoverByIndex(userAdd, holdedCoverLen.sub(1));\n      return int(qd.holdedCoverIDStatus(holdedCoverID));\n    }\n  }\n\n  /**\n   * @dev to initiate the membership and the cover\n   * @param smartCAdd is the smart contract address to make cover on\n   * @param coverCurr is the currency used to make cover\n   * @param coverDetails list of details related to cover like cover amount, expire time, coverCurrPrice and priceNXM\n   * @param coverPeriod is cover period for which cover is being bought\n   * @param _v argument from vrs hash\n   * @param _r argument from vrs hash\n   * @param _s argument from vrs hash\n   */\n  function initiateMembershipAndCover(\n    address smartCAdd,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  )\n  public\n  payable\n  checkPause\n  {\n    require(coverDetails[3] > now);\n    require(!qd.timestampRepeated(coverDetails[4]));\n    qd.setTimestampRepeated(coverDetails[4]);\n    require(!ms.isMember(msg.sender));\n    require(qd.refundEligible(msg.sender) == false);\n    uint joinFee = td.joiningFee();\n    uint totalFee = joinFee;\n    if (coverCurr == \"ETH\") {\n      totalFee = joinFee.add(coverDetails[1]);\n    } else {\n      IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n      require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]));\n    }\n    require(msg.value == totalFee);\n    require(verifySign(coverDetails, coverPeriod, coverCurr, smartCAdd, _v, _r, _s));\n    qd.addHoldCover(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod);\n    qd.setRefundEligible(msg.sender, true);\n  }\n\n  /**\n   * @dev to get the verdict of kyc process\n   * @param status is the kyc status\n   * @param _add is the address of member\n   */\n  function kycVerdict(address _add, bool status) public checkPause noReentrancy {\n    require(msg.sender == qd.kycAuthAddress());\n    _kycTrigger(status, _add);\n  }\n\n  /**\n   * @dev transfering Ethers to newly created quotation contract.\n   */\n  function transferAssetsToNewContract(address newAdd) public onlyInternal noReentrancy {\n    uint amount = address(this).balance;\n    IERC20 erc20;\n    if (amount > 0) {\n      // newAdd.transfer(amount);\n      Quotation newQT = Quotation(newAdd);\n      newQT.sendEther.value(amount)();\n    }\n    uint currAssetLen = pd.getAllCurrenciesLen();\n    for (uint64 i = 1; i < currAssetLen; i++) {\n      bytes4 currName = pd.getCurrenciesByIndex(i);\n      address currAddr = pd.getCurrencyAssetAddress(currName);\n      erc20 = IERC20(currAddr); // solhint-disable-line\n      if (erc20.balanceOf(address(this)) > 0) {\n        require(erc20.transfer(newAdd, erc20.balanceOf(address(this))));\n      }\n    }\n  }\n\n\n  /**\n   * @dev Creates cover of the quotation, changes the status of the quotation ,\n   * updates the total sum assured and locks the tokens of the cover against a quote.\n   * @param from Quote member Ethereum address.\n   */\n\n  function _makeCover(//solhint-disable-line\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod\n  )\n  internal\n  {\n    uint cid = qd.getCoverLength();\n    qd.addCover(coverPeriod, coverDetails[0],\n      from, coverCurr, scAddress, coverDetails[1], coverDetails[2]);\n    // if cover period of quote is less than 60 days.\n    if (coverPeriod <= 60) {\n      p1.closeCoverOraclise(cid, uint64(uint(coverPeriod).mul(1 days)));\n    }\n    uint coverNoteAmount = (coverDetails[2].mul(qd.tokensRetained())).div(100);\n    tc.mint(from, coverNoteAmount);\n    tf.lockCN(coverNoteAmount, coverPeriod, cid, from);\n    qd.addInTotalSumAssured(coverCurr, coverDetails[0]);\n    qd.addInTotalSumAssuredSC(scAddress, coverCurr, coverDetails[0]);\n\n\n    tf.pushStakerRewards(scAddress, coverDetails[2]);\n  }\n\n  /**\n   * @dev Makes a vover.\n   * @param from address of funder.\n   * @param scAddress Smart Contract Address\n   */\n  function _verifyCoverDetails(\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  )\n  internal\n  {\n    require(coverDetails[3] > now);\n    require(!qd.timestampRepeated(coverDetails[4]));\n    qd.setTimestampRepeated(coverDetails[4]);\n    require(verifySign(coverDetails, coverPeriod, coverCurr, scAddress, _v, _r, _s));\n    _makeCover(from, scAddress, coverCurr, coverDetails, coverPeriod);\n\n  }\n\n  /**\n   * @dev Updates the Sum Assured Amount of all the quotation.\n   * @param _cid Cover id\n   * @param _amount that will get subtracted Current Sum Assured\n   * amount that comes under a quotation.\n   */\n  function _removeSAFromCSA(uint _cid, uint _amount) internal checkPause {\n    address _add;\n    bytes4 coverCurr;\n    (,, _add, coverCurr,,) = qd.getCoverDetailsByCoverID1(_cid);\n    qd.subFromTotalSumAssured(coverCurr, _amount);\n    qd.subFromTotalSumAssuredSC(_add, coverCurr, _amount);\n  }\n\n  /**\n   * @dev to trigger the kyc process\n   * @param status is the kyc status\n   * @param _add is the address of member\n   */\n  function _kycTrigger(bool status, address _add) internal {\n\n    uint holdedCoverLen = qd.getUserHoldedCoverLength(_add).sub(1);\n    uint holdedCoverID = qd.getUserHoldedCoverByIndex(_add, holdedCoverLen);\n    address payable userAdd;\n    address scAddress;\n    bytes4 coverCurr;\n    uint16 coverPeriod;\n    uint[]  memory coverDetails = new uint[](4);\n    IERC20 erc20;\n\n    (, userAdd, coverDetails) = qd.getHoldedCoverDetailsByID2(holdedCoverID);\n    (, scAddress, coverCurr, coverPeriod) = qd.getHoldedCoverDetailsByID1(holdedCoverID);\n    require(qd.refundEligible(userAdd));\n    qd.setRefundEligible(userAdd, false);\n    require(qd.holdedCoverIDStatus(holdedCoverID) == uint(QuotationData.HCIDStatus.kycPending));\n    uint joinFee = td.joiningFee();\n    if (status) {\n      mr.payJoiningFee.value(joinFee)(userAdd);\n      if (coverDetails[3] > now) {\n        qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycPass));\n        address poolAdd = ms.getLatestAddress(\"P1\");\n        if (coverCurr == \"ETH\") {\n          p1.sendEther.value(coverDetails[1])();\n        } else {\n          erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); // solhint-disable-line\n          require(erc20.transfer(poolAdd, coverDetails[1]));\n        }\n        emit RefundEvent(userAdd, status, holdedCoverID, \"KYC Passed\");\n        _makeCover(userAdd, scAddress, coverCurr, coverDetails, coverPeriod);\n\n      } else {\n        qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycPassNoCover));\n        if (coverCurr == \"ETH\") {\n          userAdd.transfer(coverDetails[1]);\n        } else {\n          erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); // solhint-disable-line\n          require(erc20.transfer(userAdd, coverDetails[1]));\n        }\n        emit RefundEvent(userAdd, status, holdedCoverID, \"Cover Failed\");\n      }\n    } else {\n      qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycFailedOrRefunded));\n      uint totalRefund = joinFee;\n      if (coverCurr == \"ETH\") {\n        totalRefund = coverDetails[1].add(joinFee);\n      } else {\n        erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); // solhint-disable-line\n        require(erc20.transfer(userAdd, coverDetails[1]));\n      }\n      userAdd.transfer(totalRefund);\n      emit RefundEvent(userAdd, status, holdedCoverID, \"KYC Failed\");\n    }\n\n  }\n}\n\n// File: contracts/modules/capital/Pool2.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\n\n\n\ncontract Pool2 is Iupgradable {\n  using SafeMath for uint;\n\n  MCR internal m1;\n  Pool1 internal p1;\n  PoolData internal pd;\n  Factory internal factory;\n  address public uniswapFactoryAddress;\n  uint internal constant DECIMAL1E18 = uint(10) ** 18;\n  bool internal locked;\n\n  constructor(address _uniswapFactoryAdd) public {\n\n    uniswapFactoryAddress = _uniswapFactoryAdd;\n    factory = Factory(_uniswapFactoryAdd);\n  }\n\n  function() external payable {}\n\n  event Liquidity(bytes16 typeOf, bytes16 functionName);\n\n  event Rebalancing(bytes4 iaCurr, uint tokenAmount);\n\n  modifier noReentrancy() {\n    require(!locked, \"Reentrant call.\");\n    locked = true;\n    _;\n    locked = false;\n  }\n\n  /**\n   * @dev to change the uniswap factory address\n   * @param newFactoryAddress is the new factory address in concern\n   * @return the status of the concerned coverId\n   */\n  function changeUniswapFactoryAddress(address newFactoryAddress) external onlyInternal {\n    // require(ms.isOwner(msg.sender) || ms.checkIsAuthToGoverned(msg.sender));\n    uniswapFactoryAddress = newFactoryAddress;\n    factory = Factory(uniswapFactoryAddress);\n  }\n\n  /**\n   * @dev On upgrade transfer all investment assets and ether to new Investment Pool\n   * @param newPoolAddress New Investment Assest Pool address\n   */\n  function upgradeInvestmentPool(address payable newPoolAddress) external onlyInternal noReentrancy {\n    uint len = pd.getInvestmentCurrencyLen();\n    for (uint64 i = 1; i < len; i++) {\n      bytes4 iaName = pd.getInvestmentCurrencyByIndex(i);\n      _upgradeInvestmentPool(iaName, newPoolAddress);\n    }\n\n    if (address(this).balance > 0) {\n      Pool2 newP2 = Pool2(newPoolAddress);\n      newP2.sendEther.value(address(this).balance)();\n    }\n  }\n\n  /**\n   * @dev Internal Swap of assets between Capital\n   * and Investment Sub pool for excess or insufficient\n   * liquidity conditions of a given currency.\n   */\n  function internalLiquiditySwap(bytes4 curr) external onlyInternal noReentrancy {\n    uint caBalance;\n    uint baseMin;\n    uint varMin;\n    (, baseMin, varMin) = pd.getCurrencyAssetVarBase(curr);\n    caBalance = _getCurrencyAssetsBalance(curr);\n\n    if (caBalance > uint(baseMin).add(varMin).mul(2)) {\n      _internalExcessLiquiditySwap(curr, baseMin, varMin, caBalance);\n    } else if (caBalance < uint(baseMin).add(varMin)) {\n      _internalInsufficientLiquiditySwap(curr, baseMin, varMin, caBalance);\n\n    }\n  }\n\n  /**\n   * @dev Saves a given investment asset details. To be called daily.\n   * @param curr array of Investment asset name.\n   * @param rate array of investment asset exchange rate.\n   * @param date current date in yyyymmdd.\n   */\n  function saveIADetails(bytes4[] calldata curr, uint64[] calldata rate, uint64 date, bool bit)\n  external checkPause noReentrancy {\n    bytes4 maxCurr;\n    bytes4 minCurr;\n    uint64 maxRate;\n    uint64 minRate;\n    //ONLY NOTARZIE ADDRESS CAN POST\n    require(pd.isnotarise(msg.sender));\n    (maxCurr, maxRate, minCurr, minRate) = _calculateIARank(curr, rate);\n    pd.saveIARankDetails(maxCurr, maxRate, minCurr, minRate, date);\n    pd.updatelastDate(date);\n    uint len = curr.length;\n    for (uint i = 0; i < len; i++) {\n      pd.updateIAAvgRate(curr[i], rate[i]);\n    }\n    if (bit)   //for testing purpose\n      _rebalancingLiquidityTrading(maxCurr, maxRate);\n    p1.saveIADetailsOracalise(pd.iaRatesTime());\n  }\n\n  /**\n   * @dev External Trade for excess or insufficient\n   * liquidity conditions of a given currency.\n   */\n  function externalLiquidityTrade() external onlyInternal {\n\n    bool triggerTrade;\n    bytes4 curr;\n    bytes4 minIACurr;\n    bytes4 maxIACurr;\n    uint amount;\n    uint minIARate;\n    uint maxIARate;\n    uint baseMin;\n    uint varMin;\n    uint caBalance;\n\n\n    (maxIACurr, maxIARate, minIACurr, minIARate) = pd.getIARankDetailsByDate(pd.getLastDate());\n    uint len = pd.getAllCurrenciesLen();\n    for (uint64 i = 0; i < len; i++) {\n      curr = pd.getCurrenciesByIndex(i);\n      (, baseMin, varMin) = pd.getCurrencyAssetVarBase(curr);\n      caBalance = _getCurrencyAssetsBalance(curr);\n\n      if (caBalance > uint(baseMin).add(varMin).mul(2)) {// excess\n        amount = caBalance.sub(((uint(baseMin).add(varMin)).mul(3)).div(2)); // *10**18;\n        triggerTrade = _externalExcessLiquiditySwap(curr, minIACurr, amount);\n      } else if (caBalance < uint(baseMin).add(varMin)) {// insufficient\n        amount = (((uint(baseMin).add(varMin)).mul(3)).div(2)).sub(caBalance);\n        triggerTrade = _externalInsufficientLiquiditySwap(curr, maxIACurr, amount);\n      }\n\n      if (triggerTrade) {\n        p1.triggerExternalLiquidityTrade();\n      }\n    }\n  }\n\n  /**\n   * Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public onlyInternal {\n    m1 = MCR(ms.getLatestAddress(\"MC\"));\n    pd = PoolData(ms.getLatestAddress(\"PD\"));\n    p1 = Pool1(ms.getLatestAddress(\"P1\"));\n  }\n\n  function sendEther() public payable {\n\n  }\n\n  /**\n   * @dev Gets currency asset balance for a given currency name.\n   */\n  function _getCurrencyAssetsBalance(bytes4 _curr) public view returns (uint caBalance) {\n    if (_curr == \"ETH\") {\n      caBalance = address(p1).balance;\n    } else {\n      IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(_curr));\n      caBalance = erc20.balanceOf(address(p1));\n    }\n  }\n\n  /**\n   * @dev Transfers ERC20 investment asset from this Pool to another Pool.\n   */\n  function _transferInvestmentAsset(\n    bytes4 _curr,\n    address _transferTo,\n    uint _amount\n  )\n  internal\n  {\n    if (_curr == \"ETH\") {\n      if (_amount > address(this).balance)\n        _amount = address(this).balance;\n      p1.sendEther.value(_amount)();\n    } else {\n      IERC20 erc20 = IERC20(pd.getInvestmentAssetAddress(_curr));\n      if (_amount > erc20.balanceOf(address(this)))\n        _amount = erc20.balanceOf(address(this));\n      require(erc20.transfer(_transferTo, _amount));\n    }\n  }\n\n  /**\n   * @dev to perform rebalancing\n   * @param iaCurr is the investment asset currency\n   * @param iaRate is the investment asset rate\n   */\n  function _rebalancingLiquidityTrading(\n    bytes4 iaCurr,\n    uint64 iaRate\n  )\n  internal\n  checkPause\n  {\n    uint amountToSell;\n    uint totalRiskBal = pd.getLastVfull();\n    uint intermediaryEth;\n    uint ethVol = pd.ethVolumeLimit();\n\n    totalRiskBal = (totalRiskBal.mul(100000)).div(DECIMAL1E18);\n    Exchange exchange;\n    if (totalRiskBal > 0) {\n      amountToSell = ((totalRiskBal.mul(2).mul(\n        iaRate)).mul(pd.variationPercX100())).div(100 * 100 * 100000);\n      amountToSell = (amountToSell.mul(\n        10 ** uint(pd.getInvestmentAssetDecimals(iaCurr)))).div(100); // amount of asset to sell\n\n      if (iaCurr != \"ETH\" && _checkTradeConditions(iaCurr, iaRate, totalRiskBal)) {\n        exchange = Exchange(factory.getExchange(pd.getInvestmentAssetAddress(iaCurr)));\n        intermediaryEth = exchange.getTokenToEthInputPrice(amountToSell);\n        if (intermediaryEth > (address(exchange).balance.mul(ethVol)).div(100)) {\n          intermediaryEth = (address(exchange).balance.mul(ethVol)).div(100);\n          amountToSell = (exchange.getEthToTokenInputPrice(intermediaryEth).mul(995)).div(1000);\n        }\n        IERC20 erc20;\n        erc20 = IERC20(pd.getCurrencyAssetAddress(iaCurr));\n        erc20.approve(address(exchange), amountToSell);\n        exchange.tokenToEthSwapInput(amountToSell, (exchange.getTokenToEthInputPrice(\n          amountToSell).mul(995)).div(1000), pd.uniswapDeadline().add(now));\n      } else if (iaCurr == \"ETH\" && _checkTradeConditions(iaCurr, iaRate, totalRiskBal)) {\n\n        _transferInvestmentAsset(iaCurr, ms.getLatestAddress(\"P1\"), amountToSell);\n      }\n      emit Rebalancing(iaCurr, amountToSell);\n    }\n  }\n\n  /**\n   * @dev Checks whether trading is required for a\n   * given investment asset at a given exchange rate.\n   */\n  function _checkTradeConditions(\n    bytes4 curr,\n    uint64 iaRate,\n    uint totalRiskBal\n  )\n  internal\n  view\n  returns (bool check)\n  {\n    if (iaRate > 0) {\n      uint iaBalance = _getInvestmentAssetBalance(curr).div(DECIMAL1E18);\n      if (iaBalance > 0 && totalRiskBal > 0) {\n        uint iaMax;\n        uint iaMin;\n        uint checkNumber;\n        uint z;\n        (iaMin, iaMax) = pd.getInvestmentAssetHoldingPerc(curr);\n        z = pd.variationPercX100();\n        checkNumber = (iaBalance.mul(100 * 100000)).div(totalRiskBal.mul(iaRate));\n        if ((checkNumber > ((totalRiskBal.mul(iaMax.add(z))).mul(100000)).div(100)) ||\n          (checkNumber < ((totalRiskBal.mul(iaMin.sub(z))).mul(100000)).div(100)))\n          check = true; // eligibleIA\n      }\n    }\n  }\n\n  /**\n   * @dev Gets the investment asset rank.\n   */\n  function _getIARank(\n    bytes4 curr,\n    uint64 rateX100,\n    uint totalRiskPoolBalance\n  )\n  internal\n  view\n  returns (int rhsh, int rhsl) //internal function\n  {\n\n    uint currentIAmaxHolding;\n    uint currentIAminHolding;\n    uint iaBalance = _getInvestmentAssetBalance(curr);\n    (currentIAminHolding, currentIAmaxHolding) = pd.getInvestmentAssetHoldingPerc(curr);\n\n    if (rateX100 > 0) {\n      uint rhsf;\n      rhsf = (iaBalance.mul(1000000)).div(totalRiskPoolBalance.mul(rateX100));\n      rhsh = int(rhsf - currentIAmaxHolding);\n      rhsl = int(rhsf - currentIAminHolding);\n    }\n  }\n\n  /**\n   * @dev Calculates the investment asset rank.\n   */\n  function _calculateIARank(\n    bytes4[] memory curr,\n    uint64[] memory rate\n  )\n  internal\n  view\n  returns (\n    bytes4 maxCurr,\n    uint64 maxRate,\n    bytes4 minCurr,\n    uint64 minRate\n  )\n  {\n    int max = 0;\n    int min = - 1;\n    int rhsh;\n    int rhsl;\n    uint totalRiskPoolBalance;\n    (totalRiskPoolBalance,) = m1.calVtpAndMCRtp();\n    uint len = curr.length;\n    for (uint i = 0; i < len; i++) {\n      rhsl = 0;\n      rhsh = 0;\n      if (pd.getInvestmentAssetStatus(curr[i])) {\n        (rhsh, rhsl) = _getIARank(curr[i], rate[i], totalRiskPoolBalance);\n        if (rhsh > max || i == 0) {\n          max = rhsh;\n          maxCurr = curr[i];\n          maxRate = rate[i];\n        }\n        if (rhsl < min || rhsl == 0 || i == 0) {\n          min = rhsl;\n          minCurr = curr[i];\n          minRate = rate[i];\n        }\n      }\n    }\n  }\n\n  /**\n   * @dev to get balance of an investment asset\n   * @param _curr is the investment asset in concern\n   * @return the balance\n   */\n  function _getInvestmentAssetBalance(bytes4 _curr) internal view returns (uint balance) {\n    if (_curr == \"ETH\") {\n      balance = address(this).balance;\n    } else {\n      IERC20 erc20 = IERC20(pd.getInvestmentAssetAddress(_curr));\n      balance = erc20.balanceOf(address(this));\n    }\n  }\n\n  /**\n   * @dev Creates Excess liquidity trading order for a given currency and a given balance.\n   */\n  function _internalExcessLiquiditySwap(bytes4 _curr, uint _baseMin, uint _varMin, uint _caBalance) internal {\n    // require(ms.isInternal(msg.sender) || md.isnotarise(msg.sender));\n    bytes4 minIACurr;\n    // uint amount;\n\n    (,, minIACurr,) = pd.getIARankDetailsByDate(pd.getLastDate());\n    if (_curr == minIACurr) {\n      // amount = _caBalance.sub(((_baseMin.add(_varMin)).mul(3)).div(2)); //*10**18;\n      p1.transferCurrencyAsset(_curr, _caBalance.sub(((_baseMin.add(_varMin)).mul(3)).div(2)));\n    } else {\n      p1.triggerExternalLiquidityTrade();\n    }\n  }\n\n  /**\n   * @dev insufficient liquidity swap\n   * for a given currency and a given balance.\n   */\n  function _internalInsufficientLiquiditySwap(bytes4 _curr, uint _baseMin, uint _varMin, uint _caBalance) internal {\n\n    bytes4 maxIACurr;\n    uint amount;\n\n    (maxIACurr,,,) = pd.getIARankDetailsByDate(pd.getLastDate());\n\n    if (_curr == maxIACurr) {\n      amount = (((_baseMin.add(_varMin)).mul(3)).div(2)).sub(_caBalance);\n      _transferInvestmentAsset(_curr, ms.getLatestAddress(\"P1\"), amount);\n    } else {\n      IERC20 erc20 = IERC20(pd.getInvestmentAssetAddress(maxIACurr));\n      if ((maxIACurr == \"ETH\" && address(this).balance > 0) ||\n        (maxIACurr != \"ETH\" && erc20.balanceOf(address(this)) > 0))\n        p1.triggerExternalLiquidityTrade();\n\n    }\n  }\n\n  /**\n   * @dev Creates External excess liquidity trading\n   * order for a given currency and a given balance.\n   * @param curr Currency Asset to Sell\n   * @param minIACurr Investment Asset to Buy\n   * @param amount Amount of Currency Asset to Sell\n   */\n  function _externalExcessLiquiditySwap(\n    bytes4 curr,\n    bytes4 minIACurr,\n    uint256 amount\n  )\n  internal\n  returns (bool trigger)\n  {\n    uint intermediaryEth;\n    Exchange exchange;\n    IERC20 erc20;\n    uint ethVol = pd.ethVolumeLimit();\n    if (curr == minIACurr) {\n      p1.transferCurrencyAsset(curr, amount);\n    } else if (curr == \"ETH\" && minIACurr != \"ETH\") {\n\n      exchange = Exchange(factory.getExchange(pd.getInvestmentAssetAddress(minIACurr)));\n      if (amount > (address(exchange).balance.mul(ethVol)).div(100)) {// 4% ETH volume limit\n        amount = (address(exchange).balance.mul(ethVol)).div(100);\n        trigger = true;\n      }\n      p1.transferCurrencyAsset(curr, amount);\n      exchange.ethToTokenSwapInput.value(amount)\n      (exchange.getEthToTokenInputPrice(amount).mul(995).div(1000), pd.uniswapDeadline().add(now));\n    } else if (curr != \"ETH\" && minIACurr == \"ETH\") {\n      exchange = Exchange(factory.getExchange(pd.getCurrencyAssetAddress(curr)));\n      erc20 = IERC20(pd.getCurrencyAssetAddress(curr));\n      intermediaryEth = exchange.getTokenToEthInputPrice(amount);\n\n      if (intermediaryEth > (address(exchange).balance.mul(ethVol)).div(100)) {\n        intermediaryEth = (address(exchange).balance.mul(ethVol)).div(100);\n        amount = exchange.getEthToTokenInputPrice(intermediaryEth);\n        intermediaryEth = exchange.getTokenToEthInputPrice(amount);\n        trigger = true;\n      }\n      p1.transferCurrencyAsset(curr, amount);\n      // erc20.decreaseAllowance(address(exchange), erc20.allowance(address(this), address(exchange)));\n      erc20.approve(address(exchange), amount);\n\n      exchange.tokenToEthSwapInput(amount, (\n      intermediaryEth.mul(995)).div(1000), pd.uniswapDeadline().add(now));\n    } else {\n\n      exchange = Exchange(factory.getExchange(pd.getCurrencyAssetAddress(curr)));\n      intermediaryEth = exchange.getTokenToEthInputPrice(amount);\n\n      if (intermediaryEth > (address(exchange).balance.mul(ethVol)).div(100)) {\n        intermediaryEth = (address(exchange).balance.mul(ethVol)).div(100);\n        amount = exchange.getEthToTokenInputPrice(intermediaryEth);\n        trigger = true;\n      }\n\n      Exchange tmp = Exchange(factory.getExchange(\n          pd.getInvestmentAssetAddress(minIACurr))); // minIACurr exchange\n\n      if (intermediaryEth > address(tmp).balance.mul(ethVol).div(100)) {\n        intermediaryEth = address(tmp).balance.mul(ethVol).div(100);\n        amount = exchange.getEthToTokenInputPrice(intermediaryEth);\n        trigger = true;\n      }\n      p1.transferCurrencyAsset(curr, amount);\n      erc20 = IERC20(pd.getCurrencyAssetAddress(curr));\n      erc20.approve(address(exchange), amount);\n\n      exchange.tokenToTokenSwapInput(amount, (tmp.getEthToTokenInputPrice(\n        intermediaryEth).mul(995)).div(1000), (intermediaryEth.mul(995)).div(1000),\n        pd.uniswapDeadline().add(now), pd.getInvestmentAssetAddress(minIACurr));\n    }\n  }\n\n  /**\n   * @dev insufficient liquidity swap\n   * for a given currency and a given balance.\n   * @param curr Currency Asset to buy\n   * @param maxIACurr Investment Asset to sell\n   * @param amount Amount of Investment Asset to sell\n   */\n  function _externalInsufficientLiquiditySwap(\n    bytes4 curr,\n    bytes4 maxIACurr,\n    uint256 amount\n  )\n  internal\n  returns (bool trigger)\n  {\n\n    Exchange exchange;\n    IERC20 erc20;\n    uint intermediaryEth;\n    // uint ethVol = pd.ethVolumeLimit();\n    if (curr == maxIACurr) {\n      _transferInvestmentAsset(curr, ms.getLatestAddress(\"P1\"), amount);\n    } else if (curr == \"ETH\" && maxIACurr != \"ETH\") {\n      exchange = Exchange(factory.getExchange(pd.getInvestmentAssetAddress(maxIACurr)));\n      intermediaryEth = exchange.getEthToTokenInputPrice(amount);\n\n\n      if (amount > (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100)) {\n        amount = (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100);\n        // amount = exchange.getEthToTokenInputPrice(intermediaryEth);\n        intermediaryEth = exchange.getEthToTokenInputPrice(amount);\n        trigger = true;\n      }\n\n      erc20 = IERC20(pd.getCurrencyAssetAddress(maxIACurr));\n      if (intermediaryEth > erc20.balanceOf(address(this))) {\n        intermediaryEth = erc20.balanceOf(address(this));\n      }\n      // erc20.decreaseAllowance(address(exchange), erc20.allowance(address(this), address(exchange)));\n      erc20.approve(address(exchange), intermediaryEth);\n      exchange.tokenToEthTransferInput(intermediaryEth, (\n      exchange.getTokenToEthInputPrice(intermediaryEth).mul(995)).div(1000),\n        pd.uniswapDeadline().add(now), address(p1));\n\n    } else if (curr != \"ETH\" && maxIACurr == \"ETH\") {\n      exchange = Exchange(factory.getExchange(pd.getCurrencyAssetAddress(curr)));\n      intermediaryEth = exchange.getTokenToEthInputPrice(amount);\n      if (intermediaryEth > address(this).balance)\n        intermediaryEth = address(this).balance;\n      if (intermediaryEth > (address(exchange).balance.mul\n      (pd.ethVolumeLimit())).div(100)) {// 4% ETH volume limit\n        intermediaryEth = (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100);\n        trigger = true;\n      }\n      exchange.ethToTokenTransferInput.value(intermediaryEth)((exchange.getEthToTokenInputPrice(\n        intermediaryEth).mul(995)).div(1000), pd.uniswapDeadline().add(now), address(p1));\n    } else {\n      address currAdd = pd.getCurrencyAssetAddress(curr);\n      exchange = Exchange(factory.getExchange(currAdd));\n      intermediaryEth = exchange.getTokenToEthInputPrice(amount);\n      if (intermediaryEth > (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100)) {\n        intermediaryEth = (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100);\n        trigger = true;\n      }\n      Exchange tmp = Exchange(factory.getExchange(pd.getInvestmentAssetAddress(maxIACurr)));\n\n      if (intermediaryEth > address(tmp).balance.mul(pd.ethVolumeLimit()).div(100)) {\n        intermediaryEth = address(tmp).balance.mul(pd.ethVolumeLimit()).div(100);\n        // amount = exchange.getEthToTokenInputPrice(intermediaryEth);\n        trigger = true;\n      }\n\n      uint maxIAToSell = tmp.getEthToTokenInputPrice(intermediaryEth);\n\n      erc20 = IERC20(pd.getInvestmentAssetAddress(maxIACurr));\n      uint maxIABal = erc20.balanceOf(address(this));\n      if (maxIAToSell > maxIABal) {\n        maxIAToSell = maxIABal;\n        intermediaryEth = tmp.getTokenToEthInputPrice(maxIAToSell);\n        // amount = exchange.getEthToTokenInputPrice(intermediaryEth);\n      }\n      amount = exchange.getEthToTokenInputPrice(intermediaryEth);\n      erc20.approve(address(tmp), maxIAToSell);\n      tmp.tokenToTokenTransferInput(maxIAToSell, (\n      amount.mul(995)).div(1000), (\n        intermediaryEth), pd.uniswapDeadline().add(now), address(p1), currAdd);\n    }\n  }\n\n  /**\n   * @dev Transfers ERC20 investment asset from this Pool to another Pool.\n   */\n  function _upgradeInvestmentPool(\n    bytes4 _curr,\n    address _newPoolAddress\n  )\n  internal\n  {\n    IERC20 erc20 = IERC20(pd.getInvestmentAssetAddress(_curr));\n    if (erc20.balanceOf(address(this)) > 0)\n      require(erc20.transfer(_newPoolAddress, erc20.balanceOf(address(this))));\n  }\n}\n\n// File: contracts/modules/claims/ClaimsData.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\n\ncontract ClaimsData is Iupgradable {\n  using SafeMath for uint;\n\n  struct Claim {\n    uint coverId;\n    uint dateUpd;\n  }\n\n  struct Vote {\n    address voter;\n    uint tokens;\n    uint claimId;\n    int8 verdict;\n    bool rewardClaimed;\n  }\n\n  struct ClaimsPause {\n    uint coverid;\n    uint dateUpd;\n    bool submit;\n  }\n\n  struct ClaimPauseVoting {\n    uint claimid;\n    uint pendingTime;\n    bool voting;\n  }\n\n  struct RewardDistributed {\n    uint lastCAvoteIndex;\n    uint lastMVvoteIndex;\n\n  }\n\n  struct ClaimRewardDetails {\n    uint percCA;\n    uint percMV;\n    uint tokenToBeDist;\n\n  }\n\n  struct ClaimTotalTokens {\n    uint accept;\n    uint deny;\n  }\n\n  struct ClaimRewardStatus {\n    uint percCA;\n    uint percMV;\n  }\n\n  ClaimRewardStatus[] internal rewardStatus;\n\n  Claim[] internal allClaims;\n  Vote[] internal allvotes;\n  ClaimsPause[] internal claimPause;\n  ClaimPauseVoting[] internal claimPauseVotingEP;\n\n  mapping(address => RewardDistributed) internal voterVoteRewardReceived;\n  mapping(uint => ClaimRewardDetails) internal claimRewardDetail;\n  mapping(uint => ClaimTotalTokens) internal claimTokensCA;\n  mapping(uint => ClaimTotalTokens) internal claimTokensMV;\n  mapping(uint => int8) internal claimVote;\n  mapping(uint => uint) internal claimsStatus;\n  mapping(uint => uint) internal claimState12Count;\n  mapping(uint => uint[]) internal claimVoteCA;\n  mapping(uint => uint[]) internal claimVoteMember;\n  mapping(address => uint[]) internal voteAddressCA;\n  mapping(address => uint[]) internal voteAddressMember;\n  mapping(address => uint[]) internal allClaimsByAddress;\n  mapping(address => mapping(uint => uint)) internal userClaimVoteCA;\n  mapping(address => mapping(uint => uint)) internal userClaimVoteMember;\n  mapping(address => uint) public userClaimVotePausedOn;\n\n  uint internal claimPauseLastsubmit;\n  uint internal claimStartVotingFirstIndex;\n  uint public pendingClaimStart;\n  uint public claimDepositTime;\n  uint public maxVotingTime;\n  uint public minVotingTime;\n  uint public payoutRetryTime;\n  uint public claimRewardPerc;\n  uint public minVoteThreshold;\n  uint public maxVoteThreshold;\n  uint public majorityConsensus;\n  uint public pauseDaysCA;\n\n  event ClaimRaise(\n    uint indexed coverId,\n    address indexed userAddress,\n    uint claimId,\n    uint dateSubmit\n  );\n\n  event VoteCast(\n    address indexed userAddress,\n    uint indexed claimId,\n    bytes4 indexed typeOf,\n    uint tokens,\n    uint submitDate,\n    int8 verdict\n  );\n\n  constructor() public {\n    pendingClaimStart = 1;\n    maxVotingTime = 48 * 1 hours;\n    minVotingTime = 12 * 1 hours;\n    payoutRetryTime = 24 * 1 hours;\n    allvotes.push(Vote(address(0), 0, 0, 0, false));\n    allClaims.push(Claim(0, 0));\n    claimDepositTime = 7 days;\n    claimRewardPerc = 20;\n    minVoteThreshold = 5;\n    maxVoteThreshold = 10;\n    majorityConsensus = 70;\n    pauseDaysCA = 3 days;\n    _addRewardIncentive();\n  }\n\n  /**\n   * @dev Updates the pending claim start variable,\n   * the lowest claim id with a pending decision/payout.\n   */\n  function setpendingClaimStart(uint _start) external onlyInternal {\n    require(pendingClaimStart <= _start);\n    pendingClaimStart = _start;\n  }\n\n  /**\n   * @dev Updates the max vote index for which claim assessor has received reward\n   * @param _voter address of the voter.\n   * @param caIndex last index till which reward was distributed for CA\n   */\n  function setRewardDistributedIndexCA(address _voter, uint caIndex) external onlyInternal {\n    voterVoteRewardReceived[_voter].lastCAvoteIndex = caIndex;\n\n  }\n\n  /**\n   * @dev Used to pause claim assessor activity for 3 days\n   * @param user Member address whose claim voting ability needs to be paused\n   */\n  function setUserClaimVotePausedOn(address user) external {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    userClaimVotePausedOn[user] = now;\n  }\n\n  /**\n   * @dev Updates the max vote index for which member has received reward\n   * @param _voter address of the voter.\n   * @param mvIndex last index till which reward was distributed for member\n   */\n  function setRewardDistributedIndexMV(address _voter, uint mvIndex) external onlyInternal {\n\n    voterVoteRewardReceived[_voter].lastMVvoteIndex = mvIndex;\n  }\n\n  /**\n   * @param claimid claim id.\n   * @param percCA reward Percentage reward for claim assessor\n   * @param percMV reward Percentage reward for members\n   * @param tokens total tokens to be rewarded\n   */\n  function setClaimRewardDetail(\n    uint claimid,\n    uint percCA,\n    uint percMV,\n    uint tokens\n  )\n  external\n  onlyInternal\n  {\n    claimRewardDetail[claimid].percCA = percCA;\n    claimRewardDetail[claimid].percMV = percMV;\n    claimRewardDetail[claimid].tokenToBeDist = tokens;\n  }\n\n  /**\n   * @dev Sets the reward claim status against a vote id.\n   * @param _voteid vote Id.\n   * @param claimed true if reward for vote is claimed, else false.\n   */\n  function setRewardClaimed(uint _voteid, bool claimed) external onlyInternal {\n    allvotes[_voteid].rewardClaimed = claimed;\n  }\n\n  /**\n   * @dev Sets the final vote's result(either accepted or declined)of a claim.\n   * @param _claimId Claim Id.\n   * @param _verdict 1 if claim is accepted,-1 if declined.\n   */\n  function changeFinalVerdict(uint _claimId, int8 _verdict) external onlyInternal {\n    claimVote[_claimId] = _verdict;\n  }\n\n  /**\n   * @dev Creates a new claim.\n   */\n  function addClaim(\n    uint _claimId,\n    uint _coverId,\n    address _from,\n    uint _nowtime\n  )\n  external\n  onlyInternal\n  {\n    allClaims.push(Claim(_coverId, _nowtime));\n    allClaimsByAddress[_from].push(_claimId);\n  }\n\n  /**\n   * @dev Add Vote's details of a given claim.\n   */\n  function addVote(\n    address _voter,\n    uint _tokens,\n    uint claimId,\n    int8 _verdict\n  )\n  external\n  onlyInternal\n  {\n    allvotes.push(Vote(_voter, _tokens, claimId, _verdict, false));\n  }\n\n  /**\n   * @dev Stores the id of the claim assessor vote given to a claim.\n   * Maintains record of all votes given by all the CA to a claim.\n   * @param _claimId Claim Id to which vote has given by the CA.\n   * @param _voteid Vote Id.\n   */\n  function addClaimVoteCA(uint _claimId, uint _voteid) external onlyInternal {\n    claimVoteCA[_claimId].push(_voteid);\n  }\n\n  /**\n   * @dev Sets the id of the vote.\n   * @param _from Claim assessor's address who has given the vote.\n   * @param _claimId Claim Id for which vote has been given by the CA.\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\n   */\n  function setUserClaimVoteCA(\n    address _from,\n    uint _claimId,\n    uint _voteid\n  )\n  external\n  onlyInternal\n  {\n    userClaimVoteCA[_from][_claimId] = _voteid;\n    voteAddressCA[_from].push(_voteid);\n  }\n\n  /**\n   * @dev Stores the tokens locked by the Claim Assessors during voting of a given claim.\n   * @param _claimId Claim Id.\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\n   * -1 for deny and increases the tokens of claim as deny.\n   * @param _tokens Number of tokens.\n   */\n  function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\n    if (_vote == 1)\n      claimTokensCA[_claimId].accept = claimTokensCA[_claimId].accept.add(_tokens);\n    if (_vote == - 1)\n      claimTokensCA[_claimId].deny = claimTokensCA[_claimId].deny.add(_tokens);\n  }\n\n  /**\n   * @dev Stores the tokens locked by the Members during voting of a given claim.\n   * @param _claimId Claim Id.\n   * @param _vote 1 for accept and increases the tokens of claim as accept,\n   * -1 for deny and increases the tokens of claim as deny.\n   * @param _tokens Number of tokens.\n   */\n  function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\n    if (_vote == 1)\n      claimTokensMV[_claimId].accept = claimTokensMV[_claimId].accept.add(_tokens);\n    if (_vote == - 1)\n      claimTokensMV[_claimId].deny = claimTokensMV[_claimId].deny.add(_tokens);\n  }\n\n  /**\n   * @dev Stores the id of the member vote given to a claim.\n   * Maintains record of all votes given by all the Members to a claim.\n   * @param _claimId Claim Id to which vote has been given by the Member.\n   * @param _voteid Vote Id.\n   */\n  function addClaimVotemember(uint _claimId, uint _voteid) external onlyInternal {\n    claimVoteMember[_claimId].push(_voteid);\n  }\n\n  /**\n   * @dev Sets the id of the vote.\n   * @param _from Member's address who has given the vote.\n   * @param _claimId Claim Id for which vote has been given by the Member.\n   * @param _voteid Vote Id which will be stored against the given _from and claimid.\n   */\n  function setUserClaimVoteMember(\n    address _from,\n    uint _claimId,\n    uint _voteid\n  )\n  external\n  onlyInternal\n  {\n    userClaimVoteMember[_from][_claimId] = _voteid;\n    voteAddressMember[_from].push(_voteid);\n\n  }\n\n  /**\n   * @dev Increases the count of failure until payout of a claim is successful.\n   */\n  function updateState12Count(uint _claimId, uint _cnt) external onlyInternal {\n    claimState12Count[_claimId] = claimState12Count[_claimId].add(_cnt);\n  }\n\n  /**\n   * @dev Sets status of a claim.\n   * @param _claimId Claim Id.\n   * @param _stat Status number.\n   */\n  function setClaimStatus(uint _claimId, uint _stat) external onlyInternal {\n    claimsStatus[_claimId] = _stat;\n  }\n\n  /**\n   * @dev Sets the timestamp of a given claim at which the Claim's details has been updated.\n   * @param _claimId Claim Id of claim which has been changed.\n   * @param _dateUpd timestamp at which claim is updated.\n   */\n  function setClaimdateUpd(uint _claimId, uint _dateUpd) external onlyInternal {\n    allClaims[_claimId].dateUpd = _dateUpd;\n  }\n\n  /**\n   @dev Queues Claims during Emergency Pause.\n   */\n  function setClaimAtEmergencyPause(\n    uint _coverId,\n    uint _dateUpd,\n    bool _submit\n  )\n  external\n  onlyInternal\n  {\n    claimPause.push(ClaimsPause(_coverId, _dateUpd, _submit));\n  }\n\n  /**\n   * @dev Set submission flag for Claims queued during emergency pause.\n   * Set to true after EP is turned off and the claim is submitted .\n   */\n  function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external onlyInternal {\n    claimPause[_index].submit = _submit;\n  }\n\n  /**\n   * @dev Sets the index from which claim needs to be\n   * submitted when emergency pause is swithched off.\n   */\n  function setFirstClaimIndexToSubmitAfterEP(\n    uint _firstClaimIndexToSubmit\n  )\n  external\n  onlyInternal\n  {\n    claimPauseLastsubmit = _firstClaimIndexToSubmit;\n  }\n\n  /**\n   * @dev Sets the pending vote duration for a claim in case of emergency pause.\n   */\n  function setPendingClaimDetails(\n    uint _claimId,\n    uint _pendingTime,\n    bool _voting\n  )\n  external\n  onlyInternal\n  {\n    claimPauseVotingEP.push(ClaimPauseVoting(_claimId, _pendingTime, _voting));\n  }\n\n  /**\n   * @dev Sets voting flag true after claim is reopened for voting after emergency pause.\n   */\n  function setPendingClaimVoteStatus(uint _claimId, bool _vote) external onlyInternal {\n    claimPauseVotingEP[_claimId].voting = _vote;\n  }\n\n  /**\n   * @dev Sets the index from which claim needs to be\n   * reopened when emergency pause is swithched off.\n   */\n  function setFirstClaimIndexToStartVotingAfterEP(\n    uint _claimStartVotingFirstIndex\n  )\n  external\n  onlyInternal\n  {\n    claimStartVotingFirstIndex = _claimStartVotingFirstIndex;\n  }\n\n  /**\n   * @dev Calls Vote Event.\n   */\n  function callVoteEvent(\n    address _userAddress,\n    uint _claimId,\n    bytes4 _typeOf,\n    uint _tokens,\n    uint _submitDate,\n    int8 _verdict\n  )\n  external\n  onlyInternal\n  {\n    emit VoteCast(\n      _userAddress,\n      _claimId,\n      _typeOf,\n      _tokens,\n      _submitDate,\n      _verdict\n    );\n  }\n\n  /**\n   * @dev Calls Claim Event.\n   */\n  function callClaimEvent(\n    uint _coverId,\n    address _userAddress,\n    uint _claimId,\n    uint _datesubmit\n  )\n  external\n  onlyInternal\n  {\n    emit ClaimRaise(_coverId, _userAddress, _claimId, _datesubmit);\n  }\n\n  /**\n   * @dev Gets Uint Parameters by parameter code\n   * @param code whose details we want\n   * @return string value of the parameter\n   * @return associated amount (time or perc or value) to the code\n   */\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\n    codeVal = code;\n    if (code == \"CAMAXVT\") {\n      val = maxVotingTime / (1 hours);\n\n    } else if (code == \"CAMINVT\") {\n\n      val = minVotingTime / (1 hours);\n\n    } else if (code == \"CAPRETRY\") {\n\n      val = payoutRetryTime / (1 hours);\n\n    } else if (code == \"CADEPT\") {\n\n      val = claimDepositTime / (1 days);\n\n    } else if (code == \"CAREWPER\") {\n\n      val = claimRewardPerc;\n\n    } else if (code == \"CAMINTH\") {\n\n      val = minVoteThreshold;\n\n    } else if (code == \"CAMAXTH\") {\n\n      val = maxVoteThreshold;\n\n    } else if (code == \"CACONPER\") {\n\n      val = majorityConsensus;\n\n    } else if (code == \"CAPAUSET\") {\n      val = pauseDaysCA / (1 days);\n    }\n\n  }\n\n  /**\n   * @dev Get claim queued during emergency pause by index.\n   */\n  function getClaimOfEmergencyPauseByIndex(\n    uint _index\n  )\n  external\n  view\n  returns (\n    uint coverId,\n    uint dateUpd,\n    bool submit\n  )\n  {\n    coverId = claimPause[_index].coverid;\n    dateUpd = claimPause[_index].dateUpd;\n    submit = claimPause[_index].submit;\n  }\n\n  /**\n   * @dev Gets the Claim's details of given claimid.\n   */\n  function getAllClaimsByIndex(\n    uint _claimId\n  )\n  external\n  view\n  returns (\n    uint coverId,\n    int8 vote,\n    uint status,\n    uint dateUpd,\n    uint state12Count\n  )\n  {\n    return (\n    allClaims[_claimId].coverId,\n    claimVote[_claimId],\n    claimsStatus[_claimId],\n    allClaims[_claimId].dateUpd,\n    claimState12Count[_claimId]\n    );\n  }\n\n  /**\n   * @dev Gets the vote id of a given claim of a given Claim Assessor.\n   */\n  function getUserClaimVoteCA(\n    address _add,\n    uint _claimId\n  )\n  external\n  view\n  returns (uint idVote)\n  {\n    return userClaimVoteCA[_add][_claimId];\n  }\n\n  /**\n   * @dev Gets the vote id of a given claim of a given member.\n   */\n  function getUserClaimVoteMember(\n    address _add,\n    uint _claimId\n  )\n  external\n  view\n  returns (uint idVote)\n  {\n    return userClaimVoteMember[_add][_claimId];\n  }\n\n  /**\n   * @dev Gets the count of all votes.\n   */\n  function getAllVoteLength() external view returns (uint voteCount) {\n    return allvotes.length.sub(1); // Start Index always from 1.\n  }\n\n  /**\n   * @dev Gets the status number of a given claim.\n   * @param _claimId Claim id.\n   * @return statno Status Number.\n   */\n  function getClaimStatusNumber(uint _claimId) external view returns (uint claimId, uint statno) {\n    return (_claimId, claimsStatus[_claimId]);\n  }\n\n  /**\n   * @dev Gets the reward percentage to be distributed for a given status id\n   * @param statusNumber the number of type of status\n   * @return percCA reward Percentage for claim assessor\n   * @return percMV reward Percentage for members\n   */\n  function getRewardStatus(uint statusNumber) external view returns (uint percCA, uint percMV) {\n    return (rewardStatus[statusNumber].percCA, rewardStatus[statusNumber].percMV);\n  }\n\n  /**\n   * @dev Gets the number of tries that have been made for a successful payout of a Claim.\n   */\n  function getClaimState12Count(uint _claimId) external view returns (uint num) {\n    num = claimState12Count[_claimId];\n  }\n\n  /**\n   * @dev Gets the last update date of a claim.\n   */\n  function getClaimDateUpd(uint _claimId) external view returns (uint dateupd) {\n    dateupd = allClaims[_claimId].dateUpd;\n  }\n\n  /**\n   * @dev Gets all Claims created by a user till date.\n   * @param _member user's address.\n   * @return claimarr List of Claims id.\n   */\n  function getAllClaimsByAddress(address _member) external view returns (uint[] memory claimarr) {\n    return allClaimsByAddress[_member];\n  }\n\n  /**\n   * @dev Gets the number of tokens that has been locked\n   * while giving vote to a claim by  Claim Assessors.\n   * @param _claimId Claim Id.\n   * @return accept Total number of tokens when CA accepts the claim.\n   * @return deny Total number of tokens when CA declines the claim.\n   */\n  function getClaimsTokenCA(\n    uint _claimId\n  )\n  external\n  view\n  returns (\n    uint claimId,\n    uint accept,\n    uint deny\n  )\n  {\n    return (\n    _claimId,\n    claimTokensCA[_claimId].accept,\n    claimTokensCA[_claimId].deny\n    );\n  }\n\n  /**\n   * @dev Gets the number of tokens that have been\n   * locked while assessing a claim as a member.\n   * @param _claimId Claim Id.\n   * @return accept Total number of tokens in acceptance of the claim.\n   * @return deny Total number of tokens against the claim.\n   */\n  function getClaimsTokenMV(\n    uint _claimId\n  )\n  external\n  view\n  returns (\n    uint claimId,\n    uint accept,\n    uint deny\n  )\n  {\n    return (\n    _claimId,\n    claimTokensMV[_claimId].accept,\n    claimTokensMV[_claimId].deny\n    );\n  }\n\n  /**\n   * @dev Gets the total number of votes cast as Claims assessor for/against a given claim\n   */\n  function getCaClaimVotesToken(uint _claimId) external view returns (uint claimId, uint cnt) {\n    claimId = _claimId;\n    cnt = 0;\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\n      cnt = cnt.add(allvotes[claimVoteCA[_claimId][i]].tokens);\n    }\n  }\n\n  /**\n   * @dev Gets the total number of tokens cast as a member for/against a given claim\n   */\n  function getMemberClaimVotesToken(\n    uint _claimId\n  )\n  external\n  view\n  returns (uint claimId, uint cnt)\n  {\n    claimId = _claimId;\n    cnt = 0;\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\n      cnt = cnt.add(allvotes[claimVoteMember[_claimId][i]].tokens);\n    }\n  }\n\n  /**\n   * @dev Provides information of a vote when given its vote id.\n   * @param _voteid Vote Id.\n   */\n  function getVoteDetails(uint _voteid)\n  external view\n  returns (\n    uint tokens,\n    uint claimId,\n    int8 verdict,\n    bool rewardClaimed\n  )\n  {\n    return (\n    allvotes[_voteid].tokens,\n    allvotes[_voteid].claimId,\n    allvotes[_voteid].verdict,\n    allvotes[_voteid].rewardClaimed\n    );\n  }\n\n  /**\n   * @dev Gets the voter's address of a given vote id.\n   */\n  function getVoterVote(uint _voteid) external view returns (address voter) {\n    return allvotes[_voteid].voter;\n  }\n\n  /**\n   * @dev Provides information of a Claim when given its claim id.\n   * @param _claimId Claim Id.\n   */\n  function getClaim(\n    uint _claimId\n  )\n  external\n  view\n  returns (\n    uint claimId,\n    uint coverId,\n    int8 vote,\n    uint status,\n    uint dateUpd,\n    uint state12Count\n  )\n  {\n    return (\n    _claimId,\n    allClaims[_claimId].coverId,\n    claimVote[_claimId],\n    claimsStatus[_claimId],\n    allClaims[_claimId].dateUpd,\n    claimState12Count[_claimId]\n    );\n  }\n\n  /**\n   * @dev Gets the total number of votes of a given claim.\n   * @param _claimId Claim Id.\n   * @param _ca if 1: votes given by Claim Assessors to a claim,\n   * else returns the number of votes of given by Members to a claim.\n   * @return len total number of votes for/against a given claim.\n   */\n  function getClaimVoteLength(\n    uint _claimId,\n    uint8 _ca\n  )\n  external\n  view\n  returns (uint claimId, uint len)\n  {\n    claimId = _claimId;\n    if (_ca == 1)\n      len = claimVoteCA[_claimId].length;\n    else\n      len = claimVoteMember[_claimId].length;\n  }\n\n  /**\n   * @dev Gets the verdict of a vote using claim id and index.\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\n   * @return ver 1 if vote was given in favour,-1 if given in against.\n   */\n  function getVoteVerdict(\n    uint _claimId,\n    uint _index,\n    uint8 _ca\n  )\n  external\n  view\n  returns (int8 ver)\n  {\n    if (_ca == 1)\n      ver = allvotes[claimVoteCA[_claimId][_index]].verdict;\n    else\n      ver = allvotes[claimVoteMember[_claimId][_index]].verdict;\n  }\n\n  /**\n   * @dev Gets the Number of tokens of a vote using claim id and index.\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\n   * @return tok Number of tokens.\n   */\n  function getVoteToken(\n    uint _claimId,\n    uint _index,\n    uint8 _ca\n  )\n  external\n  view\n  returns (uint tok)\n  {\n    if (_ca == 1)\n      tok = allvotes[claimVoteCA[_claimId][_index]].tokens;\n    else\n      tok = allvotes[claimVoteMember[_claimId][_index]].tokens;\n  }\n\n  /**\n   * @dev Gets the Voter's address of a vote using claim id and index.\n   * @param _ca 1 for vote given as a CA, else for vote given as a member.\n   * @return voter Voter's address.\n   */\n  function getVoteVoter(\n    uint _claimId,\n    uint _index,\n    uint8 _ca\n  )\n  external\n  view\n  returns (address voter)\n  {\n    if (_ca == 1)\n      voter = allvotes[claimVoteCA[_claimId][_index]].voter;\n    else\n      voter = allvotes[claimVoteMember[_claimId][_index]].voter;\n  }\n\n  /**\n   * @dev Gets total number of Claims created by a user till date.\n   * @param _add User's address.\n   */\n  function getUserClaimCount(address _add) external view returns (uint len) {\n    len = allClaimsByAddress[_add].length;\n  }\n\n  /**\n   * @dev Calculates number of Claims that are in pending state.\n   */\n  function getClaimLength() external view returns (uint len) {\n    len = allClaims.length.sub(pendingClaimStart);\n  }\n\n  /**\n   * @dev Gets the Number of all the Claims created till date.\n   */\n  function actualClaimLength() external view returns (uint len) {\n    len = allClaims.length;\n  }\n\n  /**\n   * @dev Gets details of a claim.\n   * @param _index claim id = pending claim start + given index\n   * @param _add User's address.\n   * @return coverid cover against which claim has been submitted.\n   * @return claimId Claim  Id.\n   * @return voteCA verdict of vote given as a Claim Assessor.\n   * @return voteMV verdict of vote given as a Member.\n   * @return statusnumber Status of claim.\n   */\n  function getClaimFromNewStart(\n    uint _index,\n    address _add\n  )\n  external\n  view\n  returns (\n    uint coverid,\n    uint claimId,\n    int8 voteCA,\n    int8 voteMV,\n    uint statusnumber\n  )\n  {\n    uint i = pendingClaimStart.add(_index);\n    coverid = allClaims[i].coverId;\n    claimId = i;\n    if (userClaimVoteCA[_add][i] > 0)\n      voteCA = allvotes[userClaimVoteCA[_add][i]].verdict;\n    else\n      voteCA = 0;\n\n    if (userClaimVoteMember[_add][i] > 0)\n      voteMV = allvotes[userClaimVoteMember[_add][i]].verdict;\n    else\n      voteMV = 0;\n\n    statusnumber = claimsStatus[i];\n  }\n\n  /**\n   * @dev Gets details of a claim of a user at a given index.\n   */\n  function getUserClaimByIndex(\n    uint _index,\n    address _add\n  )\n  external\n  view\n  returns (\n    uint status,\n    uint coverid,\n    uint claimId\n  )\n  {\n    claimId = allClaimsByAddress[_add][_index];\n    status = claimsStatus[claimId];\n    coverid = allClaims[claimId].coverId;\n  }\n\n  /**\n   * @dev Gets Id of all the votes given to a claim.\n   * @param _claimId Claim Id.\n   * @return ca id of all the votes given by Claim assessors to a claim.\n   * @return mv id of all the votes given by members to a claim.\n   */\n  function getAllVotesForClaim(\n    uint _claimId\n  )\n  external\n  view\n  returns (\n    uint claimId,\n    uint[] memory ca,\n    uint[] memory mv\n  )\n  {\n    return (_claimId, claimVoteCA[_claimId], claimVoteMember[_claimId]);\n  }\n\n  /**\n   * @dev Gets Number of tokens deposit in a vote using\n   * Claim assessor's address and claim id.\n   * @return tokens Number of deposited tokens.\n   */\n  function getTokensClaim(\n    address _of,\n    uint _claimId\n  )\n  external\n  view\n  returns (\n    uint claimId,\n    uint tokens\n  )\n  {\n    return (_claimId, allvotes[userClaimVoteCA[_of][_claimId]].tokens);\n  }\n\n  /**\n   * @param _voter address of the voter.\n   * @return lastCAvoteIndex last index till which reward was distributed for CA\n   * @return lastMVvoteIndex last index till which reward was distributed for member\n   */\n  function getRewardDistributedIndex(\n    address _voter\n  )\n  external\n  view\n  returns (\n    uint lastCAvoteIndex,\n    uint lastMVvoteIndex\n  )\n  {\n    return (\n    voterVoteRewardReceived[_voter].lastCAvoteIndex,\n    voterVoteRewardReceived[_voter].lastMVvoteIndex\n    );\n  }\n\n  /**\n   * @param claimid claim id.\n   * @return perc_CA reward Percentage for claim assessor\n   * @return perc_MV reward Percentage for members\n   * @return tokens total tokens to be rewarded\n   */\n  function getClaimRewardDetail(\n    uint claimid\n  )\n  external\n  view\n  returns (\n    uint percCA,\n    uint percMV,\n    uint tokens\n  )\n  {\n    return (\n    claimRewardDetail[claimid].percCA,\n    claimRewardDetail[claimid].percMV,\n    claimRewardDetail[claimid].tokenToBeDist\n    );\n  }\n\n  /**\n   * @dev Gets cover id of a claim.\n   */\n  function getClaimCoverId(uint _claimId) external view returns (uint claimId, uint coverid) {\n    return (_claimId, allClaims[_claimId].coverId);\n  }\n\n  /**\n   * @dev Gets total number of tokens staked during voting by Claim Assessors.\n   * @param _claimId Claim Id.\n   * @param _verdict 1 to get total number of accept tokens, -1 to get total number of deny tokens.\n   * @return token token Number of tokens(either accept or deny on the basis of verdict given as parameter).\n   */\n  function getClaimVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\n    claimId = _claimId;\n    token = 0;\n    for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\n      if (allvotes[claimVoteCA[_claimId][i]].verdict == _verdict)\n        token = token.add(allvotes[claimVoteCA[_claimId][i]].tokens);\n    }\n  }\n\n  /**\n   * @dev Gets total number of tokens staked during voting by Members.\n   * @param _claimId Claim Id.\n   * @param _verdict 1 to get total number of accept tokens,\n   *  -1 to get total number of deny tokens.\n   * @return token token Number of tokens(either accept or\n   * deny on the basis of verdict given as parameter).\n   */\n  function getClaimMVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token) {\n    claimId = _claimId;\n    token = 0;\n    for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\n      if (allvotes[claimVoteMember[_claimId][i]].verdict == _verdict)\n        token = token.add(allvotes[claimVoteMember[_claimId][i]].tokens);\n    }\n  }\n\n  /**\n   * @param _voter address  of voteid\n   * @param index index to get voteid in CA\n   */\n  function getVoteAddressCA(address _voter, uint index) external view returns (uint) {\n    return voteAddressCA[_voter][index];\n  }\n\n  /**\n   * @param _voter address  of voter\n   * @param index index to get voteid in member vote\n   */\n  function getVoteAddressMember(address _voter, uint index) external view returns (uint) {\n    return voteAddressMember[_voter][index];\n  }\n\n  /**\n   * @param _voter address  of voter\n   */\n  function getVoteAddressCALength(address _voter) external view returns (uint) {\n    return voteAddressCA[_voter].length;\n  }\n\n  /**\n   * @param _voter address  of voter\n   */\n  function getVoteAddressMemberLength(address _voter) external view returns (uint) {\n    return voteAddressMember[_voter].length;\n  }\n\n  /**\n   * @dev Gets the Final result of voting of a claim.\n   * @param _claimId Claim id.\n   * @return verdict 1 if claim is accepted, -1 if declined.\n   */\n  function getFinalVerdict(uint _claimId) external view returns (int8 verdict) {\n    return claimVote[_claimId];\n  }\n\n  /**\n   * @dev Get number of Claims queued for submission during emergency pause.\n   */\n  function getLengthOfClaimSubmittedAtEP() external view returns (uint len) {\n    len = claimPause.length;\n  }\n\n  /**\n   * @dev Gets the index from which claim needs to be\n   * submitted when emergency pause is swithched off.\n   */\n  function getFirstClaimIndexToSubmitAfterEP() external view returns (uint indexToSubmit) {\n    indexToSubmit = claimPauseLastsubmit;\n  }\n\n  /**\n   * @dev Gets number of Claims to be reopened for voting post emergency pause period.\n   */\n  function getLengthOfClaimVotingPause() external view returns (uint len) {\n    len = claimPauseVotingEP.length;\n  }\n\n  /**\n   * @dev Gets claim details to be reopened for voting after emergency pause.\n   */\n  function getPendingClaimDetailsByIndex(\n    uint _index\n  )\n  external\n  view\n  returns (\n    uint claimId,\n    uint pendingTime,\n    bool voting\n  )\n  {\n    claimId = claimPauseVotingEP[_index].claimid;\n    pendingTime = claimPauseVotingEP[_index].pendingTime;\n    voting = claimPauseVotingEP[_index].voting;\n  }\n\n  /**\n   * @dev Gets the index from which claim needs to be reopened when emergency pause is swithched off.\n   */\n  function getFirstClaimIndexToStartVotingAfterEP() external view returns (uint firstindex) {\n    firstindex = claimStartVotingFirstIndex;\n  }\n\n  /**\n   * @dev Updates Uint Parameters of a code\n   * @param code whose details we want to update\n   * @param val value to set\n   */\n  function updateUintParameters(bytes8 code, uint val) public {\n    require(ms.checkIsAuthToGoverned(msg.sender));\n    if (code == \"CAMAXVT\") {\n      _setMaxVotingTime(val * 1 hours);\n\n    } else if (code == \"CAMINVT\") {\n\n      _setMinVotingTime(val * 1 hours);\n\n    } else if (code == \"CAPRETRY\") {\n\n      _setPayoutRetryTime(val * 1 hours);\n\n    } else if (code == \"CADEPT\") {\n\n      _setClaimDepositTime(val * 1 days);\n\n    } else if (code == \"CAREWPER\") {\n\n      _setClaimRewardPerc(val);\n\n    } else if (code == \"CAMINTH\") {\n\n      _setMinVoteThreshold(val);\n\n    } else if (code == \"CAMAXTH\") {\n\n      _setMaxVoteThreshold(val);\n\n    } else if (code == \"CACONPER\") {\n\n      _setMajorityConsensus(val);\n\n    } else if (code == \"CAPAUSET\") {\n      _setPauseDaysCA(val * 1 days);\n    } else {\n\n      revert(\"Invalid param code\");\n    }\n\n  }\n\n  /**\n   * @dev Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public onlyInternal {}\n\n  /**\n   * @dev Adds status under which a claim can lie.\n   * @param percCA reward percentage for claim assessor\n   * @param percMV reward percentage for members\n   */\n  function _pushStatus(uint percCA, uint percMV) internal {\n    rewardStatus.push(ClaimRewardStatus(percCA, percMV));\n  }\n\n  /**\n   * @dev adds reward incentive for all possible claim status for Claim assessors and members\n   */\n  function _addRewardIncentive() internal {\n    _pushStatus(0, 0); // 0  Pending-Claim Assessor Vote\n    _pushStatus(0, 0); // 1 Pending-Claim Assessor Vote Denied, Pending Member Vote\n    _pushStatus(0, 0); // 2 Pending-CA Vote Threshold not Reached Accept, Pending Member Vote\n    _pushStatus(0, 0); // 3 Pending-CA Vote Threshold not Reached Deny, Pending Member Vote\n    _pushStatus(0, 0); // 4 Pending-CA Consensus not reached Accept, Pending Member Vote\n    _pushStatus(0, 0); // 5 Pending-CA Consensus not reached Deny, Pending Member Vote\n    _pushStatus(100, 0); // 6 Final-Claim Assessor Vote Denied\n    _pushStatus(100, 0); // 7 Final-Claim Assessor Vote Accepted\n    _pushStatus(0, 100); // 8 Final-Claim Assessor Vote Denied, MV Accepted\n    _pushStatus(0, 100); // 9 Final-Claim Assessor Vote Denied, MV Denied\n    _pushStatus(0, 0); // 10 Final-Claim Assessor Vote Accept, MV Nodecision\n    _pushStatus(0, 0); // 11 Final-Claim Assessor Vote Denied, MV Nodecision\n    _pushStatus(0, 0); // 12 Claim Accepted Payout Pending\n    _pushStatus(0, 0); // 13 Claim Accepted No Payout\n    _pushStatus(0, 0); // 14 Claim Accepted Payout Done\n  }\n\n  /**\n   * @dev Sets Maximum time(in seconds) for which claim assessment voting is open\n   */\n  function _setMaxVotingTime(uint _time) internal {\n    maxVotingTime = _time;\n  }\n\n  /**\n   *  @dev Sets Minimum time(in seconds) for which claim assessment voting is open\n   */\n  function _setMinVotingTime(uint _time) internal {\n    minVotingTime = _time;\n  }\n\n  /**\n   *  @dev Sets Minimum vote threshold required\n   */\n  function _setMinVoteThreshold(uint val) internal {\n    minVoteThreshold = val;\n  }\n\n  /**\n   *  @dev Sets Maximum vote threshold required\n   */\n  function _setMaxVoteThreshold(uint val) internal {\n    maxVoteThreshold = val;\n  }\n\n  /**\n   *  @dev Sets the value considered as Majority Consenus in voting\n   */\n  function _setMajorityConsensus(uint val) internal {\n    majorityConsensus = val;\n  }\n\n  /**\n   * @dev Sets the payout retry time\n   */\n  function _setPayoutRetryTime(uint _time) internal {\n    payoutRetryTime = _time;\n  }\n\n  /**\n   *  @dev Sets percentage of reward given for claim assessment\n   */\n  function _setClaimRewardPerc(uint _val) internal {\n\n    claimRewardPerc = _val;\n  }\n\n  /**\n   * @dev Sets the time for which claim is deposited.\n   */\n  function _setClaimDepositTime(uint _time) internal {\n\n    claimDepositTime = _time;\n  }\n\n  /**\n   *  @dev Sets number of days claim assessment will be paused\n   */\n  function _setPauseDaysCA(uint val) internal {\n    pauseDaysCA = val;\n  }\n}\n\n// File: contracts/modules/claims/Claims.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n\n\ncontract Claims is Iupgradable {\n  using SafeMath for uint;\n\n\n  TokenFunctions internal tf;\n  NXMToken internal tk;\n  TokenController internal tc;\n  ClaimsReward internal cr;\n  Pool1 internal p1;\n  ClaimsData internal cd;\n  TokenData internal td;\n  PoolData internal pd;\n  Pool2 internal p2;\n  QuotationData internal qd;\n  MCR internal m1;\n\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\n\n  /**\n   * @dev Sets the status of claim using claim id.\n   * @param claimId claim id.\n   * @param stat status to be set.\n   */\n  function setClaimStatus(uint claimId, uint stat) external onlyInternal {\n    _setClaimStatus(claimId, stat);\n  }\n\n  /**\n   * @dev Gets claim details of claim id = pending claim start + given index\n   */\n  function getClaimFromNewStart(\n    uint index\n  )\n  external\n  view\n  returns (\n    uint coverId,\n    uint claimId,\n    int8 voteCA,\n    int8 voteMV,\n    uint statusnumber\n  )\n  {\n    (coverId, claimId, voteCA, voteMV, statusnumber) = cd.getClaimFromNewStart(index, msg.sender);\n    // status = rewardStatus[statusnumber].claimStatusDesc;\n  }\n\n  /**\n   * @dev Gets details of a claim submitted by the calling user, at a given index\n   */\n  function getUserClaimByIndex(\n    uint index\n  )\n  external\n  view\n  returns (\n    uint status,\n    uint coverId,\n    uint claimId\n  )\n  {\n    uint statusno;\n    (statusno, coverId, claimId) = cd.getUserClaimByIndex(index, msg.sender);\n    status = statusno;\n  }\n\n  /**\n   * @dev Gets details of a given claim id.\n   * @param _claimId Claim Id.\n   * @return status Current status of claim id\n   * @return finalVerdict Decision made on the claim, 1 -> acceptance, -1 -> denial\n   * @return claimOwner Address through which claim is submitted\n   * @return coverId Coverid associated with the claim id\n   */\n  function getClaimbyIndex(uint _claimId) external view returns (\n    uint claimId,\n    uint status,\n    int8 finalVerdict,\n    address claimOwner,\n    uint coverId\n  )\n  {\n    uint stat;\n    claimId = _claimId;\n    (, coverId, finalVerdict, stat,,) = cd.getClaim(_claimId);\n    claimOwner = qd.getCoverMemberAddress(coverId);\n    status = stat;\n  }\n\n  /**\n   * @dev Calculates total amount that has been used to assess a claim.\n   * Computaion:Adds acceptCA(tokens used for voting in favor of a claim)\n   * denyCA(tokens used for voting against a claim) *  current token price.\n   * @param claimId Claim Id.\n   * @param member Member type 0 -> Claim Assessors, else members.\n   * @return tokens Total Amount used in Claims assessment.\n   */\n  function getCATokens(uint claimId, uint member) external view returns (uint tokens) {\n    uint coverId;\n    (, coverId) = cd.getClaimCoverId(claimId);\n    bytes4 curr = qd.getCurrencyOfCover(coverId);\n    uint tokenx1e18 = m1.calculateTokenPrice(curr);\n    uint accept;\n    uint deny;\n    if (member == 0) {\n      (, accept, deny) = cd.getClaimsTokenCA(claimId);\n    } else {\n      (, accept, deny) = cd.getClaimsTokenMV(claimId);\n    }\n    tokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18); // amount (not in tokens)\n  }\n\n  /**\n   * Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public onlyInternal {\n    tk = NXMToken(ms.tokenAddress());\n    td = TokenData(ms.getLatestAddress(\"TD\"));\n    tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\n    tc = TokenController(ms.getLatestAddress(\"TC\"));\n    p1 = Pool1(ms.getLatestAddress(\"P1\"));\n    p2 = Pool2(ms.getLatestAddress(\"P2\"));\n    pd = PoolData(ms.getLatestAddress(\"PD\"));\n    cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\n    cd = ClaimsData(ms.getLatestAddress(\"CD\"));\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\n    m1 = MCR(ms.getLatestAddress(\"MC\"));\n  }\n\n  /**\n   * @dev Updates the pending claim start variable,\n   * the lowest claim id with a pending decision/payout.\n   */\n  function changePendingClaimStart() public onlyInternal {\n\n    uint origstat;\n    uint state12Count;\n    uint pendingClaimStart = cd.pendingClaimStart();\n    uint actualClaimLength = cd.actualClaimLength();\n    for (uint i = pendingClaimStart; i < actualClaimLength; i++) {\n      (, , , origstat, , state12Count) = cd.getClaim(i);\n\n      if (origstat > 5 && ((origstat != 12) || (origstat == 12 && state12Count >= 60)))\n        cd.setpendingClaimStart(i);\n      else\n        break;\n    }\n  }\n\n  /**\n   * @dev Submits a claim for a given cover note.\n   * Adds claim to queue incase of emergency pause else directly submits the claim.\n   * @param coverId Cover Id.\n   */\n  function submitClaim(uint coverId) public {\n    address qadd = qd.getCoverMemberAddress(coverId);\n    require(qadd == msg.sender);\n    uint8 cStatus;\n    (, cStatus,,,) = qd.getCoverDetailsByCoverID2(coverId);\n    require(cStatus != uint8(QuotationData.CoverStatus.ClaimSubmitted), \"Claim already submitted\");\n    require(cStatus != uint8(QuotationData.CoverStatus.CoverExpired), \"Cover already expired\");\n    if (ms.isPause() == false) {\n      _addClaim(coverId, now, qadd);\n    } else {\n      cd.setClaimAtEmergencyPause(coverId, now, false);\n      qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.Requested));\n    }\n  }\n\n  /**\n   * @dev Submits the Claims queued once the emergency pause is switched off.\n   */\n  function submitClaimAfterEPOff() public onlyInternal {\n    uint lengthOfClaimSubmittedAtEP = cd.getLengthOfClaimSubmittedAtEP();\n    uint firstClaimIndexToSubmitAfterEP = cd.getFirstClaimIndexToSubmitAfterEP();\n    uint coverId;\n    uint dateUpd;\n    bool submit;\n    address qadd;\n    for (uint i = firstClaimIndexToSubmitAfterEP; i < lengthOfClaimSubmittedAtEP; i++) {\n      (coverId, dateUpd, submit) = cd.getClaimOfEmergencyPauseByIndex(i);\n      require(submit == false);\n      qadd = qd.getCoverMemberAddress(coverId);\n      _addClaim(coverId, dateUpd, qadd);\n      cd.setClaimSubmittedAtEPTrue(i, true);\n    }\n    cd.setFirstClaimIndexToSubmitAfterEP(lengthOfClaimSubmittedAtEP);\n  }\n\n  /**\n   * @dev Castes vote for members who have tokens locked under Claims Assessment\n   * @param claimId  claim id.\n   * @param verdict 1 for Accept,-1 for Deny.\n   */\n  function submitCAVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\n    require(checkVoteClosing(claimId) != 1);\n    require(cd.userClaimVotePausedOn(msg.sender).add(cd.pauseDaysCA()) < now);\n    uint tokens = tc.tokensLockedAtTime(msg.sender, \"CLA\", now.add(cd.claimDepositTime()));\n    require(tokens > 0);\n    uint stat;\n    (, stat) = cd.getClaimStatusNumber(claimId);\n    require(stat == 0);\n    require(cd.getUserClaimVoteCA(msg.sender, claimId) == 0);\n    td.bookCATokens(msg.sender);\n    cd.addVote(msg.sender, tokens, claimId, verdict);\n    cd.callVoteEvent(msg.sender, claimId, \"CAV\", tokens, now, verdict);\n    uint voteLength = cd.getAllVoteLength();\n    cd.addClaimVoteCA(claimId, voteLength);\n    cd.setUserClaimVoteCA(msg.sender, claimId, voteLength);\n    cd.setClaimTokensCA(claimId, verdict, tokens);\n    tc.extendLockOf(msg.sender, \"CLA\", td.lockCADays());\n    int close = checkVoteClosing(claimId);\n    if (close == 1) {\n      cr.changeClaimStatus(claimId);\n    }\n  }\n\n  /**\n   * @dev Submits a member vote for assessing a claim.\n   * Tokens other than those locked under Claims\n   * Assessment can be used to cast a vote for a given claim id.\n   * @param claimId Selected claim id.\n   * @param verdict 1 for Accept,-1 for Deny.\n   */\n  function submitMemberVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\n    require(checkVoteClosing(claimId) != 1);\n    uint stat;\n    uint tokens = tc.totalBalanceOf(msg.sender);\n    (, stat) = cd.getClaimStatusNumber(claimId);\n    require(stat >= 1 && stat <= 5);\n    require(cd.getUserClaimVoteMember(msg.sender, claimId) == 0);\n    cd.addVote(msg.sender, tokens, claimId, verdict);\n    cd.callVoteEvent(msg.sender, claimId, \"MV\", tokens, now, verdict);\n    tc.lockForMemberVote(msg.sender, td.lockMVDays());\n    uint voteLength = cd.getAllVoteLength();\n    cd.addClaimVotemember(claimId, voteLength);\n    cd.setUserClaimVoteMember(msg.sender, claimId, voteLength);\n    cd.setClaimTokensMV(claimId, verdict, tokens);\n    int close = checkVoteClosing(claimId);\n    if (close == 1) {\n      cr.changeClaimStatus(claimId);\n    }\n  }\n\n  /**\n  * @dev Pause Voting of All Pending Claims when Emergency Pause Start.\n  */\n  function pauseAllPendingClaimsVoting() public onlyInternal {\n    uint firstIndex = cd.pendingClaimStart();\n    uint actualClaimLength = cd.actualClaimLength();\n    for (uint i = firstIndex; i < actualClaimLength; i++) {\n      if (checkVoteClosing(i) == 0) {\n        uint dateUpd = cd.getClaimDateUpd(i);\n        cd.setPendingClaimDetails(i, (dateUpd.add(cd.maxVotingTime())).sub(now), false);\n      }\n    }\n  }\n\n  /**\n   * @dev Resume the voting phase of all Claims paused due to an emergency pause.\n   */\n  function startAllPendingClaimsVoting() public onlyInternal {\n    uint firstIndx = cd.getFirstClaimIndexToStartVotingAfterEP();\n    uint i;\n    uint lengthOfClaimVotingPause = cd.getLengthOfClaimVotingPause();\n    for (i = firstIndx; i < lengthOfClaimVotingPause; i++) {\n      uint pendingTime;\n      uint claimID;\n      (claimID, pendingTime,) = cd.getPendingClaimDetailsByIndex(i);\n      uint pTime = (now.sub(cd.maxVotingTime())).add(pendingTime);\n      cd.setClaimdateUpd(claimID, pTime);\n      cd.setPendingClaimVoteStatus(i, true);\n      uint coverid;\n      (, coverid) = cd.getClaimCoverId(claimID);\n      address qadd = qd.getCoverMemberAddress(coverid);\n      tf.extendCNEPOff(qadd, coverid, pendingTime.add(cd.claimDepositTime()));\n      p1.closeClaimsOraclise(claimID, uint64(pTime));\n    }\n    cd.setFirstClaimIndexToStartVotingAfterEP(i);\n  }\n\n  /**\n   * @dev Checks if voting of a claim should be closed or not.\n   * @param claimId Claim Id.\n   * @return close 1 -> voting should be closed, 0 -> if voting should not be closed,\n   * -1 -> voting has already been closed.\n   */\n  function checkVoteClosing(uint claimId) public view returns (int8 close) {\n    close = 0;\n    uint status;\n    (, status) = cd.getClaimStatusNumber(claimId);\n    uint dateUpd = cd.getClaimDateUpd(claimId);\n    if (status == 12 && dateUpd.add(cd.payoutRetryTime()) < now) {\n      if (cd.getClaimState12Count(claimId) < 60)\n        close = 1;\n    }\n\n    if (status > 5 && status != 12) {\n      close = - 1;\n    } else if (status != 12 && dateUpd.add(cd.maxVotingTime()) <= now) {\n      close = 1;\n    } else if (status != 12 && dateUpd.add(cd.minVotingTime()) >= now) {\n      close = 0;\n    } else if (status == 0 || (status >= 1 && status <= 5)) {\n      close = _checkVoteClosingFinal(claimId, status);\n    }\n\n  }\n\n  /**\n   * @dev Checks if voting of a claim should be closed or not.\n   * Internally called by checkVoteClosing method\n   * for Claims whose status number is 0 or status number lie between 2 and 6.\n   * @param claimId Claim Id.\n   * @param status Current status of claim.\n   * @return close 1 if voting should be closed,0 in case voting should not be closed,\n   * -1 if voting has already been closed.\n   */\n  function _checkVoteClosingFinal(uint claimId, uint status) internal view returns (int8 close) {\n    close = 0;\n    uint coverId;\n    (, coverId) = cd.getClaimCoverId(claimId);\n    bytes4 curr = qd.getCurrencyOfCover(coverId);\n    uint tokenx1e18 = m1.calculateTokenPrice(curr);\n    uint accept;\n    uint deny;\n    (, accept, deny) = cd.getClaimsTokenCA(claimId);\n    uint caTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\n    (, accept, deny) = cd.getClaimsTokenMV(claimId);\n    uint mvTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\n    uint sumassured = qd.getCoverSumAssured(coverId).mul(DECIMAL1E18);\n    if (status == 0 && caTokens >= sumassured.mul(10)) {\n      close = 1;\n    } else if (status >= 1 && status <= 5 && mvTokens >= sumassured.mul(10)) {\n      close = 1;\n    }\n  }\n\n  /**\n   * @dev Changes the status of an existing claim id, based on current\n   * status and current conditions of the system\n   * @param claimId Claim Id.\n   * @param stat status number.\n   */\n  function _setClaimStatus(uint claimId, uint stat) internal {\n\n    uint origstat;\n    uint state12Count;\n    uint dateUpd;\n    uint coverId;\n    (, coverId, , origstat, dateUpd, state12Count) = cd.getClaim(claimId);\n    (, origstat) = cd.getClaimStatusNumber(claimId);\n\n    if (stat == 12 && origstat == 12) {\n      cd.updateState12Count(claimId, 1);\n    }\n    cd.setClaimStatus(claimId, stat);\n\n    if (state12Count >= 60 && stat == 12) {\n      cd.setClaimStatus(claimId, 13);\n      qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimDenied));\n    }\n    uint time = now;\n    cd.setClaimdateUpd(claimId, time);\n\n    if (stat >= 2 && stat <= 5) {\n      p1.closeClaimsOraclise(claimId, cd.maxVotingTime());\n    }\n\n    if (stat == 12 && (dateUpd.add(cd.payoutRetryTime()) <= now) && (state12Count < 60)) {\n      p1.closeClaimsOraclise(claimId, cd.payoutRetryTime());\n    } else if (stat == 12 && (dateUpd.add(cd.payoutRetryTime()) > now) && (state12Count < 60)) {\n      uint64 timeLeft = uint64((dateUpd.add(cd.payoutRetryTime())).sub(now));\n      p1.closeClaimsOraclise(claimId, timeLeft);\n    }\n  }\n\n  /**\n   * @dev Submits a claim for a given cover note.\n   * Set deposits flag against cover.\n   */\n  function _addClaim(uint coverId, uint time, address add) internal {\n    tf.depositCN(coverId);\n    uint len = cd.actualClaimLength();\n    cd.addClaim(len, coverId, add, now);\n    cd.callClaimEvent(coverId, add, len, time);\n    qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimSubmitted));\n    bytes4 curr = qd.getCurrencyOfCover(coverId);\n    uint sumAssured = qd.getCoverSumAssured(coverId).mul(DECIMAL1E18);\n    pd.changeCurrencyAssetVarMin(curr, pd.getCurrencyAssetVarMin(curr).add(sumAssured));\n    p2.internalLiquiditySwap(curr);\n    p1.closeClaimsOraclise(len, cd.maxVotingTime());\n  }\n}\n\n// File: contracts/modules/capital/Pool1.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n\n\ncontract Pool1 is Iupgradable {\n  using SafeMath for uint;\n\n  Quotation internal q2;\n  NXMToken internal tk;\n  TokenController internal tc;\n  TokenFunctions internal tf;\n  Pool2 internal p2;\n  PoolData internal pd;\n  MCR internal m1;\n  Claims public c1;\n  TokenData internal td;\n  bool internal locked;\n\n  uint internal constant DECIMAL1E18 = uint(10) ** 18;\n\n  event Apiresult(address indexed sender, string msg, bytes32 myid);\n  event Payout(address indexed to, uint coverId, uint tokens);\n\n  modifier noReentrancy() {\n    require(!locked, \"Reentrant call.\");\n    locked = true;\n    _;\n    locked = false;\n  }\n\n  function() external payable {} // solhint-disable-line\n\n  /**\n   * @dev Pays out the sum assured in case a claim is accepted\n   * @param coverid Cover Id.\n   * @param claimid Claim Id.\n   * @return succ true if payout is successful, false otherwise.\n   */\n  function sendClaimPayout(\n    uint coverid,\n    uint claimid,\n    uint sumAssured,\n    address payable coverHolder,\n    bytes4 coverCurr\n  )\n  external\n  onlyInternal\n  noReentrancy\n  returns (bool succ)\n  {\n\n    uint sa = sumAssured.div(DECIMAL1E18);\n    bool check;\n    IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n\n    //Payout\n    if (coverCurr == \"ETH\" && address(this).balance >= sumAssured) {\n      // check = _transferCurrencyAsset(coverCurr, coverHolder, sumAssured);\n      coverHolder.transfer(sumAssured);\n      check = true;\n    } else if (coverCurr == \"DAI\" && erc20.balanceOf(address(this)) >= sumAssured) {\n      erc20.transfer(coverHolder, sumAssured);\n      check = true;\n    }\n\n    if (check == true) {\n      q2.removeSAFromCSA(coverid, sa);\n      pd.changeCurrencyAssetVarMin(coverCurr,\n        pd.getCurrencyAssetVarMin(coverCurr).sub(sumAssured));\n      emit Payout(coverHolder, coverid, sumAssured);\n      succ = true;\n    } else {\n      c1.setClaimStatus(claimid, 12);\n    }\n\n    // _triggerExternalLiquidityTrade();\n    // p2.internalLiquiditySwap(coverCurr);\n\n    tf.burnStakerLockedToken(coverid, coverCurr, sumAssured);\n  }\n\n  function triggerExternalLiquidityTrade() external onlyInternal {\n    // deprecated\n  }\n\n  ///@dev Oraclize call to close emergency pause.\n  function closeEmergencyPause(uint) external onlyInternal {\n    _saveQueryId(\"EP\", 0);\n  }\n\n  function closeClaimsOraclise(uint, uint) external onlyInternal {\n    // deprecated\n  }\n\n  function closeCoverOraclise(uint, uint64) external onlyInternal {\n    // deprecated\n  }\n\n  function mcrOraclise(uint) external onlyInternal {\n    // deprecated\n  }\n\n  function mcrOracliseFail(uint, uint) external onlyInternal {\n    // deprecated\n  }\n\n  function saveIADetailsOracalise(uint) external onlyInternal {\n    // deprecated\n  }\n\n  /**\n   * @dev Save the details of the current request for a future call\n   * @param _typeof type of the query\n   * @param id ID of the proposal, quote, cover etc. for which call is made\n   */\n  function _saveQueryId(bytes4 _typeof, uint id) internal {\n\n    uint queryId = block.timestamp;\n    bytes32 myid = bytes32(queryId);\n\n    while (pd.getDateAddOfAPI(myid) != 0) {\n      myid = bytes32(++queryId);\n    }\n\n    pd.saveApiDetails(myid, _typeof, id);\n    pd.addInAllApiCall(myid);\n  }\n\n  /**\n   * @dev Transfers all assest (i.e ETH balance, Currency Assest) from old Pool to new Pool\n   * @param newPoolAddress Address of the new Pool\n   */\n  function upgradeCapitalPool(address payable newPoolAddress) external noReentrancy onlyInternal {\n    for (uint64 i = 1; i < pd.getAllCurrenciesLen(); i++) {\n      bytes4 caName = pd.getCurrenciesByIndex(i);\n      _upgradeCapitalPool(caName, newPoolAddress);\n    }\n    if (address(this).balance > 0) {\n      Pool1 newP1 = Pool1(newPoolAddress);\n      newP1.sendEther.value(address(this).balance)();\n    }\n  }\n\n  /**\n   * @dev Iupgradable Interface to update dependent contract address\n   */\n  function changeDependentContractAddress() public {\n    m1 = MCR(ms.getLatestAddress(\"MC\"));\n    tk = NXMToken(ms.tokenAddress());\n    tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\n    tc = TokenController(ms.getLatestAddress(\"TC\"));\n    pd = PoolData(ms.getLatestAddress(\"PD\"));\n    q2 = Quotation(ms.getLatestAddress(\"QT\"));\n    p2 = Pool2(ms.getLatestAddress(\"P2\"));\n    c1 = Claims(ms.getLatestAddress(\"CL\"));\n    td = TokenData(ms.getLatestAddress(\"TD\"));\n  }\n\n  function sendEther() public payable {\n\n  }\n\n  /**\n   * @dev transfers currency asset to an address\n   * @param curr is the currency of currency asset to transfer\n   * @param amount is amount of currency asset to transfer\n   * @return boolean to represent success or failure\n   */\n  function transferCurrencyAsset(\n    bytes4 curr,\n    uint amount\n  )\n  public\n  onlyInternal\n  noReentrancy\n  returns (bool)\n  {\n\n    return _transferCurrencyAsset(curr, amount);\n  }\n\n  /// @dev Handles callback of external oracle query.\n  function __callback(bytes32 myid, string memory result) public {\n    result; // silence compiler warning\n    ms.delegateCallBack(myid);\n  }\n\n  /// @dev Enables user to purchase cover with funding in ETH.\n  /// @param smartCAdd Smart Contract Address\n  function makeCoverBegin(\n    address smartCAdd,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public isMember checkPause payable {\n    require(msg.value == coverDetails[1]);\n    q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n  }\n\n  /**\n   * @dev Enables user to purchase cover via currency asset eg DAI\n   */\n  function makeCoverUsingCA(\n    address smartCAdd,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public isMember checkPause {\n    IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n    require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]), \"Transfer failed\");\n    q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n  }\n\n  /// @dev Enables user to purchase NXM at the current token price.\n  function buyToken() public payable isMember checkPause returns (bool success) {\n    require(msg.value > 0);\n    uint tokenPurchased = _getToken(address(this).balance, msg.value);\n    tc.mint(msg.sender, tokenPurchased);\n    success = true;\n  }\n\n  /// @dev Sends a given amount of Ether to a given address.\n  /// @param amount amount (in wei) to send.\n  /// @param _add Receiver's address.\n  /// @return succ True if transfer is a success, otherwise False.\n  function transferEther(uint amount, address payable _add) public noReentrancy checkPause returns (bool succ) {\n    require(ms.checkIsAuthToGoverned(msg.sender), \"Not authorized to Govern\");\n    succ = _add.send(amount);\n  }\n\n  /**\n   * @dev Allows selling of NXM for ether.\n   * Seller first needs to give this contract allowance to\n   * transfer/burn tokens in the NXMToken contract\n   * @param  _amount Amount of NXM to sell\n   * @return success returns true on successfull sale\n   */\n  function sellNXMTokens(uint _amount) public isMember noReentrancy checkPause returns (bool success) {\n    require(tk.balanceOf(msg.sender) >= _amount, \"Not enough balance\");\n    require(!tf.isLockedForMemberVote(msg.sender), \"Member voted\");\n    require(_amount <= m1.getMaxSellTokens(), \"exceeds maximum token sell limit\");\n    uint sellingPrice = _getWei(_amount);\n    tc.burnFrom(msg.sender, _amount);\n    msg.sender.transfer(sellingPrice);\n    success = true;\n  }\n\n  /**\n   * @dev gives the investment asset balance\n   * @return investment asset balance\n   */\n  function getInvestmentAssetBalance() public view returns (uint balance) {\n    IERC20 erc20;\n    uint currTokens;\n    for (uint i = 1; i < pd.getInvestmentCurrencyLen(); i++) {\n      bytes4 currency = pd.getInvestmentCurrencyByIndex(i);\n      erc20 = IERC20(pd.getInvestmentAssetAddress(currency));\n      currTokens = erc20.balanceOf(address(p2));\n      if (pd.getIAAvgRate(currency) > 0)\n        balance = balance.add((currTokens.mul(100)).div(pd.getIAAvgRate(currency)));\n    }\n\n    balance = balance.add(address(p2).balance);\n  }\n\n  /**\n   * @dev Returns the amount of wei a seller will get for selling NXM\n   * @param amount Amount of NXM to sell\n   * @return weiToPay Amount of wei the seller will get\n   */\n  function getWei(uint amount) public view returns (uint weiToPay) {\n    return _getWei(amount);\n  }\n\n  /**\n   * @dev Returns the amount of token a buyer will get for corresponding wei\n   * @param weiPaid Amount of wei\n   * @return tokenToGet Amount of tokens the buyer will get\n   */\n  function getToken(uint weiPaid) public view returns (uint tokenToGet) {\n    return _getToken((address(this).balance).add(weiPaid), weiPaid);\n  }\n\n  /**\n   * @dev Returns the amount of wei a seller will get for selling NXM\n   * @param _amount Amount of NXM to sell\n   * @return weiToPay Amount of wei the seller will get\n   */\n  function _getWei(uint _amount) internal view returns (uint weiToPay) {\n    uint tokenPrice;\n    uint weiPaid;\n    uint tokenSupply = tk.totalSupply();\n    uint vtp;\n    uint mcrFullperc;\n    uint vFull;\n    uint mcrtp;\n    (mcrFullperc, , vFull,) = pd.getLastMCR();\n    (vtp,) = m1.calVtpAndMCRtp();\n\n    while (_amount > 0) {\n      mcrtp = (mcrFullperc.mul(vtp)).div(vFull);\n      tokenPrice = m1.calculateStepTokenPrice(\"ETH\", mcrtp);\n      tokenPrice = (tokenPrice.mul(975)).div(1000); // 97.5%\n      if (_amount <= td.priceStep().mul(DECIMAL1E18)) {\n        weiToPay = weiToPay.add((tokenPrice.mul(_amount)).div(DECIMAL1E18));\n        break;\n      } else {\n        _amount = _amount.sub(td.priceStep().mul(DECIMAL1E18));\n        tokenSupply = tokenSupply.sub(td.priceStep().mul(DECIMAL1E18));\n        weiPaid = (tokenPrice.mul(td.priceStep().mul(DECIMAL1E18))).div(DECIMAL1E18);\n        vtp = vtp.sub(weiPaid);\n        weiToPay = weiToPay.add(weiPaid);\n      }\n    }\n  }\n\n  /**\n   * @dev gives the token\n   * @param _poolBalance is the pool balance\n   * @param _weiPaid is the amount paid in wei\n   * @return the token to get\n   */\n  function _getToken(uint _poolBalance, uint _weiPaid) internal view returns (uint tokenToGet) {\n    uint tokenPrice;\n    uint superWeiLeft = (_weiPaid).mul(DECIMAL1E18);\n    uint tempTokens;\n    uint superWeiSpent;\n    uint tokenSupply = tk.totalSupply();\n    uint vtp;\n    uint mcrFullperc;\n    uint vFull;\n    uint mcrtp;\n    (mcrFullperc, , vFull,) = pd.getLastMCR();\n    (vtp,) = m1.calculateVtpAndMCRtp((_poolBalance).sub(_weiPaid));\n\n    require(m1.calculateTokenPrice(\"ETH\") > 0, \"Token price can not be zero\");\n    while (superWeiLeft > 0) {\n      mcrtp = (mcrFullperc.mul(vtp)).div(vFull);\n      tokenPrice = m1.calculateStepTokenPrice(\"ETH\", mcrtp);\n      tempTokens = superWeiLeft.div(tokenPrice);\n      if (tempTokens <= td.priceStep().mul(DECIMAL1E18)) {\n        tokenToGet = tokenToGet.add(tempTokens);\n        break;\n      } else {\n        tokenToGet = tokenToGet.add(td.priceStep().mul(DECIMAL1E18));\n        tokenSupply = tokenSupply.add(td.priceStep().mul(DECIMAL1E18));\n        superWeiSpent = td.priceStep().mul(DECIMAL1E18).mul(tokenPrice);\n        superWeiLeft = superWeiLeft.sub(superWeiSpent);\n        vtp = vtp.add((td.priceStep().mul(DECIMAL1E18).mul(tokenPrice)).div(DECIMAL1E18));\n      }\n    }\n  }\n\n  /**\n   * @dev transfers currency asset\n   * @param _curr is currency of asset to transfer\n   * @param _amount is the amount to be transferred\n   * @return boolean representing the success of transfer\n   */\n  function _transferCurrencyAsset(bytes4 _curr, uint _amount) internal returns (bool succ) {\n    if (_curr == \"ETH\") {\n      if (address(this).balance < _amount)\n        _amount = address(this).balance;\n      p2.sendEther.value(_amount)();\n      succ = true;\n    } else {\n      IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(_curr)); // solhint-disable-line\n      if (erc20.balanceOf(address(this)) < _amount)\n        _amount = erc20.balanceOf(address(this));\n      require(erc20.transfer(address(p2), _amount));\n      succ = true;\n\n    }\n  }\n\n  /**\n   * @dev Transfers ERC20 Currency asset from this Pool to another Pool on upgrade.\n   */\n  function _upgradeCapitalPool(\n    bytes4 _curr,\n    address _newPoolAddress\n  )\n  internal\n  {\n    IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(_curr));\n    if (erc20.balanceOf(address(this)) > 0)\n      require(erc20.transfer(_newPoolAddress, erc20.balanceOf(address(this))));\n  }\n\n}\n\n// File: contracts/modules/claims/ClaimsReward.sol\n\n/* Copyright (C) 2020 NexusMutual.io\n\n  This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\n\n//Claims Reward Contract contains the functions for calculating number of tokens\n// that will get rewarded, unlocked or burned depending upon the status of claim.\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n\n\n\n\n\ncontract ClaimsReward is Iupgradable {\n  using SafeMath for uint;\n\n  NXMToken internal tk;\n  TokenController internal tc;\n  TokenFunctions internal tf;\n  TokenData internal td;\n  QuotationData internal qd;\n  Claims internal c1;\n  ClaimsData internal cd;\n  Pool1 internal p1;\n  Pool2 internal p2;\n  PoolData internal pd;\n  Governance internal gv;\n  IPooledStaking internal pooledStaking;\n  MemberRoles internal memberRoles;\n\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\n\n  function changeDependentContractAddress() public onlyInternal {\n    c1 = Claims(ms.getLatestAddress(\"CL\"));\n    cd = ClaimsData(ms.getLatestAddress(\"CD\"));\n    tk = NXMToken(ms.tokenAddress());\n    tc = TokenController(ms.getLatestAddress(\"TC\"));\n    td = TokenData(ms.getLatestAddress(\"TD\"));\n    tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\n    p1 = Pool1(ms.getLatestAddress(\"P1\"));\n    p2 = Pool2(ms.getLatestAddress(\"P2\"));\n    pd = PoolData(ms.getLatestAddress(\"PD\"));\n    qd = QuotationData(ms.getLatestAddress(\"QD\"));\n    gv = Governance(ms.getLatestAddress(\"GV\"));\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\"PS\"));\n    memberRoles = MemberRoles(ms.getLatestAddress(\"MR\"));\n  }\n\n  /// @dev Decides the next course of action for a given claim.\n  function changeClaimStatus(uint claimid) public checkPause onlyInternal {\n\n    uint coverid;\n    (, coverid) = cd.getClaimCoverId(claimid);\n\n    uint status;\n    (, status) = cd.getClaimStatusNumber(claimid);\n\n    // when current status is \"Pending-Claim Assessor Vote\"\n    if (status == 0) {\n      _changeClaimStatusCA(claimid, coverid, status);\n    } else if (status >= 1 && status <= 5) {\n      _changeClaimStatusMV(claimid, coverid, status);\n    } else if (status == 12) {// when current status is \"Claim Accepted Payout Pending\"\n\n      uint sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\n      address payable coverHolder = qd.getCoverMemberAddress(coverid);\n      bytes4 coverCurrency = qd.getCurrencyOfCover(coverid);\n\n      address payable payoutAddress = memberRoles.getClaimPayoutAddress(coverHolder);\n      bool success = p1.sendClaimPayout(coverid, claimid, sumAssured, payoutAddress, coverCurrency);\n\n      if (success) {\n        tf.burnStakedTokens(coverid, coverCurrency, sumAssured);\n        c1.setClaimStatus(claimid, 14);\n      }\n    }\n\n    c1.changePendingClaimStart();\n  }\n\n  /// @dev Amount of tokens to be rewarded to a user for a particular vote id.\n  /// @param check 1 -> CA vote, else member vote\n  /// @param voteid vote id for which reward has to be Calculated\n  /// @param flag if 1 calculate even if claimed,else don't calculate if already claimed\n  /// @return tokenCalculated reward to be given for vote id\n  /// @return lastClaimedCheck true if final verdict is still pending for that voteid\n  /// @return tokens number of tokens locked under that voteid\n  /// @return perc percentage of reward to be given.\n  function getRewardToBeGiven(\n    uint check,\n    uint voteid,\n    uint flag\n  )\n  public\n  view\n  returns (\n    uint tokenCalculated,\n    bool lastClaimedCheck,\n    uint tokens,\n    uint perc\n  )\n\n  {\n    uint claimId;\n    int8 verdict;\n    bool claimed;\n    uint tokensToBeDist;\n    uint totalTokens;\n    (tokens, claimId, verdict, claimed) = cd.getVoteDetails(voteid);\n    lastClaimedCheck = false;\n    int8 claimVerdict = cd.getFinalVerdict(claimId);\n    if (claimVerdict == 0) {\n      lastClaimedCheck = true;\n    }\n\n    if (claimVerdict == verdict && (claimed == false || flag == 1)) {\n\n      if (check == 1) {\n        (perc, , tokensToBeDist) = cd.getClaimRewardDetail(claimId);\n      } else {\n        (, perc, tokensToBeDist) = cd.getClaimRewardDetail(claimId);\n      }\n\n      if (perc > 0) {\n        if (check == 1) {\n          if (verdict == 1) {\n            (, totalTokens,) = cd.getClaimsTokenCA(claimId);\n          } else {\n            (,, totalTokens) = cd.getClaimsTokenCA(claimId);\n          }\n        } else {\n          if (verdict == 1) {\n            (, totalTokens,) = cd.getClaimsTokenMV(claimId);\n          } else {\n            (,, totalTokens) = cd.getClaimsTokenMV(claimId);\n          }\n        }\n        tokenCalculated = (perc.mul(tokens).mul(tokensToBeDist)).div(totalTokens.mul(100));\n\n\n      }\n    }\n  }\n\n  /// @dev Transfers all tokens held by contract to a new contract in case of upgrade.\n  function upgrade(address _newAdd) public onlyInternal {\n    uint amount = tk.balanceOf(address(this));\n    if (amount > 0) {\n      require(tk.transfer(_newAdd, amount));\n    }\n\n  }\n\n  /// @dev Total reward in token due for claim by a user.\n  /// @return total total number of tokens\n  function getRewardToBeDistributedByUser(address _add) public view returns (uint total) {\n    uint lengthVote = cd.getVoteAddressCALength(_add);\n    uint lastIndexCA;\n    uint lastIndexMV;\n    uint tokenForVoteId;\n    uint voteId;\n    (lastIndexCA, lastIndexMV) = cd.getRewardDistributedIndex(_add);\n\n    for (uint i = lastIndexCA; i < lengthVote; i++) {\n      voteId = cd.getVoteAddressCA(_add, i);\n      (tokenForVoteId,,,) = getRewardToBeGiven(1, voteId, 0);\n      total = total.add(tokenForVoteId);\n    }\n\n    lengthVote = cd.getVoteAddressMemberLength(_add);\n\n    for (uint j = lastIndexMV; j < lengthVote; j++) {\n      voteId = cd.getVoteAddressMember(_add, j);\n      (tokenForVoteId,,,) = getRewardToBeGiven(0, voteId, 0);\n      total = total.add(tokenForVoteId);\n    }\n    return (total);\n  }\n\n  /// @dev Gets reward amount and claiming status for a given claim id.\n  /// @return reward amount of tokens to user.\n  /// @return claimed true if already claimed false if yet to be claimed.\n  function getRewardAndClaimedStatus(uint check, uint claimId) public view returns (uint reward, bool claimed) {\n    uint voteId;\n    uint claimid;\n    uint lengthVote;\n\n    if (check == 1) {\n      lengthVote = cd.getVoteAddressCALength(msg.sender);\n      for (uint i = 0; i < lengthVote; i++) {\n        voteId = cd.getVoteAddressCA(msg.sender, i);\n        (, claimid, , claimed) = cd.getVoteDetails(voteId);\n        if (claimid == claimId) {break;}\n      }\n    } else {\n      lengthVote = cd.getVoteAddressMemberLength(msg.sender);\n      for (uint j = 0; j < lengthVote; j++) {\n        voteId = cd.getVoteAddressMember(msg.sender, j);\n        (, claimid, , claimed) = cd.getVoteDetails(voteId);\n        if (claimid == claimId) {break;}\n      }\n    }\n    (reward,,,) = getRewardToBeGiven(check, voteId, 1);\n\n  }\n\n  /**\n   * @dev Function used to claim all pending rewards : Claims Assessment + Risk Assessment + Governance\n   * Claim assesment, Risk assesment, Governance rewards\n   */\n  function claimAllPendingReward(uint records) public isMemberAndcheckPause {\n    _claimRewardToBeDistributed(records);\n    pooledStaking.withdrawReward(msg.sender);\n    uint governanceRewards = gv.claimReward(msg.sender, records);\n    if (governanceRewards > 0) {\n      require(tk.transfer(msg.sender, governanceRewards));\n    }\n  }\n\n  /**\n   * @dev Function used to get pending rewards of a particular user address.\n   * @param _add user address.\n   * @return total reward amount of the user\n   */\n  function getAllPendingRewardOfUser(address _add) public view returns (uint) {\n    uint caReward = getRewardToBeDistributedByUser(_add);\n    uint pooledStakingReward = pooledStaking.stakerReward(_add);\n    uint governanceReward = gv.getPendingReward(_add);\n    return caReward.add(pooledStakingReward).add(governanceReward);\n  }\n\n  /// @dev Rewards/Punishes users who  participated in Claims assessment.\n  //    Unlocking and burning of the tokens will also depend upon the status of claim.\n  /// @param claimid Claim Id.\n  function _rewardAgainstClaim(uint claimid, uint coverid, uint sumAssured, uint status) internal {\n    uint premiumNXM = qd.getCoverPremiumNXM(coverid);\n    bytes4 curr = qd.getCurrencyOfCover(coverid);\n    uint distributableTokens = premiumNXM.mul(cd.claimRewardPerc()).div(100); // 20% of premium\n\n    uint percCA;\n    uint percMV;\n\n    (percCA, percMV) = cd.getRewardStatus(status);\n    cd.setClaimRewardDetail(claimid, percCA, percMV, distributableTokens);\n    if (percCA > 0 || percMV > 0) {\n      tc.mint(address(this), distributableTokens);\n    }\n\n    if (status == 6 || status == 9 || status == 11) {\n      cd.changeFinalVerdict(claimid, - 1);\n      td.setDepositCN(coverid, false); // Unset flag\n      tf.burnDepositCN(coverid); // burn Deposited CN\n\n      pd.changeCurrencyAssetVarMin(curr, pd.getCurrencyAssetVarMin(curr).sub(sumAssured));\n      p2.internalLiquiditySwap(curr);\n\n    } else if (status == 7 || status == 8 || status == 10) {\n\n      cd.changeFinalVerdict(claimid, 1);\n      td.setDepositCN(coverid, false); // Unset flag\n      tf.unlockCN(coverid);\n\n      address payable coverHolder = qd.getCoverMemberAddress(coverid);\n      address payable payoutAddress = memberRoles.getClaimPayoutAddress(coverHolder);\n      bool success = p1.sendClaimPayout(coverid, claimid, sumAssured, payoutAddress, curr);\n\n      if (success) {\n        tf.burnStakedTokens(coverid, curr, sumAssured);\n        c1.setClaimStatus(claimid, 14);\n      }\n    }\n  }\n\n  /// @dev Computes the result of Claim Assessors Voting for a given claim id.\n  function _changeClaimStatusCA(uint claimid, uint coverid, uint status) internal {\n    // Check if voting should be closed or not\n    if (c1.checkVoteClosing(claimid) == 1) {\n      uint caTokens = c1.getCATokens(claimid, 0); // converted in cover currency.\n      uint accept;\n      uint deny;\n      uint acceptAndDeny;\n      bool rewardOrPunish;\n      uint sumAssured;\n      (, accept) = cd.getClaimVote(claimid, 1);\n      (, deny) = cd.getClaimVote(claimid, - 1);\n      acceptAndDeny = accept.add(deny);\n      accept = accept.mul(100);\n      deny = deny.mul(100);\n\n      if (caTokens == 0) {\n        status = 3;\n      } else {\n        sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\n        // Min threshold reached tokens used for voting > 5* sum assured\n        if (caTokens > sumAssured.mul(5)) {\n\n          if (accept.div(acceptAndDeny) > 70) {\n            status = 7;\n            qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimAccepted));\n            rewardOrPunish = true;\n          } else if (deny.div(acceptAndDeny) > 70) {\n            status = 6;\n            qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimDenied));\n            rewardOrPunish = true;\n          } else if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\n            status = 4;\n          } else {\n            status = 5;\n          }\n\n        } else {\n\n          if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\n            status = 2;\n          } else {\n            status = 3;\n          }\n        }\n      }\n\n      c1.setClaimStatus(claimid, status);\n\n      if (rewardOrPunish) {\n        _rewardAgainstClaim(claimid, coverid, sumAssured, status);\n      }\n    }\n  }\n\n  /// @dev Computes the result of Member Voting for a given claim id.\n  function _changeClaimStatusMV(uint claimid, uint coverid, uint status) internal {\n\n    // Check if voting should be closed or not\n    if (c1.checkVoteClosing(claimid) == 1) {\n      uint8 coverStatus;\n      uint statusOrig = status;\n      uint mvTokens = c1.getCATokens(claimid, 1); // converted in cover currency.\n\n      // If tokens used for acceptance >50%, claim is accepted\n      uint sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\n      uint thresholdUnreached = 0;\n      // Minimum threshold for member voting is reached only when\n      // value of tokens used for voting > 5* sum assured of claim id\n      if (mvTokens < sumAssured.mul(5)) {\n        thresholdUnreached = 1;\n      }\n\n      uint accept;\n      (, accept) = cd.getClaimMVote(claimid, 1);\n      uint deny;\n      (, deny) = cd.getClaimMVote(claimid, - 1);\n\n      if (accept.add(deny) > 0) {\n        if (accept.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\n        statusOrig <= 5 && thresholdUnreached == 0) {\n          status = 8;\n          coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\n        } else if (deny.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\n        statusOrig <= 5 && thresholdUnreached == 0) {\n          status = 9;\n          coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\n        }\n      }\n\n      if (thresholdUnreached == 1 && (statusOrig == 2 || statusOrig == 4)) {\n        status = 10;\n        coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\n      } else if (thresholdUnreached == 1 && (statusOrig == 5 || statusOrig == 3 || statusOrig == 1)) {\n        status = 11;\n        coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\n      }\n\n      c1.setClaimStatus(claimid, status);\n      qd.changeCoverStatusNo(coverid, uint8(coverStatus));\n      // Reward/Punish Claim Assessors and Members who participated in Claims assessment\n      _rewardAgainstClaim(claimid, coverid, sumAssured, status);\n    }\n  }\n\n  /// @dev Allows a user to claim all pending  Claims assessment rewards.\n  function _claimRewardToBeDistributed(uint _records) internal {\n    uint lengthVote = cd.getVoteAddressCALength(msg.sender);\n    uint voteid;\n    uint lastIndex;\n    (lastIndex,) = cd.getRewardDistributedIndex(msg.sender);\n    uint total = 0;\n    uint tokenForVoteId = 0;\n    bool lastClaimedCheck;\n    uint _days = td.lockCADays();\n    bool claimed;\n    uint counter = 0;\n    uint claimId;\n    uint perc;\n    uint i;\n    uint lastClaimed = lengthVote;\n\n    for (i = lastIndex; i < lengthVote && counter < _records; i++) {\n      voteid = cd.getVoteAddressCA(msg.sender, i);\n      (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\n      if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n        lastClaimed = i;\n      }\n      (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n      if (perc > 0 && !claimed) {\n        counter++;\n        cd.setRewardClaimed(voteid, true);\n      } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\n        (perc,,) = cd.getClaimRewardDetail(claimId);\n        if (perc == 0) {\n          counter++;\n        }\n        cd.setRewardClaimed(voteid, true);\n      }\n      if (tokenForVoteId > 0) {\n        total = tokenForVoteId.add(total);\n      }\n    }\n    if (lastClaimed == lengthVote) {\n      cd.setRewardDistributedIndexCA(msg.sender, i);\n    }\n    else {\n      cd.setRewardDistributedIndexCA(msg.sender, lastClaimed);\n    }\n    lengthVote = cd.getVoteAddressMemberLength(msg.sender);\n    lastClaimed = lengthVote;\n    _days = _days.mul(counter);\n    if (tc.tokensLockedAtTime(msg.sender, \"CLA\", now) > 0) {\n      tc.reduceLock(msg.sender, \"CLA\", _days);\n    }\n    (, lastIndex) = cd.getRewardDistributedIndex(msg.sender);\n    lastClaimed = lengthVote;\n    counter = 0;\n    for (i = lastIndex; i < lengthVote && counter < _records; i++) {\n      voteid = cd.getVoteAddressMember(msg.sender, i);\n      (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\n      if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n        lastClaimed = i;\n      }\n      (, claimId, , claimed) = cd.getVoteDetails(voteid);\n      if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\n        cd.setRewardClaimed(voteid, true);\n        counter++;\n      }\n      if (tokenForVoteId > 0) {\n        total = tokenForVoteId.add(total);\n      }\n    }\n    if (total > 0) {\n      require(tk.transfer(msg.sender, total));\n    }\n    if (lastClaimed == lengthVote) {\n      cd.setRewardDistributedIndexMV(msg.sender, i);\n    }\n    else {\n      cd.setRewardDistributedIndexMV(msg.sender, lastClaimed);\n    }\n  }\n\n  /**\n   * @dev Function used to claim the commission earned by the staker.\n   */\n  function _claimStakeCommission(uint _records, address _user) external onlyInternal {\n    uint total = 0;\n    uint len = td.getStakerStakedContractLength(_user);\n    uint lastCompletedStakeCommission = td.lastCompletedStakeCommission(_user);\n    uint commissionEarned;\n    uint commissionRedeemed;\n    uint maxCommission;\n    uint lastCommisionRedeemed = len;\n    uint counter;\n    uint i;\n\n    for (i = lastCompletedStakeCommission; i < len && counter < _records; i++) {\n      commissionRedeemed = td.getStakerRedeemedStakeCommission(_user, i);\n      commissionEarned = td.getStakerEarnedStakeCommission(_user, i);\n      maxCommission = td.getStakerInitialStakedAmountOnContract(\n        _user, i).mul(td.stakerMaxCommissionPer()).div(100);\n      if (lastCommisionRedeemed == len && maxCommission != commissionEarned)\n        lastCommisionRedeemed = i;\n      td.pushRedeemedStakeCommissions(_user, i, commissionEarned.sub(commissionRedeemed));\n      total = total.add(commissionEarned.sub(commissionRedeemed));\n      counter++;\n    }\n    if (lastCommisionRedeemed == len) {\n      td.setLastCompletedStakeCommissionIndex(_user, i);\n    } else {\n      td.setLastCompletedStakeCommissionIndex(_user, lastCommisionRedeemed);\n    }\n\n    if (total > 0)\n      require(tk.transfer(_user, total)); // solhint-disable-line\n  }\n\n  function fixStuckStatuses() external {\n    cd.setClaimStatus(2, 14);\n    cd.setClaimStatus(3, 14);\n    cd.setClaimStatus(5, 14);\n  }\n\n}\n\n// File: contracts/modules/staking/PooledStaking.sol\n\n/*\n    Copyright (C) 2020 NexusMutual.io\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see http://www.gnu.org/licenses/\n*/\n\npragma solidity ^0.5.0;\n\n\n\n\n\n\n\n\n\n\ncontract PooledStaking is MasterAware, IPooledStaking {\n  using SafeMath for uint;\n\n  /* Data types */\n\n  struct Staker {\n    uint deposit; // total amount of deposit nxm\n    uint reward; // total amount that is ready to be claimed\n    address[] contracts; // list of contracts the staker has staked on\n\n    // staked amounts for each contract\n    mapping(address => uint) stakes;\n\n    // amount pending to be subtracted after all unstake requests will be processed\n    mapping(address => uint) pendingUnstakeRequestsTotal;\n\n    // flag to indicate the presence of this staker in the array of stakers of each contract\n    mapping(address => bool) isInContractStakers;\n  }\n\n  struct Burn {\n    uint amount;\n    uint burnedAt;\n    address contractAddress;\n  }\n\n  struct Reward {\n    uint amount;\n    uint rewardedAt;\n    address contractAddress;\n  }\n\n  struct UnstakeRequest {\n    uint amount;\n    uint unstakeAt;\n    address contractAddress;\n    address stakerAddress;\n    uint next; // id of the next unstake request in the linked list\n  }\n\n  struct ContractReward {\n    uint amount;\n    uint lastDistributionRound;\n  }\n\n  /* Events */\n\n  // deposits\n  event Deposited(address indexed staker, uint amount);\n  event Withdrawn(address indexed staker, uint amount);\n\n  // stakes\n  event Staked(address indexed contractAddress, address indexed staker, uint amount);\n  event UnstakeRequested(address indexed contractAddress, address indexed staker, uint amount, uint unstakeAt);\n  event Unstaked(address indexed contractAddress, address indexed staker, uint amount);\n\n  // burns\n  event BurnRequested(address indexed contractAddress, uint amount);\n  event Burned(address indexed contractAddress, uint amount, uint contractStakeBeforeBurn);\n\n  // rewards\n  event RewardAdded(address indexed contractAddress, uint amount);\n  event RewardRequested(address indexed contractAddress, uint amount);\n  event Rewarded(address indexed contractAddress, uint amount, uint contractStake);\n  event RewardWithdrawn(address indexed staker, uint amount);\n\n  // pending actions processing\n  event PendingActionsProcessed(bool finished);\n\n  /* Storage variables */\n\n  bool public initialized;\n\n  NXMToken public token;\n  TokenController public tokenController;\n\n  uint public MIN_STAKE;         // Minimum allowed stake per contract\n  uint public MAX_EXPOSURE;      // Stakes sum must be less than the deposit amount times this\n  uint public MIN_UNSTAKE;       // Forbid unstake of small amounts to prevent spam\n  uint public UNSTAKE_LOCK_TIME; // Lock period in seconds before unstaking takes place\n\n  mapping(address => Staker) public stakers;     // stakerAddress => Staker\n\n  // temporary variables\n  uint public contractStaked;   // used when processing burns and rewards\n  uint public contractBurned;   // used when processing burns\n  uint public contractRewarded; // used when processing rewards\n\n  // list of stakers for all contracts\n  mapping(address => address[]) public contractStakers;\n\n  // there can be only one pending burn\n  Burn public burn;\n\n  mapping(uint => Reward) public rewards; // reward id => Reward\n  uint public firstReward;\n  uint public lastRewardId;\n\n  mapping(uint => UnstakeRequest) public unstakeRequests; // unstake id => UnstakeRequest\n  // firstUnstakeRequest is stored at unstakeRequests[0].next\n  uint public lastUnstakeRequestId;\n\n  uint public processedToStakerIndex; // we processed the action up this staker\n  bool public isContractStakeCalculated; // flag to indicate whether staked amount is up to date or not\n\n  /* state vars for rewards groupping upgrade */\n\n  // rewards to be distributed at the end of the current round\n  // contract address => ContractRewards\n  mapping(address => ContractReward) public accumulatedRewards;\n\n  uint public REWARD_ROUND_DURATION;\n  uint public REWARD_ROUNDS_START;\n\n  /* Modifiers */\n\n  modifier noPendingActions {\n    require(!hasPendingActions(), \"Unable to execute request with unprocessed actions\");\n    _;\n  }\n\n  modifier noPendingBurns {\n    require(!hasPendingBurns(), \"Unable to execute request with unprocessed burns\");\n    _;\n  }\n\n  modifier noPendingUnstakeRequests {\n    require(!hasPendingUnstakeRequests(), \"Unable to execute request with unprocessed unstake requests\");\n    _;\n  }\n\n  modifier noPendingRewards {\n    require(!hasPendingRewards(), \"Unable to execute request with unprocessed rewards\");\n    _;\n  }\n\n  modifier whenNotPausedAndInitialized {\n    require(!master.isPause(), \"System is paused\");\n    require(initialized, \"Contract is not initialized\");\n    _;\n  }\n\n  /* Getters and view functions */\n\n  function contractStakerCount(address contractAddress) external view returns (uint) {\n    return contractStakers[contractAddress].length;\n  }\n\n  function contractStakerAtIndex(address contractAddress, uint stakerIndex) external view returns (address) {\n    return contractStakers[contractAddress][stakerIndex];\n  }\n\n  function contractStakersArray(address contractAddress) external view returns (address[] memory _stakers) {\n    return contractStakers[contractAddress];\n  }\n\n  function contractStake(address contractAddress) public view returns (uint) {\n\n    address[] storage _stakers = contractStakers[contractAddress];\n    uint stakerCount = _stakers.length;\n    uint stakedOnContract;\n\n    for (uint i = 0; i < stakerCount; i++) {\n      Staker storage staker = stakers[_stakers[i]];\n      uint deposit = staker.deposit;\n      uint stake = staker.stakes[contractAddress];\n\n      // add the minimum of the two\n      stake = deposit < stake ? deposit : stake;\n      stakedOnContract = stakedOnContract.add(stake);\n    }\n\n    return stakedOnContract;\n  }\n\n  function stakerContractCount(address staker) external view returns (uint) {\n    return stakers[staker].contracts.length;\n  }\n\n  function stakerContractAtIndex(address staker, uint contractIndex) external view returns (address) {\n    return stakers[staker].contracts[contractIndex];\n  }\n\n  function stakerContractsArray(address staker) external view returns (address[] memory) {\n    return stakers[staker].contracts;\n  }\n\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint) {\n    uint stake = stakers[staker].stakes[contractAddress];\n    uint deposit = stakers[staker].deposit;\n    return stake < deposit ? stake : deposit;\n  }\n\n  function stakerContractPendingUnstakeTotal(address staker, address contractAddress) external view returns (uint) {\n    return stakers[staker].pendingUnstakeRequestsTotal[contractAddress];\n  }\n\n  function stakerReward(address staker) external view returns (uint) {\n    return stakers[staker].reward;\n  }\n\n  function stakerDeposit(address staker) external view returns (uint) {\n    return stakers[staker].deposit;\n  }\n\n  function stakerMaxWithdrawable(address stakerAddress) public view returns (uint) {\n\n    Staker storage staker = stakers[stakerAddress];\n    uint deposit = staker.deposit;\n    uint totalStaked;\n    uint maxStake;\n\n    for (uint i = 0; i < staker.contracts.length; i++) {\n\n      address contractAddress = staker.contracts[i];\n      uint initialStake = staker.stakes[contractAddress];\n      uint stake = deposit < initialStake ? deposit : initialStake;\n      totalStaked = totalStaked.add(stake);\n\n      if (stake > maxStake) {\n        maxStake = stake;\n      }\n    }\n\n    uint minRequired = totalStaked.div(MAX_EXPOSURE);\n    uint locked = maxStake > minRequired ? maxStake : minRequired;\n\n    return deposit.sub(locked);\n  }\n\n  function unstakeRequestAtIndex(uint unstakeRequestId) external view returns (\n    uint amount, uint unstakeAt, address contractAddress, address stakerAddress, uint next\n  ) {\n    UnstakeRequest storage unstakeRequest = unstakeRequests[unstakeRequestId];\n    amount = unstakeRequest.amount;\n    unstakeAt = unstakeRequest.unstakeAt;\n    contractAddress = unstakeRequest.contractAddress;\n    stakerAddress = unstakeRequest.stakerAddress;\n    next = unstakeRequest.next;\n  }\n\n  function hasPendingActions() public view returns (bool) {\n    return hasPendingBurns() || hasPendingUnstakeRequests() || hasPendingRewards();\n  }\n\n  function hasPendingBurns() public view returns (bool) {\n    return burn.burnedAt != 0;\n  }\n\n  function hasPendingUnstakeRequests() public view returns (bool){\n\n    uint nextRequestIndex = unstakeRequests[0].next;\n\n    if (nextRequestIndex == 0) {\n      return false;\n    }\n\n    return unstakeRequests[nextRequestIndex].unstakeAt <= now;\n  }\n\n  function hasPendingRewards() public view returns (bool){\n    return rewards[firstReward].rewardedAt != 0;\n  }\n\n  /* State-changing functions */\n\n  function depositAndStake(\n    uint amount,\n    address[] calldata _contracts,\n    uint[] calldata _stakes\n  ) external whenNotPausedAndInitialized onlyMember noPendingActions {\n\n    Staker storage staker = stakers[msg.sender];\n    uint oldLength = staker.contracts.length;\n\n    require(\n      _contracts.length >= oldLength,\n      \"Staking on fewer contracts is not allowed\"\n    );\n\n    require(\n      _contracts.length == _stakes.length,\n      \"Contracts and stakes arrays should have the same length\"\n    );\n\n    uint totalStaked;\n\n    // cap old stakes to this amount\n    uint oldDeposit = staker.deposit;\n    uint newDeposit = oldDeposit.add(amount);\n\n    staker.deposit = newDeposit;\n    tokenController.operatorTransfer(msg.sender, address(this), amount);\n\n    for (uint i = 0; i < _contracts.length; i++) {\n\n      address contractAddress = _contracts[i];\n\n      for (uint j = 0; j < i; j++) {\n        require(_contracts[j] != contractAddress, \"Contracts array should not contain duplicates\");\n      }\n\n      uint initialStake = staker.stakes[contractAddress];\n      uint oldStake = oldDeposit < initialStake ? oldDeposit : initialStake;\n      uint newStake = _stakes[i];\n      bool isNewStake = i >= oldLength;\n\n      if (!isNewStake) {\n        require(contractAddress == staker.contracts[i], \"Unexpected contract order\");\n        require(oldStake <= newStake, \"New stake is less than previous stake\");\n      } else {\n        require(newStake > 0, \"New stakes should be greater than 0\");\n        staker.contracts.push(contractAddress);\n      }\n\n      if (oldStake == newStake) {\n\n        // if there were burns but the stake was not updated, update it now\n        if (initialStake != newStake) {\n          staker.stakes[contractAddress] = newStake;\n        }\n\n        totalStaked = totalStaked.add(newStake);\n\n        // no other changes to this contract\n        continue;\n      }\n\n      require(newStake >= MIN_STAKE, \"Minimum stake amount not met\");\n      require(newStake <= newDeposit, \"Cannot stake more than deposited\");\n\n      if (isNewStake || !staker.isInContractStakers[contractAddress]) {\n        staker.isInContractStakers[contractAddress] = true;\n        contractStakers[contractAddress].push(msg.sender);\n      }\n\n      staker.stakes[contractAddress] = newStake;\n      totalStaked = totalStaked.add(newStake);\n      uint increase = newStake.sub(oldStake);\n\n      emit Staked(contractAddress, msg.sender, increase);\n    }\n\n    require(\n      totalStaked <= staker.deposit.mul(MAX_EXPOSURE),\n      \"Total stake exceeds maximum allowed\"\n    );\n\n    if (amount > 0) {\n      emit Deposited(msg.sender, amount);\n    }\n\n    // cleanup zero-amount contracts\n    uint lastContractIndex = _contracts.length - 1;\n\n    for (uint i = oldLength; i > 0; i--) {\n      if (_stakes[i - 1] == 0) {\n        staker.contracts[i - 1] = staker.contracts[lastContractIndex];\n        staker.contracts.pop();\n        --lastContractIndex;\n      }\n    }\n  }\n\n  function withdraw(uint amount) external whenNotPausedAndInitialized onlyMember noPendingBurns {\n    uint limit = stakerMaxWithdrawable(msg.sender);\n    require(limit >= amount, \"Requested amount exceeds max withdrawable amount\");\n    stakers[msg.sender].deposit = stakers[msg.sender].deposit.sub(amount);\n    token.transfer(msg.sender, amount);\n    emit Withdrawn(msg.sender, amount);\n  }\n\n  function requestUnstake(\n    address[] calldata _contracts,\n    uint[] calldata _amounts,\n    uint _insertAfter // unstake request id after which the new unstake request will be inserted\n  ) external whenNotPausedAndInitialized onlyMember {\n\n    require(\n      _contracts.length == _amounts.length,\n      \"Contracts and amounts arrays should have the same length\"\n    );\n\n    require(_insertAfter <= lastUnstakeRequestId, \"Invalid unstake request id provided\");\n\n    Staker storage staker = stakers[msg.sender];\n    uint deposit = staker.deposit;\n    uint previousId = _insertAfter;\n    uint unstakeAt = now.add(UNSTAKE_LOCK_TIME);\n\n    UnstakeRequest storage previousRequest = unstakeRequests[previousId];\n\n    // Forbid insertion after an empty slot when there are non-empty slots\n    // previousId != 0 allows inserting on the first position (in case lock time has been reduced)\n    if (previousId != 0) {\n      require(previousRequest.unstakeAt != 0, \"Provided unstake request id should not be an empty slot\");\n    }\n\n    for (uint i = 0; i < _contracts.length; i++) {\n\n      address contractAddress = _contracts[i];\n      uint stake = staker.stakes[contractAddress];\n\n      if (stake > deposit) {\n        stake = deposit;\n      }\n\n      uint pendingUnstakeAmount = staker.pendingUnstakeRequestsTotal[contractAddress];\n      uint requestedAmount = _amounts[i];\n      uint max = pendingUnstakeAmount > stake ? 0 : stake.sub(pendingUnstakeAmount);\n\n      require(max > 0, \"Nothing to unstake on this contract\");\n      require(requestedAmount <= max, \"Cannot unstake more than staked\");\n\n      // To prevent spam, small stakes and unstake requests are not allowed\n      // However, we allow the user to unstake the entire amount\n      if (requestedAmount != max) {\n        require(requestedAmount >= MIN_UNSTAKE, \"Unstaked amount cannot be less than minimum unstake amount\");\n        require(max.sub(requestedAmount) >= MIN_STAKE, \"Remaining stake cannot be less than minimum unstake amount\");\n      }\n\n      require(\n        unstakeAt >= previousRequest.unstakeAt,\n        \"Unstake request time must be greater or equal to previous unstake request\"\n      );\n\n      if (previousRequest.next != 0) {\n        UnstakeRequest storage nextRequest = unstakeRequests[previousRequest.next];\n        require(\n          nextRequest.unstakeAt > unstakeAt,\n          \"Next unstake request time must be greater than new unstake request time\"\n        );\n      }\n\n      // Note: We previously had an `id` variable that was assigned immediately to `previousId`.\n      //   It was removed in order to save some memory and previousId used instead.\n      //   This makes the next section slightly harder to read but you can read \"previousId\" as \"newId\" instead.\n\n      // get next available unstake request id. our new unstake request becomes previous for the next loop\n      previousId = ++lastUnstakeRequestId;\n\n      unstakeRequests[previousId] = UnstakeRequest(\n        requestedAmount,\n        unstakeAt,\n        contractAddress,\n        msg.sender,\n        previousRequest.next\n      );\n\n      // point to our new unstake request\n      previousRequest.next = previousId;\n\n      emit UnstakeRequested(contractAddress, msg.sender, requestedAmount, unstakeAt);\n\n      // increase pending unstake requests total so we keep track of final stake\n      uint newPending = staker.pendingUnstakeRequestsTotal[contractAddress].add(requestedAmount);\n      staker.pendingUnstakeRequestsTotal[contractAddress] = newPending;\n\n      // update the reference to the unstake request at target index for the next loop\n      previousRequest = unstakeRequests[previousId];\n    }\n  }\n\n  function withdrawReward(address stakerAddress) external whenNotPausedAndInitialized {\n\n    uint amount = stakers[stakerAddress].reward;\n    stakers[stakerAddress].reward = 0;\n\n    token.transfer(stakerAddress, amount);\n\n    emit RewardWithdrawn(stakerAddress, amount);\n  }\n\n  function pushBurn(\n    address contractAddress, uint amount\n  ) public onlyInternal whenNotPausedAndInitialized noPendingBurns {\n\n    address[] memory contractAddresses = new address[](1);\n    contractAddresses[0] = contractAddress;\n    _pushRewards(contractAddresses, true);\n\n    burn.amount = amount;\n    burn.burnedAt = now;\n    burn.contractAddress = contractAddress;\n\n    emit BurnRequested(contractAddress, amount);\n  }\n\n  function _getCurrentRewardsRound() internal view returns (uint) {\n\n    uint roundDuration = REWARD_ROUND_DURATION;\n    uint startTime = REWARD_ROUNDS_START;\n\n    require(startTime != 0, \"REWARD_ROUNDS_START is not initialized\");\n\n    return now <= startTime ? 0 : (now - startTime) / roundDuration;\n  }\n\n  function getCurrentRewardsRound() external view returns (uint) {\n    return _getCurrentRewardsRound();\n  }\n\n  /**\n   * @dev Pushes accumulated rewards to the processing queue.\n   */\n  function _pushRewards(address[] memory contractAddresses, bool skipRoundCheck) internal {\n\n    uint currentRound = _getCurrentRewardsRound();\n    uint lastRewardIdCounter = lastRewardId;\n    uint pushedRewards = 0;\n\n    for (uint i = 0; i < contractAddresses.length; i++) {\n\n      address contractAddress = contractAddresses[i];\n      ContractReward storage contractRewards = accumulatedRewards[contractAddress];\n      uint lastRound = contractRewards.lastDistributionRound;\n      uint amount = contractRewards.amount;\n\n      bool shouldPush = amount > 0 && (skipRoundCheck || currentRound > lastRound);\n\n      if (!shouldPush) {\n        // prevent unintended distribution of the first reward in round\n        if (lastRound != currentRound) {\n          contractRewards.lastDistributionRound = currentRound;\n        }\n        continue;\n      }\n\n      rewards[++lastRewardIdCounter] = Reward(amount, now, contractAddress);\n      emit RewardRequested(contractAddress, amount);\n\n      contractRewards.amount = 0;\n      contractRewards.lastDistributionRound = currentRound;\n      ++pushedRewards;\n\n      if (pushedRewards == 1 && firstReward == 0) {\n        firstReward = lastRewardIdCounter;\n      }\n    }\n\n    if (pushedRewards != 0) {\n      lastRewardId = lastRewardIdCounter;\n    }\n  }\n\n  /**\n   * @dev External function for pushing accumulated rewards in the processing queue.\n   * @dev `_pushRewards` checks the current round and will only push if rewards can be distributed.\n   */\n  function pushRewards(address[] calldata contractAddresses) external whenNotPausedAndInitialized {\n    _pushRewards(contractAddresses, false);\n  }\n\n  /**\n   * @dev Add reward for contract. Automatically triggers distribution if enough time has passed.\n   */\n  function accumulateReward(address contractAddress, uint amount) external onlyInternal whenNotPausedAndInitialized {\n\n    // will push rewards if needed\n    address[] memory contractAddresses = new address[](1);\n    contractAddresses[0] = contractAddress;\n    _pushRewards(contractAddresses, false);\n\n    ContractReward storage contractRewards = accumulatedRewards[contractAddress];\n    contractRewards.amount = contractRewards.amount.add(amount);\n    emit RewardAdded(contractAddress, amount);\n  }\n\n  function processPendingActions(uint maxIterations) public whenNotPausedAndInitialized returns (bool finished) {\n    (finished,) = _processPendingActions(maxIterations);\n  }\n\n  function processPendingActionsReturnLeft(uint maxIterations) public whenNotPausedAndInitialized returns (bool finished, uint iterationsLeft) {\n    (finished, iterationsLeft) = _processPendingActions(maxIterations);\n  }\n\n  function _processPendingActions(uint maxIterations) public whenNotPausedAndInitialized returns (bool finished, uint iterationsLeft) {\n\n    iterationsLeft = maxIterations;\n\n    while (true) {\n\n      uint firstUnstakeRequestIndex = unstakeRequests[0].next;\n      UnstakeRequest storage unstakeRequest = unstakeRequests[firstUnstakeRequestIndex];\n      Reward storage reward = rewards[firstReward];\n\n      // read storage and cache in memory\n      uint burnedAt = burn.burnedAt;\n      uint rewardedAt = reward.rewardedAt;\n      uint unstakeAt = unstakeRequest.unstakeAt;\n\n      bool canUnstake = firstUnstakeRequestIndex > 0 && unstakeAt <= now;\n      bool canBurn = burnedAt != 0;\n      bool canReward = firstReward != 0;\n\n      if (!canBurn && !canUnstake && !canReward) {\n        // everything is processed\n        break;\n      }\n\n      if (\n        canBurn &&\n        (!canUnstake || burnedAt < unstakeAt) &&\n        (!canReward || burnedAt < rewardedAt)\n      ) {\n\n        (finished, iterationsLeft) = _processBurn(iterationsLeft);\n\n        if (!finished) {\n          emit PendingActionsProcessed(false);\n          return (false, iterationsLeft);\n        }\n\n        continue;\n      }\n\n      if (\n        canUnstake &&\n        (!canReward || unstakeAt < rewardedAt)\n      ) {\n\n        // _processFirstUnstakeRequest is O(1) so we'll handle the iteration checks here\n        if (iterationsLeft == 0) {\n          emit PendingActionsProcessed(false);\n          return (false, iterationsLeft);\n        }\n\n        _processFirstUnstakeRequest();\n        --iterationsLeft;\n        continue;\n      }\n\n      (finished, iterationsLeft) = _processFirstReward(iterationsLeft);\n\n      if (!finished) {\n        emit PendingActionsProcessed(false);\n        return (false, iterationsLeft);\n      }\n    }\n\n    // everything is processed!\n    emit PendingActionsProcessed(true);\n    return (true, iterationsLeft);\n  }\n\n  function _processBurn(uint maxIterations) internal returns (bool finished, uint iterationsLeft) {\n\n    iterationsLeft = maxIterations;\n\n    address _contractAddress = burn.contractAddress;\n    uint _stakedOnContract;\n\n    (_stakedOnContract, finished, iterationsLeft) = _calculateContractStake(_contractAddress, iterationsLeft);\n\n    if (!finished) {\n      return (false, iterationsLeft);\n    }\n\n    address[] storage _contractStakers = contractStakers[_contractAddress];\n    uint _stakerCount = _contractStakers.length;\n\n    uint _totalBurnAmount = burn.amount;\n    uint _actualBurnAmount = contractBurned;\n\n    if (_totalBurnAmount > _stakedOnContract) {\n      _totalBurnAmount = _stakedOnContract;\n    }\n\n    for (uint i = processedToStakerIndex; i < _stakerCount; i++) {\n\n      if (iterationsLeft == 0) {\n        contractBurned = _actualBurnAmount;\n        processedToStakerIndex = i;\n        return (false, iterationsLeft);\n      }\n\n      --iterationsLeft;\n\n      Staker storage staker = stakers[_contractStakers[i]];\n      uint _stakerBurnAmount;\n      uint _newStake;\n\n      (_stakerBurnAmount, _newStake) = _burnStaker(staker, _contractAddress, _stakedOnContract, _totalBurnAmount);\n      _actualBurnAmount = _actualBurnAmount.add(_stakerBurnAmount);\n\n      if (_newStake != 0) {\n        continue;\n      }\n\n      // if we got here, the stake is explicitly set to 0\n      // the staker is removed from the contract stakers array\n      // and we will add the staker back if he stakes again\n      staker.isInContractStakers[_contractAddress] = false;\n      _contractStakers[i] = _contractStakers[_stakerCount - 1];\n      _contractStakers.pop();\n\n      // i-- might underflow to MAX_UINT\n      // but that's fine since it will be incremented back to 0 on the next loop\n      i--;\n      _stakerCount--;\n    }\n\n    delete burn;\n    contractBurned = 0;\n    processedToStakerIndex = 0;\n    isContractStakeCalculated = false;\n\n    token.burn(_actualBurnAmount);\n    emit Burned(_contractAddress, _actualBurnAmount, _stakedOnContract);\n\n    return (true, iterationsLeft);\n  }\n\n  function _burnStaker(\n    Staker storage staker, address _contractAddress, uint _stakedOnContract, uint _totalBurnAmount\n  ) internal returns (\n    uint _stakerBurnAmount, uint _newStake\n  ) {\n\n    uint _currentDeposit;\n    uint _currentStake;\n\n    // silence compiler warning\n    _newStake = 0;\n\n    // do we need a storage read?\n    if (_stakedOnContract != 0) {\n      _currentDeposit = staker.deposit;\n      _currentStake = staker.stakes[_contractAddress];\n\n      if (_currentStake > _currentDeposit) {\n        _currentStake = _currentDeposit;\n      }\n    }\n\n    if (_stakedOnContract != _totalBurnAmount) {\n      // formula: staker_burn = staker_stake / total_contract_stake * contract_burn\n      // reordered for precision loss prevention\n      _stakerBurnAmount = _currentStake.mul(_totalBurnAmount).div(_stakedOnContract);\n      _newStake = _currentStake.sub(_stakerBurnAmount);\n    } else {\n      // it's the whole stake\n      _stakerBurnAmount = _currentStake;\n    }\n\n    if (_stakerBurnAmount != 0) {\n      staker.deposit = _currentDeposit.sub(_stakerBurnAmount);\n    }\n\n    staker.stakes[_contractAddress] = _newStake;\n  }\n\n  function _calculateContractStake(\n    address _contractAddress, uint maxIterations\n  ) internal returns (\n    uint _stakedOnContract, bool finished, uint iterationsLeft\n  ) {\n\n    iterationsLeft = maxIterations;\n\n    if (isContractStakeCalculated) {\n      // use previously calculated staked amount\n      return (contractStaked, true, iterationsLeft);\n    }\n\n    address[] storage _contractStakers = contractStakers[_contractAddress];\n    uint _stakerCount = _contractStakers.length;\n    uint startIndex = processedToStakerIndex;\n\n    if (startIndex != 0) {\n      _stakedOnContract = contractStaked;\n    }\n\n    // calculate amount staked on contract\n    for (uint i = startIndex; i < _stakerCount; i++) {\n\n      if (iterationsLeft == 0) {\n        processedToStakerIndex = i;\n        contractStaked = _stakedOnContract;\n        return (_stakedOnContract, false, iterationsLeft);\n      }\n\n      --iterationsLeft;\n\n      Staker storage staker = stakers[_contractStakers[i]];\n      uint deposit = staker.deposit;\n      uint stake = staker.stakes[_contractAddress];\n      stake = deposit < stake ? deposit : stake;\n      _stakedOnContract = _stakedOnContract.add(stake);\n    }\n\n    contractStaked = _stakedOnContract;\n    isContractStakeCalculated = true;\n    processedToStakerIndex = 0;\n\n    return (_stakedOnContract, true, iterationsLeft);\n  }\n\n  function _processFirstUnstakeRequest() internal {\n\n    uint firstRequest = unstakeRequests[0].next;\n    UnstakeRequest storage unstakeRequest = unstakeRequests[firstRequest];\n    address stakerAddress = unstakeRequest.stakerAddress;\n    Staker storage staker = stakers[stakerAddress];\n\n    address contractAddress = unstakeRequest.contractAddress;\n    uint deposit = staker.deposit;\n    uint initialStake = staker.stakes[contractAddress];\n    uint stake = deposit < initialStake ? deposit : initialStake;\n\n    uint requestedAmount = unstakeRequest.amount;\n    uint actualUnstakedAmount = stake < requestedAmount ? stake : requestedAmount;\n    staker.stakes[contractAddress] = stake.sub(actualUnstakedAmount);\n\n    uint pendingUnstakeRequestsTotal = staker.pendingUnstakeRequestsTotal[contractAddress];\n    staker.pendingUnstakeRequestsTotal[contractAddress] = pendingUnstakeRequestsTotal.sub(requestedAmount);\n\n    // update pointer to first unstake request\n    unstakeRequests[0].next = unstakeRequest.next;\n    delete unstakeRequests[firstRequest];\n\n    emit Unstaked(contractAddress, stakerAddress, requestedAmount);\n  }\n\n  function _processFirstReward(uint maxIterations) internal returns (bool finished, uint iterationsLeft) {\n\n    iterationsLeft = maxIterations;\n\n    Reward storage reward = rewards[firstReward];\n    address _contractAddress = reward.contractAddress;\n    uint _totalRewardAmount = reward.amount;\n\n    uint _stakedOnContract;\n\n    (_stakedOnContract, finished, iterationsLeft) = _calculateContractStake(_contractAddress, iterationsLeft);\n\n    if (!finished) {\n      return (false, iterationsLeft);\n    }\n\n    address[] storage _contractStakers = contractStakers[_contractAddress];\n    uint _stakerCount = _contractStakers.length;\n    uint _actualRewardAmount = contractRewarded;\n\n    for (uint i = processedToStakerIndex; i < _stakerCount; i++) {\n\n      if (iterationsLeft == 0) {\n        contractRewarded = _actualRewardAmount;\n        processedToStakerIndex = i;\n        return (false, iterationsLeft);\n      }\n\n      --iterationsLeft;\n\n      address _stakerAddress = _contractStakers[i];\n\n      (uint _stakerRewardAmount, uint _stake) = _rewardStaker(\n        _stakerAddress, _contractAddress, _totalRewardAmount, _stakedOnContract\n      );\n\n      // remove 0-amount stakers, similar to what we're doing when processing burns\n      if (_stake == 0) {\n\n        // mark the user as not present in contract stakers array\n        Staker storage staker = stakers[_stakerAddress];\n        staker.isInContractStakers[_contractAddress] = false;\n\n        // remove the staker from the contract stakers array\n        _contractStakers[i] = _contractStakers[_stakerCount - 1];\n        _contractStakers.pop();\n        i--;\n        _stakerCount--;\n\n        // since the stake is 0, there's no reward to give\n        continue;\n      }\n\n      _actualRewardAmount = _actualRewardAmount.add(_stakerRewardAmount);\n    }\n\n    delete rewards[firstReward];\n    contractRewarded = 0;\n    processedToStakerIndex = 0;\n    isContractStakeCalculated = false;\n\n    if (++firstReward > lastRewardId) {\n      firstReward = 0;\n    }\n\n    tokenController.mint(address(this), _actualRewardAmount);\n    emit Rewarded(_contractAddress, _actualRewardAmount, _stakedOnContract);\n\n    return (true, iterationsLeft);\n  }\n\n  function _rewardStaker(\n    address stakerAddress, address contractAddress, uint totalRewardAmount, uint totalStakedOnContract\n  ) internal returns (uint rewardedAmount, uint stake) {\n\n    Staker storage staker = stakers[stakerAddress];\n    uint deposit = staker.deposit;\n    stake = staker.stakes[contractAddress];\n\n    if (stake > deposit) {\n      stake = deposit;\n    }\n\n    // prevent division by zero and set stake to zero\n    if (totalStakedOnContract == 0 || stake == 0) {\n      staker.stakes[contractAddress] = 0;\n      return (0, 0);\n    }\n\n    // reward = staker_stake / total_contract_stake * total_reward\n    rewardedAmount = totalRewardAmount.mul(stake).div(totalStakedOnContract);\n    staker.reward = staker.reward.add(rewardedAmount);\n  }\n\n  function updateUintParameters(bytes8 code, uint value) external onlyGovernance {\n\n    if (code == \"MIN_STAK\") {\n      MIN_STAKE = value;\n      return;\n    }\n\n    if (code == \"MAX_EXPO\") {\n      MAX_EXPOSURE = value;\n      return;\n    }\n\n    if (code == \"MIN_UNST\") {\n      MIN_UNSTAKE = value;\n      return;\n    }\n\n    if (code == \"UNST_LKT\") {\n      UNSTAKE_LOCK_TIME = value;\n      return;\n    }\n  }\n\n  function initialize() public {\n    require(!initialized, \"Contract is already initialized\");\n    tokenController.addToWhitelist(address(this));\n    initialized = true;\n  }\n\n  function changeDependentContractAddress() public {\n\n    token = NXMToken(master.tokenAddress());\n    tokenController = TokenController(master.getLatestAddress(\"TC\"));\n\n    if (!initialized) {\n      initialize();\n    }\n  }\n\n  event LockTimeMigrationCompleted(\n    bool finished,\n    uint startUnstakeIndex,\n    uint endUnstakeIndex,\n    uint iterationsLeft\n  );\n\n  function migratePendingUnstakesToNewLockTime(uint iterations) external {\n\n    uint migrationStatus;\n    bytes32 migrationStatusSlot = keccak256(\"nexusmutual.pooledstaking.LOCK_TIME_MIGRATION_STAGE\");\n    assembly { migrationStatus := sload(migrationStatusSlot) }\n    require(migrationStatus == 0, 'PooledStaking: Migration finished');\n\n    uint migrationRequestId;\n    bytes32 migrationRequestIdSlot = keccak256(\"nexusmutual.pooledstaking.LOCK_TIME_MIGRATION_FIRST_ID_POINTER\");\n    assembly { migrationRequestId := sload(migrationRequestIdSlot) }\n\n    bool finished = false;\n    uint next = migrationRequestId == 0 ? unstakeRequests[0].next : migrationRequestId;\n    uint firstId = next;\n\n    while (iterations > 0) {\n\n      iterations--;\n\n      UnstakeRequest storage unstakeRequest = unstakeRequests[next];\n      uint newUnstakeTime = unstakeRequest.unstakeAt - 60 days;\n\n      if (next > 0 && newUnstakeTime <= now) {\n        _processFirstUnstakeRequest();\n        next = unstakeRequests[0].next;\n        continue;\n      }\n\n      if (next > 0) {\n        unstakeRequest.unstakeAt = newUnstakeTime;\n        next = unstakeRequest.next;\n        continue;\n      }\n\n      finished = true;\n      break;\n    }\n\n    if (finished) {\n\n      // finished migration\n      UNSTAKE_LOCK_TIME = 30 days;\n      assembly { sstore(migrationStatusSlot, 1) }\n      assembly { sstore(migrationRequestIdSlot, 0) }\n\n    } else {\n\n      // store progress\n      assembly { sstore(migrationRequestIdSlot, next) }\n\n    }\n\n    emit LockTimeMigrationCompleted(finished, firstId, next, iterations);\n  }\n}\n"}}}