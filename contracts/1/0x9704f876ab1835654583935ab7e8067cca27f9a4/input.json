{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Tier1FarmController.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity >=0.4.22 <0.8.0;\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns(uint supply);\r\n\r\n    function balanceOf(address _owner) external view returns(uint balance);\r\n\r\n    function transfer(address _to, uint _value) external returns(bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\r\n\r\n    function approve(address _spender, uint _value) external returns(bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\r\n\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\ninterface Tier2StakingInterface {\r\n\r\n  //staked balance info\r\n  function depositBalances(address _owner, address token) external view returns(uint256 balance);\r\n  function getStakedBalances(address _owner, address token) external view returns(uint256 balance);\r\n  function getStakedPoolBalanceByUser(address _owner, address tokenAddress) external view returns(uint256);\r\n\r\n  //basic info\r\n  function tokenToFarmMapping(address tokenAddress) external view returns(address stakingContractAddress);\r\n  function stakingContracts(string calldata platformName) external view returns(address stakingAddress);\r\n  function stakingContractsStakingToken(string calldata platformName) external view returns(address tokenAddress);\r\n  function platformToken() external view returns(address tokenAddress);\r\n  function owner() external view returns(address ownerAddress);\r\n\r\n  //actions\r\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable external returns (bool);\r\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) payable external returns(bool);\r\n  function addOrEditStakingContract(string calldata name, address stakingAddress, address stakingToken ) external  returns (bool);\r\n  function updateCommission(uint amount) external  returns(bool);\r\n  function changeOwner(address payable newOwner) external returns (bool);\r\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) external returns(bool);\r\n  function kill() virtual external;\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal view returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal view returns (uint256) {\r\n    assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n\r\n\r\n  function sub(uint256 a, uint256 b) internal view returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal view returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract Tier1FarmController{\r\n\r\n  using SafeMath\r\n    for uint256;\r\n\r\n\r\n  address payable public owner;\r\n  address ETH_TOKEN_ADDRESS  = address(0x0);\r\n  mapping (string => address) public tier2StakingContracts;\r\n  uint256 public commission  = 400; // Default is 4 percent\r\n\r\n\r\n  string public farmName = 'Tier1Aggregator';\r\n  mapping (address => uint256) totalAmountStaked;\r\n\r\n  modifier onlyOwner() {\r\n        if (msg.sender == owner) _;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  constructor() public payable {\r\n        tier2StakingContracts[\"FARM\"] = 0x618fDCFF3Cca243c12E6b508D9d8a6fF9018325c;\r\n        \r\n\r\n        owner= msg.sender;\r\n\r\n  }\r\n\r\n\r\n  fallback() external payable {\r\n\r\n\r\n  }\r\n\r\n\r\n\r\n  function addOrEditTier2ChildStakingContract(string memory name, address stakingAddress ) public onlyOwner returns (bool){\r\n\r\n    tier2StakingContracts[name] = stakingAddress;\r\n    return true;\r\n\r\n  }\r\n\r\n  function addOrEditTier2ChildsChildStakingContract(address tier2Contract, string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\r\n\r\n    Tier2StakingInterface tier2Con = Tier2StakingInterface(tier2Contract);\r\n    tier2Con.addOrEditStakingContract(name, stakingAddress, stakingToken);\r\n    return true;\r\n\r\n  }\r\n\r\n  function updateCommissionTier2(address tier2Contract, uint amount) public onlyOwner returns(bool){\r\n    Tier2StakingInterface tier2Con = Tier2StakingInterface(tier2Contract);\r\n    tier2Con.updateCommission(amount);\r\n    return true;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  function deposit(string memory tier2ContractName, address tokenAddress, uint256 amount) payable public returns (bool){\r\n\r\n    address tier2Contract = tier2StakingContracts[tier2ContractName];\r\n    ERC20 thisToken = ERC20(tokenAddress);\r\n    require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\r\n    //approve the tier2 contract to handle tokens from this account\r\n    thisToken.approve(tier2Contract, amount.mul(100));\r\n\r\n    Tier2StakingInterface tier2Con = Tier2StakingInterface(tier2Contract);\r\n    tier2Con.deposit(tokenAddress, amount, msg.sender);\r\n      return true;\r\n   }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  function withdraw(string memory tier2ContractName, address tokenAddress, uint256 amount) payable public returns(bool){\r\n\r\n        address tier2Contract = tier2StakingContracts[tier2ContractName];\r\n        ERC20 thisToken = ERC20(tokenAddress);\r\n        Tier2StakingInterface tier2Con = Tier2StakingInterface(tier2Contract);\r\n        tier2Con.withdraw(tokenAddress, amount, msg.sender);\r\n        return true;\r\n\r\n   }\r\n\r\n\r\n   function changeTier2Owner(address payable tier2Contract, address payable newOwner) onlyOwner public returns (bool){\r\n     Tier2StakingInterface tier2Con = Tier2StakingInterface(tier2Contract);\r\n     tier2Con.changeOwner(newOwner);\r\n     return true;\r\n   }\r\n\r\n   function changeOwner(address payable newOwner) onlyOwner public returns (bool){\r\n     owner = newOwner;\r\n     return true;\r\n   }\r\n\r\n\r\n  function adminEmergencyWithdrawTokensTier2(address payable tier2Contract, address token, uint amount, address payable destination) public onlyOwner returns(bool) {\r\n    Tier2StakingInterface tier2Con = Tier2StakingInterface(tier2Contract);\r\n    tier2Con.adminEmergencyWithdrawTokens(token, amount, destination);\r\n    return true;\r\n  }\r\n\r\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\r\n\r\n\r\n\r\n      if (address(token) == ETH_TOKEN_ADDRESS) {\r\n          destination.transfer(amount);\r\n      }\r\n      else {\r\n          ERC20 tokenToken = ERC20(token);\r\n          require(tokenToken.transfer(destination, amount));\r\n      }\r\n\r\n\r\n\r\n\r\n      return true;\r\n  }\r\n\r\n\r\n\r\nfunction getStakedPoolBalanceByUser(string memory tier2ContractName, address _owner, address tokenAddress) public view returns(uint256){\r\n  address tier2Contract = tier2StakingContracts[tier2ContractName];\r\n  ERC20 thisToken = ERC20(tokenAddress);\r\n  Tier2StakingInterface tier2Con = Tier2StakingInterface(tier2Contract);\r\n  uint balance = tier2Con.getStakedPoolBalanceByUser(_owner, tokenAddress);\r\n  return balance;\r\n\r\n}\r\n\r\nfunction getDepositBalanceByUser(string calldata tier2ContractName, address _owner, address token) external view returns(uint256 ){\r\n  address tier2Contract = tier2StakingContracts[tier2ContractName];\r\n  ERC20 thisToken = ERC20(token);\r\n  Tier2StakingInterface tier2Con = Tier2StakingInterface(tier2Contract);\r\n  uint balance = tier2Con.depositBalances(_owner, token);\r\n  return balance;\r\n}\r\n\r\n\r\n function kill() virtual public onlyOwner {\r\n\r\n         selfdestruct(owner);\r\n\r\n }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}"}}}