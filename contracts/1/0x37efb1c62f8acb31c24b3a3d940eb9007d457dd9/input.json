{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ITorro.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\r\npragma solidity 0.6.6;\r\n\r\n/// @title Interface for ERC-20 Torro governing token.\r\n/// @notice ERC-20 token.\r\n/// @author ORayskiy - @robitnik_TorroDao\r\ninterface ITorro {\r\n\r\n  // Initializer.\r\n\r\n  /// @notice Initializes governing token.\r\n  /// @param dao_ address of cloned DAO.\r\n  /// @param factory_ address of factory.\r\n  /// @param supply_ total supply of tokens.\r\n  function initializeCustom(address dao_, address factory_, uint256 supply_) external;\r\n\r\n  // Public calls.\r\n\r\n  /// @notice Token's name.\r\n  /// @return string name of the token.\r\n  function name() external view returns (string memory);\r\n\r\n  /// @notice Token's symbol.\r\n  /// @return string symbol of the token.\r\n  function symbol() external view returns (string memory);\r\n\r\n  /// @notice Token's decimals.\r\n  /// @return uint8 demials of the token.\r\n  function decimals() external pure returns (uint8);\r\n\r\n  /// @notice Token's total supply.\r\n  /// @return uint256 total supply of the token.\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /// @notice Count of token holders.\r\n  /// @return uint256 number of token holders.\r\n  function holdersCount() external view returns (uint256);\r\n\r\n  /// @notice All token holders.\r\n  /// @return array of addresses of token holders.\r\n  function holders() external view returns (address[] memory);\r\n\r\n  /// @notice Available balance for address.\r\n  /// @param sender_ address to get available balance for.\r\n  /// @return uint256 amount of tokens available for given address.\r\n  function balanceOf(address sender_) external view returns (uint256);\r\n\r\n  /// @notice Staked balance for address.\r\n  /// @param sender_ address to get staked balance for.\r\n  /// @return uint256 amount of staked tokens for given address.\r\n  function stakedOf(address sender_) external view returns (uint256);\r\n\r\n  /// @notice Total balance for address = available + staked.\r\n  /// @param sender_ address to get total balance for.\r\n  /// @return uint256 total amount of tokens for given address.\r\n  function totalOf(address sender_) external view returns (uint256);\r\n\r\n  /// @notice Spending allowance.\r\n  /// @param owner_ token owner address.\r\n  /// @param spender_ token spender address.\r\n  /// @return uint256 amount of owner's tokens that spender can use.\r\n  function allowance(address owner_, address spender_) external view returns (uint256);\r\n\r\n  /// @notice Unstaked supply of token.\r\n  /// @return uint256 amount of tokens in circulation that are not staked.\r\n  function unstakedSupply() external view returns (uint256);\r\n\r\n  /// @notice Staked supply of token.\r\n  /// @return uint256 amount of tokens in circulation that are staked.\r\n  function stakedSupply() external view returns (uint256);\r\n\r\n  // Public transactions.\r\n\r\n  /// @notice Transfer tokens to recipient.\r\n  /// @param recipient_ address of tokens' recipient.\r\n  /// @param amount_ amount of tokens to transfer.\r\n  /// @return bool true if successful.\r\n  function transfer(address recipient_, uint256 amount_) external returns (bool);\r\n\r\n  /// @notice Approve spender to spend an allowance.\r\n  /// @param spender_ address that will be allowed to spend specified amount of tokens.\r\n  /// @param amount_ amount of tokens that spender can spend.\r\n  /// @return bool true if successful.\r\n  function approve(address spender_, uint256 amount_) external returns (bool);\r\n\r\n  /// @notice Approves DAO to spend tokens.\r\n  /// @param owner_ address whose tokens DAO can spend.\r\n  /// @param amount_ amount of tokens that DAO can spend.\r\n  /// @return bool true if successful.\r\n  function approveDao(address owner_, uint256 amount_) external returns (bool);\r\n\r\n  /// @notice Transfers tokens from owner to recipient by approved spender.\r\n  /// @param owner_ address of tokens' owner whose tokens will be spent.\r\n  /// @param recipient_ address of recipient that will recieve tokens.\r\n  /// @param amount_ amount of tokens to be spent.\r\n  /// @return bool true if successful.\r\n  function transferFrom(address owner_, address recipient_, uint256 amount_) external returns (bool);\r\n\r\n  /// @notice Increases allowance for given spender.\r\n  /// @param spender_ spender to increase allowance for.\r\n  /// @param addedValue_ extra amount that spender can spend.\r\n  /// @return bool true if successful.\r\n  function increaseAllowance(address spender_, uint256 addedValue_) external returns (bool);\r\n\r\n  /// @notice Decreases allowance for given spender.\r\n  /// @param spender_ spender to decrease allowance for.\r\n  /// @param subtractedValue_ removed amount that spender can spend.\r\n  /// @return bool true if successful.\r\n  function decreaseAllowance(address spender_, uint256 subtractedValue_) external returns (bool);\r\n\r\n  /// @notice Stake tokens.\r\n  /// @param amount_ amount of tokens to be staked.\r\n  /// @return bool true if successful.\r\n  function stake(uint256 amount_) external returns (bool);\r\n\r\n  /// @notice Unstake tokens.\r\n  /// @param amount_ amount of tokens to be unstaked.\r\n  /// @return bool true if successful.\r\n  function unstake(uint256 amount_) external returns (bool);\r\n\r\n  /// @notice Functionality for DAO to add benefits for all stakers.\r\n  /// @param amount_ amount of wei to be shared among stakers.\r\n  function addBenefits(uint256 amount_) external;\r\n\r\n  /// @notice Sets DAO and Factory addresses.\r\n  /// @param dao_ DAO address that this token governs.\r\n  /// @param factory_ Factory address.\r\n  function setDaoFactoryAddresses(address dao_, address factory_) external;\r\n\r\n  /// @notice Pauses token functionality.\r\n  /// @param paused_ whether token functionality is paused.\r\n  function setPause(bool paused_) external;\r\n\r\n  /// @notice Sets whitelist address allowing it to make token operations when paused.\r\n  /// @param whitelistAddress_ address to whitelist.\r\n  function setWhitelistAddress(address whitelistAddress_) external;\r\n\r\n  /// @notice Functionality for owner to burn tokens.\r\n  /// @param amount_ amount of tokens to burn.\r\n  function burn(uint256 amount_) external;\r\n}\r\n"
    },
    "SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "TorroIco.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\r\npragma solidity 0.6.6;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./ITorro.sol\";\r\n\r\n/// @author ORayskiy - @robitnik_TorroDao\r\ncontract TorroIco {\r\n  using SafeMath for uint256;\r\n\r\n  ITorro private _token;\r\n  address private _owner;\r\n  uint256 private _startRate;\r\n  uint256 private _rateDecrease;\r\n  uint256 private _currentRate;\r\n  uint256 private _startingBalance;\r\n  uint256 private _rateDecreaseBalanceStep;\r\n  uint256 private _rateDecreaseBalance;\r\n  bool private _isClosed;\r\n  uint256 private _weiLimit;\r\n  mapping (address => uint256) private _addressSpent;\r\n\r\n  event Purchase();\r\n\r\n  // startRate = 180\r\n  // rateDecrease = 10\r\n  // rateSteps = 3\r\n  // startingBalance = 60,000\r\n  // ethLimit = 10\r\n  constructor(address token_, uint256 startRate_, uint256 rateDecrease_, uint256 rateSteps_, uint256 startingBalance_, uint256 ethLimit_) public {\r\n    require(startRate_ > 0);\r\n    require(token_ != address(0x0));\r\n    _token = ITorro(token_);\r\n    _owner = msg.sender;\r\n    _startRate = startRate_;\r\n    _rateDecrease = rateDecrease_;\r\n    _currentRate = _startRate;\r\n    _startingBalance = startingBalance_.mul(10**uint256(_token.decimals()));\r\n    _rateDecreaseBalanceStep = _startingBalance.div(rateSteps_);\r\n    _rateDecreaseBalance = _startingBalance.sub(_rateDecreaseBalanceStep);\r\n    _weiLimit = ethLimit_.mul(1 ether);\r\n    _isClosed = true;\r\n  }\r\n\r\n  receive() external payable {\r\n    require(_isClosed == false);\r\n    require(msg.sender != address(0x0));\r\n\r\n    uint256 weiAmount = msg.value;\r\n    require(weiAmount > 0);\r\n\r\n    uint256 alreadySpent = _addressSpent[msg.sender];\r\n    uint256 afterSpent = alreadySpent.add(weiAmount);\r\n    require(afterSpent <= _weiLimit);\r\n\r\n    (uint256 tokens, uint256 refund) = _getTokenAmount(weiAmount);\r\n\r\n    _token.transfer(msg.sender, tokens);\r\n\r\n    if (refund > 0) {\r\n      payable(msg.sender).transfer(refund);\r\n    }\r\n\r\n    _addressSpent[msg.sender] = afterSpent;\r\n\r\n    emit Purchase();\r\n  }\r\n\r\n  function currentRate() public view returns (uint256) {\r\n    return _currentRate;\r\n  }\r\n\r\n  function tokensLeftAtCurrentRate() public view returns (uint256) {\r\n    uint256 balance = _token.balanceOf(address(this));\r\n    if (balance < _rateDecreaseBalance) {\r\n      return balance;\r\n    }\r\n    return balance.sub(_rateDecreaseBalance);\r\n  }\r\n\r\n  function isClosed() public view returns (bool) {\r\n    return _isClosed;\r\n  }\r\n\r\n  function _getTokenAmount(uint256 weiAmount_) private returns (uint256, uint256) {\r\n    uint256 amount = weiAmount_.mul(_currentRate);\r\n    uint256 balance = _token.balanceOf(address(this));\r\n    if (amount > balance || balance.sub(amount) <= _rateDecreaseBalance) {\r\n      uint256 hiRateAmount = balance.sub(_rateDecreaseBalance);\r\n      uint256 hiRateWeiAmount = hiRateAmount.div(_currentRate);\r\n      uint256 leftOverWeiAmount = weiAmount_.sub(hiRateWeiAmount);\r\n\r\n      bool proceed = _decreaseRate();\r\n      if (!proceed) {\r\n        return (hiRateAmount, leftOverWeiAmount);\r\n      }\r\n      uint256 loRateAmount = leftOverWeiAmount.mul(_currentRate);\r\n      return (hiRateAmount.add(loRateAmount), 0);\r\n    }\r\n    return (amount, 0);\r\n  }\r\n\r\n  function _decreaseRate() private returns (bool) {\r\n    if (_rateDecreaseBalance == 0) {\r\n      _currentRate = 0;\r\n      _isClosed = true;\r\n      return false;\r\n    }\r\n    _rateDecreaseBalance = _rateDecreaseBalance.sub(_rateDecreaseBalanceStep);\r\n    _currentRate = _currentRate.sub(_rateDecrease);\r\n    return true;\r\n  }\r\n\r\n  function open() public {\r\n    require(msg.sender == _owner);\r\n    _isClosed = false;\r\n  }\r\n\r\n  function close() public {\r\n    require(msg.sender == _owner);\r\n    payable(_owner).transfer(address(this).balance);\r\n    uint256 tokensLeft = _token.balanceOf(address(this));\r\n    if (tokensLeft > 0) {\r\n      _token.transfer(msg.sender, tokensLeft);\r\n    }\r\n    _isClosed = true;\r\n  }\r\n}\r\n"
    }
  }
}