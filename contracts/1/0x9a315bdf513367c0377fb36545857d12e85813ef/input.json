{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "OlympusTreasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n// File: interfaces/IOlympusAuthority.sol\r\n\r\n\r\npragma solidity =0.7.5;\r\n\r\ninterface IOlympusAuthority {\r\n    /* ========== EVENTS ========== */\r\n    \r\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\r\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n\r\n    event GovernorPulled(address indexed from, address indexed to);\r\n    event GuardianPulled(address indexed from, address indexed to);\r\n    event PolicyPulled(address indexed from, address indexed to);\r\n    event VaultPulled(address indexed from, address indexed to);\r\n\r\n    /* ========== VIEW ========== */\r\n    \r\n    function governor() external view returns (address);\r\n    function guardian() external view returns (address);\r\n    function policy() external view returns (address);\r\n    function vault() external view returns (address);\r\n}\r\n// File: types/OlympusAccessControlled.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\nabstract contract OlympusAccessControlled {\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\r\n\r\n    string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    IOlympusAuthority public authority;\r\n\r\n\r\n    /* ========== Constructor ========== */\r\n\r\n    constructor(IOlympusAuthority _authority) {\r\n        authority = _authority;\r\n        emit AuthorityUpdated(_authority);\r\n    }\r\n    \r\n\r\n    /* ========== MODIFIERS ========== */\r\n    \r\n    modifier onlyGovernor() {\r\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyGuardian() {\r\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPolicy() {\r\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n\r\n    modifier onlyVault() {\r\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    /* ========== GOV ONLY ========== */\r\n    \r\n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\r\n        authority = _newAuthority;\r\n        emit AuthorityUpdated(_newAuthority);\r\n    }\r\n}\r\n\r\n// File: interfaces/ITreasury.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface ITreasury {\r\n    function deposit(\r\n        uint256 _amount,\r\n        address _token,\r\n        uint256 _profit\r\n    ) external returns (uint256);\r\n\r\n    function withdraw(uint256 _amount, address _token) external;\r\n\r\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\r\n\r\n    function mint(address _recipient, uint256 _amount) external;\r\n\r\n    function manage(address _token, uint256 _amount) external;\r\n\r\n    function incurDebt(uint256 amount_, address token_) external;\r\n\r\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\r\n\r\n    function excessReserves() external view returns (uint256);\r\n\r\n    function baseSupply() external view returns (uint256);\r\n}\r\n\r\n// File: interfaces/IBondingCalculator.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface IBondingCalculator {\r\n    function markdown( address _LP ) external view returns ( uint );\r\n\r\n    function valuation( address pair_, uint amount_ ) external view returns ( uint _value );\r\n}\r\n// File: interfaces/IOwnable.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\ninterface IOwnable {\r\n  function owner() external view returns (address);\r\n\r\n  function renounceManagement() external;\r\n  \r\n  function pushManagement( address newOwner_ ) external;\r\n  \r\n  function pullManagement() external;\r\n}\r\n// File: interfaces/IERC20.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: interfaces/IsOHM.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\ninterface IsOHM is IERC20 {\r\n    function rebase( uint256 ohmProfit_, uint epoch_) external returns (uint256);\r\n\r\n    function circulatingSupply() external view returns (uint256);\r\n\r\n    function gonsForBalance( uint amount ) external view returns ( uint );\r\n\r\n    function balanceForGons( uint gons ) external view returns ( uint );\r\n\r\n    function index() external view returns ( uint );\r\n\r\n    function toG(uint amount) external view returns (uint);\r\n\r\n    function fromG(uint amount) external view returns (uint);\r\n\r\n     function changeDebt(\r\n        uint256 amount,\r\n        address debtor,\r\n        bool add\r\n    ) external;\r\n\r\n    function debtBalances(address _address) external view returns (uint256);\r\n\r\n}\r\n\r\n// File: interfaces/IOHM.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\ninterface IOHM is IERC20 {\r\n  function mint(address account_, uint256 amount_) external;\r\n\r\n  function burn(uint256 amount) external;\r\n\r\n  function burnFrom(address account_, uint256 amount_) external;\r\n}\r\n\r\n// File: interfaces/IERC20Metadata.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n// File: libraries/SafeERC20.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\r\n/// Taken from Solmate\r\nlibrary SafeERC20 {\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\r\n        );\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\r\n        );\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\r\n        );\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        (bool success, ) = to.call{value: amount}(new bytes(0));\r\n\r\n        require(success, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n// File: libraries/SafeMath.sol\r\n\r\n\r\npragma solidity ^0.7.5;\r\n\r\n\r\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    // Only used in the  BondingCalculator.sol\r\n    function sqrrt(uint256 a) internal pure returns (uint c) {\r\n        if (a > 3) {\r\n            c = a;\r\n            uint b = add( div( a, 2), 1 );\r\n            while (b < c) {\r\n                c = b;\r\n                b = div( add( div( a, b ), b), 2 );\r\n            }\r\n        } else if (a != 0) {\r\n            c = 1;\r\n        }\r\n    }\r\n\r\n}\r\n// File: Treasury.sol\r\n\r\n\r\npragma solidity ^0.7.5;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract OlympusTreasury is OlympusAccessControlled, ITreasury {\r\n    /* ========== DEPENDENCIES ========== */\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event Deposit(address indexed token, uint256 amount, uint256 value);\r\n    event Withdrawal(address indexed token, uint256 amount, uint256 value);\r\n    event CreateDebt(address indexed debtor, address indexed token, uint256 amount, uint256 value);\r\n    event RepayDebt(address indexed debtor, address indexed token, uint256 amount, uint256 value);\r\n    event Managed(address indexed token, uint256 amount);\r\n    event ReservesAudited(uint256 indexed totalReserves);\r\n    event Minted(address indexed caller, address indexed recipient, uint256 amount);\r\n    event PermissionQueued(STATUS indexed status, address queued);\r\n    event Permissioned(address addr, STATUS indexed status, bool result);\r\n\r\n    /* ========== DATA STRUCTURES ========== */\r\n\r\n    enum STATUS {\r\n        RESERVEDEPOSITOR,\r\n        RESERVESPENDER,\r\n        RESERVETOKEN,\r\n        RESERVEMANAGER,\r\n        LIQUIDITYDEPOSITOR,\r\n        LIQUIDITYTOKEN,\r\n        LIQUIDITYMANAGER,\r\n        RESERVEDEBTOR,\r\n        REWARDMANAGER,\r\n        SOHM,\r\n        OHMDEBTOR\r\n    }\r\n\r\n    struct Queue {\r\n        STATUS managing;\r\n        address toPermit;\r\n        address calculator;\r\n        uint256 timelockEnd;\r\n        bool nullify;\r\n        bool executed;\r\n    }\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    IOHM public immutable OHM;\r\n    IsOHM public sOHM;\r\n\r\n    mapping(STATUS => address[]) public registry;\r\n    mapping(STATUS => mapping(address => bool)) public permissions;\r\n    mapping(address => address) public bondCalculator;\r\n\r\n    mapping(address => uint256) public debtLimit;\r\n\r\n    uint256 public totalReserves;\r\n    uint256 public totalDebt;\r\n    uint256 public ohmDebt;\r\n\r\n    Queue[] public permissionQueue;\r\n    uint256 public immutable blocksNeededForQueue;\r\n\r\n    bool public timelockEnabled;\r\n    bool public initialized;\r\n\r\n    uint256 public onChainGovernanceTimelock;\r\n\r\n    string internal notAccepted = \"Treasury: not accepted\";\r\n    string internal notApproved = \"Treasury: not approved\";\r\n    string internal invalidToken = \"Treasury: invalid token\";\r\n    string internal insufficientReserves = \"Treasury: insufficient reserves\";\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(\r\n        address _ohm,\r\n        uint256 _timelock,\r\n        address _authority\r\n    ) OlympusAccessControlled(IOlympusAuthority(_authority)) {\r\n        require(_ohm != address(0), \"Zero address: OHM\");\r\n        OHM = IOHM(_ohm);\r\n\r\n        timelockEnabled = false;\r\n        initialized = false;\r\n        blocksNeededForQueue = _timelock;\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice allow approved address to deposit an asset for OHM\r\n     * @param _amount uint256\r\n     * @param _token address\r\n     * @param _profit uint256\r\n     * @return send_ uint256\r\n     */\r\n    function deposit(\r\n        uint256 _amount,\r\n        address _token,\r\n        uint256 _profit\r\n    ) external override returns (uint256 send_) {\r\n        if (permissions[STATUS.RESERVETOKEN][_token]) {\r\n            require(permissions[STATUS.RESERVEDEPOSITOR][msg.sender], notApproved);\r\n        } else if (permissions[STATUS.LIQUIDITYTOKEN][_token]) {\r\n            require(permissions[STATUS.LIQUIDITYDEPOSITOR][msg.sender], notApproved);\r\n        } else {\r\n            revert(invalidToken);\r\n        }\r\n\r\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        uint256 value = tokenValue(_token, _amount);\r\n        // mint OHM needed and store amount of rewards for distribution\r\n        send_ = value.sub(_profit);\r\n        OHM.mint(msg.sender, send_);\r\n\r\n        totalReserves = totalReserves.add(value);\r\n\r\n        emit Deposit(_token, _amount, value);\r\n    }\r\n\r\n    /**\r\n     * @notice allow approved address to burn OHM for reserves\r\n     * @param _amount uint256\r\n     * @param _token address\r\n     */\r\n    function withdraw(uint256 _amount, address _token) external override {\r\n        require(permissions[STATUS.RESERVETOKEN][_token], notAccepted); // Only reserves can be used for redemptions\r\n        require(permissions[STATUS.RESERVESPENDER][msg.sender], notApproved);\r\n\r\n        uint256 value = tokenValue(_token, _amount);\r\n        OHM.burnFrom(msg.sender, value);\r\n\r\n        totalReserves = totalReserves.sub(value);\r\n\r\n        IERC20(_token).safeTransfer(msg.sender, _amount);\r\n\r\n        emit Withdrawal(_token, _amount, value);\r\n    }\r\n\r\n    /**\r\n     * @notice allow approved address to withdraw assets\r\n     * @param _token address\r\n     * @param _amount uint256\r\n     */\r\n    function manage(address _token, uint256 _amount) external override {\r\n        if (permissions[STATUS.LIQUIDITYTOKEN][_token]) {\r\n            require(permissions[STATUS.LIQUIDITYMANAGER][msg.sender], notApproved);\r\n        } else {\r\n            require(permissions[STATUS.RESERVEMANAGER][msg.sender], notApproved);\r\n        }\r\n        if (permissions[STATUS.RESERVETOKEN][_token] || permissions[STATUS.LIQUIDITYTOKEN][_token]) {\r\n            uint256 value = tokenValue(_token, _amount);\r\n            require(value <= excessReserves(), insufficientReserves);\r\n            totalReserves = totalReserves.sub(value);\r\n        }\r\n        IERC20(_token).safeTransfer(msg.sender, _amount);\r\n        emit Managed(_token, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice mint new OHM using excess reserves\r\n     * @param _recipient address\r\n     * @param _amount uint256\r\n     */\r\n    function mint(address _recipient, uint256 _amount) external override {\r\n        require(permissions[STATUS.REWARDMANAGER][msg.sender], notApproved);\r\n        require(_amount <= excessReserves(), insufficientReserves);\r\n        OHM.mint(_recipient, _amount);\r\n        emit Minted(msg.sender, _recipient, _amount);\r\n    }\r\n\r\n    /**\r\n     * DEBT: The debt functions allow approved addresses to borrow treasury assets\r\n     * or OHM from the treasury, using sOHM as collateral. This might allow an\r\n     * sOHM holder to provide OHM liquidity without taking on the opportunity cost\r\n     * of unstaking, or alter their backing without imposing risk onto the treasury.\r\n     * Many of these use cases are yet to be defined, but they appear promising.\r\n     * However, we urge the community to think critically and move slowly upon\r\n     * proposals to acquire these permissions.\r\n     */\r\n\r\n    /**\r\n     * @notice allow approved address to borrow reserves\r\n     * @param _amount uint256\r\n     * @param _token address\r\n     */\r\n    function incurDebt(uint256 _amount, address _token) external override {\r\n        uint256 value;\r\n        if (_token == address(OHM)) {\r\n            require(permissions[STATUS.OHMDEBTOR][msg.sender], notApproved);\r\n            value = _amount;\r\n        } else {\r\n            require(permissions[STATUS.RESERVEDEBTOR][msg.sender], notApproved);\r\n            require(permissions[STATUS.RESERVETOKEN][_token], notAccepted);\r\n            value = tokenValue(_token, _amount);\r\n        }\r\n        require(value != 0, invalidToken);\r\n\r\n        sOHM.changeDebt(value, msg.sender, true);\r\n        require(sOHM.debtBalances(msg.sender) <= debtLimit[msg.sender], \"Treasury: exceeds limit\");\r\n        totalDebt = totalDebt.add(value);\r\n\r\n        if (_token == address(OHM)) {\r\n            OHM.mint(msg.sender, value);\r\n            ohmDebt = ohmDebt.add(value);\r\n        } else {\r\n            totalReserves = totalReserves.sub(value);\r\n            IERC20(_token).safeTransfer(msg.sender, _amount);\r\n        }\r\n        emit CreateDebt(msg.sender, _token, _amount, value);\r\n    }\r\n\r\n    /**\r\n     * @notice allow approved address to repay borrowed reserves with reserves\r\n     * @param _amount uint256\r\n     * @param _token address\r\n     */\r\n    function repayDebtWithReserve(uint256 _amount, address _token) external override {\r\n        require(permissions[STATUS.RESERVEDEBTOR][msg.sender], notApproved);\r\n        require(permissions[STATUS.RESERVETOKEN][_token], notAccepted);\r\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\r\n        uint256 value = tokenValue(_token, _amount);\r\n        sOHM.changeDebt(value, msg.sender, false);\r\n        totalDebt = totalDebt.sub(value);\r\n        totalReserves = totalReserves.add(value);\r\n        emit RepayDebt(msg.sender, _token, _amount, value);\r\n    }\r\n\r\n    /**\r\n     * @notice allow approved address to repay borrowed reserves with OHM\r\n     * @param _amount uint256\r\n     */\r\n    function repayDebtWithOHM(uint256 _amount) external {\r\n        require(permissions[STATUS.RESERVEDEBTOR][msg.sender] || permissions[STATUS.OHMDEBTOR][msg.sender], notApproved);\r\n        OHM.burnFrom(msg.sender, _amount);\r\n        sOHM.changeDebt(_amount, msg.sender, false);\r\n        totalDebt = totalDebt.sub(_amount);\r\n        ohmDebt = ohmDebt.sub(_amount);\r\n        emit RepayDebt(msg.sender, address(OHM), _amount, _amount);\r\n    }\r\n\r\n    /* ========== MANAGERIAL FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice takes inventory of all tracked assets\r\n     * @notice always consolidate to recognized reserves before audit\r\n     */\r\n    function auditReserves() external onlyGovernor {\r\n        uint256 reserves;\r\n        address[] memory reserveToken = registry[STATUS.RESERVETOKEN];\r\n        for (uint256 i = 0; i < reserveToken.length; i++) {\r\n            if (permissions[STATUS.RESERVETOKEN][reserveToken[i]]) {\r\n                reserves = reserves.add(tokenValue(reserveToken[i], IERC20(reserveToken[i]).balanceOf(address(this))));\r\n            }\r\n        }\r\n        address[] memory liquidityToken = registry[STATUS.LIQUIDITYTOKEN];\r\n        for (uint256 i = 0; i < liquidityToken.length; i++) {\r\n            if (permissions[STATUS.LIQUIDITYTOKEN][liquidityToken[i]]) {\r\n                reserves = reserves.add(tokenValue(liquidityToken[i], IERC20(liquidityToken[i]).balanceOf(address(this))));\r\n            }\r\n        }\r\n        totalReserves = reserves;\r\n        emit ReservesAudited(reserves);\r\n    }\r\n\r\n    /**\r\n     * @notice set max debt for address\r\n     * @param _address address\r\n     * @param _limit uint256\r\n     */\r\n    function setDebtLimit(address _address, uint256 _limit) external onlyGovernor {\r\n        debtLimit[_address] = _limit;\r\n    }\r\n\r\n    /**\r\n     * @notice enable permission from queue\r\n     * @param _status STATUS\r\n     * @param _address address\r\n     * @param _calculator address\r\n     */\r\n    function enable(\r\n        STATUS _status,\r\n        address _address,\r\n        address _calculator\r\n    ) external onlyGovernor {\r\n        require(timelockEnabled == false, \"Use queueTimelock\");\r\n        if (_status == STATUS.SOHM) {\r\n            sOHM = IsOHM(_address);\r\n        } else {\r\n            permissions[_status][_address] = true;\r\n\r\n            if (_status == STATUS.LIQUIDITYTOKEN) {\r\n                bondCalculator[_address] = _calculator;\r\n            }\r\n\r\n            (bool registered, ) = indexInRegistry(_address, _status);\r\n            if (!registered) {\r\n                registry[_status].push(_address);\r\n\r\n                if (_status == STATUS.LIQUIDITYTOKEN || _status == STATUS.RESERVETOKEN) {\r\n                    (bool reg, uint256 index) = indexInRegistry(_address, _status);\r\n                    if (reg) {\r\n                        delete registry[_status][index];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        emit Permissioned(_address, _status, true);\r\n    }\r\n\r\n    /**\r\n     *  @notice disable permission from address\r\n     *  @param _status STATUS\r\n     *  @param _toDisable address\r\n     */\r\n    function disable(STATUS _status, address _toDisable) external {\r\n        require(msg.sender == authority.governor() || msg.sender == authority.guardian(), \"Only governor or guardian\");\r\n        permissions[_status][_toDisable] = false;\r\n        emit Permissioned(_toDisable, _status, false);\r\n    }\r\n\r\n    /**\r\n     * @notice check if registry contains address\r\n     * @return (bool, uint256)\r\n     */\r\n    function indexInRegistry(address _address, STATUS _status) public view returns (bool, uint256) {\r\n        address[] memory entries = registry[_status];\r\n        for (uint256 i = 0; i < entries.length; i++) {\r\n            if (_address == entries[i]) {\r\n                return (true, i);\r\n            }\r\n        }\r\n        return (false, 0);\r\n    }\r\n\r\n    /* ========== TIMELOCKED FUNCTIONS ========== */\r\n\r\n    // functions are used prior to enabling on-chain governance\r\n\r\n    /**\r\n     * @notice queue address to receive permission\r\n     * @param _status STATUS\r\n     * @param _address address\r\n     * @param _calculator address\r\n     */\r\n    function queueTimelock(\r\n        STATUS _status,\r\n        address _address,\r\n        address _calculator\r\n    ) external onlyGovernor {\r\n        require(_address != address(0));\r\n        require(timelockEnabled == true, \"Timelock is disabled, use enable\");\r\n\r\n        uint256 timelock = block.number.add(blocksNeededForQueue);\r\n        if (_status == STATUS.RESERVEMANAGER || _status == STATUS.LIQUIDITYMANAGER) {\r\n            timelock = block.number.add(blocksNeededForQueue.mul(2));\r\n        }\r\n        permissionQueue.push(\r\n            Queue({managing: _status, toPermit: _address, calculator: _calculator, timelockEnd: timelock, nullify: false, executed: false})\r\n        );\r\n        emit PermissionQueued(_status, _address);\r\n    }\r\n\r\n    /**\r\n     *  @notice enable queued permission\r\n     *  @param _index uint256\r\n     */\r\n    function execute(uint256 _index) external {\r\n        require(timelockEnabled == true, \"Timelock is disabled, use enable\");\r\n\r\n        Queue memory info = permissionQueue[_index];\r\n\r\n        require(!info.nullify, \"Action has been nullified\");\r\n        require(!info.executed, \"Action has already been executed\");\r\n        require(block.number >= info.timelockEnd, \"Timelock not complete\");\r\n\r\n        if (info.managing == STATUS.SOHM) {\r\n            // 9\r\n            sOHM = IsOHM(info.toPermit);\r\n        } else {\r\n            permissions[info.managing][info.toPermit] = true;\r\n\r\n            if (info.managing == STATUS.LIQUIDITYTOKEN) {\r\n                bondCalculator[info.toPermit] = info.calculator;\r\n            }\r\n            (bool registered, ) = indexInRegistry(info.toPermit, info.managing);\r\n            if (!registered) {\r\n                registry[info.managing].push(info.toPermit);\r\n\r\n                if (info.managing == STATUS.LIQUIDITYTOKEN) {\r\n                    (bool reg, uint256 index) = indexInRegistry(info.toPermit, STATUS.RESERVETOKEN);\r\n                    if (reg) {\r\n                        delete registry[STATUS.RESERVETOKEN][index];\r\n                    }\r\n                } else if (info.managing == STATUS.RESERVETOKEN) {\r\n                    (bool reg, uint256 index) = indexInRegistry(info.toPermit, STATUS.LIQUIDITYTOKEN);\r\n                    if (reg) {\r\n                        delete registry[STATUS.LIQUIDITYTOKEN][index];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        permissionQueue[_index].executed = true;\r\n        emit Permissioned(info.toPermit, info.managing, true);\r\n    }\r\n\r\n    /**\r\n     * @notice cancel timelocked action\r\n     * @param _index uint256\r\n     */\r\n    function nullify(uint256 _index) external onlyGovernor {\r\n        permissionQueue[_index].nullify = true;\r\n    }\r\n\r\n    /**\r\n     * @notice disables timelocked functions\r\n     */\r\n    function disableTimelock() external onlyGovernor {\r\n        require(timelockEnabled == true, \"timelock already disabled\");\r\n        if (onChainGovernanceTimelock != 0 && onChainGovernanceTimelock <= block.number) {\r\n            timelockEnabled = false;\r\n        } else {\r\n            onChainGovernanceTimelock = block.number.add(blocksNeededForQueue.mul(7)); // 7-day timelock\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice enables timelocks after initilization\r\n     */\r\n    function initialize() external onlyGovernor {\r\n        require(initialized == false, \"Already initialized\");\r\n        timelockEnabled = true;\r\n        initialized = true;\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice returns excess reserves not backing tokens\r\n     * @return uint\r\n     */\r\n    function excessReserves() public view override returns (uint256) {\r\n        return totalReserves.sub(OHM.totalSupply().sub(totalDebt));\r\n    }\r\n\r\n    /**\r\n     * @notice returns OHM valuation of asset\r\n     * @param _token address\r\n     * @param _amount uint256\r\n     * @return value_ uint256\r\n     */\r\n    function tokenValue(address _token, uint256 _amount) public view override returns (uint256 value_) {\r\n        value_ = _amount.mul(10**IERC20Metadata(address(OHM)).decimals()).div(10**IERC20Metadata(_token).decimals());\r\n\r\n        if (permissions[STATUS.LIQUIDITYTOKEN][_token]) {\r\n            value_ = IBondingCalculator(bondCalculator[_token]).valuation(_token, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice returns supply metric that cannot be manipulated by debt\r\n     * @dev use this any time you need to query supply\r\n     * @return uint256\r\n     */\r\n    function baseSupply() external view override returns (uint256) {\r\n        return OHM.totalSupply() - ohmDebt;\r\n    }\r\n}"
    }
  }
}