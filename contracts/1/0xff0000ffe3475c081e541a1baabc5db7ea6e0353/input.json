{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Nix.sol":{"content":"pragma solidity ^0.8.0;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Nix v0.9.0-alpha to be deployed\r\n//\r\n// https://github.com/bokkypoobah/Nix\r\n//\r\n// Deployed to Rinkeby\r\n// - Nix 0xFF0000ffe3475C081E541a1baAbc5DB7eA6e0353\r\n// - NixHelper 0x76f910c835b5a06CD465657f1a71153e2B6B2C0B\r\n//\r\n// SPDX-License-Identifier: MIT\r\n//\r\n// Enjoy. And hello, from the past.\r\n//\r\n// (c) BokkyPooBah / Bok Consulting Pty Ltd 2022\r\n// ----------------------------------------------------------------------------\r\n\r\ninterface IERC20Partial {\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721Partial is IERC165 {\r\n    function ownerOf(uint tokenId) external view returns (address);\r\n    function balanceOf(address owner) external view returns (uint balance);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint tokenId) external payable;\r\n}\r\n\r\ninterface IRoyaltyEngineV1Partial is IERC165 {\r\n    function getRoyaltyView(address tokenAddress, uint tokenId, uint value) external view returns(address payable[] memory recipients, uint[] memory amounts);\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    function onERC721Received(address operator, address from, uint tokenId, bytes memory data) external returns(bytes4);\r\n}\r\n\r\n/// @author Alex W.(github.com/nonstopcoderaxw)\r\n/// @title Array utility functions optimized for Nix\r\nlibrary ArrayUtils {\r\n    /// @notice divide-and-conquer check if an targeted item exists in a sorted array\r\n    /// @param self the given sorted array\r\n    /// @param target the targeted item to the array\r\n    /// @return true - if exists, false - not found\r\n    function includes(uint256[] memory self, uint256 target) internal pure returns (bool) {\r\n        if (self.length > 0) {\r\n            uint256 left;\r\n            uint256 right = self.length - 1;\r\n            uint256 mid;\r\n            while (left <= right) {\r\n                mid = (left + right) / 2;\r\n                if (self[mid] < target) {\r\n                    left = mid + 1;\r\n                } else if (self[mid] > target) {\r\n                    right = mid - 1;\r\n                } else {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\ncontract Owned {\r\n    bytes4 private constant ERC721_INTERFACE = 0x80ac58cd;\r\n\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    event Withdrawn(address indexed token, uint tokens, uint tokenId);\r\n\r\n    error NotOwner();\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) {\r\n            revert NotOwner();\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function withdraw(address token, uint tokens, uint tokenId) public onlyOwner {\r\n        if (token == address(0)) {\r\n            if (tokens == 0) {\r\n                tokens = address(this).balance;\r\n            }\r\n            payable(owner).transfer(tokens);\r\n        } else {\r\n            bool isERC721 = false;\r\n            try IERC721Partial(token).supportsInterface(ERC721_INTERFACE) returns (bool b) {\r\n                isERC721 = b;\r\n            } catch {\r\n            }\r\n            if (isERC721) {\r\n                IERC721Partial(token).safeTransferFrom(address(this), owner, tokenId);\r\n            } else {\r\n                if (tokens == 0) {\r\n                    tokens = IERC20Partial(token).balanceOf(address(this));\r\n                }\r\n                IERC20Partial(token).transfer(owner, tokens);\r\n            }\r\n        }\r\n        emit Withdrawn(token, tokens, tokenId);\r\n    }\r\n}\r\n\r\n\r\ncontract ReentrancyGuard {\r\n    error ReentrancyAttempted();\r\n    uint private _executing;\r\n    modifier reentrancyGuard() {\r\n        if (_executing == 1) {\r\n            revert ReentrancyAttempted();\r\n        }\r\n        _executing = 1;\r\n        _;\r\n        _executing = 2;\r\n    }\r\n}\r\n\r\n\r\n/// @author BokkyPooBah, Bok Consulting Pty Ltd\r\n/// @title Decentralised ERC-721 exchange\r\ncontract Nix is Owned, ReentrancyGuard, ERC721TokenReceiver {\r\n    using ArrayUtils for uint[];\r\n\r\n    enum BuyOrSell { Buy, Sell }\r\n    enum AnyOrAll { Any, All }\r\n\r\n    struct Token {\r\n        address token;\r\n        bytes32[] ordersIndex;\r\n        mapping(bytes32 => Order) orders;\r\n        uint64 executed;\r\n        uint64 volumeToken;\r\n        uint volumeWeth;\r\n    }\r\n    struct Order {\r\n        address maker;\r\n        address taker;\r\n        BuyOrSell buyOrSell;\r\n        AnyOrAll anyOrAll;\r\n        bytes32 tokenIdsKey;\r\n        uint price;\r\n        uint64 expiry;\r\n        uint64 tradeCount;\r\n        uint64 tradeMax;\r\n        uint64 royaltyFactor;\r\n    }\r\n    struct Netting {\r\n        address accounts;\r\n        int amount;\r\n    }\r\n    struct ExecutedOrder {\r\n        address token;\r\n        uint64 orderIndex;\r\n    }\r\n    struct Trade {\r\n        address taker;\r\n        uint64 royaltyFactor;\r\n        uint64 blockNumber;\r\n        address[] uniqueAddresses;\r\n        mapping(address => bool) seen;\r\n        mapping(address => int) netting;\r\n        ExecutedOrder[] executedOrders;\r\n    }\r\n\r\n    bytes4 private constant ERC721_INTERFACE = 0x80ac58cd;\r\n    bytes4 private constant ERC721METADATA_INTERFACE = 0x5b5e139f;\r\n    bytes4 private constant ERC721ENUMERABLE_INTERFACE = 0x780e9d63;\r\n    uint private constant ROYALTYFACTOR_MAX = 1000;\r\n\r\n    IERC20Partial public weth;\r\n    IRoyaltyEngineV1Partial public royaltyEngine;\r\n\r\n    address[] private tokensIndex;\r\n    mapping(address => Token) private tokens;\r\n    mapping(bytes32 => uint[]) tokenIdsData;\r\n    Trade[] private trades;\r\n\r\n    event TokenAdded(address indexed token, uint indexed tokenIndex);\r\n    event OrderAdded(address indexed token, uint indexed orderIndex);\r\n    event OrderPriceAndExpiryUpdated(address indexed token, uint indexed orderIndex);\r\n    event OrderUpdated(address indexed token, uint indexed orderIndex);\r\n    event OrderExecuted(address indexed token, uint indexed orderIndex, uint indexed tradeIndex, uint[] tokenIds);\r\n    event ThankYou(uint tip);\r\n\r\n    error NotERC721();\r\n    error NotERC165();\r\n    error RoyaltyOverMax(uint royalty, uint max);\r\n    error TokenIdsMustBeSortedWithNoDuplicates();\r\n    error TokenIdsMustBeSpecifiedForBuyOrSellAll();\r\n    error TradeMaxMustBeZeroOrOneForBuyOrSellAll();\r\n    error DuplicateOrder();\r\n    error NotMaker();\r\n    error InputArraysMismatch();\r\n    error TokenIdsNotSpecified();\r\n    error CannotExecuteOwnOrder();\r\n    error OrderCanOnlyBeExecutedBySpecifiedTaker(uint orderIndex, address specifiedTaker);\r\n    error OrderExpired(uint orderIndex, uint expiry);\r\n    error TokenIdNotFound(uint orderIndex, uint tokenId);\r\n    error TokenIdsMismatch(uint orderIndex, uint[] orderTokenIds, uint[] executeTokenIds);\r\n    error OrderMaxxed(uint orderIndex, uint tradeCount, uint tradeMax);\r\n    error NetAmountMismatch(int computedNetAmount, int netAmount);\r\n    error RoyaltyEngineResultsLengthMismatch(uint recipientsLength, uint amountsLength);\r\n    error WETHTransferFromFailure();\r\n    error WETHTransferFailure();\r\n\r\n    constructor(IERC20Partial _weth, IRoyaltyEngineV1Partial _royaltyEngine) {\r\n        weth = _weth;\r\n        royaltyEngine = _royaltyEngine;\r\n    }\r\n\r\n    function onERC721Received(address /*_operator*/, address /*_from*/, uint _tokenId, bytes memory /*_data*/) external override returns(bytes4) {\r\n        emit ThankYou(_tokenId);\r\n        return this.onERC721Received.selector;\r\n    }\r\n\r\n    function getLengths() public view returns (uint _tokensLength, uint _tradesLength) {\r\n        return (tokensIndex.length, trades.length);\r\n    }\r\n    function ordersLength(address token) public view returns (uint) {\r\n        return tokens[token].ordersIndex.length;\r\n    }\r\n    function getToken(uint tokenIndex) external view returns (address token, uint64 _ordersLength, uint64 executed, uint64 volumeToken, uint volumeWeth) {\r\n        token = tokensIndex[tokenIndex];\r\n        Token storage tokenInfo = tokens[token];\r\n        _ordersLength = uint64(tokenInfo.ordersIndex.length);\r\n        executed = tokenInfo.executed;\r\n        volumeToken = tokenInfo.volumeToken;\r\n        volumeWeth = tokenInfo.volumeWeth;\r\n    }\r\n    function getOrder(address token, uint orderIndex) external view returns (Order memory order) {\r\n        bytes32 orderKey = tokens[token].ordersIndex[orderIndex];\r\n        order = tokens[token].orders[orderKey];\r\n    }\r\n    function getTrade(uint tradeIndex) external view returns (address taker, uint64 royaltyFactor, uint64 blockNumber, ExecutedOrder[] memory executedOrders) {\r\n        Trade storage trade = trades[tradeIndex];\r\n        return (trade.taker, trade.royaltyFactor, trade.blockNumber, trade.executedOrders);\r\n    }\r\n    function getTokenIds(bytes32 tokenIdsKey) external view returns (uint[] memory tokenIds) {\r\n        return _getTokenIds(tokenIdsKey);\r\n    }\r\n    function _getTokenIds(bytes32 tokenIdsKey) private view returns (uint[] memory tokenIds) {\r\n        if (tokenIdsKey != bytes32(0)) {\r\n            return tokenIdsData[tokenIdsKey];\r\n        }\r\n        return new uint[](0);\r\n    }\r\n    function getOrAddTokenIds(uint[] memory tokenIds) private returns (bytes32 tokenIdsKey) {\r\n        if (tokenIds.length > 0) {\r\n            tokenIdsKey = keccak256(abi.encodePacked(tokenIds));\r\n            if (tokenIdsData[tokenIdsKey].length == 0) {\r\n                for (uint i = 1; i < tokenIds.length; i++) {\r\n                    if (tokenIds[i - 1] >= tokenIds[i]) {\r\n                        revert TokenIdsMustBeSortedWithNoDuplicates();\r\n                    }\r\n                }\r\n                tokenIdsData[tokenIdsKey] = tokenIds;\r\n            }\r\n        }\r\n    }\r\n    function getOrAddToken(address token) private returns (Token storage tokenInfo) {\r\n        tokenInfo = tokens[token];\r\n        if (tokenInfo.token != token) {\r\n            try IERC165(token).supportsInterface(ERC721_INTERFACE) returns (bool b) {\r\n                if (!b) {\r\n                    revert NotERC721();\r\n                }\r\n                tokensIndex.push(token);\r\n                tokenInfo.token = token;\r\n                emit TokenAdded(token, tokensIndex.length - 1);\r\n            } catch {\r\n                revert NotERC165();\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Add order\r\n    /// @param token ERC-721 contract address\r\n    /// @param taker Specific address, or null for any taker\r\n    /// @param tokenIds [] (empty) for any, [tokenId1, tokenId2, ...] for specific tokenIds. Must not be empty for All. Must be sorted with no duplicates\r\n    /// @param price Price per NFT for Any. Price for all specified NFTs for All\r\n    /// @param buyOrSell (0) Buy, (1) Sell\r\n    /// @param anyOrAll (0) Any, (1) All\r\n    /// @param expiry Expiry date. 0 = no expiry.\r\n    /// @param tradeMax Must be 0 or 1 for All. Maximum number of NFTs for Any\r\n    /// @param royaltyFactor 0 to ROYALTYFACTOR_MAX, and will be applied as % when the maker sells the NFTs\r\n    /// @param integrator Address of integrator, that will receive a portion of ETH tips\r\n    /// @return orderIndex The new order index\r\n    function addOrder(\r\n        address token,\r\n        address taker,\r\n        BuyOrSell buyOrSell,\r\n        AnyOrAll anyOrAll,\r\n        uint[] memory tokenIds,\r\n        uint price,\r\n        uint expiry,\r\n        uint tradeMax,\r\n        uint royaltyFactor,\r\n        address integrator\r\n    ) external payable reentrancyGuard returns (\r\n        uint64 orderIndex\r\n    ) {\r\n        if (anyOrAll == AnyOrAll.All) {\r\n            if (tokenIds.length == 0) {\r\n                revert TokenIdsMustBeSpecifiedForBuyOrSellAll();\r\n            }\r\n            if (tradeMax > 1) {\r\n                revert TradeMaxMustBeZeroOrOneForBuyOrSellAll();\r\n            }\r\n        }\r\n        if (royaltyFactor > ROYALTYFACTOR_MAX) {\r\n            revert RoyaltyOverMax(royaltyFactor, ROYALTYFACTOR_MAX);\r\n        }\r\n        Token storage tokenInfo = getOrAddToken(token);\r\n        bytes32 tokenIdsKey = getOrAddTokenIds(tokenIds);\r\n        bytes32 orderKey = keccak256(abi.encodePacked(msg.sender, taker, token, tokenIdsKey));\r\n        orderKey = keccak256(abi.encodePacked(orderKey, price, buyOrSell, anyOrAll, expiry));\r\n        if (tokenInfo.orders[orderKey].maker != address(0)) {\r\n            revert DuplicateOrder();\r\n        }\r\n        tokenInfo.ordersIndex.push(orderKey);\r\n        Order storage order = tokenInfo.orders[orderKey];\r\n        order.maker = msg.sender;\r\n        order.taker = taker;\r\n        order.buyOrSell = buyOrSell;\r\n        order.anyOrAll = anyOrAll;\r\n        order.tokenIdsKey = tokenIdsKey;\r\n        order.price = price;\r\n        order.expiry = uint64(expiry);\r\n        order.tradeMax = uint64(tradeMax);\r\n        order.royaltyFactor = uint64(royaltyFactor);\r\n        emit OrderAdded(token, tokenInfo.ordersIndex.length - 1);\r\n        handleTips(integrator);\r\n        return uint64(tokenInfo.ordersIndex.length - 1);\r\n    }\r\n\r\n    /// @dev Update order price and expiry\r\n    /// @param token ERC-721 contract address\r\n    /// @param orderIndex Order index\r\n    /// @param price Price per NFT for Any. Price for all specified NFTs for All\r\n    /// @param expiry Expiry date. 0 = no expiry. 1 = disabled.\r\n    /// @param integrator Address of integrator, that will receive a portion of ETH tips\r\n    function updateOrderPriceAndExpiry(\r\n        address token,\r\n        uint orderIndex,\r\n        uint price,\r\n        uint expiry,\r\n        address integrator\r\n    ) external payable reentrancyGuard {\r\n        bytes32 orderKey = tokens[token].ordersIndex[orderIndex];\r\n        Order storage order = tokens[token].orders[orderKey];\r\n        if (msg.sender != order.maker) {\r\n            revert NotMaker();\r\n        }\r\n        order.price = price;\r\n        order.expiry = uint64(expiry);\r\n        emit OrderPriceAndExpiryUpdated(token, orderIndex);\r\n        handleTips(integrator);\r\n    }\r\n\r\n    /// @dev Update order\r\n    /// @param token ERC-721 contract address\r\n    /// @param orderIndex Order index\r\n    /// @param taker Specific address, or null for any taker\r\n    /// @param tokenIds [] (empty) for any, [tokenId1, tokenId2, ...] for specific tokenIds. Must not be empty for All. Must be sorted with no duplicates\r\n    /// @param price Price per NFT for Any. Price for all specified NFTs for All\r\n    /// @param expiry Expiry date. 0 = no expiry. 1 = disabled.\r\n    /// @param tradeMaxAdjustment Positive or negative number to adjust tradeMax. tradeMax must result in 0 or 1 for All, or the maximum number of NFTs for Any\r\n    /// @param royaltyFactor 0 to ROYALTYFACTOR_MAX, and will be applied as % when the maker sells the NFTs\r\n    /// @param integrator Address of integrator, that will receive a portion of ETH tips\r\n    function updateOrder(\r\n        address token,\r\n        uint orderIndex,\r\n        address taker,\r\n        uint[] memory tokenIds,\r\n        uint price,\r\n        uint expiry,\r\n        int tradeMaxAdjustment,\r\n        uint royaltyFactor,\r\n        address integrator\r\n    ) external payable reentrancyGuard {\r\n        bytes32 orderKey = tokens[token].ordersIndex[orderIndex];\r\n        Order storage order = tokens[token].orders[orderKey];\r\n        if (msg.sender != order.maker) {\r\n            revert NotMaker();\r\n        }\r\n        if (royaltyFactor > ROYALTYFACTOR_MAX) {\r\n            revert RoyaltyOverMax(royaltyFactor, ROYALTYFACTOR_MAX);\r\n        }\r\n        bytes32 tokenIdsKey = getOrAddTokenIds(tokenIds);\r\n        order.taker = taker;\r\n        order.tokenIdsKey = tokenIdsKey;\r\n        order.price = price;\r\n        order.expiry = uint64(expiry);\r\n        if (tradeMaxAdjustment < 0) {\r\n            uint64 subtract = uint64(-int64(tradeMaxAdjustment));\r\n            if (subtract < (order.tradeMax - order.tradeCount)) {\r\n                order.tradeMax -= subtract;\r\n            } else {\r\n                order.tradeMax = order.tradeCount;\r\n            }\r\n        } else {\r\n            order.tradeMax += uint64(int64(tradeMaxAdjustment));\r\n        }\r\n        if (order.anyOrAll == AnyOrAll.All) {\r\n            if (tokenIds.length == 0) {\r\n                revert TokenIdsMustBeSpecifiedForBuyOrSellAll();\r\n            }\r\n            if (order.tradeMax > 1) {\r\n                revert TradeMaxMustBeZeroOrOneForBuyOrSellAll();\r\n            }\r\n        }\r\n        order.royaltyFactor = uint64(royaltyFactor);\r\n        emit OrderUpdated(token, orderIndex);\r\n        handleTips(integrator);\r\n    }\r\n\r\n    /// @dev Taker execute orders.\r\n    /// @param tokenList List of ERC-721 contract addresses - one address for each order\r\n    /// @param orderIndexes List of order indices - one orderIndex for each order\r\n    /// @param tokenIdsList List of list of tokenIds - one set of tokenIds for each order. Each list must match the all the order tokenIds for All, and one or more for Any\r\n    /// @param netAmount Positive (taker receives WETH) or negative (taker pays WETH) for all orders\r\n    /// @param royaltyFactor 0 to ROYALTYFACTOR_MAX, and will be applied as % when the taker sells the NFTs\r\n    /// @param integrator Address of integrator, that will receive a portion of ETH tips\r\n    function executeOrders(\r\n        address[] memory tokenList,\r\n        uint[] memory orderIndexes,\r\n        uint[][] memory tokenIdsList,\r\n        int netAmount,\r\n        uint royaltyFactor,\r\n        address integrator\r\n    ) external payable reentrancyGuard {\r\n        if (tokenList.length == 0 || tokenList.length != orderIndexes.length || tokenList.length != tokenIdsList.length) {\r\n            revert InputArraysMismatch();\r\n        }\r\n        if (royaltyFactor > ROYALTYFACTOR_MAX) {\r\n            revert RoyaltyOverMax(royaltyFactor, ROYALTYFACTOR_MAX);\r\n        }\r\n        trades.push();\r\n        Trade storage trade = trades[trades.length - 1];\r\n        trade.taker = msg.sender;\r\n        trade.royaltyFactor = uint64(royaltyFactor);\r\n        trade.blockNumber = uint64(block.number);\r\n        for (uint i = 0; i < orderIndexes.length; i++) {\r\n            Token storage tokenInfo = tokens[tokenList[i]];\r\n            tokenInfo.executed++;\r\n            bytes32 orderKey = tokenInfo.ordersIndex[orderIndexes[i]];\r\n            Order storage order = tokenInfo.orders[orderKey];\r\n            trade.executedOrders.push(ExecutedOrder(tokenList[i], uint64(orderIndexes[i])));\r\n            uint[] memory tokenIds = tokenIdsList[i];\r\n            if (tokenIds.length == 0) {\r\n                revert TokenIdsNotSpecified();\r\n            }\r\n            if (msg.sender == order.maker) {\r\n                revert CannotExecuteOwnOrder();\r\n            }\r\n            if (order.taker != address(0) && order.taker != msg.sender) {\r\n                revert OrderCanOnlyBeExecutedBySpecifiedTaker(orderIndexes[i], order.taker);\r\n            }\r\n            if (order.expiry != 0 && order.expiry < block.timestamp) {\r\n                revert OrderExpired(orderIndexes[i], order.expiry);\r\n            }\r\n            (address nftFrom, address nftTo) = (order.buyOrSell == BuyOrSell.Buy) ? (msg.sender, order.maker) : (order.maker, msg.sender);\r\n            emit OrderExecuted(tokenInfo.token, orderIndexes[i], trades.length - 1, tokenIds);\r\n            uint[] memory orderTokenIds = _getTokenIds(order.tokenIdsKey);\r\n            if (order.anyOrAll == AnyOrAll.Any) {\r\n                for (uint j = 0; j < tokenIds.length; j++) {\r\n                    if (order.tokenIdsKey != bytes32(0) && !orderTokenIds.includes(tokenIds[j])) {\r\n                        revert TokenIdNotFound(orderIndexes[i], tokenIds[j]);\r\n                    }\r\n                    IERC721Partial(tokenInfo.token).safeTransferFrom(nftFrom, nftTo, tokenIds[j]);\r\n                    tokenInfo.volumeToken++;\r\n                    tokenInfo.volumeWeth += order.price;\r\n                    addNetting(tokenInfo, tokenIds[j], trade, order);\r\n                    order.tradeCount++;\r\n                }\r\n            } else {\r\n                if (tokenIds.length != orderTokenIds.length) {\r\n                    revert TokenIdsMismatch(orderIndexes[i], orderTokenIds, tokenIds);\r\n                }\r\n                for (uint j = 0; j < orderTokenIds.length; j++) {\r\n                    if (tokenIds[j] != orderTokenIds[j]) {\r\n                        revert TokenIdsMismatch(orderIndexes[i], orderTokenIds, tokenIds);\r\n                    }\r\n                    IERC721Partial(tokenInfo.token).safeTransferFrom(nftFrom, nftTo, tokenIds[j]);\r\n                    tokenInfo.volumeToken++;\r\n                }\r\n                order.tradeCount++;\r\n                tokenInfo.volumeWeth += order.price;\r\n                // NOTE - Royalty information for the FIRST tokenId for All\r\n                addNetting(tokenInfo, tokenIds[0], trade, order);\r\n            }\r\n            if (order.tradeCount > order.tradeMax) {\r\n                revert OrderMaxxed(orderIndexes[i], order.tradeCount, order.tradeMax);\r\n            }\r\n        }\r\n        if (trade.netting[msg.sender] != netAmount) {\r\n            revert NetAmountMismatch(trade.netting[msg.sender], netAmount);\r\n        }\r\n        transferNetted(trade);\r\n        handleTips(integrator);\r\n    }\r\n\r\n    function addNetting(Token storage tokenInfo, uint tokenId, Trade storage trade, Order memory order) private {\r\n        (address wethTo, address wethFrom) = (order.buyOrSell == BuyOrSell.Buy) ? (msg.sender, order.maker) : (order.maker, msg.sender);\r\n        if (!trade.seen[wethFrom]) {\r\n            trade.uniqueAddresses.push(wethFrom);\r\n            trade.seen[wethFrom] = true;\r\n        }\r\n        if (!trade.seen[wethTo]) {\r\n            trade.uniqueAddresses.push(wethTo);\r\n            trade.seen[wethTo] = true;\r\n        }\r\n        trade.netting[wethFrom] -= int(order.price);\r\n        try royaltyEngine.getRoyaltyView(tokenInfo.token, tokenId, order.price) returns (address payable[] memory recipients, uint256[] memory amounts) {\r\n            if (recipients.length != amounts.length) {\r\n                revert RoyaltyEngineResultsLengthMismatch(recipients.length, amounts.length);\r\n            }\r\n            uint royaltyFactor = (order.buyOrSell == BuyOrSell.Buy) ? trade.royaltyFactor : order.royaltyFactor;\r\n            for (uint i = 0; i < recipients.length; i++) {\r\n                if (!trade.seen[recipients[i]]) {\r\n                    trade.uniqueAddresses.push(recipients[i]);\r\n                    trade.seen[recipients[i]] = true;\r\n                }\r\n                uint royalty = amounts[i] * royaltyFactor / 100;\r\n                trade.netting[recipients[i]] += int(royalty);\r\n                trade.netting[wethTo] -= int(royalty);\r\n            }\r\n        } catch {\r\n        }\r\n        trade.netting[wethTo] += int(order.price);\r\n    }\r\n    function transferNetted(Trade storage trade) private {\r\n        for (uint i = 0; i < trade.uniqueAddresses.length; i++) {\r\n            address account = trade.uniqueAddresses[i];\r\n            delete trade.seen[account];\r\n            if (trade.netting[account] < 0) {\r\n                if (!weth.transferFrom(account, address(this), uint(-trade.netting[account]))) {\r\n                    revert WETHTransferFromFailure();\r\n                }\r\n            }\r\n        }\r\n        for (uint i = 0; i < trade.uniqueAddresses.length; i++) {\r\n            address account = trade.uniqueAddresses[i];\r\n            if (trade.netting[account] > 0) {\r\n                if (!weth.transfer(account, uint(trade.netting[account]))) {\r\n                    revert WETHTransferFailure();\r\n                }\r\n            }\r\n            delete trade.netting[account];\r\n        }\r\n        delete trade.uniqueAddresses;\r\n    }\r\n    function handleTips(address integrator) private {\r\n        if (msg.value > 0) {\r\n            uint integratorTip;\r\n            if (integrator != address(0) && integrator != owner) {\r\n                integratorTip = msg.value * 4 / 5;\r\n                if (integratorTip > 0) {\r\n                    payable(integrator).transfer(integratorTip);\r\n                }\r\n            }\r\n            emit ThankYou(msg.value);\r\n        }\r\n    }\r\n    receive() external payable {\r\n        handleTips(owner);\r\n    }\r\n}\r\n\r\n\r\n/// @author BokkyPooBah, Bok Consulting Pty Ltd\r\n/// @title Decentralised ERC-721 exchange bulk data retrieval helper\r\ncontract NixHelper {\r\n\r\n    enum OrderStatus {\r\n        Executable,\r\n        Disabled,\r\n        Expired,\r\n        Maxxed,\r\n        MakerNoWeth,\r\n        MakerNoWethAllowance,\r\n        MakerNoToken,\r\n        MakerNotApprovedNix,\r\n        UnknownError\r\n    }\r\n\r\n    Nix public nix;\r\n    IERC20Partial immutable public weth;\r\n\r\n    constructor(Nix _nix) {\r\n        nix = _nix;\r\n        weth = _nix.weth();\r\n    }\r\n\r\n    function getTokens(\r\n        uint[] memory tokensIndices\r\n    ) public view returns (\r\n        address[] memory tokens,\r\n        uint[] memory ordersLengthList,\r\n        uint[] memory executedList,\r\n        uint[] memory volumeTokenList,\r\n        uint[] memory volumeWethList\r\n    ) {\r\n        uint length = tokensIndices.length;\r\n        tokens = new address[](length);\r\n        ordersLengthList = new uint[](length);\r\n        executedList = new uint[](length);\r\n        volumeTokenList = new uint[](length);\r\n        volumeWethList = new uint[](length);\r\n        (uint tokensLength,) = nix.getLengths();\r\n        for (uint i = 0; i < length; i++) {\r\n            uint tokenIndex = tokensIndices[i];\r\n            if (tokenIndex < tokensLength) {\r\n                (address token, uint64 ordersLength, uint64 executed, uint64 volumeToken, uint volumeWeth) = nix.getToken(tokenIndex);\r\n                tokens[i] = token;\r\n                ordersLengthList[i] = ordersLength;\r\n                executedList[i] = executed;\r\n                volumeTokenList[i] = volumeToken;\r\n                volumeWethList[i] = volumeWeth;\r\n            }\r\n        }\r\n    }\r\n\r\n    function orderStatus(address token, Nix.Order memory order) public view returns (OrderStatus) {\r\n        if (order.expiry > 0 && order.expiry < block.timestamp) {\r\n            return order.expiry == 1 ? OrderStatus.Disabled: OrderStatus.Expired;\r\n        }\r\n        if (order.tradeCount >= order.tradeMax) {\r\n            return OrderStatus.Maxxed;\r\n        }\r\n        if (order.buyOrSell == Nix.BuyOrSell.Buy) {\r\n            uint wethBalance = weth.balanceOf(order.maker);\r\n            if (wethBalance < order.price) {\r\n                return OrderStatus.MakerNoWeth;\r\n            }\r\n            uint wethAllowance = weth.allowance(order.maker, address(nix));\r\n            if (wethAllowance < order.price) {\r\n                return OrderStatus.MakerNoWethAllowance;\r\n            }\r\n        } else {\r\n            try IERC721Partial(token).isApprovedForAll(order.maker, address(nix)) returns (bool b) {\r\n                if (!b) {\r\n                    return OrderStatus.MakerNotApprovedNix;\r\n                }\r\n            } catch {\r\n                return OrderStatus.UnknownError;\r\n            }\r\n            uint[] memory orderTokenIds = nix.getTokenIds(order.tokenIdsKey);\r\n            if (order.anyOrAll == Nix.AnyOrAll.Any) {\r\n                if (order.tokenIdsKey == bytes32(0)) {\r\n                    try IERC721Partial(token).balanceOf(order.maker) returns (uint b) {\r\n                        if (b == 0) {\r\n                            return OrderStatus.MakerNoToken;\r\n                        }\r\n                    } catch {\r\n                        return OrderStatus.UnknownError;\r\n                    }\r\n                } else {\r\n                    bool found = false;\r\n                    for (uint j = 0; j < orderTokenIds.length && !found; j++) {\r\n                        try IERC721Partial(token).ownerOf(orderTokenIds[j]) returns (address a) {\r\n                            if (a == order.maker) {\r\n                                found = true;\r\n                            }\r\n                        } catch {\r\n                            return OrderStatus.UnknownError;\r\n                        }\r\n                    }\r\n                    if (!found) {\r\n                        return OrderStatus.MakerNoToken;\r\n                    }\r\n                }\r\n            } else {\r\n                for (uint j = 0; j < orderTokenIds.length; j++) {\r\n                    try IERC721Partial(token).ownerOf(orderTokenIds[j]) returns (address a) {\r\n                        if (a != order.maker) {\r\n                            return OrderStatus.MakerNoToken;\r\n                        }\r\n                    } catch {\r\n                        return OrderStatus.UnknownError;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return OrderStatus.Executable;\r\n    }\r\n\r\n    function getOrders(\r\n        address token,\r\n        uint[] memory orderIndices\r\n    ) public view returns (\r\n        address[] memory makers,\r\n        address[] memory takers,\r\n        uint[][] memory tokenIds,\r\n        uint[] memory prices,\r\n        uint[7][] memory data\r\n    ) {\r\n        uint length = orderIndices.length;\r\n        makers = new address[](length);\r\n        takers = new address[](length);\r\n        tokenIds = new uint[][](length);\r\n        prices = new uint[](length);\r\n        data = new uint[7][](length);\r\n        uint ordersLength = nix.ordersLength(token);\r\n        for (uint i = 0; i < length; i++) {\r\n            uint orderIndex = orderIndices[i];\r\n            if (orderIndex < ordersLength) {\r\n                Nix.Order memory order = nix.getOrder(token, orderIndex);\r\n                makers[i] = order.maker;\r\n                takers[i] = order.taker;\r\n                tokenIds[i] = nix.getTokenIds(order.tokenIdsKey);\r\n                prices[i] = order.price;\r\n                data[i][0] = uint(order.buyOrSell);\r\n                data[i][1] = uint(order.anyOrAll);\r\n                data[i][2] = uint(order.expiry);\r\n                data[i][3] = uint(order.tradeCount);\r\n                data[i][4] = uint(order.tradeMax);\r\n                data[i][5] = uint(order.royaltyFactor);\r\n                data[i][6] = uint(orderStatus(token, order));\r\n            }\r\n        }\r\n    }\r\n\r\n    function getTrades(\r\n        uint[] memory tradeIndexes\r\n    ) public view returns (\r\n        address[] memory takers,\r\n        uint[] memory royaltyFactors,\r\n        uint[] memory blockNumbers,\r\n        Nix.ExecutedOrder[][] memory ordersList\r\n    ) {\r\n        uint length = tradeIndexes.length;\r\n        takers = new address[](length);\r\n        royaltyFactors = new uint[](length);\r\n        blockNumbers = new uint[](length);\r\n        ordersList = new Nix.ExecutedOrder[][](length);\r\n        (, uint tradesLength) = nix.getLengths();\r\n        for (uint i = 0; i < length; i++) {\r\n            uint tradeIndex = tradeIndexes[i];\r\n            if (tradeIndex < tradesLength) {\r\n                (address taker, uint64 royaltyFactor, uint64 blockNumber, Nix.ExecutedOrder[] memory orders) = nix.getTrade(tradeIndex);\r\n                takers[i] = taker;\r\n                royaltyFactors[i] = royaltyFactor;\r\n                blockNumbers[i] = blockNumber;\r\n                ordersList[i] = orders;\r\n            }\r\n        }\r\n    }\r\n}"}}}