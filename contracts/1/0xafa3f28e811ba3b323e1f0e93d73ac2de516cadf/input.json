{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Kaiba_IVC.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.10;\r\n\r\nlibrary SafeMath {\r\n\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory  errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory  errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (bytes32 );\r\n    function symbol() external pure returns (bytes32 );\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// IVC (Internal Virtual Chain)\r\n// (c) Kaiba DeFi DAO 2021\r\n\r\n// This source code is distributed under the CC-BY-ND-4.0 License https://spdx.org/licenses/CC-BY-ND-4.0.html#licenseText\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n\r\n    function symbol() external view returns (bytes32 );\r\n    function name() external view returns (bytes32 );\r\n    function decimals() external view returns (uint8);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n /////////////////////////////////////////////////////// Plugin interface\r\n\r\n    interface IVC_Plugin {\r\n        // pay extreme attention to these methods\r\n        function exists() external view returns (bool success);      \r\n        function svt_method_call_id(uint256 mid) external returns (bool, bytes32 );  \r\n        function svt_method_call_name(bytes32  mname) external returns (bool, bytes32 );\r\n    }\r\n\r\n\r\n\r\ncontract Kaiba_IVC {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /// @notice Fees balances\r\n    uint256 tax_multiplier = 995; //0.05%\r\n    uint256 taxes_eth_total;\r\n    mapping(address => uint256) taxes_token_total;\r\n    mapping (uint256 => uint256) taxes_native_total;\r\n    address kaiba_address = 0x8BB048845Ee0d75BE8e07954b2e1E5b51B64b442;\r\n    address owner;\r\n    // Rinkeby: 0xc778417E063141139Fce010982780140Aa0cD5Ab\r\n    // Mainnet: 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address constant ZERO = 0x000000000000000000000000000000000000dEaD;\r\n    ERC20 kaiba = ERC20(kaiba_address);\r\n\r\n    // Constructor\r\n    constructor () {\r\n        is_team[msg.sender] = true;\r\n        owner = msg.sender;\r\n        is_locked[841] = true;\r\n        is_locked[471] = true;\r\n        /// @notice defining WETH -> KVETH\r\n        SVT_address[0].deployed = true;\r\n        SVT_address[0].tokenOwner = owner;\r\n        SVT_address[0].totalSupply = 0;\r\n        SVT_address[0].circulatingSupply = 0;\r\n        SVT_address[0].name = \"Kaiba Virtual ETH\";\r\n        SVT_address[0].ticker = \"WETH\";\r\n        SVT_address[0].isBridged = true;\r\n        SVT_address[0].original_token = WETH; \r\n        SVT_address[0].SVT_Liquidity_storage = 0;\r\n        /// @notice also defining the liquidity\r\n        SVT_Liquidity_index[0].deployed = true;\r\n        SVT_Liquidity_index[0].active = true;\r\n        SVT_Liquidity_index[0].liq_mode = 4;\r\n        SVT_Liquidity_index[0].token_1 = ERC20(SVT_address[0].original_token);\r\n        SVT_Liquidity_index[0].SVT_token_id = 0;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////// Access control\r\n\r\n    /// @notice this part defines plugins that can access to editing methods. Be careful\r\n\r\n    mapping(address => bool) has_access;\r\n    mapping(address => mapping(uint256 => bool)) has_access_to;\r\n\r\n    mapping (address => bool) is_team;\r\n\r\n    struct auth_control {\r\n        mapping(address => bool) is_auth;\r\n    }\r\n\r\n    mapping(address => auth_control) bridge_is_auth;\r\n\r\n    mapping(uint256 => bool) is_locked;\r\n\r\n    bool internal locked;\r\n    bool internal open_bridge;\r\n\r\n    modifier can_access(uint256 specific) {\r\n        if(specific==0) {\r\n            require(has_access[msg.sender], \"Not authorized\");\r\n        } else {\r\n            require(has_access_to[msg.sender][specific], \"Not authorized\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier safe() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    modifier Unlocked(uint256 name) {\r\n        require(!is_locked[name]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuth(address to_bridge) {\r\n        require(bridge_is_auth[msg.sender].is_auth[to_bridge] ||  msg.sender==owner || open_bridge, \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyTeam {\r\n        require(is_team[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function acl_check_access(uint256 specific) public view returns(bool) {\r\n        if(specific==0) {\r\n            return has_access[msg.sender];\r\n        } else {\r\n            return has_access_to[msg.sender][specific];\r\n        }\r\n    }\r\n\r\n    function acl_give_access(address addy, bool booly) public onlyTeam {\r\n        has_access[addy] = booly;\r\n    }\r\n\r\n    function acl_give_specific_access(address addy, uint256 specific, bool booly) public onlyTeam {\r\n        has_access_to[addy][specific] = booly;\r\n    }\r\n\r\n    function acl_add_team(address addy) public onlyTeam {\r\n        is_team[addy] = true;\r\n    }\r\n\r\n    function acl_remove_team(address addy) public onlyTeam {\r\n        is_team[addy] = false;\r\n    }\r\n\r\n    function acl_locked_function(uint256 name, bool booly) public onlyTeam {\r\n        is_locked[name] = booly;\r\n    }\r\n\r\n    function acl_open_bridge(bool booly) public onlyTeam {\r\n        open_bridge = booly;\r\n    }\r\n\r\n    function acl_set_kaiba(address addy) public onlyTeam {\r\n        kaiba_address = addy;\r\n    }\r\n    \r\n    function acl_set_tax_multiplier(uint256 multiplier) public onlyTeam {\r\n        tax_multiplier = multiplier;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////// Structures\r\n\r\n    struct SVTLiquidity {  // This struct defines the types of liquidity and the relative properties\r\n        bool active;\r\n        bool deployed;\r\n        bool native_pair;\r\n        ERC20 token_1; // Always the SVT token\r\n        ERC20 token_2; // Always the native or the paired\r\n        uint256 token_1_qty; \r\n        uint256 token_2_qty;\r\n        uint256 SVT_token_id;\r\n        uint256 liq_mode; // 1: Direct pair, 2: synthetic, 3: native, 4: WETH\r\n        // Mode specific variables\r\n        IUniswapV2Pair pair; // Needed in mode 2, 3\r\n        uint256 token_2_native;\r\n    }\r\n\r\n    mapping (uint256 => SVTLiquidity) SVT_Liquidity_index;\r\n    uint256 svt_liquidity_last_id = 0;\r\n\r\n    struct SVT { // This struct defines a typical SVT token\r\n        bool deployed;\r\n        bool is_svt_native;\r\n        bool is_synthetic;\r\n        string balance_url;\r\n        address tokenOwner;\r\n        uint256 totalSupply;\r\n        uint256 circulatingSupply;\r\n        mapping (address => uint256) balance;\r\n        uint256[] fees;\r\n        mapping(uint256 => uint256) fees_storage;\r\n        bytes32 name;\r\n        bytes32 ticker;\r\n        bool isBridged;\r\n        address original_token;\r\n        address pair_address;\r\n        uint256 SVT_Liquidity_storage;\r\n        mapping(address => bool) synthesis_control;\r\n    }\r\n\r\n    mapping (uint256 => SVT) SVT_address;\r\n    uint256 svt_last_id = 0;\r\n\r\n    /// @notice Manage the imported status of ERC20 tokens \r\n    mapping (address => bool) imported;\r\n    mapping (address => uint256) imported_id;\r\n    struct pairs_for_token {\r\n        address token_address;\r\n        mapping(address => bool) paired_with;\r\n    }\r\n    mapping (bytes32 => bool) liquidity;\r\n\r\n    /// @notice Tracking imported balances of IVC addresses\r\n    mapping (address => uint256) IVC_native_balance;\r\n    uint256 IVC_native_balance_total;\r\n\r\n    /////////////////////////////////////////////////////// Access endpoints\r\n\r\n    function modify_address_balance(bool native, uint256 svt_id, address addy, uint256 ending) public can_access(0) {\r\n        if(native) {\r\n            IVC_native_balance[addy] = ending;\r\n            SVT_address[0].balance[addy] = ending;\r\n        } else {\r\n            SVT_address[svt_id].balance[addy] = ending;\r\n        }\r\n    }\r\n\r\n    function modify_update_pair(uint256 svt_liq_id, uint256 tkn_1_qty, uint256 tkn_2_qty, address tkn_1, address tkn_2) public can_access(0) {\r\n        if(tkn_2 == WETH) {\r\n            SVT_Liquidity_index[svt_liq_id].native_pair = true;\r\n        } else {\r\n            SVT_Liquidity_index[svt_liq_id].native_pair = false;\r\n        }\r\n        SVT_Liquidity_index[svt_liq_id].token_1 =ERC20(tkn_1); // Always the SVT token\r\n        SVT_Liquidity_index[svt_liq_id].token_2 =ERC20(tkn_2);\r\n        SVT_Liquidity_index[svt_liq_id].token_1_qty = tkn_1_qty;\r\n        SVT_Liquidity_index[svt_liq_id].token_2_qty = tkn_2_qty;\r\n    }\r\n\r\n\r\n    /////////////////////////////////////////////////////// Get endpoints\r\n\r\n    // List of deployed tokens\r\n    function get_svt_pools() external view returns (uint256) {\r\n        return svt_last_id;\r\n    }\r\n\r\n    // Address to SVT id\r\n    function get_svt_id(address addy) external  view returns(bool, uint256) {\r\n        if(imported[addy]) {\r\n            return (true, imported_id[addy]);\r\n        } else {\r\n            return (false, 0);\r\n        }\r\n    }\r\n\r\n    // Get the internal liquidity of a SVT token\r\n\r\n    function get_svt_liquidity(uint256 svt_id) external  view returns (bool, bool, address, address, uint256, uint256, uint256, address, uint256, bool) {\r\n        require(SVT_address[svt_id].deployed, \"SVT Token does not exist\");\r\n        require(!SVT_address[svt_id].is_synthetic, \"No pools in a synthetic coin\");\r\n        uint256 liq_index = SVT_address[svt_id].SVT_Liquidity_storage;\r\n        require(SVT_Liquidity_index[liq_index].deployed, \"SVT Token has no liquidity\");\r\n        return (SVT_Liquidity_index[liq_index].active,\r\n                SVT_Liquidity_index[liq_index].deployed,\r\n                address(SVT_Liquidity_index[liq_index].token_1),\r\n                address(SVT_Liquidity_index[liq_index].token_2),\r\n                SVT_Liquidity_index[liq_index].token_1_qty,\r\n                SVT_Liquidity_index[liq_index].token_2_qty,\r\n                SVT_Liquidity_index[liq_index].liq_mode,\r\n                address(SVT_Liquidity_index[liq_index].pair),\r\n                0,\r\n                SVT_Liquidity_index[liq_index].native_pair); \r\n    }\r\n\r\n    function get_synthetic_svt_liquidity(uint256 svt_id) external  view returns (address, address, uint256, uint256) {\r\n        require(SVT_address[svt_id].deployed, \"SVT Token does not exist\");\r\n        require(SVT_address[svt_id].is_synthetic, \"Not a synthetic asset\");\r\n        IUniswapV2Pair pair = IUniswapV2Pair(SVT_address[svt_id].pair_address);\r\n        address token0_frompair = pair.token0();\r\n        address token1_frompair = pair.token1();\r\n        (uint Res0, uint Res1,) = pair.getReserves();\r\n        return(token0_frompair, token1_frompair, Res0, Res1);\r\n    }\r\n\r\n\r\n    // Get the price of a token in eth\r\n\r\n    function get_token_price(address pairAddress, uint amount) external  view returns(uint)\r\n    {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\r\n        address token1_frompair = pair.token1();\r\n        ERC20 token1 = ERC20(token1_frompair);\r\n        (uint Res0, uint Res1,) = pair.getReserves();\r\n\r\n        // decimals\r\n        uint res0 = Res0*(10**token1.decimals());\r\n        return((amount*res0)/Res1); // return amount of token0 needed to buy token1\r\n    }\r\n\r\n    // Return the SVT balance of an address\r\n\r\n    function get_svt_address_balance(address addy, uint256 svt_id) public  view returns(uint256) {\r\n        require(SVT_address[svt_id].deployed, \"This token does not exists\");\r\n        return SVT_address[svt_id].balance[addy];\r\n    }\r\n\r\n    // Return the IVC balance of an address\r\n    function get_ivc_balance(address addy) public  view returns(uint256) {\r\n        return(IVC_native_balance[addy]);\r\n    }\r\n\r\n    function get_ivc_stats() external  view returns(uint256) {\r\n        return(IVC_native_balance_total);\r\n    }\r\n\r\n    // Return the properties of a SVT token\r\n\r\n    function get_svt(uint256 addy) external  view returns (address, uint256, uint256, uint256[] memory, bytes32 , bytes32 ) {\r\n        require(SVT_address[addy].deployed, \"Token not deployed\");\r\n        address tokenOwner = SVT_address[addy].tokenOwner;\r\n        uint256 supply = SVT_address[addy].totalSupply;\r\n        uint256 circulatingSupply = SVT_address[addy].circulatingSupply;\r\n        uint256[] memory fees = SVT_address[addy].fees;\r\n        bytes32  name = SVT_address[addy].name;\r\n        bytes32  ticker = SVT_address[addy].ticker;\r\n        return (tokenOwner, supply, circulatingSupply, fees, name, ticker);\r\n\r\n    }\r\n\r\n    // Return bridged status of a SVT token \r\n\r\n    function get_svt_bridge_status(uint256 addy) external  view returns (bool, address) {\r\n        return(SVT_address[addy].isBridged, SVT_address[addy].original_token);\r\n    }\r\n\r\n    \r\n    // Return KVETH balance of an address\r\n\r\n    function get_svt_kveth_balance(address addy) external  view returns (uint256) {\r\n        return(IVC_native_balance[addy]);\r\n    }\r\n\r\n     ///////////////////////////////////////////////////// // Transfer functions\r\n\r\n    function operate_mass_synthetic_update(uint256 svt_id, string calldata url) public can_access(1) {\r\n        require(SVT_address[svt_id].deployed, \"No assets\");\r\n        require(SVT_address[svt_id].is_synthetic, \"No synthetic\");\r\n        require(SVT_address[svt_id].synthesis_control[msg.sender], \"Denied\");\r\n        SVT_address[svt_id].balance_url = url;\r\n    }\r\n\r\n    function operate_delegated_synthetic_retrieve(address to, uint256 svt_id, uint256 qty, uint256 delegated_balance, address main_reserve) public can_access(1) {\r\n        require(SVT_address[svt_id].deployed, \"No assets\");\r\n        require(SVT_address[svt_id].is_synthetic, \"No synthetic\");\r\n        require(delegated_balance >= qty, \"Not enough tokens\");\r\n        require(SVT_address[svt_id].synthesis_control[msg.sender], \"Denied\");\r\n        ERC20 on_main = ERC20(SVT_address[svt_id].original_token);\r\n        require(on_main.balanceOf(SVT_address[svt_id].original_token) >= qty, \"Not enough tokens on mainnet\");\r\n        require(on_main.allowance(main_reserve, address(this)) >= qty, \"Allowance too low\");\r\n        on_main.transferFrom(main_reserve, to, qty);\r\n    }\r\n\r\n    function operate_tx_swap(uint256 svt_id, uint256 qty, address receiver, uint256 direction) public  safe\r\n        returns (uint256, uint256, uint256, uint256) {\r\n        uint256 to_deposit_liq;\r\n        uint256 to_withdraw_liq;\r\n        /// @notice Sanity checks\r\n        require(SVT_address[svt_id].deployed, \"SVT token does not exist\");\r\n        uint256 liq_index = SVT_address[svt_id].SVT_Liquidity_storage;\r\n        require(SVT_Liquidity_index[liq_index].active, \"SVT liquidity does not exist\");\r\n        if(direction==1) {\r\n            require(get_svt_address_balance(msg.sender, svt_id) >= qty, \"Balance is too low\");\r\n            /// @notice Getting liquidity\r\n            to_deposit_liq = SVT_Liquidity_index[liq_index].token_1_qty;\r\n            to_withdraw_liq = SVT_Liquidity_index[liq_index].token_2_qty;\r\n        } else {\r\n            require(IVC_native_balance[msg.sender] >= qty, \"Balance is too low\");\r\n            to_deposit_liq = SVT_Liquidity_index[liq_index].token_2_qty;\r\n            to_withdraw_liq = SVT_Liquidity_index[liq_index].token_1_qty;\r\n        }\r\n        /// @notice Getting taxes\r\n        uint256 local_whole_tax = calculate_taxes(svt_id, qty);\r\n        require(local_whole_tax<qty, \"Taxes too high\");\r\n        qty -= local_whole_tax;\r\n        /// @notice Getting output amount\r\n        uint256 amount_out = operate_ivc_get_amount_out(qty, to_deposit_liq, to_withdraw_liq);\r\n        /// @notice Updating liquidity and balances if it is not a simulation\r\n        if(direction==1) {\r\n            SVT_Liquidity_index[liq_index].token_1_qty += qty;\r\n            SVT_address[svt_id].balance[msg.sender] -= qty;\r\n            SVT_Liquidity_index[liq_index].token_2_qty -= amount_out;\r\n            IVC_native_balance[receiver] += amount_out;\r\n            IVC_native_balance_total += amount_out;\r\n        } else {\r\n            SVT_Liquidity_index[liq_index].token_1_qty -= amount_out;\r\n            SVT_address[svt_id].balance[receiver] += amount_out;\r\n            SVT_Liquidity_index[liq_index].token_2_qty += qty;\r\n            IVC_native_balance[msg.sender] -= qty;\r\n            IVC_native_balance_total -= qty;\r\n        }\r\n        /// @notice return the amount\r\n        return (amount_out,\r\n                SVT_address[svt_id].balance[receiver],\r\n                IVC_native_balance[msg.sender], svt_id);\r\n\r\n    }\r\n    \r\n\r\n    function simulate_tx_swap(uint256 svt_id, uint256 qty, uint8 direction) public view\r\n        returns (uint256) {\r\n        /// @notice Sanity checks\r\n        require(SVT_address[svt_id].deployed, \"SVT token does not exist\");\r\n        uint256 liq_index = SVT_address[svt_id].SVT_Liquidity_storage;\r\n        uint256 amount_out;\r\n        require(SVT_Liquidity_index[liq_index].active, \"SVT liquidity does not exist\");\r\n        if (direction==1) {\r\n            require(get_svt_address_balance(msg.sender, svt_id) >= qty, \"Balance is too low\");\r\n            uint256 to_withdraw_liq = SVT_Liquidity_index[liq_index].token_2_qty;\r\n            uint256 to_deposit_liq = SVT_Liquidity_index[liq_index].token_1_qty;\r\n            /// @notice Getting liquidity\r\n            /// @notice Getting output amount\r\n            amount_out = operate_ivc_get_amount_out(qty, to_deposit_liq, to_withdraw_liq);  \r\n        }else {\r\n            require(IVC_native_balance[msg.sender] >= qty, \"Balance is too low\");           \r\n            uint256 to_deposit_liq = SVT_Liquidity_index[liq_index].token_2_qty;\r\n            uint256 to_withdraw_liq = SVT_Liquidity_index[liq_index].token_1_qty;\r\n            /// @notice Getting liquidity\r\n            /// @notice Getting output amount\r\n            amount_out = operate_ivc_get_amount_out(qty, to_deposit_liq, to_withdraw_liq);\r\n        }\r\n        /// @notice Updating liquidity and balances if it is not a simulation\r\n        /// @notice return the amount\r\n        return amount_out;\r\n\r\n    }\r\n\r\n    /////////////////////////////////////////////////////// Entry and exit point functions\r\n\r\n    uint256 exit_lock_time = 5 minutes;\r\n    uint256 entry_lock_time = 2 minutes;\r\n    mapping(address => bool) exit_suspended;\r\n    mapping(address => bool) entry_suspended;\r\n    mapping(address => uint256) exit_lock;\r\n    mapping(address => uint256) entry_lock;\r\n\r\n    function entry_from_eth() public payable safe returns (uint256){\r\n        require(msg.value >= 10000000000000000, \"Unpayable\");\r\n        require(!entry_suspended[msg.sender], \"Suspended\");\r\n        require(entry_lock[msg.sender] + entry_lock_time < block.timestamp, \"Please wait\");\r\n        uint256 qty_to_credit = msg.value;\r\n        SVT_address[0].balance[msg.sender] += taxes_include_fee(qty_to_credit);\r\n        IVC_native_balance[msg.sender] += taxes_include_fee(qty_to_credit);\r\n        IVC_native_balance_total += qty_to_credit;\r\n        taxes_eth_total += qty_to_credit - taxes_include_fee(qty_to_credit);\r\n        entry_lock[msg.sender] = block.timestamp;\r\n        return qty_to_credit;\r\n    }\r\n\r\n    function exit_to_eth(uint256 qty, address recv) public safe returns (uint256) {\r\n        require(address(this).balance > qty, \"Unpayable: No liq?\");\r\n        require(IVC_native_balance[msg.sender] >= qty, \"No KVETH\");\r\n        require(SVT_address[0].balance[msg.sender] >= qty, \"No KVETH\");\r\n        require(!exit_suspended[msg.sender], \"Suspended\");\r\n        require(!exit_suspended[recv], \"Suspended\");\r\n        require(exit_lock[msg.sender] + exit_lock_time < block.timestamp, \"Please wait\");\r\n        require(exit_lock[recv] + exit_lock_time < block.timestamp, \"Please wait\");\r\n        exit_lock[msg.sender] = block.timestamp;\r\n        IVC_native_balance[msg.sender] -= qty;\r\n        IVC_native_balance_total -= taxes_include_fee(qty);\r\n        SVT_address[0].balance[msg.sender] -= qty;\r\n        payable(recv).transfer(taxes_include_fee(qty));\r\n        taxes_native_total[0] += qty - taxes_include_fee(qty);\r\n        return qty;\r\n    }\r\n\r\n    /// @notice Unbridge to ETH a quantity of SVT token\r\n\r\n    function exit_to_token(address token, uint256 qty) public safe {\r\n        ERC20 from_token = ERC20(token);\r\n        // Security and uniqueness checks\r\n        require(imported[token], \"This token is not imported\");\r\n        uint256 unbridge_id = imported_id[token];\r\n        require(SVT_address[unbridge_id].balance[msg.sender] >= qty, \"You don't have enough tokens\");\r\n        require(from_token.balanceOf(address(this)) >= qty, \"There aren't enough tokens\");\r\n        from_token.transfer(msg.sender, taxes_include_fee(qty));\r\n        if (SVT_address[unbridge_id].circulatingSupply < 0) {\r\n            SVT_address[unbridge_id].circulatingSupply = 0;\r\n        }\r\n        SVT_address[unbridge_id].balance[msg.sender] -= qty;\r\n        taxes_native_total[unbridge_id] += qty - taxes_include_fee(qty);\r\n    }\r\n\r\n   \r\n    /////////////////////////////////////////////////////// Public functions\r\n\r\n    function operate_transfer_svt(uint256 svt_id, address sender, address receiver, uint256 qty) public {\r\n        require(SVT_address[svt_id].deployed, \"This token does not exists\");\r\n        require(SVT_address[svt_id].balance[sender] >= qty, \"You don't own enough tokens\");\r\n        uint256 local_whole_tax = calculate_taxes(svt_id, qty);\r\n        require(local_whole_tax<qty, \"Taxes too high\");\r\n        qty -= local_whole_tax;\r\n        SVT_address[svt_id].balance[sender] -= taxes_include_fee(qty) ;\r\n        delete sender;\r\n        SVT_address[svt_id].balance[receiver] += taxes_include_fee(qty);\r\n        delete receiver;\r\n        delete qty;\r\n        taxes_native_total[svt_id] += taxes_include_fee(qty);\r\n    }\r\n\r\n\r\n    /////////////////////////////////////////////////////// Plugins functions\r\n\r\n    mapping(uint256 => IVC_Plugin) plugin_loaded;\r\n    uint256 plugin_free_id = 0;\r\n    mapping(uint256 => uint256[]) plugins_methods_id;\r\n    mapping(uint256 => bytes32[]) plugins_methods_strings;\r\n\r\n    function add_svt_plugin(address plugin_address) public onlyTeam returns (uint256){\r\n        plugin_loaded[plugin_free_id] = IVC_Plugin(plugin_address);\r\n        plugin_free_id += 1;\r\n        return (plugin_free_id -1);\r\n    }\r\n\r\n\r\n    /// @notice The next two functions are responsible to check against the initialized plugin methods ids or names. Require is used to avoid tx execution with gas if fails\r\n\r\n    function check_ivc_plugin_method_id(uint256 plugin, uint256 id) public view onlyTeam returns (bool) {\r\n        require(plugin_loaded[plugin].exists(), \"Plugin not loaded or not existant\");\r\n        bool found = false;\r\n        for (uint256 i = 0; i < plugins_methods_id[plugin].length; i++) {\r\n            if (plugins_methods_id[plugin][i] == id) {\r\n                return true;\r\n            }\r\n        }\r\n        require(found);\r\n        return false;\r\n    }\r\n\r\n    function check_ivc_plugin_method_name(uint256 plugin, bytes32 name) public view onlyTeam returns (bool) {\r\n        require(plugin_loaded[plugin].exists(), \"Plugin not loaded or not existant\");\r\n        bool found = false;\r\n        for (uint256 i = 0; i < plugins_methods_id[plugin].length; i++) {\r\n            if (plugins_methods_strings[plugin][i] == name) {\r\n                return true;\r\n            }\r\n        }\r\n        require(found);\r\n        return false;\r\n    }\r\n\r\n    /// @notice The following methods are able to call either a method id or method name from a given plugin\r\n\r\n    function execute_ivc_plugin_method_id(uint256 plugin, uint256 id) public onlyTeam returns (bool, bytes32 ) {\r\n        require(check_ivc_plugin_method_id(plugin, id), \"Error in verifying method\");\r\n        return plugin_loaded[plugin].svt_method_call_id(id);\r\n    }\r\n\r\n    function execute_ivc_plugin_method_id(uint256 plugin, bytes32  name) public onlyTeam returns (bool, bytes32 ) {\r\n        require(check_ivc_plugin_method_name(plugin, name), \"Error in verifying method\");\r\n        return plugin_loaded[plugin].svt_method_call_name(name);\r\n    }\r\n\r\n\r\n    /////////////////////////////////////////////////////// Utility functions\r\n\r\n    function taxes_include_fee(uint256 initial) private view returns (uint256) {\r\n        return( (initial*tax_multiplier) / 1000 );\r\n    }\r\n\r\n    function calculate_taxes(uint256 svt_id, uint256 qty) private returns (uint256) {\r\n        uint256 local_whole_tax = 0;\r\n        for(uint i=0; i<SVT_address[svt_id].fees.length; i++) {\r\n            SVT_address[svt_id].fees_storage[i] += (qty * SVT_address[svt_id].fees[i])/100;\r\n            local_whole_tax += (qty * SVT_address[svt_id].fees[i])/100;\r\n        }\r\n        return local_whole_tax;\r\n    }\r\n\r\n    function operate_ivc_get_amount_out(uint256 to_deposit, uint256 to_deposit_liq, uint256 to_withdraw_liq) public pure returns (uint256 out_qty) {\r\n        require(to_deposit > 0, 'KaibaSwap: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(to_deposit_liq > 0 && to_withdraw_liq > 0, 'KaibaSwap: INSUFFICIENT_LIQUIDITY');\r\n        uint to_deposit_with_fee = to_deposit.mul(997);\r\n        uint numerator = to_deposit_with_fee.mul(to_withdraw_liq);\r\n        uint denominator = to_deposit_liq.mul(1000).add(to_deposit_with_fee);\r\n        out_qty = numerator / denominator;\r\n        return out_qty;\r\n    }\r\n\r\n    /// @notice Authorize a specific address to operate on a token\r\n    function authorize_on_token(address to_authorize, address to_bridge) public onlyTeam {\r\n        bridge_is_auth[to_authorize].is_auth[to_bridge] = true;\r\n    }\r\n\r\n\r\n    /// @notice This function allows issuance of native coins\r\n    function issue_native_svt(\r\n        bytes32  name,\r\n        bytes32  ticker,\r\n        uint256 max_supply,\r\n        uint256[] calldata fees) \r\n    public Unlocked(1553) safe {\r\n        uint256 thisAddress = svt_last_id+1;\r\n        SVT_address[thisAddress].deployed = true;\r\n        SVT_address[thisAddress].circulatingSupply = max_supply;\r\n        SVT_address[thisAddress].totalSupply = max_supply;\r\n        SVT_address[thisAddress].fees = fees;\r\n        SVT_address[thisAddress].name = name;\r\n        SVT_address[thisAddress].ticker = ticker;\r\n        SVT_address[thisAddress].isBridged = true;\r\n        SVT_address[thisAddress].original_token = ZERO;\r\n        SVT_address[thisAddress].balance[msg.sender] = taxes_include_fee(max_supply);\r\n        SVT_address[thisAddress].SVT_Liquidity_storage = svt_liquidity_last_id + 1;\r\n        svt_liquidity_last_id += 1;\r\n        taxes_native_total[thisAddress] += max_supply - taxes_include_fee(max_supply);\r\n    }\r\n\r\n    function native_add_liq(uint256 svt_id, uint256 qty) payable public safe { \r\n        require(msg.value > 10000000000000000, \"Too low\");\r\n        require(SVT_address[svt_id].deployed, \"SVT does not exists\");\r\n        uint256 thisLiquidity = SVT_address[svt_id].SVT_Liquidity_storage;\r\n        require(!SVT_Liquidity_index[thisLiquidity].active, \"Pair is already alive\");\r\n        SVT_Liquidity_index[thisLiquidity].active = true;\r\n        SVT_Liquidity_index[thisLiquidity].deployed = true;\r\n        SVT_Liquidity_index[thisLiquidity].token_1 = ERC20(WETH);\r\n        SVT_Liquidity_index[thisLiquidity].token_2 = ERC20(ZERO);\r\n        SVT_Liquidity_index[thisLiquidity].token_1_qty += msg.value;\r\n        SVT_Liquidity_index[thisLiquidity].token_2_qty += qty;\r\n        SVT_Liquidity_index[thisLiquidity].SVT_token_id = svt_id;\r\n        SVT_Liquidity_index[thisLiquidity].liq_mode = 1;\r\n    }\r\n\r\n    /// @notice this returns the url with synthetic balances\r\n\r\n    function get_synthetic_svt_url(uint256 svt_id) public returns (string memory, address, address) {\r\n        require(SVT_address[svt_id].deployed=true, \"No token\");\r\n        require(SVT_address[svt_id].is_synthetic=true, \"No synthesis\");\r\n        return(SVT_address[svt_id].balance_url, SVT_address[svt_id].pair_address, SVT_address[svt_id].original_token);\r\n    }\r\n\r\n    /// @notice struct and methods to assign liquidity\r\n\r\n    struct liquidity_owner_stats {\r\n        mapping(bytes32 => bool) owned;\r\n        mapping(bytes32 => uint256) qty_1;\r\n        mapping(bytes32 => uint256) qty_2;\r\n    }\r\n\r\n    mapping(address => liquidity_owner_stats) liquidity_owned; \r\n\r\n    /// @notice If authorized, allows to pair two ERC20 tokens to an SVT Liquidity Pair\r\n    /// @dev remember to approve beforehand\r\n\r\n     function create_svt_synthetic(address to_bridge, address pair, string calldata url) public Unlocked(5147) onlyAuth(to_bridge) {\r\n        require(!imported[to_bridge], \"Already synthetized\");\r\n        svt_last_id +=1;\r\n        uint256 thisAddress = svt_last_id;\r\n        imported[to_bridge] = true;\r\n        imported_id[to_bridge] = thisAddress;\r\n        SVT_address[thisAddress].deployed = true;\r\n        SVT_address[thisAddress].totalSupply = ERC20(to_bridge).totalSupply();\r\n        SVT_address[thisAddress].circulatingSupply = ERC20(to_bridge).totalSupply();\r\n        SVT_address[thisAddress].is_synthetic = true;\r\n        SVT_address[thisAddress].balance_url = url;\r\n        SVT_address[thisAddress].original_token = to_bridge;\r\n        SVT_address[thisAddress].pair_address = pair;\r\n        SVT_address[thisAddress].name = ERC20(to_bridge).name();\r\n        SVT_address[thisAddress].ticker = ERC20(to_bridge).symbol();        \r\n     }\r\n\r\n    function create_svt_native(bytes32[] calldata strings, uint256[] calldata params, uint256[] calldata fees) public Unlocked(471)  returns(uint256, uint256){\r\n        svt_last_id += 1;\r\n        svt_liquidity_last_id += 1;\r\n        SVT_address[svt_last_id].deployed = true;\r\n        SVT_address[svt_last_id].is_svt_native = true;\r\n        SVT_address[svt_last_id].tokenOwner = msg.sender;\r\n        SVT_address[svt_last_id].totalSupply = params[0];\r\n        SVT_address[svt_last_id].circulatingSupply = params[1];\r\n        SVT_address[svt_last_id].balance[msg.sender] = params[0];\r\n        SVT_address[svt_last_id].fees = fees;\r\n        SVT_address[svt_last_id].name = strings[0];\r\n        SVT_address[svt_last_id].ticker = strings[1];\r\n        SVT_address[svt_last_id].SVT_Liquidity_storage = svt_liquidity_last_id;\r\n        return (svt_last_id, svt_liquidity_last_id);\r\n    }\r\n\r\n    function create_svt_native_pair(uint256 to_add, uint256 to_bridge, uint256 qty_1, uint256 qty_2) public Unlocked(471) {\r\n        require(SVT_address[to_add].deployed && SVT_address[to_bridge].deployed, \"Missing tokens\");\r\n        require((SVT_address[to_add].balance[msg.sender] >= qty_1) && (SVT_address[to_bridge].balance[msg.sender] >= qty_2), \"Not enough tokens\");\r\n        uint256 to_add_liq = SVT_address[to_add].SVT_Liquidity_storage;\r\n        if(!SVT_Liquidity_index[to_add_liq].active) {\r\n            SVT_Liquidity_index[to_add_liq].active = true;\r\n        } else {\r\n            uint256 ratio = (SVT_Liquidity_index[to_add_liq].token_1_qty / SVT_Liquidity_index[to_add_liq].token_2_qty);\r\n            require((qty_1/qty_2) == ratio, \"Wrong ratio\");\r\n        }\r\n            SVT_address[to_add].balance[msg.sender] -= qty_1;\r\n            SVT_address[to_bridge].balance[msg.sender] -= qty_2;\r\n            SVT_Liquidity_index[to_add_liq].token_1_qty += taxes_include_fee(qty_1);\r\n            SVT_Liquidity_index[to_add_liq].token_2_qty += taxes_include_fee(qty_2);\r\n            SVT_address[to_add].balance[owner] += (qty_1 - taxes_include_fee(qty_1));\r\n            SVT_address[to_bridge].balance[owner] += (qty_2 - taxes_include_fee(qty_2));\r\n            SVT_Liquidity_index[to_add_liq].SVT_token_id = to_add;\r\n            SVT_Liquidity_index[to_add_liq].token_2_native = to_bridge;\r\n            SVT_Liquidity_index[to_add_liq].liq_mode = 3;\r\n\r\n    }\r\n\r\n    function create_svt_pair(address to_bridge, address to_pair,  uint256 qty_1, uint256 qty_2) public Unlocked(841) onlyAuth(to_bridge) {\r\n        ERC20 from_token = ERC20(to_bridge);\r\n        ERC20 from_pair = ERC20(to_pair);\r\n        bytes32 pool_name = keccak256(abi.encodePacked(from_token.name() , from_pair.name()));\r\n        delete to_bridge;\r\n        delete to_pair;\r\n        require(from_token.balanceOf(msg.sender) >= qty_1, \"You don't have enough tokens (1)\");\r\n        require(from_pair.balanceOf(msg.sender) >= qty_2, \"You don't have enough tokens (2)\");\r\n        // Approve and transfer tokens, keeping 1% as fee\r\n        from_token.transferFrom(msg.sender, address(this), qty_1);\r\n        from_pair.transferFrom(msg.sender, address(this), qty_2);\r\n        uint256 thisAddress;\r\n        uint256 thisLiquidity;\r\n        if (liquidity[pool_name]) {\r\n            uint256 ratio = (SVT_Liquidity_index[thisLiquidity].token_1_qty / SVT_Liquidity_index[thisLiquidity].token_2_qty);\r\n            require((qty_1/qty_2) == ratio, \"Wrong ratio\");\r\n            thisAddress = imported_id[to_bridge];\r\n            thisLiquidity = SVT_address[thisAddress].SVT_Liquidity_storage;\r\n\r\n        } else {\r\n            svt_last_id +=1;\r\n            svt_liquidity_last_id += 1;\r\n            thisAddress = svt_last_id;\r\n            thisLiquidity = svt_liquidity_last_id;\r\n            imported[to_bridge] = true;\r\n            imported_id[to_bridge] = thisAddress;\r\n            liquidity[pool_name] = true;\r\n        }\r\n        // Liquidity add\r\n        if (to_pair == WETH) { \r\n            SVT_Liquidity_index[thisLiquidity].native_pair = true;\r\n        }\r\n        SVT_Liquidity_index[thisLiquidity].active = true;\r\n        SVT_Liquidity_index[thisLiquidity].deployed = true;\r\n        SVT_Liquidity_index[thisLiquidity].token_1 = ERC20(to_bridge);\r\n        SVT_Liquidity_index[thisLiquidity].token_2 = ERC20(to_pair);\r\n        delete to_pair;\r\n        SVT_Liquidity_index[thisLiquidity].token_1_qty += taxes_include_fee(qty_1);\r\n        SVT_Liquidity_index[thisLiquidity].token_2_qty += taxes_include_fee(qty_2);\r\n        SVT_Liquidity_index[thisLiquidity].SVT_token_id = thisAddress;\r\n        SVT_Liquidity_index[thisLiquidity].liq_mode = 1;\r\n        // Token definition\r\n        SVT_address[thisAddress].deployed = true;\r\n        SVT_address[thisAddress].circulatingSupply += qty_1;\r\n        liquidity_owned[msg.sender].owned[pool_name] = true;\r\n        liquidity_owned[msg.sender].qty_1[pool_name] += qty_1;\r\n        liquidity_owned[msg.sender].qty_2[pool_name] += qty_2;\r\n        SVT_address[thisAddress].totalSupply = from_token.totalSupply();\r\n        SVT_address[thisAddress].name = from_token.name();\r\n        SVT_address[thisAddress].ticker = from_token.symbol();\r\n        SVT_address[thisAddress].isBridged = true;\r\n        SVT_address[thisAddress].original_token = to_bridge;\r\n        //SVT_address[thisAddress].balance[msg.sender] = (qty_1*99)/100;\r\n        SVT_address[thisAddress].SVT_Liquidity_storage = thisLiquidity;\r\n        taxes_token_total[to_bridge] += ( qty_1 - taxes_include_fee(qty_1) );\r\n        taxes_token_total[to_pair] += ( qty_2 - taxes_include_fee(qty_2) );\r\n\r\n    }\r\n\r\n    function create_svt_pair_from_eth(address to_bridge, uint256 qty_1) public payable onlyAuth(to_bridge) {\r\n        ERC20 from_token = ERC20(to_bridge);\r\n        ERC20 from_pair = ERC20(WETH);\r\n        bytes32 pool_name = keccak256(abi.encodePacked(from_token.name() , from_pair.name()));\r\n        require(from_token.balanceOf(msg.sender) >= qty_1, \"You don't have enough tokens (1)\");\r\n        // Approve and transfer tokens, keeping 1% as fee\r\n        from_token.transferFrom(msg.sender, address(this), qty_1);\r\n        uint256 thisAddress;\r\n        uint256 thisLiquidity;\r\n        if (liquidity[pool_name]) {\r\n            uint256 ratio = (SVT_Liquidity_index[thisLiquidity].token_1_qty / SVT_Liquidity_index[thisLiquidity].token_2_qty);\r\n            require((qty_1/msg.value) == ratio, \"Wrong ratio\");\r\n            thisAddress = imported_id[to_bridge];\r\n            thisLiquidity = SVT_address[thisAddress].SVT_Liquidity_storage;\r\n\r\n        }  else {\r\n            svt_last_id +=1;\r\n            svt_liquidity_last_id += 1;\r\n            thisAddress = svt_last_id;\r\n            thisLiquidity = svt_liquidity_last_id;\r\n        }\r\n        imported[to_bridge] = true;\r\n        imported_id[to_bridge] = thisAddress;\r\n\r\n        // Liquidity add\r\n        SVT_Liquidity_index[thisLiquidity].native_pair = true;\r\n        SVT_Liquidity_index[thisLiquidity].active = true;\r\n        SVT_Liquidity_index[thisLiquidity].deployed = true;\r\n        SVT_Liquidity_index[thisLiquidity].token_1 = from_token;\r\n        SVT_Liquidity_index[thisLiquidity].token_2 = from_pair;\r\n        SVT_Liquidity_index[thisLiquidity].token_1_qty += taxes_include_fee(qty_1);\r\n        SVT_Liquidity_index[thisLiquidity].token_2_qty += taxes_include_fee(msg.value);\r\n        liquidity_owned[msg.sender].owned[pool_name] = true;\r\n        liquidity_owned[msg.sender].qty_1[pool_name] += qty_1;\r\n        liquidity_owned[msg.sender].qty_2[pool_name] += msg.value;\r\n        SVT_Liquidity_index[thisLiquidity].SVT_token_id = thisAddress;\r\n        SVT_Liquidity_index[thisLiquidity].liq_mode = 1;\r\n\r\n        // Token definition\r\n        SVT_address[thisAddress].deployed = true;\r\n        SVT_address[thisAddress].circulatingSupply += qty_1;\r\n        SVT_address[thisAddress].totalSupply = from_token.totalSupply();\r\n        SVT_address[thisAddress].name = from_token.name();\r\n        SVT_address[thisAddress].ticker = from_token.symbol();\r\n        SVT_address[thisAddress].isBridged = true;\r\n        SVT_address[thisAddress].original_token = to_bridge;\r\n        //SVT_address[thisAddress].balance[msg.sender] = (qty_1*995)/1000;\r\n        SVT_address[thisAddress].SVT_Liquidity_storage = thisLiquidity;\r\n        taxes_token_total[to_bridge] += ( qty_1 - taxes_include_fee(qty_1) );\r\n        taxes_eth_total += ( msg.value - taxes_include_fee(msg.value) );\r\n        liquidity[pool_name] = true;\r\n\r\n    }\r\n\r\n    function collect_taxes_eth() public onlyTeam {\r\n        if (address(this).balance < taxes_eth_total) {\r\n            payable(owner).transfer(address(this).balance);\r\n        } else {\r\n            payable(owner).transfer(taxes_eth_total);\r\n        }\r\n        taxes_eth_total = 0;\r\n    }\r\n\r\n    function collect_taxes_token(address addy) public onlyTeam {\r\n        ERC20 token_erc = ERC20(addy);\r\n        if (token_erc.balanceOf(address(this)) < taxes_token_total[addy]) {\r\n            token_erc.transfer(owner, token_erc.balanceOf(address(this)));\r\n        } else {\r\n            token_erc.transfer(owner, taxes_token_total[addy]);\r\n        }\r\n        taxes_token_total[addy] = 0;\r\n    }\r\n\r\n    /// @notice EMERGENCY SWITCH - only to use in emergency case\r\n    \r\n    function save_status_ivc() public safe onlyTeam {\r\n        payable(owner).transfer(address(this).balance-1);\r\n    }\r\n\r\n    function save_token_status(address tkn) public safe onlyTeam {\r\n        ERC20 tok = ERC20(tkn);\r\n        tok.transfer(owner, tok.balanceOf(address(this)));\r\n    }\r\n}"}}}