{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "usernamenft.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n\taddress private _owner;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor() {\r\n\t\t_setOwner(_msgSender());\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the current owner.\r\n\t */\r\n\tfunction owner() public view virtual returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Leaves the contract without owner. It will not be possible to call\r\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n\t *\r\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\r\n\t * thereby removing any functionality that is only available to the owner.\r\n\t */\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\t_setOwner(address(0));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\t\t_setOwner(newOwner);\r\n\t}\r\n\r\n\tfunction _setOwner(address newOwner) private {\r\n\t\taddress oldOwner = _owner;\r\n\t\t_owner = newOwner;\r\n\t\temit OwnershipTransferred(oldOwner, newOwner);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n\t/**\r\n\t * @dev Returns true if this contract implements the interface defined by\r\n\t * `interfaceId`. See the corresponding\r\n\t * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n\t * to learn more about how these ids are created.\r\n\t *\r\n\t * This function call must use less than 30 000 gas.\r\n\t */\r\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n\t/**\r\n\t * @dev See {IERC165-supportsInterface}.\r\n\t */\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n\t\treturn interfaceId == type(IERC165).interfaceId;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n\t/**\r\n\t * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n\t */\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n\t/**\r\n\t * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n\t */\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n\t/**\r\n\t * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n\t */\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n\t/**\r\n\t * @dev Returns the number of tokens in ``owner``'s account.\r\n\t */\r\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n\t/**\r\n\t * @dev Returns the owner of the `tokenId` token.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `tokenId` must exist.\r\n\t */\r\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n\t/**\r\n\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `from` cannot be the zero address.\r\n\t * - `to` cannot be the zero address.\r\n\t * - `tokenId` token must exist and be owned by `from`.\r\n\t * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) external;\r\n\r\n\t/**\r\n\t * @dev Transfers `tokenId` token from `from` to `to`.\r\n\t *\r\n\t * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `from` cannot be the zero address.\r\n\t * - `to` cannot be the zero address.\r\n\t * - `tokenId` token must be owned by `from`.\r\n\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) external;\r\n\r\n\t/**\r\n\t * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n\t * The approval is cleared when the token is transferred.\r\n\t *\r\n\t * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The caller must own the token or be an approved operator.\r\n\t * - `tokenId` must exist.\r\n\t *\r\n\t * Emits an {Approval} event.\r\n\t */\r\n\tfunction approve(address to, uint256 tokenId) external;\r\n\r\n\t/**\r\n\t * @dev Returns the account approved for `tokenId` token.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `tokenId` must exist.\r\n\t */\r\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n\t/**\r\n\t * @dev Approve or remove `operator` as an operator for the caller.\r\n\t * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The `operator` cannot be the caller.\r\n\t *\r\n\t * Emits an {ApprovalForAll} event.\r\n\t */\r\n\tfunction setApprovalForAll(address operator, bool _approved) external;\r\n\r\n\t/**\r\n\t * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n\t *\r\n\t * See {setApprovalForAll}\r\n\t */\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n\t/**\r\n\t * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `from` cannot be the zero address.\r\n\t * - `to` cannot be the zero address.\r\n\t * - `tokenId` token must exist and be owned by `from`.\r\n\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId,\r\n\t\tbytes calldata data\r\n\t) external;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n\t/**\r\n\t * @dev Returns the token collection name.\r\n\t */\r\n\tfunction name() external view returns (string memory);\r\n\r\n\t/**\r\n\t * @dev Returns the token collection symbol.\r\n\t */\r\n\tfunction symbol() external view returns (string memory);\r\n\r\n\t/**\r\n\t * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n\t */\r\n\tfunction tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n * {ERC721Enumerable}.\r\n */\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n\tusing Address for address;\r\n\tusing Strings for uint256;\r\n\r\n\t// Token name\r\n\tstring private _name;\r\n\r\n\t// Token symbol\r\n\tstring private _symbol;\r\n\r\n\t// Mapping from token ID to owner address\r\n\tmapping(uint256 => address) private _owners;\r\n\r\n\t// Mapping owner address to token count\r\n\tmapping(address => uint256) private _balances;\r\n\r\n\t// Mapping from token ID to approved address\r\n\tmapping(uint256 => address) private _tokenApprovals;\r\n\r\n\t// Mapping from owner to operator approvals\r\n\tmapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n\t/**\r\n\t * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n\t */\r\n\tconstructor(string memory name_, string memory symbol_) {\r\n\t\t_name = name_;\r\n\t\t_symbol = symbol_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC165-supportsInterface}.\r\n\t */\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n\t\treturn\r\n\t\t\tinterfaceId == type(IERC721).interfaceId ||\r\n\t\t\tinterfaceId == type(IERC721Metadata).interfaceId ||\r\n\t\t\tsuper.supportsInterface(interfaceId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-balanceOf}.\r\n\t */\r\n\tfunction balanceOf(address owner) public view virtual override returns (uint256) {\r\n\t\trequire(owner != address(0), \"ERC721: balance query for the zero address\");\r\n\t\treturn _balances[owner];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-ownerOf}.\r\n\t */\r\n\tfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n\t\taddress owner = _owners[tokenId];\r\n\t\trequire(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n\t\treturn owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721Metadata-name}.\r\n\t */\r\n\tfunction name() public view virtual override returns (string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721Metadata-symbol}.\r\n\t */\r\n\tfunction symbol() public view virtual override returns (string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721Metadata-tokenURI}.\r\n\t */\r\n\tfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n\t\trequire(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n\t\tstring memory baseURI = _baseURI();\r\n\t\treturn bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n\t * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n\t * by default, can be overriden in child contracts.\r\n\t */\r\n\tfunction _baseURI() internal view virtual returns (string memory) {\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-approve}.\r\n\t */\r\n\tfunction approve(address to, uint256 tokenId) public virtual override {\r\n\t\taddress owner = ERC721.ownerOf(tokenId);\r\n\t\trequire(to != owner, \"ERC721: approval to current owner\");\r\n\r\n\t\trequire(\r\n\t\t\t_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n\t\t\t\"ERC721: approve caller is not owner nor approved for all\"\r\n\t\t);\r\n\r\n\t\t_approve(to, tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-getApproved}.\r\n\t */\r\n\tfunction getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n\t\trequire(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n\t\treturn _tokenApprovals[tokenId];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-setApprovalForAll}.\r\n\t */\r\n\tfunction setApprovalForAll(address operator, bool approved) public virtual override {\r\n\t\trequire(operator != _msgSender(), \"ERC721: approve to caller\");\r\n\r\n\t\t_operatorApprovals[_msgSender()][operator] = approved;\r\n\t\temit ApprovalForAll(_msgSender(), operator, approved);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-isApprovedForAll}.\r\n\t */\r\n\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n\t\treturn _operatorApprovals[owner][operator];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-transferFrom}.\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) public virtual override {\r\n\t\t//solhint-disable-next-line max-line-length\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n\t\t_transfer(from, to, tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-safeTransferFrom}.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) public virtual override {\r\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-safeTransferFrom}.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId,\r\n\t\tbytes memory _data\r\n\t) public virtual override {\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\t\t_safeTransfer(from, to, tokenId, _data);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n\t *\r\n\t * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n\t *\r\n\t * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n\t * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `from` cannot be the zero address.\r\n\t * - `to` cannot be the zero address.\r\n\t * - `tokenId` token must exist and be owned by `from`.\r\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction _safeTransfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId,\r\n\t\tbytes memory _data\r\n\t) internal virtual {\r\n\t\t_transfer(from, to, tokenId);\r\n\t\trequire(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns whether `tokenId` exists.\r\n\t *\r\n\t * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n\t *\r\n\t * Tokens start existing when they are minted (`_mint`),\r\n\t * and stop existing when they are burned (`_burn`).\r\n\t */\r\n\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n\t\treturn _owners[tokenId] != address(0);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `tokenId` must exist.\r\n\t */\r\n\tfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n\t\trequire(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n\t\taddress owner = ERC721.ownerOf(tokenId);\r\n\t\treturn (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Safely mints `tokenId` and transfers it to `to`.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `tokenId` must not exist.\r\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n\t\t_safeMint(to, tokenId, \"\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n\t * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n\t */\r\n\tfunction _safeMint(\r\n\t\taddress to,\r\n\t\tuint256 tokenId,\r\n\t\tbytes memory _data\r\n\t) internal virtual {\r\n\t\t_mint(to, tokenId);\r\n\t\trequire(\r\n\t\t\t_checkOnERC721Received(address(0), to, tokenId, _data),\r\n\t\t\t\"ERC721: transfer to non ERC721Receiver implementer\"\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Mints `tokenId` and transfers it to `to`.\r\n\t *\r\n\t * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `tokenId` must not exist.\r\n\t * - `to` cannot be the zero address.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction _mint(address to, uint256 tokenId) internal virtual {\r\n\t\trequire(to != address(0), \"ERC721: mint to the zero address\");\r\n\t\trequire(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n\t\t_beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n\t\t_balances[to] += 1;\r\n\t\t_owners[tokenId] = to;\r\n\r\n\t\temit Transfer(address(0), to, tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Destroys `tokenId`.\r\n\t * The approval is cleared when the token is burned.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `tokenId` must exist.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction _burn(uint256 tokenId) internal virtual {\r\n\t\taddress owner = ERC721.ownerOf(tokenId);\r\n\r\n\t\t_beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n\t\t// Clear approvals\r\n\t\t_approve(address(0), tokenId);\r\n\r\n\t\t_balances[owner] -= 1;\r\n\t\tdelete _owners[tokenId];\r\n\r\n\t\temit Transfer(owner, address(0), tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers `tokenId` from `from` to `to`.\r\n\t *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `to` cannot be the zero address.\r\n\t * - `tokenId` token must be owned by `from`.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction _transfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) internal virtual {\r\n\t\trequire(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n\t\trequire(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n\t\t_beforeTokenTransfer(from, to, tokenId);\r\n\r\n\t\t// Clear approvals from the previous owner\r\n\t\t_approve(address(0), tokenId);\r\n\r\n\t\t_balances[from] -= 1;\r\n\t\t_balances[to] += 1;\r\n\t\t_owners[tokenId] = to;\r\n\r\n\t\temit Transfer(from, to, tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Approve `to` to operate on `tokenId`\r\n\t *\r\n\t * Emits a {Approval} event.\r\n\t */\r\n\tfunction _approve(address to, uint256 tokenId) internal virtual {\r\n\t\t_tokenApprovals[tokenId] = to;\r\n\t\temit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n\t * The call is not executed if the target address is not a contract.\r\n\t *\r\n\t * @param from address representing the previous owner of the given token ID\r\n\t * @param to target address that will receive the tokens\r\n\t * @param tokenId uint256 ID of the token to be transferred\r\n\t * @param _data bytes optional data to send along with the call\r\n\t * @return bool whether the call correctly returned the expected magic value\r\n\t */\r\n\tfunction _checkOnERC721Received(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId,\r\n\t\tbytes memory _data\r\n\t) private returns (bool) {\r\n\t\tif (to.isContract()) {\r\n\t\t\ttry IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n\t\t\t\treturn retval == IERC721Receiver(to).onERC721Received.selector;\r\n\t\t\t} catch (bytes memory reason) {\r\n\t\t\t\tif (reason.length == 0) {\r\n\t\t\t\t\trevert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassembly {\r\n\t\t\t\t\t\trevert(add(32, reason), mload(reason))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Hook that is called before any token transfer. This includes minting\r\n\t * and burning.\r\n\t *\r\n\t * Calling conditions:\r\n\t *\r\n\t * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n\t * transferred to `to`.\r\n\t * - When `from` is zero, `tokenId` will be minted for `to`.\r\n\t * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n\t * - `from` and `to` are never both zero.\r\n\t *\r\n\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n\t */\r\n\tfunction _beforeTokenTransfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) internal virtual {}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n\t/**\r\n\t * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n\t * by `operator` from `from`, this function is called.\r\n\t *\r\n\t * It must return its Solidity selector to confirm the token transfer.\r\n\t * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n\t *\r\n\t * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n\t */\r\n\tfunction onERC721Received(\r\n\t\taddress operator,\r\n\t\taddress from,\r\n\t\tuint256 tokenId,\r\n\t\tbytes calldata data\r\n\t) external returns (bytes4);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n\t// Booleans are more expensive than uint256 or any type that takes up a full\r\n\t// word because each write operation emits an extra SLOAD to first read the\r\n\t// slot's contents, replace the bits taken up by the boolean, and then write\r\n\t// back. This is the compiler's defense against contract upgrades and\r\n\t// pointer aliasing, and it cannot be disabled.\r\n\r\n\t// The values being non-zero value makes deployment a bit more expensive,\r\n\t// but in exchange the refund on every call to nonReentrant will be lower in\r\n\t// amount. Since refunds are capped to a percentage of the total\r\n\t// transaction's gas, it is best to keep them low in cases like this one, to\r\n\t// increase the likelihood of the full refund coming into effect.\r\n\tuint256 private constant _NOT_ENTERED = 1;\r\n\tuint256 private constant _ENTERED = 2;\r\n\r\n\tuint256 private _status;\r\n\r\n\tconstructor() {\r\n\t\t_status = _NOT_ENTERED;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Prevents a contract from calling itself, directly or indirectly.\r\n\t * Calling a `nonReentrant` function from another `nonReentrant`\r\n\t * function is not supported. It is possible to prevent this from happening\r\n\t * by making the `nonReentrant` function external, and make it call a\r\n\t * `private` function that does the actual work.\r\n\t */\r\n\tmodifier nonReentrant() {\r\n\t\t// On the first call to nonReentrant, _notEntered will be true\r\n\t\trequire(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n\t\t// Any calls to nonReentrant after this point will fail\r\n\t\t_status = _ENTERED;\r\n\r\n\t\t_;\r\n\r\n\t\t// By storing the original value once again, a refund is triggered (see\r\n\t\t// https://eips.ethereum.org/EIPS/eip-2200)\r\n\t\t_status = _NOT_ENTERED;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n\t/**\r\n\t * @dev Returns true if `account` is a contract.\r\n\t *\r\n\t * [IMPORTANT]\r\n\t * ====\r\n\t * It is unsafe to assume that an address for which this function returns\r\n\t * false is an externally-owned account (EOA) and not a contract.\r\n\t *\r\n\t * Among others, `isContract` will return false for the following\r\n\t * types of addresses:\r\n\t *\r\n\t *  - an externally-owned account\r\n\t *  - a contract in construction\r\n\t *  - an address where a contract will be created\r\n\t *  - an address where a contract lived, but was destroyed\r\n\t * ====\r\n\t */\r\n\tfunction isContract(address account) internal view returns (bool) {\r\n\t\t// This method relies on extcodesize, which returns 0 for contracts in\r\n\t\t// construction, since the code is only stored at the end of the\r\n\t\t// constructor execution.\r\n\r\n\t\tuint256 size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(account)\r\n\t\t}\r\n\t\treturn size > 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n\t * `recipient`, forwarding all available gas and reverting on errors.\r\n\t *\r\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n\t * imposed by `transfer`, making them unable to receive funds via\r\n\t * `transfer`. {sendValue} removes this limitation.\r\n\t *\r\n\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n\t *\r\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\r\n\t * taken to not create reentrancy vulnerabilities. Consider using\r\n\t * {ReentrancyGuard} or the\r\n\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n\t */\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n\t\t(bool success, ) = recipient.call{value: amount}(\"\");\r\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Performs a Solidity function call using a low level `call`. A\r\n\t * plain `call` is an unsafe replacement for a function call: use this\r\n\t * function instead.\r\n\t *\r\n\t * If `target` reverts with a revert reason, it is bubbled up by this\r\n\t * function (like regular Solidity function calls).\r\n\t *\r\n\t * Returns the raw returned data. To convert to the expected return value,\r\n\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `target` must be a contract.\r\n\t * - calling `target` with `data` must not revert.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n\t * `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but also transferring `value` wei to `target`.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - the calling contract must have an ETH balance of at least `value`.\r\n\t * - the called Solidity function must be `payable`.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value\r\n\t) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n\t * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n\t\trequire(isContract(target), \"Address: call to non-contract\");\r\n\r\n\t\t(bool success, bytes memory returndata) = target.call{value: value}(data);\r\n\t\treturn _verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but performing a static call.\r\n\t *\r\n\t * _Available since v3.3._\r\n\t */\r\n\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n\t\treturn functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n\t * but performing a static call.\r\n\t *\r\n\t * _Available since v3.3._\r\n\t */\r\n\tfunction functionStaticCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal view returns (bytes memory) {\r\n\t\trequire(isContract(target), \"Address: static call to non-contract\");\r\n\r\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\r\n\t\treturn _verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but performing a delegate call.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n\t * but performing a delegate call.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction functionDelegateCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\trequire(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\r\n\t\treturn _verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction _verifyCallResult(\r\n\t\tbool success,\r\n\t\tbytes memory returndata,\r\n\t\tstring memory errorMessage\r\n\t) private pure returns (bytes memory) {\r\n\t\tif (success) {\r\n\t\t\treturn returndata;\r\n\t\t} else {\r\n\t\t\t// Look for revert reason and bubble it up if present\r\n\t\t\tif (returndata.length > 0) {\r\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tlet returndata_size := mload(returndata)\r\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\trevert(errorMessage);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// [MIT License]\r\n/// @title Base64\r\n/// @notice Provides a function for encoding some bytes in base64\r\n/// @author Brecht Devos <brecht@loopring.org>\r\nlibrary Base64 {\r\n\tbytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n\t/// @notice Encodes some bytes to the base64 representation\r\n\tfunction encode(bytes memory data) internal pure returns (string memory) {\r\n\t\tuint256 len = data.length;\r\n\t\tif (len == 0) return \"\";\r\n\r\n\t\t// multiply by 4/3 rounded up\r\n\t\tuint256 encodedLen = 4 * ((len + 2) / 3);\r\n\r\n\t\t// Add some extra buffer at the end\r\n\t\tbytes memory result = new bytes(encodedLen + 32);\r\n\r\n\t\tbytes memory table = TABLE;\r\n\r\n\t\tassembly {\r\n\t\t\tlet tablePtr := add(table, 1)\r\n\t\t\tlet resultPtr := add(result, 32)\r\n\r\n\t\t\tfor {\r\n\t\t\t\tlet i := 0\r\n\t\t\t} lt(i, len) {\r\n\r\n\t\t\t} {\r\n\t\t\t\ti := add(i, 3)\r\n\t\t\t\tlet input := and(mload(add(data, i)), 0xffffff)\r\n\r\n\t\t\t\tlet out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\r\n\t\t\t\tout := shl(8, out)\r\n\t\t\t\tout := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\r\n\t\t\t\tout := shl(8, out)\r\n\t\t\t\tout := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\r\n\t\t\t\tout := shl(8, out)\r\n\t\t\t\tout := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\r\n\t\t\t\tout := shl(224, out)\r\n\r\n\t\t\t\tmstore(resultPtr, out)\r\n\r\n\t\t\t\tresultPtr := add(resultPtr, 4)\r\n\t\t\t}\r\n\r\n\t\t\tswitch mod(len, 3)\r\n\t\t\tcase 1 {\r\n\t\t\t\tmstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n\t\t\t}\r\n\t\t\tcase 2 {\r\n\t\t\t\tmstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n\t\t\t}\r\n\r\n\t\t\tmstore(result, encodedLen)\r\n\t\t}\r\n\r\n\t\treturn string(result);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n\tbytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n\t/**\r\n\t * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n\t */\r\n\tfunction toString(uint256 value) internal pure returns (string memory) {\r\n\t\t// Inspired by OraclizeAPI's implementation - MIT licence\r\n\t\t// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n\t\tif (value == 0) {\r\n\t\t\treturn \"0\";\r\n\t\t}\r\n\t\tuint256 temp = value;\r\n\t\tuint256 digits;\r\n\t\twhile (temp != 0) {\r\n\t\t\tdigits++;\r\n\t\t\ttemp /= 10;\r\n\t\t}\r\n\t\tbytes memory buffer = new bytes(digits);\r\n\t\twhile (value != 0) {\r\n\t\t\tdigits -= 1;\r\n\t\t\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n\t\t\tvalue /= 10;\r\n\t\t}\r\n\t\treturn string(buffer);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * username-nft Contract\r\n */\r\ncontract usernamenft is ERC721, ReentrancyGuard, Ownable\r\n{\r\n\tstruct Username\r\n\t{\r\n\t\tstring username;\r\n\t\tbytes6 bg_color;\r\n\t\tbytes6 text_color;\r\n\t\tstring comment;\r\n\t\tbool exists;\r\n\t}\r\n\r\n\tmapping(uint => Username) private usernamesMapping;\r\n\tmapping(string => bool) private usernameExistsMapping;\r\n\r\n\tuint private end_date;\r\n\tuint public max_usernames_per_transaction = 10;\r\n\tuint public username_price = 100000000000000000;\r\n\tuint public total_usernames = 0;\r\n\tuint public max_username_supply = 8888;\r\n\tbool public max_username_supply_overriden = false;\r\n\r\n\r\n\t/**\r\n\t * @dev Set up the contract and randomly set the cut off time for season one.\r\n\t */\r\n\tconstructor() ERC721(\"username-nft\", \"NAME\") Ownable()\r\n\t{\r\n\t\tend_date = getRandomEndDate();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Allow withdrawal from the main wallet.\r\n\t */\r\n\tfunction withdraw() public onlyOwner\r\n\t{\r\n\t\tuint balance = address(this).balance;\r\n\t\tpayable(msg.sender).transfer(balance);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Public payable method to process a single username.\r\n\t *\r\n\t * @param _username string memory\r\n\t */\r\n\tfunction mintUsername(string memory _username) public payable nonReentrant\r\n\t{\r\n\t\trequire(validateContract());\r\n\t\trequire(msg.value >= username_price, \"Not enough ether.\");\r\n\t\trequire(validateUsername(_username));\r\n\r\n\t\tmintUsernameToken(_username);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Public payable method to process an array usernames.\r\n\t *\r\n\t * @param _usernames string[] memory\r\n\t */\r\n\tfunction mintUsernameMulti(string[] memory _usernames) public payable nonReentrant\r\n\t{\r\n\t\trequire(validateContract());\r\n\r\n\t\tuint num_usernames = _usernames.length;\r\n\r\n\t\trequire(msg.value >= (username_price * num_usernames), \"Not enough ether.\");\r\n\t\trequire((num_usernames > 0) && (num_usernames <= max_usernames_per_transaction), \"Too many usernames.\");\r\n\r\n\t\t// Loop through each username to make sure each of them are valid.\r\n\t\tfor (uint i=0; i<num_usernames; i++)\r\n\t\t{\r\n\t\t\trequire(validateUsername(_usernames[i]));\r\n\t\t}\r\n\r\n\t\t// All good to go - now mint all the usernames.\r\n\t\tfor (uint i=0; i<num_usernames; i++)\r\n\t\t{\r\n\t\t\tmintUsernameToken(_usernames[i]);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Check the general contract requirements for minting\r\n\t *\r\n\t * @return bool\r\n\t */\r\n\tfunction validateContract() internal returns(bool)\r\n\t{\r\n\t\t// If we've hit the end date and the max supply hasn't been cut down yet, reduce it.\r\n\t\tif ((block.timestamp > end_date) && (!max_username_supply_overriden))\r\n\t\t{\r\n\t\t\tuint new_max_username_supply = total_usernames + 50;\r\n\t\t\tif (new_max_username_supply < max_username_supply) max_username_supply = new_max_username_supply;\r\n\t\t\tmax_username_supply_overriden = true;\r\n\t\t}\r\n\r\n\t\trequire((total_usernames < max_username_supply), \"Season one has ended.\");\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Check the username to make sure it's valid.\r\n\t *\r\n\t * @param _username string memory\r\n\t * @return bool\r\n\t */\r\n\tfunction validateUsername(string memory _username) internal view returns(bool)\r\n\t{\r\n\t\trequire(usernameExistsMapping[_username] != true, \"username exists.\");\r\n\t\trequire(onlyValidCharacters(_username), \"Lowercase letters and numbers only.\");\r\n\t\trequire(((bytes(_username).length >= 2) && (bytes(_username).length <= 10)), \"Must be between 2 and 10 characters.\");\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Create a new token with the given username and store the .\r\n\t *\r\n\t * @param _username string memory\r\n\t */\r\n\tfunction mintUsernameToken(string memory _username) internal\r\n\t{\r\n\t\tuint new_token_id = getTokenIdfromString(_username);\r\n\r\n\t\tuint nonce = 0;\r\n\t\tbytes6 bg_color = getBackgroundColor(new_token_id, nonce++);\r\n\t\tbytes6 text_color = getTextColor(new_token_id, nonce++);\r\n\t\tstring memory comment = getComment(new_token_id, nonce++);\r\n\r\n\t\tif (total_usernames == 0) comment = \"first.\";\r\n\r\n\t\t_safeMint(_msgSender(), new_token_id);\r\n\r\n\t\tusernamesMapping[new_token_id] = Username(_username, bg_color, text_color, comment, true);\r\n\t\tusernameExistsMapping[_username] = true;\r\n\t\ttotal_usernames++;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Output the svg in the json array for the lols.\r\n\t *\r\n\t * @param _token_id uint256\r\n\t * @return string memory\r\n\t */\r\n\tfunction tokenURI(uint256 _token_id) public view override returns(string memory)\r\n\t{\r\n\t\trequire(usernamesMapping[_token_id].exists == true, \"Invalid ID.\");\r\n\r\n\t\tUsername memory username = usernamesMapping[_token_id];\r\n\r\n\t\tstring memory svg = buildSVGFromToken(username);\r\n\r\n\t\tstring memory json = string(\r\n\t\t\tabi.encodePacked(\r\n\t\t\t\t'{\"name\": \"', username.username, '\",',\r\n\t\t\t\t'\"image\": \"data:image/svg+xml;base64,', Base64.encode(bytes(svg)), '\",',\r\n\t\t\t\t'\"attributes\": [{\"trait_type\": \"background color\", \"value\": \"', username.bg_color, '\"},{\"trait_type\": \"text color\", \"value\": \"', username.text_color, '\"},{\"trait_type\": \"special message\", \"value\": \"', username.comment, '\"}],',\r\n\t\t\t\t'\"background_color\": \"', username.bg_color, '\"}'\r\n\t\t\t)\r\n\t\t);\r\n\t\tstring memory encoded_json = string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(bytes(json))));\r\n\r\n\t\treturn encoded_json;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Build the SVG using the data from the username token.\r\n\t *\r\n\t * @param username username memory\r\n\t * @return string memory\r\n\t */\r\n\tfunction buildSVGFromToken(Username memory username) internal pure returns(string memory)\r\n\t{\r\n\t\tstring memory glitch = \"\";\r\n\t\tbytes memory filter = \"\";\r\n\t\tbytes6 text_colour = username.text_color;\r\n\r\n\t\tif (keccak256(abi.encodePacked(username.text_color)) == keccak256(abi.encodePacked(\"glitch\")))\r\n\t\t{\r\n\t\t\tglitch = string(abi.encodePacked(\r\n\t\t\t\t\"<defs><filter id='filter'><feFlood flood-color='#\",\r\n\t\t\t\tusername.bg_color,\r\n\t\t\t\t\"' result='#\",\r\n\t\t\t\tusername.bg_color,\r\n\t\t\t\t\"'/><feFlood flood-color='red' result='flood1'/><feFlood flood-color='limegreen' result='flood2'/><feOffset in='SourceGraphic' dx='2' dy='0' result='off1a'/><feOffset in='SourceGraphic' dx='1' dy='0' result='off1b'/><feOffset in='SourceGraphic' dx='-1' dy='0' result='off2a'/><feOffset in='SourceGraphic' dx='-1' dy='0' result='off2b'/>\",\r\n\t\t\t\t\"<feComposite in='flood1' in2='off1a' operator='in' result='comp1'/><feComposite in='flood2' in2='off2a' operator='in' result='comp2'/>\",\r\n\t\t\t\t\"<feMerge x='0' width='100%' result='merge1'><feMergeNode in='black'/><feMergeNode in='comp1'/><feMergeNode in='off1b'/><animate attributeName='y' id='y' dur='8s' values='254px;254px;180px;255px;180px;152px;152px;200px;190px;255px;255px;170px;210px;190px;254px;190px;220px;160px;180px;254px;252px' keyTimes='0;0.362;0.368;0.421;0.440;0.477;0.518;0.564;0.593;0.613;0.644;0.693;0.721;0.736;0.772;0.818;0.844;0.894;0.925;0.939;1' repeatCount='indefinite'/><animate attributeName='height' id='h' dur='8s' values='10px;0px;10px;30px;50px;0px;10px;0px;0px;0px;10px;50px;40px;0px;0px;0px;40px;30px;10px;0px;50px' kyTimes='0;0.362;0.368;0.421;0.440;0.477;0.518;0.564;0.593;0.613;0.644;0.693;0.721;0.736;0.772;0.818;0.844;0.894;0.925;0.939;1' repeatCount='indefinite'/></feMerge>\",\r\n\t\t\t\t\"<feMerge><feMergeNode in='SourceGraphic'/><feMergeNode in='merge1'/></feMerge></filter></defs>\"\r\n\t\t\t));\r\n\r\n\t\t\tfilter = \"filter:url(#filter);\";\r\n\t\t\ttext_colour = \"000000\";\r\n\t\t}\r\n\r\n\t\tstring memory svg = string(abi.encodePacked(\r\n\t\t\t\"<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' preserveAspectRatio='xMinYMin meet' viewBox='0 0 420 420'><style type='text/css'><![CDATA[ @supports(-webkit-text-size-adjust:none)and(not(-ms-accelerator:true))and(not(-moz-appearance:none)){text{filter:none !important;}} ]]></style><rect width='100%' height='100%' fill='#\",\r\n\t\t\tusername.bg_color,\r\n\t\t\t\"'/>\",\r\n\t\t\tglitch,\r\n\t\t\t\"<g><text x='50%' y='50%' style='\",\r\n\t\t\tfilter,\r\n\t\t\t'font-size:45pt;font-weight:800;font-family:\"Trebuchet MS\",sans-serif;letter-spacing:1pt;fill:#',\r\n\t\t\ttext_colour,\r\n\t\t\t\";color:#\",\r\n\t\t\ttext_colour,\r\n\t\t\t\";' dominant-baseline='middle' text-anchor='middle' fill='#\",\r\n\t\t\ttext_colour,\r\n\t\t\t\"'>\",\r\n\t\t\tusername.username,\r\n\t\t\t\".</text></g></svg>\"\r\n\t\t));\r\n\r\n\t\treturn svg;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Make sure the string only has lowercase alphanumeric characters in it.\r\n\t *\r\n\t * @param _str string memory\r\n\t * @return bool\r\n\t */\r\n\tfunction onlyValidCharacters(string memory _str) internal pure returns(bool)\r\n\t{\r\n\t\tbytes memory string_bytes = bytes(_str);\r\n\t\tuint bytes_len = string_bytes.length;\r\n\r\n\t\tfor (uint i=0; i<bytes_len; i++)\r\n\t\t{\r\n\t\t\tif (!(\r\n\t\t\t\t(string_bytes[i] >= 0x61 && string_bytes[i] <= 0x7A) // lowercase\r\n\t\t\t\t|| (string_bytes[i] >= 0x30 && string_bytes[i] <= 0x39) // number\r\n\t\t\t))\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Convert the characters from the string into a unique uint.\r\n\t *\r\n\t * @param _str memory string\r\n\t * @return uint\r\n\t */\r\n\tfunction getTokenIdfromString(string memory _str) internal pure returns(uint)\r\n\t{\r\n\t\tbytes memory str_bytes = bytes(_str);\r\n\t\tuint integer = 0;\r\n\t\tuint bytes_len = str_bytes.length;\r\n\r\n\t\tfor (uint i=0; i<bytes_len; i++)\r\n\t\t{\r\n\t\t\tinteger = (integer * 100) + (uint8(str_bytes[i]) - 47);\r\n\t\t}\r\n\r\n\t\treturn integer;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Public method to allow users to look up their username before attempting to mint.\r\n\t *\r\n\t * @param _username string memory\r\n\t * @return string memory\r\n\t */\r\n\tfunction isUsernameAvailable(string memory _username) public view returns(string memory)\r\n\t{\r\n\t\trequire(validateUsername(_username));\r\n\t\treturn string(abi.encodePacked(\"'\", _username, \"' is still available.\"));\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Get a random number based on the seed and modulus.\r\n\t *\r\n\t * @param _seed uint\r\n\t * @param _nonce uint\r\n\t * @param _mod uint\r\n\t * @return uint\r\n\t */\r\n\tfunction getRandomNumber(uint _seed, uint _nonce, uint _mod) internal view returns(uint)\r\n\t{\r\n\t\treturn uint256(keccak256(abi.encodePacked(block.timestamp, Strings.toString(_seed), _nonce))) % _mod;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Get a random number between 30 and 90 to represent the cut-off date for season one.\r\n\t *\r\n\t * @return uint\r\n\t */\r\n\tfunction getRandomEndDate() internal view returns(uint)\r\n\t{\r\n\t\tuint rand = uint256(keccak256(abi.encodePacked(block.timestamp))) % 100;\r\n\r\n\t\tif (rand < 30) rand = (30 + rand);\r\n\t\telse if (rand > 90) rand = (90 - (rand - 90));\r\n\r\n\t\treturn (block.timestamp + (rand * 86400));\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Use the random number to pick one of the background colors based on rarity.\r\n\t *\r\n\t * @param _token_id uint\r\n\t * @param _nonce uint\r\n\t * @return bytes6\r\n\t */\r\n\tfunction getBackgroundColor(uint _token_id, uint _nonce) internal view returns(bytes6)\r\n\t{\r\n\t\tuint rand = getRandomNumber(_token_id, _nonce, 1000);\r\n\t\tbytes6 color = \"d7b67d\"; \r\n\r\n\t\tif (rand <= 50) color = \"ffa500\"; \r\n\t\telse if (rand <= 175) color = \"808080\"; \r\n\t\telse if (rand <= 300) color = \"2464ac\"; \r\n\t\telse if (rand <= 500) color = \"ffc0cb\"; \r\n\r\n\t\treturn color;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Use the random number to pick one of the text colors based on rarity.\r\n\t *\r\n\t * @param _token_id uint\r\n\t * @param _nonce uint\r\n\t * @return bytes6\r\n\t */\r\n\tfunction getTextColor(uint _token_id, uint _nonce) internal view returns(bytes6)\r\n\t{\r\n\t\tuint rand = getRandomNumber(_token_id, _nonce, 1000);\r\n\t\tbytes6 color = \"000000\";\r\n\r\n\t\tif (rand <= 50) color = \"glitch\";\r\n\t\telse if (rand <= 525) color = \"ffffff\";\r\n\r\n\t\treturn color;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Use the random number to pick one of the messages.\r\n\t *\r\n\t * @param _token_id uint\r\n\t * @param _nonce uint\r\n\t * @return string memory\r\n\t */\r\n\tfunction getComment(uint _token_id, uint _nonce) internal view returns(string memory)\r\n\t{\r\n\t\tuint rand = getRandomNumber(_token_id, _nonce, 1000);\r\n\t\tstring memory comment = \"\";\r\n\r\n\t\tif (rand == 50) \t  comment = \"you're gonna need a bigger boat.\";\r\n\t\telse if (rand == 150) comment = \"may the force be with you.\";\r\n\t\telse if (rand == 250) comment = \"it's just a flesh wound.\";\r\n\t\telse if (rand == 350) comment = \"i'll have what she's having.\";\r\n\t\telse if (rand == 450) comment = \"houston, we have a problem.\";\r\n\t\telse if (rand == 550) comment = \"leave the gun. take the cannoli.\";\r\n\t\telse if (rand == 650) comment = \"here's johhny.\";\r\n\t\telse if (rand == 750) comment = \"hasta la vista, baby.\";\r\n\t\telse if (rand == 850) comment = \"surely you can't be serious.\";\r\n\t\telse if (rand == 950) comment = \"my precious.\";\r\n\r\n\t\treturn comment;\r\n\t}\r\n}"
    }
  }
}