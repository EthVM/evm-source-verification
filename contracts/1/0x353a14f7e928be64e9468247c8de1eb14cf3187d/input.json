{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"FUNDSZ.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2021-02-04\r\n*/\r\n\r\npragma solidity 0.5.16;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract FUNDSZ{\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    struct UserStruct {\r\n        bool isExist;\r\n        uint id;\r\n        uint referrerID;\r\n        uint orginalRefID;\r\n        uint placementSponser;\r\n        uint donated;\r\n        uint totalEarnedETH;\r\n        uint teamNetworkEarnETH;\r\n        bool blocked;\r\n        address[] personallyEnrolled;\r\n        address[] referrals;\r\n        uint membershipExpired;\r\n    }\r\n    \r\n    address payable public admin;\r\n    \r\n    uint  REFERRER_1_LEVEL_LIMIT = 4;\r\n    uint public PERIOD_LENGTH = 30 days;\r\n    uint public blockTime = 90 days;\r\n    uint public GRACE_PERIOD = 7 days;\r\n    \r\n    uint MatchingBonusUplineLimit = 5;\r\n    \r\n    uint public usdPrice;\r\n    \r\n    uint public currUserID = 0;\r\n    bool public lockStatus;\r\n    \r\n    mapping (address => UserStruct) public users;\r\n    mapping (uint => address) public userList;\r\n    mapping (uint => uint) public MEMBERSHIP_PRICE;\r\n    \r\n    mapping(address => uint) matrixCommissionBreakage;\r\n    mapping(address => uint) commissionsReceivedValue;\r\n    mapping(address => uint) adminBreakageAmount;\r\n    \r\n    event MatrixCommission(\r\n        address indexed _user,\r\n        address _level1,\r\n        address _level2,\r\n        address _level3,\r\n        address _level4,\r\n        address _level5,\r\n        address _level6,\r\n        address _level7,\r\n        address _level8,\r\n        uint _levelValue\r\n    );\r\n    event MatchingCarBonus(\r\n        address indexed _user,\r\n        address _sponser,\r\n        address[] receiver,\r\n        uint _value\r\n    );\r\n    event RefBonus(\r\n        address indexed _user,\r\n        address _sponser,\r\n        uint _value\r\n    );\r\n    event InfinityHouseBonus(\r\n        address _user,\r\n        address _upline9,\r\n        address _upline10,\r\n        address _upline11,\r\n        address _upline12,\r\n        uint _uplineAmount9To12\r\n    );\r\n    event regMemberEvent(\r\n        address indexed _user,\r\n        address indexed _referrer,\r\n        uint _value,\r\n        uint _vipID,\r\n        uint _time\r\n    );\r\n    event BuyMembershipEvent(\r\n        address indexed _user,\r\n        uint _value,\r\n        uint _vipID,\r\n        uint _time\r\n    );\r\n    \r\n    event BreakageEvent(\r\n        address indexed _user,\r\n        uint _value,\r\n        uint _time\r\n    );\r\n    \r\n    constructor() public {\r\n        admin = msg.sender;\r\n        UserStruct memory userStruct;\r\n        currUserID++;\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currUserID,\r\n            referrerID: 0,\r\n            orginalRefID: 0,\r\n            placementSponser: 0,\r\n            donated:2,\r\n            teamNetworkEarnETH:0,\r\n            totalEarnedETH: 0,\r\n            blocked:false,\r\n            personallyEnrolled : new address[](0),\r\n            referrals: new address[](0),\r\n            membershipExpired:55555555555\r\n        });\r\n        \r\n        users[admin] = userStruct;    \r\n        userList[currUserID] = admin;\r\n    \r\n        MEMBERSHIP_PRICE[1] = 10;\r\n        MEMBERSHIP_PRICE[2] = 50;\r\n    }\r\n    \r\n    modifier contractStatus(){\r\n        require(lockStatus == false,\"contract locked\");\r\n        _;\r\n    }\r\n    \r\n    modifier OnlyOwner(){\r\n        require(msg.sender == admin,\"OnlyOwner\");\r\n        _;\r\n    }\r\n    \r\n    function() external payable OnlyOwner{\r\n        \r\n    }\r\n    \r\n    \r\n    function subscription(uint _placementSponser, uint _referrerID, uint _orginalRefID, uint _usdValue) public contractStatus payable returns(bool){\r\n        require(!users[msg.sender].isExist,\"User exist\");\r\n        require(!isContract(msg.sender),\"Invalid address\");\r\n        require((_referrerID > 0) && (_referrerID <= currUserID),\"Invalid referrerID\");\r\n        require((_orginalRefID > 0) && (_orginalRefID <= currUserID),\"Invalid referrerID\");\r\n        require((_placementSponser > 0) && (_placementSponser <= currUserID),\"Invalid referrerID\");\r\n        require(_usdValue == 10 || (_usdValue == 50),\"Invalid membership\");\r\n        require(usdPrice > 0, \"usdPrice must be greater than zero\");\r\n        require(msg.value == usdPrice.mul(_usdValue),\"Invalid value\");\r\n        \r\n        UserStruct memory userStruct;\r\n        currUserID++;\r\n\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currUserID,\r\n            referrerID: _referrerID,\r\n            orginalRefID : _orginalRefID,\r\n            placementSponser : _placementSponser,\r\n            donated:0,\r\n            teamNetworkEarnETH:0,\r\n            // referralTeamNetWorkEarnings : 0,\r\n            totalEarnedETH: 0,\r\n            blocked:false,\r\n            personallyEnrolled : new address[](0),\r\n            referrals: new address[](0),\r\n            membershipExpired: now.add(PERIOD_LENGTH)\r\n        });\r\n\r\n        users[msg.sender] = userStruct;\r\n        userList[currUserID] = msg.sender;\r\n        \r\n        uint _DonateID;\r\n        \r\n        if(MEMBERSHIP_PRICE[1] == _usdValue)\r\n            _DonateID = 1;\r\n        else\r\n            _DonateID = 2;\r\n\r\n        users[msg.sender].donated = _DonateID;\r\n        users[userList[_placementSponser]].personallyEnrolled.push(msg.sender);\r\n        users[userList[_referrerID]].referrals.push(msg.sender);\r\n\r\n        address upline_8_address = matrixCommission(msg.sender,msg.value);\r\n        \r\n        referralBonus(msg.sender,msg.value);\r\n        matchingCarBonus(msg.sender);\r\n        infinityHouseBonus(upline_8_address,msg.value); \r\n        \r\n        uint breakage = msg.value.sub(commissionsReceivedValue[msg.sender]);\r\n        \r\n        require(address(uint160(admin)).send(breakage), \"breakage amount transfer failed\");\r\n        users[admin].totalEarnedETH = users[admin].totalEarnedETH.add(breakage);\r\n\r\n        emit regMemberEvent(msg.sender, userList[_referrerID], msg.value, _DonateID, now);\r\n        emit BreakageEvent(msg.sender, adminBreakageAmount[msg.sender].add(breakage), now);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function donate(uint _usdValue, uint _days)  public contractStatus payable returns(bool){\r\n        require(_days > 0,\"_days must be greater than zero\");\r\n        require(users[msg.sender].isExist,\"User does not exist\"); \r\n        require(!isContract(msg.sender),\"Invalid address\");\r\n        require((_usdValue == 10 || _usdValue == 50), \"Invalid membership\");\r\n        require(usdPrice > 0, \"usdPrice must be greater than zero\");\r\n        require(msg.value == (usdPrice.mul(_usdValue)).mul(_days),\"Invalid value\");\r\n        \r\n        uint _DonateID;\r\n        \r\n        if(MEMBERSHIP_PRICE[1] == _usdValue)\r\n            _DonateID = 1;\r\n        else\r\n            _DonateID = 2;\r\n        \r\n        if(users[msg.sender].donated == _DonateID)    \r\n            users[msg.sender].membershipExpired = users[msg.sender].membershipExpired.add(PERIOD_LENGTH.mul(_days));\r\n        else{\r\n            users[msg.sender].membershipExpired = now.add(PERIOD_LENGTH.mul(_days));\r\n            users[msg.sender].donated = _DonateID;\r\n        }\r\n        \r\n        \r\n        address upline_8_address = matrixCommission(msg.sender,msg.value);\r\n        \r\n        matchingCarBonus(msg.sender);\r\n        referralBonus(msg.sender,msg.value);\r\n        infinityHouseBonus(upline_8_address,msg.value);   \r\n        \r\n        uint breakage = msg.value.sub(commissionsReceivedValue[msg.sender]);\r\n        \r\n        require(address(uint160(admin)).send(breakage), \"breakage amount transfer failed\");\r\n        users[admin].totalEarnedETH = users[admin].totalEarnedETH.add(breakage);\r\n        \r\n        emit BuyMembershipEvent(msg.sender, msg.value, _DonateID, now);\r\n        emit BreakageEvent(msg.sender, adminBreakageAmount[msg.sender].add(breakage), now);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function updateUSDPrice( uint _usdPrice) public OnlyOwner returns(bool){\r\n        require(_usdPrice > 0, \"_usdPrice must be greater than zero\");\r\n        usdPrice = _usdPrice;\r\n        return true;\r\n    }\r\n    \r\n    mapping( address => address[]) bonusEligibleUsers;\r\n    \r\n    // Matrix Commission\r\n    function matrixCommission(address _user, uint _amount) internal returns(address){\r\n        matrixCommissionBreakage[msg.sender] = 0;\r\n        commissionsReceivedValue[msg.sender] = 0;\r\n        adminBreakageAmount[msg.sender] = 0;\r\n        bonusEligibleUsers[msg.sender] = new address[](0);\r\n        \r\n        address[8] memory   matrix_commission;\r\n        matrix_commission[0] = rollUp(userList[users[_user].referrerID]);\r\n        matrix_commission[1] = rollUp(userList[users[matrix_commission[0]].referrerID]);\r\n        matrix_commission[2] = rollUp(userList[users[matrix_commission[1]].referrerID]);\r\n        matrix_commission[3] = rollUp(userList[users[matrix_commission[2]].referrerID]);\r\n        matrix_commission[4] = rollUp(userList[users[matrix_commission[3]].referrerID]);\r\n        matrix_commission[5] = rollUp(userList[users[matrix_commission[4]].referrerID]);\r\n        matrix_commission[6] = rollUp(userList[users[matrix_commission[5]].referrerID]);\r\n        matrix_commission[7] = rollUp(userList[users[matrix_commission[6]].referrerID]);\r\n        \r\n        for(uint i = 0; i < matrix_commission.length; i++){\r\n            if(matrix_commission[i] == address(0)){\r\n                matrix_commission[i] = userList[1];\r\n            }\r\n        }\r\n\r\n        uint matrix_commission_upline_percentage = (_amount.mul(8 ether).div(10**20));\r\n        \r\n        for(uint i=0; i<matrix_commission.length; i++){\r\n            if(matrix_commission[i] == userList[1]){\r\n                uint commission = matrix_commission_upline_percentage.mul(matrix_commission.length.sub(i));\r\n                require(address(uint160(matrix_commission[i])).send(commission),\"transfer failed\");\r\n                users[matrix_commission[i]].totalEarnedETH = users[matrix_commission[i]].totalEarnedETH.add(commission);\r\n                users[matrix_commission[i]].teamNetworkEarnETH = users[matrix_commission[i]].teamNetworkEarnETH.add(commission);\r\n                commissionsReceivedValue[msg.sender] = commissionsReceivedValue[msg.sender].add(commission);\r\n                break;\r\n            }\r\n            else{\r\n                require(address(uint160(matrix_commission[i])).send(matrix_commission_upline_percentage),\"transfer failed\");\r\n                users[matrix_commission[i]].totalEarnedETH = users[matrix_commission[i]].totalEarnedETH.add(matrix_commission_upline_percentage);\r\n                users[matrix_commission[i]].teamNetworkEarnETH = users[matrix_commission[i]].teamNetworkEarnETH.add(matrix_commission_upline_percentage);\r\n                commissionsReceivedValue[msg.sender] = commissionsReceivedValue[msg.sender].add(matrix_commission_upline_percentage);\r\n            }\r\n        }\r\n        \r\n        adminBreakageAmount[msg.sender] = adminBreakageAmount[msg.sender].add(matrix_commission_upline_percentage.mul(matrixCommissionBreakage[msg.sender]));\r\n        \r\n        emit MatrixCommission(\r\n            _user,\r\n            bonusEligibleUsers[msg.sender][0],\r\n            bonusEligibleUsers[msg.sender][1],\r\n            bonusEligibleUsers[msg.sender][2],\r\n            bonusEligibleUsers[msg.sender][3],\r\n            bonusEligibleUsers[msg.sender][4],\r\n            bonusEligibleUsers[msg.sender][5],\r\n            bonusEligibleUsers[msg.sender][6],\r\n            bonusEligibleUsers[msg.sender][7],\r\n            matrix_commission_upline_percentage\r\n        );\r\n        \r\n        return matrix_commission[7];\r\n    }\r\n    \r\n    // roll up - matrix commission\r\n    function rollUp(address _user) internal returns(address) {\r\n        \r\n        if(!users[_user].isExist) {\r\n            matrixCommissionBreakage[msg.sender]++;\r\n            bonusEligibleUsers[msg.sender].push(_user);\r\n            return userList[1];\r\n        }\r\n        \r\n\r\n        if((users[_user].membershipExpired.add(GRACE_PERIOD) >= now) && (!users[_user].blocked)){\r\n            bonusEligibleUsers[msg.sender].push(_user);\r\n            return _user;\r\n        }\r\n        else if(\r\n            ((users[_user].membershipExpired).add(blockTime.add(GRACE_PERIOD)) < now) \r\n            && (!users[_user].blocked))\r\n        {\r\n            users[_user].blocked = true;\r\n        }        \r\n        \r\n        return rollUp(userList[users[_user].referrerID]);\r\n    }\r\n    \r\n    mapping(address => address[]) public _teamNetworkEarnWallet;\r\n    \r\n    // Matching Commission\r\n    function matchingCarBonus(address _user) internal {\r\n        address sponser = userList[users[_user].referrerID];\r\n        \r\n        uint _carBonus;\r\n        \r\n        if(sponser == address(0)) sponser = userList[1];\r\n        \r\n        _teamNetworkEarnWallet[sponser] = new address[](0);\r\n        \r\n        if(((users[sponser].membershipExpired).add(blockTime.add(GRACE_PERIOD)) < now) && (!users[sponser].blocked)){\r\n            users[sponser].blocked = true;\r\n        }\r\n        \r\n        if(sponser != userList[1])\r\n            getAllDirectSponsor( sponser, userList[users[sponser].referrerID], 0);\r\n\r\n        if((_teamNetworkEarnWallet[sponser].length > 0) && (users[sponser].teamNetworkEarnETH > 0)){\r\n            _carBonus = (users[sponser].teamNetworkEarnETH.mul(25 ether).div(100 ether)).div(MatchingBonusUplineLimit);\r\n            \r\n            if(_carBonus > 0){\r\n                for(uint j=0; j<_teamNetworkEarnWallet[sponser].length;j++){\r\n                    require(address(uint160(_teamNetworkEarnWallet[sponser][j])).send(_carBonus),\"transfer car bonus failed\");\r\n                    users[_teamNetworkEarnWallet[sponser][j]].totalEarnedETH = users[_teamNetworkEarnWallet[sponser][j]].totalEarnedETH.add(_carBonus);\r\n                    commissionsReceivedValue[msg.sender] = commissionsReceivedValue[msg.sender].add(_carBonus);\r\n                }\r\n                \r\n                if(_teamNetworkEarnWallet[sponser].length != MatchingBonusUplineLimit){\r\n                    uint breakage = MatchingBonusUplineLimit.sub(_teamNetworkEarnWallet[sponser].length);\r\n                    if(breakage > 0){\r\n                        require(address(uint160(admin)).send(_carBonus.mul(breakage)),\"transfer car bonus failed\");\r\n                        users[admin].totalEarnedETH = users[admin].totalEarnedETH.add(_carBonus.mul(breakage));\r\n                        adminBreakageAmount[msg.sender] = adminBreakageAmount[msg.sender].add(_carBonus.mul(breakage));\r\n                        commissionsReceivedValue[msg.sender] = commissionsReceivedValue[msg.sender].add(_carBonus.mul(breakage));\r\n                    }\r\n                }    \r\n                    \r\n                \r\n                emit MatchingCarBonus(\r\n                    _user,\r\n                    sponser,\r\n                    _teamNetworkEarnWallet[sponser],\r\n                    _carBonus\r\n                );\r\n            }\r\n        }\r\n    }\r\n    \r\n    // get all qualified direct sponsers.\r\n    function getAllDirectSponsor(address _sponser, address _directSponser, uint _limit) internal returns(bool){\r\n        \r\n        uint referralCount = rollUpD50Enrolled( _directSponser, 0, users[_directSponser].referrals.length-1); \r\n                    \r\n        if(referralCount >= 1)\r\n          _teamNetworkEarnWallet[_sponser].push(_directSponser);\r\n        \r\n        if(_directSponser == userList[1])\r\n            return true;\r\n        \r\n        _limit++;\r\n        \r\n        if(_limit == MatchingBonusUplineLimit)\r\n            return true;\r\n        \r\n        return getAllDirectSponsor( _sponser, userList[users[_directSponser].referrerID], _limit);\r\n    }\r\n    \r\n    // roll up $50 - Matching bonus \r\n    function rollUpD50Enrolled(address _user, uint _referralCount, uint _referralIndex) internal  returns(uint){\r\n        \r\n        if(((users[users[_user].referrals[_referralIndex]].membershipExpired).add(GRACE_PERIOD) >= now) && (users[users[_user].referrals[_referralIndex]].donated == 2)){\r\n            _referralCount++;\r\n        }\r\n        \r\n        if(_referralIndex == 0)\r\n            return _referralCount;\r\n            \r\n        _referralIndex--;\r\n        \r\n        return rollUpD50Enrolled( _user, _referralCount, _referralIndex);\r\n    }\r\n    \r\n\r\n    // Referral Commission    \r\n    function referralBonus(address _user, uint _value) internal{\r\n        address sponser = userList[users[_user].placementSponser]; \r\n        uint _refBonus = ((_value).mul(12 ether).div(10**20));\r\n        \r\n        if(sponser == address(0)) sponser = userList[1];\r\n        \r\n        if(((users[sponser].membershipExpired).add(blockTime.add(GRACE_PERIOD)) < now)  && (!users[sponser].blocked))\r\n            users[sponser].blocked = true;              \r\n        \r\n        if(users[sponser].blocked){\r\n            sponser = admin;\r\n        }  \r\n        \r\n        require(address(uint160(sponser)).send(_refBonus),\"transfer failed\");\r\n        users[sponser].totalEarnedETH = users[sponser].totalEarnedETH.add(_refBonus);\r\n        commissionsReceivedValue[msg.sender] = commissionsReceivedValue[msg.sender].add(_refBonus);\r\n        \r\n        if(sponser != userList[users[_user].placementSponser])\r\n            adminBreakageAmount[msg.sender] = adminBreakageAmount[msg.sender].add(_refBonus);\r\n        else{\r\n            emit RefBonus(\r\n                _user,\r\n                sponser,\r\n                _refBonus\r\n            );\r\n        }\r\n    }\r\n\r\n    mapping(address => address[]) _addressList;\r\n\r\n    // Infinity Commission    \r\n    function infinityHouseBonus(address _user, uint _amount) internal {\r\n        address[4] memory   house_bonus;\r\n        _addressList[msg.sender] = new address[](0);\r\n        bonusEligibleUsers[msg.sender] = new address[](0);\r\n        \r\n        _addressList[msg.sender].push(userList[1]);\r\n        \r\n        house_bonus[0] = matchingHouseBonusRollUp(userList[users[_user].referrerID],usdPrice.mul(500000), _addressList[msg.sender]); // 2%\r\n        _addressList[msg.sender].push(house_bonus[0]);\r\n        \r\n        house_bonus[1] = matchingHouseBonusRollUp(userList[users[_user].referrerID],usdPrice.mul(200000), _addressList[msg.sender]); // 2%\r\n        if((house_bonus[1] == userList[1]))\r\n            house_bonus[1] = house_bonus[0];\r\n            \r\n        _addressList[msg.sender].push(house_bonus[1]);    \r\n        \r\n        house_bonus[2] = matchingHouseBonusRollUp(userList[users[_user].referrerID],usdPrice.mul(100000), _addressList[msg.sender]); // 2%\r\n        if((house_bonus[2] == userList[1]))\r\n            house_bonus[2] = house_bonus[1];\r\n        \r\n        _addressList[msg.sender].push(house_bonus[2]);    \r\n        \r\n        house_bonus[3] = matchingHouseBonusRollUp(userList[users[_user].referrerID], usdPrice.mul(20000), _addressList[msg.sender]); // 2%\r\n        \r\n        if((house_bonus[3] == userList[1]))\r\n            house_bonus[3] = house_bonus[2];\r\n        \r\n        uint houseUpline_9_12 = (_amount.mul(2 ether).div(10**20));\r\n        \r\n        for(uint i=0; i<house_bonus.length;i++){\r\n            require(address(uint160(house_bonus[i])).send(houseUpline_9_12),\"transfer failed\");\r\n            users[house_bonus[i]].totalEarnedETH = users[house_bonus[i]].totalEarnedETH.add(houseUpline_9_12);\r\n            commissionsReceivedValue[msg.sender] = commissionsReceivedValue[msg.sender].add(houseUpline_9_12);\r\n        }\r\n        \r\n        emit InfinityHouseBonus(\r\n            msg.sender,\r\n            bonusEligibleUsers[msg.sender][0],\r\n            bonusEligibleUsers[msg.sender][1],\r\n            bonusEligibleUsers[msg.sender][2],\r\n            bonusEligibleUsers[msg.sender][3],\r\n            houseUpline_9_12\r\n        );\r\n    }\r\n    \r\n    // roll up - House bonus\r\n    function matchingHouseBonusRollUp(address _user,uint _usdETHValue, address[] memory __previousAddress) internal  returns(address) {\r\n        \r\n        for(uint i=0;i<__previousAddress.length;i++){\r\n            if((_user == __previousAddress[i]) && (_user != userList[1]))\r\n                matchingHouseBonusRollUp(userList[users[_user].referrerID],_usdETHValue, __previousAddress);\r\n        }\r\n        \r\n        if(!users[_user].isExist) {\r\n            bonusEligibleUsers[msg.sender].push(_user);\r\n            return userList[1];\r\n        }\r\n        \r\n         if(((users[_user].membershipExpired).add(GRACE_PERIOD) >= now) && (users[_user].donated == 2) && (!users[_user].blocked))\r\n        {\r\n            uint referralCount;\r\n            if(users[_user].referrals.length > 0)\r\n                referralCount = rollUpD50FL( _user, 0, users[_user].referrals.length-1);\r\n            \r\n            \r\n            if(referralCount >= 4){\r\n                if(users[_user].totalEarnedETH >= _usdETHValue){\r\n                    bonusEligibleUsers[msg.sender].push(_user);\r\n                    return _user;\r\n                }\r\n            } \r\n        } \r\n        \r\n        return matchingHouseBonusRollUp(userList[users[_user].referrerID],_usdETHValue, __previousAddress);\r\n    }\r\n\r\n    // roll up $50 - House bonus    \r\n    function rollUpD50FL(address _user, uint _referralCount, uint _referralIndex) internal  returns(uint){\r\n        \r\n        if(((users[users[_user].referrals[_referralIndex]].membershipExpired).add(GRACE_PERIOD) >= now)  && (users[users[_user].referrals[_referralIndex]].donated == 2)){\r\n            _referralCount++;\r\n        }\r\n        \r\n        if(_referralIndex == 0)\r\n            return _referralCount;\r\n            \r\n        _referralIndex--;\r\n        \r\n        return rollUpD50FL( _user, _referralCount, _referralIndex);\r\n    }\r\n    \r\n    function updateGracePeriod(uint _gracePeriod) public OnlyOwner returns(bool) {\r\n        GRACE_PERIOD = _gracePeriod;\r\n        return true;\r\n    }\r\n    \r\n    function failSafe(address payable _toUser, uint _amount) public OnlyOwner returns (bool) {\r\n        require(_toUser != address(0), \"Invalid Address\");\r\n        require(address(this).balance >= _amount, \"Insufficient balance\");\r\n\r\n        (_toUser).transfer(_amount);\r\n        return true;\r\n    }\r\n \r\n    function contractLock(bool _lockStatus) public OnlyOwner returns(bool) {\r\n        lockStatus = _lockStatus;\r\n        return true;\r\n    }\r\n    \r\n    function updateBlockTime(uint _newBlockTime) public OnlyOwner returns(bool) {\r\n        blockTime = _newBlockTime;\r\n        return true;\r\n    }\r\n    \r\n    function updateMatchingBonusUplineLimit(uint _MatchingBonusUplineLimit) public OnlyOwner returns(bool) {\r\n        require(_MatchingBonusUplineLimit > 0, \"MatchingBonusUplineLimit must be greater than zero\");\r\n        MatchingBonusUplineLimit = _MatchingBonusUplineLimit;\r\n        return true;\r\n    }\r\n    \r\n    function updateAdminWallet( address payable _newAdminWallet) public OnlyOwner returns(bool){\r\n        require(_newAdminWallet != address(0), \"_newAdminWallet must not be zero wallet\");\r\n        \r\n        UserStruct memory userStruct;\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: 1,\r\n            referrerID: 0,\r\n            orginalRefID: 0,\r\n            placementSponser: 0,\r\n            donated: users[admin].donated,\r\n            teamNetworkEarnETH: users[admin].teamNetworkEarnETH,\r\n            totalEarnedETH: users[admin].totalEarnedETH,\r\n            blocked: users[admin].blocked,\r\n            personallyEnrolled : users[admin].personallyEnrolled,\r\n            referrals: users[admin].referrals,\r\n            membershipExpired:users[admin].membershipExpired\r\n        });\r\n        \r\n        UserStruct memory userStruct_;\r\n        \r\n        users[admin] = userStruct_;\r\n        \r\n        admin = _newAdminWallet;\r\n        \r\n        users[admin] = userStruct;    \r\n        userList[1] = admin;\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function isContract(address account) public view returns (bool) {\r\n        uint32 size;\r\n        assembly {\r\n                size := extcodesize(account)\r\n            }\r\n        if(size != 0)\r\n            return true;\r\n            \r\n        return false;\r\n    }\r\n    \r\n    function viewMembershipExpired(address _user) public view returns(uint) {\r\n        return users[_user].membershipExpired;\r\n    }\r\n    \r\n    function viewUserReferral(address _user) public view returns(address[] memory) {\r\n        return users[_user].personallyEnrolled;\r\n    } \r\n    \r\n    function viewUserDirectReferral(address _user) public view returns(address[] memory) {\r\n        return users[_user].referrals;\r\n    } \r\n    \r\n}"}}}