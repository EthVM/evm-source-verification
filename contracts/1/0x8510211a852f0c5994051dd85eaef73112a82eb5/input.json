{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ApprovedTransfer.sol":{"content":"pragma experimental ABIEncoderV2;\r\n// File: contracts/modules/common/Utils.sol\r\n// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n// SPDX-License-Identifier: GPL-3.0-only\r\n/**\r\n * @title Utils\r\n * @notice Common utility methods used by modules.\r\n */\r\nlibrary Utils {\r\n    /**\r\n    * @notice Helper method to recover the signer at a given position from a list of concatenated signatures.\r\n    * @param _signedHash The signed hash\r\n    * @param _signatures The concatenated signatures.\r\n    * @param _index The index of the signature to recover.\r\n    */\r\n    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint _index) internal pure returns (address) {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        // we jump 32 (0x20) as the first slot of bytes contains the length\r\n        // we jump 65 (0x41) per signature\r\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\r\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\r\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\r\n        }\r\n        require(v == 27 || v == 28);\r\n        address recoveredAddress = ecrecover(_signedHash, v, r, s);\r\n        require(recoveredAddress != address(0), \"Utils: ecrecover returned 0\");\r\n        return recoveredAddress;\r\n    }\r\n    /**\r\n    * @notice Helper method to parse data and extract the method signature.\r\n    */\r\n    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\r\n        require(_data.length >= 4, \"RM: Invalid functionPrefix\");\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            prefix := mload(add(_data, 0x20))\r\n        }\r\n    }\r\n    /**\r\n    * @notice Returns ceil(a / b).\r\n    */\r\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        if (a % b == 0) {\r\n            return c;\r\n        } else {\r\n            return c + 1;\r\n        }\r\n    }\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a < b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n}\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n// File: contracts/infrastructure/storage/ILimitStorage.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\n/**\r\n * @title ILimitStorage\r\n * @notice LimitStorage interface\r\n */\r\ninterface ILimitStorage {\r\n    struct Limit {\r\n        // the current limit\r\n        uint128 current;\r\n        // the pending limit if any\r\n        uint128 pending;\r\n        // when the pending limit becomes the current limit\r\n        uint64 changeAfter;\r\n    }\r\n    struct DailySpent {\r\n        // The amount already spent during the current period\r\n        uint128 alreadySpent;\r\n        // The end of the current period\r\n        uint64 periodEnd;\r\n    }\r\n    function setLimit(address _wallet, Limit memory _limit) external;\r\n    function getLimit(address _wallet) external view returns (Limit memory _limit);\r\n    function setDailySpent(address _wallet, DailySpent memory _dailySpent) external;\r\n    function getDailySpent(address _wallet) external view returns (DailySpent memory _dailySpent);\r\n    function setLimitAndDailySpent(address _wallet, Limit memory _limit, DailySpent memory _dailySpent) external;\r\n    function getLimitAndDailySpent(address _wallet) external view returns (Limit memory _limit, DailySpent memory _dailySpent);\r\n}\r\n// File: contracts/infrastructure/ITokenPriceRegistry.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\n/**\r\n * @title ITokenPriceRegistry\r\n * @notice TokenPriceRegistry interface\r\n */\r\ninterface ITokenPriceRegistry {\r\n    function getTokenPrice(address _token) external view returns (uint184 _price);\r\n    function isTokenTradable(address _token) external view returns (bool _isTradable);\r\n}\r\n// File: contracts/modules/common/IVersionManager.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title IVersionManager\r\n * @notice Interface for the VersionManager module.\r\n * @author Olivier VDB - <olivier@argent.xyz>\r\n */\r\ninterface IVersionManager {\r\n    /**\r\n     * @notice Returns true if the feature is authorised for the wallet\r\n     * @param _wallet The target wallet.\r\n     * @param _feature The feature.\r\n     */\r\n    function isFeatureAuthorised(address _wallet, address _feature) external view returns (bool);\r\n    /**\r\n     * @notice Lets a feature (caller) invoke a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _to The target address for the transaction.\r\n     * @param _value The value of the transaction.\r\n     * @param _data The data of the transaction.\r\n     */\r\n    function checkAuthorisedFeatureAndInvokeWallet(\r\n        address _wallet,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) external returns (bytes memory _res);\r\n    /* ******* Backward Compatibility with old Storages and BaseWallet *************** */\r\n    /**\r\n     * @notice Sets a new owner for the wallet.\r\n     * @param _newOwner The new owner.\r\n     */\r\n    function setOwner(address _wallet, address _newOwner) external;\r\n    /**\r\n     * @notice Lets a feature write data to a storage contract.\r\n     * @param _wallet The target wallet.\r\n     * @param _storage The storage contract.\r\n     * @param _data The data of the call\r\n     */\r\n    function invokeStorage(address _wallet, address _storage, bytes calldata _data) external;\r\n    /**\r\n     * @notice Upgrade a wallet to a new version.\r\n     * @param _wallet the wallet to upgrade\r\n     * @param _toVersion the new version\r\n     */\r\n    function upgradeWallet(address _wallet, uint256 _toVersion) external;\r\n}\r\n// File: contracts/modules/common/LimitUtils.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\n/**\r\n * @title LimitUtils\r\n * @notice Helper library to manage the daily limit and interact with a contract implementing the ILimitStorage interface.\r\n * @author Julien Niset - <julien@argent.xyz>\r\n */\r\nlibrary LimitUtils {\r\n    // large limit when the limit can be considered disabled\r\n    uint128 constant internal LIMIT_DISABLED = uint128(-1);\r\n    using SafeMath for uint256;\r\n    // *************** Internal Functions ********************* //\r\n    /**\r\n     * @notice Changes the daily limit (expressed in ETH).\r\n     * Decreasing the limit is immediate while increasing the limit is pending for the security period.\r\n     * @param _lStorage The storage contract.\r\n     * @param _versionManager The version manager.\r\n     * @param _wallet The target wallet.\r\n     * @param _targetLimit The target limit.\r\n     * @param _securityPeriod The security period.\r\n     */\r\n    function changeLimit(\r\n        ILimitStorage _lStorage,\r\n        IVersionManager _versionManager,\r\n        address _wallet,\r\n        uint256 _targetLimit,\r\n        uint256 _securityPeriod\r\n    )\r\n        internal\r\n        returns (ILimitStorage.Limit memory)\r\n    {\r\n        ILimitStorage.Limit memory limit = _lStorage.getLimit(_wallet);\r\n        uint256 currentLimit = currentLimit(limit);\r\n        ILimitStorage.Limit memory newLimit;\r\n        if (_targetLimit <= currentLimit) {\r\n            uint128 targetLimit = safe128(_targetLimit);\r\n            newLimit = ILimitStorage.Limit(targetLimit, targetLimit, safe64(block.timestamp));\r\n        } else {\r\n            newLimit = ILimitStorage.Limit(safe128(currentLimit), safe128(_targetLimit), safe64(block.timestamp.add(_securityPeriod)));\r\n        }\r\n        setLimit(_versionManager, _lStorage, _wallet, newLimit);\r\n        return newLimit;\r\n    }\r\n     /**\r\n     * @notice Disable the daily limit.\r\n     * The change is pending for the security period.\r\n     * @param _lStorage The storage contract.\r\n     * @param _versionManager The version manager.\r\n     * @param _wallet The target wallet.\r\n     * @param _securityPeriod The security period.\r\n     */\r\n    function disableLimit(\r\n        ILimitStorage _lStorage,\r\n        IVersionManager _versionManager,\r\n        address _wallet,\r\n        uint256 _securityPeriod\r\n    )\r\n        internal\r\n    {\r\n        changeLimit(_lStorage, _versionManager, _wallet, LIMIT_DISABLED, _securityPeriod);\r\n    }\r\n    /**\r\n    * @notice Returns whether the daily limit is disabled for a wallet.\r\n    * @param _wallet The target wallet.\r\n    * @return _limitDisabled true if the daily limit is disabled, false otherwise.\r\n    */\r\n    function isLimitDisabled(ILimitStorage _lStorage, address _wallet) internal view returns (bool) {\r\n        ILimitStorage.Limit memory limit = _lStorage.getLimit(_wallet);\r\n        uint256 currentLimit = currentLimit(limit);\r\n        return (currentLimit == LIMIT_DISABLED);\r\n    }\r\n    /**\r\n    * @notice Checks if a transfer is within the limit. If yes the daily spent is updated.\r\n    * @param _lStorage The storage contract.\r\n    * @param _versionManager The Version Manager.\r\n    * @param _wallet The target wallet.\r\n    * @param _amount The amount for the transfer\r\n    * @return true if the transfer is withing the daily limit.\r\n    */\r\n    function checkAndUpdateDailySpent(\r\n        ILimitStorage _lStorage,\r\n        IVersionManager _versionManager,\r\n        address _wallet,\r\n        uint256 _amount\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        (ILimitStorage.Limit memory limit, ILimitStorage.DailySpent memory dailySpent) = _lStorage.getLimitAndDailySpent(_wallet);\r\n        uint256 currentLimit = currentLimit(limit);\r\n        if (_amount == 0 || currentLimit == LIMIT_DISABLED) {\r\n            return true;\r\n        }\r\n        ILimitStorage.DailySpent memory newDailySpent;\r\n        if (dailySpent.periodEnd <= block.timestamp && _amount <= currentLimit) {\r\n            newDailySpent = ILimitStorage.DailySpent(safe128(_amount), safe64(block.timestamp + 24 hours));\r\n            setDailySpent(_versionManager, _lStorage, _wallet, newDailySpent);\r\n            return true;\r\n        } else if (dailySpent.periodEnd > block.timestamp && _amount.add(dailySpent.alreadySpent) <= currentLimit) {\r\n            newDailySpent = ILimitStorage.DailySpent(safe128(_amount.add(dailySpent.alreadySpent)), safe64(dailySpent.periodEnd));\r\n            setDailySpent(_versionManager, _lStorage, _wallet, newDailySpent);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n    * @notice Helper method to Reset the daily consumption.\r\n    * @param _versionManager The Version Manager.\r\n    * @param _wallet The target wallet.\r\n    */\r\n    function resetDailySpent(IVersionManager _versionManager, ILimitStorage limitStorage, address _wallet) internal {\r\n        setDailySpent(_versionManager, limitStorage, _wallet, ILimitStorage.DailySpent(uint128(0), uint64(0)));\r\n    }\r\n    /**\r\n    * @notice Helper method to get the ether value equivalent of a token amount.\r\n    * @notice For low value amounts of tokens we accept this to return zero as these are small enough to disregard.\r\n    * Note that the price stored for tokens = price for 1 token (in ETH wei) * 10^(18-token decimals).\r\n    * @param _amount The token amount.\r\n    * @param _token The address of the token.\r\n    * @return The ether value for _amount of _token.\r\n    */\r\n    function getEtherValue(ITokenPriceRegistry _priceRegistry, uint256 _amount, address _token) internal view returns (uint256) {\r\n        uint256 price = _priceRegistry.getTokenPrice(_token);\r\n        uint256 etherValue = price.mul(_amount).div(10**18);\r\n        return etherValue;\r\n    }\r\n    /**\r\n    * @notice Helper method to get the current limit from a Limit struct.\r\n    * @param _limit The limit struct\r\n    */\r\n    function currentLimit(ILimitStorage.Limit memory _limit) internal view returns (uint256) {\r\n        if (_limit.changeAfter > 0 && _limit.changeAfter < block.timestamp) {\r\n            return _limit.pending;\r\n        }\r\n        return _limit.current;\r\n    }\r\n    function safe128(uint256 _num) internal pure returns (uint128) {\r\n        require(_num < 2**128, \"LU: more then 128 bits\");\r\n        return uint128(_num);\r\n    }\r\n    function safe64(uint256 _num) internal pure returns (uint64) {\r\n        require(_num < 2**64, \"LU: more then 64 bits\");\r\n        return uint64(_num);\r\n    }\r\n    // *************** Storage invocations in VersionManager ********************* //\r\n    function setLimit(\r\n        IVersionManager _versionManager,\r\n        ILimitStorage _lStorage,\r\n        address _wallet, \r\n        ILimitStorage.Limit memory _limit\r\n    ) internal {\r\n        _versionManager.invokeStorage(\r\n            _wallet,\r\n            address(_lStorage),\r\n            abi.encodeWithSelector(_lStorage.setLimit.selector, _wallet, _limit)\r\n        );\r\n    }\r\n    function setDailySpent(\r\n        IVersionManager _versionManager,\r\n        ILimitStorage _lStorage,\r\n        address _wallet, \r\n        ILimitStorage.DailySpent memory _dailySpent\r\n    ) private {\r\n        _versionManager.invokeStorage(\r\n            _wallet,\r\n            address(_lStorage),\r\n            abi.encodeWithSelector(_lStorage.setDailySpent.selector, _wallet, _dailySpent)\r\n        );\r\n    }\r\n}\r\n// File: contracts/wallet/IWallet.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title IWallet\r\n * @notice Interface for the BaseWallet\r\n */\r\ninterface IWallet {\r\n    /**\r\n     * @notice Returns the wallet owner.\r\n     * @return The wallet owner address.\r\n     */\r\n    function owner() external view returns (address);\r\n    /**\r\n     * @notice Returns the number of authorised modules.\r\n     * @return The number of authorised modules.\r\n     */\r\n    function modules() external view returns (uint);\r\n    /**\r\n     * @notice Sets a new owner for the wallet.\r\n     * @param _newOwner The new owner.\r\n     */\r\n    function setOwner(address _newOwner) external;\r\n    /**\r\n     * @notice Checks if a module is authorised on the wallet.\r\n     * @param _module The module address to check.\r\n     * @return `true` if the module is authorised, otherwise `false`.\r\n     */\r\n    function authorised(address _module) external view returns (bool);\r\n    /**\r\n     * @notice Returns the module responsible for a static call redirection.\r\n     * @param _sig The signature of the static call.\r\n     * @return the module doing the redirection\r\n     */\r\n    function enabled(bytes4 _sig) external view returns (address);\r\n    /**\r\n     * @notice Enables/Disables a module.\r\n     * @param _module The target module.\r\n     * @param _value Set to `true` to authorise the module.\r\n     */\r\n    function authoriseModule(address _module, bool _value) external;\r\n    /**\r\n    * @notice Enables a static method by specifying the target module to which the call must be delegated.\r\n    * @param _module The target module.\r\n    * @param _method The static method signature.\r\n    */\r\n    function enableStaticCall(address _module, bytes4 _method) external;\r\n}\r\n// File: contracts/infrastructure/IModuleRegistry.sol\r\n// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title IModuleRegistry\r\n * @notice Interface for the registry of authorised modules.\r\n */\r\ninterface IModuleRegistry {\r\n    function registerModule(address _module, bytes32 _name) external;\r\n    function deregisterModule(address _module) external;\r\n    function registerUpgrader(address _upgrader, bytes32 _name) external;\r\n    function deregisterUpgrader(address _upgrader) external;\r\n    function recoverToken(address _token) external;\r\n    function moduleInfo(address _module) external view returns (bytes32);\r\n    function upgraderInfo(address _upgrader) external view returns (bytes32);\r\n    function isRegisteredModule(address _module) external view returns (bool);\r\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool);\r\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool);\r\n}\r\n// File: contracts/infrastructure/storage/ILockStorage.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\npragma solidity >=0.5.4 <0.7.0;\r\ninterface ILockStorage {\r\n    function isLocked(address _wallet) external view returns (bool);\r\n    function getLock(address _wallet) external view returns (uint256);\r\n    function getLocker(address _wallet) external view returns (address);\r\n    function setLock(address _wallet, address _locker, uint256 _releaseAfter) external;\r\n}\r\n// File: contracts/modules/common/IFeature.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title IFeature\r\n * @notice Interface for a Feature.\r\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\r\n */\r\ninterface IFeature {\r\n    enum OwnerSignature {\r\n        Anyone,             // Anyone\r\n        Required,           // Owner required\r\n        Optional,           // Owner and/or guardians\r\n        Disallowed          // guardians only\r\n    }\r\n    /**\r\n    * @notice Utility method to recover any ERC20 token that was sent to the Feature by mistake.\r\n    * @param _token The token to recover.\r\n    */\r\n    function recoverToken(address _token) external;\r\n    /**\r\n     * @notice Inits a Feature for a wallet by e.g. setting some wallet specific parameters in storage.\r\n     * @param _wallet The wallet.\r\n     */\r\n    function init(address _wallet) external;\r\n    /**\r\n     * @notice Helper method to check if an address is an authorised feature of a target wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _feature The address.\r\n     */\r\n    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) external view returns (bool);\r\n    /**\r\n    * @notice Gets the number of valid signatures that must be provided to execute a\r\n    * specific relayed transaction.\r\n    * @param _wallet The target wallet.\r\n    * @param _data The data of the relayed transaction.\r\n    * @return The number of required signatures and the wallet owner signature requirement.\r\n    */\r\n    function getRequiredSignatures(address _wallet, bytes calldata _data) external view returns (uint256, OwnerSignature);\r\n    /**\r\n    * @notice Gets the list of static call signatures that this feature responds to on behalf of wallets\r\n    */\r\n    function getStaticCallSignatures() external view returns (bytes4[] memory);\r\n}\r\n// File: lib/other/ERC20.sol\r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * ERC20 contract interface.\r\n */\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function decimals() external view returns (uint);\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n}\r\n// File: contracts/modules/common/BaseFeature.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.s\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\n/**\r\n * @title BaseFeature\r\n * @notice Base Feature contract that contains methods common to all Feature contracts.\r\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\r\n */\r\ncontract BaseFeature is IFeature {\r\n    // Empty calldata\r\n    bytes constant internal EMPTY_BYTES = \"\";\r\n    // Mock token address for ETH\r\n    address constant internal ETH_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    // The address of the Lock storage\r\n    ILockStorage internal lockStorage;\r\n    // The address of the Version Manager\r\n    IVersionManager internal versionManager;\r\n    event FeatureCreated(bytes32 name);\r\n    /**\r\n     * @notice Throws if the wallet is locked.\r\n     */\r\n    modifier onlyWhenUnlocked(address _wallet) {\r\n        require(!lockStorage.isLocked(_wallet), \"BF: wallet locked\");\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Throws if the sender is not the VersionManager.\r\n     */\r\n    modifier onlyVersionManager() {\r\n        require(msg.sender == address(versionManager), \"BF: caller must be VersionManager\");\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Throws if the sender is not the owner of the target wallet.\r\n     */\r\n    modifier onlyWalletOwner(address _wallet) {\r\n        require(isOwner(_wallet, msg.sender), \"BF: must be wallet owner\");\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Throws if the sender is not an authorised feature of the target wallet.\r\n     */\r\n    modifier onlyWalletFeature(address _wallet) {\r\n        require(versionManager.isFeatureAuthorised(_wallet, msg.sender), \"BF: must be a wallet feature\");\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Throws if the sender is not the owner of the target wallet or the feature itself.\r\n     */\r\n    modifier onlyWalletOwnerOrFeature(address _wallet) {\r\n        // Wrapping in an internal method reduces deployment cost by avoiding duplication of inlined code\r\n        verifyOwnerOrAuthorisedFeature(_wallet, msg.sender);\r\n        _;\r\n    }\r\n    constructor(\r\n        ILockStorage _lockStorage,\r\n        IVersionManager _versionManager,\r\n        bytes32 _name\r\n    ) public {\r\n        lockStorage = _lockStorage;\r\n        versionManager = _versionManager;\r\n        emit FeatureCreated(_name);\r\n    }\r\n    /**\r\n    * @inheritdoc IFeature\r\n    */\r\n    function recoverToken(address _token) external virtual override {\r\n        uint total = ERC20(_token).balanceOf(address(this));\r\n        _token.call(abi.encodeWithSelector(ERC20(_token).transfer.selector, address(versionManager), total));\r\n    }\r\n    /**\r\n     * @notice Inits the feature for a wallet by doing nothing.\r\n     * @dev !! Overriding methods need make sure `init()` can only be called by the VersionManager !!\r\n     * @param _wallet The wallet.\r\n     */\r\n    function init(address _wallet) external virtual override  {}\r\n    /**\r\n     * @inheritdoc IFeature\r\n     */\r\n    function getRequiredSignatures(address, bytes calldata) external virtual view override returns (uint256, OwnerSignature) {\r\n        revert(\"BF: disabled method\");\r\n    }\r\n    /**\r\n     * @inheritdoc IFeature\r\n     */\r\n    function getStaticCallSignatures() external virtual override view returns (bytes4[] memory _sigs) {}\r\n    /**\r\n     * @inheritdoc IFeature\r\n     */\r\n    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) public override view returns (bool) {\r\n        return versionManager.isFeatureAuthorised(_wallet, _feature);\r\n    }\r\n    /**\r\n    * @notice Checks that the wallet address provided as the first parameter of _data matches _wallet\r\n    * @return false if the addresses are different.\r\n    */\r\n    function verifyData(address _wallet, bytes calldata _data) internal pure returns (bool) {\r\n        require(_data.length >= 36, \"RM: Invalid dataWallet\");\r\n        address dataWallet = abi.decode(_data[4:], (address));\r\n        return dataWallet == _wallet;\r\n    }\r\n     /**\r\n     * @notice Helper method to check if an address is the owner of a target wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _addr The address.\r\n     */\r\n    function isOwner(address _wallet, address _addr) internal view returns (bool) {\r\n        return IWallet(_wallet).owner() == _addr;\r\n    }\r\n    /**\r\n     * @notice Verify that the caller is an authorised feature or the wallet owner.\r\n     * @param _wallet The target wallet.\r\n     * @param _sender The caller.\r\n     */\r\n    function verifyOwnerOrAuthorisedFeature(address _wallet, address _sender) internal view {\r\n        require(isFeatureAuthorisedInVersionManager(_wallet, _sender) || isOwner(_wallet, _sender), \"BF: must be owner or feature\");\r\n    }\r\n    /**\r\n     * @notice Helper method to invoke a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _to The target address for the transaction.\r\n     * @param _value The value of the transaction.\r\n     * @param _data The data of the transaction.\r\n     */\r\n    function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data)\r\n        internal\r\n        returns (bytes memory _res) \r\n    {\r\n        _res = versionManager.checkAuthorisedFeatureAndInvokeWallet(_wallet, _to, _value, _data);\r\n    }\r\n}\r\n// File: contracts/modules/common/BaseTransfer.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\n/**\r\n * @title BaseTransfer\r\n * @notice Contains common methods to transfer tokens or call third-party contracts.\r\n * @author Olivier VDB - <olivier@argent.xyz>\r\n */\r\nabstract contract BaseTransfer is BaseFeature {\r\n    // The address of the WETH token\r\n    address public wethToken;\r\n    // *************** Events *************************** //\r\n    event Transfer(address indexed wallet, address indexed token, uint256 indexed amount, address to, bytes data);\r\n    event Approved(address indexed wallet, address indexed token, uint256 amount, address spender);\r\n    event CalledContract(address indexed wallet, address indexed to, uint256 amount, bytes data);\r\n    event ApprovedAndCalledContract(\r\n        address indexed wallet,\r\n        address indexed to,\r\n        address spender,\r\n        address indexed token,\r\n        uint256 amountApproved,\r\n        uint256 amountSpent,\r\n        bytes data\r\n    );\r\n    event LimitChanged(address indexed wallet, uint indexed newLimit, uint64 indexed startAfter);\r\n    // *************** Constructor ********************** //\r\n    constructor(address _wethToken) public {\r\n        wethToken = _wethToken;\r\n    }\r\n    // *************** Internal Functions ********************* //\r\n    /**\r\n    * @notice Make sure a contract call is not trying to call a module, a feature, or the wallet itself.\r\n    * @param _wallet The target wallet.\r\n    * @param _contract The address of the contract.\r\n     */\r\n    modifier onlyAuthorisedContractCall(address _wallet, address _contract) {\r\n        require(\r\n            _contract != _wallet && // not calling the wallet\r\n            !IWallet(_wallet).authorised(_contract) && // not calling an authorised module\r\n            !versionManager.isFeatureAuthorised(_wallet, _contract), // not calling an authorised feature\r\n            \"BT: Forbidden contract\"\r\n        );\r\n        _;\r\n    }\r\n    /**\r\n    * @notice Helper method to transfer ETH or ERC20 for a wallet.\r\n    * @param _wallet The target wallet.\r\n    * @param _token The ERC20 address.\r\n    * @param _to The recipient.\r\n    * @param _value The amount of ETH to transfer\r\n    * @param _data The data to *log* with the transfer.\r\n    */\r\n    function doTransfer(address _wallet, address _token, address _to, uint256 _value, bytes memory _data) internal {\r\n        if (_token == ETH_TOKEN) {\r\n            invokeWallet(_wallet, _to, _value, EMPTY_BYTES);\r\n        } else {\r\n            bytes memory methodData = abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _value);\r\n            bytes memory transferSuccessBytes = invokeWallet(_wallet, _token, 0, methodData);\r\n            // Check transfer is successful, when `transfer` returns a success bool result\r\n            if (transferSuccessBytes.length > 0) {\r\n                require(abi.decode(transferSuccessBytes, (bool)), \"RM: Transfer failed\");\r\n            }\r\n        }\r\n        emit Transfer(_wallet, _token, _value, _to, _data);\r\n    }\r\n    /**\r\n    * @notice Helper method to approve spending the ERC20 of a wallet.\r\n    * @param _wallet The target wallet.\r\n    * @param _token The ERC20 address.\r\n    * @param _spender The spender address.\r\n    * @param _value The amount of token to transfer.\r\n    */\r\n    function doApproveToken(address _wallet, address _token, address _spender, uint256 _value) internal {\r\n        bytes memory methodData = abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _value);\r\n        invokeWallet(_wallet, _token, 0, methodData);\r\n        emit Approved(_wallet, _token, _value, _spender);\r\n    }\r\n    /**\r\n    * @notice Helper method to call an external contract.\r\n    * @param _wallet The target wallet.\r\n    * @param _contract The contract address.\r\n    * @param _value The ETH value to transfer.\r\n    * @param _data The method data.\r\n    */\r\n    function doCallContract(address _wallet, address _contract, uint256 _value, bytes memory _data) internal {\r\n        invokeWallet(_wallet, _contract, _value, _data);\r\n        emit CalledContract(_wallet, _contract, _value, _data);\r\n    }\r\n    /**\r\n    * @notice Helper method to approve a certain amount of token and call an external contract.\r\n    * The address that spends the _token and the address that is called with _data can be different.\r\n    * @param _wallet The target wallet.\r\n    * @param _token The ERC20 address.\r\n    * @param _proxy The address to approve.\r\n    * @param _amount The amount of tokens to transfer.\r\n    * @param _contract The contract address.\r\n    * @param _data The method data.\r\n    */\r\n    function doApproveTokenAndCallContract(\r\n        address _wallet,\r\n        address _token,\r\n        address _proxy,\r\n        uint256 _amount,\r\n        address _contract,\r\n        bytes memory _data\r\n    )\r\n        internal\r\n    {\r\n        // Ensure there is sufficient balance of token before we approve\r\n        uint256 balance = ERC20(_token).balanceOf(_wallet);\r\n        require(balance >= _amount, \"BT: insufficient balance\");\r\n        uint256 existingAllowance = ERC20(_token).allowance(_wallet, _proxy);\r\n        uint256 totalAllowance = SafeMath.add(existingAllowance, _amount);\r\n        // Approve the desired amount plus existing amount. This logic allows for potential gas saving later\r\n        // when restoring the original approved amount, in cases where the _proxy uses the exact approved _amount.\r\n        bytes memory methodData = abi.encodeWithSignature(\"approve(address,uint256)\", _proxy, totalAllowance);\r\n        invokeWallet(_wallet, _token, 0, methodData);\r\n        invokeWallet(_wallet, _contract, 0, _data);\r\n        // Calculate the approved amount that was spent after the call\r\n        uint256 unusedAllowance = ERC20(_token).allowance(_wallet, _proxy);\r\n        uint256 usedAllowance = SafeMath.sub(totalAllowance, unusedAllowance);\r\n        // Ensure the amount spent does not exceed the amount approved for this call\r\n        require(usedAllowance <= _amount, \"BT: insufficient amount for call\");\r\n        if (unusedAllowance != existingAllowance) {\r\n            // Restore the original allowance amount if the amount spent was different (can be lower).\r\n            methodData = abi.encodeWithSignature(\"approve(address,uint256)\", _proxy, existingAllowance);\r\n            invokeWallet(_wallet, _token, 0, methodData);\r\n        }\r\n        emit ApprovedAndCalledContract(\r\n            _wallet,\r\n            _contract,\r\n            _proxy,\r\n            _token,\r\n            _amount,\r\n            usedAllowance,\r\n            _data);\r\n    }\r\n    /**\r\n    * @notice Helper method to wrap ETH into WETH, approve a certain amount of WETH and call an external contract.\r\n    * The address that spends the WETH and the address that is called with _data can be different.\r\n    * @param _wallet The target wallet.\r\n    * @param _proxy The address to approves.\r\n    * @param _amount The amount of tokens to transfer.\r\n    * @param _contract The contract address.\r\n    * @param _data The method data.\r\n    */\r\n    function doApproveWethAndCallContract(\r\n        address _wallet,\r\n        address _proxy,\r\n        uint256 _amount,\r\n        address _contract,\r\n        bytes memory _data\r\n    )\r\n        internal\r\n    {\r\n        uint256 wethBalance = ERC20(wethToken).balanceOf(_wallet);\r\n        if (wethBalance < _amount) {\r\n            // Wrap ETH into WETH\r\n            invokeWallet(_wallet, wethToken, _amount - wethBalance, abi.encodeWithSignature(\"deposit()\"));\r\n        }\r\n        doApproveTokenAndCallContract(_wallet, wethToken, _proxy, _amount, _contract, _data);\r\n    }\r\n}\r\n// File: contracts/infrastructure/storage/IGuardianStorage.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\npragma solidity >=0.5.4 <0.7.0;\r\ninterface IGuardianStorage {\r\n    /**\r\n     * @notice Lets an authorised module add a guardian to a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The guardian to add.\r\n     */\r\n    function addGuardian(address _wallet, address _guardian) external;\r\n    /**\r\n     * @notice Lets an authorised module revoke a guardian from a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The guardian to revoke.\r\n     */\r\n    function revokeGuardian(address _wallet, address _guardian) external;\r\n    /**\r\n     * @notice Checks if an account is a guardian for a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The account.\r\n     * @return true if the account is a guardian for a wallet.\r\n     */\r\n    function isGuardian(address _wallet, address _guardian) external view returns (bool);\r\n    function isLocked(address _wallet) external view returns (bool);\r\n    function getLock(address _wallet) external view returns (uint256);\r\n    function getLocker(address _wallet) external view returns (address);\r\n    function setLock(address _wallet, uint256 _releaseAfter) external;\r\n    function getGuardians(address _wallet) external view returns (address[] memory);\r\n    function guardianCount(address _wallet) external view returns (uint256);\r\n}\r\n// File: modules/ApprovedTransfer.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\n/**\r\n * @title ApprovedTransfer\r\n * @notice Feature to transfer tokens (ETH or ERC20) or call third-party contracts with the approval of guardians.\r\n * @author Julien Niset - <julien@argent.xyz>\r\n */\r\ncontract ApprovedTransfer is BaseTransfer {\r\n    bytes32 constant NAME = \"ApprovedTransfer\";\r\n    // The guardian storage\r\n    IGuardianStorage public guardianStorage;\r\n    // The limit storage\r\n    ILimitStorage public limitStorage;\r\n    constructor(\r\n        ILockStorage _lockStorage,\r\n        IGuardianStorage _guardianStorage,\r\n        ILimitStorage _limitStorage,\r\n        IVersionManager _versionManager,\r\n        address _wethToken\r\n    )\r\n        BaseFeature(_lockStorage, _versionManager, NAME)\r\n        BaseTransfer(_wethToken)\r\n        public\r\n    {\r\n        guardianStorage = _guardianStorage;\r\n        limitStorage = _limitStorage;\r\n    }\r\n    /**\r\n    * @notice Transfers tokens (ETH or ERC20) from a wallet.\r\n    * @param _wallet The target wallet.\r\n    * @param _token The address of the token to transfer.\r\n    * @param _to The destination address\r\n    * @param _amount The amount of token to transfer\r\n    * @param _data  The data for the transaction (only for ETH transfers)\r\n    */\r\n    function transferToken(\r\n        address _wallet,\r\n        address _token,\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        onlyWalletFeature(_wallet)\r\n        onlyWhenUnlocked(_wallet)\r\n    {\r\n        doTransfer(_wallet, _token, _to, _amount, _data);\r\n        LimitUtils.resetDailySpent(versionManager, limitStorage, _wallet);\r\n    }\r\n    /**\r\n    * @notice Call a contract.\r\n    * @param _wallet The target wallet.\r\n    * @param _contract The address of the contract.\r\n    * @param _value The amount of ETH to transfer as part of call\r\n    * @param _data The encoded method data\r\n    */\r\n    function callContract(\r\n        address _wallet,\r\n        address _contract,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        onlyWalletFeature(_wallet)\r\n        onlyWhenUnlocked(_wallet)\r\n        onlyAuthorisedContractCall(_wallet, _contract)\r\n    {\r\n        doCallContract(_wallet, _contract, _value, _data);\r\n        LimitUtils.resetDailySpent(versionManager, limitStorage, _wallet);\r\n    }\r\n    /**\r\n    * @notice Lets the owner do an ERC20 approve followed by a call to a contract.\r\n    * The address to approve may be different than the contract to call.\r\n    * We assume that the contract does not require ETH.\r\n    * @param _wallet The target wallet.\r\n    * @param _token The token to approve.\r\n    * @param _spender The address to approve.\r\n    * @param _amount The amount of ERC20 tokens to approve.\r\n    * @param _contract The contract to call.\r\n    * @param _data The encoded method data\r\n    */\r\n    function approveTokenAndCallContract(\r\n        address _wallet,\r\n        address _token,\r\n        address _spender,\r\n        uint256 _amount,\r\n        address _contract,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        onlyWalletFeature(_wallet)\r\n        onlyWhenUnlocked(_wallet)\r\n        onlyAuthorisedContractCall(_wallet, _contract)\r\n    {\r\n        doApproveTokenAndCallContract(_wallet, _token, _spender, _amount, _contract, _data);\r\n        LimitUtils.resetDailySpent(versionManager, limitStorage, _wallet);\r\n    }\r\n    /**\r\n     * @notice Changes the daily limit. The change is immediate.\r\n     * @param _wallet The target wallet.\r\n     * @param _newLimit The new limit.\r\n     */\r\n    function changeLimit(address _wallet, uint256 _newLimit) external onlyWalletFeature(_wallet) onlyWhenUnlocked(_wallet) {\r\n        uint128 targetLimit = LimitUtils.safe128(_newLimit);\r\n        ILimitStorage.Limit memory newLimit = ILimitStorage.Limit(targetLimit, targetLimit, LimitUtils.safe64(block.timestamp));\r\n        ILimitStorage.DailySpent memory resetDailySpent = ILimitStorage.DailySpent(uint128(0), uint64(0));\r\n        setLimitAndDailySpent(_wallet, newLimit, resetDailySpent);\r\n        emit LimitChanged(_wallet, _newLimit, newLimit.changeAfter);\r\n    }\r\n    /**\r\n    * @notice Resets the daily spent amount.\r\n    * @param _wallet The target wallet.\r\n    */\r\n    function resetDailySpent(address _wallet) external onlyWalletFeature(_wallet) onlyWhenUnlocked(_wallet) {\r\n        LimitUtils.resetDailySpent(versionManager, limitStorage, _wallet);\r\n    }\r\n    /**\r\n    * @notice lets the owner wrap ETH into WETH, approve the WETH and call a contract.\r\n    * The address to approve may be different than the contract to call.\r\n    * We assume that the contract does not require ETH.\r\n    * @param _wallet The target wallet.\r\n    * @param _spender The address to approve.\r\n    * @param _amount The amount of ERC20 tokens to approve.\r\n    * @param _contract The contract to call.\r\n    * @param _data The encoded method data\r\n    */\r\n    function approveWethAndCallContract(\r\n        address _wallet,\r\n        address _spender,\r\n        uint256 _amount,\r\n        address _contract,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        onlyWalletFeature(_wallet)\r\n        onlyWhenUnlocked(_wallet)\r\n        onlyAuthorisedContractCall(_wallet, _contract)\r\n    {\r\n        doApproveWethAndCallContract(_wallet, _spender, _amount, _contract, _data);\r\n        LimitUtils.resetDailySpent(versionManager, limitStorage, _wallet);\r\n    }\r\n    /**\r\n     * @inheritdoc IFeature\r\n     */\r\n    function getRequiredSignatures(address _wallet, bytes calldata) external view override returns (uint256, OwnerSignature) {\r\n        // owner  + [n/2] guardians\r\n        uint numberOfGuardians = Utils.ceil(guardianStorage.guardianCount(_wallet), 2);\r\n        require(numberOfGuardians > 0, \"AT: no guardians set on wallet\");\r\n        uint numberOfSignatures = 1 + numberOfGuardians;\r\n        return (numberOfSignatures, OwnerSignature.Required);\r\n    }\r\n    // *************** Internal Functions ********************* //\r\n    function setLimitAndDailySpent(\r\n        address _wallet,\r\n        ILimitStorage.Limit memory _limit,\r\n        ILimitStorage.DailySpent memory _dailySpent\r\n    ) internal {\r\n        versionManager.invokeStorage(\r\n            _wallet,\r\n            address(limitStorage),\r\n            abi.encodeWithSelector(limitStorage.setLimitAndDailySpent.selector, _wallet, _limit, _dailySpent)\r\n        );\r\n    }\r\n}"}}}