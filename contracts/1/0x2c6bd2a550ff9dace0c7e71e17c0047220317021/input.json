{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":999999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/CosmoDistributor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n        return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\n\ncontract CosmoDistributor {\n    using SafeMath for uint256;\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status = _NOT_ENTERED;\n\n    address private _owner;\n\n    address public constant token = 0x27cd7375478F189bdcF55616b088BE03d9c4339c;\n    uint256 public constant timeStart = 1615820400;  // 2021-03-15T15:00:00.000Z = 1615820400\n    uint256 public constant timeEnd = 1647356400;    // 2022-03-15T15:00:00.000Z = 1647356400\n\n    mapping(address => uint256) public vestedAmount;\n    mapping(address => uint256) public totalDrawn;\n    mapping(address => uint256) public lastDrawnAt;\n\n    string public url = \"https://CosmoFund.space/\";\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event ScheduleCreated(address indexed beneficiary);\n    event DrawDown(address indexed beneficiary, uint256 indexed amount);\n\n    constructor() public {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n        setup();\n    }\n\n    function setup() internal {\n        vestedAmount[0xB2F8234571eEF9B222DEca1307A03c6c2E376b73] = 1800000000e18;\n        vestedAmount[0x3A7F0d57928d7dCE60E11470e528c47CF5084f33] = 18000000e18;\n    }\n\n    /**\n    * @notice Create new vesting schedules in a batch\n    * @notice A transfer is used to bring tokens into the VestingDepositAccount so pre-approval is required\n    * @param beneficiaries array of beneficiaries of the vested tokens\n    * @param amounts array of amount of tokens (in wei)\n    * @dev array index of address should be the same as the array index of the amount\n    */\n    function createVestingSchedules(address[] calldata beneficiaries, uint256[] calldata amounts) external onlyOwner returns (bool) {\n        require(beneficiaries.length > 0, \"Empty Data\");\n        require(beneficiaries.length == amounts.length, \"Array lengths do not match\");\n        for (uint256 i = 0; i < beneficiaries.length; i = i.add(1)) {\n            address beneficiary = beneficiaries[i];\n            uint256 amount = amounts[i];\n            _createVestingSchedule(beneficiary, amount);\n        }\n        return true;\n    }\n\n    /**\n    * @notice Create a new vesting schedule\n    * @notice A transfer is used to bring tokens into the VestingDepositAccount so pre-approval is required\n    * @param beneficiary beneficiary of the vested tokens\n    * @param amount amount of tokens (in wei)\n    */\n    function createVestingSchedule(address beneficiary, uint256 amount) external onlyOwner returns (bool) {\n        return _createVestingSchedule(beneficiary, amount);\n    }\n\n    /**\n    * @notice Draws down any vested tokens due\n    * @dev Must be called directly by the beneficiary assigned the tokens in the schedule\n    */\n    function drawDown() nonReentrant external returns (bool) {\n        return _drawDown(_msgSender());\n    }\n\n    /**\n    * @notice Vesting schedule and associated data for a beneficiary\n    * @dev Must be called directly by the beneficiary assigned the tokens in the schedule\n    * @return _amount\n    * @return _totalDrawn\n    * @return _lastDrawnAt\n    * @return _remainingBalance\n    */\n    function vestingScheduleForBeneficiary(address beneficiary) external view\n    returns (uint256 _amount, uint256 _totalDrawn, uint256 _lastDrawnAt, uint256 _remainingBalance) {\n        return (\n            vestedAmount[beneficiary],\n            totalDrawn[beneficiary],\n            lastDrawnAt[beneficiary],\n            vestedAmount[beneficiary].sub(totalDrawn[beneficiary])\n        );\n    }\n\n    /**\n    * @notice Draw down amount currently available (based on the block timestamp)\n    * @param beneficiary beneficiary of the vested tokens\n    * @return amount tokens due from vesting schedule\n    */\n    function availableDrawDownAmount(address beneficiary) external view returns (uint256) {\n        return _availableDrawDownAmount(beneficiary);\n    }\n\n    /**\n    * @notice Balance remaining in vesting schedule\n    * @param beneficiary beneficiary of the vested tokens\n    * @return remainingBalance tokens still due (and currently locked) from vesting schedule\n    */\n    function remainingBalance(address beneficiary) external view returns (uint256) {\n        return vestedAmount[beneficiary].sub(totalDrawn[beneficiary]);\n    }\n\n    function _createVestingSchedule(address beneficiary, uint256 amount) internal returns (bool) {\n        require(beneficiary != address(0), \"Beneficiary cannot be empty\");\n        require(amount > 0, \"Amount cannot be empty\");\n        // Ensure one per address\n        require(vestedAmount[beneficiary] == 0, \"Schedule already in flight\");\n        vestedAmount[beneficiary] = amount;\n        // Vest the tokens into the deposit account and delegate to the beneficiary\n        require(IERC20(token).transferFrom(_msgSender(), address(this), amount), \"Unable to escrow tokens\");\n        emit ScheduleCreated(beneficiary);\n        return true;\n    }\n\n    function _drawDown(address beneficiary) internal returns (bool) {\n        require(vestedAmount[beneficiary] > 0, \"There is no schedule currently in flight\");\n        uint256 amount = _availableDrawDownAmount(beneficiary);\n        require(amount > 0, \"No allowance left to withdraw\");\n        // Update last drawn to now\n        lastDrawnAt[beneficiary] = _getNow();\n        // Increase total drawn amount\n        totalDrawn[beneficiary] = totalDrawn[beneficiary].add(amount);\n        // Safety measure - this should never trigger\n        require(totalDrawn[beneficiary] <= vestedAmount[beneficiary], \"Safety Mechanism - Drawn exceeded Amount Vested\");\n        // Issue tokens to beneficiary\n        require(IERC20(token).transfer(beneficiary, amount), \"Unable to transfer tokens\");\n        emit DrawDown(beneficiary, amount);\n        return true;\n    }\n\n    function _availableDrawDownAmount(address beneficiary) internal view returns (uint256) {\n        uint256 nowTime = _getNow();\n        // Schedule complete\n        if (nowTime > timeEnd) {\n            return vestedAmount[beneficiary].sub(totalDrawn[beneficiary]);\n        }\n        // Schedule is active\n        // Work out when the last invocation was\n        uint256 timeLastDrawnOrStart = lastDrawnAt[beneficiary] == 0 ? timeStart : lastDrawnAt[beneficiary];\n        // Find out how much time has past since last invocation\n        uint256 timePassedSinceLastInvocation = nowTime.sub(timeLastDrawnOrStart);\n        // Work out how many due tokens - time passed * rate per second\n        uint256 drawDownRate = vestedAmount[beneficiary].mul(1e18).div(timeEnd.sub(timeStart));\n        uint256 amount = timePassedSinceLastInvocation.mul(drawDownRate).div(1e18);\n        return amount;\n    }\n\n    function _getNow() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"Reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Caller is not the owner\");\n        _;\n    }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n}\n"}}}