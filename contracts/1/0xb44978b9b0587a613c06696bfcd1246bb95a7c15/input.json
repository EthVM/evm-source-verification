{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BitcashPayDecentralizedLiquidityContribution.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity >=0.4.16 <0.8.0;\r\n\r\n/**\r\n\r\n██████╗░██╗████████╗░█████╗░░█████╗░░██████╗██╗░░██╗██████╗░░█████╗░██╗░░░██╗\r\n██╔══██╗██║╚══██╔══╝██╔══██╗██╔══██╗██╔════╝██║░░██║██╔══██╗██╔══██╗╚██╗░██╔╝\r\n██████╦╝██║░░░██║░░░██║░░╚═╝███████║╚█████╗░███████║██████╔╝███████║░╚████╔╝░\r\n██╔══██╗██║░░░██║░░░██║░░██╗██╔══██║░╚═══██╗██╔══██║██╔═══╝░██╔══██║░░╚██╔╝░░\r\n██████╦╝██║░░░██║░░░╚█████╔╝██║░░██║██████╔╝██║░░██║██║░░░░░██║░░██║░░░██║░░░\r\n╚═════╝░╚═╝░░░╚═╝░░░░╚════╝░╚═╝░░╚═╝╚═════╝░╚═╝░░╚═╝╚═╝░░░░░╚═╝░░╚═╝░░░╚═╝░░░\r\n\r\nBitcashpay BCP token has a Decentralized Liquidity Contribution or DLC as we termed it. \r\nUnlike the traditional ICOs where the project owners or team members gather \r\nfunds to “further develop” the project ( or simply run away ), \r\nparticipants to our DLC will directly contribute to uniswap’s ETH/BCP pair. \r\nNinety-five percent (95%) of accumulated funds during our DLC event will go directly to ETH/BCP pairing in uniswap, \r\nthis will create a HUGE DECENTRALIZED LIUIDITY POOL in Uniswap, an OWNERLESS POOL \r\nand only five percent (5%) will go to the team to be used for further development. \r\nThere will be a total of 300M BCP tokens up for grabs on our DLC event with a hardcap of 20,000 ETH\r\n\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface BitcashPay {\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint _value\r\n    ) external returns (bool success);\r\n\r\n    function transfer(address _to, uint _amount) external returns (bool success);\r\n}\r\n\r\ninterface UniswapRouterV2 {\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenMax,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (\r\n        uint256 amountToken,\r\n        uint256 amountETH,\r\n        uint256 liquidity\r\n    );\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (\r\n        uint256 amountB\r\n    );\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (\r\n        uint256[] memory amounts\r\n    );\r\n\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\ninterface IERC20Token {\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )  external returns (\r\n        bool success\r\n    );\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    )  external returns (\r\n        bool success\r\n    );\r\n\r\n}\r\n\r\ninterface UniswapV2Pair {\r\n\r\n    function getReserves() external view returns (\r\n        uint112 reserve0,\r\n        uint112 reserve1,\r\n        uint32 blockTimestampLast\r\n    );\r\n\r\n    function token1() external view returns (address);\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract BitcashPayDecentralizedLiquidityContribution is ReentrancyGuard\r\n{\r\n    using SafeMath for uint;\r\n\r\n    BitcashPay public BITCASHPAY_CONTRACT;\r\n    UniswapV2Pair public UNISWAP_PAIR;\r\n    UniswapRouterV2 public UNISWAP_ROUTER;\r\n\r\n    address public owner;\r\n    uint investmentDays = 90;\r\n\r\n    address payable TEAM_ADDRESS;\r\n    address public TOKEN_DEFINER;\r\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    uint public startDate;\r\n\r\n    uint public reservationChange = 66667000000000 wei; //in wei 15k BCP per 1 ETH\r\n\r\n    uint public maxBCPAvailableForContribution = 300000000;\r\n\r\n    uint public referraBonusRate = 10;\r\n    uint public hardCap = 20000 ether;\r\n\r\n    uint MULTIPLIER = 10 ** 8; // BCP TO WEI\r\n\r\n    mapping (address => uint) internal bcpReservations;\r\n    mapping (address => Bonus[]) internal referralBonuses;\r\n    mapping (address => uint) internal reservedEther;\r\n\r\n    struct Globals {\r\n        uint totalReservedTokens;\r\n        uint totalWeiContributed;\r\n        uint totalReferralTokens;\r\n    }\r\n\r\n    Globals public g;\r\n\r\n    struct Bonus {\r\n        address fromAddress;\r\n        address toAddress;\r\n        uint amount;\r\n        uint bonus;\r\n    }\r\n\r\n    event UniSwapResult(\r\n        uint amountToken,\r\n        uint amountETH,\r\n        uint liquidity\r\n    );\r\n\r\n    event BitcashPayReservation (\r\n        address _reservedTo,\r\n        uint _amountReserved\r\n    );\r\n\r\n    event BitcashPayReservationReferralBonus (\r\n        address _from,\r\n        address _referrerAddress,\r\n        uint _amount\r\n    );\r\n\r\n    constructor(address _bitcashPayToken, address _uniswapPair, address _uniswapRouter, address payable _teamAddress)\r\n    {\r\n        BITCASHPAY_CONTRACT = BitcashPay(_bitcashPayToken);\r\n        UNISWAP_PAIR = UniswapV2Pair(_uniswapPair);\r\n        UNISWAP_ROUTER = UniswapRouterV2(_uniswapRouter);\r\n        TOKEN_DEFINER = msg.sender;\r\n        TEAM_ADDRESS = _teamAddress;\r\n        startDate = block.timestamp;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // BITCASHPAY DLC VARIABLE SETTERS //\r\n\r\n    function setMaxBCPAvailableForContribution(uint _amount) public onlyOwner\r\n    {\r\n        maxBCPAvailableForContribution = _amount;\r\n    }\r\n\r\n    \r\n    function setDefaultReservationChange(uint _reservationChange) public onlyOwner\r\n    {\r\n        reservationChange = _reservationChange;\r\n    }\r\n    \r\n\r\n    function setInvestmentDays(uint _investmentDays) public onlyOwner\r\n    {\r\n        investmentDays = _investmentDays;\r\n    }\r\n\r\n    function setReferralBonusRate(uint _referralBonusRate) public onlyOwner\r\n    {\r\n        referraBonusRate = _referralBonusRate;\r\n    }\r\n\r\n    function setHardCap(uint _hardCap) public onlyOwner\r\n    {\r\n        hardCap = _hardCap;\r\n    }\r\n\r\n    /** @notice Allows reservation of BitcashPay tokens\r\n      */\r\n    receive() external payable {\r\n        require (\r\n            msg.value >= reservationChange,\r\n            'BitcashPay: Reservation too low.'\r\n        );\r\n\r\n        uint reservationAmount = (msg.value).div(reservationChange);\r\n\r\n        _reserveBitcashPay(\r\n            msg.sender,\r\n            reservationAmount\r\n        );\r\n\r\n        g.totalWeiContributed += msg.value;\r\n\r\n        reservedEther[msg.sender] += msg.value;\r\n    }\r\n\r\n    /** @notice Allows reservation of BitcashPay Token to be excuted by web3\r\n      * @param _referrerAddress address of referrers been pulled from localstorage/url/cookies\r\n      */\r\n    function reserveBitcashPay(address _referrerAddress) external payable nonReentrant\r\n    {\r\n\r\n        uint reservationAmount = (msg.value).div(reservationChange);\r\n\r\n        _reserveBitcashPay(\r\n            msg.sender,\r\n            reservationAmount\r\n        );\r\n\r\n        _reserveReferralBonus(msg.sender, _referrerAddress, reservationAmount);\r\n\r\n        g.totalWeiContributed += msg.value;\r\n        \r\n        reservedEther[msg.sender] += msg.value;\r\n    }\r\n\r\n    \r\n    /** @notice Allows reservation of BitcashPay tokens with other ERC20 tokens\r\n      * @dev this will require LT contract to be approved as spender\r\n      * @param _tokenAddress address of an ERC20 token to use\r\n      * @param _tokenAmount amount of tokens to use for reservation\r\n      * @param _referrerAddress referral address for bonus\r\n      */\r\n    function reserveBitcashPayWithToken(\r\n        address _tokenAddress, //erc token address\r\n        uint256 _tokenAmount,\r\n        address _referrerAddress\r\n    )\r\n        external nonReentrant\r\n    {\r\n        IERC20Token _token = IERC20Token(\r\n            _tokenAddress\r\n        );\r\n\r\n        _token.transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            _tokenAmount\r\n        );\r\n\r\n        _token.approve(\r\n            address(UNISWAP_ROUTER),\r\n            _tokenAmount\r\n        );\r\n\r\n        address[] memory _path = preparePath(\r\n            _tokenAddress\r\n        );\r\n\r\n        uint256[] memory amounts =\r\n        UNISWAP_ROUTER.swapExactTokensForETH(\r\n            _tokenAmount,\r\n            0,\r\n            _path,\r\n            address(this),\r\n            block.timestamp.add(2 hours)\r\n        );\r\n\r\n        require (\r\n            amounts[1] >= reservationChange,\r\n            'BitcashPay: Reservation too low.'\r\n        );\r\n\r\n\r\n        uint reservationAmount = (amounts[1]).div(reservationChange);\r\n\r\n        _reserveBitcashPay(\r\n            msg.sender,\r\n            reservationAmount\r\n        );\r\n\r\n        _reserveReferralBonus(msg.sender, _referrerAddress, reservationAmount);\r\n\r\n        g.totalWeiContributed += amounts[1];\r\n        reservedEther[msg.sender] += amounts[1];\r\n    }\r\n\r\n\r\n    // INFO VIEW FUNCTIONS //\r\n\r\n    //----------------------------------------//\r\n\r\n    function myTotalContributionAmount() external view returns (uint256) {\r\n        return bcpReservations[msg.sender];\r\n    }\r\n\r\n    function reservationDaysRemaining() external view returns (uint) {\r\n        return (block.timestamp - startDate) / 60 / 60 / 24;\r\n    }\r\n\r\n    function myTotalClaimableReservations() external view returns (uint)\r\n    {\r\n        return claimableReservation(msg.sender);\r\n    }\r\n\r\n    function myTotalClaimableReferralBonus() external view returns (uint)\r\n    {\r\n        return claimableReferralBonus(msg.sender);\r\n    }\r\n\r\n\r\n    // PAYOUT BITCASHPAY TOKENS //\r\n    // ------------------------ //\r\n\r\n    //  BITCASHPAY TOKEN PAYOUT FUNCTIONS (INDIVIDUAL)  //\r\n    //  ----------------------------------------  //\r\n\r\n    function getMyTokens()\r\n        external\r\n        afterReservationPhase\r\n    {\r\n        payoutInvestorAddress(msg.sender);\r\n        payoutReferralAddress(msg.sender);\r\n    }\r\n\r\n   \r\n    function payoutInvestorAddress(\r\n        address _investorAddress\r\n    )\r\n        public\r\n        afterReservationPhase\r\n        returns (uint claimedReservation)\r\n    {\r\n        uint reservation = claimableReservation(_investorAddress);\r\n        require(claimableReservation(_investorAddress) > 0, \"BitcashPay: You dont have claimable reservation.\");\r\n        BITCASHPAY_CONTRACT.transferFrom(owner, _investorAddress, reservation);\r\n        bcpReservations[_investorAddress] = 0;\r\n        return claimableReservation(_investorAddress);\r\n    }\r\n\r\n\r\n    function payoutReferralAddress(\r\n        address _referrerAddress\r\n    ) public\r\n        afterReservationPhase\r\n        returns (uint256 _referralTokens)\r\n    {\r\n        _referralTokens = claimableReferralBonus(_referrerAddress);\r\n        if (_referralTokens > 0) {\r\n            BITCASHPAY_CONTRACT.transferFrom(owner, _referrerAddress, claimableReservation(_referrerAddress));\r\n            delete referralBonuses[_referrerAddress];\r\n        }\r\n    }\r\n\r\n\r\n    // BITCASHPAY RESERVATION INTERNAL FUNCTIONS //\r\n    // ---------------------------------------- //\r\n\r\n    /** @notice Calculates the claimable reservation\r\n      * @dev if contribution reached the hard cap (20,000ETH) the maximum BCP Available for Contribution will be devided\r\n      * @param _contributorsAddress address of the contributor\r\n      */\r\n    function claimableReservation(address _contributorsAddress) public view returns (uint)\r\n    {\r\n\r\n        if (g.totalWeiContributed >= hardCap) {\r\n            uint contributorsShare = maxBCPAvailableForContribution.mul(MULTIPLIER).mul(reservedEther[_contributorsAddress] / g.totalWeiContributed);\r\n            return contributorsShare;\r\n        }\r\n        \r\n        return bcpReservations[_contributorsAddress];\r\n    }\r\n\r\n    function claimableReferralBonus(address _referrerAddress) public view returns (uint TotalBonus)\r\n    {\r\n        TotalBonus = 0;\r\n        \r\n        for (uint b = 0; b < referralBonuses[_referrerAddress].length; b += 1 ) {\r\n            if (g.totalWeiContributed >= hardCap) {\r\n                TotalBonus += (referralBonuses[_referrerAddress][b].amount).mul(referraBonusRate.mul(100).div(10000));\r\n            } else {\r\n                TotalBonus += referralBonuses[_referrerAddress][b].bonus;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function _reserveBitcashPay(address _senderAddress, uint _amount) internal\r\n    {\r\n        bcpReservations[_senderAddress] += _amount.mul(MULTIPLIER);\r\n        g.totalReservedTokens += _amount.mul(MULTIPLIER);\r\n\r\n        emit BitcashPayReservation(\r\n            _senderAddress,\r\n            _amount.mul(MULTIPLIER)\r\n        );\r\n    }\r\n\r\n\r\n    function _reserveReferralBonus(address _from, address _referrerAddress,  uint _amount) internal\r\n    {\r\n        uint referralBonus = _amount * referraBonusRate.mul(100) / 10000;\r\n\r\n        referralBonuses[_referrerAddress].push(Bonus(_from, _referrerAddress, _amount, referralBonus.mul(MULTIPLIER)));\r\n        g.totalReferralTokens += referralBonus.mul(MULTIPLIER);\r\n\r\n        emit BitcashPayReservationReferralBonus (\r\n            _from,\r\n            _referrerAddress,\r\n            referralBonus.mul(MULTIPLIER)\r\n        );\r\n        \r\n    }\r\n\r\n\r\n    //  LIQUIDITY GENERATION FUNCTION  //\r\n    //  -----------------------------  //\r\n\r\n    /** @notice Forwards the contribution to the liquidity pool\r\n      */\r\n    function forwardLiquidity()\r\n        external\r\n        afterReservationPhase\r\n    {\r\n\r\n        uint _balance = g.totalWeiContributed;\r\n        uint _buffer = g.totalReservedTokens + g.totalReferralTokens;\r\n        uint _teamContribution = 5;\r\n\r\n        // exclude eth for the team (5% of the total contribution)\r\n        _balance = _balance.sub(_balance.mul(_teamContribution * 100 / 10000));\r\n\r\n        _buffer = _buffer.mul(_balance).div(\r\n            g.totalWeiContributed\r\n        );\r\n\r\n        //pair\r\n        BITCASHPAY_CONTRACT.approve(\r\n            address(UNISWAP_ROUTER), _buffer\r\n        );\r\n\r\n        (\r\n            uint amountToken,\r\n            uint amountETH,\r\n            uint liquidity\r\n        ) =\r\n\r\n        UNISWAP_ROUTER.addLiquidityETH{value: _balance}(\r\n            address(BITCASHPAY_CONTRACT),\r\n            _buffer,\r\n            0,\r\n            0,\r\n            address(0x0),\r\n            block.timestamp.add(2 hours)\r\n        );\r\n\r\n        g.totalReservedTokens = 0;\r\n        g.totalReferralTokens = 0;\r\n        g.totalWeiContributed = 0;\r\n\r\n        emit UniSwapResult(\r\n            amountToken, amountETH, liquidity\r\n        );\r\n    }\r\n\r\n    function requestTeamFunds(\r\n        uint256 _amount\r\n    )\r\n        external\r\n        afterUniswapTransfer\r\n    {\r\n        TEAM_ADDRESS.transfer(_amount);\r\n    }\r\n\r\n    function requestLeftOverBCPFunds(\r\n        uint256 _amount\r\n    )\r\n        external\r\n        afterUniswapTransfer\r\n    {\r\n        BITCASHPAY_CONTRACT.transfer(owner, _amount);\r\n    }\r\n\r\n    function preparePath(\r\n        address _tokenAddress\r\n    ) internal pure returns (\r\n        address[] memory _path\r\n    ) {\r\n        _path = new address[](2);\r\n        _path[0] = _tokenAddress;\r\n        _path[1] = WETH;\r\n    }\r\n\r\n    function notContract(address _addr) internal view returns (bool) {\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size == 0);\r\n    }\r\n\r\n\r\n    modifier afterReservationPhase()\r\n    {   \r\n        require(block.timestamp - startDate >= (investmentDays * 60 * 60 * 24), \"BitcashPay: Contribution period is not yet done.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == owner,\r\n            'BitcashPay: Access Denied!'\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier afterUniswapTransfer() {\r\n        require (\r\n            g.totalWeiContributed == 0,\r\n            'BitcashPay: forward liquidity first'\r\n        );\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public{\r\n        if (newOwner != address(0)) owner = newOwner;\r\n    }\r\n\r\n\r\n}"}}}