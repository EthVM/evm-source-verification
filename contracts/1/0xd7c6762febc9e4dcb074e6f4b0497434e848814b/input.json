{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":999999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ross.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Safe ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\nlibrary SafeTransferLib {\r\n    /*///////////////////////////////////////////////////////////////\r\n                           ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 68 because the calldata length is 4 + 32 * 2.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                         INTERNAL HELPER LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\r\n        assembly {\r\n            // Get how many bytes the call returned.\r\n            let returnDataSize := returndatasize()\r\n\r\n            // If the call reverted:\r\n            if iszero(callStatus) {\r\n                // Copy the revert message into memory.\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // Revert with the same message.\r\n                revert(0, returnDataSize)\r\n            }\r\n\r\n            switch returnDataSize\r\n            case 32 {\r\n                // Copy the return data into memory.\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // Set success to whether it returned true.\r\n                success := iszero(iszero(mload(0)))\r\n            }\r\n            case 0 {\r\n                // There was no return data.\r\n                success := 1\r\n            }\r\n            default {\r\n                // It returned some malformed input.\r\n                success := 0\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Claim some Ross. \r\n/// Don't be an asshole. \r\n/// Ross can read receipts and will nullify claims.\r\ncontract RossDrop {\r\n    using SafeTransferLib for address;\r\n\r\n    address ross = 0xB13784c5e23Be3a430A5db7D0b7C32f15B07aFE7;\r\n\r\n    mapping(address => bool) claimed;\r\n\r\n    function claim() public {\r\n        require(!claimed[msg.sender], \"CLAIMED\");\r\n\r\n        ross.safeTransfer(msg.sender, 5 ether);\r\n\r\n        claimed[msg.sender] = true;\r\n    }\r\n}"}}}