{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":500},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"gateway-contracts/ArbGateway.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC721.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./Outbox.sol\";\r\nimport \"./Inbox.sol\";\r\nimport \"./ArbSys.sol\";\r\nimport \"./Initializable.sol\";\r\n\r\ninterface HungryBunz is IERC721 {\r\n    function serializeAtts(uint16 tokenId) external view returns (bytes16);\r\n    function serializeStats(uint16 tokenId) external view returns (bytes16);\r\n    function writeSerializedAtts(uint16 tokenId, bytes16 newAtts) external;\r\n    function writeSerializedStats(uint16 tokenId, bytes16 newStats) external;\r\n    function setInactiveOnThisChain(uint16 tokenId) external;\r\n    function setActiveOnThisChain(uint16 tokenId, bytes memory metadata, address sender) external;\r\n    function applicationOwnerOf(uint256 tokenId) external view returns (address);\r\n}\r\n\r\ninterface INom {\r\n    function burn(address account, uint256 amount) external;\r\n    function applicationMint(address to, uint256 amount) external;\r\n}\r\n\r\ninterface IArbPartner {\r\n    function synchronizeAndRelease(uint16,address,bytes memory) external;\r\n    function receiveNom(address initiatedBy, uint256 quantity) external;\r\n}\r\n\r\ncontract ArbGateway is Ownable, Initializable {\r\n    //******************************************************\r\n    //CRITICAL CONTRACT PARAMETERS\r\n    //******************************************************\r\n    //Pausable library is simple enough to integrate into this contract\r\n    bool public paused = false;\r\n\r\n    uint8 _layer;\r\n    address _signer;\r\n    address _arbPartner;\r\n    IArbPartner _arbPartnerInterface;\r\n    IInbox _inbox; //Inbox for L1\r\n    IOutbox _outbox; //Outbox for L2\r\n    HungryBunz _hbContract; //Layer-local main contract\r\n    INom _nom; //Layer-local Nom contract\r\n    ArbSys _ArbSys = ArbSys(address(100)); //ArbSys address never changes!\r\n    \r\n    event receivedMessageFromL1(address sentBy, uint16 tokenId);\r\n    \r\n    //******************************************************\r\n    //CONTRACT CONSTRUCTOR\r\n    //******************************************************\r\n    constructor()\r\n    {\r\n        ownableInit();\r\n    }\r\n\r\n    function initGateway (\r\n        address hbContractAddress,\r\n        address nomContract,\r\n        uint8 layer\r\n    ) external initializer\r\n    {\r\n        require(owner() == address(0) || owner() == msg.sender,\r\n            \"No.\");\r\n        \r\n        ownableInit();\r\n        _layer = layer; //Set to 1 for L1, 2 for L2\r\n        _hbContract = HungryBunz(hbContractAddress);\r\n        _nom = INom(nomContract);\r\n\r\n        _signer = 0xF658480075BA1158f12524409066Ca495b54b0dD;\r\n    }\r\n    \r\n    function updateArbitrumInbox(address gatewayAddress) public onlyOwner {\r\n        _inbox = IInbox(gatewayAddress);\r\n        _outbox = IOutbox(_inbox.bridge().activeOutbox());\r\n    }\r\n    \r\n    function updateArbitrumPartner(address partnerAddress) public onlyOwner {\r\n        if (_layer == 1) {\r\n            _arbPartner = partnerAddress;\r\n        } else {\r\n            address aliasedAddress = address(uint160(partnerAddress) + uint160(0x1111000000000000000000000000000000001111));\r\n            _arbPartner = aliasedAddress;\r\n        }\r\n        _arbPartnerInterface = IArbPartner(_arbPartner);\r\n    }\r\n\r\n    //Cost of owner pausing when already paused is mild annoyance.\r\n    //Removed extra requires\r\n    function pause() onlyOwner public {\r\n        paused = true;\r\n    }\r\n    \r\n    function arbToEth(bytes memory synchronizationData) internal {\r\n        _ArbSys.sendTxToL1(\r\n            _arbPartner,\r\n            synchronizationData\r\n            );\r\n        _ArbSys.sendTxToL1{value: msg.value}(msg.sender, '');\r\n    }\r\n    \r\n    function ethToArb(bytes memory synchronizationData, uint256 maxBaseFee, uint256 maxGas, uint256 maxPriority) internal {\r\n        uint256 nftTransferFees = (maxGas * maxPriority) + maxBaseFee;\r\n        require(msg.value >= nftTransferFees + maxBaseFee, \"Insufficient funds\");\r\n\r\n        _inbox.createRetryableTicketNoRefundAliasRewrite{value: nftTransferFees}(\r\n            _arbPartner, //Destination address\r\n            0, //Call value for remote contract call. Always 0.\r\n            maxBaseFee, //Max submission cost\r\n            msg.sender, //Refund excess to sender\r\n            msg.sender, //Refund excess to sender\r\n            maxGas, //Maximum gas units\r\n            maxPriority, //Maximum gas price\r\n            synchronizationData\r\n            );\r\n    }\r\n    \r\n    //Temporarily changed from payable to view for diagnostics.\r\n    function teleportAndLock(uint16[] memory tokenIds, uint256 maxBaseFee, uint256 maxGas, uint256 maxPriority) public payable{\r\n        require(paused == false, \"Gateway paused.\");\r\n\r\n        uint256 nftTransferFees = (maxGas * maxPriority) + maxBaseFee;\r\n        require(msg.value >= (nftTransferFees * tokenIds.length),\r\n            \"Insufficient funds\");\r\n\r\n        for(uint i = 0; i < tokenIds.length; i++) {\r\n            //Use overriden ownerOf check to implicitly prevent\r\n            //exploits involving teleporting a token more than\r\n            //once, or teleporting immediately after staking.\r\n            require(msg.sender == _hbContract.applicationOwnerOf(uint256(tokenIds[i])),\r\n                \"Cannot teleport token you don't own!\");\r\n            \r\n            //We won't synchronize names between layers, since\r\n            //arbitrary length strings could be exceedingly\r\n            //expensive to synchronize across layers. This can\r\n            //create a nuisance for future owners.\r\n            bytes memory tokenProperties = abi.encodePacked(\r\n                    _hbContract.serializeAtts(tokenIds[i]),\r\n                    _hbContract.serializeStats(tokenIds[i])\r\n                );\r\n                \r\n            bytes memory returndata = abi.encodeWithSelector(\r\n                IArbPartner.synchronizeAndRelease.selector,\r\n                tokenIds[i],\r\n                msg.sender,\r\n                tokenProperties\r\n            );\r\n            \r\n            _hbContract.setInactiveOnThisChain(tokenIds[i]);\r\n            \r\n            if(_layer == 1) {\r\n                ethToArb(returndata, maxBaseFee, maxGas, maxPriority); \r\n            } else {\r\n                arbToEth(returndata);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function synchronizeAndRelease(uint16 tokenId, address initiatedBy, bytes memory properties) external {\r\n        require(paused == false, \"Gateway paused.\");\r\n        bool authorizedSender;\r\n        if (_layer == 2) {\r\n            if(msg.sender == _arbPartner) {\r\n                authorizedSender = true;\r\n            }\r\n        } else {\r\n            if(_outbox.l2ToL1Sender() == _arbPartner && msg.sender == address(_outbox)) {\r\n                authorizedSender = true;\r\n            }\r\n        }\r\n\r\n        require(authorizedSender, \"Not from authorized sender\");\r\n        emit receivedMessageFromL1(initiatedBy, tokenId);\r\n        _hbContract.setActiveOnThisChain(tokenId, properties, initiatedBy);\r\n    }\r\n    \r\n    //Temporarily changed from payable to view for diagnostics.\r\n    function sendNom(uint256 quantity, uint256 maxBaseFee, uint256 maxGas, uint256 maxPriority) public payable{\r\n        require(paused == false, \"Gateway paused.\");\r\n\r\n        uint256 nftTransferFees = (maxGas * maxPriority) + maxBaseFee;\r\n        uint256 ethToDeposit = msg.value - (nftTransferFees);\r\n        \r\n        _inbox.depositEth{value: ethToDeposit}(maxBaseFee);\r\n        _nom.burn(msg.sender, quantity);\r\n\r\n        bytes memory returndata = abi.encodeWithSelector(\r\n            IArbPartner.receiveNom.selector,\r\n            msg.sender,\r\n            quantity\r\n        );\r\n        \r\n        if(_layer == 1) {\r\n            ethToArb(returndata, maxBaseFee, maxGas, maxPriority); \r\n        } else {\r\n            arbToEth(returndata);\r\n        }\r\n    }\r\n    \r\n    function receiveNom(address initiatedBy, uint256 quantity) external {\r\n        require(paused == false, \"Gateway paused.\");\r\n        bool authorizedSender;\r\n        if (_layer == 2) {\r\n            if(msg.sender == _arbPartner) {\r\n                authorizedSender = true;\r\n            }\r\n        } else {\r\n            if(_outbox.l2ToL1Sender() == _arbPartner && msg.sender == address(_outbox)) {\r\n                authorizedSender = true;\r\n            }\r\n        }\r\n        require(authorizedSender, \"Not from authorized sender\");\r\n        _nom.applicationMint(initiatedBy, quantity);\r\n    }\r\n\r\n    //******************************************************\r\n    //OWNER ONLY RECOVERY FUNCTIONS FOR EMERGENCIES\r\n    //******************************************************\r\n    function lastDitchLock(uint16 tokenId) external onlyOwner {\r\n        _hbContract.setInactiveOnThisChain(tokenId);\r\n    }\r\n\r\n    function lastDitchRelease(uint16 tokenId, address initiatedBy, bytes memory properties) external onlyOwner {\r\n        _hbContract.setActiveOnThisChain(tokenId, properties, initiatedBy);\r\n    }\r\n}"},"gateway-contracts/ArbSys.sol":{"content":"// SPDX-License-Identifier: None\r\npragma solidity >=0.7.0;\r\n\r\n/**\r\n* @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\r\n */\r\ninterface ArbSys {\r\n    /**\r\n    * @notice Get internal version number identifying an ArbOS build\r\n    * @return version number as int\r\n     */\r\n    function arbOSVersion() external pure returns (uint);\r\n\r\n    /**\r\n    * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\r\n    * @return block number as int\r\n     */ \r\n    function arbBlockNumber() external view returns (uint);\r\n\r\n    /** \r\n    * @notice Send given amount of Eth to dest from sender.\r\n    * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\r\n    * @param destination recipient address on L1\r\n    * @return unique identifier for this L2-to-L1 transaction.\r\n    */\r\n    function withdrawEth(address destination) external payable returns(uint);\r\n\r\n    /** \r\n    * @notice Send a transaction to L1\r\n    * @param destination recipient address on L1 \r\n    * @param calldataForL1 (optional) calldata for L1 contract call\r\n    * @return a unique identifier for this L2-to-L1 transaction.\r\n    */\r\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns(uint);\r\n\r\n\r\n    /** \r\n    * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\r\n    * @param account target account\r\n    * @return the number of transactions issued by the given external account or the account sequence number of the given contract\r\n    */\r\n    function getTransactionCount(address account) external view returns(uint256);\r\n\r\n    /**  \r\n    * @notice get the value of target L2 storage slot \r\n    * This function is only callable from address 0 to prevent contracts from being able to call it\r\n    * @param account target account\r\n    * @param index target index of storage slot \r\n    * @return stotage value for the given account at the given index\r\n    */\r\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\r\n\r\n    /**\r\n    * @notice check if current call is coming from l1\r\n    * @return true if the caller of this was called directly from L1\r\n    */\r\n    function isTopLevelCall() external view returns (bool);\r\n\r\n    event EthWithdrawal(address indexed destAddr, uint amount);\r\n\r\n    event L2ToL1Transaction(address caller, address indexed destination, uint indexed uniqueId,\r\n                            uint indexed batchNumber, uint indexInBatch,\r\n                            uint arbBlockNum, uint ethBlockNum, uint timestamp,\r\n                            uint callvalue, bytes data);\r\n}"},"gateway-contracts/IERC721.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n// File: gateway-contracts/IERC721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n"},"gateway-contracts/Inbox.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\r\npragma solidity >=0.7.0;\r\n\r\n\r\ninterface IInbox {\r\n    \r\n    \r\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\r\n\r\n    function sendUnsignedTransaction(\r\n        uint256 maxGas,\r\n        uint256 gasPriceBid,\r\n        uint256 nonce,\r\n        address destAddr,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (uint256);\r\n\r\n    function sendContractTransaction(\r\n        uint256 maxGas,\r\n        uint256 gasPriceBid,\r\n        address destAddr,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (uint256);\r\n\r\n   function sendL1FundedUnsignedTransaction(\r\n        uint256 maxGas,\r\n        uint256 gasPriceBid,\r\n        uint256 nonce,\r\n        address destAddr,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    function sendL1FundedContractTransaction(\r\n        uint256 maxGas,\r\n        uint256 gasPriceBid,\r\n        address destAddr,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    function createRetryableTicket(\r\n        address destAddr,\r\n        uint256 arbTxCallValue,\r\n        uint256 maxSubmissionCost,\r\n        address submissionRefundAddress,\r\n        address valueRefundAddress,\r\n        uint256 maxGas,\r\n        uint256 gasPriceBid,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n    \r\n    function createRetryableTicketNoRefundAliasRewrite(\r\n        address destAddr,\r\n        uint256 l2CallValue,\r\n        uint256 maxSubmissionCost,\r\n        address excessFeeRefundAddress,\r\n        address callValueRefundAddress,\r\n        uint256 maxGas,\r\n        uint256 gasPriceBid,\r\n        bytes calldata data\r\n    ) external payable returns (uint256);\r\n\r\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\r\n\r\n    function bridge() external view returns (IBridge);\r\n}\r\n\r\n\r\ninterface IBridge {\r\n    event MessageDelivered(\r\n        uint256 indexed messageIndex,\r\n        bytes32 indexed beforeInboxAcc,\r\n        address inbox,\r\n        uint8 kind,\r\n        address sender,\r\n        bytes32 messageDataHash\r\n    );\r\n\r\n    function deliverMessageToInbox(\r\n        uint8 kind,\r\n        address sender,\r\n        bytes32 messageDataHash\r\n    ) external payable returns (uint256);\r\n\r\n    function executeCall(\r\n        address destAddr,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (bool success, bytes memory returnData);\r\n\r\n    // These are only callable by the admin\r\n    function setInbox(address inbox, bool enabled) external;\r\n\r\n    function setOutbox(address inbox, bool enabled) external;\r\n\r\n    // View functions\r\n\r\n    function activeOutbox() external view returns (address);\r\n\r\n    function allowedInboxes(address inbox) external view returns (bool);\r\n\r\n    function allowedOutboxes(address outbox) external view returns (bool);\r\n\r\n    function inboxAccs(uint256 index) external view returns (bytes32);\r\n\r\n    function messageCount() external view returns (uint256);\r\n}\r\n\r\ninterface IMessageProvider {\r\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\r\n\r\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\r\n}\r\n"},"gateway-contracts/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n"},"gateway-contracts/Outbox.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\r\n\r\n/*\r\n * Copyright 2021, Offchain Labs, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface IOutbox {\r\n    event OutboxEntryCreated(\r\n        uint256 indexed batchNum,\r\n        uint256 outboxIndex,\r\n        bytes32 outputRoot,\r\n        uint256 numInBatch\r\n    );\r\n\r\n    function l2ToL1Sender() external view returns (address);\r\n\r\n    function l2ToL1Block() external view returns (uint256);\r\n\r\n    function l2ToL1EthBlock() external view returns (uint256);\r\n\r\n    function l2ToL1Timestamp() external view returns (uint256);\r\n\r\n    function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths)\r\n        external;\r\n}"},"gateway-contracts/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initialization\r\n     */\r\n    function ownableInit() internal {\r\n        _setOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Caller is not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}"}}}