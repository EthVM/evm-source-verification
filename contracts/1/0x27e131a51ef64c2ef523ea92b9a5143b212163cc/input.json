{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"RewardChangeSpellMainnet.sol":{"content":"pragma solidity ^0.5.12;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function mint(address account, uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ninterface IAdapter {\r\n    function calc(\r\n        address gem,\r\n        uint256 acc,\r\n        uint256 factor\r\n    ) external view returns (uint256);\r\n}\r\n\r\ninterface IGemForRewardChecker {\r\n    function check(address gem) external view returns (bool);\r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n}\r\n\r\n\r\ninterface UniswapV2PairLike {\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n}\r\n\r\n/**\r\n * @title Adapter class needed to calculate USD value of specific amount of LP tokens\r\n * this contract assumes that USD value of each part of LP pair is eq 1 USD\r\n */\r\ncontract UniswapAdapterForStables is IAdapter {\r\n    using SafeMath for uint256;\r\n\r\n    struct TokenPair {\r\n        address t0;\r\n        address t1;\r\n        uint256 r0;\r\n        uint256 r1;\r\n        uint256 usdPrec;\r\n    }\r\n\r\n    function calc(\r\n        address gem,\r\n        uint256 value,\r\n        uint256 factor\r\n    ) external view returns (uint256) {\r\n        (uint112 _reserve0, uint112 _reserve1, ) = UniswapV2PairLike(gem).getReserves();\r\n\r\n        TokenPair memory tokenPair;\r\n        tokenPair.usdPrec = 10**6;\r\n\r\n        tokenPair.t0 = UniswapV2PairLike(gem).token0();\r\n        tokenPair.t1 = UniswapV2PairLike(gem).token1();\r\n\r\n        tokenPair.r0 = uint256(_reserve0).mul(tokenPair.usdPrec).div(\r\n            uint256(10)**IERC20(tokenPair.t0).decimals()\r\n        );\r\n        tokenPair.r1 = uint256(_reserve1).mul(tokenPair.usdPrec).div(\r\n            uint256(10)**IERC20(tokenPair.t1).decimals()\r\n        );\r\n\r\n        uint256 totalValue = tokenPair.r0.min(tokenPair.r1).mul(2); //total value in uni's reserves for stables only\r\n\r\n        uint256 supply = UniswapV2PairLike(gem).totalSupply();\r\n\r\n        return value.mul(totalValue).mul(factor).mul(1e18).div(supply.mul(tokenPair.usdPrec));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Adapter class needed to calculate USD value of specific amount of LP tokens\r\n * this contract assumes that USD value of only one part of LP pair is eq 1 USD\r\n */\r\ncontract UniswapAdapterWithOneStable is IAdapter {\r\n    using SafeMath for uint256;\r\n\r\n    struct LocalVars {\r\n        address t0;\r\n        address t1;\r\n        uint256 totalValue;\r\n        uint256 supply;\r\n        uint256 usdPrec;\r\n    }\r\n\r\n    address public deployer;\r\n    address public buck;\r\n\r\n    constructor() public {\r\n        deployer = msg.sender;\r\n    }\r\n\r\n    function setup(address _buck) public {\r\n        require(deployer == msg.sender);\r\n        buck = _buck;\r\n        deployer = address(0);\r\n    }\r\n\r\n    function calc(\r\n        address gem,\r\n        uint256 value,\r\n        uint256 factor\r\n    ) external view returns (uint256) {\r\n        (uint112 _reserve0, uint112 _reserve1, ) = UniswapV2PairLike(gem).getReserves();\r\n\r\n        LocalVars memory loc;\r\n        loc.t0 = UniswapV2PairLike(gem).token0();\r\n        loc.t1 = UniswapV2PairLike(gem).token1();\r\n        loc.usdPrec = 10**6;\r\n\r\n        if (buck == loc.t0) {\r\n            loc.totalValue = uint256(_reserve0).mul(loc.usdPrec).div(\r\n                uint256(10)**IERC20(loc.t0).decimals()\r\n            );\r\n        } else if (buck == loc.t1) {\r\n            loc.totalValue = uint256(_reserve1).mul(loc.usdPrec).div(\r\n                uint256(10)**IERC20(loc.t1).decimals()\r\n            );\r\n        } else {\r\n            require(false, \"gem w/o buck\");\r\n        }\r\n\r\n        loc.supply = UniswapV2PairLike(gem).totalSupply();\r\n\r\n        return\r\n            value.mul(loc.totalValue).mul(2).mul(factor).mul(1e18).div(\r\n                loc.supply.mul(loc.usdPrec)\r\n            );\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract PauseLike {\r\n    function delay() public returns (uint);\r\n    function exec(address, bytes32, bytes memory, uint256) public;\r\n    function plot(address, bytes32, bytes memory, uint256) public;\r\n}\r\n\r\ncontract RewarderLike {\r\n\r\n    function registerPairDesc(\r\n        address gem,\r\n        address adapter,\r\n        uint256 factor,\r\n        bytes32 name\r\n    ) external;\r\n\r\n    function gov() external returns (address);\r\n}\r\n\r\n\r\n\r\ncontract RewardChangeDeployer {\r\n\r\n    struct Item {\r\n        bytes32 ilk;\r\n        address gem;\r\n        address adapter;\r\n    }\r\n\r\n    function applyItems(RewarderLike rewarder, uint256 factor, Item[] memory items) internal {\r\n        require(factor > 0, \"zero-factor\");\r\n\r\n        for (uint256 i=0; i<items.length; i++) {\r\n            rewarder.registerPairDesc(items[i].gem, items[i].adapter, factor, items[i].ilk);\r\n        }\r\n    }\r\n\r\n    function register(bytes32 ilk, address gem, address buck, RewarderLike rewarder) internal returns (Item memory) {\r\n\r\n        require(UniswapV2PairLike(gem).token0() == buck || UniswapV2PairLike(gem).token1() == buck,\r\n                \"no-buck-in-uni\");\r\n\r\n        address gov = rewarder.gov();\r\n        require(UniswapV2PairLike(gem).token0() == gov || UniswapV2PairLike(gem).token1() == gov,\r\n                \"no-fl-in-uni\");\r\n\r\n\r\n        UniswapAdapterWithOneStable adapter = new UniswapAdapterWithOneStable();\r\n        adapter.setup(buck);\r\n        return Item(ilk, gem, address(adapter));\r\n    }\r\n}\r\n\r\n// 0x464c5f5553444300000000000000000000000000000000000000000000000000 FL_USDC\r\n// 0x464c5f5553445400000000000000000000000000000000000000000000000000 FL_USDT\r\n// 0x464c5f4441490000000000000000000000000000000000000000000000000000 FL_DAI\r\n// 0x464c5f5553444e00000000000000000000000000000000000000000000000000 FL_USDN\r\n\r\ncontract RewardChangeDeployerRinkeby is RewardChangeDeployer {\r\n    function deploy(uint256 factor) public {\r\n\r\n        RewarderLike rewarder = RewarderLike(0xB78b9ddC192484274d842A6d88c6056362f7B50E);\r\n\r\n        Item[] memory items = new Item[](4);\r\n        uint256 idx = 0;\r\n\r\n        items[idx++] = register(0x464c5f5553444300000000000000000000000000000000000000000000000000,\r\n                                 0x27B93998F0a570f0E4e14Ab5D6311128190653Fd,\r\n                                 0x4DBCdF9B62e891a7cec5A2568C3F4FAF9E8Abe2b,\r\n                                 rewarder);\r\n\r\n        items[idx++] = register(0x464c5f5553445400000000000000000000000000000000000000000000000000,\r\n                                 0x5E959712B64485727AB30Ed311043c31038e7082,\r\n                                 0xD9BA894E0097f8cC2BBc9D24D308b98e36dc6D02,\r\n                                 rewarder);\r\n\r\n        items[idx++] = register(0x464c5f4441490000000000000000000000000000000000000000000000000000,\r\n                                 0xb6f29a055F08fEd501CD9aaf88588766FC47e939,\r\n                                 0x97833b01a73733065684A851Fd1E91D7951b5fD8,\r\n                                 rewarder);\r\n\r\n        items[idx++] = register(0x464c5f5553444e00000000000000000000000000000000000000000000000000,\r\n                                 0x9cDEd043725A031F047C16c8fA85D1B2Ed289a6f,\r\n                                 0x033C5b4A8E1b8A2f3b5A7451a9defD561028a8C5,\r\n                                 rewarder);\r\n\r\n        applyItems(rewarder, factor, items);\r\n    }\r\n}\r\n\r\n\r\ncontract RewardChangeDeployerKovan is RewardChangeDeployer {\r\n    function deploy(uint256 factor) public {\r\n\r\n        RewarderLike rewarder = RewarderLike(0x31902B4010A078712e3C1e470C33545Ba4DC5E52);\r\n\r\n        Item[] memory items = new Item[](4);\r\n        uint256 idx = 0;\r\n\r\n        //USDC\r\n        items[idx++] = register(0x464c5f5553444300000000000000000000000000000000000000000000000000,\r\n                                0xf0e4366B5943c384c48352DD9caaA6fcd96Af1e0,\r\n                                0xe22da380ee6B445bb8273C81944ADEB6E8450422,\r\n                                rewarder);\r\n\r\n        //USDT\r\n        items[idx++] = register(0x464c5f5553445400000000000000000000000000000000000000000000000000,\r\n                                 0x1AE497d93b05C3F5E19C49A81019c20c103A0Ed1,\r\n                                 0x13512979ADE267AB5100878E2e0f485B568328a4,\r\n                                 rewarder);\r\n\r\n        //DAI\r\n        items[idx++] = register(0x464c5f4441490000000000000000000000000000000000000000000000000000,\r\n                                 0x077327CaB4BDFfbf01eC0281074dabF29CB9FD70,\r\n                                 0xFf795577d9AC8bD7D90Ee22b6C1703490b6512FD,\r\n                                 rewarder);\r\n\r\n        //USDN\r\n        items[idx++] = register(0x464c5f5553444e00000000000000000000000000000000000000000000000000,\r\n                                 0x43Bbb1b23C3f78B4533e96aEaa2b2B20A4EEE240,\r\n                                 0x5f99471D242d04C42a990A33e8233f5B48F89C43,\r\n                                 rewarder);\r\n\r\n        applyItems(rewarder, factor, items);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract RewardChangeDeployerMainnet is RewardChangeDeployer {\r\n    function deploy(uint256 factor) public {\r\n\r\n        RewarderLike rewarder = RewarderLike(0x975Aa6606f1e5179814BAEf22811441C5060e815);\r\n\r\n        Item[] memory items = new Item[](4);\r\n        uint256 idx = 0;\r\n\r\n        //USDC\r\n        items[idx++] = register(0x464c5f5553444300000000000000000000000000000000000000000000000000,\r\n                                0xeC314D972FC771EAe56EC5063A5282A554FD54a2,\r\n                                0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,\r\n                                rewarder);\r\n\r\n        //USDT\r\n        items[idx++] = register(0x464c5f5553445400000000000000000000000000000000000000000000000000,\r\n                                 0x6E35996aE06c45E9De2736C44Df9c3f1aAb781af,\r\n                                 0xdAC17F958D2ee523a2206206994597C13D831ec7,\r\n                                 rewarder);\r\n\r\n        //DAI\r\n        items[idx++] = register(0x464c5f4441490000000000000000000000000000000000000000000000000000,\r\n                                 0xc869935EFE9264874BaF7940449925318f193322,\r\n                                 0x6B175474E89094C44Da98b954EedeAC495271d0F,\r\n                                 rewarder);\r\n\r\n        //USDN\r\n        items[idx++] = register(0x464c5f5553444e00000000000000000000000000000000000000000000000000,\r\n                                 0x3C63d86453f6491948C2c33065C441a507f2F32C,\r\n                                 0x674C6Ad92Fd080e4004b2312b45f796a192D27a0,\r\n                                 rewarder);\r\n\r\n        applyItems(rewarder, factor, items);\r\n    }\r\n}\r\n\r\ncontract RewardChangeSpell {\r\n    bool      public done;\r\n    address   public pause;\r\n\r\n    address   public action;\r\n    bytes32   public tag;\r\n    uint256   public eta;\r\n    bytes     public sig;\r\n\r\n    function setup(address deployer, uint256 factor) internal {\r\n        require(factor > 0, \"zero-factor\");\r\n        sig = abi.encodeWithSignature(\"deploy(uint256)\", factor);\r\n        bytes32 _tag; assembly { _tag := extcodehash(deployer) }\r\n        action = deployer;\r\n        tag = _tag;\r\n    }\r\n\r\n    function schedule() external {\r\n        require(eta == 0, \"spell-already-scheduled\");\r\n        eta = now + PauseLike(pause).delay();\r\n        PauseLike(pause).plot(action, tag, sig, eta);\r\n    }\r\n\r\n    function cast() public {\r\n        require(!done, \"spell-already-cast\");\r\n        done = true;\r\n        PauseLike(pause).exec(action, tag, sig, eta);\r\n    }\r\n}\r\n\r\n\r\ncontract RewardChangeSpellRinkeby is RewardChangeSpell {\r\n    constructor(uint256 factor) public {\r\n        pause = 0xF4F8eC149D428B899a02b22ad972125Cf1199FF8;\r\n        setup(address(new RewardChangeDeployerRinkeby()), factor);\r\n    }\r\n}\r\n\r\ncontract RewardChangeSpellMainnet is RewardChangeSpell {\r\n    constructor(uint256 factor) public {\r\n        pause = 0x146921eF7A94C50b96cb53Eb9C2CA4EB25D4Bfa8;\r\n        setup(address(new RewardChangeDeployerMainnet()), factor);\r\n    }\r\n}\r\n\r\n\r\ncontract RewardChangeSpellKovan is RewardChangeSpell {\r\n    constructor(uint256 factor) public {\r\n        pause = 0xF218b6B4CCFa7A9fEa768DC5EdA06D5C26fa2D92;\r\n        setup(address(new RewardChangeDeployerKovan()), factor);\r\n    }\r\n}"}}}