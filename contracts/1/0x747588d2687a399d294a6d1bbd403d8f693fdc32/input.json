{"language":"Solidity","settings":{"evmVersion":"london","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"TestContract/ERC721.sol":{"content":"pragma solidity <=8.7.0;\npragma experimental ABIEncoderV2;\n//SPDX-License-Identifier: MIT\n\nabstract contract Context {\n\tfunction _msgSender() internal view virtual returns (address payable) {\n\t\treturn payable(msg.sender);\n\t}\n\n\tfunction _msgData() internal view virtual returns (bytes memory) {\n\t\tthis;\n\t\treturn msg.data;\n\t}\n}\n\nlibrary Base64 {\n\tbytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n\tfunction encode(bytes memory data) internal pure returns (string memory) {\n\t\tuint256 len = data.length;\n\t\tif (len == 0) return \"\";\n\n\t\tuint256 encodedLen = 4 * ((len + 2) / 3);\n\t\tbytes memory result = new bytes(encodedLen + 32);\n\t\tbytes memory table = TABLE;\n\n\t\tassembly {\n\t\t\tlet tablePtr := add(table, 1)\n\t\t\tlet resultPtr := add(result, 32)\n\n\t\t\tfor {\n\t\t\t\tlet i := 0\n\t\t\t} lt(i, len) {\n\n\t\t\t} {\n\t\t\t\ti := add(i, 3)\n\t\t\t\tlet input := and(mload(add(data, i)), 0xffffff)\n\n\t\t\t\tlet out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n\t\t\t\tout := shl(8, out)\n\t\t\t\tout := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n\t\t\t\tout := shl(8, out)\n\t\t\t\tout := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n\t\t\t\tout := shl(8, out)\n\t\t\t\tout := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n\t\t\t\tout := shl(224, out)\n\n\t\t\t\tmstore(resultPtr, out)\n\n\t\t\t\tresultPtr := add(resultPtr, 4)\n\t\t\t}\n\n\t\t\tswitch mod(len, 3)\n\t\t\tcase 1 {\n\t\t\t\tmstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n\t\t\t}\n\t\t\tcase 2 {\n\t\t\t\tmstore(sub(resultPtr, 1), shl(248, 0x3d))\n\t\t\t}\n\n\t\t\tmstore(result, encodedLen)\n\t\t}\n\n\t\treturn string(result);\n\t}\n}\n\nabstract contract Ownable is Context {\n\taddress payable private _owner;\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\tconstructor () {\n\t\taddress payable msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\tfunction owner() public view virtual returns (address payable) {\n\t\treturn _owner;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\n/*\tfunction renounceOwnership() public virtual onlyOwner {\n\t\temit OwnershipTransferred(_owner, address(0));\n\t\t_owner = address(0);\n\t}\n\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}*/\n}\n\nabstract contract ReentrancyGuard {\n\tuint256 private constant _NOT_ENTERED = 1;\n\tuint256 private constant _ENTERED = 2;\n\tuint256 private _status;\n\n\tconstructor() {\n\t\t_status = _NOT_ENTERED;\n\t}\n\n\tmodifier nonReentrant() {\n\t\trequire(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\t\t_status = _ENTERED;\n\t\t_;\n\t\t_status = _NOT_ENTERED;\n\t}\n}\n\ninterface IERC721Receiver {\n\tfunction onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\nlibrary Strings {\n\tfunction toString(uint256 value) internal pure returns (string memory) {\n\t\tunchecked {\n\t\t\tif (value == 0) {\n\t\t\t\treturn \"0\";\n\t\t\t}\n\t\t\tuint256 temp = value;\n\t\t\tuint256 digits;\n\t\t\twhile (temp != 0) {\n\t\t\t\tdigits++;\n\t\t\t\ttemp /= 10;\n\t\t\t}\n\t\t\tbytes memory buffer = new bytes(digits);\n\t\t\tuint256 index = digits - 1;\n\t\t\ttemp = value;\n\t\t\twhile (temp != 0) {\n\t\t\t\tbuffer[index--] = bytes1(uint8(48 + temp % 10));\n\t\t\t\ttemp /= 10;\n\t\t\t}\n\t\t\treturn string(buffer);\n\t\t}\n\t}\n}\n\nlibrary EnumerableMap {\n\tstruct MapEntry {\n\t\tbytes32 _key;\n\t\tbytes32 _value;\n\t}\n\n\tstruct Map {\n\t\tMapEntry[] _entries;\n\t\tmapping (bytes32 => uint256) _indexes;\n\t}\n\n\tfunction _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n\t\tuint256 keyIndex = map._indexes[key];\n\t\tif (keyIndex == 0) {\n\t\t\tmap._entries.push(MapEntry({ _key: key, _value: value }));\n\t\t\tmap._indexes[key] = map._entries.length;\n\t\t\treturn true;\n\t\t} else {\n\t\t\tmap._entries[keyIndex - 1]._value = value;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction _remove(Map storage map, bytes32 key) private returns (bool) {\n\t\tuint256 keyIndex = map._indexes[key];\n\t\tif (keyIndex != 0) {\n\t\t\tuint256 toDeleteIndex = keyIndex - 1;\n\t\t\tuint256 lastIndex = map._entries.length - 1;\n\t\t\tMapEntry storage lastEntry = map._entries[lastIndex];\n\t\t\tmap._entries[toDeleteIndex] = lastEntry;\n\t\t\tmap._indexes[lastEntry._key] = toDeleteIndex + 1;\n\t\t\tmap._entries.pop();\n\t\t\tdelete map._indexes[key];\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction _contains(Map storage map, bytes32 key) private view returns (bool) {\n\t\treturn map._indexes[key] != 0;\n\t}\n\n\tfunction _length(Map storage map) private view returns (uint256) {\n\t\treturn map._entries.length;\n\t}\n\n\tfunction _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n\t\trequire(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n\t\tMapEntry storage entry = map._entries[index];\n\t\treturn (entry._key, entry._value);\n\t}\n\n\tfunction _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n\t\tuint256 keyIndex = map._indexes[key];\n\t\tif (keyIndex == 0) return (false, 0);\n\t\treturn (true, map._entries[keyIndex - 1]._value);\n\t}\n\n\tfunction _get(Map storage map, bytes32 key) private view returns (bytes32) {\n\t\tuint256 keyIndex = map._indexes[key];\n\t\trequire(keyIndex != 0, \"EnumerableMap: nonexistent key\");\n\t\treturn map._entries[keyIndex - 1]._value;\n\t}\n\n\tfunction _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n\t\tuint256 keyIndex = map._indexes[key];\n\t\trequire(keyIndex != 0, errorMessage);\n\t\treturn map._entries[keyIndex - 1]._value;\n\t}\n\n\tstruct UintToAddressMap {\n\t\tMap _inner;\n\t}\n\n\tfunction set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n\t\treturn _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n\t}\n\n\tfunction remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n\t\treturn _remove(map._inner, bytes32(key));\n\t}\n\n\tfunction contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n\t\treturn _contains(map._inner, bytes32(key));\n\t}\n\n\tfunction length(UintToAddressMap storage map) internal view returns (uint256) {\n\t\treturn _length(map._inner);\n\t}\n\n\tfunction at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n\t\t(bytes32 key, bytes32 value) = _at(map._inner, index);\n\t\treturn (uint256(key), address(uint160(uint256(value))));\n\t}\n\n\tfunction tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n\t\t(bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n\t\treturn (success, address(uint160(uint256(value))));\n\t}\n\n\tfunction get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n\t\treturn address(uint160(uint256(_get(map._inner, bytes32(key)))));\n\t}\n\n\tfunction get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n\t\treturn address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n\t}\n}\n\nlibrary EnumerableSet {\n\tstruct Set {\n\t\tbytes32[] _values;\n\t\tmapping (bytes32 => uint256) _indexes;\n\t}\n\n\tfunction _add(Set storage set, bytes32 value) private returns (bool) {\n\t\tif (!_contains(set, value)) {\n\t\t\tset._values.push(value);\n\t\t\tset._indexes[value] = set._values.length;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction _remove(Set storage set, bytes32 value) private returns (bool) {\n\t\tuint256 valueIndex = set._indexes[value];\n\t\tif (valueIndex != 0) {\n\t\t\tuint256 toDeleteIndex = valueIndex - 1;\n\t\t\tuint256 lastIndex = set._values.length - 1;\n\t\t\tbytes32 lastvalue = set._values[lastIndex];\n\t\t\tset._values[toDeleteIndex] = lastvalue;\n\t\t\tset._indexes[lastvalue] = toDeleteIndex + 1;\n\t\t\tset._values.pop();\n\t\t\tdelete set._indexes[value];\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction _contains(Set storage set, bytes32 value) private view returns (bool) {\n\t\treturn set._indexes[value] != 0;\n\t}\n\n\tfunction _length(Set storage set) private view returns (uint256) {\n\t\treturn set._values.length;\n\t}\n\n\tfunction _at(Set storage set, uint256 index) private view returns (bytes32) {\n\t\trequire(set._values.length > index, \"EnumerableSet: index out of bounds\");\n\t\treturn set._values[index];\n\t}\n\n\tstruct Bytes32Set {\n\t\tSet _inner;\n\t}\n\n\tfunction add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n\t\treturn _add(set._inner, value);\n\t}\n\n\tfunction remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n\t\treturn _remove(set._inner, value);\n\t}\n\n\tfunction contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n\t\treturn _contains(set._inner, value);\n\t}\n\n\tfunction length(Bytes32Set storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\tfunction at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n\t\treturn _at(set._inner, index);\n\t}\n\n\tstruct AddressSet {\n\t\tSet _inner;\n\t}\n\n\tfunction add(AddressSet storage set, address value) internal returns (bool) {\n\t\treturn _add(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\tfunction remove(AddressSet storage set, address value) internal returns (bool) {\n\t\treturn _remove(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\tfunction contains(AddressSet storage set, address value) internal view returns (bool) {\n\t\treturn _contains(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\tfunction length(AddressSet storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\tfunction at(AddressSet storage set, uint256 index) internal view returns (address) {\n\t\treturn address(uint160(uint256(_at(set._inner, index))));\n\t}\n\n\tstruct UintSet {\n\t\tSet _inner;\n\t}\n\n\tfunction add(UintSet storage set, uint256 value) internal returns (bool) {\n\t\treturn _add(set._inner, bytes32(value));\n\t}\n\n\tfunction remove(UintSet storage set, uint256 value) internal returns (bool) {\n\t\treturn _remove(set._inner, bytes32(value));\n\t}\n\n\tfunction contains(UintSet storage set, uint256 value) internal view returns (bool) {\n\t\treturn _contains(set._inner, bytes32(value));\n\t}\n\n\tfunction length(UintSet storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\tfunction at(UintSet storage set, uint256 index) internal view returns (uint256) {\n\t\treturn uint256(_at(set._inner, index));\n\t}\n}\n\nlibrary Address {\n\n\tfunction isContract(address account) internal view returns (bool) {\n\t\tuint256 size;\n\t\tassembly { size := extcodesize(account) }\n\t\treturn size > 0;\n\t}\n\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\n\t\t(bool success, ) = recipient.call{ value: amount }(\"\");\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\n\t}\n\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\n\t}\n\n\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\n\t}\n\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\t}\n\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\n\t\trequire(isContract(target), \"Address: call to non-contract\");\n\t\t(bool success, bytes memory returndata) = target.call{ value: value }(data);\n\t\treturn _verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n\t\treturn functionStaticCall(target, data, \"Address: low-level static call failed\");\n\t}\n\n\tfunction functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n\t\trequire(isContract(target), \"Address: static call to non-contract\");\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\n\t\treturn _verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n\t}\n\n\tfunction functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n\t\trequire(isContract(target), \"Address: delegate call to non-contract\");\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\n\t\treturn _verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\tfunction _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n\t\tif (success) {\n\t\t\treturn returndata;\n\t\t} else {\n\t\t\tif (returndata.length > 0) {\n\t\t\t\tassembly {\n\t\t\t\t\tlet returndata_size := mload(returndata)\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trevert(errorMessage);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlibrary SafeMath {\n\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tuint256 c = a + b;\n\t\tif (c < a) return (false, 0);\n\t\treturn (true, c);\n\t}\n\n\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tif (b > a) return (false, 0);\n\t\treturn (true, a - b);\n\t}\n\n\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tif (a == 0) return (true, 0);\n\t\tuint256 c = a * b;\n\t\tif (c / a != b) return (false, 0);\n\t\treturn (true, c);\n\t}\n\n\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tif (b == 0) return (false, 0);\n\t\treturn (true, a / b);\n\t}\n\n\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n\t\tif (b == 0) return (false, 0);\n\t\treturn (true, a % b);\n\t}\n\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\t\treturn c;\n\t}\n\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b <= a, \"SafeMath: subtraction overflow\");\n\t\treturn a - b;\n\t}\n\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tif (a == 0) return 0;\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\t\treturn c;\n\t}\n\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b > 0, \"SafeMath: division by zero\");\n\t\treturn a / b;\n\t}\n\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b > 0, \"SafeMath: modulo by zero\");\n\t\treturn a % b;\n\t}\n\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\treturn a - b;\n\t}\n\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b > 0, errorMessage);\n\t\treturn a / b;\n\t}\n\n\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b > 0, errorMessage);\n\t\treturn a % b;\n\t}\n}\n\ninterface IERC165 {\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\nabstract contract ERC165 is IERC165 {\n\tbytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\tmapping(bytes4 => bool) private _supportedInterfaces;\n\n\tconstructor() {\n\t\t_registerInterface(_INTERFACE_ID_ERC165);\n\t}\n\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\t\treturn _supportedInterfaces[interfaceId];\n\t}\n\n\tfunction _registerInterface(bytes4 interfaceId) internal virtual {\n\t\trequire(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n\t\t_supportedInterfaces[interfaceId] = true;\n\t}\n}\n\ninterface IERC721 is IERC165 {\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\n\tfunction approve(address to, uint256 tokenId) external;\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\n\tfunction setApprovalForAll(address operator, bool _approved) external;\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\ninterface IERC721Enumerable is IERC721 {\n\tfunction totalSupply() external view returns (uint256);\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\tfunction tokenByIndex(uint256 index) external view returns (uint256);\n}\n\ninterface IERC721Metadata is IERC721 {\n\tfunction name() external view returns (string memory);\n\tfunction symbol() external view returns (string memory);\n\tfunction tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n\tusing SafeMath for uint256;\n\tusing Address for address;\n\tusing EnumerableSet for EnumerableSet.UintSet;\n\tusing EnumerableMap for EnumerableMap.UintToAddressMap;\n\tusing Strings for uint256;\n\n\tbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\tmapping (address => EnumerableSet.UintSet) private _holderTokens;\n\tEnumerableMap.UintToAddressMap private _tokenOwners;\n\tmapping (uint256 => address) private _tokenApprovals;\n\tmapping (address => mapping (address => bool)) private _operatorApprovals;\n\tstring private _name;\n\tstring private _symbol;\n\tmapping (uint256 => string) private _tokenURIs;\n\tstring private _baseURI;\n\tbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\tbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\tbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\tconstructor (string memory name_, string memory symbol_) {\n\t\t_name = name_;\n\t\t_symbol = symbol_;\n\n\t\t_registerInterface(_INTERFACE_ID_ERC721);\n\t\t_registerInterface(_INTERFACE_ID_ERC721_METADATA);\n\t\t_registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n\t}\n\n\tfunction balanceOf(address owner) public view virtual override returns (uint256) {\n\t\trequire(owner != address(0), \"ERC721: balance query for the zero address\");\n\t\treturn _holderTokens[owner].length();\n\t}\n\n\tfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\n\t\treturn _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n\t}\n\n\tfunction name() public view virtual override returns (string memory) {\n\t\treturn _name;\n\t}\n\n\tfunction symbol() public view virtual override returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\tfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n\t\trequire(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\t\tstring memory _tokenURI = _tokenURIs[tokenId];\n\t\tstring memory base = baseURI();\n\t\tif (bytes(base).length == 0) {\n\t\t\treturn _tokenURI;\n\t\t}\n\t\tif (bytes(_tokenURI).length > 0) {\n\t\t\treturn string(abi.encodePacked(base, _tokenURI));\n\t\t}\n\t\treturn string(abi.encodePacked(base, tokenId.toString(), string(\".json\")));\n\t}\n\n\tfunction baseURI() public view virtual returns (string memory) {\n\t\treturn _baseURI;\n\t}\n\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n\t\treturn _holderTokens[owner].at(index);\n\t}\n\n\tfunction totalSupply() public view virtual override returns (uint256) {\n\t\treturn _tokenOwners.length();\n\t}\n\n\tfunction tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n\t\t(uint256 tokenId, ) = _tokenOwners.at(index);\n\t\treturn tokenId;\n\t}\n\n\tfunction approve(address to, uint256 tokenId) public virtual override {\n\t\taddress owner = ERC721.ownerOf(tokenId);\n\t\trequire(to != owner, \"ERC721: approval to current owner\");\n\t\trequire(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n\t\t\t\"ERC721: approve caller is not owner nor approved for all\"\n\t\t);\n\t\t_approve(to, tokenId);\n\t}\n\n\tfunction getApproved(uint256 tokenId) public view virtual override returns (address) {\n\t\trequire(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\t\treturn _tokenApprovals[tokenId];\n\t}\n\n\tfunction setApprovalForAll(address operator, bool approved) public virtual override {\n\t\trequire(operator != _msgSender(), \"ERC721: approve to caller\");\n\t\t_operatorApprovals[_msgSender()][operator] = approved;\n\t\temit ApprovalForAll(_msgSender(), operator, approved);\n\t}\n\n\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n\t\treturn _operatorApprovals[owner][operator];\n\t}\n\n\tfunction transferFrom(address from, address to, uint256 tokenId) public virtual override {\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\t\t_transfer(from, to, tokenId);\n\t}\n\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\n\t}\n\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\t\t_safeTransfer(from, to, tokenId, _data);\n\t}\n\n\tfunction _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n\t\t_transfer(from, to, tokenId);\n\t\trequire(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n\t}\n\n\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\n\t\treturn _tokenOwners.contains(tokenId);\n\t}\n\n\tfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n\t\trequire(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n\t\taddress owner = ERC721.ownerOf(tokenId);\n\t\treturn (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\n\t}\n\n\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\n\t\t_safeMint(to, tokenId, \"\");\n\t}\n\n\tfunction _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n\t\t_mint(to, tokenId);\n\t\trequire(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n\t}\n\n\tfunction _mint(address to, uint256 tokenId) internal virtual {\n\t\trequire(to != address(0), \"ERC721: mint to the zero address\");\n\t\trequire(!_exists(tokenId), \"ERC721: token already minted\");\n\t\t_beforeTokenTransfer(address(0), to, tokenId);\n\t\t_holderTokens[to].add(tokenId);\n\t\t_tokenOwners.set(tokenId, to);\n\t\temit Transfer(address(0), to, tokenId);\n\t}\n\n\tfunction _burn(uint256 tokenId) internal virtual {\n\t\taddress owner = ERC721.ownerOf(tokenId);\n\t\t_beforeTokenTransfer(owner, address(0), tokenId);\n\t\t_approve(address(0), tokenId);\n\t\tif (bytes(_tokenURIs[tokenId]).length != 0) {\n\t\t\tdelete _tokenURIs[tokenId];\n\t\t}\n\t\t_holderTokens[owner].remove(tokenId);\n\t\t_tokenOwners.remove(tokenId);\n\t\temit Transfer(owner, address(0), tokenId);\n\t}\n\n\tfunction _transfer(address from, address to, uint256 tokenId) internal virtual {\n\t\trequire(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n\t\trequire(to != address(0), \"ERC721: transfer to the zero address\");\n\t\t_beforeTokenTransfer(from, to, tokenId);\n\t\t_approve(address(0), tokenId);\n\t\t_holderTokens[from].remove(tokenId);\n\t\t_holderTokens[to].add(tokenId);\n\t\t_tokenOwners.set(tokenId, to);\n\t\temit Transfer(from, to, tokenId);\n\t}\n\n\tfunction _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n\t\trequire(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n\t\t_tokenURIs[tokenId] = _tokenURI;\n\t}\n\n\tfunction _setBaseURI(string memory baseURI_) internal virtual {\n\t\t_baseURI = baseURI_;\n\t}\n\n\tfunction _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n\tprivate returns (bool)\n\t{\n\t\tif (!to.isContract()) {\n\t\t\treturn true;\n\t\t}\n\t\tbytes memory returndata = to.functionCall(abi.encodeWithSelector(\n\t\t\t\tIERC721Receiver(to).onERC721Received.selector,\n\t\t\t\t_msgSender(),\n\t\t\t\tfrom,\n\t\t\t\ttokenId,\n\t\t\t\t_data\n\t\t\t), \"ERC721: transfer to non ERC721Receiver implementer\");\n\t\tbytes4 retval = abi.decode(returndata, (bytes4));\n\t\treturn (retval == _ERC721_RECEIVED);\n\t}\n\n\tfunction _approve(address to, uint256 tokenId) internal virtual {\n\t\t_tokenApprovals[tokenId] = to;\n\t\temit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n\t}\n\n\tfunction _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}"},"TestContract/LGBTNFT.sol":{"content":"pragma solidity <=8.7.0;\npragma experimental ABIEncoderV2;\n//SPDX-License-Identifier: MIT\n\nimport \"./ERC721.sol\";\n\ncontract LGBTNFT is ERC721, ReentrancyGuard, Ownable {\n\tuint256 public price = 100000000000000000;\n\tuint256 public maxSupply = 4869;\n\tuint256 public currentSupply = 0;\n\taddress public LGBTokenContract;\n\tuint256 public LGBTokenDropPerMint = 1000000000000;\n\tuint256 public openAt = 1638554400;\n\n\tconstructor() ERC721(\"LGBT NFT\", \"LGBT+\") {\n\t\t_setBaseURI(string(\"https://lgbt-nft.online/meta/\"));\n\t}\n\n\tfunction isOpen() public view returns (bool) {\n\t\tif (block.timestamp >= openAt) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction mint() public payable nonReentrant {\n\t\trequire(isOpen(), \"Minting is not yet enabled\");\n\t\trequire(price <= msg.value, \"Not enough Ether sent\");\n\t\tuint256 Count = msg.value/price;\n\t\trequire(currentSupply < maxSupply, \"Minting closed\");\n\t\tuint256 remaining = maxSupply-currentSupply;\n\t\trequire(Count <= remaining, \"Not enough NFT remaining for this Ether amount\");\n\t\tfor (uint256 i=0; i<Count; i++) {\n\t\t\t_safeMint(msg.sender, currentSupply);\n\t\t\tif (currentSupply < maxSupply/2) {\n\t\t\t\tERC20(LGBTokenContract).transfer(msg.sender, LGBTokenDropPerMint);\n\t\t\t}\n\t\t\tcurrentSupply += 1;\n\t\t}\n\t}\n\n\tfunction withdraw() public onlyOwner {\n\t\tuint256 balance = address(this).balance;\n\t\tpayable(msg.sender).transfer(balance);\n\t}\n\n\tfunction setLGBTokenContract(address contractAddress) external onlyOwner {\n\t\tLGBTokenContract = contractAddress;\n\t}\n\n\treceive() external payable {}\n}\n\ninterface ERC20 {\n\tfunction transfer(address, uint256) external returns (bool);\n\tfunction approve(address, uint256) external returns (bool);\n\tfunction transferFrom(address, address, uint256) external returns (bool);\n}"}}}