{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"WildcardSteward_v3.sol":{"content":"// File: @openzeppelin/upgrades/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context is Initializable {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is Initializable, IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApprovalForAll}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either {approve} or {setApprovalForAll}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/drafts/Counters.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/introspection/ERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\ncontract ERC165 is Initializable, IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    function initialize() public initializer {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC721/ERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721 is Initializable, Context, ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => Counters.Counter) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    /*\r\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\r\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\r\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\r\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\r\n     *\r\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\r\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    function initialize() public initializer {\r\n        ERC165.initialize();\r\n\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    function _hasBeenInitialized() internal view returns (bool) {\r\n        return supportsInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID.\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\r\n     * @param to operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != _msgSender(), \"ERC721: approve to caller\");\r\n\r\n        _operatorApprovals[_msgSender()][to] = approved;\r\n        emit ApprovalForAll(_msgSender(), to, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner.\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address.\r\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     * Requires the msg.sender to be the owner, approved, or operator.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the _msgSender() to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransferFrom(from, to, tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the _msgSender() to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\r\n        _transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists.\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return bool whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID.\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     * is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to safely mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _safeMint(address to, uint256 tokenId) internal {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to safely mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\r\n        _mint(to, tokenId);\r\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token.\r\n     * Reverts if the token does not exist.\r\n     * Deprecated, use {_burn} instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[owner].decrement();\r\n        _tokenOwner[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token.\r\n     * Reverts if the token does not exist.\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(uint256 tokenId) internal {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * This is an internal detail of the `ERC721` contract and its use is deprecated.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\r\n            IERC721Receiver(to).onERC721Received.selector,\r\n            _msgSender(),\r\n            from,\r\n            tokenId,\r\n            _data\r\n        ));\r\n        if (!success) {\r\n            if (returndata.length > 0) {\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n            }\r\n        } else {\r\n            bytes4 retval = abi.decode(returndata, (bytes4));\r\n            return (retval == _ERC721_RECEIVED);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to clear current approval of a given token ID.\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Enumerable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721Enumerable is Initializable, IERC721 {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256);\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC721/ERC721Enumerable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721Enumerable is Initializable, Context, ERC165, ERC721, IERC721Enumerable {\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint256[]) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    /*\r\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\r\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\r\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\r\n     *\r\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n\r\n    /**\r\n     * @dev Constructor function.\r\n     */\r\n    function initialize() public initializer {\r\n        require(ERC721._hasBeenInitialized());\r\n        // register the supported interface to conform to ERC721Enumerable via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\r\n    }\r\n\r\n    function _hasBeenInitialized() internal view returns (bool) {\r\n        return supportsInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\r\n     * @param owner address owning the tokens list to be accessed\r\n     * @param index uint256 representing the index to be accessed of the requested tokens list\r\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\r\n        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of tokens stored by the contract.\r\n     * @return uint256 representing the total amount of tokens\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of all the tokens in this contract\r\n     * Reverts if the index is greater or equal to the total number of tokens.\r\n     * @param index uint256 representing the index to be accessed of the tokens list\r\n     * @return uint256 token ID at the given index of the tokens list\r\n     */\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        super._transferFrom(from, to, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(from, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token.\r\n     * Reverts if the given token ID already exists.\r\n     * @param to address the beneficiary that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        super._mint(to, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n\r\n        _addTokenToAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token.\r\n     * Reverts if the token does not exist.\r\n     * Deprecated, use {ERC721-_burn} instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        super._burn(owner, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\r\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\r\n        _ownedTokensIndex[tokenId] = 0;\r\n\r\n        _removeTokenFromAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the list of token IDs of the requested owner.\r\n     * @param owner address owning the tokens\r\n     * @return uint256[] List of token IDs owned by the requested address\r\n     */\r\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\r\n        return _ownedTokens[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\r\n        _ownedTokens[to].push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        _ownedTokens[from].length--;\r\n\r\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\r\n        // lastTokenId, or just over the end of the array if the token was the last one).\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        _allTokens.length--;\r\n        _allTokensIndex[tokenId] = 0;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721Metadata.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721Metadata is Initializable, IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC721/ERC721Metadata.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC721Metadata is Initializable, Context, ERC165, ERC721, IERC721Metadata {\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n    // Base URI\r\n    string private _baseURI;\r\n\r\n    /*\r\n     *     bytes4(keccak256('name()')) == 0x06fdde03\r\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\r\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\r\n     *\r\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    function initialize(string memory name, string memory symbol) public initializer {\r\n        require(ERC721._hasBeenInitialized());\r\n\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n    }\r\n\r\n    function _hasBeenInitialized() internal view returns (bool) {\r\n        return supportsInterface(_INTERFACE_ID_ERC721_METADATA);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token name.\r\n     * @return string representing the token name\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol.\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the URI for a given token ID. May return an empty string.\r\n     *\r\n     * If the token's URI is non-empty and a base URI was set (via\r\n     * {_setBaseURI}), it will be added to the token ID's URI as a prefix.\r\n     *\r\n     * Reverts if the token ID does not exist.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n\r\n        // Even if there is a base URI, it is only appended to non-empty token-specific URIs\r\n        if (bytes(_tokenURI).length == 0) {\r\n            return \"\";\r\n        } else {\r\n            // abi.encodePacked is being used to concatenate strings\r\n            return string(abi.encodePacked(_baseURI, _tokenURI));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the token URI for a given token.\r\n     *\r\n     * Reverts if the token ID does not exist.\r\n     *\r\n     * TIP: if all token IDs share a prefix (e.g. if your URIs look like\r\n     * `http://api.myproject.com/token/<id>`), use {_setBaseURI} to store\r\n     * it and save gas.\r\n     */\r\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\r\n        _tokenURIs[tokenId] = _tokenURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the base URI for all token IDs. It is\r\n     * automatically added as a prefix to the value returned in {tokenURI}.\r\n     *\r\n     * _Available since v2.5.0._\r\n     */\r\n    function _setBaseURI(string memory baseURI) internal {\r\n        _baseURI = baseURI;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\r\n    * automatically added as a preffix in {tokenURI} to each token's URI, when\r\n    * they are non-empty.\r\n    *\r\n    * _Available since v2.5.0._\r\n    */\r\n    function baseURI() external view returns (string memory) {\r\n        return _baseURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token.\r\n     * Reverts if the token does not exist.\r\n     * Deprecated, use _burn(uint256) instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        super._burn(owner, tokenId);\r\n\r\n        // Clear metadata (if any)\r\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\r\n            delete _tokenURIs[tokenId];\r\n        }\r\n    }\r\n\r\n    uint256[49] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/access/roles/MinterRole.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ncontract MinterRole is Initializable, Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    function initialize(address sender) public initializer {\r\n        if (!isMinter(sender)) {\r\n            _addMinter(sender);\r\n        }\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(_msgSender());\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC721/ERC721MetadataMintable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721MetadataMintable\r\n * @dev ERC721 minting logic with metadata.\r\n */\r\ncontract ERC721MetadataMintable is Initializable, ERC721, ERC721Metadata, MinterRole {\r\n    function initialize(address sender) public initializer {\r\n        require(ERC721._hasBeenInitialized());\r\n        require(ERC721Metadata._hasBeenInitialized());\r\n        MinterRole.initialize(sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens.\r\n     * @param to The address that will receive the minted tokens.\r\n     * @param tokenId The token id to mint.\r\n     * @param tokenURI The token URI of the minted token.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mintWithTokenURI(address to, uint256 tokenId, string memory tokenURI) public onlyMinter returns (bool) {\r\n        _mint(to, tokenId);\r\n        _setTokenURI(tokenId, tokenURI);\r\n        return true;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/ERC721Patronage_v1.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// import \"./WildcardSteward_v1.sol\";\r\ncontract ERC721Patronage_v1 is\r\n    Initializable,\r\n    ERC721,\r\n    ERC721Enumerable,\r\n    ERC721Metadata,\r\n    ERC721MetadataMintable\r\n{\r\n    address public steward;\r\n\r\n    function setup(\r\n        address _steward,\r\n        string memory name,\r\n        string memory symbol,\r\n        address minter\r\n    ) public initializer {\r\n        steward = _steward;\r\n        ERC721.initialize();\r\n        ERC721Enumerable.initialize();\r\n        ERC721Metadata.initialize(name, symbol);\r\n        // Initialize the minter and pauser roles, and renounce them\r\n        ERC721MetadataMintable.initialize(address(this));\r\n        _removeMinter(address(this));\r\n        _addMinter(minter);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (spender == steward);\r\n        /*\r\n          // NOTE: temporarily disabling sending of the tokens independently. A protective messure since it isn't clear to users how this function should work.\r\n          //       Will re-add once a mechanism is agreed on by the community.\r\n          || ERC721._isApprovedOrOwner(spender, tokenId)\r\n          */\r\n    }\r\n\r\n    // function transferFrom(address from, address to, uint256 tokenId) public {\r\n    //     if (msg.sender != steward) {\r\n    //         WildcardSteward_v1 stewardContract = WildcardSteward_v1(steward);\r\n\r\n    //         // Calculate remaining deposit for the two addresses involved in transfer.\r\n    //         stewardContract._collectPatronagePatron(to);\r\n    //         stewardContract._collectPatronage(tokenId);\r\n\r\n    //         // Do not allow someone to transfer a token if their deposit is Zero.\r\n    //         require(stewardContract.deposit(to) > 0, \"Recipient needs to have a deposit.\");\r\n    //         require(stewardContract.deposit(from) > 0, \"Sender deposit has run out.\");\r\n    //     }\r\n\r\n    //     ERC721.transferFrom(from, to, tokenId);\r\n    // }\r\n}\r\n\r\n// File: contracts/interfaces/IERC20Mintable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract IERC20Mintable {\r\n    function mint(address account, uint256 amount) public returns (bool);\r\n}\r\n\r\n// File: contracts/MintManager_v2.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\ncontract MintManager_v2 is Initializable {\r\n    using SafeMath for uint256;\r\n\r\n    address public admin;\r\n    address public steward;\r\n    IERC20Mintable public token;\r\n\r\n    modifier onlySteward() {\r\n        require(msg.sender == steward, \"Not steward\");\r\n        _;\r\n    }\r\n\r\n    function initialize(\r\n        address _admin,\r\n        address _steward,\r\n        address _token\r\n    ) public initializer {\r\n        admin = _admin;\r\n        steward = _steward;\r\n        token = IERC20Mintable(_token);\r\n    }\r\n\r\n    function tokenMint(\r\n        address receiverOfTokens,\r\n        uint256 time,\r\n        uint256 mintRate\r\n    ) external onlySteward {\r\n        uint256 amountToMintForUser = time.mul(mintRate);\r\n        uint256 amountToMintForTreasury = amountToMintForUser.mul(20).div(100);\r\n        token.mint(receiverOfTokens, amountToMintForUser);\r\n        token.mint(admin, amountToMintForTreasury);\r\n    }\r\n}\r\n\r\n// File: contracts/WildcardSteward_v3.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\ncontract WildcardSteward_v3 is Initializable {\r\n    /*\r\n    This smart contract collects patronage from current owner through a Harberger tax model and \r\n    takes stewardship of the asset token if the patron can't pay anymore.\r\n\r\n    Harberger Tax (COST): \r\n    - Asset is always on sale.\r\n    - You have to have a price set.\r\n    - Tax (Patronage) is paid to maintain ownership.\r\n    - Steward maints control over ERC721.\r\n    */\r\n    using SafeMath for uint256;\r\n    mapping(uint256 => uint256) public price; //in wei\r\n    ERC721Patronage_v1 public assetToken; // ERC721 NFT.\r\n\r\n    mapping(uint256 => uint256) deprecated_totalCollected; // THIS VALUE IS DEPRECATED\r\n    mapping(uint256 => uint256) deprecated_currentCollected; // THIS VALUE IS DEPRECATED\r\n    mapping(uint256 => uint256) deprecated_timeLastCollected; // THIS VALUE IS DEPRECATED.\r\n    mapping(address => uint256) public timeLastCollectedPatron;\r\n    mapping(address => uint256) public deposit;\r\n    mapping(address => uint256) public totalPatronOwnedTokenCost;\r\n\r\n    mapping(uint256 => address) public benefactors; // non-profit benefactor\r\n    mapping(address => uint256) public benefactorFunds;\r\n\r\n    mapping(uint256 => address) deprecated_currentPatron; // Deprecate This is different to the current token owner.\r\n    mapping(uint256 => mapping(address => bool)) deprecated_patrons; // Deprecate\r\n    mapping(uint256 => mapping(address => uint256)) deprecated_timeHeld; // Deprecate\r\n\r\n    mapping(uint256 => uint256) deprecated_timeAcquired; // deprecate\r\n\r\n    // 1200% patronage\r\n    mapping(uint256 => uint256) public patronageNumerator;\r\n    uint256 public patronageDenominator;\r\n\r\n    enum StewardState {Foreclosed, Owned}\r\n    mapping(uint256 => StewardState) public state;\r\n\r\n    address public admin;\r\n\r\n    //////////////// NEW variables in v2///////////////////\r\n    mapping(uint256 => uint256) deprecated_tokenGenerationRate; // we can reuse the patronage denominator\r\n\r\n    MintManager_v2 public mintManager;\r\n    //////////////// NEW variables in v3 ///////////////////\r\n    uint256 public auctionStartPrice;\r\n    uint256 public auctionEndPrice;\r\n    uint256 public auctionLength;\r\n\r\n    mapping(uint256 => address) public artistAddresses; //mapping from tokenID to the artists address\r\n    mapping(uint256 => uint256) public wildcardsPercentages; // mapping from tokenID to the percentage sale cut of wildcards for each token\r\n    mapping(uint256 => uint256) public artistPercentages; // tokenId to artist percetages. To make it configurable. 10 000 = 100%\r\n    mapping(uint256 => uint256) public tokenAuctionBeginTimestamp;\r\n\r\n    mapping(address => uint256) public totalPatronTokenGenerationRate; // The total token generation rate for all the tokens of the given address.\r\n    mapping(address => uint256) public totalBenefactorTokenNumerator;\r\n    mapping(address => uint256) public timeLastCollectedBenefactor; // make my name consistent please\r\n    mapping(address => uint256) public benefactorCredit;\r\n    address public withdrawCheckerAdmin;\r\n\r\n    /*\r\n    31536000 seconds = 365 days\r\n\r\n    divisor = 365 days * 1000000000000\r\n            = 31536000000000000000\r\n    */\r\n\r\n    // 11574074074074 = 10^18 / 86400 This is just less (rounded down) than one token a day.\r\n    //       - this can be done since all tokens have the exact same tokenGenerationRate - and hardcoding saves gas.\r\n    uint256 public constant globalTokenGenerationRate = 11574074074074;\r\n    uint256 public constant yearTimePatronagDenominator = 31536000000000000000;\r\n\r\n    event Buy(uint256 indexed tokenId, address indexed owner, uint256 price);\r\n    event PriceChange(uint256 indexed tokenId, uint256 newPrice);\r\n    event Foreclosure(address indexed prevOwner, uint256 foreclosureTime);\r\n    event RemainingDepositUpdate(\r\n        address indexed tokenPatron,\r\n        uint256 remainingDeposit\r\n    );\r\n\r\n    event AddTokenV3(\r\n        uint256 indexed tokenId,\r\n        uint256 patronageNumerator,\r\n        uint256 unixTimestampOfTokenAuctionStart\r\n    );\r\n\r\n    // QUESTION: in future versions, should these two events (CollectPatronage and CollectLoyalty) be combined into one? - they only ever happen at the same time.\r\n    // NOTE: this event is deprecated - it is only here for the upgrade function.\r\n    event CollectPatronage(\r\n        uint256 indexed tokenId,\r\n        address indexed patron,\r\n        uint256 remainingDeposit,\r\n        uint256 amountReceived\r\n    );\r\n    event CollectLoyalty(address indexed patron, uint256 amountRecieved);\r\n\r\n    event ArtistCommission(\r\n        uint256 indexed tokenId,\r\n        address artist,\r\n        uint256 artistCommission\r\n    );\r\n    event WithdrawBenefactorFundsWithSafetyDelay(\r\n        address indexed benefactor,\r\n        uint256 withdrawAmount\r\n    );\r\n    event WithdrawBenefactorFunds(\r\n        address indexed benefactor,\r\n        uint256 withdrawAmount\r\n    );\r\n    event UpgradeToV3();\r\n    event ChangeAuctionParameters();\r\n\r\n    modifier onlyPatron(uint256 tokenId) {\r\n        require(msg.sender == assetToken.ownerOf(tokenId), \"Not patron\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"Not admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyReceivingBenefactorOrAdmin(uint256 tokenId) {\r\n        require(\r\n            msg.sender == benefactors[tokenId] || msg.sender == admin,\r\n            \"Not benefactor or admin\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier collectPatronageAndSettleBenefactor(uint256 tokenId) {\r\n        _collectPatronageAndSettleBenefactor(tokenId);\r\n        _;\r\n    }\r\n\r\n    modifier collectPatronagePatron(address tokenPatron) {\r\n        _collectPatronagePatron(tokenPatron);\r\n        _;\r\n    }\r\n\r\n    modifier youCurrentlyAreNotInDefault(address tokenPatron) {\r\n        require(\r\n            !(deposit[tokenPatron] == 0 &&\r\n                totalPatronOwnedTokenCost[tokenPatron] > 0),\r\n            \"no deposit existing tokens\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier updateBenefactorBalance(address benefactor) {\r\n        _updateBenefactorBalance(benefactor);\r\n        _;\r\n    }\r\n\r\n    modifier priceGreaterThanZero(uint256 _newPrice) {\r\n        require(_newPrice > 0, \"Price is zero\");\r\n        _;\r\n    }\r\n    modifier notNullAddress(address checkAddress) {\r\n        require(checkAddress != address(0), \"null address\");\r\n        _;\r\n    }\r\n    modifier notSameAddress(address firstAddress, address secondAddress) {\r\n        require(firstAddress != secondAddress, \"cannot be same address\");\r\n        _;\r\n    }\r\n    modifier validWildcardsPercentage(\r\n        uint256 wildcardsPercentage,\r\n        uint256 tokenID\r\n    ) {\r\n        require(\r\n            wildcardsPercentage >= 50000 &&\r\n                wildcardsPercentage <= (1000000 - artistPercentages[tokenID]), // not sub safemath. Is this okay?\r\n            \"wildcards commision not between 5% and 100%\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function initialize(\r\n        address _assetToken,\r\n        address _admin,\r\n        address _mintManager,\r\n        address _withdrawCheckerAdmin,\r\n        uint256 _auctionStartPrice,\r\n        uint256 _auctionEndPrice,\r\n        uint256 _auctionLength\r\n    ) public initializer {\r\n        assetToken = ERC721Patronage_v1(_assetToken);\r\n        admin = _admin;\r\n        withdrawCheckerAdmin = _withdrawCheckerAdmin;\r\n        mintManager = MintManager_v2(_mintManager);\r\n        _changeAuctionParameters(\r\n            _auctionStartPrice,\r\n            _auctionEndPrice,\r\n            _auctionLength\r\n        );\r\n    }\r\n\r\n    function uintToStr(uint256 _i)\r\n        internal\r\n        pure\r\n        returns (string memory _uintAsString)\r\n    {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n\r\n        uint256 j = _i;\r\n        uint256 len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n\r\n        bytes memory bstr = new bytes(len);\r\n        while (_i != 0) {\r\n            bstr[--len] = bytes1(uint8(48 + (_i % 10)));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function listNewTokens(\r\n        uint256[] memory tokens,\r\n        address payable[] memory _benefactors,\r\n        uint256[] memory _patronageNumerator,\r\n        address[] memory _artists,\r\n        uint256[] memory _artistCommission,\r\n        uint256[] memory _releaseDate\r\n    ) public onlyAdmin {\r\n        assert(tokens.length == _benefactors.length);\r\n        assert(tokens.length == _patronageNumerator.length);\r\n        assert(tokens.length == _releaseDate.length);\r\n        assert(_artists.length == _artistCommission.length);\r\n\r\n        for (uint8 i = 0; i < tokens.length; ++i) {\r\n            address benefactor = _benefactors[i];\r\n            require(_benefactors[i] != address(0), \"null address\");\r\n            string memory idString = uintToStr(tokens[i]);\r\n            string memory tokenUriBase = \"https://wildcards.xyz/token/\";\r\n            string memory tokenUri = string(\r\n                abi.encodePacked(tokenUriBase, idString)\r\n            );\r\n            assetToken.mintWithTokenURI(address(this), tokens[i], tokenUri);\r\n            benefactors[tokens[i]] = _benefactors[i];\r\n            state[tokens[i]] = StewardState.Foreclosed;\r\n            patronageNumerator[tokens[i]] = _patronageNumerator[i];\r\n            // tokenGenerationRate[tokens[i]] = _tokenGenerationRate[i];\r\n\r\n            if (_releaseDate[i] < now) {\r\n                tokenAuctionBeginTimestamp[tokens[i]] = now;\r\n            } else {\r\n                tokenAuctionBeginTimestamp[tokens[i]] = _releaseDate[i];\r\n            }\r\n\r\n            emit AddTokenV3(\r\n                tokens[i],\r\n                _patronageNumerator[i],\r\n                tokenAuctionBeginTimestamp[tokens[i]]\r\n            );\r\n            // Adding this after the add token emit, so graph can first capture the token before processing the change artist things\r\n            if (_artists.length > i) {\r\n                changeArtistAddressAndCommission(\r\n                    tokens[i],\r\n                    _artists[i],\r\n                    _artistCommission[i]\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function upgradeToV3(\r\n        uint256[] memory tokens,\r\n        address _withdrawCheckerAdmin,\r\n        uint256 _auctionStartPrice,\r\n        uint256 _auctionEndPrice,\r\n        uint256 _auctionLength\r\n    ) public notNullAddress(_withdrawCheckerAdmin) {\r\n        emit UpgradeToV3();\r\n        // This function effectively needs to call both _collectPatronage and _collectPatronagePatron from the v2 contract.\r\n        require(withdrawCheckerAdmin == address(0));\r\n        withdrawCheckerAdmin = _withdrawCheckerAdmin;\r\n        // For each token\r\n        for (uint8 i = 0; i < tokens.length; ++i) {\r\n            uint256 tokenId = tokens[i];\r\n            address currentOwner = assetToken.ownerOf(tokenId);\r\n\r\n            uint256 timeSinceTokenLastCollection = now.sub(\r\n                deprecated_timeLastCollected[tokenId]\r\n            );\r\n\r\n            // NOTE: for this upgrade we make sure no tokens are foreclosed, or close to foreclosing\r\n            uint256 collection = price[tokenId]\r\n                .mul(timeSinceTokenLastCollection)\r\n                .mul(patronageNumerator[tokenId])\r\n                .div(yearTimePatronagDenominator);\r\n\r\n            // set the timeLastCollectedPatron for that tokens owner to 'now'.\r\n            // timeLastCollected[tokenId] = now; // This variable is depricated, no need to update it.\r\n            if (timeLastCollectedPatron[currentOwner] < now) {\r\n                // set subtract patronage owed for the Patron from their deposit.\r\n                deposit[currentOwner] = deposit[currentOwner].sub(\r\n                    patronageOwedPatron(currentOwner)\r\n                );\r\n\r\n                timeLastCollectedPatron[currentOwner] = now;\r\n            }\r\n\r\n            // Add the amount collected for current token to the benefactorFunds.\r\n            benefactorFunds[benefactors[tokenId]] = benefactorFunds[benefactors[tokenId]]\r\n                .add(collection);\r\n\r\n            // Emit an event for the graph to pickup this action (the last time this event will ever be emited)\r\n            emit CollectPatronage(\r\n                tokenId,\r\n                currentOwner,\r\n                deposit[currentOwner],\r\n                collection\r\n            );\r\n\r\n            // mint required loyalty tokens\r\n            mintManager.tokenMint(\r\n                currentOwner,\r\n                timeSinceTokenLastCollection, // this should always be > 0\r\n                globalTokenGenerationRate // instead of this -> tokenGenerationRate[tokenId] hard code to save gas\r\n            );\r\n            emit CollectLoyalty(\r\n                currentOwner,\r\n                timeSinceTokenLastCollection.mul(globalTokenGenerationRate)\r\n            ); // OPTIMIZE ME\r\n\r\n            // Add the tokens generation rate to the totalPatronTokenGenerationRate of the current owner\r\n            totalPatronTokenGenerationRate[currentOwner] = totalPatronTokenGenerationRate[currentOwner]\r\n                .add(globalTokenGenerationRate);\r\n\r\n            address tokenBenefactor = benefactors[tokenId];\r\n            // add the scaled tokens price to the `totalBenefactorTokenNumerator`\r\n            totalBenefactorTokenNumerator[tokenBenefactor] = totalBenefactorTokenNumerator[tokenBenefactor]\r\n                .add(price[tokenId].mul(patronageNumerator[tokenId]));\r\n\r\n            if (timeLastCollectedBenefactor[tokenBenefactor] == 0) {\r\n                timeLastCollectedBenefactor[tokenBenefactor] = now;\r\n            }\r\n        }\r\n        _changeAuctionParameters(\r\n            _auctionStartPrice,\r\n            _auctionEndPrice,\r\n            _auctionLength\r\n        );\r\n    }\r\n\r\n    function changeReceivingBenefactor(\r\n        uint256 tokenId,\r\n        address payable _newReceivingBenefactor\r\n    )\r\n        public\r\n        onlyReceivingBenefactorOrAdmin(tokenId)\r\n        updateBenefactorBalance(benefactors[tokenId])\r\n        updateBenefactorBalance(_newReceivingBenefactor)\r\n        notNullAddress(_newReceivingBenefactor)\r\n    {\r\n        address oldBenfactor = benefactors[tokenId];\r\n\r\n        require(\r\n            oldBenfactor != _newReceivingBenefactor,\r\n            \"cannot be same address\"\r\n        );\r\n\r\n        // Collect patronage from old and new benefactor before changing totalBenefactorTokenNumerator on both\r\n        uint256 scaledPrice = price[tokenId].mul(patronageNumerator[tokenId]);\r\n        totalBenefactorTokenNumerator[oldBenfactor] = totalBenefactorTokenNumerator[oldBenfactor]\r\n            .sub(scaledPrice);\r\n        totalBenefactorTokenNumerator[_newReceivingBenefactor] = totalBenefactorTokenNumerator[_newReceivingBenefactor]\r\n            .add(scaledPrice);\r\n\r\n        benefactors[tokenId] = _newReceivingBenefactor;\r\n        // NB No fund exchanging here please!\r\n    }\r\n\r\n    // NB This function is if an organisation loses their keys etc..\r\n    // It will transfer their deposit to their new benefactor address\r\n    // It should only be called once all their tokens also changeReceivingBenefactor\r\n    function changeReceivingBenefactorDeposit(\r\n        address oldBenfactor,\r\n        address payable _newReceivingBenefactor\r\n    )\r\n        public\r\n        onlyAdmin\r\n        notNullAddress(_newReceivingBenefactor)\r\n        notSameAddress(oldBenfactor, _newReceivingBenefactor)\r\n    {\r\n        require(benefactorFunds[oldBenfactor] > 0, \"no funds\");\r\n\r\n        benefactorFunds[_newReceivingBenefactor] = benefactorFunds[_newReceivingBenefactor]\r\n            .add(benefactorFunds[oldBenfactor]);\r\n        benefactorFunds[oldBenfactor] = 0;\r\n    }\r\n\r\n    function changeAdmin(address _admin) public onlyAdmin {\r\n        admin = _admin;\r\n    }\r\n\r\n    function changeWithdrawCheckerAdmin(address _withdrawCheckerAdmin)\r\n        public\r\n        onlyAdmin\r\n        notNullAddress(_withdrawCheckerAdmin)\r\n    {\r\n        withdrawCheckerAdmin = _withdrawCheckerAdmin;\r\n    }\r\n\r\n    function changeArtistAddressAndCommission(\r\n        uint256 tokenId,\r\n        address artistAddress,\r\n        uint256 percentage\r\n    ) public onlyAdmin {\r\n        require(percentage <= 200000, \"not more than 20%\");\r\n        artistPercentages[tokenId] = percentage;\r\n        artistAddresses[tokenId] = artistAddress;\r\n        emit ArtistCommission(tokenId, artistAddress, percentage);\r\n    }\r\n\r\n    function _changeAuctionParameters(\r\n        uint256 _auctionStartPrice,\r\n        uint256 _auctionEndPrice,\r\n        uint256 _auctionLength\r\n    ) internal {\r\n        require(\r\n            _auctionStartPrice >= _auctionEndPrice,\r\n            \"auction start < auction end\"\r\n        );\r\n        require(_auctionLength >= 86400, \"1 day min auction length\");\r\n\r\n        auctionStartPrice = _auctionStartPrice;\r\n        auctionEndPrice = _auctionEndPrice;\r\n        auctionLength = _auctionLength;\r\n        emit ChangeAuctionParameters();\r\n    }\r\n\r\n    function changeAuctionParameters(\r\n        uint256 _auctionStartPrice,\r\n        uint256 _auctionEndPrice,\r\n        uint256 _auctionLength\r\n    ) external onlyAdmin {\r\n        _changeAuctionParameters(\r\n            _auctionStartPrice,\r\n            _auctionEndPrice,\r\n            _auctionLength\r\n        );\r\n    }\r\n\r\n    function patronageOwedPatron(address tokenPatron)\r\n        public\r\n        view\r\n        returns (uint256 patronageDue)\r\n    {\r\n        // NOTE: Leaving this code here as a reminder: totalPatronOwnedTokenCost[tokenPatron] has to be zero if timeLastCollectedPatron[tokenPatron] is zero. So effectively this line isn't needed.\r\n        // if (timeLastCollectedPatron[tokenPatron] == 0) return 0;\r\n        return\r\n            totalPatronOwnedTokenCost[tokenPatron]\r\n                .mul(now.sub(timeLastCollectedPatron[tokenPatron]))\r\n                .div(yearTimePatronagDenominator);\r\n    }\r\n\r\n    function patronageDueBenefactor(address benefactor)\r\n        public\r\n        view\r\n        returns (uint256 payoutDue)\r\n    {\r\n        // NOTE: Leaving this code here as a reminder: totalBenefactorTokenNumerator[tokenPatron] has to be zero if timeLastCollectedBenefactor[tokenPatron] is zero. So effectively this line isn't needed.\r\n        // if (timeLastCollectedBenefactor[benefactor] == 0) return 0;\r\n        return\r\n            totalBenefactorTokenNumerator[benefactor]\r\n                .mul(now.sub(timeLastCollectedBenefactor[benefactor]))\r\n                .div(yearTimePatronagDenominator);\r\n    }\r\n\r\n    function foreclosedPatron(address tokenPatron) public view returns (bool) {\r\n        if (patronageOwedPatron(tokenPatron) >= deposit[tokenPatron]) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function foreclosed(uint256 tokenId) public view returns (bool) {\r\n        address tokenPatron = assetToken.ownerOf(tokenId);\r\n        return foreclosedPatron(tokenPatron);\r\n    }\r\n\r\n    function depositAbleToWithdraw(address tokenPatron)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 collection = patronageOwedPatron(tokenPatron);\r\n        if (collection >= deposit[tokenPatron]) {\r\n            return 0;\r\n        } else {\r\n            return deposit[tokenPatron].sub(collection);\r\n        }\r\n    }\r\n\r\n    function foreclosureTimePatron(address tokenPatron)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 pps = totalPatronOwnedTokenCost[tokenPatron].div(\r\n            yearTimePatronagDenominator\r\n        );\r\n        return now.add(depositAbleToWithdraw(tokenPatron).div(pps));\r\n    }\r\n\r\n    function foreclosureTime(uint256 tokenId) public view returns (uint256) {\r\n        address tokenPatron = assetToken.ownerOf(tokenId);\r\n        return foreclosureTimePatron(tokenPatron);\r\n    }\r\n\r\n    /* actions */\r\n    function _collectLoyaltyPatron(\r\n        address tokenPatron,\r\n        uint256 timeSinceLastMint\r\n    ) internal {\r\n        if (timeSinceLastMint != 0) {\r\n            mintManager.tokenMint(\r\n                tokenPatron,\r\n                timeSinceLastMint,\r\n                totalPatronTokenGenerationRate[tokenPatron]\r\n            );\r\n            emit CollectLoyalty(\r\n                tokenPatron,\r\n                timeSinceLastMint.mul(\r\n                    totalPatronTokenGenerationRate[tokenPatron]\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    // TODO: create a version of this function that only collects patronage (and only settles the benefactor if the token forecloses) - is this needed?\r\n\r\n    function _collectPatronageAndSettleBenefactor(uint256 tokenId) public {\r\n        address tokenPatron = assetToken.ownerOf(tokenId);\r\n        uint256 newTimeLastCollectedOnForeclosure = _collectPatronagePatron(\r\n            tokenPatron\r\n        );\r\n\r\n        address benefactor = benefactors[tokenId];\r\n        // bool tokenForeclosed = newTimeLastCollectedOnForeclosure > 0;\r\n        bool tokenIsOwned = state[tokenId] == StewardState.Owned;\r\n        if (newTimeLastCollectedOnForeclosure > 0 && tokenIsOwned) {\r\n            tokenAuctionBeginTimestamp[tokenId] =\r\n                // The auction starts the second after the last time collected.\r\n                newTimeLastCollectedOnForeclosure +\r\n                1;\r\n\r\n\r\n                uint256 patronageDueBenefactorBeforeForeclosure\r\n             = patronageDueBenefactor(benefactor);\r\n\r\n            _foreclose(tokenId);\r\n\r\n            uint256 amountOverCredited = price[tokenId]\r\n                .mul(now.sub(newTimeLastCollectedOnForeclosure))\r\n                .mul(patronageNumerator[tokenId])\r\n                .div(yearTimePatronagDenominator);\r\n\r\n            if (amountOverCredited < patronageDueBenefactorBeforeForeclosure) {\r\n                _increaseBenefactorBalance(\r\n                    benefactor,\r\n                    patronageDueBenefactorBeforeForeclosure - amountOverCredited\r\n                );\r\n            } else {\r\n                _decreaseBenefactorBalance(\r\n                    benefactor,\r\n                    amountOverCredited - patronageDueBenefactorBeforeForeclosure\r\n                );\r\n            }\r\n\r\n            timeLastCollectedBenefactor[benefactor] = now;\r\n        } else {\r\n            _updateBenefactorBalance(benefactor);\r\n        }\r\n    }\r\n\r\n    function safeSend(uint256 _wei, address payable recipient)\r\n        internal\r\n        returns (bool transferSuccess)\r\n    {\r\n        (transferSuccess, ) = recipient.call.gas(2300).value(_wei)(\"\");\r\n    }\r\n\r\n    // if credit balance exists,\r\n    // if amount owed > creidt\r\n    // credit zero add amount\r\n    // else reduce credit by certain amount.\r\n    // else if credit balance doesn't exist\r\n    // add amount to balance\r\n\r\n    function _updateBenefactorBalance(address benefactor) public {\r\n        uint256 patronageDueBenefactor = patronageDueBenefactor(benefactor);\r\n\r\n        if (patronageDueBenefactor > 0) {\r\n            _increaseBenefactorBalance(benefactor, patronageDueBenefactor);\r\n        }\r\n\r\n        timeLastCollectedBenefactor[benefactor] = now;\r\n    }\r\n\r\n    function _increaseBenefactorBalance(\r\n        address benefactor,\r\n        uint256 patronageDueBenefactor\r\n    ) internal {\r\n        if (benefactorCredit[benefactor] > 0) {\r\n            if (patronageDueBenefactor < benefactorCredit[benefactor]) {\r\n                benefactorCredit[benefactor] = benefactorCredit[benefactor].sub(\r\n                    patronageDueBenefactor\r\n                );\r\n            } else {\r\n                benefactorFunds[benefactor] = patronageDueBenefactor.sub(\r\n                    benefactorCredit[benefactor]\r\n                );\r\n                benefactorCredit[benefactor] = 0;\r\n            }\r\n        } else {\r\n            benefactorFunds[benefactor] = benefactorFunds[benefactor].add(\r\n                patronageDueBenefactor\r\n            );\r\n        }\r\n    }\r\n\r\n    function _decreaseBenefactorBalance(\r\n        address benefactor,\r\n        uint256 amountOverCredited\r\n    ) internal {\r\n        if (benefactorFunds[benefactor] > 0) {\r\n            if (amountOverCredited <= benefactorFunds[benefactor]) {\r\n                benefactorFunds[benefactor] = benefactorFunds[benefactor].sub(\r\n                    amountOverCredited\r\n                );\r\n            } else {\r\n                benefactorCredit[benefactor] = amountOverCredited.sub(\r\n                    benefactorFunds[benefactor]\r\n                );\r\n                benefactorFunds[benefactor] = 0;\r\n            }\r\n        } else {\r\n            benefactorCredit[benefactor] = benefactorCredit[benefactor].add(\r\n                amountOverCredited\r\n            );\r\n        }\r\n    }\r\n\r\n    function fundsDueForAuctionPeriodAtCurrentRate(address benefactor)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            totalBenefactorTokenNumerator[benefactor].mul(auctionLength).div(\r\n                yearTimePatronagDenominator\r\n            ); // 365 days * 1000000000000\r\n    }\r\n\r\n    function withdrawBenefactorFundsTo(address payable benefactor) public {\r\n        _updateBenefactorBalance(benefactor);\r\n\r\n        uint256 availableToWithdraw = benefactorFunds[benefactor];\r\n\r\n\r\n            uint256 benefactorWithdrawalSafetyDiscount\r\n         = fundsDueForAuctionPeriodAtCurrentRate(benefactor);\r\n\r\n        require(\r\n            availableToWithdraw > benefactorWithdrawalSafetyDiscount,\r\n            \"no funds\"\r\n        );\r\n\r\n        // NOTE: no need for safe-maths, above require prevents issues.\r\n        uint256 amountToWithdraw = availableToWithdraw -\r\n            benefactorWithdrawalSafetyDiscount;\r\n\r\n        benefactorFunds[benefactor] = benefactorWithdrawalSafetyDiscount;\r\n        if (safeSend(amountToWithdraw, benefactor)) {\r\n            emit WithdrawBenefactorFundsWithSafetyDelay(\r\n                benefactor,\r\n                amountToWithdraw\r\n            );\r\n        } else {\r\n            benefactorFunds[benefactor] = benefactorFunds[benefactor].add(\r\n                amountToWithdraw\r\n            );\r\n        }\r\n    }\r\n\r\n    function hasher(\r\n        address benefactor,\r\n        uint256 maxAmount,\r\n        uint256 expiry\r\n    ) public view returns (bytes32) {\r\n        // In ethereum you have to prepend all signature hashes with this message (supposedly to prevent people from)\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19Ethereum Signed Message:\\n32\",\r\n                    keccak256(abi.encodePacked(benefactor, maxAmount, expiry))\r\n                )\r\n            );\r\n    }\r\n\r\n    function withdrawBenefactorFundsToValidated(\r\n        address payable benefactor,\r\n        uint256 maxAmount,\r\n        uint256 expiry,\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public {\r\n        require(\r\n            ecrecover(hash, v, r, s) == withdrawCheckerAdmin,\r\n            \"no permission to withdraw\"\r\n        );\r\n        require(\r\n            hash == hasher(benefactor, maxAmount, expiry),\r\n            \"incorrect hash\"\r\n        );\r\n        require(now < expiry, \"coupon expired\");\r\n\r\n        _updateBenefactorBalance(benefactor);\r\n\r\n        uint256 availableToWithdraw = benefactorFunds[benefactor];\r\n\r\n        if (availableToWithdraw > 0) {\r\n            if (availableToWithdraw > maxAmount) {\r\n                if (safeSend(maxAmount, benefactor)) {\r\n                    benefactorFunds[benefactor] = availableToWithdraw.sub(\r\n                        maxAmount\r\n                    );\r\n                    emit WithdrawBenefactorFunds(\r\n                        benefactor,\r\n                        availableToWithdraw\r\n                    );\r\n                }\r\n            } else {\r\n                if (safeSend(availableToWithdraw, benefactor)) {\r\n                    benefactorFunds[benefactor] = 0;\r\n                    emit WithdrawBenefactorFunds(\r\n                        benefactor,\r\n                        availableToWithdraw\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _collectPatronagePatron(address tokenPatron)\r\n        public\r\n        returns (uint256 newTimeLastCollectedOnForeclosure)\r\n    {\r\n        uint256 patronageOwedByTokenPatron = patronageOwedPatron(tokenPatron);\r\n\r\n        uint256 timeSinceLastMint;\r\n\r\n        if (\r\n            patronageOwedByTokenPatron > 0 &&\r\n            patronageOwedByTokenPatron > deposit[tokenPatron]\r\n        ) {\r\n\r\n                uint256 previousCollectionTime\r\n             = timeLastCollectedPatron[tokenPatron];\r\n            newTimeLastCollectedOnForeclosure = previousCollectionTime.add(\r\n                (\r\n                    (now.sub(previousCollectionTime))\r\n                        .mul(deposit[tokenPatron])\r\n                        .div(patronageOwedByTokenPatron)\r\n                )\r\n            );\r\n            timeLastCollectedPatron[tokenPatron] = newTimeLastCollectedOnForeclosure;\r\n            deposit[tokenPatron] = 0;\r\n            timeSinceLastMint = (\r\n                newTimeLastCollectedOnForeclosure.sub(previousCollectionTime)\r\n            );\r\n        } else {\r\n            timeSinceLastMint = now.sub(timeLastCollectedPatron[tokenPatron]);\r\n            timeLastCollectedPatron[tokenPatron] = now;\r\n            deposit[tokenPatron] = deposit[tokenPatron].sub(\r\n                patronageOwedByTokenPatron\r\n            );\r\n        }\r\n\r\n        _collectLoyaltyPatron(tokenPatron, timeSinceLastMint);\r\n        emit RemainingDepositUpdate(tokenPatron, deposit[tokenPatron]);\r\n    }\r\n\r\n    function depositWei() public payable {\r\n        depositWeiPatron(msg.sender);\r\n    }\r\n\r\n    function depositWeiPatron(address patron) public payable {\r\n        require(totalPatronOwnedTokenCost[patron] > 0, \"no tokens\");\r\n        deposit[patron] = deposit[patron].add(msg.value);\r\n        emit RemainingDepositUpdate(patron, deposit[patron]);\r\n    }\r\n\r\n    function _auctionPrice(uint256 tokenId) internal view returns (uint256) {\r\n        uint256 auctionEnd = tokenAuctionBeginTimestamp[tokenId].add(\r\n            auctionLength\r\n        );\r\n\r\n        // If it is not brand new and foreclosed, use the foreclosre auction price.\r\n        uint256 _auctionStartPrice;\r\n        if (price[tokenId] != 0 && price[tokenId] > auctionEndPrice) {\r\n            _auctionStartPrice = price[tokenId];\r\n        } else {\r\n            // Otherwise use starting auction price\r\n            _auctionStartPrice = auctionStartPrice;\r\n        }\r\n\r\n        if (now >= auctionEnd) {\r\n            return auctionEndPrice;\r\n        } else {\r\n            // startPrice - ( ( (startPrice - endPrice) * howLongThisAuctionBeenGoing ) / auctionLength )\r\n            return\r\n                _auctionStartPrice.sub(\r\n                    (_auctionStartPrice.sub(auctionEndPrice))\r\n                        .mul(now.sub(tokenAuctionBeginTimestamp[tokenId]))\r\n                        .div(auctionLength)\r\n                );\r\n        }\r\n    }\r\n\r\n    function buy(\r\n        uint256 tokenId,\r\n        uint256 _newPrice,\r\n        uint256 previousPrice,\r\n        uint256 wildcardsPercentage\r\n    )\r\n        public\r\n        payable\r\n        collectPatronageAndSettleBenefactor(tokenId)\r\n        collectPatronagePatron(msg.sender)\r\n        priceGreaterThanZero(_newPrice)\r\n        youCurrentlyAreNotInDefault(msg.sender)\r\n        validWildcardsPercentage(wildcardsPercentage, tokenId)\r\n    {\r\n        require(state[tokenId] == StewardState.Owned, \"token on auction\");\r\n        require(\r\n            price[tokenId] == previousPrice,\r\n            \"must specify current price accurately\"\r\n        );\r\n\r\n        _distributePurchaseProceeds(tokenId);\r\n\r\n        wildcardsPercentages[tokenId] = wildcardsPercentage;\r\n        uint256 remainingValueForDeposit = msg.value.sub(price[tokenId]);\r\n        deposit[msg.sender] = deposit[msg.sender].add(remainingValueForDeposit);\r\n        transferAssetTokenTo(\r\n            tokenId,\r\n            assetToken.ownerOf(tokenId),\r\n            msg.sender,\r\n            _newPrice\r\n        );\r\n        emit Buy(tokenId, msg.sender, _newPrice);\r\n    }\r\n\r\n    function buyAuction(\r\n        uint256 tokenId,\r\n        uint256 _newPrice,\r\n        uint256 wildcardsPercentage\r\n    )\r\n        public\r\n        payable\r\n        collectPatronageAndSettleBenefactor(tokenId)\r\n        collectPatronagePatron(msg.sender)\r\n        priceGreaterThanZero(_newPrice)\r\n        youCurrentlyAreNotInDefault(msg.sender)\r\n        validWildcardsPercentage(wildcardsPercentage, tokenId)\r\n    {\r\n        require(\r\n            state[tokenId] == StewardState.Foreclosed,\r\n            \"token not foreclosed\"\r\n        );\r\n        require(now >= tokenAuctionBeginTimestamp[tokenId], \"not on auction\");\r\n        uint256 auctionTokenPrice = _auctionPrice(tokenId);\r\n        uint256 remainingValueForDeposit = msg.value.sub(auctionTokenPrice);\r\n\r\n        _distributeAuctionProceeds(tokenId);\r\n\r\n        state[tokenId] = StewardState.Owned;\r\n\r\n        wildcardsPercentages[tokenId] = wildcardsPercentage;\r\n        deposit[msg.sender] = deposit[msg.sender].add(remainingValueForDeposit);\r\n        transferAssetTokenTo(\r\n            tokenId,\r\n            assetToken.ownerOf(tokenId),\r\n            msg.sender,\r\n            _newPrice\r\n        );\r\n        emit Buy(tokenId, msg.sender, _newPrice);\r\n    }\r\n\r\n    function _distributeAuctionProceeds(uint256 tokenId) internal {\r\n        uint256 totalAmount = price[tokenId];\r\n        uint256 artistAmount;\r\n        if (artistPercentages[tokenId] == 0) {\r\n            artistAmount = 0;\r\n        } else {\r\n            artistAmount = totalAmount.mul(artistPercentages[tokenId]).div(\r\n                1000000\r\n            );\r\n            deposit[artistAddresses[tokenId]] = deposit[artistAddresses[tokenId]]\r\n                .add(artistAmount);\r\n        }\r\n        uint256 wildcardsAmount = totalAmount.sub(artistAmount);\r\n        deposit[admin] = deposit[admin].add(wildcardsAmount);\r\n    }\r\n\r\n    function _distributePurchaseProceeds(uint256 tokenId) internal {\r\n        uint256 totalAmount = price[tokenId];\r\n        address tokenPatron = assetToken.ownerOf(tokenId);\r\n        // Wildcards percentage calc\r\n        if (wildcardsPercentages[tokenId] == 0) {\r\n            wildcardsPercentages[tokenId] = 50000;\r\n        }\r\n        uint256 wildcardsAmount = totalAmount\r\n            .mul(wildcardsPercentages[tokenId])\r\n            .div(1000000);\r\n\r\n        // Artist percentage calc\r\n        uint256 artistAmount;\r\n        if (artistPercentages[tokenId] == 0) {\r\n            artistAmount = 0;\r\n        } else {\r\n            artistAmount = totalAmount.mul(artistPercentages[tokenId]).div(\r\n                1000000\r\n            );\r\n            deposit[artistAddresses[tokenId]] = deposit[artistAddresses[tokenId]]\r\n                .add(artistAmount);\r\n        }\r\n\r\n        uint256 previousOwnerProceedsFromSale = totalAmount\r\n            .sub(wildcardsAmount)\r\n            .sub(artistAmount);\r\n        if (\r\n            totalPatronOwnedTokenCost[tokenPatron] ==\r\n            price[tokenId].mul(patronageNumerator[tokenId])\r\n        ) {\r\n            previousOwnerProceedsFromSale = previousOwnerProceedsFromSale.add(\r\n                deposit[tokenPatron]\r\n            );\r\n            deposit[tokenPatron] = 0;\r\n            address payable payableCurrentPatron = address(\r\n                uint160(tokenPatron)\r\n            );\r\n            (bool transferSuccess, ) = payableCurrentPatron\r\n                .call\r\n                .gas(2300)\r\n                .value(previousOwnerProceedsFromSale)(\"\");\r\n            if (!transferSuccess) {\r\n                deposit[tokenPatron] = deposit[tokenPatron].add(\r\n                    previousOwnerProceedsFromSale\r\n                );\r\n            }\r\n        } else {\r\n            deposit[tokenPatron] = deposit[tokenPatron].add(\r\n                previousOwnerProceedsFromSale\r\n            );\r\n        }\r\n\r\n        deposit[admin] = deposit[admin].add(wildcardsAmount);\r\n    }\r\n\r\n    function changePrice(uint256 tokenId, uint256 _newPrice)\r\n        public\r\n        onlyPatron(tokenId)\r\n        collectPatronageAndSettleBenefactor(tokenId)\r\n    {\r\n        require(state[tokenId] != StewardState.Foreclosed, \"foreclosed\");\r\n        require(_newPrice != 0, \"incorrect price\");\r\n        require(_newPrice < 10000 ether, \"exceeds max price\");\r\n\r\n        uint256 oldPriceScaled = price[tokenId].mul(\r\n            patronageNumerator[tokenId]\r\n        );\r\n        uint256 newPriceScaled = _newPrice.mul(patronageNumerator[tokenId]);\r\n        address tokenBenefactor = benefactors[tokenId];\r\n\r\n        totalPatronOwnedTokenCost[msg.sender] = totalPatronOwnedTokenCost[msg\r\n            .sender]\r\n            .sub(oldPriceScaled)\r\n            .add(newPriceScaled);\r\n\r\n        totalBenefactorTokenNumerator[tokenBenefactor] = totalBenefactorTokenNumerator[tokenBenefactor]\r\n            .sub(oldPriceScaled)\r\n            .add(newPriceScaled);\r\n\r\n        price[tokenId] = _newPrice;\r\n        emit PriceChange(tokenId, price[tokenId]);\r\n    }\r\n\r\n    function withdrawDeposit(uint256 _wei)\r\n        public\r\n        collectPatronagePatron(msg.sender)\r\n        returns (uint256)\r\n    {\r\n        _withdrawDeposit(_wei);\r\n    }\r\n\r\n    function withdrawBenefactorFunds() public {\r\n        withdrawBenefactorFundsTo(msg.sender);\r\n    }\r\n\r\n    function exit() public collectPatronagePatron(msg.sender) {\r\n        _withdrawDeposit(deposit[msg.sender]);\r\n    }\r\n\r\n    function _withdrawDeposit(uint256 _wei) internal {\r\n        require(deposit[msg.sender] >= _wei, \"withdrawing too much\");\r\n\r\n        deposit[msg.sender] = deposit[msg.sender].sub(_wei);\r\n\r\n        (bool transferSuccess, ) = msg.sender.call.gas(2300).value(_wei)(\"\");\r\n        if (!transferSuccess) {\r\n            revert(\"withdrawal failed\");\r\n        }\r\n    }\r\n\r\n    function _foreclose(uint256 tokenId) internal {\r\n        address currentOwner = assetToken.ownerOf(tokenId);\r\n        resetTokenOnForeclosure(tokenId, currentOwner);\r\n        state[tokenId] = StewardState.Foreclosed;\r\n\r\n        emit Foreclosure(currentOwner, timeLastCollectedPatron[currentOwner]);\r\n    }\r\n\r\n    function transferAssetTokenTo(\r\n        uint256 tokenId,\r\n        address _currentOwner,\r\n        address _newOwner,\r\n        uint256 _newPrice\r\n    ) internal {\r\n        require(_newPrice < 10000 ether, \"exceeds max price\");\r\n\r\n        uint256 scaledOldPrice = price[tokenId].mul(\r\n            patronageNumerator[tokenId]\r\n        );\r\n        uint256 scaledNewPrice = _newPrice.mul(patronageNumerator[tokenId]);\r\n\r\n        totalPatronOwnedTokenCost[_newOwner] = totalPatronOwnedTokenCost[_newOwner]\r\n            .add(scaledNewPrice);\r\n        totalPatronTokenGenerationRate[_newOwner] = totalPatronTokenGenerationRate[_newOwner]\r\n            .add(globalTokenGenerationRate);\r\n\r\n        address tokenBenefactor = benefactors[tokenId];\r\n        totalBenefactorTokenNumerator[tokenBenefactor] = totalBenefactorTokenNumerator[tokenBenefactor]\r\n            .add(scaledNewPrice);\r\n\r\n        if (_currentOwner != address(this) && _currentOwner != address(0)) {\r\n            totalPatronOwnedTokenCost[_currentOwner] = totalPatronOwnedTokenCost[_currentOwner]\r\n                .sub(scaledOldPrice);\r\n\r\n            totalPatronTokenGenerationRate[_currentOwner] = totalPatronTokenGenerationRate[_currentOwner]\r\n                .sub(globalTokenGenerationRate);\r\n\r\n            totalBenefactorTokenNumerator[tokenBenefactor] = totalBenefactorTokenNumerator[tokenBenefactor]\r\n                .sub(scaledOldPrice);\r\n        }\r\n\r\n        assetToken.transferFrom(_currentOwner, _newOwner, tokenId);\r\n\r\n        price[tokenId] = _newPrice;\r\n    }\r\n\r\n    function resetTokenOnForeclosure(uint256 tokenId, address _currentOwner)\r\n        internal\r\n    {\r\n        uint256 scaledPrice = price[tokenId].mul(patronageNumerator[tokenId]);\r\n\r\n        totalPatronOwnedTokenCost[_currentOwner] = totalPatronOwnedTokenCost[_currentOwner]\r\n            .sub(scaledPrice);\r\n\r\n        totalPatronTokenGenerationRate[_currentOwner] = totalPatronTokenGenerationRate[_currentOwner]\r\n            .sub((globalTokenGenerationRate));\r\n\r\n        address tokenBenefactor = benefactors[tokenId];\r\n        totalBenefactorTokenNumerator[tokenBenefactor] = totalBenefactorTokenNumerator[tokenBenefactor]\r\n            .sub(scaledPrice);\r\n\r\n        assetToken.transferFrom(_currentOwner, address(this), tokenId);\r\n    }\r\n}"}}}