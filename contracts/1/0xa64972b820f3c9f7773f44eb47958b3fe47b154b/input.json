{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BFX_Pair_Staking.sol":{"content":"pragma solidity ^0.5.4;\r\n\r\ncontract BFX_Pair_Staking {\r\n\r\n    using SafeMath for uint256;\r\n    \r\n    address public PairAddress          = address(0x917909fA34af61868687F57D61344Fb600E064D5);\r\n    address public bfxContractAddress   = address(0x25901F2a5A4bb0aaAbe2CDb24E0E15A0d49B015d);\r\n    address public BFX_reward_holder    = address(0x46E74d30e381684a21e392Fc55251FB6cEaFf4A1); \r\n    ERC20Contract token;\r\n    ERC20Contract pair;\r\n    \r\n    address payable _owner;\r\n    \r\n    uint public BFX_PAIR_Reward_Ratio = 1000;      //1 PAIR = 10.00 BFX per block\r\n    \r\n    uint public totalInvested = 0;\r\n    uint public totalInterest = 0;\r\n    \r\n    mapping(address => uint256) public investment;\r\n    mapping(address => uint256) public interest;\r\n    mapping(address => uint256) public lastInterestTime;\r\n    mapping(address => uint256) public totalearnedInterest;\r\n    \r\n    event stakeEvent(address _address,uint256 Amount);\r\n    event unstakeEvent(address _address,uint256 Amount);\r\n    event withdrawInterestEvent(address _address,uint256 Amount);\r\n    \r\n    constructor () public //creation settings\r\n    {\r\n        _owner              = msg.sender;\r\n        token               = ERC20Contract(bfxContractAddress);\r\n        pair                = ERC20Contract(PairAddress);\r\n \r\n    }\r\n    \r\n    function stake(uint256 amount) public {\r\n        require(amount>=0,'zero amount');\r\n        \r\n        //Check if the contract is allowed to send token on user behalf\r\n        uint256 allowance = pair.allowance(msg.sender,address(this));\r\n        require (allowance>=amount,'allowance error');\r\n\r\n        require(pair.transferFrom(msg.sender,address(this),amount),'transfer Token Error');\r\n        \r\n        if (lastInterestTime[msg.sender] == 0)\r\n            lastInterestTime[msg.sender] = block.number;\r\n        else{\r\n            interest[msg.sender] = interest[msg.sender].add(calculateInterest(msg.sender));\r\n            lastInterestTime[msg.sender] = block.number;\r\n        }\r\n            \r\n        investment[msg.sender] = investment[msg.sender].add(amount);\r\n        totalInvested = totalInvested.add(amount);\r\n        emit stakeEvent(msg.sender,amount);\r\n    }\r\n    function Unstake(uint256 amount) public {\r\n        require(lastInterestTime[msg.sender]!=0);\r\n        require(lastInterestTime[msg.sender]<=block.number);\r\n        require(amount<=investment[msg.sender],'not enough fund');\r\n        \r\n        //accumulate current Interest and set new time\r\n        interest[msg.sender] = interest[msg.sender].add(calculateInterest(msg.sender));\r\n        lastInterestTime[msg.sender] = block.number;\r\n        \r\n        investment[msg.sender] = investment[msg.sender].sub(amount);\r\n        totalInvested = totalInvested.sub(amount);\r\n        \r\n        require(pair.transfer(msg.sender, amount),'transfer Token Error');\r\n        emit unstakeEvent(msg.sender,amount);\r\n    }\r\n    function claimRewards() public {\r\n        require(lastInterestTime[msg.sender]!=0);\r\n        require(lastInterestTime[msg.sender]<block.number);\r\n        uint256 currentInterest = calculateInterest(msg.sender);\r\n        lastInterestTime[msg.sender] = block.number;\r\n        uint256 toPayReward = interest[msg.sender]+currentInterest;\r\n        interest[msg.sender] = 0;\r\n        \r\n        require(token.transferFrom(BFX_reward_holder,msg.sender, toPayReward),'transfer Token Error');\r\n        \r\n        emit withdrawInterestEvent(msg.sender,toPayReward);\r\n        totalInterest = totalInterest.add(toPayReward);\r\n        totalearnedInterest[msg.sender] = totalearnedInterest[msg.sender].add(toPayReward);\r\n        \r\n    }\r\n    //interest from last withdrawTime\r\n    function calculateInterest(address account) public view returns(uint256){\r\n        if (lastInterestTime[account]==0) return 0;\r\n        if (lastInterestTime[account]>=block.number) return 0;\r\n        uint256 stakingDuration = block.number.sub(lastInterestTime[account]);  //in seconds\r\n        \r\n        return investment[account].mul(BFX_PAIR_Reward_Ratio.mul(stakingDuration).div(100));\r\n        \r\n    }\r\n    function getContractBalance() public view returns(uint256 _contractBalance) {\r\n        return pair.balanceOf(address(this));\r\n    }\r\n    //Setters\r\n    \r\n    function setBFXaddress(address _newAddress) public onlyOwner() {\r\n        bfxContractAddress = _newAddress;\r\n        token              = ERC20Contract(bfxContractAddress);\r\n    }\r\n    function setPairAddress(address _newPairAddress) public onlyOwner() {\r\n        PairAddress         = _newPairAddress;\r\n        pair                = ERC20Contract(PairAddress);\r\n    }\r\n    function setBFX_ETH_Reward(uint _newBFX_PAIR_Reward_Ratio) public onlyOwner() {\r\n        BFX_PAIR_Reward_Ratio = _newBFX_PAIR_Reward_Ratio;\r\n    }\r\n    function setBFX_Reward_Holder(address _newHolder) public onlyOwner() {\r\n        BFX_reward_holder = _newHolder;\r\n    }\r\n    \r\n    \r\n    modifier onlyOwner(){\r\n        require(msg.sender==_owner,'Not Owner');\r\n        _;\r\n    }\r\n    function getOwner() public view returns(address ) {\r\n        return _owner;\r\n    }\r\n    //Protect the pool in case of hacking\r\n    function kill() onlyOwner public {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        token.transfer(_owner, balance);\r\n        pair.transfer(_owner, balance);\r\n        selfdestruct(_owner);\r\n    }\r\n    function transferFundBFX(uint256 amount) onlyOwner public {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(amount<=balance,'exceed contract balance');\r\n        token.transfer(_owner, amount);\r\n    }\r\n    function transferFundPair(uint256 amount) onlyOwner public {\r\n        uint256 balance = pair.balanceOf(address(this));\r\n        require(amount<=balance,'exceed contract balance');\r\n        pair.transfer(_owner, amount);\r\n    }\r\n    function transferOwnership(address payable _newOwner) onlyOwner external {\r\n        require(_newOwner != address(0) && _newOwner != _owner);\r\n        _owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20Contract\r\n{\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n}\r\n// ----------------------------------------------------------------------------\r\n\r\n// Safe maths\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n\r\n        c = a + b;\r\n\r\n        require(c >= a);\r\n\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n\r\n        require(b <= a);\r\n\r\n        c = a - b;\r\n\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n\r\n        c = a * b;\r\n\r\n        require(a == 0 || c / a == b);\r\n\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n\r\n        require(b > 0);\r\n\r\n        c = a / b;\r\n\r\n    }\r\n\r\n}"}}}