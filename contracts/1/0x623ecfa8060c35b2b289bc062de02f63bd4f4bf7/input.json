{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/Token.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n// pragma experimental SMTChecker;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this;\n        return msg.data;\n    }\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\ncontract DiamondHandsToken is ERC20(\"DiamondHands\", unicode\"ðŸ’ŽðŸ™Œ\") {\n    //// constants\n\n    // balance has to be 100 tokens to become a diamond member who can:\n    // - invite people and get bonus from their purchases\n    // - buy extra tokens cheaper\n    uint256 constant MINIMUM_DIAMOND_MEMBER_BALANCE = 100 * 1e18;\n    // diamond members get 20% discount on purchases above 100 tokens\n    uint256 constant DIAMOND_MEMBER_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND = 200;\n    // diamond members get 10% extra bonus tokens from people they invited, \n    // until those become diamond members themselves\n    uint256 constant DIAMOND_MEMBER_INTRODUCER_BONUS_TOKENS_PER_THOUSAND = 100;\n    // invited people get 10% discount on purchases,\n    // until they become diamond members and get 20% diamond discount\n    uint256 constant INVITED_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND = 100;\n\n    // Price growth\n    // - the price grows 5% upon every iteration\n    // - new iteration lasts 30-90 minutes and starts:\n    //   * either after 100 tokens were bought in the current iteration (fast growth due to popularity),\n    //   * or, if somebody buys or sells tokens after 90 minutes of no growth (slow growth)\n\n    // initial token price is 0.001 ETH per token\n    uint256 constant INITIAL_PRICE_ETH_WEI = 1e15;\n    // for non-diamond and non-invited members the purchase price is sell price + 80%\n    uint256 constant PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND = 1800;\n    // price grows 5% each iteration\n    uint256 constant PRICE_GROWTH_MULTIPLIER_PER_THOUSAND = 1050;\n    // maximum speed that the price can grow is once per 30 minutes\n    uint256 constant MINIMUM_GROWTH_ITERATION_PERIOD = 30 minutes;\n    // after 90 minutes of no growth (low activity), the price will still grow\n    uint256 constant SLOW_GROWTH_ITERATION_PERIOD = 90 minutes;\n    // at least 100 tokens have to be sold for fast growth\n    uint256 constant FAST_GROWTH_THRESHOLD = 100 * 1e18;\n    \n    //// events\n    event NewPrice(uint256 timestamp, uint256 newPrice);\n\n    //// state\n    mapping (address => address) private _introducers;\n    uint256 private _sellPriceEthWei;\n    uint256 private _lastPriceGrowthTimestamp;\n    uint256 private _purchasedTokensForFastGrowthSoFar = 0;\n    \n    //// private\n    constructor() payable {\n        emit NewPrice(\n            _lastPriceGrowthTimestamp = block.timestamp,\n            _sellPriceEthWei = INITIAL_PRICE_ETH_WEI\n            );\n        // no pre-mine\n    }\n\n    function _isDiamondMember(address member) private view returns(bool) {\n        return balanceOf(member) >= MINIMUM_DIAMOND_MEMBER_BALANCE;\n    }\n    function _registerUnderIntroducer(address introducer) private {\n        require(msg.sender != introducer,\n            \"Members cannot introduce themselves\");\n        require(_introducers[msg.sender] == address(0) || _introducers[msg.sender] == introducer, \n            \"Introducer cannot be changed later\");\n        require(_isDiamondMember(introducer), \n            \"Provided introducer address is not a Diamond member at this moment\");\n        _introducers[msg.sender] = introducer;\n    }\n    function _growIfAccumulatedEnough(uint256 amountBought) private {\n        // check if we should make the price grow\n        uint256 accumulated = _purchasedTokensForFastGrowthSoFar + amountBought;\n        uint256 lastPriceGrowthTimestamp = _lastPriceGrowthTimestamp;\n        uint256 blockTimestamp = block.timestamp;\n        if (\n            // fast growth condition\n            (accumulated > FAST_GROWTH_THRESHOLD\n            && (lastPriceGrowthTimestamp + MINIMUM_GROWTH_ITERATION_PERIOD) <= blockTimestamp)\n            ||\n            // slow growth condition\n            (lastPriceGrowthTimestamp + SLOW_GROWTH_ITERATION_PERIOD) <= blockTimestamp\n            ) {\n            // start new iteration with new price\n            _purchasedTokensForFastGrowthSoFar = 0;\n            emit NewPrice(\n                _lastPriceGrowthTimestamp = blockTimestamp,\n                _sellPriceEthWei = _sellPriceEthWei * PRICE_GROWTH_MULTIPLIER_PER_THOUSAND / 1000\n                );\n        }\n        else {\n            _purchasedTokensForFastGrowthSoFar = accumulated;\n        }\n    }\n    function _sell(uint256 amount) private {\n        uint256 sellPriceEthWei = _sellPriceEthWei;\n        _growIfAccumulatedEnough(0);\n        _burn(msg.sender, amount);\n        payable(msg.sender).transfer(amount * sellPriceEthWei / 1e18);\n    }\n    function _buy(uint256 ethWeiAmount) private {\n        uint256 sellPriceEthWei = _sellPriceEthWei;\n        uint256 amountBought = 0;\n        uint256 myBalance = balanceOf(msg.sender);\n        address introducer = _introducers[msg.sender];\n\n        // if not a diamond member yet, buy at non-diamond price\n        if (myBalance < MINIMUM_DIAMOND_MEMBER_BALANCE) {\n            uint256 nonDiamondBuyPriceInEthWei = \n                introducer != address(0) \n                    // if we have an introducer, get a discounted price\n                    ? (sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND * (1000 - INVITED_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND) \n                        / (1000 * 1000))\n                    // else get a normal price\n                    : (sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND / 1000);\n            uint256 amountAtThisPrice = ethWeiAmount * 1e18 / nonDiamondBuyPriceInEthWei;\n\n            // if didn't become a diamond member while buying\n            if (myBalance + amountAtThisPrice <= MINIMUM_DIAMOND_MEMBER_BALANCE) {\n                // buy the whole amount\n                amountBought = amountAtThisPrice;\n                ethWeiAmount = 0;\n            }\n            else {\n                // buy just enough to become a diamond member, and buy the rest at diamond price\n                amountBought = MINIMUM_DIAMOND_MEMBER_BALANCE - myBalance;\n                ethWeiAmount -= amountBought * nonDiamondBuyPriceInEthWei / 1e18;\n            }\n        }\n\n        // if still have money at this point, buy at diamond price\n        if (ethWeiAmount > 0) {\n            uint256 diamondBuyPriceInEthWei = \n                (sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND * (1000 - DIAMOND_MEMBER_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND) \n                        / (1000 * 1000));\n            amountBought += ethWeiAmount * 1e18 / diamondBuyPriceInEthWei;\n        }\n\n        // grow the price\n        _growIfAccumulatedEnough(amountBought);\n        // mint the tokens\n        _mint(msg.sender, amountBought);\n        // mint tokens for the introducer\n        if (introducer != address(0)) {\n            _mint(introducer, amountBought * DIAMOND_MEMBER_INTRODUCER_BONUS_TOKENS_PER_THOUSAND / 1000);\n        }\n    }\n\n    //// view\n    function haveIntroducer() public view returns(bool) { return _introducers[msg.sender] != address(0); }\n    function amDiamondMember() public view returns(bool) { return _isDiamondMember(msg.sender); }\n    function getSellPrice() public view returns(uint256) { return _sellPriceEthWei; }\n    function getBasicBuyPrice() public view returns(uint256) {\n        return _sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND / 1000;\n    }\n    function getBuyPriceWithMyDiscounts() public view returns(uint256) {\n        if (_isDiamondMember(msg.sender)) {\n            return \n                _sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND * (1000 - DIAMOND_MEMBER_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND) \n                / (1000 * 1000);\n        }\n        else if (_introducers[msg.sender] != address(0)) {\n            return\n                _sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND * (1000 - INVITED_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND) \n                / (1000 * 1000);\n        }\n        else {\n            return _sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND / 1000;\n        }\n    }\n    function getTokensBoughtAfterLastGrowth() public view returns(uint256) { return _purchasedTokensForFastGrowthSoFar; }\n    function getUiState() public view returns(\n        uint256 secondsElapsed, \n        uint256 tokensSold, \n        uint256 sellPrice, \n        uint256 buyPriceBasic, \n        uint256 buyPricePersonal, \n        uint256 balance, \n        bool invited, \n        bool diamond) {\n        return (\n            block.timestamp - _lastPriceGrowthTimestamp,\n            _purchasedTokensForFastGrowthSoFar,\n            _sellPriceEthWei,\n            getBasicBuyPrice(),\n            getBuyPriceWithMyDiscounts(),\n            balanceOf(msg.sender),\n            haveIntroducer(),\n            amDiamondMember()\n            );\n    }\n\n    //// callable from outside\n    function totalSupply() public view virtual override returns (uint256) {\n        return address(this).balance * 1e18 / _sellPriceEthWei;\n    }\n    function buy() external payable {\n        require(msg.value > 0,\n            \"Please send ETH to purchase tokens\");\n        _buy(msg.value);\n    }\n    function buyAndRegisterUnderIntroducer(address introducer) external payable {\n        require(msg.value > 0,\n            \"Please send ETH to purchase tokens\");\n        require(introducer != address(0),\n            \"Please specify an introducer to register under\");\n        _registerUnderIntroducer(introducer);\n        _buy(msg.value);\n    }\n    function sell(uint256 amount) external {\n        require(amount > 0,\n            \"Please provide the amount of tokens to sell\");\n        _sell(amount);\n    }\n    function sellAll() external {\n        uint256 balance = balanceOf(msg.sender);\n        require(balance > 0,\n            \"You don't have any tokens to sell\");\n        _sell(balance);\n    }\n}\n"
    }
  }
}