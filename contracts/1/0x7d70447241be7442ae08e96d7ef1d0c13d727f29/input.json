{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "InvestmentPool.sol": {
      "content": "/*\r\n * This file was generated by MyWish Platform (https://mywish.io/)\r\n * The complete code could be found at https://github.com/MyWishPlatform/\r\n * Copyright (C) 2020 MyWish\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Helps contracts guard agains reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private reentrancyLock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!reentrancyLock);\r\n    reentrancyLock = true;\r\n    _;\r\n    reentrancyLock = false;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n* @title Contract that will work with ERC223 tokens.\r\n*/\r\ncontract ERC223Receiver {\r\n  /**\r\n   * @dev Standard ERC223 function that will handle incoming token transfers.\r\n   *\r\n   * @param _from  Token sender address.\r\n   * @param _value Amount of tokens.\r\n   * @param _data  Transaction metadata.\r\n   */\r\n  function tokenFallback(address _from, uint _value, bytes _data) public;\r\n}\r\n\r\n\r\n/**\r\n * @title BaseInvestmentPool\r\n * @dev The contract that contains base investment pool functionality:\r\n *      apply funds, send it investment address, withdraw tokens.\r\n */\r\ncontract BaseInvestmentPool is Ownable, ReentrancyGuard, ERC223Receiver {\r\n  using SafeMath for uint;\r\n\r\n  /**\r\n   * @notice how much tokens each investor withdrawn from investment pool.\r\n   */\r\n  mapping(address => uint) public tokensWithdrawnByInvestor;\r\n\r\n  /**\r\n   * @notice how much funds each investor sent to investment pool.\r\n   */\r\n  mapping(address => uint) public investments;\r\n\r\n  /**\r\n   * @notice all funds will be sent to this address when soft cap will be reached.\r\n   */\r\n  address public investmentAddress;\r\n\r\n  /**\r\n   * @notice address of token contract from which tokens will be transferred to investment pool.\r\n   */\r\n  address public tokenAddress;\r\n\r\n  /**\r\n   * @notice how much tokens all investors withdrawn from contract.\r\n   */\r\n  uint public tokensWithdrawn;\r\n\r\n  /**\r\n   * @notice how much tokens contract owner withdrawn from his reward part.\r\n   */\r\n  uint public rewardWithdrawn;\r\n\r\n  /**\r\n   * @notice  how much tokens will receive contract owner.\r\n   *          Owner will receive (rewardPermille * all collected tokens / 1000).\r\n   */\r\n  uint public rewardPermille;\r\n\r\n  /**\r\n   * @notice how much wei already collected on contract.\r\n   */\r\n  uint public weiRaised;\r\n\r\n  /**\r\n   * @notice is money already sent to investment address.\r\n   */\r\n  bool public isFinalized;\r\n\r\n  /**\r\n   * @notice emitted when funds is transferred to investmentAddress.\r\n   */\r\n  event Finalized();\r\n\r\n  /**\r\n   * @notice emitted when investor sends funds to this contract.\r\n   *\r\n   * @param investor  investor address.\r\n   * @param amount    wei amount.\r\n   */\r\n  event Invest(address indexed investor, uint amount);\r\n\r\n  /**\r\n   * @notice emitted when investor takes him tokens from the contract.\r\n   *\r\n   * @param investor  investor address.\r\n   * @param amount    token amount.\r\n   */\r\n  event WithdrawTokens(address indexed investor, uint amount);\r\n\r\n  /**\r\n   * @notice emitted when contract owner takes him tokens from the contract.\r\n   *\r\n   * @param owner   contract owner.\r\n   * @param amount  token amount.\r\n   */\r\n  event WithdrawReward(address indexed owner, uint amount);\r\n\r\n  /**\r\n   * @notice emitted when contract owner sets investment address.\r\n   *\r\n   * @param investmentAddress investment address.\r\n   */\r\n  event SetInvestmentAddress(address indexed investmentAddress);\r\n\r\n  /**\r\n   * @notice emitted when contract owner sets token address.\r\n   *\r\n   * @param tokenAddress token address.\r\n   */\r\n  event SetTokenAddress(address indexed tokenAddress);\r\n\r\n  /**\r\n   * @param _owner              who will own the InvestmentPool contract.\r\n   * @param _investmentAddress  address to which the funds will be sent after successful collection on the contract.\r\n   * @param _tokenAddress       the address of the contract token whose token we want to receive.\r\n   * @param _rewardPermille     owner of contract will receive (_rewardPermille / 1000 * all tokens collected) as a fee.\r\n   */\r\n  constructor(\r\n    address _owner,\r\n    address _investmentAddress,\r\n    address _tokenAddress,\r\n    uint _rewardPermille\r\n  )\r\n    public\r\n  {\r\n    require(_owner != address(0), \"owner address should not be null\");\r\n    require(_rewardPermille < 1000, \"rate should be less than 1000\");\r\n    owner = _owner;\r\n    investmentAddress = _investmentAddress;\r\n    tokenAddress = _tokenAddress;\r\n    rewardPermille = _rewardPermille;\r\n  }\r\n\r\n  /**\r\n   * @notice sends all funds to investmentAddress.\r\n   */\r\n  function finalize() external nonReentrant {\r\n    require(!isFinalized, \"pool is already finalized\");\r\n    _preValidateFinalization();\r\n    // solium-disable-next-line security/no-call-value\r\n    require(investmentAddress.call.value(weiRaised)(), \"error when sending funds to ICO\");\r\n    isFinalized = true;\r\n    emit Finalized();\r\n  }\r\n\r\n  /**\r\n   * @notice withdraws sender's tokens.\r\n   */\r\n  function withdrawTokens() external nonReentrant {\r\n    require(msg.sender == owner || investments[msg.sender] != 0, \"you are not owner and not investor\");\r\n    if (investments[msg.sender] != 0) {\r\n      _withdrawInvestorTokens(msg.sender);\r\n    }\r\n    if (msg.sender == owner && rewardPermille != 0) {\r\n      _withdrawOwnerTokens();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice token receiver fallback function for compatibility with ERC223. Applies ERC223 tokens from ICO.\r\n   */\r\n  function tokenFallback(address, uint, bytes) public {\r\n    require(msg.sender == tokenAddress, \"allowed receive tokens only from target ICO\");\r\n  }\r\n\r\n  /**\r\n   * @notice apply funds from investor.\r\n   *\r\n   * @param _beneficiary investor.\r\n   */\r\n  function invest(address _beneficiary) public payable {\r\n    uint amount = msg.value;\r\n    _preValidateInvest(_beneficiary, amount);\r\n    weiRaised = weiRaised.add(amount);\r\n    investments[_beneficiary] = investments[_beneficiary].add(amount);\r\n    emit Invest(_beneficiary, amount);\r\n  }\r\n\r\n  /**\r\n   * @notice sets investments address if it was not set early.\r\n   *\r\n   * @param _investmentAddress investment address to set.\r\n   */\r\n  function setInvestmentAddress(address _investmentAddress) public onlyOwner {\r\n    require(investmentAddress == address(0), \"investment address already set\");\r\n    investmentAddress = _investmentAddress;\r\n    emit SetInvestmentAddress(_investmentAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice sets token address if it was not set early.\r\n   *\r\n   * @param _tokenAddress token address to set.\r\n   */\r\n  function setTokenAddress(address _tokenAddress) public onlyOwner {\r\n    require(tokenAddress == address(0), \"token address already set\");\r\n    tokenAddress = _tokenAddress;\r\n    emit SetTokenAddress(_tokenAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice withdraws investors's part of tokens.\r\n   */\r\n  function _withdrawInvestorTokens(address _investor) internal {\r\n    uint tokenAmount = _getInvestorTokenAmount(_investor);\r\n    require(tokenAmount != 0, \"contract have no tokens for you\");\r\n    _transferTokens(_investor, tokenAmount);\r\n    tokensWithdrawnByInvestor[_investor] = tokensWithdrawnByInvestor[_investor].add(tokenAmount);\r\n    emit WithdrawTokens(_investor, tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice withdraws owner's percent of tokens.\r\n   */\r\n  function _withdrawOwnerTokens() internal {\r\n    require(isFinalized, \"contract not finalized yet\");\r\n    uint tokenAmount = _getRewardTokenAmount();\r\n    require(tokenAmount != 0, \"contract have no tokens for you\");\r\n    _transferTokens(owner, tokenAmount);\r\n    rewardWithdrawn = rewardWithdrawn.add(tokenAmount);\r\n    emit WithdrawReward(owner, tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @return how much tokens will owner receive.\r\n   */\r\n  function _getRewardTokenAmount() internal view returns (uint) {\r\n    uint tokenRaised = ERC20Basic(tokenAddress).balanceOf(this).add(tokensWithdrawn);\r\n    uint tokenAmount = tokenRaised.mul(rewardPermille).div(1000);\r\n    return tokenAmount.sub(rewardWithdrawn);\r\n  }\r\n\r\n  /**\r\n   * @param _investor investor address.\r\n   * @return how much tokens will investor receive.\r\n   */\r\n  function _getInvestorTokenAmount(address _investor) internal view returns (uint) {\r\n    uint tokenRaised = ERC20Basic(tokenAddress).balanceOf(this).add(tokensWithdrawn);\r\n    uint investedAmount = investments[_investor];\r\n    uint tokenAmount = investedAmount.mul(tokenRaised).mul(1000 - rewardPermille).div(weiRaised.mul(1000));\r\n    return tokenAmount.sub(tokensWithdrawnByInvestor[_investor]);\r\n  }\r\n\r\n  /**\r\n   * @notice transfers tokens to investor.\r\n   *\r\n   * @param _investor investor address.\r\n   * @param _amount   token amount to transfer.\r\n   */\r\n  function _transferTokens(address _investor, uint _amount) internal {\r\n    ERC20Basic(tokenAddress).transfer(_investor, _amount);\r\n    tokensWithdrawn = tokensWithdrawn.add(_amount);\r\n  }\r\n\r\n  /**\r\n   * @notice validates transaction before applying funds from investor.\r\n   *\r\n   * @param _beneficiary  investor address.\r\n   * @param _amount       wei amount investor send.\r\n   */\r\n  function _preValidateInvest(address _beneficiary, uint _amount) internal {\r\n    require(_beneficiary != address(0), \"cannot invest from null address\");\r\n    require(!isFinalized, \"contract is already finalized\");\r\n  }\r\n\r\n  /**\r\n   * @notice validates transaction before sending funds to ICO.\r\n   */\r\n  function _preValidateFinalization() internal {\r\n    require(investmentAddress != address(0), \"investment address did not set\");\r\n    require(tokenAddress != address(0), \"token address did not set\");\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title CancellableInvestmentPool\r\n * @dev The contract extends BaseInvestmentPool and adds additional functionality: owner can cancel fundraising.\r\n */\r\ncontract CancellableInvestmentPool is BaseInvestmentPool {\r\n  /**\r\n   * @notice is contract owner cancelled fundraising.\r\n   */\r\n  bool public isCancelled;\r\n\r\n  /**\r\n   * @notice emitted when contract owner cancelled fundraising.\r\n   */\r\n  event Cancelled();\r\n\r\n  /**\r\n   * @notice sets contract to cancelled state. No one can contribute funds to contract ins this state.\r\n   */\r\n  function cancel() public onlyOwner {\r\n    require(!isCancelled, \"pool is already cancelled\");\r\n    _preValidateCancellation();\r\n    isCancelled = true;\r\n    emit Cancelled();\r\n  }\r\n\r\n  /**\r\n   * @notice validates contract's state before cancellation.\r\n   */\r\n  function _preValidateCancellation() internal {\r\n    require(!isFinalized, \"pool is finalized\");\r\n  }\r\n\r\n  /**\r\n   * @notice validates contract's state before finalization.\r\n   */\r\n  function _preValidateFinalization() internal {\r\n    super._preValidateFinalization();\r\n    require(!isCancelled, \"pool is cancelled\");\r\n  }\r\n\r\n  /**\r\n   * @notice validates contract state before applying users funds.\r\n   */\r\n  function _preValidateInvest(address _beneficiary, uint _amount) internal {\r\n    super._preValidateInvest(_beneficiary, _amount);\r\n    require(!isCancelled, \"contract is already cancelled\");\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title TimedInvestmentPool\r\n * @dev The contract extends BaseInvestmentPool and adds additional functionality:\r\n *      investors can send funds to the contract only in specified time and it's able to send funds to investment\r\n *      address only before specified time (endTime).\r\n */\r\ncontract TimedInvestmentPool is BaseInvestmentPool {\r\n  /**\r\n   * @notice start time when investors allowed to contribute funds to the contract.\r\n   */\r\n  uint public startTime;\r\n\r\n  /**\r\n   * @notice end time when investors allowed to contribute funds to the contract.\r\n   */\r\n  uint public endTime;\r\n\r\n  /**\r\n   * @param _startTime  start time when investors allowed to contribute funds to the contract.\r\n   * @param _endTime    end time when investors allowed to contribute funds to the contract.\r\n   */\r\n  constructor(uint _startTime, uint _endTime) public {\r\n    require(_startTime < _endTime, \"start time should be before end time\");\r\n    startTime = _startTime;\r\n    endTime = _endTime;\r\n  }\r\n\r\n  /**\r\n   * @return start time has already come\r\n   */\r\n  function hasStarted() public view returns (bool) {\r\n    return now >= startTime;\r\n  }\r\n\r\n  /**\r\n   * @return end time has not yet come\r\n   */\r\n  function hasEnded() public view returns (bool) {\r\n    return now >= endTime;\r\n  }\r\n\r\n  /**\r\n   * @notice validates investor's transactions and contract state before applying investors funds.\r\n   */\r\n  function _preValidateInvest(address _beneficiary, uint _amount) internal {\r\n    super._preValidateInvest(_beneficiary, _amount);\r\n    require(hasStarted(), \"contract is not yet started\");\r\n    require(!hasEnded(), \"contract is already ended\");\r\n  }\r\n\r\n  /**\r\n   * @notice validates transaction before sending funds to ICO.\r\n   */\r\n  function _preValidateFinalization() internal {\r\n    super._preValidateFinalization();\r\n    require(!hasEnded(), \"time is out\");\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title HardCappedInvestmentPool\r\n * @dev The contract extends BaseInvestmentPool and adds additional functionality:\r\n *      contract can't raise more funds than specified cap.\r\n */\r\ncontract HardCappedInvestmentPool is BaseInvestmentPool {\r\n  /**\r\n   * @notice max wei amount that can be raised on the contract.\r\n   */\r\n  uint hardCap;\r\n\r\n  /**\r\n   * @param _hardCap max wei amount that can be raised on the contract.\r\n   */\r\n  constructor(uint _hardCap) public {\r\n    hardCap = _hardCap;\r\n  }\r\n\r\n  /**\r\n   * @return is hard cap reached.\r\n   */\r\n  function hardCapReached() public view returns (bool) {\r\n    return weiRaised >= hardCap;\r\n  }\r\n\r\n  /**\r\n   * @notice validates investor's transactions and contract state before applying investors funds.\r\n   */\r\n  function _preValidateInvest(address _beneficiary, uint _amount) internal {\r\n    super._preValidateInvest(_beneficiary, _amount);\r\n    require(!hardCapReached(), \"hard cap already reached\");\r\n    require(weiRaised.add(_amount) <= hardCap, \"cannot invest more than hard cap\");\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SoftCappedInvestmentPool\r\n * @dev The contract extends BaseInvestmentPool and adds additional functionality:\r\n *      it's able to send funds to investment address only after specified soft cap is reached.\r\n */\r\ncontract SoftCappedInvestmentPool is BaseInvestmentPool {\r\n  /**\r\n   * @notice min wei amount needed to allow send it to investment address.\r\n   */\r\n  uint softCap;\r\n\r\n  /**\r\n   * @param _softCap min wei amount needed to allow send it to investment address.\r\n   */\r\n  constructor(uint _softCap) public {\r\n    softCap = _softCap;\r\n  }\r\n\r\n  /**\r\n   * @return is soft cap reached\r\n   */\r\n  function softCapReached() public view returns (bool) {\r\n    return weiRaised >= softCap;\r\n  }\r\n\r\n  /**\r\n   * @notice validates transaction before sending funds to ICO.\r\n   */\r\n  function _preValidateFinalization() internal {\r\n    super._preValidateFinalization();\r\n    require(softCapReached(), \"soft cap did not reached yet\");\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title RefundableInvestmentPool\r\n * @dev The contract extends CancellableInvestmentPool and TimedInvestmentPool and adds additional functionality:\r\n *      investors can take their funds back if fundraising was cancelled or send time is over and funds was not be sent\r\n *      to the investment address.\r\n */\r\ncontract RefundableInvestmentPool is CancellableInvestmentPool, TimedInvestmentPool {\r\n  /**\r\n   * @notice who may execute `executeAfterFinalize` function besides owner. If it's 0x0 then only owner may.\r\n   */\r\n  address public serviceAccount;\r\n\r\n  /**\r\n   * @notice is ICO returned funds.\r\n   */\r\n  bool public isInvestmentAddressRefunded;\r\n\r\n  /**\r\n   * @notice is investment target (ICO) refunding.\r\n   */\r\n  bool private isRefundMode;\r\n\r\n  /**\r\n   * @notice emitted when investor takes him funds back.\r\n   *\r\n   * @param investor  investor address.\r\n   * @param amount    wei amount.\r\n   */\r\n  event Refund(address indexed investor, uint amount);\r\n\r\n  /**\r\n   * @notice emitted when investment target (ICO) returns funds back to InvestmentPool.\r\n   *\r\n   * @param amount refunded wei amount.\r\n   */\r\n  event ClaimRefund(uint amount);\r\n\r\n  /**\r\n   * @param _serviceAccount who may execute `executeAfterFinalize` function besides owner.\r\n   *                        If it's 0x0 then only owner may.\r\n   */\r\n  constructor(address _serviceAccount) {\r\n    serviceAccount = _serviceAccount;\r\n  }\r\n\r\n  /**\r\n   * @notice fallback function applying funds from investors or ICO.\r\n   */\r\n  function() external payable {\r\n    if (msg.sender == investmentAddress || isRefundMode) {\r\n      require(isFinalized, \"accepts transactions from investment address only after finalize\");\r\n      emit ClaimRefund(msg.value);\r\n    } else {\r\n      invest(msg.sender);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute function on contract of investment address after IPool sent funds to investmentAddress. It is for refund.\r\n   *\r\n   * @param _data call data. For example: claimRefund() - 0xb5545a3c.\r\n   */\r\n  function executeAfterFinalize(bytes _data)\r\n    external\r\n    payable\r\n    nonReentrant\r\n  {\r\n    require(msg.sender == owner || msg.sender == serviceAccount, \"only owner and service account may do this\");\r\n    require(investmentAddress != address(0), \"investment address did not set\");\r\n    require(isFinalized, \"contract not finalized yet\");\r\n    uint balanceBeforeCall = address(this).balance;\r\n    isRefundMode = true;\r\n    if (msg.value != 0) {\r\n      investmentAddress.call.value(msg.value)(_data); // solium-disable-line security/no-call-value\r\n    } else {\r\n      investmentAddress.call(_data); // solium-disable-line security/no-low-level-calls\r\n    }\r\n    isRefundMode = false;\r\n    if (address(this).balance > balanceBeforeCall) {\r\n      isInvestmentAddressRefunded = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice  user can refund his money if contract has been cancelled\r\n   *          or time was out and funds has not been sent to ICO.\r\n   */\r\n  function claimRefund() external nonReentrant {\r\n    require(investments[msg.sender] != 0, \"you are not investor\");\r\n    // solium-disable-next-line indentation\r\n    require(isCancelled || (!isFinalized && hasEnded()) || isInvestmentAddressRefunded,\r\n      \"contract has not ended, not cancelled and ico did not refunded\");\r\n    address investor = msg.sender;\r\n    uint amount = investments[investor];\r\n    investor.transfer(amount);\r\n    delete investments[investor];\r\n    emit Refund(investor, amount);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title WhitelistedInvestmentPool\r\n * @dev The contract extends BaseInvestmentPool and adds additional functionality:\r\n *      only whitelisted investors can send funds to the contract.\r\n */\r\ncontract WhitelistedInvestmentPool is BaseInvestmentPool {\r\n  /**\r\n   * @notice investors which can contribute funds to the contract.\r\n   */\r\n  mapping(address => bool) private whitelist;\r\n\r\n  /**\r\n   * @notice emitted when contract owner added new address to the whitelist.\r\n   *\r\n   * @param _address whitelisted address.\r\n   */\r\n  event WhitelistedAddressAdded(address indexed _address);\r\n\r\n  /**\r\n   * @notice emitted when contract owner removed address from the whitelist.\r\n   *\r\n   * @param _address address removed from whitelist.\r\n   */\r\n  event WhitelistedAddressRemoved(address indexed _address);\r\n\r\n  /**\r\n   * @dev throws if investor is not whitelisted.\r\n   * @param _investor address\r\n   */\r\n  modifier onlyIfWhitelisted(address _investor) {\r\n    require(whitelist[_investor]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add single address to whitelist\r\n   */\r\n  function addAddressToWhitelist(address _address) external onlyOwner {\r\n    whitelist[_address] = true;\r\n    emit WhitelistedAddressAdded(_address);\r\n  }\r\n\r\n  /**\r\n   * @dev add addresses to whitelist\r\n   */\r\n  function addAddressesToWhitelist(address[] _addresses) external onlyOwner {\r\n    for (uint i = 0; i < _addresses.length; i++) {\r\n      whitelist[_addresses[i]] = true;\r\n      emit WhitelistedAddressAdded(_addresses[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove single address from whitelist\r\n   */\r\n  function removeAddressFromWhitelist(address _address) external onlyOwner {\r\n    delete whitelist[_address];\r\n    emit WhitelistedAddressRemoved(_address);\r\n  }\r\n\r\n  /**\r\n   * @dev remove addresses from whitelist\r\n   */\r\n  function removeAddressesFromWhitelist(address[] _addresses) external onlyOwner {\r\n    for (uint i = 0; i < _addresses.length; i++) {\r\n      delete whitelist[_addresses[i]];\r\n      emit WhitelistedAddressRemoved(_addresses[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev getter to determine if address is in whitelist\r\n   */\r\n  function isWhitelisted(address _address) public view returns (bool) {\r\n    return whitelist[_address];\r\n  }\r\n\r\n  function _preValidateInvest(address _beneficiary, uint _amount) internal onlyIfWhitelisted(_beneficiary) {\r\n    super._preValidateInvest(_beneficiary, _amount);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title MaxRestrictedInvestmentPool\r\n * @dev The contract extends BaseInvestmentPool and adds additional functionality:\r\n *      investors can't send to the contract more than specified max amount in one transaction.\r\n */\r\ncontract MaxRestrictedInvestmentPool is BaseInvestmentPool {\r\n  /**\r\n   * @notice max wei amount than can be contributed in one transaction.\r\n   */\r\n  uint public maxInvestment;\r\n\r\n  /**\r\n   * @param _maxInvestment max wei amount than can be contributed in one transaction.\r\n   */\r\n  constructor(uint _maxInvestment) public {\r\n    maxInvestment = _maxInvestment;\r\n  }\r\n\r\n  /**\r\n   * @notice validates investor's transactions and contract state before applying investors funds.\r\n   */\r\n  function _preValidateInvest(address _beneficiary, uint _amount) internal {\r\n    super._preValidateInvest(_beneficiary, _amount);\r\n    require(_amount <= maxInvestment, \"too high value\");\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ChangeableTimedInvestmentPool\r\n * @dev The contract extends TimedInvestmentPool and adds additional functionality:\r\n *      owner can change start and end times.\r\n */\r\ncontract ChangeableTimedInvestmentPool is TimedInvestmentPool {\r\n  /**\r\n   * @notice emitted when contract owner shifted start or/and end time.\r\n   *\r\n   * @param startTime     new start time.\r\n   * @param endTime       new end time.\r\n   * @param oldStartTime  old start time.\r\n   * @param oldEndTime    old end time.\r\n   */\r\n  event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime);\r\n\r\n  /**\r\n   * @notice shifts the start time when contract applies funds from investors.\r\n   */\r\n  function setStartTime(uint _startTime) public onlyOwner {\r\n    // only if InvestmentPool was not started\r\n    require(now < startTime);\r\n    // only move time to future\r\n    require(_startTime > startTime);\r\n    require(_startTime < endTime);\r\n    emit TimesChanged(\r\n      _startTime,\r\n      endTime,\r\n      startTime,\r\n      endTime\r\n    );\r\n    startTime = _startTime;\r\n  }\r\n\r\n  /**\r\n   * @notice shifts the end time when contract applies funds from investors.\r\n   */\r\n  function setEndTime(uint _endTime) public onlyOwner {\r\n    // only if InvestmentPool was not ended\r\n    require(now < endTime);\r\n    // only if new end time in future\r\n    require(now < _endTime);\r\n    require(_endTime > startTime);\r\n    emit TimesChanged(\r\n      startTime,\r\n      _endTime,\r\n      startTime,\r\n      endTime\r\n    );\r\n    endTime = _endTime;\r\n  }\r\n\r\n  /**\r\n   * @notice shifts the time (start & end) when contract applies funds from investors.\r\n   */\r\n  function setTimes(uint _startTime, uint _endTime) public onlyOwner {\r\n    require(_endTime > _startTime);\r\n    uint oldStartTime = startTime;\r\n    uint oldEndTime = endTime;\r\n    bool changed = false;\r\n    if (_startTime != oldStartTime) {\r\n      require(_startTime > now);\r\n      // only if InvestmentPool was not started\r\n      require(now < oldStartTime);\r\n      // only move time to future\r\n      require(_startTime > oldStartTime);\r\n\r\n      startTime = _startTime;\r\n      changed = true;\r\n    }\r\n    if (_endTime != oldEndTime) {\r\n      // only if InvestmentPool was not ended\r\n      require(now < oldEndTime);\r\n      // end time in future\r\n      require(now < _endTime);\r\n\r\n      endTime = _endTime;\r\n      changed = true;\r\n    }\r\n\r\n    if (changed) {\r\n      emit TimesChanged(\r\n        startTime,\r\n        _endTime,\r\n        startTime,\r\n        endTime\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title InvestmentPool\r\n */\r\ncontract InvestmentPool is // solium-disable-line lbrace\r\n    SoftCappedInvestmentPool\r\n  , HardCappedInvestmentPool\r\n  , CancellableInvestmentPool\r\n  , RefundableInvestmentPool\r\n  , WhitelistedInvestmentPool\r\n  , MaxRestrictedInvestmentPool\r\n  , ChangeableTimedInvestmentPool\r\n{\r\n  /**\r\n   * @param _owner              who will own the contract.\r\n   * @param _investmentAddress  all funds will be sent to this address when soft cap will be reached.\r\n   * @param _tokenAddress       the address of the contract token whose token we want to receive.\r\n   */\r\n  constructor(\r\n    address _owner,\r\n    address _investmentAddress,\r\n    address _tokenAddress,\r\n    address _serviceAccount\r\n  )\r\n    public\r\n    BaseInvestmentPool(_owner, _investmentAddress, _tokenAddress, 50)\r\n    RefundableInvestmentPool(_serviceAccount)\r\n    SoftCappedInvestmentPool(0)\r\n    HardCappedInvestmentPool(20000000000000000000000000000)\r\n    TimedInvestmentPool(1609232185, 1609491360)\r\n    MaxRestrictedInvestmentPool(20000000000000000000000000000)\r\n  {\r\n    require(softCap <= hardCap, \"soft cap should be less than hard cap\");\r\n  }\r\n}"
    }
  }
}