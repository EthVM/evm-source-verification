{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"vestingResolver.sol":{"content":"// Sources flattened with hardhat v2.3.0 https://hardhat.org\n\n// File @openzeppelin/contracts/math/SafeMath.sol@v3.4.0-solc-0.7\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n// File contracts/InstaVestingResolver.sol\n\ninterface TokenInterface {\n    function balanceOf(address account) external view returns (uint);\n    function delegate(address delegatee) external;\n    function transfer(address dst, uint rawAmount) external returns (bool);\n}\n\ninterface InstaVestingInferface {\n    function owner() external view returns(address);\n    function recipient() external view returns(address);\n    function vestingAmount() external view returns(uint256);\n    function vestingBegin() external view returns(uint32);\n    function vestingCliff() external view returns(uint32);\n    function vestingEnd() external view returns(uint32);\n    function lastUpdate() external view returns(uint32);\n    function terminateTime() external view returns(uint32);\n}\n\ninterface InstaVestingFactoryInterface {\n    function recipients(address) external view returns(address);\n}\n\ncontract InstaTokenVestingResolver  {\n    using SafeMath for uint256;\n\n    TokenInterface public constant token = TokenInterface(0x6f40d4A6237C257fff2dB00FA0510DeEECd303eb);\n    // InstaVestingFactoryInterface public constant factory = InstaVestingFactoryInterface(0x3730D9b06bc23fd2E2F84f1202a7e80815dd054a);\n    InstaVestingFactoryInterface public immutable factory;\n\n    constructor(address factory_) {\n        factory = InstaVestingFactoryInterface(factory_);\n    }\n    \n    struct VestingData {\n        address recipient;\n        address vesting;\n        address owner;\n        uint256 vestingAmount;\n        uint256 vestingBegin;\n        uint256 vestingCliff;\n        uint256 vestingEnd;\n        uint256 lastClaimed;\n        uint256 terminatedTime;\n        uint256 vestedAmount;\n        uint256 unvestedAmount;\n        uint256 claimedAmount;\n        uint256 claimableAmount;\n    }\n\n    function getVestingByrecipient(address recipient) external view returns(VestingData memory vestingData) {\n        address vestingAddr = factory.recipients(recipient);\n        return getVesting(vestingAddr);\n    }\n\n    function getVesting(address vesting) public view returns(VestingData memory vestingData) {\n        if (vesting == address(0)) return vestingData;\n\n        InstaVestingInferface VestingContract = InstaVestingInferface(vesting);\n        uint256 vestingBegin = uint256(VestingContract.vestingBegin());\n\n        if (vestingBegin == 0) return vestingData;\n        uint256 vestingEnd = uint256(VestingContract.vestingEnd());\n        uint256 vestingCliff = uint256(VestingContract.vestingCliff());\n        uint256 vestingAmount = VestingContract.vestingAmount();\n        uint256 lastUpdate = uint256(VestingContract.lastUpdate());\n        uint256 terminatedTime = uint256(VestingContract.terminateTime());\n\n        \n        uint256 claimedAmount;\n        uint256 claimableAmount;\n        uint256 vestedAmount;\n        uint256 unvestedAmount;\n        if (block.timestamp > vestingCliff) {\n            uint256 time = terminatedTime == 0 ? block.timestamp : terminatedTime;\n            vestedAmount = vestingAmount.mul(time - vestingBegin).div(vestingEnd - vestingBegin);\n            unvestedAmount = vestingAmount.sub(vestedAmount);\n            claimableAmount = vestingAmount.mul(time - lastUpdate).div(vestingEnd - vestingBegin);\n            claimedAmount = vestedAmount.mul(time - vestingBegin).div(vestingEnd - vestingBegin);\n        }\n\n        vestingData = VestingData({\n            recipient: VestingContract.recipient(),\n            owner: VestingContract.owner(),\n            vesting: vesting,\n            vestingAmount: vestingAmount,\n            vestingBegin: vestingBegin,\n            vestingCliff: vestingCliff,\n            vestingEnd: vestingEnd,\n            lastClaimed: lastUpdate,\n            terminatedTime: terminatedTime,\n            vestedAmount: vestedAmount,\n            unvestedAmount: unvestedAmount,\n            claimedAmount: claimedAmount,\n            claimableAmount: claimableAmount\n        });\n    }\n\n}\n"}}}