{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "KOLWithDraw.sol": {
      "content": "pragma solidity ^0.4.23;\r\n/*\r\n *             ╔═╗┌─┐┌─┐┬┌─┐┬┌─┐┬   ┌─────────────────────────┐ ╦ ╦┌─┐┌┐ ╔═╗┬┌┬┐┌─┐\r\n *             ║ ║├┤ ├┤ ││  │├─┤│   │ KOL Community Foundation│ │ ║║║├┤ ├┴┐╚═╗│ │ ├┤\r\n *             ╚═╝└  └  ┴└─┘┴┴ ┴┴─┘ └─┬─────────────────────┬─┘ ╚╩╝└─┘└─┘╚═╝┴ ┴ └─┘\r\n *   ┌────────────────────────────────┘                     └──────────────────────────────┐\r\n *   │    ┌─────────────────────────────────────────────────────────────────────────────┐  │\r\n *   └────┤ Dev:Jack Koe ├─────────────┤ Special for: KOL  ├───────────────┤ 20200513   ├──┘\r\n *        └─────────────────────────────────────────────────────────────────────────────┘\r\n */\r\n\r\n library SafeMath {\r\n   function mul(uint a, uint b) internal pure  returns (uint) {\r\n     uint c = a * b;\r\n     require(a == 0 || c / a == b);\r\n     return c;\r\n   }\r\n   function div(uint a, uint b) internal pure returns (uint) {\r\n     require(b > 0);\r\n     uint c = a / b;\r\n     require(a == b * c + a % b);\r\n     return c;\r\n   }\r\n   function sub(uint a, uint b) internal pure returns (uint) {\r\n     require(b <= a);\r\n     return a - b;\r\n   }\r\n   function add(uint a, uint b) internal pure returns (uint) {\r\n     uint c = a + b;\r\n     require(c >= a);\r\n     return c;\r\n   }\r\n   function max64(uint64 a, uint64 b) internal  pure returns (uint64) {\r\n     return a >= b ? a : b;\r\n   }\r\n   function min64(uint64 a, uint64 b) internal  pure returns (uint64) {\r\n     return a < b ? a : b;\r\n   }\r\n   function max256(uint256 a, uint256 b) internal  pure returns (uint256) {\r\n     return a >= b ? a : b;\r\n   }\r\n   function min256(uint256 a, uint256 b) internal  pure returns (uint256) {\r\n     return a < b ? a : b;\r\n   }\r\n }\r\n\r\n /**\r\n  * title KOL Promotion Withdraw contract\r\n  * dev visit: https://github.com/jackoelv/KOL/\r\n */\r\n\r\n contract ERC20Basic {\r\n   uint public totalSupply;\r\n   function balanceOf(address who) public constant returns (uint);\r\n   function transfer(address to, uint value) public;\r\n   event Transfer(address indexed from, address indexed to, uint value);\r\n }\r\n\r\n contract ERC20 is ERC20Basic {\r\n   function allowance(address owner, address spender) public constant returns (uint);\r\n   function transferFrom(address from, address to, uint value) public;\r\n   function approve(address spender, uint value) public;\r\n   event Approval(address indexed owner, address indexed spender, uint value);\r\n }\r\n\r\n /**\r\n  * title KOL Promotion Withdraw contract\r\n  * dev visit: https://github.com/jackoelv/KOL/\r\n */\r\n\r\n contract BasicToken is ERC20Basic {\r\n\r\n   using SafeMath for uint;\r\n\r\n   mapping(address => uint) balances;\r\n\r\n   function transfer(address _to, uint _value) public{\r\n     balances[msg.sender] = balances[msg.sender].sub(_value);\r\n     balances[_to] = balances[_to].add(_value);\r\n     emit Transfer(msg.sender, _to, _value);\r\n   }\r\n\r\n   function balanceOf(address _owner) public constant returns (uint balance) {\r\n     return balances[_owner];\r\n   }\r\n }\r\n\r\n /**\r\n  * title KOL Promotion Withdraw contract\r\n  * dev visit: https://github.com/jackoelv/KOL/\r\n */\r\n\r\n contract StandardToken is BasicToken, ERC20 {\r\n   mapping (address => mapping (address => uint)) allowed;\r\n   uint256 public userSupplyed;\r\n\r\n   function transferFrom(address _from, address _to, uint _value) public {\r\n     balances[_to] = balances[_to].add(_value);\r\n     balances[_from] = balances[_from].sub(_value);\r\n     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n     emit Transfer(_from, _to, _value);\r\n   }\r\n\r\n   function approve(address _spender, uint _value) public{\r\n     require((_value == 0) || (allowed[msg.sender][_spender] == 0)) ;\r\n     allowed[msg.sender][_spender] = _value;\r\n     emit Approval(msg.sender, _spender, _value);\r\n   }\r\n\r\n   function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n     return allowed[_owner][_spender];\r\n   }\r\n }\r\n contract KOL is StandardToken {\r\n   function queryNode(address _addr) public view returns(bool);\r\n   function querySuperNode(address _addr) public view returns(bool);\r\n }\r\n contract KOLP is StandardToken {\r\n\r\n   address public draw;\r\n   bool public going;\r\n   struct lock{\r\n     uint256 begin;\r\n     uint256 amount;\r\n     uint256 end;\r\n     bool withDrawed;\r\n   }\r\n   struct teamRate{\r\n     uint8 rate;\r\n     uint256 changeTime;\r\n\r\n   }\r\n   struct inviteBonus{\r\n     uint256 begin;\r\n     uint256 dayBonus;\r\n     uint256 hisTotalBonus;\r\n   }\r\n   struct withDraws{\r\n     uint256 time;\r\n     uint256 amount;\r\n   }\r\n   struct dayTeamBonus{\r\n     uint256 theDayLastSecond;\r\n     uint256 theDayTeamBonus;\r\n     uint256 totalTeamBonus;\r\n     uint8 theDayRate;\r\n   }\r\n   struct dayInviteBonus{\r\n     uint256 theDayLastSecond;\r\n     uint256 theDayInviteBonus;\r\n     uint256 totalInviteBonus;\r\n   }\r\n   mapping (address => dayTeamBonus[]) public LockTeamBonus;\r\n   mapping (address => dayInviteBonus[]) public LockInviteBonus;\r\n\r\n\r\n   mapping (address => address[]) public InviteList;\r\n   mapping (address => address[]) public ChildAddrs;\r\n   mapping (address => lock[]) public LockHistory;\r\n   mapping (address => uint256) public LockBalance;\r\n\r\n   mapping (address => uint256) public InviteHistoryBonus;\r\n   mapping (address => uint256) public InviteCurrentDayBonus;\r\n\r\n   mapping (uint256 => uint256) public ClosePrice;\r\n   mapping (address => uint256) public TotalUsers;\r\n   mapping (address => uint256) public TotalLockingAmount;\r\n   mapping (uint256 => address) public InviteCode;\r\n   mapping (address => uint256) public RInviteCode;\r\n\r\n   mapping (address => uint8) public isLevelN;\r\n   mapping (uint8 => uint8) public levelRate;\r\n   mapping (address => bool) public USDTOrCoin;\r\n\r\n   //GAS优化\r\n   modifier onlyContract {\r\n       require(msg.sender == draw);\r\n       _;\r\n   }\r\n   function qsLevel(address _addr) onlyContract public ;\r\n   /* function queryAndSetLevelN(address _addr) public; */\r\n   function queryLockBalance(address _addr,uint256 _queryTime) public view returns(uint256);\r\n   function getYestodayLastSecond(uint256 _queryTime) public view returns(uint256);\r\n   function clearLock(address _addr) onlyContract public ;\r\n   function pushInvite(address _addr,\r\n                       uint256 _theDayLastSecond,\r\n                       uint256 _theDayInviteBonus,\r\n                       uint256 _totalInviteBonus) onlyContract public ;\r\n   function setLastInvite(address _addr,\r\n                       uint256 _theDayInviteBonus,\r\n                       uint256 _totalInviteBonus) onlyContract public ;\r\n   function pushTeam(address _addr,\r\n                       uint256 _theDayLastSecond,\r\n                       uint256 _theDayTeamBonus,\r\n                       uint256 _totalTeamBonus,\r\n                       uint8 _theDayRate) onlyContract public ;\r\n   function setLastTeam(address _addr,\r\n                       uint256 _theDayTeamBonus,\r\n                       uint256 _totalTeamBonus,\r\n                       uint8 _theDayRate) onlyContract public ;\r\n\r\n   function subTotalUsers(address _addr) onlyContract public ;\r\n   function subTotalLockingAmount(address _addr,uint256 _amount) onlyContract public ;\r\n   function subTotalBalance(uint256 _amount) onlyContract public ;\r\n   function setInviteTeam(address _addr) onlyContract public ;\r\n   function getLockLen(address _addr) public view returns(uint256);\r\n   function getFathersLength(address _addr) public view returns(uint256);\r\n   function getLockTeamBonusLen(address _addr) public view returns(uint256);\r\n   function getLockInviteBonusLen(address _addr) public view returns(uint256);\r\n\r\n}\r\n\r\n /**\r\n  * title KOL Promotion Withdraw contract\r\n  * dev visit: https://github.com/jackoelv/KOL/\r\n */\r\n\r\n contract Ownable {\r\n     address public owner;\r\n\r\n     constructor() public{\r\n         owner = msg.sender;\r\n     }\r\n\r\n     modifier onlyOwner {\r\n         require(msg.sender == owner);\r\n         _;\r\n     }\r\n     function transferOwnership(address newOwner) onlyOwner public{\r\n         if (newOwner != address(0)) {\r\n             owner = newOwner;\r\n         }\r\n     }\r\n }\r\n /**\r\n  * title KOL Promotion Withdraw contract\r\n  * dev visit: https://github.com/jackoelv/KOL/\r\n */\r\ncontract KOLWithDraw is Ownable{\r\n  using SafeMath for uint256;\r\n  string public name = \"KOL Withdraw\";\r\n  KOL public kol;\r\n  KOLP public kolp;\r\n\r\n  uint256 public every = 1 days;\r\n  uint256 public minBonus = 30 * (10 ** 18);\r\n  uint256 public leftBonus = 0;\r\n  address public reciever;\r\n  uint256 public etherFee = 0.005 ether;\r\n  uint8 public fee = 5;\r\n\r\n\r\n  struct dayTeamBonus{\r\n    uint256 theDayLastSecond;\r\n    uint256 theDayTeamBonus;\r\n    uint256 totalTeamBonus;\r\n    uint8 theDayRate;\r\n  }\r\n  struct dayInviteBonus{\r\n    uint256 theDayLastSecond;\r\n    uint256 theDayInviteBonus;\r\n    uint256 totalInviteBonus;\r\n  }\r\n\r\n  mapping (address => uint256) public TotalWithDraws;\r\n\r\n  mapping (address => uint256) public DrawTime;\r\n  event WithDrawed(address _user,uint256 _amount);\r\n\r\n  constructor(address _kolAddress,address _kolpAddress,address _reciever) public {\r\n    kol = KOL(_kolAddress);\r\n    kolp = KOLP(_kolpAddress);\r\n    reciever = _reciever;\r\n  }\r\n\r\n  function querySelfBonus(address _addr) public view returns(uint256){\r\n    uint256 len = kolp.getLockLen(_addr);\r\n    uint256 selfBonus;\r\n    if(len >0){\r\n      uint256 begin;\r\n      uint256 end;\r\n      uint256 amount;\r\n      bool withDrawed;\r\n      for (uint i=0; i<len; i++){\r\n        (begin,amount,end,withDrawed) = kolp.LockHistory(_addr,i);\r\n        if (!withDrawed){\r\n          if (DrawTime[_addr] > begin) begin = DrawTime[_addr];\r\n          uint256 lastingDays = (kolp.getYestodayLastSecond(now) - kolp.getYestodayLastSecond(begin)) / every;\r\n          if (kolp.USDTOrCoin(_addr)){\r\n            begin = kolp.getYestodayLastSecond(begin) + every;\r\n            for (uint j=0;j<lastingDays;j++){\r\n              uint256 theTime = begin + j*every;\r\n              selfBonus += amount * 3 / 1000 * kolp.ClosePrice(begin) / kolp.ClosePrice(theTime);\r\n            }\r\n          }else{\r\n            selfBonus += lastingDays * amount * 3 / 1000;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return (selfBonus);\r\n\r\n  }\r\n\r\n  function queryInviteBonus(address _addr) public view returns(uint256){\r\n    uint256 last = kolp.getLockInviteBonusLen(_addr);\r\n    if(last>0){\r\n      uint256 yestodayLastSecond = kolp.getYestodayLastSecond(now);\r\n      uint256 lastingDays;\r\n      uint256 newDayInviteTotalBonus;\r\n      dayInviteBonus memory theDayIB = dayInviteBonus(0,0,0);\r\n      while(last>=1){\r\n        (theDayIB.theDayLastSecond,theDayIB.theDayInviteBonus,theDayIB.totalInviteBonus) = kolp.LockInviteBonus(_addr,last-1);\r\n        last--;\r\n        if (theDayIB.theDayLastSecond <= yestodayLastSecond){\r\n          lastingDays = (yestodayLastSecond - theDayIB.theDayLastSecond) / every;\r\n          newDayInviteTotalBonus = (lastingDays * theDayIB.theDayInviteBonus) + theDayIB.totalInviteBonus;\r\n          return (newDayInviteTotalBonus);\r\n        }\r\n      }\r\n      return 0;\r\n    }else\r\n      return 0;\r\n  }\r\n  function queryTeamBonus(address _addr) public view returns(uint256){\r\n    uint256 last = kolp.getLockTeamBonusLen(_addr);\r\n    if(last>0){\r\n      uint256 yestodayLastSecond = kolp.getYestodayLastSecond(now);\r\n      uint256 lastingDays;\r\n      uint256 newDayTeamTotalBonus;\r\n      dayTeamBonus memory theDayTB =dayTeamBonus(0,0,0,0);\r\n      while(last>=1){\r\n        (theDayTB.theDayLastSecond,theDayTB.theDayTeamBonus,theDayTB.totalTeamBonus,theDayTB.theDayRate) = kolp.LockTeamBonus(_addr,last-1);\r\n        last--;\r\n        if (theDayTB.theDayLastSecond <= yestodayLastSecond){\r\n          lastingDays = (yestodayLastSecond - theDayTB.theDayLastSecond) / every;\r\n          newDayTeamTotalBonus = (lastingDays * theDayTB.theDayTeamBonus * theDayTB.theDayRate / 100 ) + theDayTB.totalTeamBonus;\r\n          return (newDayTeamTotalBonus);\r\n        }\r\n      }\r\n      return 0;\r\n    }else\r\n      return 0;\r\n\r\n  }\r\n  function afterWithdraw(address _addr,uint256 _amount) private {\r\n    address father;\r\n    uint256 fathersLen = kolp.getFathersLength(_addr);\r\n    for (uint i = 0; i<fathersLen; i++){\r\n      father = kolp.InviteList(_addr,i);\r\n      kolp.subTotalUsers(father);\r\n      kolp.subTotalLockingAmount(father,_amount);\r\n      kolp.qsLevel(father);\r\n      kolp.setInviteTeam(_addr);\r\n    }\r\n\r\n  }\r\n  function withdraw(bool _onlyBonus) payable public{\r\n    //true: bonus;false:balance & bonus;\r\n    require(msg.value >= etherFee);\r\n    uint256 bonus = querySelfBonus(msg.sender);\r\n    DrawTime[msg.sender] = now;\r\n    uint256 last = kolp.getLockInviteBonusLen(msg.sender);\r\n    uint256 yestodayLastSecond = kolp.getYestodayLastSecond(now);\r\n    uint256 lastingDays;\r\n\r\n    if(last>0){\r\n      dayInviteBonus memory theDayIB = dayInviteBonus(0,0,0);\r\n      uint256 realLast = last;\r\n      while(realLast>=1){\r\n        (theDayIB.theDayLastSecond,theDayIB.theDayInviteBonus,theDayIB.totalInviteBonus) = kolp.LockInviteBonus(msg.sender,realLast-1);\r\n        realLast--;\r\n        if (theDayIB.theDayLastSecond <= yestodayLastSecond){\r\n          lastingDays = (yestodayLastSecond - theDayIB.theDayLastSecond) / every;\r\n          bonus += (lastingDays * theDayIB.theDayInviteBonus) + theDayIB.totalInviteBonus;\r\n          if(theDayIB.theDayLastSecond < yestodayLastSecond){\r\n            kolp.pushInvite(msg.sender,yestodayLastSecond,theDayIB.theDayInviteBonus,0);\r\n          }else if(theDayIB.theDayLastSecond == yestodayLastSecond){\r\n            kolp.setLastInvite(msg.sender,theDayIB.theDayInviteBonus,0);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    last = kolp.getLockTeamBonusLen(msg.sender);\r\n\r\n    if(last>0){\r\n      dayTeamBonus memory theDayTB =dayTeamBonus(0,0,0,0);\r\n      while(last>=1){\r\n        (theDayTB.theDayLastSecond,theDayTB.theDayTeamBonus,theDayTB.totalTeamBonus,theDayTB.theDayRate) = kolp.LockTeamBonus(msg.sender,last-1);\r\n        last--;\r\n        if (theDayTB.theDayLastSecond <= yestodayLastSecond){\r\n          lastingDays = (yestodayLastSecond - theDayTB.theDayLastSecond) / every;\r\n          bonus += (lastingDays * theDayTB.theDayTeamBonus * theDayTB.theDayRate / 100 ) + theDayTB.totalTeamBonus;\r\n          if(theDayTB.theDayLastSecond < yestodayLastSecond){\r\n            kolp.pushTeam(msg.sender,yestodayLastSecond,theDayTB.theDayTeamBonus,0,theDayTB.theDayRate);\r\n          }else if(theDayTB.theDayLastSecond == yestodayLastSecond){\r\n            kolp.setLastTeam(msg.sender,theDayTB.theDayTeamBonus,0,theDayTB.theDayRate);\r\n          }\r\n        }\r\n      }\r\n\r\n    }\r\n    uint256 realBonus = bonus;\r\n    if (leftBonus == 0){\r\n      _onlyBonus = false;\r\n      realBonus =0;\r\n    }else if(bonus >= leftBonus){\r\n      realBonus = leftBonus;\r\n    }\r\n    uint256 subLeft = realBonus;\r\n    /* leftBonus = leftBonus.sub(realBonus); */\r\n    uint256 tax = realBonus*fee/100;\r\n    realBonus = realBonus.sub(tax);\r\n\r\n    if (!_onlyBonus){\r\n      uint256 balance = kolp.LockBalance(msg.sender);\r\n      if (bonus < minBonus){\r\n        realBonus = balance;\r\n        tax = 0;\r\n        subLeft = 0;\r\n      }else{\r\n        realBonus += balance;\r\n      }\r\n      kolp.subTotalBalance(balance);\r\n      kolp.clearLock(msg.sender);\r\n      afterWithdraw(msg.sender,balance);\r\n\r\n    }else{\r\n      require(bonus >= minBonus);\r\n    }\r\n    if (realBonus > 0) {\r\n      kol.transfer(msg.sender,realBonus);\r\n      TotalWithDraws[msg.sender] += realBonus;\r\n      emit WithDrawed(msg.sender,realBonus);\r\n    }\r\n    if (tax > 0) kol.transfer(reciever,tax);\r\n    leftBonus = leftBonus.sub(subLeft);\r\n\r\n  }\r\n  function calcuAllBonus(bool _onlyBonus) public view returns(uint256){\r\n    //true: Only Bonus;false: balance & bonus;\r\n    uint256 bonus = querySelfBonus(msg.sender);\r\n    bonus += queryInviteBonus(msg.sender);\r\n    bonus += queryTeamBonus(msg.sender);\r\n    if (leftBonus == 0){\r\n      bonus =0;\r\n    }else if(bonus >= leftBonus){\r\n      bonus = leftBonus;\r\n    }\r\n    bonus = bonus * (100-fee) /100;\r\n\r\n    if (!_onlyBonus){\r\n      uint256 balance = kolp.LockBalance(msg.sender);\r\n      bonus += balance;\r\n    }\r\n    return bonus;\r\n  }\r\n  function addBonus(uint256 _amount) onlyOwner public{\r\n    leftBonus = leftBonus.add(_amount);\r\n  }\r\n  function setFee(uint8 _fee) onlyOwner public{\r\n    fee = _fee;\r\n  }\r\n  function setKOLP(address _paddr) onlyOwner public{\r\n    kolp = KOLP(_paddr);\r\n  }\r\n  function draw() onlyOwner public{\r\n    reciever.send(address(this).balance);\r\n  }\r\n  function setetherFee(uint256 _fee) onlyOwner public{\r\n    etherFee = _fee;\r\n  }\r\n  function setReciever(address _reciever) onlyOwner public{\r\n    reciever = _reciever;\r\n  }\r\n}"
    }
  }
}