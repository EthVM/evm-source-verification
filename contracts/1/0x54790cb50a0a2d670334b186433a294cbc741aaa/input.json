{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/DSA_READ/curve_y.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface ICurve {\n    function get_virtual_price() external view returns (uint256 out);\n    function coins(int128 tokenId) external view returns (address token);\n    function calc_token_amount(uint256[4] calldata amounts, bool deposit) external view returns (uint256 amount);\n    function get_dy_underlying(int128 sellTokenId, int128 buyTokenId, uint256 sellTokenAmt) external view returns (uint256 buyTokenAmt);\n}\n\ninterface ICurveZap {\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256 amount);\n}\n\ninterface TokenInterface {\n    function decimals() external view returns (uint);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint);\n}\n\n\ncontract DSMath {\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"math-not-safe\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"sub-overflow\");\n    }\n\n    uint constant WAD = 10 ** 18;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n}\n\ncontract CurveHelpers is DSMath {\n    /**\n  * @dev Return ycurve Swap Address\n  */\n  function getCurveSwapAddr() internal pure returns (address) {\n    return 0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51;\n  }\n\n  /**\n  * @dev Return ycurve zap Address\n  */\n  function getCurveZapAddr() internal pure returns (address) {\n    return 0xbBC81d23Ea2c3ec7e56D39296F0cbB648873a5d3;\n  }\n\n  /**\n  * @dev Return Curve Token Address\n  */\n  function getCurveTokenAddr() internal pure returns (address) {\n    return 0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8;\n  }\n\n    function getTokenI(address token) internal pure returns (int128 i) {\n    if (token == address(0x6B175474E89094C44Da98b954EedeAC495271d0F)) {\n      // DAI Token\n      i = 0;\n    } else if (token == address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)) {\n      // USDC Token\n      i = 1;\n    } else if (token == address(0xdAC17F958D2ee523a2206206994597C13D831ec7)) {\n      // USDT Token\n      i = 2;\n    } else if (token == address(0x0000000000085d4780B73119b644AE5ecd22b376)) {\n      // USDT Token\n      i = 3;\n    } else {\n      revert(\"token-not-found.\");\n    }\n  }\n\n    function convertTo18(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = mul(_amt, 10 ** (18 - _dec));\n    }\n\n    function convert18ToDec(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = (_amt / 10 ** (18 - _dec));\n    }\n\n    function getBuyUnitAmt(\n        address buyAddr,\n        address sellAddr,\n        uint sellAmt,\n        uint buyAmt,\n        uint slippage\n    ) internal view returns (uint unitAmt) {\n        uint _sellAmt = convertTo18(TokenInterface(sellAddr).decimals(), sellAmt);\n        uint _buyAmt = convertTo18(TokenInterface(buyAddr).decimals(), buyAmt);\n        unitAmt = wdiv(_buyAmt, _sellAmt);\n        unitAmt = wmul(unitAmt, sub(WAD, slippage));\n    }\n\n    function getDepositUnitAmt(\n        address token,\n        uint depositAmt,\n        uint curveAmt,\n        uint slippage\n    ) internal view returns (uint unitAmt) {\n        uint _depositAmt = convertTo18(TokenInterface(token).decimals(), depositAmt);\n        uint _curveAmt = convertTo18(TokenInterface(getCurveTokenAddr()).decimals(), curveAmt);\n        unitAmt = wdiv(_curveAmt, _depositAmt);\n        unitAmt = wmul(unitAmt, sub(WAD, slippage));\n    }\n\n    function getWithdrawtUnitAmt(\n        address token,\n        uint withdrawAmt,\n        uint curveAmt,\n        uint slippage\n    ) internal view returns (uint unitAmt) {\n        uint _withdrawAmt = convertTo18(TokenInterface(token).decimals(), withdrawAmt);\n        uint _curveAmt = convertTo18(TokenInterface(getCurveTokenAddr()).decimals(), curveAmt);\n        unitAmt = wdiv(_curveAmt, _withdrawAmt);\n        unitAmt = wmul(unitAmt, add(WAD, slippage));\n    }\n}\n\n\ncontract Resolver is CurveHelpers {\n\n    function getBuyAmount(address buyAddr, address sellAddr, uint sellAmt, uint slippage)\n        public\n        view\n        returns (uint buyAmt, uint unitAmt, uint virtualPrice)\n    {\n        ICurve curve = ICurve(getCurveSwapAddr());\n        buyAmt = curve.get_dy_underlying(getTokenI(sellAddr), getTokenI(buyAddr), sellAmt);\n        virtualPrice = curve.get_virtual_price();\n        unitAmt = getBuyUnitAmt(buyAddr, sellAddr, sellAmt, buyAmt, slippage);\n    }\n\n    function getDepositAmount(address token, uint depositAmt, uint slippage)\n        public\n        view\n        returns (uint curveAmt, uint unitAmt, uint virtualPrice)\n    {\n        uint[4] memory amts;\n        amts[uint(getTokenI(token))] = depositAmt;\n        ICurve curve = ICurve(getCurveSwapAddr());\n        curveAmt = curve.calc_token_amount(amts, true);\n        virtualPrice = curve.get_virtual_price();\n        unitAmt = getDepositUnitAmt(token, depositAmt, curveAmt, slippage);\n    }\n\n    function getWithdrawAmount(address token, uint withdrawAmt, uint slippage)\n        public\n        view\n        returns (uint curveAmt, uint unitAmt, uint virtualPrice)\n    {\n        uint[4] memory amts;\n        amts[uint(getTokenI(token))] = withdrawAmt;\n        ICurve curve = ICurve(getCurveSwapAddr());\n        curveAmt = curve.calc_token_amount(amts, false);\n        virtualPrice = curve.get_virtual_price();\n        unitAmt = getWithdrawtUnitAmt(token, withdrawAmt, curveAmt, slippage);\n    }\n\n    function getWithdrawTokenAmount(address token, uint curveAmt, uint slippage)\n        public\n        view\n        returns (uint tokenAmt, uint unitAmt, uint virtualPrice)\n    {\n        tokenAmt = ICurveZap(getCurveZapAddr()).calc_withdraw_one_coin(curveAmt, getTokenI(token));\n        virtualPrice = ICurve(getCurveSwapAddr()).get_virtual_price();\n        unitAmt = getWithdrawtUnitAmt(token, tokenAmt, curveAmt, slippage);\n    }\n\n    function getPosition(\n        address user\n    ) public view returns (\n        uint userBal,\n        uint totalSupply,\n        uint virtualPrice,\n        uint userShare,\n        uint poolyDaiBal,\n        uint poolyUsdcBal,\n        uint poolyUsdtBal,\n        uint poolyTusdBal\n    ) {\n        TokenInterface curveToken = TokenInterface(getCurveTokenAddr());\n        userBal = curveToken.balanceOf(user);\n        totalSupply = curveToken.totalSupply();\n        userShare = wdiv(userBal, totalSupply);\n        ICurve curveContract = ICurve(getCurveSwapAddr());\n        virtualPrice = curveContract.get_virtual_price();\n        poolyDaiBal = TokenInterface(curveContract.coins(0)).balanceOf(getCurveSwapAddr());\n        poolyUsdcBal = TokenInterface(curveContract.coins(1)).balanceOf(getCurveSwapAddr());\n        poolyUsdtBal = TokenInterface(curveContract.coins(2)).balanceOf(getCurveSwapAddr());\n        poolyTusdBal = TokenInterface(curveContract.coins(3)).balanceOf(getCurveSwapAddr());\n    }\n}\n\n\ncontract InstaCurveYResolver is Resolver {\n    string public constant name = \"Curve-Y-Resolver-v1\";\n}"
    }
  }
}