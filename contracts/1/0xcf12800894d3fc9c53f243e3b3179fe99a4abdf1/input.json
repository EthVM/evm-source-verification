{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/seekrewards.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2021-04-28\n*/\n\npragma solidity 0.6.0;\n\ninterface IERC777 {\n    function name() external view returns(string memory);\n    function symbol() external view returns(string memory);\n    function decimals() external view returns(uint8);\n    function totalSupply() external view returns(uint256);\n    function balanceOf(address owner) external view returns(uint256);\n    function transfer(address to, uint256 amount) external returns(bool);\n    function transferFrom(address from, address to, uint256 amount) external returns(bool);\n    function approve(address spender, uint256 amount) external returns(bool);\n    function allowance(address owner, address spender) external view returns(uint256);\n    function burnBalance(address _addr, uint _amount) external;\n    function mint(address _tokenHolder, uint256 _amount, bytes calldata _data, bytes calldata _operatorData) external;\n    function defaultOperators() external view returns(address[] memory);\n\n    // solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n\n\nlibrary SafeMath {\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers.\n     * (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. \n     * (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\ncontract SeekReward {\n\n    using SafeMath for uint256;\n\n    // Investor details\n    struct user {\n        uint256 cycle;\n        address upline;\n        uint256 referrals;\n        uint256 payouts;\n        uint256 referalBonus;\n        uint256 matchBonus;\n        uint256 depositAmount;\n        uint256 depositPayouts;\n        uint40 depositTime;\n        uint256 totalDeposits;\n        uint256 totalStructure;\n    }\n    \n    // Token instance\n    IERC777 public token;\n\n    // Mapping users details by address\n    mapping(address => user)public users;\n\n    // Contract status\n    bool public lockStatus;\n    // Admin1 address\n    address public admin1;\n    // Admin2 address\n    address public admin2;\n    // Total levels\n    uint[]public Levels;\n    // Total users count\n    uint256 public totalUsers = 1;\n    // Total deposit amount.\n    uint256 public totalDeposited;\n    // Total withdraw amount\n    uint256 public totalWithdraw;\n\n    // Matching bonus event\n    event MatchBonus(address indexed from, address indexed to, uint value, uint time);\n    // Withdraw event\n    event Withdraw(address indexed from, uint value, uint time);\n    // Deposit event\n    event Deposit(address indexed from, address indexed refer, uint value, uint time);\n    // Admin withdraw event\n    event AdminEarnings(address indexed user, uint value, uint time);\n    // User withdraw limt event\n    event LimitReached(address indexed from, uint value, uint time);\n   \n    /**\n     * @dev Initializes the contract setting the owners and token.\n     */\n    constructor(address  _owner1, address  _owner2, address _token) public {\n        admin1 = _owner1;\n        admin2 = _owner2;\n        token = IERC777(_token);\n\n        //Levels maximum amount\n        Levels.push(6000e18);\n        Levels.push(6000e18);\n        Levels.push(6000e18);\n        Levels.push(6000e18);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == admin1, \"SeekReward: Only Owner\");\n        _;\n    }\n\n    /**\n     * @dev Throws if lockStatus is true\n     */\n    modifier isLock() {\n        require(lockStatus == false, \"SeekReward: Contract Locked\");\n        _;\n    }\n\n    /**\n     * @dev Throws if called by other contract\n     */\n    modifier isContractCheck(address _user) {\n        require(!isContract(_user), \"SeekReward: Invalid address\");\n        _;\n    }\n\n    function _setUpline(address _addr, address _upline) private {\n        if (users[_addr].upline == address(0) && _upline != _addr && _addr != admin1 && \n           (users[_upline].depositTime > 0 || _upline == admin1)) {\n            users[_addr].upline = _upline;\n            users[_upline].referrals = users[_upline].referrals.add(1);\n            totalUsers++;\n            for (uint8 i = 0; i < 21; i++) { // For update total structure for uplines\n                if (_upline == address(0)) break;\n                users[_upline].totalStructure++;\n                _upline = users[_upline].upline;\n            }\n        }\n    }\n\n    function _deposit(address _addr, uint256 _amount) private {\n        require(users[_addr].upline != address(0) || _addr == admin1, \"No upline\");\n        if (users[_addr].depositTime > 0) {\n            users[_addr].cycle++;\n            require(users[_addr].payouts >= this.maxPayoutOf(users[_addr].depositAmount),\n            \"SeekReward: Deposit already exists\");\n            require(_amount >= users[_addr].depositAmount && _amount <= Levels[users[_addr].cycle > Levels.length - 1 ?Levels.length - 1 : users[_addr].cycle], \"SeekReward: Bad amount\");\n        }\n        else {\n            require(_amount >= 0.5e18 && _amount <= Levels[0], \"SeekReward: Bad amount\");\n        }\n        require(token.transferFrom(msg.sender, address(this), _amount), \"Seekreward: transaction failed\");\n\n        users[_addr].payouts = 0;\n        users[_addr].depositAmount = _amount;\n        users[_addr].depositPayouts = 0;\n        users[_addr].depositTime = uint40(block.timestamp);\n        users[_addr].referalBonus = 0;\n        users[_addr].matchBonus = 0;\n        users[_addr].totalDeposits = users[_addr].totalDeposits.add(_amount);\n        totalDeposited = totalDeposited.add(_amount);\n\n        address upline = users[_addr].upline;\n        address up = users[users[_addr].upline].upline;\n\n        if (upline != address(0)) {\n            token.transfer(upline, _amount.mul(10e18).div(100e18)); // 10% for direct referer\n            users[upline].referalBonus = users[upline].referalBonus.add(_amount.mul(10e18).div(100e18));\n        }\n        if (up != address(0)) {\n            token.transfer(up, _amount.mul(5e18).div(100e18)); // 5% for indirect referer\n            users[up].referalBonus = users[up].referalBonus.add(_amount.mul(5e18).div(100e18));\n        }\n\n        uint adminFee = _amount.mul(5e18).div(100e18);\n        token.transfer(admin1, adminFee.div(2)); // 2.5% admin1\n        token.transfer(admin2, adminFee.div(2)); // 2.5% admin2\n        adminFee = 0;\n        emit Deposit(_addr, users[_addr].upline, _amount, block.timestamp);\n    }\n\n    /**\n     * @dev deposit: User deposit with 1 seek token\n     * 5% adminshare split into 2 accounts\n     * @param _upline: Referal address\n     * @param amount:1st deposit minimum 1 seek & maximum 150 for cycle 1\n     * Next depsoit amount based on previous deposit amount and maximum amount based on cycles\n     */\n    function deposit(address _upline, uint amount) external isLock isContractCheck(msg.sender) {\n        _setUpline(msg.sender, _upline);\n        _deposit(msg.sender, amount);\n    }\n    \n    function _matchBonus(address _user, uint _amount) private {\n        address up = users[_user].upline;\n        for (uint i = 1; i <= 21; i++) { // For matching bonus\n            if (up == address(0)) break;\n            if (i <= 3) {\n                users[up].matchBonus = users[up].matchBonus.add(_amount); \n                emit MatchBonus(_user, up, _amount, block.timestamp);\n            }\n            else if (i <= 6) {\n                if (users[up].referrals >= 2) {\n                    users[up].matchBonus = users[up].matchBonus.add(_amount);\n                    emit MatchBonus(_user, up, _amount, block.timestamp);\n                }\n            }\n            else if (i <= 10) {\n                if (users[up].referrals >= 4) {\n                    users[up].matchBonus = users[up].matchBonus.add(_amount);\n                    emit MatchBonus(_user, up, _amount, block.timestamp);\n                }\n            }\n            else if (i <= 14) {\n                if (users[up].referrals >= 8) {\n                    users[up].matchBonus = users[up].matchBonus.add(_amount);\n                    emit MatchBonus(_user, up, _amount, block.timestamp);\n                }\n            }\n            else if (i <= 21) {\n                if (users[up].referrals >= 16) {\n                    users[up].matchBonus = users[up].matchBonus.add(_amount);\n                    emit MatchBonus(_user, up, _amount, block.timestamp);\n                }\n            }\n            up = users[up].upline;\n        }\n    }\n\n    /**\n     * @dev withdraw: User can get amount till maximum payout reach.\n     * maximum payout based on(daily ROI,matchbonus)\n     * maximum payout limit 210 percentage\n     */\n    function withdraw() external isLock {\n        (uint256 to_payout, uint256 max_payout) = this.payoutOf(msg.sender);\n        require(msg.sender != admin1, \"SeekReward: only for users\");\n        require(users[msg.sender].payouts < max_payout, \"SeekReward: Full payouts\");\n        // Deposit payout\n        if (to_payout > 0) {\n            if (users[msg.sender].payouts.add(to_payout) > max_payout) {\n                to_payout = max_payout.sub(users[msg.sender].payouts);\n            }\n            users[msg.sender].depositPayouts = users[msg.sender].depositPayouts.add(to_payout);\n            users[msg.sender].payouts = users[msg.sender].payouts.add(to_payout);\n            _matchBonus(msg.sender, to_payout.mul(3e18).div(100e18));\n        }\n        // matching bonus\n        if (users[msg.sender].payouts < max_payout && users[msg.sender].matchBonus > 0) {\n            if (users[msg.sender].payouts.add(users[msg.sender].matchBonus) > max_payout) {\n                users[msg.sender].matchBonus = max_payout.sub(users[msg.sender].payouts);\n            }\n            users[msg.sender].payouts = users[msg.sender].payouts.add(users[msg.sender].matchBonus);\n            to_payout = to_payout.add(users[msg.sender].matchBonus);\n            users[msg.sender].matchBonus = users[msg.sender].matchBonus.sub(users[msg.sender].matchBonus);\n        }\n        totalWithdraw = totalWithdraw.add(to_payout);\n        token.transfer(msg.sender, to_payout); // Daily roi and matching bonus\n        emit Withdraw(msg.sender, to_payout, block.timestamp);\n\n        if (users[msg.sender].payouts >= max_payout) {\n            emit LimitReached(msg.sender, users[msg.sender].payouts, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev adminWithdraw: owner invokes the function\n     * owner can get referbonus, matchbonus \n     */\n    function adminWithdraw() external onlyOwner {\n        uint amount;\n        if (users[admin1].referalBonus > 0) {\n            amount = amount.add(users[admin1].referalBonus);\n            users[admin1].referalBonus = 0;\n        }\n        if (users[admin1].matchBonus > 0) {\n            amount = amount.add(users[admin1].matchBonus);\n            users[admin1].matchBonus = 0;\n        }\n        token.transfer(admin1, amount); //Referal bonus and matching bonus\n        emit AdminEarnings(admin1, amount, block.timestamp);\n    }\n\n    /**\n     * @dev maxPayoutOf: Amount calculate by 210 percentage\n     */\n    function maxPayoutOf(uint256 _amount) external pure returns(uint256) {\n        return _amount.mul(210).div(100);\n    }\n\n    /**\n     * @dev payoutOf: Users daily ROI and maximum payout will be show\n     */\n    function payoutOf(address _addr) external view returns(uint256 payout, uint256 max_payout) {\n        max_payout = this.maxPayoutOf(users[_addr].depositAmount);\n        if (users[_addr].depositPayouts < max_payout) {\n            payout = ((users[_addr].depositAmount.mul(1e18).div(100e18)).mul((block.timestamp\n            .sub(users[_addr].depositTime)).div(1 days))).sub(users[_addr].depositPayouts); // Daily roi\n            if (users[_addr].depositPayouts.add(payout) > max_payout) {\n                payout = max_payout.sub(users[_addr].depositPayouts);\n            }\n        }\n    }\n\n    /**\n     * @dev userInfo: Returns upline,depositTime,depositAmount,payouts,match_bonus\n     */\n    function userInfo(address _addr) external view returns(address upline, uint40 deposit_time,\n    uint256 deposit_amount, uint256 payouts, uint256 match_bonus) {\n        return (users[_addr].upline, users[_addr].depositTime, users[_addr].depositAmount,\n                users[_addr].payouts, users[_addr].matchBonus);\n    }\n\n    /**\n     * @dev userInfoTotals: Returns users referrals count, totalDeposit, totalStructure\n     */\n    function userInfoTotals(address _addr) external view returns(uint256 referrals,\n    uint256 total_deposits, uint256 total_structure) {\n        return (users[_addr].referrals, users[_addr].totalDeposits, users[_addr].totalStructure);\n    }\n\n    /**\n     * @dev contractInfo: Returns total users, totalDeposited, totalWithdraw\n     */\n    function contractInfo() external view returns(uint256 _total_users, uint256 _total_deposited,\n    uint256 _total_withdraw) {\n        return (totalUsers, totalDeposited, totalWithdraw);\n    }\n\n    /**\n     * @dev contractLock: For contract status\n     */\n    function contractLock(bool _lockStatus) public onlyOwner returns(bool) {\n        lockStatus = _lockStatus;\n        return true;\n    }\n\n    /**\n     * @dev failSafe: Returns transfer token\n     */\n    function failSafe(address _toUser, uint _amount) external onlyOwner returns(bool) {\n        require(_toUser != address(0), \"Invalid Address\");\n        require(token.balanceOf(address(this)) >= _amount, \"SeekReward: insufficient amount\");\n        token.transfer(_toUser, _amount);\n        return true;\n    }\n\n    /**\n     * @dev isContract: Returns true if account is a contract\n     */\n    function isContract(address _account) public view returns(bool) {\n        uint32 size;\n        assembly {\n            size:= extcodesize(_account)\n        }\n        if (size != 0)\n            return true;\n        return false;\n    }\n}"}}}