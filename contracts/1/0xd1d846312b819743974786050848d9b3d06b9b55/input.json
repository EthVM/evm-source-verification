{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"TokenHolder.sol":{"content":"\n// File: solidity/contracts/utility/interfaces/IOwned.sol\n\n// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/*\n    Owned contract interface\n*/\ninterface IOwned {\n    // this function isn't since the compiler emits automatically generated getter functions as external\n    function owner() external view returns (address);\n\n    function transferOwnership(address _newOwner) external;\n\n    function acceptOwnership() external;\n}\n\n// File: solidity/contracts/utility/Owned.sol\n\n\npragma solidity 0.6.12;\n\n\n/**\n * @dev This contract provides support and utilities for contract ownership.\n */\ncontract Owned is IOwned {\n    address public override owner;\n    address public newOwner;\n\n    /**\n     * @dev triggered when the owner is updated\n     *\n     * @param _prevOwner previous owner\n     * @param _newOwner  new owner\n     */\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n\n    /**\n     * @dev initializes a new Owned instance\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        _ownerOnly();\n        _;\n    }\n\n    // error message binary size optimization\n    function _ownerOnly() internal view {\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\n    }\n\n    /**\n     * @dev allows transferring the contract ownership\n     * the new owner still needs to accept the transfer\n     * can only be called by the contract owner\n     *\n     * @param _newOwner    new contract owner\n     */\n    function transferOwnership(address _newOwner) public override ownerOnly {\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\n        newOwner = _newOwner;\n    }\n\n    /**\n     * @dev used by a new owner to accept an ownership transfer\n     */\n    function acceptOwnership() public override {\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\n        emit OwnerUpdate(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\n// File: solidity/contracts/utility/Utils.sol\n\n\npragma solidity 0.6.12;\n\n/**\n * @dev Utilities & Common Modifiers\n */\ncontract Utils {\n    // verifies that a value is greater than zero\n    modifier greaterThanZero(uint256 _value) {\n        _greaterThanZero(_value);\n        _;\n    }\n\n    // error message binary size optimization\n    function _greaterThanZero(uint256 _value) internal pure {\n        require(_value > 0, \"ERR_ZERO_VALUE\");\n    }\n\n    // validates an address - currently only checks that it isn't null\n    modifier validAddress(address _address) {\n        _validAddress(_address);\n        _;\n    }\n\n    // error message binary size optimization\n    function _validAddress(address _address) internal pure {\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\n    }\n\n    // verifies that the address is different than this contract address\n    modifier notThis(address _address) {\n        _notThis(_address);\n        _;\n    }\n\n    // error message binary size optimization\n    function _notThis(address _address) internal view {\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\n    }\n\n    // validates an external address - currently only checks that it isn't null or this\n    modifier validExternalAddress(address _address) {\n        _validExternalAddress(_address);\n        _;\n    }\n\n    // error message binary size optimization\n    function _validExternalAddress(address _address) internal view {\n        require(_address != address(0) && _address != address(this), \"ERR_INVALID_EXTERNAL_ADDRESS\");\n    }\n}\n\n// File: solidity/contracts/token/interfaces/IERC20Token.sol\n\n\npragma solidity 0.6.12;\n\n/*\n    ERC20 Standard Token interface\n*/\ninterface IERC20Token {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n}\n\n// File: solidity/contracts/utility/TokenHandler.sol\n\n\npragma solidity 0.6.12;\n\n\ncontract TokenHandler {\n    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\n    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256(\"transfer(address,uint256)\"));\n    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n\n    /**\n     * @dev executes the ERC20 token's `approve` function and reverts upon failure\n     * the main purpose of this function is to prevent a non standard ERC20 token\n     * from failing silently\n     *\n     * @param _token   ERC20 token address\n     * @param _spender approved address\n     * @param _value   allowance amount\n     */\n    function safeApprove(\n        IERC20Token _token,\n        address _spender,\n        uint256 _value\n    ) internal {\n        (bool success, bytes memory data) = address(_token).call(\n            abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"ERR_APPROVE_FAILED\");\n    }\n\n    /**\n     * @dev executes the ERC20 token's `transfer` function and reverts upon failure\n     * the main purpose of this function is to prevent a non standard ERC20 token\n     * from failing silently\n     *\n     * @param _token   ERC20 token address\n     * @param _to      target address\n     * @param _value   transfer amount\n     */\n    function safeTransfer(\n        IERC20Token _token,\n        address _to,\n        uint256 _value\n    ) internal {\n        (bool success, bytes memory data) = address(_token).call(\n            abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"ERR_TRANSFER_FAILED\");\n    }\n\n    /**\n     * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\n     * the main purpose of this function is to prevent a non standard ERC20 token\n     * from failing silently\n     *\n     * @param _token   ERC20 token address\n     * @param _from    source address\n     * @param _to      target address\n     * @param _value   transfer amount\n     */\n    function safeTransferFrom(\n        IERC20Token _token,\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        (bool success, bytes memory data) = address(_token).call(\n            abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"ERR_TRANSFER_FROM_FAILED\");\n    }\n}\n\n// File: solidity/contracts/utility/interfaces/ITokenHolder.sol\n\n\npragma solidity 0.6.12;\n\n\n\n/*\n    Token Holder interface\n*/\ninterface ITokenHolder is IOwned {\n    function withdrawTokens(\n        IERC20Token _token,\n        address _to,\n        uint256 _amount\n    ) external;\n}\n\n// File: solidity/contracts/utility/TokenHolder.sol\n\n\npragma solidity 0.6.12;\n\n\n\n\n\n\n/**\n * @dev This contract provides a safety mechanism for allowing the owner to\n * send tokens that were sent to the contract by mistake back to the sender.\n *\n * We consider every contract to be a 'token holder' since it's currently not possible\n * for a contract to deny receiving tokens.\n *\n * Note that we use the non standard ERC-20 interface which has no return value for transfer\n * in order to support both non standard as well as standard token contracts.\n * see https://github.com/ethereum/solidity/issues/4116\n */\ncontract TokenHolder is ITokenHolder, TokenHandler, Owned, Utils {\n    /**\n     * @dev withdraws tokens held by the contract and sends them to an account\n     * can only be called by the owner\n     *\n     * @param _token   ERC20 token contract address\n     * @param _to      account to receive the new amount\n     * @param _amount  amount to withdraw\n     */\n    function withdrawTokens(\n        IERC20Token _token,\n        address _to,\n        uint256 _amount\n    ) public virtual override ownerOnly validAddress(address(_token)) validAddress(_to) notThis(_to) {\n        safeTransfer(_token, _to, _amount);\n    }\n}\n"}}}