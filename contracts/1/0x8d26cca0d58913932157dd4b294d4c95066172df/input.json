{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ZeroEx_.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary LibRichErrors {\r\n\tbytes4 internal constant STANDARD_ERROR_SELECTOR = bytes4(keccak256(\"Error(string)\"));\r\n\r\n    function StandardError(string memory message)\r\n        internal\r\n        pure\r\n        returns (bytes memory encodedError)\r\n    {\r\n        return abi.encodeWithSelector(\r\n            STANDARD_ERROR_SELECTOR,\r\n            bytes(message)\r\n        );\r\n    }\r\n\r\n    function rrevert(bytes memory encodedError)\r\n        internal\r\n        pure\r\n    {\r\n        assembly {\r\n            revert(add(encodedError, 0x20), mload(encodedError))\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary LibProxyRichErrors {\r\n    function NotImplementedError(bytes4 selector)\r\n        internal\r\n        pure\r\n        returns (bytes memory encodedError)\r\n    {\r\n        return abi.encodeWithSelector(\r\n            bytes4(keccak256(\"NotImplementedError(bytes4)\")),\r\n            selector\r\n        );\r\n    }\r\n\r\n    function InvalidBootstrapCallerError(address actual, address expected)\r\n        internal\r\n        pure\r\n        returns (bytes memory encodedError)\r\n    {\r\n        return abi.encodeWithSelector(\r\n            bytes4(keccak256(\"InvalidBootstrapCallerError(address,address)\")),\r\n            actual,\r\n            expected\r\n        );\r\n    }\r\n\r\n    function InvalidDieCallerError(address actual, address expected)\r\n        internal\r\n        pure\r\n        returns (bytes memory encodedError)\r\n    {\r\n        return abi.encodeWithSelector(\r\n            bytes4(keccak256(\"InvalidDieCallerError(address,address)\")),\r\n            actual,\r\n            expected\r\n        );\r\n    }\r\n\r\n    function BootstrapCallFailedError(address target, bytes memory resultData)\r\n        internal\r\n        pure\r\n        returns (bytes memory encodedError)\r\n    {\r\n        return abi.encodeWithSelector(\r\n            bytes4(keccak256(\"BootstrapCallFailedError(address,bytes)\")),\r\n            target,\r\n            resultData\r\n        );\r\n    }\r\n}\r\n\r\n\r\nlibrary LibBootstrap {\r\n    bytes4 internal constant BOOTSTRAP_SUCCESS = bytes4(keccak256(\"BOOTSTRAP_SUCCESS\"));\r\n\r\n    using LibRichErrors for bytes;\r\n\r\n    function delegatecallBootstrapFunction(\r\n        address target,\r\n        bytes memory data\r\n    )\r\n        internal\r\n    {\r\n        (bool success, bytes memory resultData) = target.delegatecall(data);\r\n        if (!success ||\r\n            resultData.length != 32 ||\r\n            abi.decode(resultData, (bytes4)) != BOOTSTRAP_SUCCESS)\r\n        {\r\n            LibProxyRichErrors.BootstrapCallFailedError(target, resultData).rrevert();\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @dev Common storage helpers\r\nlibrary LibStorage {\r\n    /// @dev What to bit-shift a storage ID by to get its slot.\r\n    ///      This gives us a maximum of 2**128 inline fields in each bucket.\r\n    uint256 private constant STORAGE_SLOT_EXP = 128;\r\n\r\n    /// @dev Storage IDs for feature storage buckets.\r\n    ///      WARNING: APPEND-ONLY.\r\n    enum StorageId {\r\n        Proxy,\r\n        SimpleFunctionRegistry,\r\n        Ownable,\r\n        ERC20,\r\n        AccessControl,\r\n        ERC20AccessControl,\r\n        Test\r\n    }\r\n\r\n    /// @dev Get the storage slot given a storage ID. We assign unique, well-spaced\r\n    ///     slots to storage bucket variables to ensure they do not overlap.\r\n    ///     See: https://solidity.readthedocs.io/en/v0.6.6/assembly.html#access-to-external-variables-functions-and-libraries\r\n    /// @param storageId An entry in `StorageId`\r\n    /// @return slot The storage slot.\r\n    function getStorageSlot(StorageId storageId)\r\n        internal\r\n        pure\r\n        returns (uint256 slot)\r\n    {\r\n        // This should never overflow with a reasonable `STORAGE_SLOT_EXP`\r\n        // because Solidity will do a range check on `storageId` during the cast.\r\n        return (uint256(storageId) + 1) << STORAGE_SLOT_EXP;\r\n    }\r\n}\r\n\r\n\r\nlibrary LibProxyStorage {\r\n    struct Storage {\r\n        // Mapping of function selector -> function implementation\r\n        mapping(bytes4 => address) impls;\r\n        //address owner;\r\n    }\r\n\r\n    function getStorage() internal pure returns (Storage storage stor) {\r\n        uint256 storageSlot = LibStorage.getStorageSlot(\r\n            LibStorage.StorageId.Proxy\r\n        );\r\n        assembly {\r\n            stor.slot := storageSlot\r\n        }\r\n    }\r\n}\r\n\r\n\r\ninterface IBootstrapFeature {\r\n    /// @dev Bootstrap the initial feature set of this contract by delegatecalling\r\n    ///      into `target`. Before exiting the `bootstrap()` function will\r\n    ///      deregister itself from the proxy to prevent being called again.\r\n    /// @param target The bootstrapper contract address.\r\n    /// @param callData The call data to execute on `target`.\r\n    function bootstrap(address target, bytes calldata callData) external;\r\n}\r\n\r\n\r\n/// @dev Detachable `bootstrap()` feature.\r\ncontract BootstrapFeature is\r\n    IBootstrapFeature\r\n{\r\n    // immutable -> persist across delegatecalls\r\n    /// @dev aka ZeroEx.\r\n    address immutable private _deployer;\r\n    /// @dev The implementation address of this contract.\r\n    address immutable private _implementation;\r\n    /// @dev aka InitialMigration.\r\n    address immutable private _bootstrapCaller;\r\n\r\n    using LibRichErrors for bytes;\r\n\r\n    constructor(address bootstrapCaller) {\r\n        _deployer = msg.sender;\r\n        _implementation = address(this);\r\n        _bootstrapCaller = bootstrapCaller;\r\n    }\r\n\r\n    modifier onlyBootstrapCaller() {\r\n        if (msg.sender != _bootstrapCaller) {\r\n            LibProxyRichErrors.InvalidBootstrapCallerError(msg.sender, _bootstrapCaller).rrevert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyDeployer() {\r\n        if (msg.sender != _deployer) {\r\n            LibProxyRichErrors.InvalidDieCallerError(msg.sender, _deployer).rrevert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function bootstrap(address target, bytes calldata callData) external override onlyBootstrapCaller {\r\n        LibProxyStorage.getStorage().impls[this.bootstrap.selector] = address(0);\r\n        BootstrapFeature(_implementation).die();\r\n        LibBootstrap.delegatecallBootstrapFunction(target, callData);\r\n    }\r\n\r\n    function die() external onlyDeployer {\r\n        assert(address(this) == _implementation);\r\n        selfdestruct(payable(msg.sender));\r\n    }\r\n}\r\n\r\n\r\ncontract ZeroEx_ {\r\n    /// @param bootstrapper Who can call `bootstrap()`.\r\n    constructor(address bootstrapper) {\r\n        BootstrapFeature bootstrap = new BootstrapFeature(bootstrapper);\r\n        LibProxyStorage.getStorage().impls[bootstrap.bootstrap.selector] = address(bootstrap);\r\n    }\r\n\r\n    function getFunctionImplementation(bytes4 selector)\r\n        public\r\n        view\r\n        returns (address impl)\r\n    {\r\n        return LibProxyStorage.getStorage().impls[selector];\r\n    }\r\n\r\n    fallback() external payable {\r\n        mapping(bytes4 => address) storage impls =\r\n            LibProxyStorage.getStorage().impls;\r\n\r\n        assembly {\r\n            let cdlen := calldatasize()\r\n\r\n            // receive() external payable {}\r\n            if iszero(cdlen) {\r\n                return(0, 0)\r\n            }\r\n\r\n            // 0x00-0x3F reserved for slot calculation\r\n            calldatacopy(0x40, 0, cdlen)\r\n            let selector := and(mload(0x40), 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\r\n\r\n            // slot for impls[selector] = keccak256(selector . impls.slot)\r\n            mstore(0, selector)\r\n            mstore(0x20, impls.slot)\r\n            let slot := keccak256(0, 0x40)\r\n\r\n            let delegate := sload(slot)\r\n            if iszero(delegate) {\r\n                // abi.encodeWithSelector(bytes4(keccak256(\"NotImplementedError(bytes4)\")), selector)\r\n                mstore(0, 0x734e6e1c00000000000000000000000000000000000000000000000000000000)\r\n                mstore(4, selector)\r\n                revert(0, 0x24)\r\n            }\r\n\r\n            let success := delegatecall(\r\n                gas(),\r\n                delegate,\r\n                0x40, cdlen,\r\n                0, 0\r\n            )\r\n            let rdlen := returndatasize()\r\n            returndatacopy(0, 0, rdlen)\r\n            if success {\r\n                return(0, rdlen)\r\n            }\r\n            revert(0, rdlen)\r\n        }\r\n    }\r\n}"
    }
  }
}