{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"otc_heco.sol":{"content":"pragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n// SPDX-License-Identifier: MIT\r\nlibrary Strings {\r\n  struct slice {\r\n    uint _len;\r\n    uint _ptr;\r\n  }\r\n\r\n  function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\r\n    if (_i == 0) {\r\n      return \"0\";\r\n    }\r\n    uint j = _i;\r\n    uint len;\r\n    while (j != 0) {\r\n      len++;\r\n      j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(len);\r\n    uint k = len;\r\n    while (_i != 0) {\r\n      k = k - 1;\r\n      uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n      bytes1 b1 = bytes1(temp);\r\n      bstr[k] = b1;\r\n      _i /= 10;\r\n    }\r\n    return string(bstr);\r\n  }\r\n\r\n  function memcpy(uint dest, uint src, uint len) private pure {\r\n    for (; len >= 32; len -= 32) {\r\n      assembly {\r\n        mstore(dest, mload(src))\r\n      }\r\n      dest += 32;\r\n      src += 32;\r\n    }\r\n    uint mask = 256 ** (32 - len) - 1;\r\n    assembly {\r\n      let srcpart := and(mload(src), not(mask))\r\n      let destpart := and(mload(dest), mask)\r\n      mstore(dest, or(destpart, srcpart))\r\n    }\r\n  }\r\n\r\n  function toSlice(string memory self) internal pure returns (slice memory) {\r\n    uint ptr;\r\n    assembly {\r\n      ptr := add(self, 0x20)\r\n    }\r\n    return slice(bytes(self).length, ptr);\r\n  }\r\n\r\n  function concat(slice memory self, slice memory other) internal pure returns (string memory) {\r\n    string memory ret = new string(self._len + other._len);\r\n    uint retptr;\r\n    assembly {retptr := add(ret, 32)}\r\n    memcpy(retptr, self._ptr, self._len);\r\n    memcpy(retptr + self._len, other._ptr, other._len);\r\n    return ret;\r\n  }\r\n}\r\n\r\ninterface IERC20 {\r\n  function symbol() external view returns (string memory);\r\n\r\n  function name() external view returns (string memory);\r\n\r\n  function decimals() external view returns (uint256);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n}\r\n\r\nlibrary SafeERC20 {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n  }\r\n\r\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n  }\r\n\r\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    bytes memory returndata = address(token).functionCall(data, \"e0\");\r\n    if (returndata.length > 0) {\r\n      require(abi.decode(returndata, (bool)), \"e1\");\r\n    }\r\n  }\r\n}\r\n\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n  uint256 private constant _NOT_ENTERED = 1;\r\n  uint256 private constant _ENTERED = 2;\r\n  uint256 private _status;\r\n\r\n  constructor() internal {\r\n    _status = _NOT_ENTERED;\r\n  }\r\n\r\n  modifier nonReentrant() {\r\n    require(_status != _ENTERED, \"e0\");\r\n    _status = _ENTERED;\r\n    _;\r\n    _status = _NOT_ENTERED;\r\n  }\r\n}\r\n\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor () internal {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), \"Ow1\");\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), \"Ow2\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\nlibrary Address {\r\n  function isContract(address account) internal view returns (bool) {\r\n    uint256 size;\r\n    assembly {\r\n      size := extcodesize(account)\r\n    }\r\n    return size > 0;\r\n  }\r\n\r\n  function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n    return _functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n    require(isContract(target), \"e0\");\r\n    (bool success, bytes memory returndata) = target.call{value : weiValue}(data);\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      if (returndata.length > 0) {\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"add e0\");\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"sub e0\");\r\n    uint256 c = a - b;\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"mul e0\");\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"div e0\");\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n}\r\n\r\ninterface Map {\r\n  function getFeeNum() external view returns (uint256 tx_price, uint256 tx_fee_rate, uint256 tx_fee_type, uint256 fee_token_decimals, uint256 usdt_token_decimals, IERC20 fee_token, IERC20 usdt_token, address tx_fee_address, address router_address);\r\n}\r\n\r\ninterface IMdexRouter {\r\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n  ) external;\r\n}\r\n\r\ncontract OtcItem is Ownable, ReentrancyGuard {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n  using SafeERC20 for IERC20;\r\n  bool public can_ido;\r\n  bool public can_buyback;\r\n  uint256 private order_id;\r\n  uint256 private time;\r\n  uint256 public amount_all;\r\n  uint256 public amount_ok;\r\n  uint256 private price;\r\n  address private fee_to;\r\n  IERC20 private usdt_token;\r\n  IERC20 private ido_token;\r\n  address private factory;\r\n  string private order_md5;\r\n  Map private map;\r\n  mapping(address => bool) private white_list;\r\n  mapping(address => uint256) public can_buyback_amount_list;\r\n\r\n  struct deposit_ithdraw_item {\r\n    string op_type;\r\n    string order_md5;\r\n    uint256 _amount;\r\n    uint256 time;\r\n  }\r\n\r\n  struct ido_buyback_item {\r\n    string op_type;\r\n    string order_md5;\r\n    uint256 ido_token_amount;\r\n    uint256 usdt_token_amount;\r\n    uint256 time;\r\n  }\r\n\r\n  mapping(address => mapping(uint256 => deposit_ithdraw_item[])) private deposit_ithdraw_list;\r\n  mapping(address => mapping(uint256 => ido_buyback_item[])) private ido_buyback_list;\r\n\r\n\r\n  modifier onlyFeeto() {\r\n    require(msg.sender == fee_to || msg.sender == owner(), 'e0');\r\n    _;\r\n  }\r\n\r\n  modifier onlyFactory() {\r\n    require(msg.sender == factory, 'onlyFactory error');\r\n    _;\r\n  }\r\n\r\n  constructor(IERC20 _usdt_token, IERC20 _ido_token, address _fee_to, uint256 _price, string memory _order_md5, uint256 _order_id, uint256 _time, uint256 _amount, Map _map) public {\r\n    usdt_token = _usdt_token;\r\n    ido_token = _ido_token;\r\n    factory = msg.sender;\r\n    fee_to = _fee_to;\r\n    price = _price;\r\n    order_md5 = _order_md5;\r\n    order_id = _order_id;\r\n    time = _time;\r\n    amount_all = _amount;\r\n    deposit_ithdraw_list[fee_to][order_id].push((deposit_ithdraw_item('deposit', order_md5, _amount, _time)));\r\n    map = _map;\r\n    enable_disable_ido_buyback(true, false);\r\n  }\r\n\r\n  function enable_disable_ido_buyback(bool _can_ido, bool _can_buyback) public onlyFeeto {\r\n    can_ido = _can_ido;\r\n    can_buyback = _can_buyback;\r\n  }\r\n\r\n  function deposit(uint256 _amount, uint256 _time) public onlyFeeto {\r\n    require(_amount > 0, 'e0');\r\n    require(ido_token.balanceOf(msg.sender) >= _amount, 'e1');\r\n    amount_all = amount_all.add(_amount);\r\n    deposit_ithdraw_list[fee_to][order_id].push((deposit_ithdraw_item('deposit', order_md5, _amount, _time)));\r\n    ido_token.safeTransferFrom(msg.sender, address(this), _amount);\r\n  }\r\n\r\n  function withdraw(uint256 _amount, uint256 _time) public onlyFeeto {\r\n    require(_amount > 0, 'e0');\r\n    require(ido_token.balanceOf(address(this)) >= _amount, 'e1');\r\n    amount_all = amount_all.sub(_amount);\r\n    deposit_ithdraw_list[fee_to][order_id].push((deposit_ithdraw_item('withdraw', order_md5, _amount, _time)));\r\n    ido_token.safeTransfer(msg.sender, _amount);\r\n  }\r\n\r\n\r\n  function auto_swap(IERC20 fee_token, address router_address, uint256 fee_amount, address tx_fee_address) private {\r\n    address[] memory path = new address[](2);\r\n    path[0] = address(usdt_token);\r\n    path[1] = address(fee_token);\r\n    usdt_token.approve(router_address, fee_amount);\r\n    IMdexRouter(router_address).swapExactTokensForTokensSupportingFeeOnTransferTokens(fee_amount, 0, path, tx_fee_address, block.timestamp);\r\n  }\r\n\r\n  /*\r\n  uint256 tx_fee_type; //0,usdt;1,fee_token;2,autoswap;3,fixed\r\n  */\r\n  function PayFee(uint256 usdt_token_amount, address _user) private {\r\n    (,uint256 tx_fee_rate,uint256 tx_fee_type,,,IERC20 fee_token,,address tx_fee_address,address router_address) = map.getFeeNum();\r\n    uint256 fee_amount = usdt_token_amount.mul(tx_fee_rate).div(1e3);\r\n    usdt_token.safeTransferFrom(_user, fee_to, usdt_token_amount);\r\n    if (address(fee_token) == address(0)) {\r\n      tx_fee_type = 0;\r\n    }\r\n    if (tx_fee_type == 0) {\r\n      require(usdt_token.balanceOf(_user) >= fee_amount, 'e0');\r\n      usdt_token.safeTransferFrom(_user, tx_fee_address, fee_amount);\r\n    } else if (tx_fee_type == 2) {\r\n      require(usdt_token.balanceOf(_user) >= fee_amount, 'e1');\r\n      usdt_token.safeTransferFrom(_user, address(this), fee_amount);\r\n      auto_swap(fee_token, router_address, fee_amount, tx_fee_address);\r\n    } else if (tx_fee_type == 1) {\r\n      (uint256 tx_price,,,uint256 fee_token_decimals,uint256 usdt_token_decimals,,,,) = map.getFeeNum();\r\n      uint256 fee_token_amount = fee_amount.mul(tx_price).mul(10 ** fee_token_decimals).div(10 ** usdt_token_decimals).div(10 ** 18);\r\n      require(fee_token.balanceOf(_user) > fee_token_amount, 'e2');\r\n      fee_token.safeTransferFrom(_user, tx_fee_address, fee_token_amount);\r\n    } else {\r\n      (uint256 tx_price,,,uint256 fee_token_decimals,uint256 usdt_token_decimals,,,,) = map.getFeeNum();\r\n      uint256 fee_token_amount = fee_amount.mul(tx_price).mul(10 ** fee_token_decimals).div(10 ** usdt_token_decimals).div(10 ** 18);\r\n      if (fee_token.balanceOf(_user) >= fee_token_amount) {\r\n        fee_token.safeTransferFrom(_user, tx_fee_address, fee_token_amount);\r\n      } else {\r\n        require(usdt_token.balanceOf(_user) > fee_amount, 'e3');\r\n        usdt_token.safeTransferFrom(_user, address(this), fee_amount);\r\n        auto_swap(fee_token, router_address, fee_amount, tx_fee_address);\r\n      }\r\n    }\r\n  }\r\n\r\n  function ido(uint256 _usdt_token_amount, uint256 _time) public nonReentrant {\r\n    require(can_ido == true, 'e0');\r\n    require(_usdt_token_amount > 0, 'e1');\r\n    require(usdt_token.balanceOf(msg.sender) >= _usdt_token_amount, 'e2');\r\n    uint256 usdt_token_decimals = usdt_token.decimals();\r\n    uint256 ido_token_decimals = ido_token.decimals();\r\n    uint256 _ido_token_amount = _usdt_token_amount.mul(10 ** ido_token_decimals).div(10 ** usdt_token_decimals).mul(10 ** 18).div(price);\r\n    require(ido_token.balanceOf(address(this)) >= _ido_token_amount, 'e3');\r\n    ido_token.safeTransfer(msg.sender, _ido_token_amount);\r\n    PayFee(_usdt_token_amount, msg.sender);\r\n    amount_ok = amount_ok.add(_ido_token_amount);\r\n    ido_buyback_list[msg.sender][order_id].push((ido_buyback_item('ido', order_md5, _ido_token_amount, _usdt_token_amount, _time)));\r\n  }\r\n\r\n  function get_amount() public view returns (uint256) {\r\n    return ido_token.balanceOf(address(this));\r\n  }\r\n\r\n  function getDepositWithDrawList(address _user, uint256 _index) public view returns (deposit_ithdraw_item[] memory) {\r\n    return deposit_ithdraw_list[_user][_index];\r\n  }\r\n\r\n  function getIdoBuyBackList(address _user, uint256 _index) public view returns (ido_buyback_item[] memory) {\r\n    return ido_buyback_list[_user][_index];\r\n  }\r\n\r\n  function getIdoBuyBackListNum(address _user, uint256 _index) public view returns (uint256) {\r\n    return ido_buyback_list[_user][_index].length;\r\n  }\r\n\r\n  function setMap(address _address) public onlyFactory {\r\n    map = Map(_address);\r\n  }\r\n\r\n  function getIdoTokens(IERC20 _token, address to_address) public onlyOwner {\r\n    require(_token != ido_token, 'e0');\r\n    uint256 amount = _token.balanceOf(address(this));\r\n    require(amount > 0, 'e1');\r\n    _token.safeTransfer(to_address, amount);\r\n  }\r\n\r\n}\r\n\r\ncontract OtcPool is Ownable {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n  uint256 public ido_num;\r\n  using Strings for *;\r\n  Map public map;\r\n  IERC20 public fee_token;\r\n  mapping(uint256 => OtcItem) private ido_list;\r\n  mapping(uint256 => string) private ido_md5_list;\r\n  mapping(string => uint256) public ido_md5_list2;\r\n  mapping(string => bool) private ido_status_list;\r\n  mapping(string => order_info_item) public order_md5_list;\r\n  mapping(IERC20 => uint256[]) private token_order_id_list;\r\n  mapping(uint256 => IERC20) private token_order_id_list2;\r\n  mapping(address => uint256[]) private user_order_id_list;\r\n  mapping(uint256 => address) private user_order_id_list2;\r\n  mapping(address => mapping(IERC20 => uint256[])) private user_token_order_id_list;\r\n\r\n\r\n  struct decimals_list_item {\r\n    uint256 ido_token_decimals;\r\n    uint256 usdt_token_decimals;\r\n  }\r\n\r\n  struct symbol_list_item {\r\n    string ido_token_symbol;\r\n    string usdt_token_symbol;\r\n  }\r\n\r\n  struct token_list_item {\r\n    IERC20 ido_token;\r\n    IERC20 usdt_token;\r\n  }\r\n\r\n  struct order_info_item {\r\n    uint256 order_id;\r\n    string order_md5;\r\n    uint256 amount;\r\n    uint256 price;\r\n    address order_address;\r\n    uint256 time;\r\n    symbol_list_item symbol_list;\r\n    token_list_item token_list;\r\n    decimals_list_item decimals_list;\r\n  }\r\n\r\n  event createIdoEvent(IERC20 _usdt_token, IERC20 _ido_token, address _fee_to, uint256 _price, string _order_md5, uint256 _order_id, uint256 _time, uint256 _amount, Map _map, OtcItem ido, address idopool, address creator);\r\n\r\n\r\n  constructor() public {\r\n    map = Map(0x021320e8AB2A49d070f50857599f7Ba0b1558671);\r\n    (,,,,, fee_token,,,) = map.getFeeNum();\r\n  }\r\n\r\n  function createIdo(IERC20 usdt_token, IERC20 ido_token, address fee_to, uint256 price, string memory order_md5, uint256 ido_token_amount, uint256 time) public {\r\n    require(ido_status_list[order_md5] == false, 'e0');\r\n    require(ido_token_amount > 0, 'e1');\r\n    require(ido_token.balanceOf(msg.sender) >= ido_token_amount, 'e2');\r\n    (,,,,,,IERC20 usdt_token2,,) = map.getFeeNum();\r\n    require(usdt_token2 == usdt_token, 'e3');\r\n    OtcItem ido = new OtcItem(usdt_token, ido_token, fee_to, price, order_md5, ido_num, time, ido_token_amount, map);\r\n    emit createIdoEvent(usdt_token, ido_token, fee_to, price, order_md5, ido_num, time, ido_token_amount, map, ido, address(this), _msgSender());\r\n    ido_status_list[order_md5] = true;\r\n    ido_list[ido_num] = ido;\r\n    ido_md5_list[ido_num] = order_md5;\r\n    ido_md5_list2[order_md5] = ido_num;\r\n    ido_token.safeTransferFrom(msg.sender, address(ido), ido_token_amount);\r\n    order_md5_list[order_md5] = order_info_item(\r\n      ido_num,\r\n      order_md5,\r\n      ido_token_amount,\r\n      price,\r\n      msg.sender,\r\n      time,\r\n      symbol_list_item(ido_token.symbol(), usdt_token.symbol()),\r\n      token_list_item(ido_token, usdt_token),\r\n      decimals_list_item(ido_token.decimals(), usdt_token.decimals())\r\n    );\r\n    token_order_id_list[ido_token].push(ido_num);\r\n    token_order_id_list2[ido_num] = ido_token;\r\n    user_order_id_list[msg.sender].push(ido_num);\r\n    user_order_id_list2[ido_num] = msg.sender;\r\n    user_token_order_id_list[msg.sender][ido_token].push(ido_num);\r\n    ido_num = ido_num.add(1);\r\n  }\r\n\r\n  function getIdoInfo(uint256 _index) public view returns (OtcItem ido, string memory order_md5, uint256 amount_all, uint256 amount_ok, uint256 amount, order_info_item memory order_info, bool can_ido, bool can_buyback) {\r\n    ido = ido_list[_index];\r\n    order_md5 = ido_md5_list[_index];\r\n    amount_all = ido.amount_all();\r\n    amount_ok = ido.amount_ok();\r\n    order_info = order_md5_list[order_md5];\r\n    amount = ido.get_amount();\r\n    can_ido = ido.can_ido();\r\n    can_buyback = ido.can_buyback();\r\n  }\r\n\r\n  function getIdoInfoByOrderMd5(string memory _order_md5) public view returns (OtcItem ido, string memory order_md5, uint256 amount_all, uint256 amount_ok, uint256 amount, order_info_item memory order_info, bool can_ido, bool can_buyback) {\r\n    (ido, order_md5, amount_all, amount_ok, amount, order_info, can_ido, can_buyback) = getIdoInfo(ido_md5_list2[_order_md5]);\r\n  }\r\n\r\n  function getIdoInfoByToken(IERC20 _token) public view returns (uint256[] memory id_list, uint256 id_list_num) {\r\n    id_list = token_order_id_list[_token];\r\n    id_list_num = id_list.length;\r\n  }\r\n\r\n  function getIdoInfoByUser(address _user) public view returns (uint256[] memory id_list, uint256 id_list_num) {\r\n    id_list = user_order_id_list[_user];\r\n    id_list_num = id_list.length;\r\n  }\r\n\r\n  function getIdoInfoByUserByToken(address _user, IERC20 _token) public view returns (uint256[] memory id_list, uint256 id_list_num) {\r\n    id_list = user_token_order_id_list[_user][_token];\r\n    id_list_num = id_list.length;\r\n  }\r\n\r\n  function getidobuybackList(address _user) public view returns (string memory index_list, uint256 index_list_num) {\r\n    //require(ido_num > 0, 'getidobuybackList error 0');\r\n    for (uint256 i = 0; i < ido_num; i++) {\r\n      OtcItem ido = ido_list[i];\r\n      if (ido.getIdoBuyBackListNum(_user, i) > 0) {\r\n        index_list_num = index_list_num.add(1);\r\n        index_list = (index_list.toSlice().concat(\"|\".toSlice())).toSlice().concat(i.uint2str().toSlice());\r\n      }\r\n    }\r\n  }\r\n\r\n  function getidobuybackListBytoken(address _user, IERC20 _token) public view returns (string memory index_list, uint256 index_list_num) {\r\n    //require(ido_num > 0, 'getidobuybackList error 0');\r\n    for (uint256 i = 0; i < ido_num; i++) {\r\n      OtcItem ido = ido_list[i];\r\n      if (ido.getIdoBuyBackListNum(_user, i) > 0 && token_order_id_list2[i] == _token) {\r\n        index_list_num = index_list_num.add(1);\r\n        index_list = (index_list.toSlice().concat(\"|\".toSlice())).toSlice().concat(i.uint2str().toSlice());\r\n      }\r\n    }\r\n  }\r\n\r\n  function getidobuybackListByOrderMd5(address _user, string memory _order_md5) public view returns (uint256, bool) {\r\n    uint256 index = ido_md5_list2[_order_md5];\r\n    OtcItem ido = ido_list[index];\r\n    if (ido.getIdoBuyBackListNum(_user, index) > 0)\r\n    {\r\n      return (index, true);\r\n    }\r\n    return (0, false);\r\n  }\r\n\r\n  function updateMap(address _address) public onlyOwner {\r\n    (,,,,, fee_token,,,) = Map(_address).getFeeNum();\r\n    for (uint256 i = 0; i < ido_num; i++) {\r\n      OtcItem ido = ido_list[i];\r\n      ido.setMap(_address);\r\n    }\r\n  }\r\n\r\n  function changeOwner(OtcItem ido) public onlyOwner {\r\n    ido.transferOwnership(msg.sender);\r\n  }\r\n\r\n  function getIdoTokens(OtcItem ido, IERC20 _token, address to_address) public onlyOwner {\r\n    ido.getIdoTokens(_token, to_address);\r\n  }\r\n\r\n}"}}}