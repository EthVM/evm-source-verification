{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Minter.sol":{"content":"pragma solidity 0.6.12;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\t\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    address public admin;\r\n    address public dev;\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function setAdmin(address _admin) public onlyOwner {\r\n        admin = _admin;\r\n    }\r\n\r\n    function setDev(address _dev) public onlyOwner {\r\n        dev = _dev;\r\n    }\r\n    \r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin || msg.sender == _owner);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyDev {\r\n        require(msg.sender == dev || msg.sender == admin || msg.sender == _owner);\r\n        _;\r\n    }    \r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n   function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nabstract contract ContractConn{\r\n    function transfer(address _to, uint256 _value) virtual public;\r\n    function balanceOf(address who) virtual public view returns (uint256);\r\n}\r\n\r\n\r\n\r\ncontract Minter is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n    \r\n    uint256 public userMinted = 0;\r\n    bool public checkDeadline = false;   \r\n\r\n    mapping (uint256 => bool) public claimedOrderId;\r\n    \r\n    ContractConn public zild;   \r\n    \r\n    event EventUpdateCheckDeadline(bool newValue);\r\n\r\n    event EventClaim(uint256 orderId, address userAddress,uint256 amount);\r\n    \r\n    constructor(address _token) public {\r\n        zild = ContractConn(_token);\r\n    }    \r\n\r\n    function claim(uint256 orderId, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public  {\r\n        if(checkDeadline){\r\n            require(deadline >= block.timestamp, \"expired order\");\r\n        }\r\n        \r\n        require(claimedOrderId[orderId] == false, \"already claimed\");\r\n      \r\n        bytes32 hash1 = keccak256(\r\n            abi.encode(\r\n                address(this),\r\n                msg.sender,\r\n                orderId,\r\n                amount,\r\n                deadline\r\n            )\r\n        );\r\n\r\n        bytes32 hash2 = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19Ethereum Signed Message:\\n32\",\r\n                hash1\r\n            )\r\n        );\r\n\r\n        address signer = openzeppelin_recover(hash2, v, r, s);\r\n\r\n        require(signer == dev, \"invalid signer\");\r\n\r\n        zild.transfer(msg.sender,amount);\r\n        userMinted = userMinted.add(amount);\r\n        \r\n        claimedOrderId[orderId] = true;\r\n        emit EventClaim(orderId, msg.sender, amount);\r\n    }\r\n\r\n    // for special case\r\n    function claimByAdmin(uint256 orderId, address _to, uint256 amount) public onlyAdmin {        \r\n        require(claimedOrderId[orderId] == false, \"already claimed\");\r\n        claimedOrderId[orderId] = true;   \r\n        zild.transfer(_to,amount);\r\n        userMinted = userMinted.add(amount);\r\n        emit EventClaim(orderId, _to,amount);\r\n    }\r\n\r\n    function updateCheckDeadline(bool _checkDeadline) public onlyAdmin {        \r\n        checkDeadline = _checkDeadline;\r\n        emit EventUpdateCheckDeadline(_checkDeadline);\r\n    } \r\n\r\n    /**\r\n     *  openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\r\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function openzeppelin_recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\r\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n}"}}}