{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "FeeCollectorFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n// @author: 0age\r\n\r\n\r\ninterface FeeCollectorFactoryInterface {\r\n    function getDeploymentAddress(\r\n        FeeRecipient[] memory feeRecipients\r\n    ) external view returns (address);\r\n\r\n    function deployAndCollect(\r\n        FeeRecipient[] calldata feeRecipients,\r\n        address[] calldata tokens,\r\n        uint256 gasPerTransfer // maximum gas submitter is willing to spend to process each transfer\r\n    ) external;\r\n\r\n    event Deployed(\r\n        address feeCollector,\r\n        FeeRecipient[] feeRecipients\r\n    );\r\n}\r\n\r\n\r\ninterface FeeCollectorInterface {\r\n    function feeRecipients() external view returns (\r\n        FeeRecipient[] memory feeRecipients\r\n    );\r\n\r\n    function initialize(FeeRecipient[] memory feeRecipients_) external; // only callable by factory\r\n\r\n    function collect(\r\n        address[] calldata tokens, // use 0xeeee...eeee for Ether\r\n        uint256 gasPerTransfer     // maximum gas submitter is willing to spend to process each transfer\r\n    ) external returns (\r\n        CollectedTokenAmount[] memory amounts\r\n    ); // arrays of recipient amounts nested in arrays of tokens\r\n\r\n    event Collected(address token, uint256[] amounts); // emitted for each token collected\r\n\r\n    error NotEnoughFeeRecipients();\r\n    error TooManyFeeRecipients();\r\n    error InvalidFeeBips();\r\n    error NoBalance(address token);\r\n    error GasPerTransferTooLow(uint256 gasPerTransferShortfall);\r\n    error BadReturnValueFromTokenOnTransfer(address token, address to);\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\nstruct FeeRecipient {\r\n    address payable account;\r\n    uint16 feeBips;\r\n}\r\n\r\n\r\nstruct CollectedTokenAmount {\r\n    uint256[] amounts;\r\n}\r\n\r\n\r\ncontract FeeCollectorFactory is FeeCollectorFactoryInterface {\r\n    address immutable private _feeCollectorImplementation;\r\n\r\n    constructor() {\r\n        FeeCollectorImplementation implementation = new FeeCollectorImplementation();\r\n        _feeCollectorImplementation = address(implementation);\r\n    }\r\n\r\n    function getDeploymentAddress(\r\n        FeeRecipient[] memory feeRecipients\r\n    ) external view returns (address) {\r\n        return address(uint160(uint(keccak256(abi.encodePacked(\r\n            bytes1(0xff),\r\n            address(this),\r\n            uint256(0),\r\n            keccak256(abi.encodePacked(\r\n                type(FeeCollectorProxy).creationCode,\r\n                abi.encode(_feeCollectorImplementation, feeRecipients)\r\n            ))\r\n        )))));\r\n    }\r\n\r\n    function deployAndCollect(\r\n        FeeRecipient[] memory feeRecipients,\r\n        address[] memory tokens,\r\n        uint256 gasPerTransfer\r\n    ) public {\r\n        FeeCollectorProxy feeCollector = new FeeCollectorProxy{salt: 0}(\r\n            _feeCollectorImplementation,\r\n            feeRecipients\r\n        );\r\n\r\n        emit Deployed(\r\n            address(feeCollector),\r\n            feeRecipients\r\n        );\r\n\r\n        FeeCollectorInterface(address(feeCollector)).collect(\r\n            tokens, gasPerTransfer\r\n        );\r\n    }\r\n}\r\n\r\n\r\ncontract FeeCollectorImplementation is FeeCollectorInterface {\r\n    address private constant _ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    FeeRecipient[] private _feeRecipients;\r\n\r\n    function initialize(FeeRecipient[] memory feeRecipients_) external {\r\n        // Ensure this function is only callable during contract construction.\r\n        assembly { if extcodesize(address()) { revert(0, 0) } }\r\n\r\n        if (feeRecipients_.length < 2) {\r\n            revert NotEnoughFeeRecipients();\r\n        }\r\n\r\n        if (feeRecipients_.length > 10) {\r\n            revert TooManyFeeRecipients();\r\n        }\r\n\r\n        uint256 totalFeeBips;\r\n        for (uint256 i = 0; i < feeRecipients_.length; i++) {\r\n            FeeRecipient memory feeRecipient = feeRecipients_[i];\r\n            _feeRecipients.push(feeRecipient);\r\n            totalFeeBips += uint256(feeRecipient.feeBips);\r\n        }\r\n\r\n        if (totalFeeBips != 10_000) {\r\n            revert InvalidFeeBips();\r\n        }\r\n    }\r\n\r\n    function collect(\r\n        address[] memory tokens,\r\n        uint256 gasPerTransfer\r\n    ) public returns (\r\n        CollectedTokenAmount[] memory amountsPerToken\r\n    ) {\r\n        if (gasPerTransfer < 100_000) {\r\n            revert GasPerTransferTooLow(100_000 - gasPerTransfer);\r\n        }\r\n\r\n        uint256 totalFeeRecipients = _feeRecipients.length;\r\n\r\n        amountsPerToken = new CollectedTokenAmount[](tokens.length);\r\n\r\n        uint256[] memory amounts = new uint256[](totalFeeRecipients);\r\n\r\n        for (uint256 t = 0; t < tokens.length; t++) {\r\n            address token = tokens[t];\r\n\r\n            if (token == _ETH) {\r\n                amountsPerToken[t].amounts =  _collectEth(\r\n                    gasPerTransfer, totalFeeRecipients\r\n                );\r\n                continue;\r\n            }\r\n\r\n            uint256 balance = IERC20(token).balanceOf(address(this));\r\n\r\n            if (balance == 0) {\r\n                revert NoBalance(token);\r\n            }\r\n\r\n            uint256 amount;\r\n            bool transferSucceeded;\r\n            for (uint256 i = 1; i < totalFeeRecipients; i++) {\r\n                FeeRecipient memory feeRecipient = _feeRecipients[i];\r\n                amount = (balance * uint256(feeRecipient.feeBips)) / 10_000;\r\n\r\n                (bool ok, bytes memory data) = token.call{gas: gasPerTransfer}(\r\n                    abi.encodeWithSelector(\r\n                        IERC20.transfer.selector, feeRecipient.account, amount\r\n                    )\r\n                );\r\n\r\n                transferSucceeded = ok && (\r\n                    (data.length == 32 && abi.decode(data, (bool))) ||\r\n                    data.length == 0\r\n                );\r\n\r\n                if (!transferSucceeded) {\r\n                    amount = 0;\r\n                }\r\n\r\n                amounts[i] = amount;\r\n            }\r\n\r\n            amount = IERC20(token).balanceOf(address(this));\r\n            if (amount != 0) {\r\n                FeeRecipient memory primaryFeeRecipient = _feeRecipients[0];\r\n\r\n                (bool primaryOk, bytes memory primaryData) = token.call(\r\n                    abi.encodeWithSelector(\r\n                        IERC20.transfer.selector,\r\n                        primaryFeeRecipient.account,\r\n                        amount\r\n                    )\r\n                );\r\n                if (!primaryOk) {\r\n                    assembly {\r\n                        returndatacopy(0, 0, returndatasize())\r\n                        revert(0, returndatasize())\r\n                    }\r\n                }\r\n\r\n                transferSucceeded = (\r\n                    (\r\n                        primaryData.length == 32 &&\r\n                        abi.decode(primaryData, (bool))\r\n                    ) ||\r\n                    primaryData.length == 0\r\n                );\r\n\r\n                if (!transferSucceeded) {\r\n                    revert BadReturnValueFromTokenOnTransfer(\r\n                        token, primaryFeeRecipient.account\r\n                    );\r\n                }\r\n\r\n                amounts[0] = amount;\r\n            }\r\n\r\n            emit Collected(token, amounts);\r\n\r\n            amountsPerToken[t].amounts = amounts;\r\n        }\r\n\r\n        return amountsPerToken;\r\n    }\r\n\r\n    function feeRecipients() external view returns (FeeRecipient[] memory) {\r\n        return _feeRecipients;\r\n    }\r\n\r\n    function _collectEth(\r\n        uint256 gasPerTransfer,\r\n        uint256 totalFeeRecipients\r\n    ) internal returns (\r\n        uint256[] memory amounts\r\n    ) {\r\n        uint256 balance = address(this).balance;\r\n\r\n        if (balance == 0) {\r\n            revert NoBalance(_ETH);\r\n        }\r\n\r\n        amounts = new uint256[](totalFeeRecipients);\r\n\r\n        uint256 amount;\r\n        bool ok;\r\n        for (uint256 i = 1; i < totalFeeRecipients; i++) {\r\n            FeeRecipient memory feeRecipient = _feeRecipients[i];\r\n            amount = (balance * uint256(feeRecipient.feeBips)) / 10_000;\r\n\r\n            (ok,) = feeRecipient.account.call{\r\n                value: amount,\r\n                gas: gasPerTransfer\r\n            }(\"\");\r\n\r\n            if (!ok) {\r\n                amount = 0;\r\n            }\r\n\r\n            amounts[i] = amount;\r\n        }\r\n\r\n        amount = address(this).balance;\r\n        if (amount == 0) {\r\n            return amounts;\r\n        }\r\n\r\n        FeeRecipient memory primaryFeeRecipient = _feeRecipients[0];\r\n\r\n        (ok,) = primaryFeeRecipient.account.call{value: amount}(\"\");\r\n            if (!ok) {\r\n                assembly {\r\n                    returndatacopy(0, 0, returndatasize())\r\n                    revert(0, returndatasize())\r\n                }\r\n            }\r\n\r\n        amounts[0] = amount;\r\n\r\n        emit Collected(_ETH, amounts);\r\n\r\n        return amounts;\r\n    }\r\n}\r\n\r\ncontract FeeCollectorProxy {\r\n    constructor(\r\n        address feeCollectorImplementation,\r\n        FeeRecipient[] memory feeRecipients\r\n    ) {\r\n        (bool ok,) = feeCollectorImplementation.delegatecall(\r\n            abi.encodeWithSelector(\r\n                FeeCollectorInterface.initialize.selector, feeRecipients\r\n            )\r\n        );\r\n        if (!ok) {\r\n            assembly {\r\n                returndatacopy(0, 0, returndatasize())\r\n                revert(0, returndatasize())\r\n            }\r\n        }\r\n\r\n        // place more-minimal proxy runtime code in memory.\r\n        bytes memory runtimeCode = abi.encodePacked(\r\n            bytes11(0x3d3d3d3d363d3d37363d73),\r\n            feeCollectorImplementation,\r\n            bytes13(0x5af43d3d93803e602a57fd5bf3)\r\n        );\r\n\r\n        // return more-minimal proxy code to write it to contract runtime.\r\n        assembly {\r\n            return(add(0x20, runtimeCode), 44) // runtime code, length\r\n        }\r\n    }\r\n}"
    }
  }
}