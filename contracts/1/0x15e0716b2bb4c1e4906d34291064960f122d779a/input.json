{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 0
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MarbleNFTFactory.sol": {
      "content": "// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev ERC-721 non-fungible token standard. See https://goo.gl/pc9yoS.\r\n */\r\ninterface ERC721 {\r\n\r\n  /**\r\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n   * transfer, the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n   * address indicates there is no approved address. When a Transfer event emits, this also\r\n   * indicates that the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n   * all NFTs of the owner.\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n   * invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received`\r\n   * on `_to` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\"\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT.\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they mayb be permanently lost.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Set or reaffirm the approved address for an NFT.\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @param _approved The new approved NFT controller.\r\n   * @param _tokenId The NFT to approve.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n   * @notice The contract MUST allow multiple operators per owner.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Get the approved address for a single NFT.\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @param _tokenId The NFT to find the approved address for.\r\n   */\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721Enumerable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\r\n * See https://goo.gl/pc9yoS.\r\n */\r\ninterface ERC721Enumerable {\r\n\r\n  /**\r\n   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\r\n   * assigned and queryable owner not equal to the zero address.\r\n   */\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\r\n   * @param _index A counter less than `totalSupply()`.\r\n   */\r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\r\n   * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\r\n   * representing invalid NFTs.\r\n   * @param _owner An address where we are interested in NFTs owned by them.\r\n   * @param _index A counter less than `balanceOf(_owner)`.\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721Metadata.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev Optional metadata extension for ERC-721 non-fungible token standard.\r\n * See https://goo.gl/pc9yoS.\r\n */\r\ninterface ERC721Metadata {\r\n\r\n  /**\r\n   * @dev Returns a descriptive name for a collection of NFTs in this contract.\r\n   */\r\n  function name()\r\n    external\r\n    view\r\n    returns (string _name);\r\n\r\n  /**\r\n   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\r\n   */\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string _symbol);\r\n\r\n  /**\r\n   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\r\n   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\r\n   * that conforms to the \"ERC721 Metadata JSON Schema\".\r\n   */\r\n  function tokenURI(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (string);\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/utils/ERC165.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev A standard for detecting smart contract interfaces. See https://goo.gl/cxQCse.\r\n */\r\ninterface ERC165 {\r\n\r\n  /**\r\n   * @dev Checks if the smart contract includes a specific interface.\r\n   * @notice This function uses less than 30,000 gas.\r\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/utils/SupportsInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @dev Implementation of standard for detect smart contract interfaces.\r\n */\r\ncontract SupportsInterface is\r\n  ERC165\r\n{\r\n\r\n  /**\r\n   * @dev Mapping of supported intefraces.\r\n   * @notice You must not set element 0xffffffff to true.\r\n   */\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check which interfaces are suported by this contract.\r\n   * @param _interfaceID Id of the interface.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceID];\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev Math operations with safety checks that throw on error. This contract is based\r\n * on the source code at https://goo.gl/iyQsmU.\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, throws on overflow.\r\n   * @param _a Factor number.\r\n   * @param _b Factor number.\r\n   */\r\n  function mul(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient.\r\n   * @param _a Dividend number.\r\n   * @param _b Divisor number.\r\n   */\r\n  function div(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    uint256 c = _a / _b;\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   * @param _a Minuend number.\r\n   * @param _b Subtrahend number.\r\n   */\r\n  function sub(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, throws on overflow.\r\n   * @param _a Number.\r\n   * @param _b Number.\r\n   */\r\n  function add(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    uint256 c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev The contract has an owner address, and provides basic authorization control whitch\r\n * simplifies the implementation of user permissions. This contract is based on the source code\r\n * at https://goo.gl/n2ZGVt.\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev An event which is triggered when the owner is changed.\r\n   * @param previousOwner The address of the previous owner.\r\n   * @param newOwner The address of the new owner.\r\n   */\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The constructor sets the original `owner` of the contract to the sender account.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(\r\n    address _newOwner\r\n  )\r\n    onlyOwner\r\n    public\r\n  {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/ownership/Claimable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @dev The contract has an owner address, and provides basic authorization control whitch\r\n * simplifies the implementation of user permissions. This contract is based on the source code\r\n * at goo.gl/CfEAkv and upgrades Ownable contracts with additional claim step which makes ownership\r\n * transfers less prone to errors.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev An event which is triggered when the owner is changed.\r\n   * @param previousOwner The address of the previous owner.\r\n   * @param newOwner The address of the new owner.\r\n   */\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev Allows the current owner to give new owner ability to claim the ownership of the contract.\r\n   * This differs from the Owner's function in that it allows setting pedingOwner address to 0x0,\r\n   * which effectively cancels an active claim.\r\n   * @param _newOwner The address which can claim ownership of the contract.\r\n   */\r\n  function transferOwnership(\r\n    address _newOwner\r\n  )\r\n    onlyOwner\r\n    public\r\n  {\r\n    pendingOwner = _newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current pending owner to claim the ownership of the contract. It emits\r\n   * OwnershipTransferred event and resets pending owner to 0.\r\n   */\r\n  function claimOwnership()\r\n    public\r\n  {\r\n    require(msg.sender == pendingOwner);\r\n    address previousOwner = owner;\r\n    owner = pendingOwner;\r\n    pendingOwner = 0;\r\n    emit OwnershipTransferred(previousOwner, owner);\r\n  }\r\n}\r\n\r\n// File: contracts/Adminable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Adminable\r\n * @dev Allows to manage privilages to special contract functionality.\r\n */\r\ncontract Adminable is Claimable {\r\n  mapping(address => uint) public adminsMap;\r\n  address[] public adminList;\r\n\r\n  /**\r\n   * @dev Returns true, if provided address has special privilages, otherwise false\r\n   * @param adminAddress - address to check\r\n   */\r\n  function isAdmin(address adminAddress)\r\n    public\r\n    view\r\n    returns(bool isIndeed)\r\n  {\r\n    if (adminAddress == owner) return true;\r\n\r\n    if (adminList.length == 0) return false;\r\n    return (adminList[adminsMap[adminAddress]] == adminAddress);\r\n  }\r\n\r\n  /**\r\n   * @dev Grants special rights for address holder\r\n   * @param adminAddress - address of future admin\r\n   */\r\n  function addAdmin(address adminAddress)\r\n    public\r\n    onlyOwner\r\n    returns(uint index)\r\n  {\r\n    require(!isAdmin(adminAddress), \"Address already has admin rights!\");\r\n\r\n    adminsMap[adminAddress] = adminList.push(adminAddress)-1;\r\n\r\n    return adminList.length-1;\r\n  }\r\n\r\n  /**\r\n   * @dev Removes special rights for provided address\r\n   * @param adminAddress - address of current admin\r\n   */\r\n  function removeAdmin(address adminAddress)\r\n    public\r\n    onlyOwner\r\n    returns(uint index)\r\n  {\r\n    // we can not remove owner from admin role\r\n    require(owner != adminAddress, \"Owner can not be removed from admin role!\");\r\n    require(isAdmin(adminAddress), \"Provided address is not admin.\");\r\n\r\n    uint rowToDelete = adminsMap[adminAddress];\r\n    address keyToMove = adminList[adminList.length-1];\r\n    adminList[rowToDelete] = keyToMove;\r\n    adminsMap[keyToMove] = rowToDelete;\r\n    adminList.length--;\r\n\r\n    return rowToDelete;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyAdmin() {\r\n    require(isAdmin(msg.sender), \"Can be executed only by admin accounts!\");\r\n    _;\r\n  }\r\n}\r\n\r\n// File: contracts/Pausable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism for mainenance purposes\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause()\r\n    external\r\n    onlyOwner\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    paused = true;\r\n    emit Pause();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause()\r\n    external\r\n    onlyOwner\r\n    whenPaused\r\n    returns (bool)\r\n  {\r\n    paused = false;\r\n    emit Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/MarbleNFTCandidateInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Marble NFT Candidate Contract\r\n * @dev Contracts allows public audiance to create Marble NFT candidates. All our candidates for NFT goes through our services to figure out if they are suitable for Marble NFT.\r\n * once their are picked our other contract will create NFT with same owner as candite and plcae it to minting auction. In minitng auction everyone can buy created NFT until duration period.\r\n * If duration is over, and noone has bought NFT, then creator of candidate can take Marble NFT from minting auction to his collection.\r\n */\r\ninterface MarbleNFTCandidateInterface {\r\n\r\n  /**\r\n   * @dev Sets minimal price for creating Marble NFT Candidate\r\n   * @param _minimalMintingPrice Minimal price asked from creator of Marble NFT candidate (weis)\r\n   */\r\n  function setMinimalPrice(uint256 _minimalMintingPrice)\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns true if URI is already a candidate. Otherwise false.\r\n   * @param _uri URI to check\r\n   */\r\n  function isCandidate(string _uri)\r\n    external\r\n    view\r\n    returns(bool isIndeed);\r\n\r\n\r\n  /**\r\n   * @dev Creates Marble NFT Candidate. This candidate will go through our processing. If it's suitable, then Marble NFT is created.\r\n   * @param _uri URI of resource you want to transform to Marble NFT\r\n   */\r\n  function createCandidate(string _uri)\r\n    external\r\n    payable\r\n    returns(uint index);\r\n\r\n  /**\r\n   * @dev Removes URI from candidate list.\r\n   * @param _uri URI to be removed from candidate list.\r\n   */\r\n  function removeCandidate(string _uri)\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns total count of candidates.\r\n   */\r\n  function getCandidatesCount()\r\n    external\r\n    view\r\n    returns(uint256 count);\r\n\r\n  /**\r\n   * @dev Transforms URI to hash.\r\n   * @param _uri URI to be transformed to hash.\r\n   */\r\n  function getUriHash(string _uri)\r\n    external\r\n    view\r\n    returns(uint256 hash);\r\n\r\n  /**\r\n   * @dev Returns Candidate model by URI\r\n   * @param _uri URI representing candidate\r\n   */\r\n  function getCandidate(string _uri)\r\n    external\r\n    view\r\n    returns(\r\n    uint256 index,\r\n    address owner,\r\n    uint256 mintingPrice,\r\n    string url,\r\n    uint256 created);\r\n}\r\n\r\n// File: contracts/MarbleDutchAuctionInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Marble Dutch Auction Interface\r\n * @dev describes all externaly accessible functions neccessery to run Marble Auctions\r\n */\r\ninterface MarbleDutchAuctionInterface {\r\n\r\n  /**\r\n   * @dev Sets new auctioneer cut, in case we are to cheap :))\r\n   * @param _cut - percent cut the auctioneer takes on each auction, must be between 0-100. Values 0-10,000 map to 0%-100%.\r\n   */\r\n  function setAuctioneerCut(\r\n    uint256 _cut\r\n  )\r\n   external;\r\n\r\n  /**\r\n  * @dev Sets new auctioneer delayed cut, in case we are not earning much during creating NFTs initial auctions!\r\n  * @param _cut Percent cut the auctioneer takes on each auction, must be between 0-10000. Values 0-10,000 map to 0%-100%.\r\n  */\r\n  function setAuctioneerDelayedCancelCut(\r\n    uint256 _cut\r\n  )\r\n   external;\r\n\r\n  /**\r\n   * @dev Sets an addresses of ERC 721 contract owned/admined by same entity.\r\n   * @param _nftAddress Address of ERC 721 contract\r\n   */\r\n  function setNFTContract(address _nftAddress)\r\n    external;\r\n\r\n\r\n  /**\r\n   * @dev Creates new auction without special logic. It allows user to sell owned Marble NFTs\r\n   * @param _tokenId ID of token to auction, sender must be owner.\r\n   * @param _startingPrice Price of item (in wei) at beginning of auction.\r\n   * @param _endingPrice Price of item (in wei) at end of auction.\r\n   * @param _duration Length of time to move between starting price and ending price (in seconds) - it determines dynamic state of auction\r\n   */\r\n  function createAuction(\r\n    uint256 _tokenId,\r\n    uint256 _startingPrice,\r\n    uint256 _endingPrice,\r\n    uint256 _duration\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Creates and begins a new minting auction. Minitng auction is initial auction allowing to challenge newly Minted Marble NFT.\r\n   * If no-one buy NFT during dynamic state of auction, then seller (original creator of NFT) will be allowed to become owner of NFT. It means during dynamic (duration)\r\n   * state of auction, it won't be possible to use cancelAuction function by seller!\r\n   * @param _tokenId - ID of token to auction, sender must be owner.\r\n   * @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n   * @param _endingPrice - Price of item (in wei) at end of auction.\r\n   * @param _duration - Length of time to move between starting price and ending price (in seconds).\r\n   * @param _seller - Seller, if not the message sender\r\n   */\r\n  function createMintingAuction(\r\n    uint256 _tokenId,\r\n    uint256 _startingPrice,\r\n    uint256 _endingPrice,\r\n    uint256 _duration,\r\n    address _seller\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev It allows seller to cancel auction and get back Marble NFT.\r\n   * @param _tokenId ID of token on auction\r\n   */\r\n  function cancelAuction(\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev It allows seller to cancel auction and get back Marble NFT.\r\n   * @param _tokenId ID of token on auction\r\n   */\r\n  function cancelAuctionWhenPaused(\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Bids on an open auction, completing the auction and transferring ownership of the NFT if enough Ether is supplied.\r\n   * @param _tokenId ID of token to bid on.\r\n   */\r\n  function bid(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    payable;\r\n\r\n  /**\r\n   * @dev Returns the current price of an auction.\r\n   * @param _tokenId ID of the token price we are checking.\r\n   */\r\n  function getCurrentPrice(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the count of all existing auctions.\r\n   */\r\n  function totalAuctions()\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns NFT ID by its index.\r\n   * @param _index A counter less than `totalSupply()`.\r\n   */\r\n  function tokenInAuctionByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the n-th NFT ID from a list of owner's tokens.\r\n   * @param _seller Token owner's address.\r\n   * @param _index Index number representing n-th token in owner's list of tokens.\r\n   */\r\n  function tokenOfSellerByIndex(\r\n    address _seller,\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the count of all existing auctions.\r\n   */\r\n  function totalAuctionsBySeller(\r\n    address _seller\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns true if the NFT is on auction.\r\n   * @param _tokenId ID of the token to be checked.\r\n   */\r\n  function isOnAuction(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (bool isIndeed);\r\n\r\n  /**\r\n   * @dev Returns auction info for an NFT on auction.\r\n   * @param _tokenId ID of NFT placed in auction\r\n   */\r\n  function getAuction(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns\r\n  (\r\n    address seller,\r\n    uint256 startingPrice,\r\n    uint256 endingPrice,\r\n    uint256 duration,\r\n    uint256 startedAt,\r\n    bool canBeCanceled\r\n  );\r\n\r\n  /**\r\n   * @dev remove NFT reference from auction conrtact, should be use only when NFT is being burned\r\n   * @param _tokenId ID of token on auction\r\n   */\r\n  function removeAuction(\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n}\r\n\r\n// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721TokenReceiver.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev ERC-721 interface for accepting safe transfers. See https://goo.gl/pc9yoS.\r\n */\r\ninterface ERC721TokenReceiver {\r\n\r\n  /**\r\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\r\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n   * of other than the magic value MUST result in the transaction being reverted.\r\n   * Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing.\r\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\r\n   * MUST implement the wallet interface if it will accept safe transfers.\r\n   * @param _operator The address which called `safeTransferFrom` function.\r\n   * @param _from The address which previously owned the token.\r\n   * @param _tokenId The NFT identifier which is being transferred.\r\n   * @param _data Additional data with no specified format.\r\n   */\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    external\r\n    returns(bytes4);\r\n    \r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/utils/AddressUtils.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev Utility library of inline functions on addresses.\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * @dev Returns whether the target address is a contract.\r\n   * @param _addr Address to check.\r\n   */\r\n  function isContract(\r\n    address _addr\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    uint256 size;\r\n\r\n    /**\r\n     * XXX Currently there is no better way to check if there is a contract in an address than to\r\n     * check the size of the code at that address.\r\n     * See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\r\n     * TODO: Check this again before the Serenity release, because all addresses will be\r\n     * contracts then.\r\n     */\r\n    assembly { size := extcodesize(_addr) } // solium-disable-line security/no-inline-assembly\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-erc721/contracts/tokens/NFToken.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of ERC-721 non-fungible token standard.\r\n */\r\ncontract NFToken is\r\n  ERC721,\r\n  SupportsInterface\r\n{\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  /**\r\n   * @dev A mapping from NFT ID to the address that owns it.\r\n   */\r\n  mapping (uint256 => address) internal idToOwner;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to approved address.\r\n   */\r\n  mapping (uint256 => address) internal idToApprovals;\r\n\r\n   /**\r\n   * @dev Mapping from owner address to count of his tokens.\r\n   */\r\n  mapping (address => uint256) internal ownerToNFTokenCount;\r\n\r\n  /**\r\n   * @dev Mapping from owner address to mapping of operator addresses.\r\n   */\r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n  /**\r\n   * @dev Magic value of a smart contract that can recieve NFT.\r\n   * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\r\n   */\r\n  bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  /**\r\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n   * transfer, the approved address for that NFT (if any) is reset to none.\r\n   * @param _from Sender of NFT (if address is zero address it indicates token creation).\r\n   * @param _to Receiver of NFT (if address is zero address it indicates token destruction).\r\n   * @param _tokenId The NFT that got transfered.\r\n   */\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n   * address indicates there is no approved address. When a Transfer event emits, this also\r\n   * indicates that the approved address for that NFT (if any) is reset to none.\r\n   * @param _owner Owner of NFT.\r\n   * @param _approved Address that we are approving.\r\n   * @param _tokenId NFT which we are approving.\r\n   */\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n   * all NFTs of the owner.\r\n   * @param _owner Owner of NFT.\r\n   * @param _operator Address to which we are setting operator rights.\r\n   * @param _approved Status of operator rights(true if operator rights are given and false if\r\n   * revoked).\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  /**\r\n   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\r\n   * @param _tokenId ID of the NFT to validate.\r\n   */\r\n  modifier canOperate(\r\n    uint256 _tokenId\r\n  ) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Guarantees that the msg.sender is allowed to transfer NFT.\r\n   * @param _tokenId ID of the NFT to transfer.\r\n   */\r\n  modifier canTransfer(\r\n    uint256 _tokenId\r\n  ) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender\r\n      || getApproved(_tokenId) == msg.sender\r\n      || ownerToOperators[tokenOwner][msg.sender]\r\n    );\r\n\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Guarantees that _tokenId is a valid Token.\r\n   * @param _tokenId ID of the NFT to validate.\r\n   */\r\n  modifier validNFToken(\r\n    uint256 _tokenId\r\n  ) {\r\n    require(idToOwner[_tokenId] != address(0));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_owner != address(0));\r\n    return ownerToNFTokenCount[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n   * invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address _owner)\r\n  {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0));\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received`\r\n   * on `_to` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    external\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\"\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT.\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they maybe be permanently lost.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from);\r\n    require(_to != address(0));\r\n\r\n    _transfer(_to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Set or reaffirm the approved address for an NFT.\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @param _approved Address to be approved for the given NFT ID.\r\n   * @param _tokenId ID of the token to be approved.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    canOperate(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(_approved != tokenOwner);\r\n\r\n    idToApprovals[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n   * @notice This works even if sender doesn't own any tokens at the time.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external\r\n  {\r\n    require(_operator != address(0));\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Get the approved address for a single NFT.\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @param _tokenId ID of the NFT to query the approval of.\r\n   */\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (address)\r\n  {\r\n    return idToApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if `_operator` is an approved operator for `_owner`.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(_owner != address(0));\r\n    require(_operator != address(0));\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Actually perform the safeTransferFrom.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function _safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    internal\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from);\r\n    require(_to != address(0));\r\n\r\n    _transfer(_to, _tokenId);\r\n\r\n    if (_to.isContract()) {\r\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n      require(retval == MAGIC_ON_ERC721_RECEIVED);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Actually preforms the transfer.\r\n   * @notice Does NO checks.\r\n   * @param _to Address of a new owner.\r\n   * @param _tokenId The NFT that is being transferred.\r\n   */\r\n  function _transfer(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    private\r\n  {\r\n    address from = idToOwner[_tokenId];\r\n    clearApproval(_tokenId);\r\n\r\n    removeNFToken(from, _tokenId);\r\n    addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(from, _to, _tokenId);\r\n  }\r\n   \r\n  /**\r\n   * @dev Mints a new NFT.\r\n   * @notice This is a private function which should be called from user-implemented external\r\n   * mint function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _to The address that will own the minted NFT.\r\n   * @param _tokenId of the NFT to be minted by the msg.sender.\r\n   */\r\n  function _mint(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    require(_to != address(0));\r\n    require(_tokenId != 0);\r\n    require(idToOwner[_tokenId] == address(0));\r\n\r\n    addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Burns a NFT.\r\n   * @notice This is a private function which should be called from user-implemented external\r\n   * burn function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _owner Address of the NFT owner.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function _burn(\r\n    address _owner,\r\n    uint256 _tokenId\r\n  )\r\n    validNFToken(_tokenId)\r\n    internal\r\n  {\r\n    clearApproval(_tokenId);\r\n    removeNFToken(_owner, _tokenId);\r\n    emit Transfer(_owner, address(0), _tokenId);\r\n  }\r\n\r\n  /** \r\n   * @dev Clears the current approval of a given NFT ID.\r\n   * @param _tokenId ID of the NFT to be transferred.\r\n   */\r\n  function clearApproval(\r\n    uint256 _tokenId\r\n  )\r\n    private\r\n  {\r\n    if(idToApprovals[_tokenId] != 0)\r\n    {\r\n      delete idToApprovals[_tokenId];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a NFT from owner.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _from Address from wich we want to remove the NFT.\r\n   * @param _tokenId Which NFT we want to remove.\r\n   */\r\n  function removeNFToken(\r\n    address _from,\r\n    uint256 _tokenId\r\n  )\r\n   internal\r\n  {\r\n    require(idToOwner[_tokenId] == _from);\r\n    assert(ownerToNFTokenCount[_from] > 0);\r\n    ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from].sub(1);\r\n    delete idToOwner[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Assignes a new NFT to owner.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _to Address to wich we want to add the NFT.\r\n   * @param _tokenId Which NFT we want to add.\r\n   */\r\n  function addNFToken(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    require(idToOwner[_tokenId] == address(0));\r\n\r\n    idToOwner[_tokenId] = _to;\r\n    ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-erc721/contracts/tokens/NFTokenMetadata.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\r\n */\r\ncontract NFTokenMetadata is\r\n  NFToken,\r\n  ERC721Metadata\r\n{\r\n\r\n  /**\r\n   * @dev A descriptive name for a collection of NFTs.\r\n   */\r\n  string internal nftName;\r\n\r\n  /**\r\n   * @dev An abbreviated name for NFTokens.\r\n   */\r\n  string internal nftSymbol;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to metadata uri.\r\n   */\r\n  mapping (uint256 => string) internal idToUri;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   * @notice When implementing this contract don't forget to set nftName and nftSymbol.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n  }\r\n\r\n  /**\r\n   * @dev Burns a NFT.\r\n   * @notice This is a internal function which should be called from user-implemented external\r\n   * burn function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _owner Address of the NFT owner.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function _burn(\r\n    address _owner,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    super._burn(_owner, _tokenId);\r\n\r\n    if (bytes(idToUri[_tokenId]).length != 0) {\r\n      delete idToUri[_tokenId];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\r\n   * @notice this is a internal function which should be called from user-implemented external\r\n   * function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _tokenId Id for which we want uri.\r\n   * @param _uri String representing RFC 3986 URI.\r\n   */\r\n  function _setTokenUri(\r\n    uint256 _tokenId,\r\n    string _uri\r\n  )\r\n    validNFToken(_tokenId)\r\n    internal\r\n  {\r\n    idToUri[_tokenId] = _uri;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns a descriptive name for a collection of NFTokens.\r\n   */\r\n  function name()\r\n    external\r\n    view\r\n    returns (string _name)\r\n  {\r\n    _name = nftName;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an abbreviated name for NFTokens.\r\n   */\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string _symbol)\r\n  {\r\n    _symbol = nftSymbol;\r\n  }\r\n\r\n  /**\r\n   * @dev A distinct URI (RFC 3986) for a given NFT.\r\n   * @param _tokenId Id for which we want uri.\r\n   */\r\n  function tokenURI(\r\n    uint256 _tokenId\r\n  )\r\n    validNFToken(_tokenId)\r\n    external\r\n    view\r\n    returns (string)\r\n  {\r\n    return idToUri[_tokenId];\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-erc721/contracts/tokens/NFTokenEnumerable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @dev Optional enumeration implementation for ERC-721 non-fungible token standard.\r\n */\r\ncontract NFTokenEnumerable is\r\n  NFToken,\r\n  ERC721Enumerable\r\n{\r\n\r\n  /**\r\n   * @dev Array of all NFT IDs.\r\n   */\r\n  uint256[] internal tokens;\r\n\r\n  /**\r\n   * @dev Mapping from token ID its index in global tokens array.\r\n   */\r\n  mapping(uint256 => uint256) internal idToIndex;\r\n\r\n  /**\r\n   * @dev Mapping from owner to list of owned NFT IDs.\r\n   */\r\n  mapping(address => uint256[]) internal ownerToIds;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to its index in the owner tokens list.\r\n   */\r\n  mapping(uint256 => uint256) internal idToOwnerIndex;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\r\n  }\r\n\r\n  /**\r\n   * @dev Mints a new NFT.\r\n   * @notice This is a private function which should be called from user-implemented external\r\n   * mint function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _to The address that will own the minted NFT.\r\n   * @param _tokenId of the NFT to be minted by the msg.sender.\r\n   */\r\n  function _mint(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    super._mint(_to, _tokenId);\r\n    tokens.push(_tokenId);\r\n    idToIndex[_tokenId] = tokens.length.sub(1);\r\n  }\r\n\r\n  /**\r\n   * @dev Burns a NFT.\r\n   * @notice This is a private function which should be called from user-implemented external\r\n   * burn function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _owner Address of the NFT owner.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function _burn(\r\n    address _owner,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    super._burn(_owner, _tokenId);\r\n    assert(tokens.length > 0);\r\n\r\n    uint256 tokenIndex = idToIndex[_tokenId];\r\n    // Sanity check. This could be removed in the future.\r\n    assert(tokens[tokenIndex] == _tokenId);\r\n    uint256 lastTokenIndex = tokens.length.sub(1);\r\n    uint256 lastToken = tokens[lastTokenIndex];\r\n\r\n    tokens[tokenIndex] = lastToken;\r\n\r\n    tokens.length--;\r\n    // Consider adding a conditional check for the last token in order to save GAS.\r\n    idToIndex[lastToken] = tokenIndex;\r\n    idToIndex[_tokenId] = 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a NFT from an address.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _from Address from wich we want to remove the NFT.\r\n   * @param _tokenId Which NFT we want to remove.\r\n   */\r\n  function removeNFToken(\r\n    address _from,\r\n    uint256 _tokenId\r\n  )\r\n   internal\r\n  {\r\n    super.removeNFToken(_from, _tokenId);\r\n    assert(ownerToIds[_from].length > 0);\r\n\r\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownerToIds[_from].length.sub(1);\r\n    uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n\r\n    ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n\r\n    ownerToIds[_from].length--;\r\n    // Consider adding a conditional check for the last token in order to save GAS.\r\n    idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n    idToOwnerIndex[_tokenId] = 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Assignes a new NFT to an address.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _to Address to wich we want to add the NFT.\r\n   * @param _tokenId Which NFT we want to add.\r\n   */\r\n  function addNFToken(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    super.addNFToken(_to, _tokenId);\r\n\r\n    uint256 length = ownerToIds[_to].length;\r\n    ownerToIds[_to].push(_tokenId);\r\n    idToOwnerIndex[_tokenId] = length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the count of all existing NFTokens.\r\n   */\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return tokens.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns NFT ID by its index.\r\n   * @param _index A counter less than `totalSupply()`.\r\n   */\r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index < tokens.length);\r\n    // Sanity check. This could be removed in the future.\r\n    assert(idToIndex[tokens[_index]] == _index);\r\n    return tokens[_index];\r\n  }\r\n\r\n  /**\r\n   * @dev returns the n-th NFT ID from a list of owner's tokens.\r\n   * @param _owner Token owner's address.\r\n   * @param _index Index number representing n-th token in owner's list of tokens.\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index < ownerToIds[_owner].length);\r\n    return ownerToIds[_owner][_index];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/MarbleNFTInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Marble NFT Interface\r\n * @dev Defines Marbles unique extension of NFT.\r\n * ...It contains methodes returning core properties what describe Marble NFTs and provides management options to create,\r\n * burn NFT or change approvals of it.\r\n */\r\ninterface MarbleNFTInterface {\r\n\r\n  /**\r\n   * @dev Mints Marble NFT.\r\n   * @notice This is a external function which should be called just by the owner of contract or any other user who has priviladge of being resposible\r\n   * of creating valid Marble NFT. Valid token contains all neccessary information to be able recreate marble card image.\r\n   * @param _tokenId The ID of new NFT.\r\n   * @param _owner Address of the NFT owner.\r\n   * @param _uri Unique URI proccessed by Marble services to be sure it is valid NFTs DNA. Most likely it is URL pointing to some website address.\r\n   * @param _metadataUri URI pointing to \"ERC721 Metadata JSON Schema\"\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function mint(\r\n    uint256 _tokenId,\r\n    address _owner,\r\n    address _creator,\r\n    string _uri,\r\n    string _metadataUri,\r\n    uint256 _created\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Burns Marble NFT. Should be fired only by address with proper authority as contract owner or etc.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function burn(\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Allowes to change approval for change of ownership even when sender is not NFT holder. Sender has to have special role granted by contract to use this tool.\r\n   * @notice Careful with this!!!! :))\r\n   * @param _tokenId ID of the NFT to be updated.\r\n   * @param _approved ETH address what supposed to gain approval to take ownership of NFT.\r\n   */\r\n  function forceApproval(\r\n    uint256 _tokenId,\r\n    address _approved\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns properties used for generating NFT metadata image (a.k.a. card).\r\n   * @param _tokenId ID of the NFT.\r\n   */\r\n  function tokenSource(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (\r\n      string uri,\r\n      address creator,\r\n      uint256 created\r\n    );\r\n\r\n  /**\r\n   * @dev Returns ID of NFT what matches provided source URI.\r\n   * @param _uri URI of source website.\r\n   */\r\n  function tokenBySourceUri(string _uri)\r\n    external\r\n    view\r\n    returns (uint256 tokenId);\r\n\r\n  /**\r\n   * @dev Returns all properties of Marble NFT. Lets call it Marble NFT Model with properties described below:\r\n   * @param _tokenId ID  of NFT\r\n   * Returned model:\r\n   * uint256 id ID of NFT\r\n   * string uri  URI of source website. Website is used to mine data to crate NFT metadata image.\r\n   * string metadataUri URI to NFT metadata assets. In our case to our websevice providing JSON with additional information based on \"ERC721 Metadata JSON Schema\".\r\n   * address owner NFT owner address.\r\n   * address creator Address of creator of this NFT. It means that this addres placed sourceURI to candidate contract.\r\n   * uint256 created Date and time of creation of NFT candidate.\r\n   *\r\n   * (id, uri, metadataUri, owner, creator, created)\r\n   */\r\n  function getNFT(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns(\r\n      uint256 id,\r\n      string uri,\r\n      string metadataUri,\r\n      address owner,\r\n      address creator,\r\n      uint256 created\r\n    );\r\n\r\n\r\n    /**\r\n     * @dev Transforms URI to hash.\r\n     * @param _uri URI to be transformed to hash.\r\n     */\r\n    function getSourceUriHash(string _uri)\r\n      external\r\n      view\r\n      returns(uint256 hash);\r\n}\r\n\r\n// File: contracts/MarbleNFT.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title MARBLE NFT CONTRACT\r\n * @notice We omit a fallback function to prevent accidental sends to this contract.\r\n */\r\ncontract MarbleNFT is\r\n  Adminable,\r\n  NFTokenMetadata,\r\n  NFTokenEnumerable,\r\n  MarbleNFTInterface\r\n{\r\n\r\n  /*\r\n   * @dev structure storing additional information about created NFT\r\n   * uri: URI used as source/key/representation of NFT, it can be considered as tokens DNA\r\n   * creator:  address of candidate creator - a.k.a. address of person who initialy provided source URI\r\n   * created: date of NFT creation\r\n   */\r\n  struct MarbleNFTSource {\r\n\r\n    // URI used as source/key of NFT, we can consider it as tokens DNA\r\n    string uri;\r\n\r\n    // address of candidate creator - a.k.a. address of person who initialy provided source URI\r\n    address creator;\r\n\r\n    // date of NFT creation\r\n    uint256 created;\r\n  }\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to marble NFT source.\r\n   */\r\n  mapping (uint256 => MarbleNFTSource) public idToMarbleNFTSource;\r\n  /**\r\n   * @dev Mapping from marble NFT source uri hash TO NFT ID .\r\n   */\r\n  mapping (uint256 => uint256) public sourceUriHashToId;\r\n\r\n  constructor()\r\n    public\r\n  {\r\n    nftName = \"MARBLE-NFT\";\r\n    nftSymbol = \"MRBLNFT\";\r\n  }\r\n\r\n  /**\r\n   * @dev Mints a new NFT.\r\n   * @param _tokenId The unique number representing NFT\r\n   * @param _owner Holder of Marble NFT\r\n   * @param _creator Creator of Marble NFT\r\n   * @param _uri URI representing NFT\r\n   * @param _metadataUri URI pointing to \"ERC721 Metadata JSON Schema\"\r\n   * @param _created date of creation of NFT candidate\r\n   */\r\n  function mint(\r\n    uint256 _tokenId,\r\n    address _owner,\r\n    address _creator,\r\n    string _uri,\r\n    string _metadataUri,\r\n    uint256 _created\r\n  )\r\n    external\r\n    onlyAdmin\r\n  {\r\n    uint256 uriHash = _getSourceUriHash(_uri);\r\n\r\n    require(uriHash != _getSourceUriHash(\"\"), \"NFT URI can not be empty!\");\r\n    require(sourceUriHashToId[uriHash] == 0, \"NFT with same URI already exists!\");\r\n\r\n    _mint(_owner, _tokenId);\r\n    _setTokenUri(_tokenId, _metadataUri);\r\n\r\n    idToMarbleNFTSource[_tokenId] = MarbleNFTSource(_uri, _creator, _created);\r\n    sourceUriHashToId[uriHash] = _tokenId;\r\n  }\r\n\r\n  /**\r\n   * @dev Burns NFT. Sadly, trully.. ...probably someone marbled something ugly!!!! :)\r\n   * @param _tokenId ID of ugly NFT\r\n   */\r\n  function burn(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    onlyAdmin\r\n  {\r\n    address owner = idToOwner[_tokenId];\r\n\r\n    MarbleNFTSource memory marbleNFTSource = idToMarbleNFTSource[_tokenId];\r\n\r\n    if (bytes(marbleNFTSource.uri).length != 0) {\r\n      uint256 uriHash = _getSourceUriHash(marbleNFTSource.uri);\r\n      delete sourceUriHashToId[uriHash];\r\n      delete idToMarbleNFTSource[_tokenId];\r\n    }\r\n\r\n    _burn(owner, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Tool to manage misstreated NFTs or to be able to extend our services for new cool stuff like auctions, weird games and so on......\r\n   * @param _tokenId ID of the NFT to be update.\r\n   * @param _approved Address to replace current approved address on NFT\r\n   */\r\n  function forceApproval(\r\n    uint256 _tokenId,\r\n    address _approved\r\n  )\r\n    external\r\n    onlyAdmin\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(_approved != tokenOwner,\"Owner can not be become new owner!\");\r\n\r\n    idToApprovals[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns model of Marble NFT source properties\r\n   * @param _tokenId ID of the NFT\r\n   */\r\n  function tokenSource(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (\r\n      string uri,\r\n      address creator,\r\n      uint256 created)\r\n  {\r\n    MarbleNFTSource memory marbleNFTSource = idToMarbleNFTSource[_tokenId];\r\n    return (marbleNFTSource.uri, marbleNFTSource.creator, marbleNFTSource.created);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns token ID related to provided source uri\r\n   * @param _uri URI representing created NFT\r\n   */\r\n  function tokenBySourceUri(string _uri)\r\n    external\r\n    view\r\n    returns (uint256 tokenId)\r\n  {\r\n    return sourceUriHashToId[_getSourceUriHash(_uri)];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whole Marble NFT model\r\n   * --------------------\r\n   *   MARBLE NFT MODEL\r\n   * --------------------\r\n   * uint256 id NFT unique identification\r\n   * string uri NFT source URI, source is whole site what was proccessed by marble to create this NFT, it is URI representation of NFT (call it DNA)\r\n   * string metadataUri  URI pointint to token NFT metadata shcema\r\n   * address owner Current NFT owner\r\n   * address creator First NFT owner\r\n   * uint256 created Date of NFT candidate creation\r\n   *\r\n   * (id, uri, metadataUri, owner, creator, created)\r\n   */\r\n  function getNFT(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns(\r\n      uint256 id,\r\n      string uri,\r\n      string metadataUri,\r\n      address owner,\r\n      address creator,\r\n      uint256 created\r\n    )\r\n  {\r\n\r\n    MarbleNFTSource memory marbleNFTSource = idToMarbleNFTSource[_tokenId];\r\n\r\n    return (\r\n      _tokenId,\r\n      marbleNFTSource.uri,\r\n      idToUri[_tokenId],\r\n      idToOwner[_tokenId],\r\n      marbleNFTSource.creator,\r\n      marbleNFTSource.created);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Transforms URI to hash.\r\n   * @param _uri URI to be transformed to hash.\r\n   */\r\n  function getSourceUriHash(string _uri)\r\n     external\r\n     view\r\n     returns(uint256 hash)\r\n  {\r\n     return _getSourceUriHash(_uri);\r\n  }\r\n\r\n  /**\r\n   * @dev Transforms URI to hash.\r\n   * @param _uri URI to be transformed to hash.\r\n   */\r\n  function _getSourceUriHash(string _uri)\r\n    internal\r\n    pure\r\n    returns(uint256 hash)\r\n  {\r\n    return uint256(keccak256(abi.encodePacked(_uri)));\r\n  }\r\n}\r\n\r\n// File: contracts/MarbleNFTFactory.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Marble NFT Factory\r\n * @dev Covers all parts of creating new NFT token. Contains references to all involved contracts and giving possibility of burning NFT corretly.\r\n */\r\ncontract MarbleNFTFactory is\r\n  Adminable,\r\n  Pausable,\r\n  SupportsInterface\r\n{\r\n\r\n  using SafeMath for uint256;\r\n\r\n  MarbleNFT public marbleNFTContract;\r\n  MarbleNFTCandidateInterface public marbleNFTCandidateContract;\r\n  MarbleDutchAuctionInterface public marbleDutchAuctionContract;\r\n\r\n  /**\r\n   * @dev property holding last created NFT ID\r\n   * - it's  separeted from Marble NFT contract in case that we will want to change NFT id strategy in the future. Currently no idea why we would do it! :)\r\n   */\r\n  uint256 public lastMintedNFTId;\r\n\r\n  constructor(uint256 _lastMintedNFTId)\r\n    public\r\n  {\r\n    lastMintedNFTId = _lastMintedNFTId;\r\n  }\r\n\r\n  /**\r\n   * @dev Emits when new marble when is minted\r\n   */\r\n  event MarbleNFTCreated(\r\n    address indexed _creator,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev Emits when new marble is minted\r\n   */\r\n  event MarbleNFTBurned(\r\n    uint256 indexed _tokenId,\r\n    address indexed _owner,\r\n    address indexed _creator\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev Creates Marble NFT from Candidate and returns NFTs owner. Was created, bc of deep stack error over mint function.\r\n   * @param _id ID of Marble NFT\r\n   * @param _uri URI determining Marble NFT, lets say this is our DNA...\r\n   * @param _metadataUri URI pointing to \"ERC721 Metadata JSON Schema\"\r\n   * @param _candidateUri URI initially provided to user for purposes of creation Marble NFT\r\n   */\r\n  function _mint(\r\n    uint256 _id,\r\n    string _uri,\r\n    string _metadataUri,\r\n    string _candidateUri\r\n  )\r\n    internal\r\n    returns (address owner)\r\n  {\r\n    require(marbleNFTCandidateContract.isCandidate(_candidateUri), \"There is no candidate with this URL!!\");\r\n    uint256 created;\r\n\r\n    (, owner, , , created) = marbleNFTCandidateContract.getCandidate(_candidateUri);\r\n\r\n    marbleNFTContract.mint(\r\n      _id,\r\n      owner,\r\n      owner,\r\n      _uri,\r\n      _metadataUri,\r\n      now\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Sets new last minted ID, !! use careful\r\n   * @param _lastMintedNFTId New value of last mineted NFT\r\n   */\r\n  function setLastMintedNFTId(uint256 _lastMintedNFTId)\r\n     external\r\n     onlyOwner\r\n     whenPaused\r\n  {\r\n      lastMintedNFTId = _lastMintedNFTId;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets auction contract\r\n   * @param _address Contract address\r\n   */\r\n  function setMarbleDutchAuctionContract(address _address)\r\n     external\r\n     onlyAdmin\r\n     whenNotPaused\r\n  {\r\n      marbleDutchAuctionContract = MarbleDutchAuctionInterface(_address);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets Marble NFT contract\r\n   * @param _address Contract address\r\n   */\r\n  function setNFTContract(address _address)\r\n     external\r\n     onlyAdmin\r\n     whenNotPaused\r\n  {\r\n      marbleNFTContract = MarbleNFT(_address);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets Candidate contract\r\n   * @param _address Contract address\r\n   */\r\n  function setCandidateContract(address _address)\r\n    external\r\n    onlyAdmin\r\n    whenNotPaused\r\n  {\r\n     marbleNFTCandidateContract = MarbleNFTCandidateInterface(_address);\r\n  }\r\n\r\n  /**\r\n   * @dev Creates Marble NFT. Then place it over auction in special fashion and remove candidate entry.\r\n   * NOTE: we are not removing candidates, should we or should we not??\r\n   * @param _uri URI determining Marble NFT, lets say this is our DNA...\r\n   * @param _metadataUri URI pointing to \"ERC721 Metadata JSON Schema\"\r\n   * @param _candidateUri URI initially provided to user for purposes of creation Marble NFT\r\n   * @param _auctionStartingPrice Starting price of auction.\r\n   * @param _auctionMinimalPrice Ending price of auction.\r\n   * @param _auctionDuration Duration (in seconds) of auction when price is moving, lets say, it determines dynamic part of auction price creation.\r\n   */\r\n  function mint(\r\n    string _uri,\r\n    string _metadataUri,\r\n    string _candidateUri,\r\n    uint256 _auctionStartingPrice,\r\n    uint256 _auctionMinimalPrice,\r\n    uint256 _auctionDuration\r\n  )\r\n    external\r\n    onlyAdmin\r\n    whenNotPaused\r\n  {\r\n    uint256 id = lastMintedNFTId.add(1);\r\n\r\n    address owner = _mint(\r\n      id,\r\n      _uri,\r\n      _metadataUri,\r\n      _candidateUri\r\n    );\r\n\r\n    marbleDutchAuctionContract.createMintingAuction(\r\n      id,\r\n      _auctionStartingPrice,\r\n      _auctionMinimalPrice,\r\n      _auctionDuration,\r\n      owner\r\n    );\r\n\r\n    lastMintedNFTId = id;\r\n\r\n    emit MarbleNFTCreated(owner, id);\r\n  }\r\n\r\n  /**\r\n   * @dev Creates Marble NFT. Then place it over auction in special fashion and remove candidate entry......hmm removing of candidate is not important and we can remove it from the minting process.\r\n   * NOTE: !! rather careful with this stuff, it burns\r\n   * @param _tokenId Id of Marble NFT to burn\r\n   */\r\n  function burn(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    onlyAdmin\r\n    whenNotPaused\r\n  {\r\n\r\n    require(marbleNFTContract.ownerOf(_tokenId) != address(0) , \"Marble NFT doesnt not exists!\");\r\n    address owner;\r\n    address creator;\r\n\r\n    // get some info about NFT to tell the world whos NFT we are burning!!\r\n    (, , , owner, creator, ) = marbleNFTContract.getNFT(_tokenId);\r\n\r\n    Pausable auctionContractToBePaused = Pausable(address(marbleDutchAuctionContract));\r\n\r\n    // If NFT is on our auction contract, we have to remove it first\r\n    if (marbleDutchAuctionContract.isOnAuction(_tokenId)) {\r\n      require(auctionContractToBePaused.paused(), \"Auction contract has to be paused!\");\r\n      marbleDutchAuctionContract.removeAuction(_tokenId);\r\n    }\r\n\r\n    // burn NFT\r\n    marbleNFTContract.burn(_tokenId);\r\n\r\n    // Let's everyone to know that we burn things....! :)\r\n    emit MarbleNFTBurned(_tokenId, owner, creator);\r\n  }\r\n}"
    }
  }
}