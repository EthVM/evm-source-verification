{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Scanner.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-09-18\n*/\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function owner() external view returns (address);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface ISushiSwapPoolNames {\n    function logos(uint256) external view returns(string memory);\n    function names(uint256) external view returns(string memory);\n    function setPoolInfo(uint256 pid, string memory logo, string memory name) external;\n}\n\ninterface ISushiToken is IERC20{\n    function delegates(address who) external view returns(address);\n    function getCurrentVotes(address who) external view returns(uint256);\n    function nonces(address who) external view returns(uint256);\n}\n\ninterface IMasterChef {\n    function BONUS_MULTIPLIER() external view returns (uint256);\n    function bonusEndBlock() external view returns (uint256);\n    function devaddr() external view returns (address);\n    function migrator() external view returns (address);\n    function owner() external view returns (address);\n    function startBlock() external view returns (uint256);\n    function sushi() external view returns (address);\n    function sushiPerBlock() external view returns (uint256);\n    function totalAllocPoint() external view returns (uint256);\n\n    function poolLength() external view returns (uint256);\n    function poolInfo(uint256 nr) external view returns (address, uint256, uint256, uint256);\n    function userInfo(uint256 nr, address who) external view returns (uint256, uint256);\n    function pendingSushi(uint256 nr, address who) external view returns (uint256);\n}\n\ninterface IFactory {\n    function allPairsLength() external view returns (uint256);\n    function allPairs(uint256 i) external view returns (address);\n    function getPair(address token0, address token1) external view returns (address);\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n}\n\ninterface IPair is IERC20 {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112, uint112, uint32);\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a); return c; }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); uint256 c = a - b; return c; }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b > 0); uint256 c = a / b; return c; }\n}\n\ncontract Ownable {\n    address public owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        address msgSender = msg.sender;\n        owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n\ncontract BoringCryptoTokenScanner\n{\n    using SafeMath for uint256;\n\n    struct Balance {\n        address token;\n        uint256 balance;\n    }\n    \n    struct BalanceFull {\n        address token;\n        uint256 balance;\n        uint256 rate;\n    }\n    \n    struct TokenInfo {\n        address token;\n        uint256 decimals;\n        string name;\n        string symbol;\n    }\n\n    function getTokenInfo(address[] calldata addresses) public view returns(TokenInfo[] memory) {\n        TokenInfo[] memory infos = new TokenInfo[](addresses.length);\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IERC20 token = IERC20(addresses[i]);\n            infos[i].token = address(token);\n            \n            infos[i].name = token.name();\n            infos[i].symbol = token.symbol();\n            infos[i].decimals = token.decimals();\n        }\n\n        return infos;\n    }\n\n    function findBalances(address who, address[] calldata addresses) public view returns(Balance[] memory) {\n        uint256 balanceCount;\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (IERC20(addresses[i]).balanceOf(who) > 0) {\n                balanceCount++;\n            }\n        }\n\n        Balance[] memory balances = new Balance[](balanceCount);\n\n        balanceCount = 0;\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IERC20 token = IERC20(addresses[i]);\n            uint256 balance = token.balanceOf(who);\n            if (balance > 0) {\n                balances[balanceCount].token = address(token);\n                balances[balanceCount].balance = token.balanceOf(who);\n                balanceCount++;\n            }\n        }\n\n        return balances;\n    }\n    \n    function getBalances(address who, address[] calldata addresses, IFactory factory, address currency) public view returns(BalanceFull[] memory) {\n        BalanceFull[] memory balances = new BalanceFull[](addresses.length);\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IERC20 token = IERC20(addresses[i]);\n            balances[i].token = address(token);\n            balances[i].balance = token.balanceOf(who);\n\n            IPair pair = IPair(factory.getPair(addresses[i], currency));\n            if(address(pair) != address(0))\n            {\n                uint256 reserveCurrency;\n                uint256 reserveToken;\n                if (pair.token0() == currency) {\n                    (reserveCurrency, reserveToken,) = pair.getReserves();\n                }\n                else\n                {\n                    (reserveToken, reserveCurrency,) = pair.getReserves();\n                }\n                balances[i].rate = reserveToken * 1e18 / reserveCurrency;\n            }\n        }\n\n        return balances;\n    }\n\n    struct Factory {\n        IFactory factory;\n        uint256 allPairsLength;\n        address feeTo;\n        address feeToSetter;\n    }\n    \n    function getFactoryInfo(IFactory[] calldata addresses) public view returns(Factory[] memory) {\n        Factory[] memory factories = new Factory[](addresses.length);\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IFactory factory = addresses[i];\n            factories[i].factory = factory;\n            \n            factories[i].allPairsLength = factory.allPairsLength();\n            factories[i].feeTo = factory.feeTo();\n            factories[i].feeToSetter = factory.feeToSetter();\n        }\n\n        return factories;\n    }\n\n    struct Pair {\n        address token;\n        address token0;\n        address token1;\n    }\n    \n    function getPairs(IFactory factory, uint256 fromID, uint256 toID) public view returns(Pair[] memory) {\n        if (toID == 0){\n            toID = factory.allPairsLength();\n        }\n        \n        Pair[] memory pairs = new Pair[](toID - fromID);\n\n        for(uint256 id = fromID; id < toID; id++) {\n            address token = factory.allPairs(id);\n            uint256 i = id - fromID;\n            pairs[i].token = token;\n            pairs[i].token0 = IPair(token).token0();\n            pairs[i].token1 = IPair(token).token1();\n        }\n        return pairs;\n    }\n\n    function findPairs(address who, IFactory factory, uint256 fromID, uint256 toID) public view returns(Pair[] memory) {\n        if (toID == 0){\n            toID = factory.allPairsLength();\n        }\n        \n        uint256 pairCount;\n\n        for(uint256 id = fromID; id < toID; id++) {\n            address token = factory.allPairs(id);\n            if (IERC20(token).balanceOf(who) > 0) {\n                pairCount++;\n            }\n        }\n\n        Pair[] memory pairs = new Pair[](pairCount);\n\n        pairCount = 0;\n        for(uint256 id = fromID; id < toID; id++) {\n            address token = factory.allPairs(id);\n            uint256 balance = IERC20(token).balanceOf(who);\n            if (balance > 0) {\n                pairs[pairCount].token = token;\n                pairs[pairCount].token0 = IPair(token).token0();\n                pairs[pairCount].token1 = IPair(token).token1();\n                pairCount++;\n            }\n        }\n\n        return pairs;\n    }\n\n    struct PairFull {\n        address token;\n        address token0;\n        address token1;\n        uint256 reserve0;\n        uint256 reserve1;\n        uint256 totalSupply;\n        uint256 balance;\n    }\n\n    function getPairsFull(address who, address[] calldata addresses) public view returns(PairFull[] memory) {\n        PairFull[] memory pairs = new PairFull[](addresses.length);\n        for (uint256 i = 0; i < addresses.length; i++) {\n            address token = addresses[i];\n            pairs[i].token = token;\n            pairs[i].token0 = IPair(token).token0();\n            pairs[i].token1 = IPair(token).token1();\n            (uint256 reserve0, uint256 reserve1,) = IPair(token).getReserves();\n            pairs[i].reserve0 = reserve0;\n            pairs[i].reserve1 = reserve1;\n            pairs[i].balance = IERC20(token).balanceOf(who);\n        }\n        return pairs;\n    }\n}"
    }
  }
}