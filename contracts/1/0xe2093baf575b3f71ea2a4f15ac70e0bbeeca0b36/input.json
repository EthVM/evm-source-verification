{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ValidatorProxy1.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorValidatorInterface {\n  function validate(\n    uint256 previousRoundId,\n    int256 previousAnswer,\n    uint256 currentRoundId,\n    int256 currentAnswer\n  )\n    external\n    returns (\n      bool\n    );\n}\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner {\n\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(\n    address indexed from,\n    address indexed to\n  );\n  event OwnershipTransferred(\n    address indexed from,\n    address indexed to\n  );\n\n  constructor(address newOwner) {\n    s_owner = newOwner;\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(\n    address to\n  )\n    external\n    onlyOwner()\n  {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership()\n    external\n  {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner()\n    public\n    view\n    returns (\n      address\n    )\n  {\n    return s_owner;\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n    _;\n  }\n\n}\n\ncontract ValidatorProxy is AggregatorValidatorInterface, ConfirmedOwner {\n\n  /// @notice Uses a single storage slot to store the current address\n  struct ProxyConfiguration {\n    address target;\n    bool hasNewProposal;\n  }\n\n  // Configuration for the current aggregator\n  ProxyConfiguration private s_currentAggregator;\n  // Proposed aggregator address\n  address private s_proposedAggregator;\n\n  // Configuration for the current validator\n  ProxyConfiguration private s_currentValidator;\n  // Proposed validator address\n  address private s_proposedValidator;\n\n  event AggregatorProposed(\n    address indexed aggregator\n  );\n  event AggregatorUpgraded(\n    address indexed previous,\n    address indexed current\n  );\n  event ValidatorProposed(\n    address indexed validator\n  );\n  event ValidatorUpgraded(\n    address indexed previous,\n    address indexed current\n  );\n  /// @notice The proposed aggregator called validate, but the call was not passed on to any validators\n  event ProposedAggregatorValidateCall(\n    address indexed proposed,\n    uint256 previousRoundId,\n    int256 previousAnswer,\n    uint256 currentRoundId,\n    int256 currentAnswer\n  );\n\n  /**\n   * @notice Construct the ValidatorProxy with an aggregator and a validator\n   * @param aggregator address\n   * @param validator address\n   */\n  constructor(\n    address aggregator,\n    address validator\n  )\n    ConfirmedOwner(msg.sender)\n  {\n    s_currentAggregator.target = aggregator;\n    s_currentValidator.target = validator;\n  }\n\n  /**\n   * @notice Validate a transmission\n   * @dev Must be called by either the `s_currentAggregator.target`, or the `s_proposedAggregator`.\n   * If called by the `s_currentAggregator.target` this function passes the call on to the `s_currentValidator.target`\n   * and the `s_proposedValidator`, if it is set.\n   * If called by the `s_proposedAggregator` this function emits a `ProposedAggregatorValidateCall` to signal that\n   * the call was received.\n   * @param previousRoundId uint256\n   * @param previousAnswer int256\n   * @param currentRoundId uint256\n   * @param currentAnswer int256\n   * @return bool\n   */\n  function validate(\n    uint256 previousRoundId,\n    int256 previousAnswer,\n    uint256 currentRoundId,\n    int256 currentAnswer\n  )\n    external\n    override\n    returns (\n      bool\n    )\n  {\n    address currentAggregator = s_currentAggregator.target;\n    address proposedAggregator = s_proposedAggregator;\n    require(msg.sender == currentAggregator || msg.sender == proposedAggregator, \"Not a configured aggregator\");\n    // If the aggregator is still in proposed state, emit an event and don't push to any validator.\n    // This is to confirm that `validate` is being called prior to upgrade.\n    if (msg.sender == proposedAggregator) {\n      emit ProposedAggregatorValidateCall(\n        proposedAggregator,\n        previousRoundId,\n        previousAnswer,\n        currentRoundId,\n        currentAnswer\n      );\n      return true;\n    }\n\n    // Send the validate call to the current validator\n    ProxyConfiguration memory currentValidator = s_currentValidator;\n    require(s_currentValidator.target != address(0), \"No validator set\");\n    AggregatorValidatorInterface(currentValidator.target).validate(\n      previousRoundId,\n      previousAnswer,\n      currentRoundId,\n      currentAnswer\n    );\n    // If there is a new proposed validator, send the validate call to that validator also\n    if (currentValidator.hasNewProposal) {\n      AggregatorValidatorInterface(s_proposedValidator).validate(\n        previousRoundId,\n        previousAnswer,\n        currentRoundId,\n        currentAnswer\n      );\n    }\n    return true;\n  }\n\n  /** AGGREGATOR CONFIGURATION FUNCTIONS **/\n\n  /**\n   * @notice Propose an aggregator\n   * @dev A zero address can be used to unset the proposed aggregator. Only owner can call.\n   * @param proposed address\n   */\n  function proposeNewAggregator(\n    address proposed\n  )\n    external\n    onlyOwner()\n  {\n    s_proposedAggregator = proposed;\n    // If proposed is zero address, hasNewProposal = false\n    s_currentAggregator.hasNewProposal = (proposed != address(0));\n    emit AggregatorProposed(proposed);\n  }\n\n  /**\n   * @notice Upgrade the aggregator by setting the current aggregator as the proposed aggregator.\n   * @dev Must have a proposed aggregator. Only owner can call.\n   */\n  function upgradeAggregator()\n    external\n    onlyOwner()\n  {\n    // Get configuration in memory\n    ProxyConfiguration memory current = s_currentAggregator;\n    address previous = current.target;\n    address proposed = s_proposedAggregator;\n\n    // Perform the upgrade\n    require(current.hasNewProposal == true, \"No proposal\");\n    current.target = proposed;\n    current.hasNewProposal = false;\n\n    s_currentAggregator = current;\n    s_proposedAggregator = address(0);\n\n    emit AggregatorUpgraded(previous, proposed);\n  }\n\n  /**\n   * @notice Get aggregator details\n   * @return current address\n   * @return hasProposal bool\n   * @return proposed address\n   */\n  function getAggregators()\n    external\n    view\n    returns(\n      address current,\n      bool hasProposal,\n      address proposed\n    )\n  {\n    current = s_currentAggregator.target;\n    hasProposal = s_currentAggregator.hasNewProposal;\n    proposed = s_proposedAggregator;\n  }\n\n  /** VALIDATOR CONFIGURATION FUNCTIONS **/\n\n  /**\n   * @notice Propose an validator\n   * @dev A zero address can be used to unset the proposed validator. Only owner can call.\n   * @param proposed address\n   */\n  function proposeNewValidator(\n    address proposed\n  )\n    external\n    onlyOwner()\n  {\n    s_proposedValidator = proposed;\n    // If proposed is zero address, hasNewProposal = false\n    s_currentValidator.hasNewProposal = (proposed != address(0));\n    emit ValidatorProposed(proposed);\n  }\n\n  /**\n   * @notice Upgrade the validator by setting the current validator as the proposed validator.\n   * @dev Must have a proposed validator. Only owner can call.\n   */\n  function upgradeValidator()\n    external\n    onlyOwner()\n  {\n    // Get configuration in memory\n    ProxyConfiguration memory current = s_currentValidator;\n    address previous = current.target;\n    address proposed = s_proposedValidator;\n\n    // Perform the upgrade\n    require(current.hasNewProposal == true, \"No proposal\");\n    current.target = proposed;\n    current.hasNewProposal = false;\n\n    s_currentValidator = current;\n    s_proposedValidator = address(0);\n\n    emit ValidatorUpgraded(previous, proposed);\n  }\n\n  /**\n   * @notice Get validator details\n   * @return current address\n   * @return hasProposal bool\n   * @return proposed address\n   */\n  function getValidators()\n    external\n    view\n    returns(\n      address current,\n      bool hasProposal,\n      address proposed\n    )\n  {\n    current = s_currentValidator.target;\n    hasProposal = s_currentValidator.hasNewProposal;\n    proposed = s_proposedValidator;\n  }\n\n}"}}}