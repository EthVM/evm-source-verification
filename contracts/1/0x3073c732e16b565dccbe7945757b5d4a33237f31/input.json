{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/HEX.sol":{"content":"\npragma solidity ^0.6.4;\n\ninterface HEX {\n   /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);//from address(0) for minting\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n   function stakeStart(uint256 newStakedHearts, uint256 newStakedDays) external;\n   function stakeEnd(uint256 stakeIndex, uint40 stakeIdParam) external;\n   function stakeCount(address stakerAddr) external view returns (uint256);\n   function stakeLists(address owner, uint256 stakeIndex) external view returns (uint40, uint72, uint72, uint16, uint16, uint16, bool);\n   function currentDay() external view returns (uint256);\n   function dailyDataRange(uint256 beginDay, uint256 endDay) external view returns (uint256[] memory);\n   function globalInfo() external view returns (uint256[13] memory);\n\n}"},"browser/HEXLOCK.sol":{"content":"//HEXLOCK.sol\r\n//\r\n//\r\n\r\npragma solidity ^0.6.4;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./HEX.sol\";\r\n\r\n////////////////////////////////////////////////\r\n////////////////////EVENTS/////////////////////\r\n//////////////////////////////////////////////\r\ncontract Events {\r\n\r\n//when a user starts staking\r\n    event StakeStarted(\r\n        uint heartValue,\r\n        uint indexed dayLength,\r\n        uint hexStakeId\r\n    );\r\n\r\n//when a user ends stake\r\n    event StakeEnded(\r\n        uint heartValue,\r\n        uint stakeProfit,\r\n        uint indexed dayLength,\r\n        uint hexStakeId\r\n    );\r\n\r\n}\r\n\r\ncontract TokenEvents {\r\n\r\n//when a user locks tokens\r\n    event TokenLock(\r\n        address indexed user,\r\n        uint value\r\n    );\r\n\r\n//when a user unlocks tokens\r\n    event TokenUnlock(\r\n        address indexed user,\r\n        uint value\r\n    );\r\n}\r\n\r\n//////////////////////////////////////\r\n//////////LOCK TOKEN CONTRACT////////\r\n////////////////////////////////////\r\ncontract LOCK is IERC20, TokenEvents{\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    \r\n    uint256 internal _totalSupply;\r\n    string public constant name = \"HEXLOCK\";\r\n    string public constant symbol = \"LOCK\";\r\n    uint public constant decimals = 8;\r\n\r\n    //LOCKING\r\n    uint public totalLocked;\r\n    mapping (address => uint) public tokenLockedBalances;//balance of LOCK locked mapped by user\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() override public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) override public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) override public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) override public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) override public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) override public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n          _totalSupply = _totalSupply.add(amount);\r\n          _balances[account] = _balances[account].add(amount);\r\n          emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);//from address(0) for minting\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    //mint LOCK to msg.sender\r\n    function mintLock(uint hearts)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint amt = hearts.div(1000);\r\n        address minter = msg.sender;\r\n        _mint(minter, amt);//mint LOCK\r\n        return true;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    /////////////////PUBLIC FACING - LOCK CONTROL//////////\r\n    //////////////////////////////////////////////////////\r\n\r\n    //lock LOCK tokens to contract\r\n    function LockTokens(uint amt)\r\n        public\r\n    {\r\n        require(amt > 0, \"zero input\");\r\n        require(tokenBalance() >= amt, \"Error: insufficient balance\");//ensure user has enough funds\r\n        tokenLockedBalances[msg.sender] = tokenLockedBalances[msg.sender].add(amt);\r\n        totalLocked = totalLocked.add(amt);\r\n        _transfer(msg.sender, address(this), amt);//make transfer\r\n        emit TokenLock(msg.sender, amt);\r\n    }\r\n\r\n    //unlock LOCK tokens from contract\r\n    function UnlockTokens(uint amt)\r\n        public\r\n    {\r\n        require(amt > 0, \"zero input\");\r\n        require(tokenLockedBalances[msg.sender] >= amt,\"Error: unsufficient frozen balance\");//ensure user has enough locked funds\r\n        tokenLockedBalances[msg.sender] = tokenLockedBalances[msg.sender].sub(amt);//update balances\r\n        totalLocked = totalLocked.sub(amt);\r\n        _transfer(address(this), msg.sender, amt);//make transfer\r\n        emit TokenUnlock(msg.sender, amt);\r\n    }\r\n\r\n    ///////////////////////////////\r\n    ////////VIEW ONLY//////////////\r\n    ///////////////////////////////\r\n\r\n    //total LOCK frozen in contract\r\n    function totalLockedTokenBalance()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalLocked;\r\n    }\r\n\r\n    //LOCK balance of caller\r\n    function tokenBalance()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balanceOf(msg.sender);\r\n    }\r\n}\r\n\r\ncontract HEXLOCK is LOCK, Events {\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////CONTRACT SETUP///////////////////////\r\n    ////////////////////////////////////////////////////////////////////\r\n    using SafeMath for uint256;\r\n\r\n    HEX hexInterface;\r\n\r\n    //HEXLOCK\r\n    address payable constant hexAddress = 0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39;\r\n\r\n    address payable devAddress;//set in constructor\r\n    address payable devAddress2 = 0xD30BC4859A79852157211E6db19dE159673a67E2;\r\n    uint constant fee = 1000; //0.1%;\r\n    uint constant devFee = 2; // 50% of 0.1% @ 0.05%;\r\n    uint constant refFee = 2; // 50% of 0.1% @ 0.05%\r\n    \r\n    uint public last_stake_id;// stake id\r\n    uint public userCount; \r\n    uint public lifetimeHeartsStaked;\r\n    \r\n    mapping (address => UserInfo) public users;\r\n    mapping (uint => StakeInfo) public stakes;\r\n    mapping (address => uint[]) internal userStakeIds;\r\n\r\n    bool locked;\r\n\r\n    struct UserInfo {\r\n        uint     totalHeartsStaked;\r\n        address  userAddress;\r\n    }\r\n\r\n    struct StakeInfo {\r\n        uint     heartValue;\r\n        uint     dayLength;\r\n        address payable userAddress;\r\n        address payable refferer;\r\n        uint     stakeId;\r\n        uint     hexStakeIndex;\r\n        uint40   hexStakeId;\r\n        bool     isStaking;\r\n        uint256  stakeStartTimestamp;\r\n        uint     stakeValue;\r\n        uint     stakeProfit;\r\n        bool     stakeEnded;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == devAddress, \"notOwner\");\r\n        _;\r\n    }\r\n\r\n    modifier canStake(uint hearts) {\r\n        require(hearts > 0, \"Error: value must be greater than 0\");\r\n        _;\r\n    }\r\n\r\n    modifier synchronized {\r\n        require(!locked, \"Sync lock\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    constructor() public {\r\n        devAddress = msg.sender;\r\n        hexInterface = HEX(hexAddress);\r\n        mintLock(100000000000000000);\r\n    }\r\n\r\n    receive() external payable {\r\n        devAddress.transfer(msg.value);//assume any eth sent to contract as donation.\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////HEXLOCK CORE//////////////////////////\r\n    ////////////////////////////////////////////////////////////////////\r\n\r\n    //stakes hex - transfers HEX from user to contract - approval needed\r\n    function stakeHex(uint hearts, uint dayLength, address payable ref)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        //send\r\n        require(hexInterface.transferFrom(msg.sender, address(this), hearts), \"Transfer failed\");//send hex from user to contract\r\n        //user info\r\n        updateUserData(hearts);\r\n        //stake HEX\r\n        hexInterface.stakeStart(hearts, dayLength);\r\n        //get the most recent stakeIndex\r\n        uint hexStakeIndex = hexInterface.stakeCount(address(this)).sub(1);\r\n        //update stake info\r\n        updateStakeData(hearts, dayLength, ref, hexStakeIndex);\r\n        //mint bonus LOCK tokens relative to HEX amount and stake length (stake for more than 20 days and get larger bonus)\r\n        if(dayLength < 10){\r\n            dayLength = 10;\r\n        }\r\n        require(mintLock(hearts * (dayLength / 10)), \"Error: could not mint tokens\");\r\n        return true;\r\n    }\r\n\r\n\r\n    //end a stake - cannot emergency unstake\r\n    function endStake(uint stakeId)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(stakeId <= last_stake_id, \"Error: stakeId out of range\");\r\n        StakeInfo storage stake = stakes[stakeId];\r\n        require(stake.userAddress == msg.sender, \"cannot end another users stake. If this was intentional, use the HEX good accounting function.\");\r\n        require(!stake.stakeEnded, \"Stake has already been ended\");\r\n        require(stake.heartValue > 0, \"Stake has either already ended, or does not exist\");\r\n        require(isStakeFinished(stakeId), \"Error: cannot early unstake\");\r\n\r\n        uint256 oldBalance = getContractBalance();\r\n        //find the stake index then\r\n        //end stake\r\n        hexInterface.stakeEnd(getStakeIndexById(address(this), stake.hexStakeId), stake.hexStakeId);\r\n        stake.isStaking = false;\r\n        stake.stakeEnded = true;\r\n        //calc stakeValue and stakeProfit\r\n        uint256 stakeValue = getContractBalance().sub(oldBalance);\r\n        uint _fee; \r\n        uint _devFee;\r\n        uint _refFee;\r\n        uint _profit;\r\n        uint _principal;\r\n        if(stakeValue < stake.heartValue)//late penalties cut into principal\r\n        {\r\n            stake.stakeValue = stakeValue;//remaining principal\r\n            stake.stakeProfit = 0;//interest\r\n            //calc fee from remaining principal\r\n            _fee = stakeValue.div(fee);\r\n            _devFee = _fee.div(devFee);\r\n            _refFee = _fee.div(refFee);\r\n            _profit = 0;\r\n            _principal = stakeValue.sub(_fee);//sub fee from remaining principal\r\n        }\r\n        else{\r\n            stake.stakeValue = stakeValue;//principal + interest\r\n            stake.stakeProfit = stakeValue.sub(stake.heartValue);//interest\r\n            //calc fee from staking interest\r\n            _fee = stake.stakeProfit.div(fee);\r\n            _devFee = _fee.div(devFee);\r\n            _refFee = _fee.div(refFee);\r\n            _profit = stake.stakeProfit.sub(_fee);//sub fee from interest profit\r\n            _principal = stake.heartValue;\r\n        }\r\n        if(stake.refferer == address(0)){//no ref\r\n            require(hexInterface.transfer(devAddress, _refFee), \"Dev transfer failed\");//send hex to dev\r\n        }\r\n        else{//ref\r\n            require(hexInterface.transfer(stake.refferer, _refFee), \"Ref transfer failed\");//send hex to refferer\r\n        }\r\n        uint dFee = _devFee.mul(9).div(10);//90% of 0.05%\r\n        require(hexInterface.transfer(devAddress, dFee), \"Dev transfer failed\");//send hex to dev\r\n        require(hexInterface.transfer(devAddress2, _devFee.sub(dFee)), \"Dev transfer failed\");//send hex to dev2\r\n        require(hexInterface.transfer(msg.sender, _principal.add(_profit)), \"Transfer failed\");//transfer funds to user endstake\r\n        emit StakeEnded(\r\n            stake.stakeProfit,\r\n            stake.heartValue,\r\n            stake.dayLength,\r\n            stake.hexStakeId\r\n        );\r\n        stake.heartValue = 0;\r\n        return true;\r\n    }\r\n\r\n    //updates user data\r\n    function updateUserData(uint hearts)\r\n        internal\r\n    {\r\n        UserInfo storage user = users[msg.sender];\r\n        lifetimeHeartsStaked += hearts;\r\n        if(user.totalHeartsStaked == 0){\r\n            userCount++;\r\n        }\r\n        user.totalHeartsStaked = user.totalHeartsStaked.add(hearts);//total amount of hearts staked by this user after fees\r\n        user.userAddress = msg.sender;\r\n    }\r\n\r\n    //updates stake data\r\n    function updateStakeData(uint hearts, uint dayLength, address payable ref, uint index)\r\n        internal\r\n    {\r\n        uint _stakeId = _next_stake_id();//new stake id\r\n        userStakeIds[msg.sender].push(_stakeId);//update userStakeIds\r\n        StakeInfo memory stake;\r\n        stake.heartValue = hearts;//amount of hearts staked\r\n        stake.dayLength = dayLength;//length of days staked\r\n        stake.userAddress = msg.sender;//staker\r\n        stake.refferer = ref;//referrer\r\n        stake.hexStakeIndex = index;//hex contract stakeIndex\r\n        SStore memory _stake = getStakeByIndex(address(this), stake.hexStakeIndex); //get stake from address and stakeindex\r\n        stake.hexStakeId = _stake.stakeId;//hex contract stake id\r\n        stake.stakeId = _stakeId;//hexlock contract stake id\r\n        stake.stakeStartTimestamp = now;//timestamp stake started\r\n        stake.isStaking = true;//stake is now staking\r\n        stakes[_stakeId] = stake;//update data\r\n        emit StakeStarted(\r\n            hearts,\r\n            dayLength,\r\n            stake.hexStakeId\r\n        );\r\n    }\r\n\r\n    //get next stake id\r\n    function _next_stake_id()\r\n        internal\r\n        returns (uint)\r\n    {\r\n        last_stake_id++;\r\n        return last_stake_id;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////\r\n    ////////////////////////PUBLIC FACING HEXLOCK////////////////////\r\n    ////////////////////////////////////////////////////////////////\r\n\r\n    //stake HEX\r\n    function StakeHex(uint _hearts, uint _dayLength, address payable _ref)\r\n        public\r\n        canStake(_hearts)\r\n        synchronized\r\n    {\r\n        require(stakeHex(_hearts, _dayLength, _ref), \"Error: could not stake\");\r\n    }\r\n\r\n    //ends a stake then returns HEX + interest to msg.sender\r\n    function EndStake(uint _stakeId)\r\n        public\r\n        synchronized\r\n    {\r\n        require(endStake(_stakeId), \"Error: could not endstake\");\r\n    }\r\n\r\n\r\n    //////////////////////////////////////////\r\n    ////////////VIEW ONLY/////////////////////\r\n    //////////////////////////////////////////\r\n\r\n\r\n    //\r\n    function isStaking(uint _stakeId)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return stakes[_stakeId].isStaking;\r\n    }\r\n\r\n    //\r\n    function isStakeFinished(uint _stakeId)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        //add 1 to staking dayLength to account for stake pending time\r\n        return stakes[_stakeId].stakeStartTimestamp.add((stakes[_stakeId].dayLength.add(1)).mul(86400)) <= now;\r\n    }\r\n\r\n    //\r\n    function isStakeEnded(uint _stakeId)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return stakes[_stakeId].stakeEnded;\r\n    }\r\n\r\n    //general user info\r\n    function getUserInfo(address addr)\r\n        public\r\n        view\r\n        returns(\r\n        uint    totalHeartsStaked,\r\n        uint[] memory _stakeIds,\r\n        address userAddress\r\n        )\r\n    {\r\n        return(users[addr].totalHeartsStaked, userStakeIds[addr], users[addr].userAddress);\r\n    }\r\n\r\n    //general stake info\r\n    function getStakeInfo(uint stakeId)\r\n        public\r\n        view\r\n        returns(\r\n        uint     heartValue,\r\n        uint     stakeDayLength,\r\n        uint     hexStakeId,\r\n        uint     hexStakeIndex,\r\n        address payable userAddress,\r\n        address payable refferer,\r\n        uint    stakeStartTimestamp\r\n        )\r\n    {\r\n        return(stakes[stakeId].heartValue, stakes[stakeId].dayLength, stakes[stakeId].hexStakeId, stakes[stakeId].hexStakeIndex, stakes[stakeId].userAddress, stakes[stakeId].refferer, stakes[stakeId].stakeStartTimestamp);\r\n    }\r\n\r\n    //returns amount of users by address to ever stake via the contract\r\n    function getUserCount()\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return userCount;\r\n    }\r\n\r\n    //returns contract HEX balance\r\n    function getContractBalance()\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return hexInterface.balanceOf(address(this));\r\n    }\r\n\r\n    ///////////////////////////////////////////////\r\n    ///////////////////HEX UTILS///////////////////\r\n    ///////////////////////////////////////////////\r\n    //credits to kyle bahr @ https://gist.github.com/kbahr/80e61ab761053849f7fdc6226b85a354\r\n\r\n    struct SStore {\r\n        uint40 stakeId;\r\n        uint72 stakedHearts;\r\n        uint72 stakeShares;\r\n        uint16 lockedDay;\r\n        uint16 stakedDays;\r\n        uint16 unlockedDay;\r\n        bool isAutoStake;\r\n    }\r\n\r\n    struct DailyDataCache {\r\n        uint256 dayPayoutTotal;\r\n        uint256 dayStakeSharesTotal;\r\n        uint256 dayUnclaimedSatoshisTotal;\r\n    }\r\n    uint256 private constant HEARTS_UINT_SHIFT = 72;\r\n    uint256 private constant HEARTS_MASK = (1 << HEARTS_UINT_SHIFT) - 1;\r\n    uint256 private constant SATS_UINT_SHIFT = 56;\r\n    uint256 private constant SATS_MASK = (1 << SATS_UINT_SHIFT) - 1;\r\n\r\n    function decodeDailyData(uint256 encDay)\r\n    private\r\n    pure\r\n    returns (DailyDataCache memory)\r\n    {\r\n        uint256 v = encDay;\r\n        uint256 payout = v & HEARTS_MASK;\r\n        v = v >> HEARTS_UINT_SHIFT;\r\n        uint256 shares = v & HEARTS_MASK;\r\n        v = v >> HEARTS_UINT_SHIFT;\r\n        uint256 sats = v & SATS_MASK;\r\n        return DailyDataCache(payout, shares, sats);\r\n    }\r\n\r\n    function interestForRange(DailyDataCache[] memory dailyData, uint256 myShares)\r\n    private\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        uint256 len = dailyData.length;\r\n        uint256 total = 0;\r\n        for(uint256 i = 0; i < len; i++){\r\n            total += interestForDay(dailyData[i], myShares);\r\n        }\r\n        return total;\r\n    }\r\n\r\n    function interestForDay(DailyDataCache memory dayObj, uint256 myShares)\r\n    private\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return myShares * dayObj.dayPayoutTotal / dayObj.dayStakeSharesTotal;\r\n    }\r\n\r\n    function getDataRange(uint256 b, uint256 e)\r\n    private\r\n    view\r\n    returns (DailyDataCache[] memory)\r\n    {\r\n        uint256[] memory dataRange = hexInterface.dailyDataRange(b, e);\r\n        uint256 len = dataRange.length;\r\n        DailyDataCache[] memory data = new DailyDataCache[](len);\r\n        for(uint256 i = 0; i < len; i++){\r\n            data[i] = decodeDailyData(dataRange[i]);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    function getLastDataDay()\r\n    private\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256[13] memory globalInfo = hexInterface.globalInfo();\r\n        uint256 lastDay = globalInfo[4];\r\n        return lastDay;\r\n    }\r\n\r\n    function getInterestByStake(SStore memory s)\r\n    private\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 b = s.lockedDay;\r\n        uint256 e = getLastDataDay(); // ostensibly \"today\"\r\n\r\n        if (b >= e) {\r\n            //not started - error\r\n            return 0;\r\n        } else {\r\n            DailyDataCache[] memory data = getDataRange(b, e);\r\n            return interestForRange(data, s.stakeShares);\r\n        }\r\n    }\r\n\r\n    function getInterestByStakeId(address addr, uint40 stakeId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        SStore memory s = getStakeByStakeId(addr, stakeId);\r\n\r\n        return getInterestByStake(s);\r\n    }\r\n\r\n    function getTotalValueByStakeId(address addr, uint40 stakeId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        SStore memory stake = getStakeByStakeId(addr, stakeId);\r\n\r\n        uint256 interest = getInterestByStake(stake);\r\n        return stake.stakedHearts + interest;\r\n    }\r\n\r\n    function getStakeByIndex(address addr, uint256 idx)\r\n    private\r\n    view\r\n    returns (SStore memory)\r\n    {\r\n        uint40 stakeId;\r\n        uint72 stakedHearts;\r\n        uint72 stakeShares;\r\n        uint16 lockedDay;\r\n        uint16 stakedDays;\r\n        uint16 unlockedDay;\r\n        bool isAutoStake;\r\n\r\n        (stakeId,\r\n            stakedHearts,\r\n            stakeShares,\r\n            lockedDay,\r\n            stakedDays,\r\n            unlockedDay,\r\n            isAutoStake) = hexInterface.stakeLists(addr, idx);\r\n\r\n        return SStore(stakeId,\r\n                        stakedHearts,\r\n                        stakeShares,\r\n                        lockedDay,\r\n                        stakedDays,\r\n                        unlockedDay,\r\n                        isAutoStake);\r\n    }\r\n\r\n    function getStakeByStakeId(address addr, uint40 sid)\r\n    private\r\n    view\r\n    returns (SStore memory)\r\n    {\r\n\r\n        uint40 stakeId;\r\n        uint72 stakedHearts;\r\n        uint72 stakeShares;\r\n        uint16 lockedDay;\r\n        uint16 stakedDays;\r\n        uint16 unlockedDay;\r\n        bool isAutoStake;\r\n\r\n        uint256 stakeCount = hexInterface.stakeCount(addr);\r\n        for(uint256 i = 0; i < stakeCount; i++){\r\n            (stakeId,\r\n            stakedHearts,\r\n            stakeShares,\r\n            lockedDay,\r\n            stakedDays,\r\n            unlockedDay,\r\n            isAutoStake) = hexInterface.stakeLists(addr, i);\r\n\r\n            if(stakeId == sid){\r\n                return SStore(stakeId,\r\n                                stakedHearts,\r\n                                stakeShares,\r\n                                lockedDay,\r\n                                stakedDays,\r\n                                unlockedDay,\r\n                                isAutoStake);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getStakeIndexById(address addr, uint40 sid)\r\n        private\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint40 stakeId;\r\n        uint72 stakedHearts;\r\n        uint72 stakeShares;\r\n        uint16 lockedDay;\r\n        uint16 stakedDays;\r\n        uint16 unlockedDay;\r\n        bool isAutoStake;\r\n\r\n        uint256 stakeCount = hexInterface.stakeCount(addr);\r\n        for(uint256 i = 0; i < stakeCount; i++){\r\n            (stakeId,\r\n            stakedHearts,\r\n            stakeShares,\r\n            lockedDay,\r\n            stakedDays,\r\n            unlockedDay,\r\n            isAutoStake) = hexInterface.stakeLists(addr, i);\r\n\r\n            if(stakeId == sid){\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n}\r\n"},"browser/IERC20.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\n \r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);//from address(0) for minting\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"},"browser/SafeMath.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"}}}