{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":20000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BondTokenName.sol":{"content":"pragma solidity 0.6.6;\r\n\r\n// File: contracts/bondTokenName/BondTokenNameInterface.sol\r\n\r\n\r\n\r\n/**\r\n * @title bond token name contract interface\r\n */\r\ninterface BondTokenNameInterface {\r\n    function genBondTokenName(\r\n        string calldata shortNamePrefix,\r\n        string calldata longNamePrefix,\r\n        uint256 maturity,\r\n        uint256 solidStrikePriceE4\r\n    ) external pure returns (string memory shortName, string memory longName);\r\n\r\n    function getBondTokenName(\r\n        uint256 maturity,\r\n        uint256 solidStrikePriceE4,\r\n        uint256 rateLBTWorthlessE4\r\n    ) external pure returns (string memory shortName, string memory longName);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = byte(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: contracts/util/Digits.sol\r\n\r\n\r\n\r\nlibrary Digits {\r\n    /**\r\n     * @notice represent given number to `digits` digits string\r\n     */\r\n    function toString(uint256 value, uint256 digits) internal pure returns (string memory) {\r\n        // solium-disable-previous-line security/no-assign-params\r\n        bytes memory buffer = new bytes(digits);\r\n        while (digits != 0) {\r\n            digits--;\r\n            buffer[digits] = bytes1(uint8(48 + (value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: contracts/util/DateTimeLibrary.sol\r\n\r\n\r\n\r\nlibrary DateTimeLibrary {\r\n    uint256 internal constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint256 internal constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint256 internal constant SECONDS_PER_MINUTE = 60;\r\n    int256 internal constant OFFSET19700101 = 2440588;\r\n\r\n    uint256 internal constant DOW_MON = 1;\r\n    uint256 internal constant DOW_TUE = 2;\r\n    uint256 internal constant DOW_WED = 3;\r\n    uint256 internal constant DOW_THU = 4;\r\n    uint256 internal constant DOW_FRI = 5;\r\n    uint256 internal constant DOW_SAT = 6;\r\n    uint256 internal constant DOW_SUN = 7;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate the number of days from 1970/01/01 to year/month/day using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // days = day\r\n    //      - 32075\r\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\r\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\r\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\r\n    //      - offset\r\n    // ------------------------------------------------------------------------\r\n    function _daysFromDate(\r\n        uint256 year,\r\n        uint256 month,\r\n        uint256 day\r\n    ) internal pure returns (uint256 _days) {\r\n        require(year >= 1970, \"year must be more than or equal to 1970\");\r\n        int256 _year = int256(year);\r\n        int256 _month = int256(month);\r\n        int256 _day = int256(day);\r\n\r\n        int256 __days = _day -\r\n            32075 +\r\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\r\n            4 +\r\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\r\n            12 -\r\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\r\n            4 -\r\n            OFFSET19700101;\r\n\r\n        _days = uint256(__days);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate year/month/day from the number of days since 1970/01/01 using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // int L = days + 68569 + offset\r\n    // int N = 4 * L / 146097\r\n    // L = L - (146097 * N + 3) / 4\r\n    // year = 4000 * (L + 1) / 1461001\r\n    // L = L - 1461 * year / 4 + 31\r\n    // month = 80 * L / 2447\r\n    // dd = L - 2447 * month / 80\r\n    // L = month / 11\r\n    // month = month + 2 - 12 * L\r\n    // year = 100 * (N - 49) + year + L\r\n    // ------------------------------------------------------------------------\r\n    function _daysToDate(uint256 _days)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 year,\r\n            uint256 month,\r\n            uint256 day\r\n        )\r\n    {\r\n        int256 __days = int256(_days);\r\n\r\n        int256 L = __days + 68569 + OFFSET19700101;\r\n        int256 N = (4 * L) / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int256 _year = (4000 * (L + 1)) / 1461001;\r\n        L = L - (1461 * _year) / 4 + 31;\r\n        int256 _month = (80 * L) / 2447;\r\n        int256 _day = L - (2447 * _month) / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint256(_year);\r\n        month = uint256(_month);\r\n        day = uint256(_day);\r\n    }\r\n\r\n    function timestampFromDate(\r\n        uint256 year,\r\n        uint256 month,\r\n        uint256 day\r\n    ) internal pure returns (uint256 timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\r\n    }\r\n\r\n    function timestampFromDateTime(\r\n        uint256 year,\r\n        uint256 month,\r\n        uint256 day,\r\n        uint256 hour,\r\n        uint256 minute,\r\n        uint256 second\r\n    ) internal pure returns (uint256 timestamp) {\r\n        timestamp =\r\n            _daysFromDate(year, month, day) *\r\n            SECONDS_PER_DAY +\r\n            hour *\r\n            SECONDS_PER_HOUR +\r\n            minute *\r\n            SECONDS_PER_MINUTE +\r\n            second;\r\n    }\r\n\r\n    function timestampToDate(uint256 timestamp)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 year,\r\n            uint256 month,\r\n            uint256 day\r\n        )\r\n    {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function timestampToDateTime(uint256 timestamp)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 year,\r\n            uint256 month,\r\n            uint256 day,\r\n            uint256 hour,\r\n            uint256 minute,\r\n            uint256 second\r\n        )\r\n    {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint256 secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n        secs = secs % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n        second = secs % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function isValidDate(\r\n        uint256 year,\r\n        uint256 month,\r\n        uint256 day\r\n    ) internal pure returns (bool valid) {\r\n        if (year >= 1970 && month > 0 && month <= 12) {\r\n            uint256 daysInMonth = _getDaysInMonth(year, month);\r\n            if (day > 0 && day <= daysInMonth) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function isValidDateTime(\r\n        uint256 year,\r\n        uint256 month,\r\n        uint256 day,\r\n        uint256 hour,\r\n        uint256 minute,\r\n        uint256 second\r\n    ) internal pure returns (bool valid) {\r\n        if (isValidDate(year, month, day)) {\r\n            if (hour < 24 && minute < 60 && second < 60) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function isLeapYear(uint256 timestamp) internal pure returns (bool leapYear) {\r\n        uint256 year;\r\n        uint256 month;\r\n        uint256 day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        leapYear = _isLeapYear(year);\r\n    }\r\n\r\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\r\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\r\n    }\r\n\r\n    function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\r\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\r\n    }\r\n\r\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\r\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\r\n    }\r\n\r\n    function getDaysInMonth(uint256 timestamp) internal pure returns (uint256 daysInMonth) {\r\n        uint256 year;\r\n        uint256 month;\r\n        uint256 day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        daysInMonth = _getDaysInMonth(year, month);\r\n    }\r\n\r\n    function _getDaysInMonth(uint256 year, uint256 month)\r\n        internal\r\n        pure\r\n        returns (uint256 daysInMonth)\r\n    {\r\n        if (\r\n            month == 1 ||\r\n            month == 3 ||\r\n            month == 5 ||\r\n            month == 7 ||\r\n            month == 8 ||\r\n            month == 10 ||\r\n            month == 12\r\n        ) {\r\n            daysInMonth = 31;\r\n        } else if (month != 2) {\r\n            daysInMonth = 30;\r\n        } else {\r\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\r\n        }\r\n    }\r\n\r\n    // 1 = Monday, 7 = Sunday\r\n    function getDayOfWeek(uint256 timestamp) internal pure returns (uint256 dayOfWeek) {\r\n        uint256 _days = timestamp / SECONDS_PER_DAY;\r\n        dayOfWeek = ((_days + 3) % 7) + 1;\r\n    }\r\n\r\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\r\n        uint256 month;\r\n        uint256 day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\r\n        uint256 year;\r\n        uint256 day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function getDay(uint256 timestamp) internal pure returns (uint256 day) {\r\n        uint256 year;\r\n        uint256 month;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\r\n        uint256 secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n    }\r\n\r\n    function getMinute(uint256 timestamp) internal pure returns (uint256 minute) {\r\n        uint256 secs = timestamp % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function getSecond(uint256 timestamp) internal pure returns (uint256 second) {\r\n        second = timestamp % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    // function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n    //     uint year;\r\n    //     uint month;\r\n    //     uint day;\r\n    //     (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    //     year += _years;\r\n    //     uint daysInMonth = _getDaysInMonth(year, month);\r\n    //     if (day > daysInMonth) {\r\n    //         day = daysInMonth;\r\n    //     }\r\n    //     newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n    //     require(newTimestamp >= timestamp);\r\n    // }\r\n    // function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n    //     uint year;\r\n    //     uint month;\r\n    //     uint day;\r\n    //     (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    //     month += _months;\r\n    //     year += (month - 1) / 12;\r\n    //     month = (month - 1) % 12 + 1;\r\n    //     uint daysInMonth = _getDaysInMonth(year, month);\r\n    //     if (day > daysInMonth) {\r\n    //         day = daysInMonth;\r\n    //     }\r\n    //     newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n    //     require(newTimestamp >= timestamp);\r\n    // }\r\n    // function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n    //     newTimestamp = timestamp + _days * SECONDS_PER_DAY;\r\n    //     require(newTimestamp >= timestamp);\r\n    // }\r\n    // function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n    //     newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\r\n    //     require(newTimestamp >= timestamp);\r\n    // }\r\n    // function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n    //     newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\r\n    //     require(newTimestamp >= timestamp);\r\n    // }\r\n    // function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n    //     newTimestamp = timestamp + _seconds;\r\n    //     require(newTimestamp >= timestamp);\r\n    // }\r\n\r\n    // function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n    //     uint year;\r\n    //     uint month;\r\n    //     uint day;\r\n    //     (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    //     year -= _years;\r\n    //     uint daysInMonth = _getDaysInMonth(year, month);\r\n    //     if (day > daysInMonth) {\r\n    //         day = daysInMonth;\r\n    //     }\r\n    //     newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n    //     require(newTimestamp <= timestamp);\r\n    // }\r\n    // function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n    //     uint year;\r\n    //     uint month;\r\n    //     uint day;\r\n    //     (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    //     uint yearMonth = year * 12 + (month - 1) - _months;\r\n    //     year = yearMonth / 12;\r\n    //     month = yearMonth % 12 + 1;\r\n    //     uint daysInMonth = _getDaysInMonth(year, month);\r\n    //     if (day > daysInMonth) {\r\n    //         day = daysInMonth;\r\n    //     }\r\n    //     newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n    //     require(newTimestamp <= timestamp);\r\n    // }\r\n    // function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n    //     newTimestamp = timestamp - _days * SECONDS_PER_DAY;\r\n    //     require(newTimestamp <= timestamp);\r\n    // }\r\n    // function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n    //     newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\r\n    //     require(newTimestamp <= timestamp);\r\n    // }\r\n    // function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n    //     newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\r\n    //     require(newTimestamp <= timestamp);\r\n    // }\r\n    // function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n    //     newTimestamp = timestamp - _seconds;\r\n    //     require(newTimestamp <= timestamp);\r\n    // }\r\n\r\n    // function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\r\n    //     require(fromTimestamp <= toTimestamp);\r\n    //     uint fromYear;\r\n    //     uint fromMonth;\r\n    //     uint fromDay;\r\n    //     uint toYear;\r\n    //     uint toMonth;\r\n    //     uint toDay;\r\n    //     (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n    //     (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n    //     _years = toYear - fromYear;\r\n    // }\r\n    // function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\r\n    //     require(fromTimestamp <= toTimestamp);\r\n    //     uint fromYear;\r\n    //     uint fromMonth;\r\n    //     uint fromDay;\r\n    //     uint toYear;\r\n    //     uint toMonth;\r\n    //     uint toDay;\r\n    //     (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n    //     (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n    //     _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\r\n    // }\r\n    // function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\r\n    //     require(fromTimestamp <= toTimestamp);\r\n    //     _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\r\n    // }\r\n    // function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\r\n    //     require(fromTimestamp <= toTimestamp);\r\n    //     _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\r\n    // }\r\n    // function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\r\n    //     require(fromTimestamp <= toTimestamp);\r\n    //     _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\r\n    // }\r\n    // function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\r\n    //     require(fromTimestamp <= toTimestamp);\r\n    //     _seconds = toTimestamp - fromTimestamp;\r\n    // }\r\n}\r\n\r\n// File: contracts/bondTokenName/BondTokenName.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title bond token name contract\r\n * @notice generate the name of bond token from its bond property\r\n */\r\ncontract BondTokenName is BondTokenNameInterface {\r\n    using Strings for uint256;\r\n    using Digits for uint256;\r\n    using DateTimeLibrary for uint256;\r\n\r\n    /**\r\n     * @notice generate a bond token name with exactly 12 letters and a long bond token name\r\n     */\r\n    function genBondTokenName(\r\n        string memory shortNamePrefix,\r\n        string memory longNamePrefix,\r\n        uint256 maturity,\r\n        uint256 solidStrikePriceE0\r\n    ) public pure override returns (string memory shortName, string memory longName) {\r\n        (uint256 year, uint256 month, uint256 day) = maturity.timestampToDate();\r\n        string memory yearStr = year.toString(4);\r\n        string memory monthStr = month.toString(2);\r\n        string memory dayStr = day.toString(2);\r\n        {\r\n            string memory shortDateStr = string(abi.encodePacked(monthStr, dayStr));\r\n            string memory shortStrikePriceStr = solidStrikePriceE0.toString(4);\r\n\r\n            shortName = string(\r\n                abi.encodePacked(shortNamePrefix, shortDateStr, \"\", shortStrikePriceStr)\r\n            );\r\n        }\r\n        {\r\n            string memory dateStr = string(abi.encodePacked(yearStr, monthStr, dayStr));\r\n            string memory strikePriceStr = solidStrikePriceE0.toString();\r\n            longName = string(abi.encodePacked(longNamePrefix, \" \", dateStr, \" \", strikePriceStr));\r\n        }\r\n    }\r\n\r\n    function getBondTokenName(\r\n        uint256 maturity,\r\n        uint256 solidStrikePriceE0,\r\n        uint256 rateLBTWorthlessE0\r\n    ) public pure override returns (string memory shortName, string memory longName) {\r\n        if (solidStrikePriceE0 != 0) {\r\n            return genBondTokenName(\"SBT\", \"SBT\", maturity, solidStrikePriceE0);\r\n        } else if (rateLBTWorthlessE0 != 0) {\r\n            return genBondTokenName(\"LBT\", \"LBT\", maturity, rateLBTWorthlessE0);\r\n        } else {\r\n            return genBondTokenName(\"IMT\", \"Immortal Option\", maturity, 0);\r\n        }\r\n    }\r\n}"}}}