{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ChainlinkRelayer.sol": {
      "content": "pragma solidity 0.6.7;\n\ncontract GebMath {\n    uint256 public constant RAY = 10 ** 27;\n    uint256 public constant WAD = 10 ** 18;\n\n    function ray(uint x) public pure returns (uint z) {\n        z = multiply(x, 10 ** 9);\n    }\n    function rad(uint x) public pure returns (uint z) {\n        z = multiply(x, 10 ** 27);\n    }\n    function minimum(uint x, uint y) public pure returns (uint z) {\n        z = (x <= y) ? x : y;\n    }\n    function addition(uint x, uint y) public pure returns (uint z) {\n        z = x + y;\n        require(z >= x, \"uint-uint-add-overflow\");\n    }\n    function subtract(uint x, uint y) public pure returns (uint z) {\n        z = x - y;\n        require(z <= x, \"uint-uint-sub-underflow\");\n    }\n    function multiply(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"uint-uint-mul-overflow\");\n    }\n    function rmultiply(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, y) / RAY;\n    }\n    function rdivide(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, RAY) / y;\n    }\n    function wdivide(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, WAD) / y;\n    }\n    function wmultiply(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, y) / WAD;\n    }\n    function rpower(uint x, uint n, uint base) public pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) { revert(0,0) }\n                    x := div(xxRound, base)\n                    if mod(n,2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) { revert(0,0) }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n}\n\ninterface AggregatorInterface {\n    event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n\n    function latestAnswer() external view returns (int256);\n    function latestTimestamp() external view returns (uint256);\n    function latestRound() external view returns (uint256);\n    function getAnswer(uint256 roundId) external view returns (int256);\n    function getTimestamp(uint256 roundId) external view returns (uint256);\n\n    // post-Historic\n\n    function decimals() external view returns (uint8);\n    function getRoundData(uint256 _roundId)\n      external\n      returns (\n        uint256 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint256 answeredInRound\n      );\n    function latestRoundData()\n      external\n      returns (\n        uint256 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint256 answeredInRound\n      );\n}\n\ncontract ChainlinkRelayer is GebMath {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"ChainlinkRelayer/account-not-authorized\");\n        _;\n    }\n\n    // --- Variables ---\n    AggregatorInterface public chainlinkAggregator;\n\n    // Multiplier for the Chainlink price feed in order to scaled it to 18 decimals. Default to 10 for USD price feeds\n    uint8   public multiplier = 10;\n    // Time threshold after which a Chainlink response is considered stale\n    uint256 public staleThreshold;\n\n    bytes32 public symbol = \"ethusd\";\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(\n      bytes32 parameter,\n      address addr\n    );\n    event ModifyParameters(\n      bytes32 parameter,\n      uint256 val\n    );\n\n    constructor(\n      address aggregator,\n      uint256 staleThreshold_\n    ) public {\n        require(aggregator != address(0), \"ChainlinkRelayer/null-aggregator\");\n        require(multiplier >= 1, \"ChainlinkRelayer/null-multiplier\");\n        require(staleThreshold_ > 0, \"ChainlinkRelayer/null-stale-threshold\");\n\n        authorizedAccounts[msg.sender] = 1;\n\n        staleThreshold                 = staleThreshold_;\n        chainlinkAggregator            = AggregatorInterface(aggregator);\n\n        emit AddAuthorization(msg.sender);\n        emit ModifyParameters(\"staleThreshold\", staleThreshold);\n        emit ModifyParameters(\"aggregator\", aggregator);\n    }\n\n    // --- General Utils ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Modify an uin256 parameter\n    * @param parameter The name of the parameter to change\n    * @param data The new parameter value\n    */\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        if (parameter == \"staleThreshold\") {\n          require(data > 1, \"ChainlinkRelayer/invalid-stale-threshold\");\n          staleThreshold = data;\n        }\n        else revert(\"ChainlinkRelayer/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /*\n    * @notify Modify an address parameter\n    * @param parameter The name of the parameter to change\n    * @param addr The new parameter address\n    */\n    function modifyParameters(bytes32 parameter, address addr) external isAuthorized {\n        require(addr != address(0), \"ChainlinkRelayer/null-addr\");\n        if (parameter == \"aggregator\") chainlinkAggregator = AggregatorInterface(addr);\n        else revert(\"ChainlinkRelayer/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, addr);\n    }\n\n    // --- Main Getters ---\n    /**\n    * @notice Fetch the latest medianResult or revert if is is null, if the price is stale or if chainlinkAggregator is null\n    **/\n    function read() external view returns (uint256) {\n        // The relayer must not be null\n        require(address(chainlinkAggregator) != address(0), \"ChainlinkRelayer/null-reward-relayer\");\n\n        // Fetch values from Chainlink\n        uint256 medianPrice         = multiply(uint(chainlinkAggregator.latestAnswer()), 10 ** uint(multiplier));\n        uint256 aggregatorTimestamp = chainlinkAggregator.latestTimestamp();\n\n        require(both(medianPrice > 0, subtract(now, aggregatorTimestamp) <= staleThreshold), \"ChainlinkRelayer/invalid-price-feed\");\n        return medianPrice;\n    }\n    /**\n    * @notice Fetch the latest medianResult and whether it is valid or not\n    **/\n    function getResultWithValidity() external view returns (uint256, bool) {\n        if (address(chainlinkAggregator) == address(0)) return (0, false);\n\n        // Fetch values from Chainlink\n        uint256 medianPrice         = multiply(uint(chainlinkAggregator.latestAnswer()), 10 ** uint(multiplier));\n        uint256 aggregatorTimestamp = chainlinkAggregator.latestTimestamp();\n\n        return (medianPrice, both(medianPrice > 0, subtract(now, aggregatorTimestamp) <= staleThreshold));\n    }\n\n    // --- Median Updates ---\n    /*\n    * @notice Remnant from other Chainlink medians\n    */\n    function updateResult(address feeReceiver) external {}\n}"
    }
  }
}