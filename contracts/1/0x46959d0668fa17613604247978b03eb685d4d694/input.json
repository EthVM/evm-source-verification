{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ccTokenDeSwap.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2021-12-06\r\n*/\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\n// pragma experimental SMTChecker;\r\n\r\n/// @title ERC20If\r\nabstract contract ERC20If {\r\n    function totalSupply() virtual public view returns (uint256);\r\n\r\n    function balanceOf(address _who) virtual public view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) virtual public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function allowance(address _owner, address _spender) virtual public view returns (uint256);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) virtual public returns (bool);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\nabstract contract OwnableIf {\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner(), \"not owner......\");\r\n        _;\r\n    }\r\n\r\n    function _owner() view virtual public returns (address);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is OwnableIf {\r\n    address public owner;\r\n\r\n    function _owner() view override public returns (address){\r\n        return owner;\r\n    }\r\n\r\n    //    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    //    /**\r\n    //     * @dev Throws if called by any account other than the owner.\r\n    //     */\r\n    //    modifier onlyOwner() {\r\n    //        require(msg.sender == owner);\r\n    //        _;\r\n    //    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    //   function renounceOwnership() public onlyOwner {\r\n    //     emit OwnershipRenounced(owner);\r\n    //     owner = address(0);\r\n    //   }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) virtual public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address _newOwner) internal {\r\n        require(_newOwner != address(0), \"invalid _newOwner\");\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Claimable.sol\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is Ownable {\r\n    address public pendingOwner;\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingOwner.\r\n     */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"no permission\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to set the pendingOwner address.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) override public onlyOwner {\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the pendingOwner address to finalize the transfer.\r\n     */\r\n    function claimOwnership() public onlyPendingOwner {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title CanReclaimToken\r\nabstract contract CanReclaimToken is OwnableIf {\r\n\r\n    function reclaimToken(ERC20If _token) external onlyOwner {\r\n        uint256 balance = _token.balanceOf((address)(this));\r\n        require(_token.transfer(_owner(), balance));\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n// \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract ccTokenWrap is Ownable, CanReclaimToken {\r\n    using SafeMath for uint256;\r\n    ERC20If public cctoken;\r\n    string public nativeCoinType;\r\n    address public cctokenRepository;\r\n    uint256 public wrapSeq;\r\n    mapping(bytes32 => uint256) public wrapSeqMap;\r\n\r\n    // bool public checkSignature = true;\r\n\r\n    uint256 constant rate_precision = 1e10;\r\n\r\n    // function _checkSignature(bool _b) public onlyOwner {\r\n    //     checkSignature = _b;\r\n    // }\r\n\r\n    function _cctokenRepositorySet(address newRepository)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newRepository != (address)(0), \"invalid addr\");\r\n        cctokenRepository = newRepository;\r\n    }\r\n\r\n    function wrapHash(string memory nativeCoinAddress, string memory nativeTxId)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(nativeCoinAddress, nativeTxId));\r\n    }\r\n\r\n    event SETUP(\r\n        address _cctoken,\r\n        string _nativeCoinType,\r\n        address _cctokenRepository\r\n    );\r\n\r\n    function setup(\r\n        address _cctoken,\r\n        string memory _nativeCoinType,\r\n        address _cctokenRepository,\r\n        address _initOwner\r\n    )\r\n        public\r\n        returns (\r\n            bool\r\n        )\r\n    {\r\n        if (wrapSeq <= 0) {\r\n            wrapSeq = 1;\r\n            cctoken = (ERC20If)(_cctoken);\r\n            nativeCoinType = _nativeCoinType;\r\n            cctokenRepository = _cctokenRepository;\r\n            owner = _initOwner;\r\n            emit SETUP(_cctoken, _nativeCoinType, _cctokenRepository);\r\n            emit OwnershipTransferred(_owner(), _initOwner);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function uintToString(uint256 _i) public pure returns (string memory) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 j = _i;\r\n        uint256 len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint256 k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function toHexString(bytes memory data)\r\n        public\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(2 + data.length * 2);\r\n        str[0] = \"0\";\r\n        str[1] = \"x\";\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\r\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    function toHexString(address account) public pure returns (string memory) {\r\n        return toHexString(abi.encodePacked(account));\r\n    }\r\n\r\n    function calcCCTokenAmount(\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate\r\n    ) public pure returns (uint256) {\r\n        return amt.sub(fee).mul(rate).div(rate_precision);\r\n    }\r\n\r\n    function encode(\r\n        address receiveCCTokenAddress,\r\n        string memory nativeCoinAddress,\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate,\r\n        uint64 deadline\r\n    ) public view returns (bytes memory) {\r\n        uint id;\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return\r\n            abi.encodePacked(\r\n                \"wrap \",\r\n                nativeCoinType,\r\n                \"\\nto:\",\r\n                toHexString(receiveCCTokenAddress),\r\n                \"\\namt:\",\r\n                uintToString(amt),\r\n                \"\\nfee:\",\r\n                uintToString(fee),\r\n                \"\\nrate:\",\r\n                uintToString(rate),\r\n                \"\\ndeadline:\",\r\n                uintToString(deadline),\r\n                \"\\naddr:\",\r\n                nativeCoinAddress,\r\n                \"\\nchainid:\",\r\n                uintToString(id)\r\n            );\r\n    }\r\n\r\n    function personalMessage(bytes memory _msg)\r\n        public\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            abi.encodePacked(\r\n                \"\\x19Ethereum Signed Message:\\n\",\r\n                uintToString(_msg.length),\r\n                _msg\r\n            );\r\n    }\r\n\r\n    function recoverPersonalSignature(\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v,\r\n        bytes memory text\r\n    ) public pure returns (address) {\r\n        bytes32 h = keccak256(personalMessage(text));\r\n        return ecrecover(h, v, r, s);\r\n    }\r\n\r\n    function wrap(\r\n        address ethAccount,\r\n        address receiveCCTokenAddress,\r\n        string memory nativeCoinAddress,\r\n        string memory nativeTxId,\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate,\r\n        uint64 deadline,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v\r\n    ) public onlyOwner returns (bool) {\r\n        uint256 cctokenAmount = calcCCTokenAmount(amt, fee, rate);\r\n        // if (checkSignature) \r\n        {\r\n            bytes memory text =\r\n                encode(\r\n                    receiveCCTokenAddress,\r\n                    nativeCoinAddress,\r\n                    amt,\r\n                    fee,\r\n                    rate,\r\n                    deadline\r\n                );\r\n\r\n            address addr = recoverPersonalSignature(r, s, v, text);\r\n            require(addr != address(0), \"0 address\");\r\n            require(addr == ethAccount, \"invalid signature\");\r\n        }\r\n        require(\r\n            wrapSeqMap[wrapHash(nativeCoinAddress, nativeTxId)] <= 0,\r\n            \"wrap dup.\"\r\n        );\r\n        wrapSeqMap[wrapHash(nativeCoinAddress, nativeTxId)] = wrapSeq;\r\n        wrapSeq = wrapSeq + 1;\r\n\r\n        require(\r\n            cctoken.transferFrom(\r\n                cctokenRepository,\r\n                receiveCCTokenAddress,\r\n                cctokenAmount\r\n            ),\r\n            \"transferFrom failed\"\r\n        );\r\n        emit WRAP_EVENT(\r\n            wrapSeq,\r\n            ethAccount,\r\n            receiveCCTokenAddress,\r\n            nativeCoinAddress,\r\n            nativeTxId,\r\n            amt,fee,rate,\r\n            deadline,\r\n            r,\r\n            s,\r\n            v\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    event WRAP_EVENT(\r\n        uint256 indexed wrapSeq,\r\n        address ethAccount,\r\n        address receiveCCTokenAddress,\r\n        string nativeCoinAddress,\r\n        string nativeTxId,\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate,\r\n        uint64 deadline,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v\r\n    );\r\n}\r\n\r\n\r\ncontract ccTokenDeSwap is ccTokenWrap {\r\n    using SafeMath for uint256;\r\n\r\n    //PENDING=》CANCELED\r\n    //PENDING=》APPROVED\r\n    //APPROVED=》FINISHED\r\n    enum OrderStatus {PENDING, CANCELED, APPROVED, FINISHED}\r\n\r\n    function getStatusString(OrderStatus status)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        if (status == OrderStatus.PENDING) {\r\n            return \"pending\";\r\n        } else if (status == OrderStatus.CANCELED) {\r\n            return \"canceled\";\r\n        } else if (status == OrderStatus.APPROVED) {\r\n            return \"approved\";\r\n        } else if (status == OrderStatus.FINISHED) {\r\n            return \"finished\";\r\n        } else {\r\n            // unreachable.\r\n            return \"unknown\";\r\n        }\r\n    }\r\n\r\n    struct UnWrapOrder {\r\n        address ethAccount;\r\n        uint256 nativeCoinAmount;\r\n        uint256 cctokenAmount;\r\n        string nativeCoinAddress;\r\n        string nativeTxId;\r\n        uint256 requestBlockNo;\r\n        uint256 confirmedBlockNo;\r\n        OrderStatus status;\r\n        uint256 fee;\r\n        uint256 rate;\r\n    }\r\n\r\n    UnWrapOrder[] public unWrapOrders;\r\n    bool public paused = false;\r\n    modifier notPaused() {\r\n        require(!paused, \"paused\");\r\n        _;\r\n    }\r\n\r\n    function pause(bool _paused) public onlyOwner returns (bool) {\r\n        paused = _paused;\r\n        return true;\r\n    }\r\n\r\n    function getUnWrapOrderNum() public view returns (uint256) {\r\n        return unWrapOrders.length;\r\n    }\r\n\r\n    function getUnWrapOrderInfo(uint256 seq)\r\n        public\r\n        view\r\n        returns (\r\n            address ethAccount,\r\n            uint256 nativeCoinAmount,\r\n            uint256 cctokenAmount,\r\n            string memory nativeCoinAddress,\r\n            string memory nativeTxId,\r\n            uint256 requestBlockNo,\r\n            uint256 confirmedBlockNo,\r\n            string memory status\r\n        )\r\n    {\r\n        require(seq < unWrapOrders.length, \"invalid seq\");\r\n        UnWrapOrder memory order = unWrapOrders[seq];\r\n        ethAccount = order.ethAccount;\r\n        nativeCoinAmount = order.nativeCoinAmount;\r\n        cctokenAmount = order.cctokenAmount;\r\n        nativeCoinAddress = order.nativeCoinAddress;\r\n        nativeTxId = order.nativeTxId;\r\n        requestBlockNo = order.requestBlockNo;\r\n        confirmedBlockNo = order.confirmedBlockNo;\r\n        status = getStatusString(order.status);\r\n    }\r\n\r\n    function calcUnWrapAmount(\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate\r\n    ) public pure returns (uint256) {\r\n        return amt.sub(fee).mul(rate).div(rate_precision);\r\n    }\r\n\r\n    function unWrap(\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate,\r\n        string memory nativeCoinAddress\r\n    ) public notPaused returns (bool) {\r\n        address ethAccount = msg.sender;\r\n        uint256 cctokenAmount = amt;\r\n        uint256 nativeCoinAmount = calcUnWrapAmount(amt, fee, rate);\r\n        require(\r\n            cctoken.transferFrom(ethAccount, cctokenRepository, cctokenAmount),\r\n            \"transferFrom failed\"\r\n        );\r\n        uint256 seq = unWrapOrders.length;\r\n        unWrapOrders.push(\r\n            UnWrapOrder({\r\n                ethAccount: ethAccount,\r\n                nativeCoinAmount: nativeCoinAmount,\r\n                cctokenAmount: cctokenAmount,\r\n                nativeCoinAddress: nativeCoinAddress,\r\n                requestBlockNo: block.number,\r\n                status: OrderStatus.PENDING,\r\n                nativeTxId: \"\",\r\n                confirmedBlockNo: 0,\r\n                fee: fee,\r\n                rate: rate\r\n            })\r\n        );\r\n        emit UNWRAP_REQUEST(seq, ethAccount, nativeCoinAddress, amt, fee, rate);\r\n\r\n        return true;\r\n    }\r\n\r\n    event UNWRAP_REQUEST(\r\n        uint256 indexed seq,\r\n        address ethAccount,\r\n        string nativeCoinAddress,\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate\r\n    );\r\n\r\n    event UNWRAP_APPROVE(uint256 indexed seq);\r\n\r\n    function approveUnWrapOrder(\r\n        uint256 seq,\r\n        address ethAccount,\r\n        uint256 nativeCoinAmount,\r\n        uint256 cctokenAmount,\r\n        string memory nativeCoinAddress\r\n    ) public onlyOwner returns (bool) {\r\n        require(unWrapOrders.length > seq, \"invalid seq\");\r\n        UnWrapOrder memory order = unWrapOrders[seq];\r\n        require(order.status == OrderStatus.PENDING, \"status not pending\");\r\n        require(ethAccount == order.ethAccount, \"invalid param1\");\r\n        require(cctokenAmount == order.cctokenAmount, \"invalid param2\");\r\n        require(nativeCoinAmount == order.nativeCoinAmount, \"invalid param3\");\r\n        require(\r\n            stringEquals(nativeCoinAddress, order.nativeCoinAddress),\r\n            \"invalid param4\"\r\n        );\r\n\r\n        unWrapOrders[seq].status = OrderStatus.APPROVED;\r\n        emit UNWRAP_APPROVE(seq);\r\n        return true;\r\n    }\r\n\r\n    event UNWRAP_CANCEL(uint256 indexed seq);\r\n\r\n    function cancelUnWrapOrder(uint256 seq) public returns (bool) {\r\n        require(unWrapOrders.length > seq, \"invalid seq\");\r\n        UnWrapOrder memory order = unWrapOrders[seq];\r\n        require(msg.sender == order.ethAccount, \"invalid auth.\");\r\n        require(order.status == OrderStatus.PENDING, \"status not pending\");\r\n        unWrapOrders[seq].status = OrderStatus.CANCELED;\r\n\r\n        require(\r\n            cctoken.transferFrom(\r\n                cctokenRepository,\r\n                order.ethAccount,\r\n                order.cctokenAmount\r\n            ),\r\n            \"transferFrom failed\"\r\n        );\r\n\r\n        emit UNWRAP_CANCEL(seq);\r\n        return true;\r\n    }\r\n\r\n    function stringEquals(string memory s1, string memory s2)\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (keccak256(abi.encodePacked(s1)) ==\r\n            keccak256(abi.encodePacked(s2)));\r\n    }\r\n\r\n    event UNWRAP_FINISH(uint256 indexed seq, string nativeTxId);\r\n\r\n    function finishUnWrapOrder(uint256 seq, string memory nativeTxId)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(unWrapOrders.length > seq, \"invalid seq\");\r\n        UnWrapOrder memory order = unWrapOrders[seq];\r\n        require(order.status == OrderStatus.APPROVED, \"status not approved\");\r\n\r\n        unWrapOrders[seq].status = OrderStatus.FINISHED;\r\n        unWrapOrders[seq].nativeTxId = nativeTxId;\r\n        unWrapOrders[seq].confirmedBlockNo = block.number;\r\n        emit UNWRAP_FINISH(seq, nativeTxId);\r\n        return true;\r\n    }\r\n\r\n    address public pendingOwner;\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingOwner.\r\n     */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"no permission\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to set the pendingOwner address.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) override public onlyOwner {\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the pendingOwner address to finalize the transfer.\r\n     */\r\n    function claimOwnership() public onlyPendingOwner {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}"}}}