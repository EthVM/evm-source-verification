{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":2000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DeltaTimeStaking2021.sol":{"content":"// Sources flattened with hardhat v2.6.6 https://hardhat.org\r\n\r\n// File @animoca/ethereum-contracts-core/contracts/utils/types/AddressIsContract.sol@v1.1.3\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// Partially derived from OpenZeppelin:\r\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/406c83649bd6169fc1b578e08506d78f0873b276/contracts/utils/Address.sol\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @dev Upgrades the address type to check if it is a contract.\r\n */\r\nlibrary AddressIsContract {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core/contracts/utils/ERC20Wrapper.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20Wrapper\r\n * Wraps ERC20 functions to support non-standard implementations which do not return a bool value.\r\n * Calls to the wrapped functions revert only if they throw or if they return false.\r\n */\r\nlibrary ERC20Wrapper {\r\n    using AddressIsContract for address;\r\n\r\n    function wrappedTransfer(\r\n        IWrappedERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function wrappedTransferFrom(\r\n        IWrappedERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function wrappedApprove(\r\n        IWrappedERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function _callWithOptionalReturnData(IWrappedERC20 token, bytes memory callData) internal {\r\n        address target = address(token);\r\n        require(target.isContract(), \"ERC20Wrapper: non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = target.call(callData);\r\n        if (success) {\r\n            if (data.length != 0) {\r\n                require(abi.decode(data, (bool)), \"ERC20Wrapper: operation failed\");\r\n            }\r\n        } else {\r\n            // revert using a standard revert message\r\n            if (data.length == 0) {\r\n                revert(\"ERC20Wrapper: operation failed\");\r\n            }\r\n\r\n            // revert using the revert message coming from the call\r\n            assembly {\r\n                let size := mload(data)\r\n                revert(add(32, data), size)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IWrappedERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/SafeCast.sol@v3.4.0\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/math/SafeMath.sol@v3.4.0\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/math/SignedSafeMath.sol@v3.4.0\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two signed integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two signed integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core/contracts/introspection/IERC165.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets/contracts/token/ERC1155/interfaces/IERC1155TokenReceiver.sol@v3.0.1\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC1155 Multi Token Standard, Tokens Receiver.\r\n * Interface for any contract that wants to support transfers from ERC1155 asset contracts.\r\n * @dev See https://eips.ethereum.org/EIPS/eip-1155\r\n * @dev Note: The ERC-165 identifier for this interface is 0x4e2312e0.\r\n */\r\ninterface IERC1155TokenReceiver {\r\n    /**\r\n     * @notice Handle the receipt of a single ERC1155 token type.\r\n     * An ERC1155 contract MUST call this function on a recipient contract, at the end of a `safeTransferFrom` after the balance update.\r\n     * This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     *  (i.e. 0xf23a6e61) to accept the transfer.\r\n     * Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\r\n     * @param operator  The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from      The address which previously owned the token\r\n     * @param id        The ID of the token being transferred\r\n     * @param value     The amount of tokens being transferred\r\n     * @param data      Additional data with no specified format\r\n     * @return bytes4   `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @notice Handle the receipt of multiple ERC1155 token types.\r\n     * An ERC1155 contract MUST call this function on a recipient contract, at the end of a `safeBatchTransferFrom` after the balance updates.\r\n     * This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     *  (i.e. 0xbc197c81) if to accept the transfer(s).\r\n     * Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\r\n     * @param operator  The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from      The address which previously owned the token\r\n     * @param ids       An array containing ids of each token being transferred (order and length must match _values array)\r\n     * @param values    An array containing amounts of each token being transferred (order and length must match _ids array)\r\n     * @param data      Additional data with no specified format\r\n     * @return          `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets/contracts/token/ERC1155/ERC1155TokenReceiver.sol@v3.0.1\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC1155 Transfers Receiver Contract.\r\n * @dev The functions `onERC1155Received(address,address,uint256,uint256,bytes)`\r\n *  and `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)` need to be implemented by a child contract.\r\n */\r\nabstract contract ERC1155TokenReceiver is IERC165, IERC1155TokenReceiver {\r\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\r\n    bytes4 internal constant _ERC1155_RECEIVED = 0xf23a6e61;\r\n\r\n    // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\r\n    bytes4 internal constant _ERC1155_BATCH_RECEIVED = 0xbc197c81;\r\n\r\n    bytes4 internal constant _ERC1155_REJECTED = 0xffffffff;\r\n\r\n    //======================================================= ERC165 ========================================================//\r\n\r\n    /// @inheritdoc IERC165\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId || interfaceId == type(IERC1155TokenReceiver).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core/contracts/metatx/ManagedIdentity.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/*\r\n * Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner.\r\n */\r\nabstract contract ManagedIdentity {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core/contracts/access/IERC173.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC-173 Contract Ownership Standard\r\n * Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n */\r\ninterface IERC173 {\r\n    /**\r\n     * Event emited when ownership of a contract changes.\r\n     * @param previousOwner the previous owner.\r\n     * @param newOwner the new owner.\r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * Get the address of the owner\r\n     * @return The address of the owner.\r\n     */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n     * Set the address of the new owner of the contract\r\n     * Set newOwner to address(0) to renounce any ownership.\r\n     * @dev Emits an {OwnershipTransferred} event.\r\n     * @param newOwner The address of the new owner of the contract. Using the zero address means renouncing ownership.\r\n     */\r\n    function transferOwnership(address newOwner) external;\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core/contracts/access/Ownable.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is ManagedIdentity, IERC173 {\r\n    address internal _owner;\r\n\r\n    /**\r\n     * Initializes the contract, setting the deployer as the initial owner.\r\n     * @dev Emits an {IERC173-OwnershipTransferred(address,address)} event.\r\n     */\r\n    constructor(address owner_) {\r\n        _owner = owner_;\r\n        emit OwnershipTransferred(address(0), owner_);\r\n    }\r\n\r\n    /**\r\n     * Gets the address of the current contract owner.\r\n     */\r\n    function owner() public view virtual override returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * See {IERC173-transferOwnership(address)}\r\n     * @dev Reverts if the sender is not the current contract owner.\r\n     * @param newOwner the address of the new owner. Use the zero address to renounce the ownership.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual override {\r\n        _requireOwnership(_msgSender());\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if `account` is not the contract owner.\r\n     * @param account the account to test.\r\n     */\r\n    function _requireOwnership(address account) internal virtual {\r\n        require(account == this.owner(), \"Ownable: not the owner\");\r\n    }\r\n}\r\n\r\n\r\n// File contracts/staking/DeltaTimeStaking2021.sol\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Delta Time Staking 2021\r\n * Distribute REVV rewards over discrete-time schedules for the staking of Car NFTs.\r\n * This contract is designed on a self-service model, where users will stake NFTs, unstake NFTs and claim rewards through their own transactions only.\r\n */\r\ncontract DeltaTimeStaking2021 is ERC1155TokenReceiver, Ownable {\r\n    using ERC20Wrapper for IWrappedERC20;\r\n    using SafeCast for uint256;\r\n    using SafeMath for uint256;\r\n    using SignedSafeMath for int256;\r\n\r\n    event RewardsAdded(uint256 startPeriod, uint256 endPeriod, uint256 rewardsPerCycle);\r\n\r\n    event Started();\r\n\r\n    event NftStaked(address staker, uint256 cycle, uint256 tokenId, uint256 weight);\r\n\r\n    event NftUnstaked(address staker, uint256 cycle, uint256 tokenId, uint256 weight);\r\n\r\n    event RewardsClaimed(address staker, uint256 cycle, uint256 startPeriod, uint256 periods, uint256 amount);\r\n\r\n    event HistoriesUpdated(address staker, uint256 startCycle, uint256 stakerStake, uint256 globalStake);\r\n\r\n    event Disabled();\r\n\r\n    /**\r\n     * Used to represent the current staking status of an NFT.\r\n     * Optimised for use in storage.\r\n     */\r\n    struct TokenInfo {\r\n        address owner;\r\n        uint64 weight;\r\n        uint16 depositCycle;\r\n        uint16 withdrawCycle;\r\n    }\r\n\r\n    /**\r\n     * Used as a historical record of change of stake.\r\n     * Stake represents an aggregation of staked token weights.\r\n     * Optimised for use in storage.\r\n     */\r\n    struct Snapshot {\r\n        uint128 stake;\r\n        uint128 startCycle;\r\n    }\r\n\r\n    /**\r\n     * Used to represent a staker's information about the next claim.\r\n     * Optimised for use in storage.\r\n     */\r\n    struct NextClaim {\r\n        uint16 period;\r\n        uint64 globalSnapshotIndex;\r\n        uint64 stakerSnapshotIndex;\r\n    }\r\n\r\n    /**\r\n     * Used as a container to hold result values from computing rewards.\r\n     */\r\n    struct ComputedClaim {\r\n        uint16 startPeriod;\r\n        uint16 periods;\r\n        uint256 amount;\r\n    }\r\n\r\n    bool public enabled = true;\r\n\r\n    uint256 public totalRewardsPool;\r\n\r\n    uint256 public startTimestamp;\r\n\r\n    IWrappedERC20 public immutable rewardsTokenContract;\r\n    IWhitelistedNftContract public immutable whitelistedNftContract;\r\n\r\n    uint32 public immutable cycleLengthInSeconds;\r\n    uint16 public immutable periodLengthInCycles;\r\n\r\n    Snapshot[] public globalHistory;\r\n\r\n    mapping(uint256 => uint64) public weightsByRarity;\r\n\r\n    /* staker => snapshots*/\r\n    mapping(address => Snapshot[]) public stakerHistories;\r\n\r\n    /* staker => next claim */\r\n    mapping(address => NextClaim) public nextClaims;\r\n\r\n    /* tokenId => token info */\r\n    mapping(uint256 => TokenInfo) public tokenInfos;\r\n\r\n    /* period => rewardsPerCycle */\r\n    mapping(uint256 => uint256) public rewardsSchedule;\r\n\r\n    modifier hasStarted() {\r\n        require(startTimestamp != 0, \"NftStaking: staking not started\");\r\n        _;\r\n    }\r\n\r\n    modifier hasNotStarted() {\r\n        require(startTimestamp == 0, \"NftStaking: staking has started\");\r\n        _;\r\n    }\r\n\r\n    modifier isEnabled() {\r\n        // solhint-disable-next-line reason-string\r\n        require(enabled, \"NftStaking: contract is not enabled\");\r\n        _;\r\n    }\r\n\r\n    modifier isNotEnabled() {\r\n        require(!enabled, \"NftStaking: contract is enabled\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @dev Reverts if the period length value is zero.\r\n     * @dev Reverts if the cycle length value is zero.\r\n     * @dev Warning: cycles and periods need to be calibrated carefully.\r\n     *  Small values will increase computation load while estimating and claiming rewards.\r\n     *  Big values will increase the time to wait before a new period becomes claimable.\r\n     * @param cycleLengthInSeconds_ The length of a cycle, in seconds.\r\n     * @param periodLengthInCycles_ The length of a period, in cycles.\r\n     * @param whitelistedNftContract_ The ERC1155-compliant (optional ERC721-compliance) contract from which staking is accepted.\r\n     * @param rewardsTokenContract_ The ERC20-based token used as staking rewards.\r\n     */\r\n    constructor(\r\n        uint32 cycleLengthInSeconds_,\r\n        uint16 periodLengthInCycles_,\r\n        IWhitelistedNftContract whitelistedNftContract_,\r\n        IWrappedERC20 rewardsTokenContract_,\r\n        uint256[] memory rarities,\r\n        uint64[] memory weights\r\n    ) Ownable(msg.sender) {\r\n        require(rarities.length == weights.length, \"NftStaking: wrong arguments\");\r\n\r\n        // solhint-disable-next-line reason-string\r\n        require(cycleLengthInSeconds_ >= 1 minutes, \"NftStaking: invalid cycle length\");\r\n        // solhint-disable-next-line reason-string\r\n        require(periodLengthInCycles_ >= 2, \"NftStaking: invalid period length\");\r\n\r\n        cycleLengthInSeconds = cycleLengthInSeconds_;\r\n        periodLengthInCycles = periodLengthInCycles_;\r\n        whitelistedNftContract = whitelistedNftContract_;\r\n        rewardsTokenContract = rewardsTokenContract_;\r\n\r\n        for (uint256 i = 0; i < rarities.length; ++i) {\r\n            weightsByRarity[rarities[i]] = weights[i];\r\n        }\r\n    }\r\n\r\n    /*                                            Admin Public Functions                                            */\r\n\r\n    /**\r\n     * Adds `rewardsPerCycle` reward amount for the period range from `startPeriod` to `endPeriod`, inclusive, to the rewards schedule.\r\n     * The necessary amount of reward tokens is transferred to the contract. Cannot be used for past periods.\r\n     * Can only be used to add rewards and not to remove them.\r\n     * @dev Reverts if not called by the owner.\r\n     * @dev Reverts if the start period is zero.\r\n     * @dev Reverts if the end period precedes the start period.\r\n     * @dev Reverts if attempting to add rewards for a period earlier than the current, after staking has started.\r\n     * @dev Reverts if the reward tokens transfer fails.\r\n     * @dev The rewards token contract emits an ERC20 Transfer event for the reward tokens transfer.\r\n     * @dev Emits a RewardsAdded event.\r\n     * @param startPeriod The starting period (inclusive).\r\n     * @param endPeriod The ending period (inclusive).\r\n     * @param rewardsPerCycle The reward amount to add for each cycle within range.\r\n     */\r\n    function addRewardsForPeriods(\r\n        uint16 startPeriod,\r\n        uint16 endPeriod,\r\n        uint256 rewardsPerCycle\r\n    ) external {\r\n        _requireOwnership(msg.sender);\r\n        require(startPeriod != 0 && startPeriod <= endPeriod, \"NftStaking: wrong period range\");\r\n\r\n        uint16 periodLengthInCycles_ = periodLengthInCycles;\r\n\r\n        if (startTimestamp != 0) {\r\n            // solhint-disable-next-line reason-string\r\n            require(startPeriod >= _getCurrentPeriod(periodLengthInCycles_), \"NftStaking: already committed reward schedule\");\r\n        }\r\n\r\n        for (uint256 period = startPeriod; period <= endPeriod; ++period) {\r\n            rewardsSchedule[period] = rewardsSchedule[period].add(rewardsPerCycle);\r\n        }\r\n\r\n        uint256 addedRewards = rewardsPerCycle.mul(periodLengthInCycles_).mul(endPeriod - startPeriod + 1);\r\n\r\n        totalRewardsPool = totalRewardsPool.add(addedRewards);\r\n\r\n        rewardsTokenContract.wrappedTransferFrom(msg.sender, address(this), addedRewards);\r\n\r\n        emit RewardsAdded(startPeriod, endPeriod, rewardsPerCycle);\r\n    }\r\n\r\n    /**\r\n     * Starts the first cycle of staking, enabling users to stake NFTs.\r\n     * @dev Reverts if not called by the owner.\r\n     * @dev Reverts if the staking has already started.\r\n     * @dev Emits a Started event.\r\n     */\r\n    function start() public hasNotStarted {\r\n        _requireOwnership(msg.sender);\r\n        startTimestamp = block.timestamp;\r\n        emit Started();\r\n    }\r\n\r\n    /**\r\n     * Permanently disables all staking and claiming.\r\n     * This is an emergency recovery feature which is NOT part of the normal contract operation.\r\n     * @dev Reverts if not called by the owner.\r\n     * @dev Emits a Disabled event.\r\n     */\r\n    function disable() public {\r\n        _requireOwnership(msg.sender);\r\n        enabled = false;\r\n        emit Disabled();\r\n    }\r\n\r\n    /**\r\n     * Withdraws a specified amount of reward tokens from the contract it has been disabled.\r\n     * @dev Reverts if not called by the owner.\r\n     * @dev Reverts if the contract has not been disabled.\r\n     * @dev Reverts if the reward tokens transfer fails.\r\n     * @dev The rewards token contract emits an ERC20 Transfer event for the reward tokens transfer.\r\n     * @param amount The amount to withdraw.\r\n     */\r\n    function withdrawRewardsPool(uint256 amount) public isNotEnabled {\r\n        _requireOwnership(msg.sender);\r\n        rewardsTokenContract.wrappedTransfer(msg.sender, amount);\r\n    }\r\n\r\n    /*                                             ERC1155TokenReceiver                                             */\r\n\r\n    function onERC1155Received(\r\n        address, /*operator*/\r\n        address from,\r\n        uint256 id,\r\n        uint256, /*value*/\r\n        bytes calldata /*data*/\r\n    ) external virtual override returns (bytes4) {\r\n        _stakeNft(id, from);\r\n        return _ERC1155_RECEIVED;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address, /*operator*/\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata, /*values*/\r\n        bytes calldata /*data*/\r\n    ) external virtual override returns (bytes4) {\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            _stakeNft(ids[i], from);\r\n        }\r\n        return _ERC1155_BATCH_RECEIVED;\r\n    }\r\n\r\n    /*                                            Staking Public Functions                                            */\r\n\r\n    /**\r\n     * Unstakes a deposited NFT from the contract and updates the histories accordingly.\r\n     * The NFT's weight will not count for the current cycle.\r\n     * @dev Reverts if the caller is not the original owner of the NFT.\r\n     * @dev While the contract is enabled, reverts if the NFT is still frozen.\r\n     * @dev Reverts if the NFT transfer back to the original owner fails.\r\n     * @dev If ERC1155 safe transfers are supported by the receiver wallet,\r\n     *  the whitelisted NFT contract emits an ERC1155 TransferSingle event for the NFT transfer back to the staker.\r\n     * @dev If ERC1155 safe transfers are not supported by the receiver wallet,\r\n     *  the whitelisted NFT contract emits an ERC721 Transfer event for the NFT transfer back to the staker.\r\n     * @dev While the contract is enabled, emits a HistoriesUpdated event.\r\n     * @dev Emits a NftUnstaked event.\r\n     * @param tokenId The token identifier, referencing the NFT being unstaked.\r\n     */\r\n    function unstakeNft(uint256 tokenId) external {\r\n        TokenInfo memory tokenInfo = tokenInfos[tokenId];\r\n\r\n        // solhint-disable-next-line reason-string\r\n        require(tokenInfo.owner == msg.sender, \"NftStaking: token not staked or incorrect token owner\");\r\n\r\n        uint16 currentCycle = _getCycle(block.timestamp);\r\n\r\n        if (enabled) {\r\n            // ensure that at least an entire cycle has elapsed before unstaking the token to avoid\r\n            // an exploit where a full cycle would be claimable if staking just before the end\r\n            // of a cycle and unstaking right after the start of the new cycle\r\n            require(currentCycle - tokenInfo.depositCycle >= 2, \"NftStaking: token still frozen\");\r\n\r\n            _updateHistories(msg.sender, -int128(tokenInfo.weight), currentCycle);\r\n\r\n            // clear the token owner to ensure it cannot be unstaked again without being re-staked\r\n            tokenInfo.owner = address(0);\r\n\r\n            // set the withdrawal cycle to ensure it cannot be re-staked during the same cycle\r\n            tokenInfo.withdrawCycle = currentCycle;\r\n\r\n            tokenInfos[tokenId] = tokenInfo;\r\n        }\r\n\r\n        whitelistedNftContract.transferFrom(address(this), msg.sender, tokenId);\r\n\r\n        emit NftUnstaked(msg.sender, currentCycle, tokenId, tokenInfo.weight);\r\n    }\r\n\r\n    /**\r\n     * Estimates the claimable rewards for the specified maximum number of past periods, starting at the next claimable period.\r\n     * Estimations can be done only for periods which have already ended.\r\n     * The maximum number of periods to claim can be calibrated to chunk down claims in several transactions to accomodate gas constraints.\r\n     * @param maxPeriods The maximum number of periods to calculate for.\r\n     * @return startPeriod The first period on which the computation starts.\r\n     * @return periods The number of periods computed for.\r\n     * @return amount The total claimable rewards.\r\n     */\r\n    function estimateRewards(uint16 maxPeriods)\r\n        external\r\n        view\r\n        isEnabled\r\n        hasStarted\r\n        returns (\r\n            uint16 startPeriod,\r\n            uint16 periods,\r\n            uint256 amount\r\n        )\r\n    {\r\n        (ComputedClaim memory claim, ) = _computeRewards(msg.sender, maxPeriods);\r\n        startPeriod = claim.startPeriod;\r\n        periods = claim.periods;\r\n        amount = claim.amount;\r\n    }\r\n\r\n    /**\r\n     * Claims the claimable rewards for the specified maximum number of past periods, starting at the next claimable period.\r\n     * Claims can be done only for periods which have already ended.\r\n     * The maximum number of periods to claim can be calibrated to chunk down claims in several transactions to accomodate gas constraints.\r\n     * @dev Reverts if the reward tokens transfer fails.\r\n     * @dev The rewards token contract emits an ERC20 Transfer event for the reward tokens transfer.\r\n     * @dev Emits a RewardsClaimed event.\r\n     * @param maxPeriods The maximum number of periods to claim for.\r\n     */\r\n    function claimRewards(uint16 maxPeriods) external isEnabled hasStarted {\r\n        NextClaim memory nextClaim = nextClaims[msg.sender];\r\n\r\n        (ComputedClaim memory claim, NextClaim memory newNextClaim) = _computeRewards(msg.sender, maxPeriods);\r\n\r\n        // free up memory on already processed staker snapshots\r\n        Snapshot[] storage stakerHistory = stakerHistories[msg.sender];\r\n        while (nextClaim.stakerSnapshotIndex < newNextClaim.stakerSnapshotIndex) {\r\n            delete stakerHistory[nextClaim.stakerSnapshotIndex++];\r\n        }\r\n\r\n        if (claim.periods == 0) {\r\n            return;\r\n        }\r\n\r\n        if (nextClaims[msg.sender].period == 0) {\r\n            return;\r\n        }\r\n\r\n        Snapshot memory lastStakerSnapshot = stakerHistory[stakerHistory.length - 1];\r\n\r\n        uint256 lastClaimedCycle = (claim.startPeriod + claim.periods - 1) * periodLengthInCycles;\r\n        if (\r\n            lastClaimedCycle >= lastStakerSnapshot.startCycle && // the claim reached the last staker snapshot\r\n            lastStakerSnapshot.stake == 0 // and nothing is staked in the last staker snapshot\r\n        ) {\r\n            // re-init the next claim\r\n            delete nextClaims[msg.sender];\r\n        } else {\r\n            nextClaims[msg.sender] = newNextClaim;\r\n        }\r\n\r\n        if (claim.amount != 0) {\r\n            rewardsTokenContract.wrappedTransfer(msg.sender, claim.amount);\r\n        }\r\n\r\n        emit RewardsClaimed(msg.sender, _getCycle(block.timestamp), claim.startPeriod, claim.periods, claim.amount);\r\n    }\r\n\r\n    /*                                            Utility Public Functions                                            */\r\n\r\n    /**\r\n     * Retrieves the current cycle (index-1 based).\r\n     * @return The current cycle (index-1 based).\r\n     */\r\n    function getCurrentCycle() external view returns (uint16) {\r\n        return _getCycle(block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the current period (index-1 based).\r\n     * @return The current period (index-1 based).\r\n     */\r\n    function getCurrentPeriod() external view returns (uint16) {\r\n        return _getCurrentPeriod(periodLengthInCycles);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the last global snapshot index, if any.\r\n     * @dev Reverts if the global history is empty.\r\n     * @return The last global snapshot index.\r\n     */\r\n    function lastGlobalSnapshotIndex() external view returns (uint256) {\r\n        uint256 length = globalHistory.length;\r\n        // solhint-disable-next-line reason-string\r\n        require(length != 0, \"NftStaking: empty global history\");\r\n        return length - 1;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the last staker snapshot index, if any.\r\n     * @dev Reverts if the staker history is empty.\r\n     * @return The last staker snapshot index.\r\n     */\r\n    function lastStakerSnapshotIndex(address staker) external view returns (uint256) {\r\n        uint256 length = stakerHistories[staker].length;\r\n        // solhint-disable-next-line reason-string\r\n        require(length != 0, \"NftStaking: empty staker history\");\r\n        return length - 1;\r\n    }\r\n\r\n    /*                                            Staking Internal Functions                                            */\r\n\r\n    /**\r\n     * Stakes the NFT received by the contract for its owner. The NFT's weight will count for the current cycle.\r\n     * @dev Reverts if the caller is not the whitelisted NFT contract.\r\n     * @dev Emits an HistoriesUpdated event.\r\n     * @dev Emits an NftStaked event.\r\n     * @param tokenId Identifier of the staked NFT.\r\n     * @param tokenOwner Owner of the staked NFT.\r\n     */\r\n    function _stakeNft(uint256 tokenId, address tokenOwner) internal isEnabled hasStarted {\r\n        // solhint-disable-next-line reason-string\r\n        require(address(whitelistedNftContract) == msg.sender, \"NftStaking: contract not whitelisted\");\r\n\r\n        uint64 weight = _validateAndGetNftWeight(tokenId);\r\n\r\n        uint16 periodLengthInCycles_ = periodLengthInCycles;\r\n        uint16 currentCycle = _getCycle(block.timestamp);\r\n\r\n        _updateHistories(tokenOwner, int128(weight), currentCycle);\r\n\r\n        // initialise the next claim if it was the first stake for this staker or if\r\n        // the next claim was re-initialised (ie. rewards were claimed until the last\r\n        // staker snapshot and the last staker snapshot has no stake)\r\n        if (nextClaims[tokenOwner].period == 0) {\r\n            uint16 currentPeriod = _getPeriod(currentCycle, periodLengthInCycles_);\r\n            nextClaims[tokenOwner] = NextClaim(currentPeriod, uint64(globalHistory.length - 1), 0);\r\n        }\r\n\r\n        uint16 withdrawCycle = tokenInfos[tokenId].withdrawCycle;\r\n        // solhint-disable-next-line reason-string\r\n        require(currentCycle != withdrawCycle, \"NftStaking: unstaked token cooldown\");\r\n\r\n        // set the staked token's info\r\n        tokenInfos[tokenId] = TokenInfo(tokenOwner, weight, currentCycle, 0);\r\n\r\n        emit NftStaked(tokenOwner, currentCycle, tokenId, weight);\r\n    }\r\n\r\n    /**\r\n     * Calculates the amount of rewards for a staker over a capped number of periods.\r\n     * @dev Processes until the specified maximum number of periods to claim is reached,\r\n     *  or the last computable period is reached, whichever occurs first.\r\n     * @param staker The staker for whom the rewards will be computed.\r\n     * @param maxPeriods Maximum number of periods over which to compute the rewards.\r\n     * @return claim the result of computation\r\n     * @return nextClaim the next claim which can be used to update the staker's state\r\n     */\r\n    // solhint-disable-next-line code-complexity\r\n    function _computeRewards(address staker, uint16 maxPeriods) internal view returns (ComputedClaim memory claim, NextClaim memory nextClaim) {\r\n        // computing 0 periods\r\n        if (maxPeriods == 0) {\r\n            return (claim, nextClaim);\r\n        }\r\n\r\n        // the history is empty\r\n        if (globalHistory.length == 0) {\r\n            return (claim, nextClaim);\r\n        }\r\n\r\n        nextClaim = nextClaims[staker];\r\n        claim.startPeriod = nextClaim.period;\r\n\r\n        // nothing has been staked yet\r\n        if (claim.startPeriod == 0) {\r\n            return (claim, nextClaim);\r\n        }\r\n\r\n        uint16 periodLengthInCycles_ = periodLengthInCycles;\r\n        uint16 endClaimPeriod = _getCurrentPeriod(periodLengthInCycles_);\r\n\r\n        // current period is not claimable\r\n        if (nextClaim.period == endClaimPeriod) {\r\n            return (claim, nextClaim);\r\n        }\r\n\r\n        // retrieve the next snapshots if they exist\r\n        Snapshot[] memory stakerHistory = stakerHistories[staker];\r\n\r\n        Snapshot memory globalSnapshot = globalHistory[nextClaim.globalSnapshotIndex];\r\n        Snapshot memory stakerSnapshot = stakerHistory[nextClaim.stakerSnapshotIndex];\r\n        Snapshot memory nextGlobalSnapshot;\r\n        Snapshot memory nextStakerSnapshot;\r\n\r\n        if (nextClaim.globalSnapshotIndex != globalHistory.length - 1) {\r\n            nextGlobalSnapshot = globalHistory[nextClaim.globalSnapshotIndex + 1];\r\n        }\r\n        if (nextClaim.stakerSnapshotIndex != stakerHistory.length - 1) {\r\n            nextStakerSnapshot = stakerHistory[nextClaim.stakerSnapshotIndex + 1];\r\n        }\r\n\r\n        // excludes the current period\r\n        claim.periods = endClaimPeriod - nextClaim.period;\r\n\r\n        if (maxPeriods < claim.periods) {\r\n            claim.periods = maxPeriods;\r\n        }\r\n\r\n        // re-calibrate the end claim period based on the actual number of\r\n        // periods to claim. nextClaim.period will be updated to this value\r\n        // after exiting the loop\r\n        endClaimPeriod = nextClaim.period + claim.periods;\r\n\r\n        // iterate over periods\r\n        while (nextClaim.period != endClaimPeriod) {\r\n            uint16 nextPeriodStartCycle = nextClaim.period * periodLengthInCycles_ + 1;\r\n            uint256 rewardPerCycle = rewardsSchedule[nextClaim.period];\r\n            uint256 startCycle = nextPeriodStartCycle - periodLengthInCycles_;\r\n            uint256 endCycle = 0;\r\n\r\n            // iterate over global snapshots\r\n            while (endCycle != nextPeriodStartCycle) {\r\n                // find the range-to-claim starting cycle, where the current\r\n                // global snapshot, the current staker snapshot, and the current\r\n                // period overlap\r\n                if (globalSnapshot.startCycle > startCycle) {\r\n                    startCycle = globalSnapshot.startCycle;\r\n                }\r\n                if (stakerSnapshot.startCycle > startCycle) {\r\n                    startCycle = stakerSnapshot.startCycle;\r\n                }\r\n\r\n                // find the range-to-claim ending cycle, where the current\r\n                // global snapshot, the current staker snapshot, and the current\r\n                // period no longer overlap. The end cycle is exclusive of the\r\n                // range-to-claim and represents the beginning cycle of the next\r\n                // range-to-claim\r\n                endCycle = nextPeriodStartCycle;\r\n                if ((nextGlobalSnapshot.startCycle != 0) && (nextGlobalSnapshot.startCycle < endCycle)) {\r\n                    endCycle = nextGlobalSnapshot.startCycle;\r\n                }\r\n\r\n                // only calculate and update the claimable rewards if there is\r\n                // something to calculate with\r\n                if ((globalSnapshot.stake != 0) && (stakerSnapshot.stake != 0) && (rewardPerCycle != 0)) {\r\n                    uint256 snapshotReward = (endCycle - startCycle).mul(rewardPerCycle).mul(stakerSnapshot.stake);\r\n                    snapshotReward /= globalSnapshot.stake;\r\n\r\n                    claim.amount = claim.amount.add(snapshotReward);\r\n                }\r\n\r\n                // advance the current global snapshot to the next (if any)\r\n                // if its cycle range has been fully processed and if the next\r\n                // snapshot starts at most on next period first cycle\r\n                if (nextGlobalSnapshot.startCycle == endCycle) {\r\n                    globalSnapshot = nextGlobalSnapshot;\r\n                    ++nextClaim.globalSnapshotIndex;\r\n\r\n                    if (nextClaim.globalSnapshotIndex != globalHistory.length - 1) {\r\n                        nextGlobalSnapshot = globalHistory[nextClaim.globalSnapshotIndex + 1];\r\n                    } else {\r\n                        nextGlobalSnapshot = Snapshot(0, 0);\r\n                    }\r\n                }\r\n\r\n                // advance the current staker snapshot to the next (if any)\r\n                // if its cycle range has been fully processed and if the next\r\n                // snapshot starts at most on next period first cycle\r\n                if (nextStakerSnapshot.startCycle == endCycle) {\r\n                    stakerSnapshot = nextStakerSnapshot;\r\n                    ++nextClaim.stakerSnapshotIndex;\r\n\r\n                    if (nextClaim.stakerSnapshotIndex != stakerHistory.length - 1) {\r\n                        nextStakerSnapshot = stakerHistory[nextClaim.stakerSnapshotIndex + 1];\r\n                    } else {\r\n                        nextStakerSnapshot = Snapshot(0, 0);\r\n                    }\r\n                }\r\n            }\r\n\r\n            ++nextClaim.period;\r\n        }\r\n\r\n        return (claim, nextClaim);\r\n    }\r\n\r\n    /**\r\n     * Updates the global and staker histories at the current cycle with a new difference in stake.\r\n     * @dev Emits a HistoriesUpdated event.\r\n     * @param staker The staker who is updating the history.\r\n     * @param stakeDelta The difference to apply to the current stake.\r\n     * @param currentCycle The current cycle.\r\n     */\r\n    function _updateHistories(\r\n        address staker,\r\n        int128 stakeDelta,\r\n        uint16 currentCycle\r\n    ) internal {\r\n        uint256 stakerSnapshotIndex = _updateHistory(stakerHistories[staker], stakeDelta, currentCycle);\r\n        uint256 globalSnapshotIndex = _updateHistory(globalHistory, stakeDelta, currentCycle);\r\n\r\n        emit HistoriesUpdated(staker, currentCycle, stakerHistories[staker][stakerSnapshotIndex].stake, globalHistory[globalSnapshotIndex].stake);\r\n    }\r\n\r\n    /**\r\n     * Updates the history at the current cycle with a new difference in stake.\r\n     * @dev It will update the latest snapshot if it starts at the current cycle, otherwise will create a new snapshot with the updated stake.\r\n     * @param history The history to update.\r\n     * @param stakeDelta The difference to apply to the current stake.\r\n     * @param currentCycle The current cycle.\r\n     * @return snapshotIndex Index of the snapshot that was updated or created (i.e. the latest snapshot index).\r\n     */\r\n    function _updateHistory(\r\n        Snapshot[] storage history,\r\n        int128 stakeDelta,\r\n        uint16 currentCycle\r\n    ) internal returns (uint256 snapshotIndex) {\r\n        uint256 historyLength = history.length;\r\n        uint128 snapshotStake;\r\n\r\n        if (historyLength != 0) {\r\n            // there is an existing snapshot\r\n            snapshotIndex = historyLength - 1;\r\n            Snapshot storage sSnapshot = history[snapshotIndex];\r\n            snapshotStake = uint256(int256(sSnapshot.stake).add(stakeDelta)).toUint128();\r\n\r\n            if (sSnapshot.startCycle == currentCycle) {\r\n                // update the snapshot if it starts on the current cycle\r\n                sSnapshot.stake = snapshotStake;\r\n                return snapshotIndex;\r\n            }\r\n\r\n            // update the snapshot index (as a reflection that a new latest\r\n            // snapshot will be added to the history), if there was already an\r\n            // existing snapshot\r\n            snapshotIndex += 1;\r\n        } else {\r\n            // the snapshot index (as a reflection that a new latest snapshot\r\n            // will be added to the history) should already be initialized\r\n            // correctly to the default value 0\r\n\r\n            // the stake delta will not be negative, if we have no history, as\r\n            // that would indicate that we are unstaking without having staked\r\n            // anything first\r\n            snapshotStake = uint128(stakeDelta);\r\n        }\r\n\r\n        Snapshot memory mSnapshot;\r\n        mSnapshot.stake = snapshotStake;\r\n        mSnapshot.startCycle = currentCycle;\r\n\r\n        // add a new snapshot in the history\r\n        history.push(mSnapshot);\r\n    }\r\n\r\n    /*                                           Utility Internal Functions                                           */\r\n\r\n    /**\r\n     * Retrieves the cycle (index-1 based) at the specified timestamp.\r\n     * @param timestamp The timestamp for which the cycle is derived from.\r\n     * @return The cycle (index-1 based) at the specified timestamp, or zero if the contract is not started yet.\r\n     */\r\n    function _getCycle(uint256 timestamp) internal view returns (uint16) {\r\n        uint256 startTimestamp_ = startTimestamp;\r\n        if (startTimestamp_ == 0) return 0;\r\n        return (((timestamp - startTimestamp_) / uint256(cycleLengthInSeconds)) + 1).toUint16();\r\n    }\r\n\r\n    /**\r\n     * Retrieves the period (index-1 based) for the specified cycle and period length.\r\n     * @param cycle The cycle within the period to retrieve.\r\n     * @param periodLengthInCycles_ Length of a period, in cycles.\r\n     * @return The period (index-1 based) for the specified cycle and period length, 0r zero if `cycle` is zero.\r\n     */\r\n    function _getPeriod(uint16 cycle, uint16 periodLengthInCycles_) internal pure returns (uint16) {\r\n        if (cycle == 0) {\r\n            return 0;\r\n        }\r\n        return (cycle - 1) / periodLengthInCycles_ + 1;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the current period (index-1 based).\r\n     * @param periodLengthInCycles_ Length of a period, in cycles.\r\n     * @return The current period (index-1 based).\r\n     */\r\n    function _getCurrentPeriod(uint16 periodLengthInCycles_) internal view returns (uint16) {\r\n        return _getPeriod(_getCycle(block.timestamp), periodLengthInCycles_);\r\n    }\r\n\r\n    /*                                                Internal Hooks                                                */\r\n\r\n    /**\r\n     * Verifies that the token is eligible and returns its associated weight.\r\n     * @dev Reverts if the token is not a 2019 or 2020 Car NFT.\r\n     * @param nftId uint256 token identifier of the NFT.\r\n     * @return uint64 the weight of the NFT.\r\n     */\r\n    function _validateAndGetNftWeight(uint256 nftId) internal view returns (uint64) {\r\n        // Ids bits layout specification:\r\n        // https://github.com/animocabrands/f1dt-core_metadata/blob/v0.1.1/src/constants.js\r\n        uint256 nonFungible = (nftId >> 255) & 1;\r\n        uint256 tokenType = (nftId >> 240) & 0xFF;\r\n        uint256 tokenSeason = (nftId >> 224) & 0xFF;\r\n        uint256 tokenRarity = (nftId >> 176) & 0xFF;\r\n\r\n        // For interpretation of values, refer to https://github.com/animocabrands/f1dt-core_metadata/blob/version-1.0.3/src/mappings/\r\n        // Types: https://github.com/animocabrands/f1dt-core_metadata/blob/version-1.0.3/src/mappings/CommonAttributes/Type/Types.js\r\n        // Seasons: https://github.com/animocabrands/f1dt-core_metadata/blob/version-1.0.3/src/mappings/CommonAttributes/Season/Seasons.js\r\n        // Rarities: https://github.com/animocabrands/f1dt-core_metadata/blob/version-1.0.3/src/mappings/CommonAttributes/Rarity/Rarities.js\r\n        require(nonFungible == 1 && tokenType == 1 && (tokenSeason == 2 || tokenSeason == 3), \"NftStaking: wrong token\");\r\n\r\n        return weightsByRarity[tokenRarity];\r\n    }\r\n}\r\n\r\ninterface IWhitelistedNftContract {\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n}"}}}