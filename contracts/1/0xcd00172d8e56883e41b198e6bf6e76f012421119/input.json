{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"whitelistOracle.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity <=0.7.4;\n\nabstract contract ReentrancyGuard {\n\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\nlibrary Math {\n    \n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\n\t\treturn c;\n\t}\n\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"multiplication overflow\");\n\n\t\treturn c;\n\t}\n\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b > 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n}\n\ninterface IStaking{\n    \n    function stake(uint256 amount,uint256 tenure) external returns(bool);\n    \n    function claim(uint256 stakeId) external returns(bool);\n    \n    function calculateClaimAmount(address user,uint256 stakeId) external returns(uint256,uint256);\n                \n    function revokeOwnership(address _newOwner) external returns(bool);\n\n    function changeROI(uint256 _newROI) external returns(bool);\n\n    function updateEdgexContract(address _contractAddress) external returns(bool);\n}\n\ninterface IERC20{\n\t\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n}\n\ncontract EdgeStakingV1 is ReentrancyGuard {\n\n    uint256 public currentROI; // ROI per second in 10^13 precision\n    address public edgexContract; // edge196 token contract\n    address public admin;\n    \n    struct Stake{\n        uint256 amount;\n        uint256 maturesAt;\n        uint256 createdAt;\n        uint256 roiAtStake;\n        bool isClaimed;\n        uint256 interest;\n    }\n\n    mapping(address => uint256) public totalStakingContracts;\n    mapping(address => mapping(uint256 => Stake)) public stakeContract;\n\n    event RevokeOwnership(address indexed newOwner);\n    event ChangeROI(uint256 newROI);\n\n    modifier onlyAdmin(){\n        require(msg.sender == admin,\"Caller not admin\");\n        _;\n    }\n\n    modifier isZero(address _address){\n        require(_address != address(0),\"Invalid Address\");\n        _;\n    }\n\n    constructor(address _edgexContract,uint256 _newROI, address _admin){\n        edgexContract = _edgexContract;\n        currentROI = _newROI;\n        admin = _admin;\n    }\n\n    function stake(uint256 _amount, uint256 _tenureInDays) public nonReentrant returns(bool) {\n        require(\n            IERC20(edgexContract)\n            .allowance(msg.sender,address(this)) >= _amount, \"Allowance Exceeded\"\n            );\n        require(\n            IERC20(edgexContract)\n            .balanceOf(msg.sender) >= _amount, \"Insufficient Balance\"\n            );\n        updateStakeData(_amount,_tenureInDays,msg.sender);\n        totalStakingContracts[msg.sender] = Math.add(totalStakingContracts[msg.sender],1);\n        IERC20(edgexContract)\n        .transferFrom(msg.sender,address(this),_amount);\n        return true;\n        }\n\n    function updateStakeData(uint256 _amount, uint256 _tenureInDays, address _user) internal{\n        uint256 totalContracts = Math.add(totalStakingContracts[_user],1);         \n        Stake storage sc = stakeContract[_user][totalContracts];\n        sc.amount = _amount;\n        sc.createdAt = block.timestamp;\n        uint256 maturityInSeconds = Math.mul(_tenureInDays,1 minutes);\n        sc.maturesAt = Math.add(block.timestamp,maturityInSeconds);\n        sc.roiAtStake = currentROI;\n    }\n\n    function claim(uint256 _stakingContractId) public nonReentrant returns(bool){\n        Stake storage sc = stakeContract[msg.sender][_stakingContractId];\n        require(\n            sc.maturesAt <= block.timestamp,\n            \"Not Yet Matured\"\n        );\n        require(\n            !sc.isClaimed,\n            \"Already Claimed\"\n        );\n        uint256 total; uint256 interest;\n        (total,interest) = calculateClaimAmount(msg.sender,_stakingContractId);\n        sc.isClaimed = true;\n        sc.interest = interest;\n        IERC20(edgexContract)\n        .transfer(msg.sender,total);\n        return true;\n    }\n\n    function calculateClaimAmount(address _user, uint256 _contractId) public view returns(uint256,uint256){\n        Stake storage sc = stakeContract[_user][_contractId];\n        uint256 a = Math.mul(sc.amount,sc.roiAtStake);\n        uint256 time = Math.sub(sc.maturesAt,sc.createdAt);\n        uint256 b = Math.mul(a,time);\n        uint256 interest = Math.div(b,Math.mul(31536,10**18));\n        uint256 total = Math.add(sc.amount,interest);\n        return(total,interest);\n    }\n    \n    /**\n        @dev changing the admin of the oracle\n        Warning : Admin can change ROI & other features.\n     */\n\n    function revokeOwnership(address _newOwner) public onlyAdmin isZero(_newOwner) returns(bool){\n        admin = payable(_newOwner);\n        emit RevokeOwnership(_newOwner);\n        return true;\n    }\n\n    function changeROI(uint256 _newROI) public onlyAdmin returns(bool){\n        currentROI = _newROI;\n        emit ChangeROI(_newROI);\n        return true;\n    }\n    \n    function updateEdgexContract(address _contractAddress) public onlyAdmin isZero(_contractAddress) returns(bool){\n        edgexContract = _contractAddress;\n        return true;\n    }\n\n    function withdrawLiquidity(uint256 _edgexAmount, address _to) public virtual onlyAdmin isZero(_to) returns(bool){\n        IERC20(edgexContract)\n        .transfer(_to,_edgexAmount);\n        return true;\n    }\n\n}\n\n"}}}