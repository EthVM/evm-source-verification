{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Token.sol": {
      "content": "pragma solidity ^0.5.13;\r\n\r\ninterface Callable {\r\n    function tokenCallback(\r\n        address _from,\r\n        uint256 _tokens,\r\n        bytes calldata _data\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract Token {\r\n    uint256 private constant FLOAT_SCALAR = 2**64;\r\n    uint256 private constant INITIAL_SUPPLY = 3e24; // 3m\r\n    uint256 private constant STAKE_FEE = 2; // 1% per tx\r\n    uint256 private constant MIN_STAKE_AMOUNT = 1e19; // 10\r\n\r\n    string public constant name = \"FurToken\";\r\n    string public constant symbol = \"FUR\";\r\n    uint8 public constant decimals = 18;\r\n    address owner = 0x929B1F2328d03c05b0Fb36053222fB4B15bb29dd;\r\n\r\n    struct User {\r\n        uint256 balance;\r\n        uint256 staked;\r\n        mapping(address => uint256) allowance;\r\n        int256 scaledPayout;\r\n    }\r\n\r\n    struct Info {\r\n        uint256 totalSupply;\r\n        uint256 totalStaked;\r\n        mapping(address => User) users;\r\n        uint256 scaledPayoutPerToken;\r\n        address admin;\r\n    }\r\n    Info private info;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 tokens\r\n    );\r\n    event Whitelist(address indexed user, bool status);\r\n    event Stake(address indexed owner, uint256 tokens);\r\n    event Unstake(address indexed owner, uint256 tokens);\r\n    event Collect(address indexed owner, uint256 tokens);\r\n    event Fee(uint256 tokens);\r\n\r\n    constructor() public {\r\n        info.admin = owner;\r\n        info.totalSupply = INITIAL_SUPPLY;\r\n        info.users[owner].balance = INITIAL_SUPPLY;\r\n        emit Transfer(address(0x0), owner, INITIAL_SUPPLY);\r\n    }\r\n\r\n    function stake(uint256 _tokens) external {\r\n        _stake(_tokens);\r\n    }\r\n\r\n    function unstake(uint256 _tokens) external {\r\n        _unstake(_tokens);\r\n    }\r\n\r\n    function collect() external returns (uint256) {\r\n        uint256 _dividends = dividendsOf(msg.sender);\r\n        require(_dividends >= 0);\r\n        info.users[msg.sender].scaledPayout += int256(\r\n            _dividends * FLOAT_SCALAR\r\n        );\r\n        info.users[msg.sender].balance += _dividends;\r\n        emit Transfer(address(this), msg.sender, _dividends);\r\n        emit Collect(msg.sender, _dividends);\r\n        return _dividends;\r\n    }\r\n\r\n    function stakeDrop(uint256 _tokens) external {\r\n        require(balanceOf(msg.sender) >= _tokens);\r\n        uint256 _droppedAmount = _tokens;\r\n        info.users[msg.sender].balance -= _tokens;\r\n        if (info.totalStaked > 0) {\r\n            info.scaledPayoutPerToken +=\r\n                (_droppedAmount * FLOAT_SCALAR) /\r\n                info.totalStaked;\r\n            emit Transfer(msg.sender, address(this), _droppedAmount);\r\n            emit Fee(_droppedAmount);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function distribute(uint256 _tokens) external {\r\n        require(info.totalStaked > 0);\r\n        require(balanceOf(msg.sender) >= _tokens);\r\n        info.users[msg.sender].balance -= _tokens;\r\n        info.scaledPayoutPerToken +=\r\n            (_tokens * FLOAT_SCALAR) /\r\n            info.totalStaked;\r\n        emit Transfer(msg.sender, address(this), _tokens);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _tokens) external returns (bool) {\r\n        _transfer(msg.sender, _to, _tokens);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _tokens)\r\n        external\r\n        returns (bool)\r\n    {\r\n        info.users[msg.sender].allowance[_spender] = _tokens;\r\n        emit Approval(msg.sender, _spender, _tokens);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokens\r\n    ) external returns (bool) {\r\n        require(info.users[_from].allowance[msg.sender] >= _tokens);\r\n        info.users[_from].allowance[msg.sender] -= _tokens;\r\n        _transfer(_from, _to, _tokens);\r\n        return true;\r\n    }\r\n\r\n    function transferAndCall(\r\n        address _to,\r\n        uint256 _tokens,\r\n        bytes calldata _data\r\n    ) external returns (bool) {\r\n        uint256 _transferred = _transfer(msg.sender, _to, _tokens);\r\n        uint32 _size;\r\n        assembly {\r\n            _size := extcodesize(_to)\r\n        }\r\n        if (_size > 0) {\r\n            require(\r\n                Callable(_to).tokenCallback(msg.sender, _transferred, _data)\r\n            );\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function bulkTransfer(\r\n        address[] calldata _receivers,\r\n        uint256[] calldata _amounts\r\n    ) external {\r\n        require(_receivers.length == _amounts.length);\r\n        for (uint256 i = 0; i < _receivers.length; i++) {\r\n            _transfer(msg.sender, _receivers[i], _amounts[i]);\r\n        }\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return info.totalSupply;\r\n    }\r\n\r\n    function totalStaked() public view returns (uint256) {\r\n        return info.totalStaked;\r\n    }\r\n\r\n    function balanceOf(address _user) public view returns (uint256) {\r\n        return info.users[_user].balance - stakedOf(_user);\r\n    }\r\n\r\n    function stakedOf(address _user) public view returns (uint256) {\r\n        return info.users[_user].staked;\r\n    }\r\n\r\n    function dividendsOf(address _user) public view returns (uint256) {\r\n        return\r\n            uint256(\r\n                int256(info.scaledPayoutPerToken * info.users[_user].staked) -\r\n                    info.users[_user].scaledPayout\r\n            ) / FLOAT_SCALAR;\r\n    }\r\n\r\n    function allowance(address _user, address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return info.users[_user].allowance[_spender];\r\n    }\r\n\r\n    function allInfoFor(address _user)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 totalTokenSupply,\r\n            uint256 totalTokensStaked,\r\n            uint256 userBalance,\r\n            uint256 userStaked,\r\n            uint256 userDividends\r\n        )\r\n    {\r\n        return (\r\n            totalSupply(),\r\n            totalStaked(),\r\n            balanceOf(_user),\r\n            stakedOf(_user),\r\n            dividendsOf(_user)\r\n        );\r\n    }\r\n\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokens\r\n    ) internal returns (uint256) {\r\n        require(balanceOf(_from) >= _tokens);\r\n        info.users[_from].balance -= _tokens;\r\n        uint256 _feeAmount = (_tokens * STAKE_FEE) / 100;\r\n        uint256 _transferred = _tokens - _feeAmount;\r\n        if (info.totalStaked > 0) {\r\n            info.users[_to].balance += _transferred;\r\n            emit Transfer(_from, _to, _transferred);\r\n            info.scaledPayoutPerToken +=\r\n                (_feeAmount * FLOAT_SCALAR) /\r\n                info.totalStaked;\r\n            emit Transfer(_from, address(this), _feeAmount);\r\n            emit Fee(_feeAmount);\r\n            return _transferred;\r\n        } else {\r\n            info.users[_to].balance += _tokens;\r\n            emit Transfer(_from, _to, _tokens);\r\n            return _tokens;\r\n        }\r\n    }\r\n\r\n    function _stake(uint256 _amount) internal {\r\n        require(balanceOf(msg.sender) >= _amount);\r\n        require(stakedOf(msg.sender) + _amount >= MIN_STAKE_AMOUNT);\r\n        info.totalStaked += _amount;\r\n        info.users[msg.sender].staked += _amount;\r\n        info.users[msg.sender].scaledPayout += int256(\r\n            _amount * info.scaledPayoutPerToken\r\n        );\r\n        emit Transfer(msg.sender, address(this), _amount);\r\n        emit Stake(msg.sender, _amount);\r\n    }\r\n\r\n    function _unstake(uint256 _amount) internal {\r\n        require(stakedOf(msg.sender) >= _amount);\r\n        uint256 _feeAmount = (_amount * 10) / 100;\r\n        info.scaledPayoutPerToken +=\r\n            (_feeAmount * FLOAT_SCALAR) /\r\n            info.totalStaked;\r\n        info.totalStaked -= _amount;\r\n        info.users[msg.sender].balance -= _feeAmount;\r\n        info.users[msg.sender].staked -= _amount;\r\n        info.users[msg.sender].scaledPayout -= int256(\r\n            _amount * info.scaledPayoutPerToken\r\n        );\r\n        emit Transfer(address(this), msg.sender, _amount - _feeAmount);\r\n        emit Unstake(msg.sender, _amount);\r\n    }\r\n}"
    }
  }
}