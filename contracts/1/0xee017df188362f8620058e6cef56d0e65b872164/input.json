{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{"LoopringAmmPool.sol":{"AmmExitRequest":"0x643caf6bb68986cd17f71e225c8e264378bfcce5","AmmJoinRequest":"0xd86ecd9dc3c18e1d202c63941cacb85ec9fadf83","AmmStatus":"0xaae0a0515609723f66a38e6fe9e3455e7897143a","AmmWithdrawal":"0xb971902d99e1f94f02cc19e6bec73cf3d38c16b3"}},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":999999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"LoopringAmmPool.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\r\n// Copyright 2017 Loopring Technology Limited.\r\npragma solidity ^0.7.0;\r\n\r\n\r\n/// @title Poseidon hash function\r\n///        See: https://eprint.iacr.org/2019/458.pdf\r\n///        Code auto-generated by generate_poseidon_EVM_code.py\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary Poseidon\r\n{\r\n    //\r\n    // hash_t5f6p52\r\n    //\r\n\r\n    struct HashInputs5\r\n    {\r\n        uint t0;\r\n        uint t1;\r\n        uint t2;\r\n        uint t3;\r\n        uint t4;\r\n    }\r\n\r\n    function hash_t5f6p52_internal(\r\n        uint t0,\r\n        uint t1,\r\n        uint t2,\r\n        uint t3,\r\n        uint t4,\r\n        uint q\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        assembly {\r\n            function mix(_t0, _t1, _t2, _t3, _t4, _q) -> nt0, nt1, nt2, nt3, nt4 {\r\n                nt0 := mulmod(_t0, 4977258759536702998522229302103997878600602264560359702680165243908162277980, _q)\r\n                nt0 := addmod(nt0, mulmod(_t1, 19167410339349846567561662441069598364702008768579734801591448511131028229281, _q), _q)\r\n                nt0 := addmod(nt0, mulmod(_t2, 14183033936038168803360723133013092560869148726790180682363054735190196956789, _q), _q)\r\n                nt0 := addmod(nt0, mulmod(_t3, 9067734253445064890734144122526450279189023719890032859456830213166173619761, _q), _q)\r\n                nt0 := addmod(nt0, mulmod(_t4, 16378664841697311562845443097199265623838619398287411428110917414833007677155, _q), _q)\r\n                nt1 := mulmod(_t0, 107933704346764130067829474107909495889716688591997879426350582457782826785, _q)\r\n                nt1 := addmod(nt1, mulmod(_t1, 17034139127218860091985397764514160131253018178110701196935786874261236172431, _q), _q)\r\n                nt1 := addmod(nt1, mulmod(_t2, 2799255644797227968811798608332314218966179365168250111693473252876996230317, _q), _q)\r\n                nt1 := addmod(nt1, mulmod(_t3, 2482058150180648511543788012634934806465808146786082148795902594096349483974, _q), _q)\r\n                nt1 := addmod(nt1, mulmod(_t4, 16563522740626180338295201738437974404892092704059676533096069531044355099628, _q), _q)\r\n                nt2 := mulmod(_t0, 13596762909635538739079656925495736900379091964739248298531655823337482778123, _q)\r\n                nt2 := addmod(nt2, mulmod(_t1, 18985203040268814769637347880759846911264240088034262814847924884273017355969, _q), _q)\r\n                nt2 := addmod(nt2, mulmod(_t2, 8652975463545710606098548415650457376967119951977109072274595329619335974180, _q), _q)\r\n                nt2 := addmod(nt2, mulmod(_t3, 970943815872417895015626519859542525373809485973005165410533315057253476903, _q), _q)\r\n                nt2 := addmod(nt2, mulmod(_t4, 19406667490568134101658669326517700199745817783746545889094238643063688871948, _q), _q)\r\n                nt3 := mulmod(_t0, 2953507793609469112222895633455544691298656192015062835263784675891831794974, _q)\r\n                nt3 := addmod(nt3, mulmod(_t1, 19025623051770008118343718096455821045904242602531062247152770448380880817517, _q), _q)\r\n                nt3 := addmod(nt3, mulmod(_t2, 9077319817220936628089890431129759976815127354480867310384708941479362824016, _q), _q)\r\n                nt3 := addmod(nt3, mulmod(_t3, 4770370314098695913091200576539533727214143013236894216582648993741910829490, _q), _q)\r\n                nt3 := addmod(nt3, mulmod(_t4, 4298564056297802123194408918029088169104276109138370115401819933600955259473, _q), _q)\r\n                nt4 := mulmod(_t0, 8336710468787894148066071988103915091676109272951895469087957569358494947747, _q)\r\n                nt4 := addmod(nt4, mulmod(_t1, 16205238342129310687768799056463408647672389183328001070715567975181364448609, _q), _q)\r\n                nt4 := addmod(nt4, mulmod(_t2, 8303849270045876854140023508764676765932043944545416856530551331270859502246, _q), _q)\r\n                nt4 := addmod(nt4, mulmod(_t3, 20218246699596954048529384569730026273241102596326201163062133863539137060414, _q), _q)\r\n                nt4 := addmod(nt4, mulmod(_t4, 1712845821388089905746651754894206522004527237615042226559791118162382909269, _q), _q)\r\n            }\r\n\r\n            function ark(_t0, _t1, _t2, _t3, _t4, _q, c) -> nt0, nt1, nt2, nt3, nt4 {\r\n                nt0 := addmod(_t0, c, _q)\r\n                nt1 := addmod(_t1, c, _q)\r\n                nt2 := addmod(_t2, c, _q)\r\n                nt3 := addmod(_t3, c, _q)\r\n                nt4 := addmod(_t4, c, _q)\r\n            }\r\n\r\n            function sbox_full(_t0, _t1, _t2, _t3, _t4, _q) -> nt0, nt1, nt2, nt3, nt4 {\r\n                nt0 := mulmod(_t0, _t0, _q)\r\n                nt0 := mulmod(nt0, nt0, _q)\r\n                nt0 := mulmod(_t0, nt0, _q)\r\n                nt1 := mulmod(_t1, _t1, _q)\r\n                nt1 := mulmod(nt1, nt1, _q)\r\n                nt1 := mulmod(_t1, nt1, _q)\r\n                nt2 := mulmod(_t2, _t2, _q)\r\n                nt2 := mulmod(nt2, nt2, _q)\r\n                nt2 := mulmod(_t2, nt2, _q)\r\n                nt3 := mulmod(_t3, _t3, _q)\r\n                nt3 := mulmod(nt3, nt3, _q)\r\n                nt3 := mulmod(_t3, nt3, _q)\r\n                nt4 := mulmod(_t4, _t4, _q)\r\n                nt4 := mulmod(nt4, nt4, _q)\r\n                nt4 := mulmod(_t4, nt4, _q)\r\n            }\r\n\r\n            function sbox_partial(_t, _q) -> nt {\r\n                nt := mulmod(_t, _t, _q)\r\n                nt := mulmod(nt, nt, _q)\r\n                nt := mulmod(_t, nt, _q)\r\n            }\r\n\r\n            // round 0\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14397397413755236225575615486459253198602422701513067526754101844196324375522)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 1\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10405129301473404666785234951972711717481302463898292859783056520670200613128)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 2\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 5179144822360023508491245509308555580251733042407187134628755730783052214509)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 3\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9132640374240188374542843306219594180154739721841249568925550236430986592615)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 4\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20360807315276763881209958738450444293273549928693737723235350358403012458514)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 5\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17933600965499023212689924809448543050840131883187652471064418452962948061619)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 6\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3636213416533737411392076250708419981662897009810345015164671602334517041153)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 7\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2008540005368330234524962342006691994500273283000229509835662097352946198608)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 8\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16018407964853379535338740313053768402596521780991140819786560130595652651567)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 9\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20653139667070586705378398435856186172195806027708437373983929336015162186471)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 10\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17887713874711369695406927657694993484804203950786446055999405564652412116765)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 11\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4852706232225925756777361208698488277369799648067343227630786518486608711772)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 12\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8969172011633935669771678412400911310465619639756845342775631896478908389850)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 13\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20570199545627577691240476121888846460936245025392381957866134167601058684375)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 14\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16442329894745639881165035015179028112772410105963688121820543219662832524136)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 15\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20060625627350485876280451423010593928172611031611836167979515653463693899374)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 16\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16637282689940520290130302519163090147511023430395200895953984829546679599107)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 17\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15599196921909732993082127725908821049411366914683565306060493533569088698214)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 18\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16894591341213863947423904025624185991098788054337051624251730868231322135455)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 19\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 1197934381747032348421303489683932612752526046745577259575778515005162320212)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 20\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6172482022646932735745595886795230725225293469762393889050804649558459236626)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 21\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21004037394166516054140386756510609698837211370585899203851827276330669555417)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 22\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15262034989144652068456967541137853724140836132717012646544737680069032573006)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 23\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15017690682054366744270630371095785995296470601172793770224691982518041139766)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 24\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15159744167842240513848638419303545693472533086570469712794583342699782519832)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 25\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11178069035565459212220861899558526502477231302924961773582350246646450941231)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 26\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21154888769130549957415912997229564077486639529994598560737238811887296922114)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 27\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20162517328110570500010831422938033120419484532231241180224283481905744633719)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 28\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2777362604871784250419758188173029886707024739806641263170345377816177052018)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 29\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15732290486829619144634131656503993123618032247178179298922551820261215487562)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 30\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6024433414579583476444635447152826813568595303270846875177844482142230009826)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 31\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17677827682004946431939402157761289497221048154630238117709539216286149983245)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 32\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10716307389353583413755237303156291454109852751296156900963208377067748518748)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 33\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14925386988604173087143546225719076187055229908444910452781922028996524347508)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 34\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8940878636401797005293482068100797531020505636124892198091491586778667442523)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 35\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 18911747154199663060505302806894425160044925686870165583944475880789706164410)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 36\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8821532432394939099312235292271438180996556457308429936910969094255825456935)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 37\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20632576502437623790366878538516326728436616723089049415538037018093616927643)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 38\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 71447649211767888770311304010816315780740050029903404046389165015534756512)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 39\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2781996465394730190470582631099299305677291329609718650018200531245670229393)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 40\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 12441376330954323535872906380510501637773629931719508864016287320488688345525)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 41\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2558302139544901035700544058046419714227464650146159803703499681139469546006)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 42\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10087036781939179132584550273563255199577525914374285705149349445480649057058)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 43\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4267692623754666261749551533667592242661271409704769363166965280715887854739)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 44\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4945579503584457514844595640661884835097077318604083061152997449742124905548)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 45\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17742335354489274412669987990603079185096280484072783973732137326144230832311)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 46\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6266270088302506215402996795500854910256503071464802875821837403486057988208)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 47\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2716062168542520412498610856550519519760063668165561277991771577403400784706)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 48\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 19118392018538203167410421493487769944462015419023083813301166096764262134232)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 49\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9386595745626044000666050847309903206827901310677406022353307960932745699524)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 50\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9121640807890366356465620448383131419933298563527245687958865317869840082266)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 51\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3078975275808111706229899605611544294904276390490742680006005661017864583210)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 52\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 7157404299437167354719786626667769956233708887934477609633504801472827442743)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 53\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14056248655941725362944552761799461694550787028230120190862133165195793034373)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 54\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14124396743304355958915937804966111851843703158171757752158388556919187839849)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 55\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11851254356749068692552943732920045260402277343008629727465773766468466181076)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 56\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9799099446406796696742256539758943483211846559715874347178722060519817626047)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 57\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10156146186214948683880719664738535455146137901666656566575307300522957959544)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n        }\r\n        return t0;\r\n    }\r\n\r\n    function hash_t5f6p52(HashInputs5 memory i, uint q) internal pure returns (uint)\r\n    {\r\n        // validate inputs\r\n        require(i.t0 < q, \"INVALID_INPUT\");\r\n        require(i.t1 < q, \"INVALID_INPUT\");\r\n        require(i.t2 < q, \"INVALID_INPUT\");\r\n        require(i.t3 < q, \"INVALID_INPUT\");\r\n        require(i.t4 < q, \"INVALID_INPUT\");\r\n\r\n        return hash_t5f6p52_internal(i.t0, i.t1, i.t2, i.t3, i.t4, q);\r\n    }\r\n\r\n\r\n    //\r\n    // hash_t7f6p52\r\n    //\r\n\r\n    struct HashInputs7\r\n    {\r\n        uint t0;\r\n        uint t1;\r\n        uint t2;\r\n        uint t3;\r\n        uint t4;\r\n        uint t5;\r\n        uint t6;\r\n    }\r\n\r\n    function mix(HashInputs7 memory i, uint q) internal pure\r\n    {\r\n        HashInputs7 memory o;\r\n        o.t0 = mulmod(i.t0, 14183033936038168803360723133013092560869148726790180682363054735190196956789, q);\r\n        o.t0 = addmod(o.t0, mulmod(i.t1, 9067734253445064890734144122526450279189023719890032859456830213166173619761, q), q);\r\n        o.t0 = addmod(o.t0, mulmod(i.t2, 16378664841697311562845443097199265623838619398287411428110917414833007677155, q), q);\r\n        o.t0 = addmod(o.t0, mulmod(i.t3, 12968540216479938138647596899147650021419273189336843725176422194136033835172, q), q);\r\n        o.t0 = addmod(o.t0, mulmod(i.t4, 3636162562566338420490575570584278737093584021456168183289112789616069756675, q), q);\r\n        o.t0 = addmod(o.t0, mulmod(i.t5, 8949952361235797771659501126471156178804092479420606597426318793013844305422, q), q);\r\n        o.t0 = addmod(o.t0, mulmod(i.t6, 13586657904816433080148729258697725609063090799921401830545410130405357110367, q), q);\r\n        o.t1 = mulmod(i.t0, 2799255644797227968811798608332314218966179365168250111693473252876996230317, q);\r\n        o.t1 = addmod(o.t1, mulmod(i.t1, 2482058150180648511543788012634934806465808146786082148795902594096349483974, q), q);\r\n        o.t1 = addmod(o.t1, mulmod(i.t2, 16563522740626180338295201738437974404892092704059676533096069531044355099628, q), q);\r\n        o.t1 = addmod(o.t1, mulmod(i.t3, 10468644849657689537028565510142839489302836569811003546969773105463051947124, q), q);\r\n        o.t1 = addmod(o.t1, mulmod(i.t4, 3328913364598498171733622353010907641674136720305714432354138807013088636408, q), q);\r\n        o.t1 = addmod(o.t1, mulmod(i.t5, 8642889650254799419576843603477253661899356105675006557919250564400804756641, q), q);\r\n        o.t1 = addmod(o.t1, mulmod(i.t6, 14300697791556510113764686242794463641010174685800128469053974698256194076125, q), q);\r\n        o.t2 = mulmod(i.t0, 8652975463545710606098548415650457376967119951977109072274595329619335974180, q);\r\n        o.t2 = addmod(o.t2, mulmod(i.t1, 970943815872417895015626519859542525373809485973005165410533315057253476903, q), q);\r\n        o.t2 = addmod(o.t2, mulmod(i.t2, 19406667490568134101658669326517700199745817783746545889094238643063688871948, q), q);\r\n        o.t2 = addmod(o.t2, mulmod(i.t3, 17049854690034965250221386317058877242629221002521630573756355118745574274967, q), q);\r\n        o.t2 = addmod(o.t2, mulmod(i.t4, 4964394613021008685803675656098849539153699842663541444414978877928878266244, q), q);\r\n        o.t2 = addmod(o.t2, mulmod(i.t5, 15474947305445649466370538888925567099067120578851553103424183520405650587995, q), q);\r\n        o.t2 = addmod(o.t2, mulmod(i.t6, 1016119095639665978105768933448186152078842964810837543326777554729232767846, q), q);\r\n        o.t3 = mulmod(i.t0, 9077319817220936628089890431129759976815127354480867310384708941479362824016, q);\r\n        o.t3 = addmod(o.t3, mulmod(i.t1, 4770370314098695913091200576539533727214143013236894216582648993741910829490, q), q);\r\n        o.t3 = addmod(o.t3, mulmod(i.t2, 4298564056297802123194408918029088169104276109138370115401819933600955259473, q), q);\r\n        o.t3 = addmod(o.t3, mulmod(i.t3, 6905514380186323693285869145872115273350947784558995755916362330070690839131, q), q);\r\n        o.t3 = addmod(o.t3, mulmod(i.t4, 4783343257810358393326889022942241108539824540285247795235499223017138301952, q), q);\r\n        o.t3 = addmod(o.t3, mulmod(i.t5, 1420772902128122367335354247676760257656541121773854204774788519230732373317, q), q);\r\n        o.t3 = addmod(o.t3, mulmod(i.t6, 14172871439045259377975734198064051992755748777535789572469924335100006948373, q), q);\r\n        o.t4 = mulmod(i.t0, 8303849270045876854140023508764676765932043944545416856530551331270859502246, q);\r\n        o.t4 = addmod(o.t4, mulmod(i.t1, 20218246699596954048529384569730026273241102596326201163062133863539137060414, q), q);\r\n        o.t4 = addmod(o.t4, mulmod(i.t2, 1712845821388089905746651754894206522004527237615042226559791118162382909269, q), q);\r\n        o.t4 = addmod(o.t4, mulmod(i.t3, 13001155522144542028910638547179410124467185319212645031214919884423841839406, q), q);\r\n        o.t4 = addmod(o.t4, mulmod(i.t4, 16037892369576300958623292723740289861626299352695838577330319504984091062115, q), q);\r\n        o.t4 = addmod(o.t4, mulmod(i.t5, 19189494548480259335554606182055502469831573298885662881571444557262020106898, q), q);\r\n        o.t4 = addmod(o.t4, mulmod(i.t6, 19032687447778391106390582750185144485341165205399984747451318330476859342654, q), q);\r\n        o.t5 = mulmod(i.t0, 13272957914179340594010910867091459756043436017766464331915862093201960540910, q);\r\n        o.t5 = addmod(o.t5, mulmod(i.t1, 9416416589114508529880440146952102328470363729880726115521103179442988482948, q), q);\r\n        o.t5 = addmod(o.t5, mulmod(i.t2, 8035240799672199706102747147502951589635001418759394863664434079699838251138, q), q);\r\n        o.t5 = addmod(o.t5, mulmod(i.t3, 21642389080762222565487157652540372010968704000567605990102641816691459811717, q), q);\r\n        o.t5 = addmod(o.t5, mulmod(i.t4, 20261355950827657195644012399234591122288573679402601053407151083849785332516, q), q);\r\n        o.t5 = addmod(o.t5, mulmod(i.t5, 14514189384576734449268559374569145463190040567900950075547616936149781403109, q), q);\r\n        o.t5 = addmod(o.t5, mulmod(i.t6, 19038036134886073991945204537416211699632292792787812530208911676638479944765, q), q);\r\n        o.t6 = mulmod(i.t0, 15627836782263662543041758927100784213807648787083018234961118439434298020664, q);\r\n        o.t6 = addmod(o.t6, mulmod(i.t1, 5655785191024506056588710805596292231240948371113351452712848652644610823632, q), q);\r\n        o.t6 = addmod(o.t6, mulmod(i.t2, 8265264721707292643644260517162050867559314081394556886644673791575065394002, q), q);\r\n        o.t6 = addmod(o.t6, mulmod(i.t3, 17151144681903609082202835646026478898625761142991787335302962548605510241586, q), q);\r\n        o.t6 = addmod(o.t6, mulmod(i.t4, 18731644709777529787185361516475509623264209648904603914668024590231177708831, q), q);\r\n        o.t6 = addmod(o.t6, mulmod(i.t5, 20697789991623248954020701081488146717484139720322034504511115160686216223641, q), q);\r\n        o.t6 = addmod(o.t6, mulmod(i.t6, 6200020095464686209289974437830528853749866001482481427982839122465470640886, q), q);\r\n        i.t0 = o.t0;\r\n        i.t1 = o.t1;\r\n        i.t2 = o.t2;\r\n        i.t3 = o.t3;\r\n        i.t4 = o.t4;\r\n        i.t5 = o.t5;\r\n        i.t6 = o.t6;\r\n    }\r\n\r\n    function ark(HashInputs7 memory i, uint q, uint c) internal pure\r\n    {\r\n        HashInputs7 memory o;\r\n        o.t0 = addmod(i.t0, c, q);\r\n        o.t1 = addmod(i.t1, c, q);\r\n        o.t2 = addmod(i.t2, c, q);\r\n        o.t3 = addmod(i.t3, c, q);\r\n        o.t4 = addmod(i.t4, c, q);\r\n        o.t5 = addmod(i.t5, c, q);\r\n        o.t6 = addmod(i.t6, c, q);\r\n        i.t0 = o.t0;\r\n        i.t1 = o.t1;\r\n        i.t2 = o.t2;\r\n        i.t3 = o.t3;\r\n        i.t4 = o.t4;\r\n        i.t5 = o.t5;\r\n        i.t6 = o.t6;\r\n    }\r\n\r\n    function sbox_full(HashInputs7 memory i, uint q) internal pure\r\n    {\r\n        HashInputs7 memory o;\r\n        o.t0 = mulmod(i.t0, i.t0, q);\r\n        o.t0 = mulmod(o.t0, o.t0, q);\r\n        o.t0 = mulmod(i.t0, o.t0, q);\r\n        o.t1 = mulmod(i.t1, i.t1, q);\r\n        o.t1 = mulmod(o.t1, o.t1, q);\r\n        o.t1 = mulmod(i.t1, o.t1, q);\r\n        o.t2 = mulmod(i.t2, i.t2, q);\r\n        o.t2 = mulmod(o.t2, o.t2, q);\r\n        o.t2 = mulmod(i.t2, o.t2, q);\r\n        o.t3 = mulmod(i.t3, i.t3, q);\r\n        o.t3 = mulmod(o.t3, o.t3, q);\r\n        o.t3 = mulmod(i.t3, o.t3, q);\r\n        o.t4 = mulmod(i.t4, i.t4, q);\r\n        o.t4 = mulmod(o.t4, o.t4, q);\r\n        o.t4 = mulmod(i.t4, o.t4, q);\r\n        o.t5 = mulmod(i.t5, i.t5, q);\r\n        o.t5 = mulmod(o.t5, o.t5, q);\r\n        o.t5 = mulmod(i.t5, o.t5, q);\r\n        o.t6 = mulmod(i.t6, i.t6, q);\r\n        o.t6 = mulmod(o.t6, o.t6, q);\r\n        o.t6 = mulmod(i.t6, o.t6, q);\r\n        i.t0 = o.t0;\r\n        i.t1 = o.t1;\r\n        i.t2 = o.t2;\r\n        i.t3 = o.t3;\r\n        i.t4 = o.t4;\r\n        i.t5 = o.t5;\r\n        i.t6 = o.t6;\r\n    }\r\n\r\n    function sbox_partial(HashInputs7 memory i, uint q) internal pure\r\n    {\r\n        HashInputs7 memory o;\r\n        o.t0 = mulmod(i.t0, i.t0, q);\r\n        o.t0 = mulmod(o.t0, o.t0, q);\r\n        o.t0 = mulmod(i.t0, o.t0, q);\r\n        i.t0 = o.t0;\r\n    }\r\n\r\n    function hash_t7f6p52(HashInputs7 memory i, uint q) internal pure returns (uint)\r\n    {\r\n        // validate inputs\r\n        require(i.t0 < q, \"INVALID_INPUT\");\r\n        require(i.t1 < q, \"INVALID_INPUT\");\r\n        require(i.t2 < q, \"INVALID_INPUT\");\r\n        require(i.t3 < q, \"INVALID_INPUT\");\r\n        require(i.t4 < q, \"INVALID_INPUT\");\r\n        require(i.t5 < q, \"INVALID_INPUT\");\r\n        require(i.t6 < q, \"INVALID_INPUT\");\r\n\r\n        // round 0\r\n        ark(i, q, 14397397413755236225575615486459253198602422701513067526754101844196324375522);\r\n        sbox_full(i, q);\r\n        mix(i, q);\r\n        // round 1\r\n        ark(i, q, 10405129301473404666785234951972711717481302463898292859783056520670200613128);\r\n        sbox_full(i, q);\r\n        mix(i, q);\r\n        // round 2\r\n        ark(i, q, 5179144822360023508491245509308555580251733042407187134628755730783052214509);\r\n        sbox_full(i, q);\r\n        mix(i, q);\r\n        // round 3\r\n        ark(i, q, 9132640374240188374542843306219594180154739721841249568925550236430986592615);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 4\r\n        ark(i, q, 20360807315276763881209958738450444293273549928693737723235350358403012458514);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 5\r\n        ark(i, q, 17933600965499023212689924809448543050840131883187652471064418452962948061619);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 6\r\n        ark(i, q, 3636213416533737411392076250708419981662897009810345015164671602334517041153);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 7\r\n        ark(i, q, 2008540005368330234524962342006691994500273283000229509835662097352946198608);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 8\r\n        ark(i, q, 16018407964853379535338740313053768402596521780991140819786560130595652651567);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 9\r\n        ark(i, q, 20653139667070586705378398435856186172195806027708437373983929336015162186471);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 10\r\n        ark(i, q, 17887713874711369695406927657694993484804203950786446055999405564652412116765);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 11\r\n        ark(i, q, 4852706232225925756777361208698488277369799648067343227630786518486608711772);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 12\r\n        ark(i, q, 8969172011633935669771678412400911310465619639756845342775631896478908389850);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 13\r\n        ark(i, q, 20570199545627577691240476121888846460936245025392381957866134167601058684375);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 14\r\n        ark(i, q, 16442329894745639881165035015179028112772410105963688121820543219662832524136);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 15\r\n        ark(i, q, 20060625627350485876280451423010593928172611031611836167979515653463693899374);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 16\r\n        ark(i, q, 16637282689940520290130302519163090147511023430395200895953984829546679599107);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 17\r\n        ark(i, q, 15599196921909732993082127725908821049411366914683565306060493533569088698214);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 18\r\n        ark(i, q, 16894591341213863947423904025624185991098788054337051624251730868231322135455);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 19\r\n        ark(i, q, 1197934381747032348421303489683932612752526046745577259575778515005162320212);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 20\r\n        ark(i, q, 6172482022646932735745595886795230725225293469762393889050804649558459236626);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 21\r\n        ark(i, q, 21004037394166516054140386756510609698837211370585899203851827276330669555417);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 22\r\n        ark(i, q, 15262034989144652068456967541137853724140836132717012646544737680069032573006);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 23\r\n        ark(i, q, 15017690682054366744270630371095785995296470601172793770224691982518041139766);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 24\r\n        ark(i, q, 15159744167842240513848638419303545693472533086570469712794583342699782519832);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 25\r\n        ark(i, q, 11178069035565459212220861899558526502477231302924961773582350246646450941231);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 26\r\n        ark(i, q, 21154888769130549957415912997229564077486639529994598560737238811887296922114);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 27\r\n        ark(i, q, 20162517328110570500010831422938033120419484532231241180224283481905744633719);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 28\r\n        ark(i, q, 2777362604871784250419758188173029886707024739806641263170345377816177052018);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 29\r\n        ark(i, q, 15732290486829619144634131656503993123618032247178179298922551820261215487562);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 30\r\n        ark(i, q, 6024433414579583476444635447152826813568595303270846875177844482142230009826);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 31\r\n        ark(i, q, 17677827682004946431939402157761289497221048154630238117709539216286149983245);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 32\r\n        ark(i, q, 10716307389353583413755237303156291454109852751296156900963208377067748518748);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 33\r\n        ark(i, q, 14925386988604173087143546225719076187055229908444910452781922028996524347508);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 34\r\n        ark(i, q, 8940878636401797005293482068100797531020505636124892198091491586778667442523);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 35\r\n        ark(i, q, 18911747154199663060505302806894425160044925686870165583944475880789706164410);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 36\r\n        ark(i, q, 8821532432394939099312235292271438180996556457308429936910969094255825456935);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 37\r\n        ark(i, q, 20632576502437623790366878538516326728436616723089049415538037018093616927643);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 38\r\n        ark(i, q, 71447649211767888770311304010816315780740050029903404046389165015534756512);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 39\r\n        ark(i, q, 2781996465394730190470582631099299305677291329609718650018200531245670229393);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 40\r\n        ark(i, q, 12441376330954323535872906380510501637773629931719508864016287320488688345525);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 41\r\n        ark(i, q, 2558302139544901035700544058046419714227464650146159803703499681139469546006);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 42\r\n        ark(i, q, 10087036781939179132584550273563255199577525914374285705149349445480649057058);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 43\r\n        ark(i, q, 4267692623754666261749551533667592242661271409704769363166965280715887854739);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 44\r\n        ark(i, q, 4945579503584457514844595640661884835097077318604083061152997449742124905548);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 45\r\n        ark(i, q, 17742335354489274412669987990603079185096280484072783973732137326144230832311);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 46\r\n        ark(i, q, 6266270088302506215402996795500854910256503071464802875821837403486057988208);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 47\r\n        ark(i, q, 2716062168542520412498610856550519519760063668165561277991771577403400784706);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 48\r\n        ark(i, q, 19118392018538203167410421493487769944462015419023083813301166096764262134232);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 49\r\n        ark(i, q, 9386595745626044000666050847309903206827901310677406022353307960932745699524);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 50\r\n        ark(i, q, 9121640807890366356465620448383131419933298563527245687958865317869840082266);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 51\r\n        ark(i, q, 3078975275808111706229899605611544294904276390490742680006005661017864583210);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 52\r\n        ark(i, q, 7157404299437167354719786626667769956233708887934477609633504801472827442743);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 53\r\n        ark(i, q, 14056248655941725362944552761799461694550787028230120190862133165195793034373);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 54\r\n        ark(i, q, 14124396743304355958915937804966111851843703158171757752158388556919187839849);\r\n        sbox_partial(i, q);\r\n        mix(i, q);\r\n        // round 55\r\n        ark(i, q, 11851254356749068692552943732920045260402277343008629727465773766468466181076);\r\n        sbox_full(i, q);\r\n        mix(i, q);\r\n        // round 56\r\n        ark(i, q, 9799099446406796696742256539758943483211846559715874347178722060519817626047);\r\n        sbox_full(i, q);\r\n        mix(i, q);\r\n        // round 57\r\n        ark(i, q, 10156146186214948683880719664738535455146137901666656566575307300522957959544);\r\n        sbox_full(i, q);\r\n        mix(i, q);\r\n\r\n        return i.t0;\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title Utility Functions for uint\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary MathUint\r\n{\r\n    using MathUint for uint;\r\n\r\n    function mul(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\r\n    }\r\n\r\n    function sub(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        require(b <= a, \"SUB_UNDERFLOW\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"ADD_OVERFLOW\");\r\n    }\r\n\r\n    function add64(\r\n        uint64 a,\r\n        uint64 b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint64 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"ADD_OVERFLOW\");\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title ERC20 safe transfer\r\n/// @dev see https://github.com/sec-bit/badERC20Fix\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ERC20SafeTransfer\r\n{\r\n    function safeTransferAndVerify(\r\n        address token,\r\n        address to,\r\n        uint    value\r\n        )\r\n        internal\r\n    {\r\n        safeTransferWithGasLimitAndVerify(\r\n            token,\r\n            to,\r\n            value,\r\n            gasleft()\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint    value\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return safeTransferWithGasLimit(\r\n            token,\r\n            to,\r\n            value,\r\n            gasleft()\r\n        );\r\n    }\r\n\r\n    function safeTransferWithGasLimitAndVerify(\r\n        address token,\r\n        address to,\r\n        uint    value,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n    {\r\n        require(\r\n            safeTransferWithGasLimit(token, to, value, gasLimit),\r\n            \"TRANSFER_FAILURE\"\r\n        );\r\n    }\r\n\r\n    function safeTransferWithGasLimit(\r\n        address token,\r\n        address to,\r\n        uint    value,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        // A transfer is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n\r\n        // bytes4(keccak256(\"transfer(address,uint256)\")) = 0xa9059cbb\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            bytes4(0xa9059cbb),\r\n            to,\r\n            value\r\n        );\r\n        (bool success, ) = token.call{gas: gasLimit}(callData);\r\n        return checkReturnValue(success);\r\n    }\r\n\r\n    function safeTransferFromAndVerify(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint    value\r\n        )\r\n        internal\r\n    {\r\n        safeTransferFromWithGasLimitAndVerify(\r\n            token,\r\n            from,\r\n            to,\r\n            value,\r\n            gasleft()\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint    value\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return safeTransferFromWithGasLimit(\r\n            token,\r\n            from,\r\n            to,\r\n            value,\r\n            gasleft()\r\n        );\r\n    }\r\n\r\n    function safeTransferFromWithGasLimitAndVerify(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint    value,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n    {\r\n        bool result = safeTransferFromWithGasLimit(\r\n            token,\r\n            from,\r\n            to,\r\n            value,\r\n            gasLimit\r\n        );\r\n        require(result, \"TRANSFER_FAILURE\");\r\n    }\r\n\r\n    function safeTransferFromWithGasLimit(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint    value,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        // A transferFrom is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n\r\n        // bytes4(keccak256(\"transferFrom(address,address,uint256)\")) = 0x23b872dd\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            bytes4(0x23b872dd),\r\n            from,\r\n            to,\r\n            value\r\n        );\r\n        (bool success, ) = token.call{gas: gasLimit}(callData);\r\n        return checkReturnValue(success);\r\n    }\r\n\r\n    function checkReturnValue(\r\n        bool success\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // A transfer/transferFrom is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n        if (success) {\r\n            assembly {\r\n                switch returndatasize()\r\n                // Non-standard ERC20: nothing is returned so if 'call' was successful we assume the transfer succeeded\r\n                case 0 {\r\n                    success := 1\r\n                }\r\n                // Standard ERC20: a single boolean value is returned which needs to be true\r\n                case 32 {\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)\r\n                }\r\n                // None of the above: not successful\r\n                default {\r\n                    success := 0\r\n                }\r\n            }\r\n        }\r\n        return success;\r\n    }\r\n}\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ExchangeTokens.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeTokens\r\n{\r\n    using MathUint          for uint;\r\n    using ERC20SafeTransfer for address;\r\n    using ExchangeMode      for ExchangeData.State;\r\n\r\n    event TokenRegistered(\r\n        address token,\r\n        uint16  tokenId\r\n    );\r\n\r\n    function getTokenAddress(\r\n        ExchangeData.State storage S,\r\n        uint16 tokenID\r\n        )\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        require(tokenID < S.tokens.length, \"INVALID_TOKEN_ID\");\r\n        return S.tokens[tokenID].token;\r\n    }\r\n\r\n    function registerToken(\r\n        ExchangeData.State storage S,\r\n        address tokenAddress\r\n        )\r\n        public\r\n        returns (uint16 tokenID)\r\n    {\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n        require(S.tokenToTokenId[tokenAddress] == 0, \"TOKEN_ALREADY_EXIST\");\r\n        require(S.tokens.length < ExchangeData.MAX_NUM_TOKENS(), \"TOKEN_REGISTRY_FULL\");\r\n\r\n        // Check if the deposit contract supports the new token\r\n        if (S.depositContract != IDepositContract(0)) {\r\n            require(\r\n                S.depositContract.isTokenSupported(tokenAddress),\r\n                \"UNSUPPORTED_TOKEN\"\r\n            );\r\n        }\r\n\r\n        // Assign a tokenID and store the token\r\n        ExchangeData.Token memory token = ExchangeData.Token(\r\n            tokenAddress\r\n        );\r\n        tokenID = uint16(S.tokens.length);\r\n        S.tokens.push(token);\r\n        S.tokenToTokenId[tokenAddress] = tokenID + 1;\r\n\r\n        emit TokenRegistered(tokenAddress, tokenID);\r\n    }\r\n\r\n    function getTokenID(\r\n        ExchangeData.State storage S,\r\n        address tokenAddress\r\n        )\r\n        internal  // inline call\r\n        view\r\n        returns (uint16 tokenID)\r\n    {\r\n        tokenID = S.tokenToTokenId[tokenAddress];\r\n        require(tokenID != 0, \"TOKEN_NOT_FOUND\");\r\n        tokenID = tokenID - 1;\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ExchangeBalances.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeBalances\r\n{\r\n    using MathUint  for uint;\r\n\r\n    function verifyAccountBalance(\r\n        uint                              merkleRoot,\r\n        ExchangeData.MerkleProof calldata merkleProof\r\n        )\r\n        public\r\n        pure\r\n    {\r\n        require(\r\n            isAccountBalanceCorrect(merkleRoot, merkleProof),\r\n            \"INVALID_MERKLE_TREE_DATA\"\r\n        );\r\n    }\r\n\r\n    function isAccountBalanceCorrect(\r\n        uint                            merkleRoot,\r\n        ExchangeData.MerkleProof memory merkleProof\r\n        )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // Calculate the Merkle root using the Merkle paths provided\r\n        uint calculatedRoot = getBalancesRoot(\r\n            merkleProof.balanceLeaf.tokenID,\r\n            merkleProof.balanceLeaf.balance,\r\n            merkleProof.balanceLeaf.weightAMM,\r\n            merkleProof.balanceLeaf.storageRoot,\r\n            merkleProof.balanceMerkleProof\r\n        );\r\n        calculatedRoot = getAccountInternalsRoot(\r\n            merkleProof.accountLeaf.accountID,\r\n            merkleProof.accountLeaf.owner,\r\n            merkleProof.accountLeaf.pubKeyX,\r\n            merkleProof.accountLeaf.pubKeyY,\r\n            merkleProof.accountLeaf.nonce,\r\n            merkleProof.accountLeaf.feeBipsAMM,\r\n            calculatedRoot,\r\n            merkleProof.accountMerkleProof\r\n        );\r\n        // Check against the expected Merkle root\r\n        return (calculatedRoot == merkleRoot);\r\n    }\r\n\r\n    function getBalancesRoot(\r\n        uint16   tokenID,\r\n        uint     balance,\r\n        uint     weightAMM,\r\n        uint     storageRoot,\r\n        uint[24] memory balanceMerkleProof\r\n        )\r\n        private\r\n        pure\r\n        returns (uint)\r\n    {\r\n        // Hash the balance leaf\r\n        uint balanceItem = hashImpl(balance, weightAMM, storageRoot, 0);\r\n        // Calculate the Merkle root of the balance quad Merkle tree\r\n        uint _id = tokenID;\r\n        for (uint depth = 0; depth < 8; depth++) {\r\n            uint base = depth * 3;\r\n            if (_id & 3 == 0) {\r\n                balanceItem = hashImpl(\r\n                    balanceItem,\r\n                    balanceMerkleProof[base],\r\n                    balanceMerkleProof[base + 1],\r\n                    balanceMerkleProof[base + 2]\r\n                );\r\n            } else if (_id & 3 == 1) {\r\n                balanceItem = hashImpl(\r\n                    balanceMerkleProof[base],\r\n                    balanceItem,\r\n                    balanceMerkleProof[base + 1],\r\n                    balanceMerkleProof[base + 2]\r\n                );\r\n            } else if (_id & 3 == 2) {\r\n                balanceItem = hashImpl(\r\n                    balanceMerkleProof[base],\r\n                    balanceMerkleProof[base + 1],\r\n                    balanceItem,\r\n                    balanceMerkleProof[base + 2]\r\n                );\r\n            } else if (_id & 3 == 3) {\r\n                balanceItem = hashImpl(\r\n                    balanceMerkleProof[base],\r\n                    balanceMerkleProof[base + 1],\r\n                    balanceMerkleProof[base + 2],\r\n                    balanceItem\r\n                );\r\n            }\r\n            _id = _id >> 2;\r\n        }\r\n        return balanceItem;\r\n    }\r\n\r\n    function getAccountInternalsRoot(\r\n        uint32   accountID,\r\n        address  owner,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint     nonce,\r\n        uint     feeBipsAMM,\r\n        uint     balancesRoot,\r\n        uint[48] memory accountMerkleProof\r\n        )\r\n        private\r\n        pure\r\n        returns (uint)\r\n    {\r\n        // Hash the account leaf\r\n        uint accountItem = hashAccountLeaf(uint(owner), pubKeyX, pubKeyY, nonce, feeBipsAMM, balancesRoot);\r\n        // Calculate the Merkle root of the account quad Merkle tree\r\n        uint _id = accountID;\r\n        for (uint depth = 0; depth < 16; depth++) {\r\n            uint base = depth * 3;\r\n            if (_id & 3 == 0) {\r\n                accountItem = hashImpl(\r\n                    accountItem,\r\n                    accountMerkleProof[base],\r\n                    accountMerkleProof[base + 1],\r\n                    accountMerkleProof[base + 2]\r\n                );\r\n            } else if (_id & 3 == 1) {\r\n                accountItem = hashImpl(\r\n                    accountMerkleProof[base],\r\n                    accountItem,\r\n                    accountMerkleProof[base + 1],\r\n                    accountMerkleProof[base + 2]\r\n                );\r\n            } else if (_id & 3 == 2) {\r\n                accountItem = hashImpl(\r\n                    accountMerkleProof[base],\r\n                    accountMerkleProof[base + 1],\r\n                    accountItem,\r\n                    accountMerkleProof[base + 2]\r\n                );\r\n            } else if (_id & 3 == 3) {\r\n                accountItem = hashImpl(\r\n                    accountMerkleProof[base],\r\n                    accountMerkleProof[base + 1],\r\n                    accountMerkleProof[base + 2],\r\n                    accountItem\r\n                );\r\n            }\r\n            _id = _id >> 2;\r\n        }\r\n        return accountItem;\r\n    }\r\n\r\n    function hashAccountLeaf(\r\n        uint t0,\r\n        uint t1,\r\n        uint t2,\r\n        uint t3,\r\n        uint t4,\r\n        uint t5\r\n        )\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        Poseidon.HashInputs7 memory inputs = Poseidon.HashInputs7(t0, t1, t2, t3, t4, t5, 0);\r\n        return Poseidon.hash_t7f6p52(inputs, ExchangeData.SNARK_SCALAR_FIELD());\r\n    }\r\n\r\n    function hashImpl(\r\n        uint t0,\r\n        uint t1,\r\n        uint t2,\r\n        uint t3\r\n        )\r\n        private\r\n        pure\r\n        returns (uint)\r\n    {\r\n        Poseidon.HashInputs5 memory inputs = Poseidon.HashInputs5(t0, t1, t2, t3, 0);\r\n        return Poseidon.hash_t5f6p52(inputs, ExchangeData.SNARK_SCALAR_FIELD());\r\n    }\r\n}\r\n\r\n//Mainly taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\r\n\r\n\r\nlibrary BytesUtil {\r\n\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\r\n        require(_bytes.length >= (_start + 1));\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\r\n        require(_bytes.length >= (_start + 2));\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint24(bytes memory _bytes, uint _start) internal  pure returns (uint24) {\r\n        require(_bytes.length >= (_start + 3));\r\n        uint24 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x3), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\r\n        require(_bytes.length >= (_start + 4));\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\r\n        require(_bytes.length >= (_start + 8));\r\n        uint64 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\r\n        require(_bytes.length >= (_start + 12));\r\n        uint96 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\r\n        require(_bytes.length >= (_start + 16));\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\r\n        require(_bytes.length >= (_start + 4));\r\n        bytes4 tempBytes4;\r\n\r\n        assembly {\r\n            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes4;\r\n    }\r\n\r\n    function toBytes20(bytes memory _bytes, uint _start) internal  pure returns (bytes20) {\r\n        require(_bytes.length >= (_start + 20));\r\n        bytes20 tempBytes20;\r\n\r\n        assembly {\r\n            tempBytes20 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes20;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\r\n        require(_bytes.length >= (_start + 32));\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function fastSHA256(\r\n        bytes memory data\r\n        )\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        bytes32[] memory result = new bytes32[](1);\r\n        bool success;\r\n        assembly {\r\n             let ptr := add(data, 32)\r\n             success := staticcall(sub(gas(), 2000), 2, ptr, mload(data), add(result, 32), 32)\r\n        }\r\n        require(success, \"SHA256_FAILED\");\r\n        return result[0];\r\n    }\r\n}\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title Utility Functions for addresses\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary AddressUtil\r\n{\r\n    using AddressUtil for *;\r\n\r\n    function isContract(\r\n        address addr\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(addr) }\r\n        return (codehash != 0x0 &&\r\n                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\r\n    }\r\n\r\n    function toPayable(\r\n        address addr\r\n        )\r\n        internal\r\n        pure\r\n        returns (address payable)\r\n    {\r\n        return payable(addr);\r\n    }\r\n\r\n    // Works like address.send but with a customizable gas limit\r\n    // Make sure your code is safe for reentrancy when using this function!\r\n    function sendETH(\r\n        address to,\r\n        uint    amount,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n        address payable recipient = to.toPayable();\r\n        /* solium-disable-next-line */\r\n        (success, ) = recipient.call{value: amount, gas: gasLimit}(\"\");\r\n    }\r\n\r\n    // Works like address.transfer but with a customizable gas limit\r\n    // Make sure your code is safe for reentrancy when using this function!\r\n    function sendETHAndVerify(\r\n        address to,\r\n        uint    amount,\r\n        uint    gasLimit\r\n        )\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        success = to.sendETH(amount, gasLimit);\r\n        require(success, \"TRANSFER_FAILURE\");\r\n    }\r\n\r\n    // Works like call but is slightly more efficient when data\r\n    // needs to be copied from memory to do the call.\r\n    function fastCall(\r\n        address to,\r\n        uint    gasLimit,\r\n        uint    value,\r\n        bytes   memory data\r\n        )\r\n        internal\r\n        returns (bool success, bytes memory returnData)\r\n    {\r\n        if (to != address(0)) {\r\n            assembly {\r\n                // Do the call\r\n                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\r\n                // Copy the return data\r\n                let size := returndatasize()\r\n                returnData := mload(0x40)\r\n                mstore(returnData, size)\r\n                returndatacopy(add(returnData, 32), 0, size)\r\n                // Update free memory pointer\r\n                mstore(0x40, add(returnData, add(32, size)))\r\n            }\r\n        }\r\n    }\r\n\r\n    // Like fastCall, but throws when the call is unsuccessful.\r\n    function fastCallAndVerify(\r\n        address to,\r\n        uint    gasLimit,\r\n        uint    value,\r\n        bytes   memory data\r\n        )\r\n        internal\r\n        returns (bytes memory returnData)\r\n    {\r\n        bool success;\r\n        (success, returnData) = fastCall(to, gasLimit, value, data);\r\n        if (!success) {\r\n            assembly {\r\n                revert(add(returnData, 32), mload(returnData))\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\nlibrary EIP712\r\n{\r\n    struct Domain {\r\n        string  name;\r\n        string  version;\r\n        address verifyingContract;\r\n    }\r\n\r\n    bytes32 constant internal EIP712_DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n    );\r\n\r\n    string constant internal EIP191_HEADER = \"\\x19\\x01\";\r\n\r\n    function hash(Domain memory domain)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        uint _chainid;\r\n        assembly { _chainid := chainid() }\r\n\r\n        return keccak256(\r\n            abi.encode(\r\n                EIP712_DOMAIN_TYPEHASH,\r\n                keccak256(bytes(domain.name)),\r\n                keccak256(bytes(domain.version)),\r\n                _chainid,\r\n                domain.verifyingContract\r\n            )\r\n        );\r\n    }\r\n\r\n    function hashPacked(\r\n        bytes32 domainHash,\r\n        bytes32 dataHash\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                EIP191_HEADER,\r\n                domainHash,\r\n                dataHash\r\n            )\r\n        );\r\n    }\r\n}\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title Utility Functions for uint\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary MathUint96\r\n{\r\n    function add(\r\n        uint96 a,\r\n        uint96 b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint96 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"ADD_OVERFLOW\");\r\n    }\r\n\r\n    function sub(\r\n        uint96 a,\r\n        uint96 b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint96 c)\r\n    {\r\n        require(b <= a, \"SUB_UNDERFLOW\");\r\n        return a - b;\r\n    }\r\n}\r\n\r\n// Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeCast.sol\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint96 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint96).\r\n     *\r\n     * Counterpart to Solidity's `uint96` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 96 bits\r\n     */\r\n    function toUint96(uint256 value) internal pure returns (uint96) {\r\n        require(value < 2**96, \"SafeCast: value doesn\\'t fit in 96 bits\");\r\n        return uint96(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint40 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint40).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 40 bits\r\n     */\r\n    function toUint40(uint256 value) internal pure returns (uint40) {\r\n        require(value < 2**40, \"SafeCast: value doesn\\'t fit in 40 bits\");\r\n        return uint40(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title Ownable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev The Ownable contract has an owner address, and provides basic\r\n///      authorization control functions, this simplifies the implementation of\r\n///      \"user permissions\".\r\ncontract Ownable\r\n{\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract\r\n    ///      to the sender.\r\n    constructor()\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a\r\n    ///      new owner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n/// @title Claimable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Extension for the Ownable contract, where the ownership needs\r\n///      to be claimed. This allows the new owner to accept the transfer.\r\ncontract Claimable is Ownable\r\n{\r\n    address public pendingOwner;\r\n\r\n    /// @dev Modifier throws if called by any account other than the pendingOwner.\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to set the pendingOwner address.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /// @dev Allows the pendingOwner address to finalize the transfer.\r\n    function claimOwnership()\r\n        public\r\n        onlyPendingOwner\r\n    {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ExchangeSignatures.\r\n/// @dev All methods in this lib are internal, therefore, there is no need\r\n///      to deploy this library independently.\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\nlibrary ExchangeSignatures\r\n{\r\n    using SignatureUtil for bytes32;\r\n\r\n    function requireAuthorizedTx(\r\n        ExchangeData.State storage S,\r\n        address signer,\r\n        bytes memory signature,\r\n        bytes32 txHash\r\n        )\r\n        internal // inline call\r\n    {\r\n        require(signer != address(0), \"INVALID_SIGNER\");\r\n        // Verify the signature if one is provided, otherwise fall back to an approved tx\r\n        if (signature.length > 0) {\r\n            require(txHash.verifySignature(signer, signature), \"INVALID_SIGNATURE\");\r\n        } else {\r\n            require(S.approvedTx[signer][txHash], \"TX_NOT_APPROVED\");\r\n            delete S.approvedTx[signer][txHash];\r\n        }\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title AmmUpdateTransaction\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary AmmUpdateTransaction\r\n{\r\n    using BytesUtil            for bytes;\r\n    using MathUint             for uint;\r\n    using ExchangeSignatures   for ExchangeData.State;\r\n\r\n    bytes32 constant public AMMUPDATE_TYPEHASH = keccak256(\r\n        \"AmmUpdate(address owner,uint32 accountID,uint16 tokenID,uint8 feeBips,uint96 tokenWeight,uint32 validUntil,uint32 nonce)\"\r\n    );\r\n\r\n    struct AmmUpdate\r\n    {\r\n        address owner;\r\n        uint32  accountID;\r\n        uint16  tokenID;\r\n        uint8   feeBips;\r\n        uint96  tokenWeight;\r\n        uint32  validUntil;\r\n        uint32  nonce;\r\n        uint96  balance;\r\n    }\r\n\r\n    // Auxiliary data for each AMM update\r\n    struct AmmUpdateAuxiliaryData\r\n    {\r\n        bytes  signature;\r\n        uint32 validUntil;\r\n    }\r\n\r\n    function process(\r\n        ExchangeData.State        storage S,\r\n        ExchangeData.BlockContext memory  ctx,\r\n        bytes                     memory  data,\r\n        uint                              offset,\r\n        bytes                     memory  auxiliaryData\r\n        )\r\n        internal\r\n    {\r\n        // Read in the AMM update\r\n        AmmUpdate memory update = readTx(data, offset);\r\n        AmmUpdateAuxiliaryData memory auxData = abi.decode(auxiliaryData, (AmmUpdateAuxiliaryData));\r\n\r\n        // Check validUntil\r\n        require(ctx.timestamp < auxData.validUntil, \"AMM_UPDATE_EXPIRED\");\r\n        update.validUntil = auxData.validUntil;\r\n\r\n        // Calculate the tx hash\r\n        bytes32 txHash = hashTx(ctx.DOMAIN_SEPARATOR, update);\r\n\r\n        // Check the on-chain authorization\r\n        S.requireAuthorizedTx(update.owner, auxData.signature, txHash);\r\n    }\r\n\r\n    function readTx(\r\n        bytes memory data,\r\n        uint         offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (AmmUpdate memory update)\r\n    {\r\n        uint _offset = offset;\r\n        // We don't use abi.decode for this because of the large amount of zero-padding\r\n        // bytes the circuit would also have to hash.\r\n        update.owner = data.toAddress(_offset);\r\n        _offset += 20;\r\n        update.accountID = data.toUint32(_offset);\r\n        _offset += 4;\r\n        update.tokenID = data.toUint16(_offset);\r\n        _offset += 2;\r\n        update.feeBips = data.toUint8(_offset);\r\n        _offset += 1;\r\n        update.tokenWeight = data.toUint96(_offset);\r\n        _offset += 12;\r\n        update.nonce = data.toUint32(_offset);\r\n        _offset += 4;\r\n        update.balance = data.toUint96(_offset);\r\n        _offset += 12;\r\n    }\r\n\r\n    function hashTx(\r\n        bytes32 DOMAIN_SEPARATOR,\r\n        AmmUpdate memory update\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return EIP712.hashPacked(\r\n            DOMAIN_SEPARATOR,\r\n            keccak256(\r\n                abi.encode(\r\n                    AMMUPDATE_TYPEHASH,\r\n                    update.owner,\r\n                    update.accountID,\r\n                    update.tokenID,\r\n                    update.feeBips,\r\n                    update.tokenWeight,\r\n                    update.validUntil,\r\n                    update.nonce\r\n                )\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title BlockReader\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Utility library to read block data.\r\nlibrary BlockReader {\r\n    using BlockReader       for ExchangeData.Block;\r\n    using BytesUtil         for bytes;\r\n\r\n    uint public constant OFFSET_TO_TRANSACTIONS = 20 + 32 + 32 + 4 + 1 + 1 + 4 + 4;\r\n\r\n    struct BlockHeader\r\n    {\r\n        address exchange;\r\n        bytes32 merkleRootBefore;\r\n        bytes32 merkleRootAfter;\r\n        uint32  timestamp;\r\n        uint8   protocolTakerFeeBips;\r\n        uint8   protocolMakerFeeBips;\r\n        uint32  numConditionalTransactions;\r\n        uint32  operatorAccountID;\r\n    }\r\n\r\n    function readHeader(\r\n        ExchangeData.Block memory _block\r\n        )\r\n        internal\r\n        pure\r\n        returns (BlockHeader memory header)\r\n    {\r\n        uint offset = 0;\r\n        header.exchange = _block.data.toAddress(offset);\r\n        offset += 20;\r\n        header.merkleRootBefore = _block.data.toBytes32(offset);\r\n        offset += 32;\r\n        header.merkleRootAfter = _block.data.toBytes32(offset);\r\n        offset += 32;\r\n        header.timestamp = _block.data.toUint32(offset);\r\n        offset += 4;\r\n        header.protocolTakerFeeBips = _block.data.toUint8(offset);\r\n        offset += 1;\r\n        header.protocolMakerFeeBips = _block.data.toUint8(offset);\r\n        offset += 1;\r\n        header.numConditionalTransactions = _block.data.toUint32(offset);\r\n        offset += 4;\r\n        header.operatorAccountID = _block.data.toUint32(offset);\r\n        offset += 4;\r\n        assert(offset == OFFSET_TO_TRANSACTIONS);\r\n    }\r\n\r\n    function readTransactionData(\r\n        ExchangeData.Block memory _block,\r\n        uint txIdx\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(txIdx < _block.blockSize, \"INVALID_TX_IDX\");\r\n\r\n        bytes memory data = _block.data;\r\n\r\n        // The transaction was transformed to make it easier to compress.\r\n        // Transform it back here.\r\n        bytes memory txData = new bytes(ExchangeData.TX_DATA_AVAILABILITY_SIZE());\r\n        // Part 1\r\n        uint txDataOffset = OFFSET_TO_TRANSACTIONS +\r\n            txIdx * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_1();\r\n        assembly {\r\n            mstore(add(txData, 32), mload(add(data, add(txDataOffset, 32))))\r\n        }\r\n        // Part 2\r\n        txDataOffset = OFFSET_TO_TRANSACTIONS +\r\n            _block.blockSize * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_1() +\r\n            txIdx * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_2();\r\n        assembly {\r\n            mstore(add(txData, 61 /*32 + 29*/), mload(add(data, add(txDataOffset, 32))))\r\n            mstore(add(txData, 68            ), mload(add(data, add(txDataOffset, 39))))\r\n        }\r\n        return txData;\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title ERC20 Token Interface\r\n/// @dev see https://github.com/ethereum/EIPs/issues/20\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nabstract contract ERC20\r\n{\r\n    function totalSupply()\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint);\r\n\r\n    function balanceOf(\r\n        address who\r\n        )\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n        )\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint value\r\n        )\r\n        public\r\n        virtual\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint    value\r\n        )\r\n        public\r\n        virtual\r\n        returns (bool);\r\n\r\n    function approve(\r\n        address spender,\r\n        uint    value\r\n        )\r\n        public\r\n        virtual\r\n        returns (bool);\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Utility Functions for floats\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary FloatUtil\r\n{\r\n    using MathUint for uint;\r\n    using SafeCast for uint;\r\n\r\n    // Decodes a decimal float value that is encoded like `exponent | mantissa`.\r\n    // Both exponent and mantissa are in base 10.\r\n    // Decoding to an integer is as simple as `mantissa * (10 ** exponent)`\r\n    // Will throw when the decoded value overflows an uint96\r\n    /// @param f The float value with 5 bits for the exponent\r\n    /// @param numBits The total number of bits (numBitsMantissa := numBits - numBitsExponent)\r\n    /// @return value The decoded integer value.\r\n    function decodeFloat(\r\n        uint f,\r\n        uint numBits\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint96 value)\r\n    {\r\n        uint numBitsMantissa = numBits.sub(5);\r\n        uint exponent = f >> numBitsMantissa;\r\n        // log2(10**77) = 255.79 < 256\r\n        require(exponent <= 77, \"EXPONENT_TOO_LARGE\");\r\n        uint mantissa = f & ((1 << numBitsMantissa) - 1);\r\n        value = mantissa.mul(10 ** exponent).toUint96();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title TransferTransaction\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary TransferTransaction\r\n{\r\n    using BytesUtil            for bytes;\r\n    using FloatUtil            for uint;\r\n    using MathUint             for uint;\r\n    using ExchangeSignatures   for ExchangeData.State;\r\n\r\n    bytes32 constant public TRANSFER_TYPEHASH = keccak256(\r\n        \"Transfer(address from,address to,uint16 tokenID,uint96 amount,uint16 feeTokenID,uint96 maxFee,uint32 validUntil,uint32 storageID)\"\r\n    );\r\n\r\n    struct Transfer\r\n    {\r\n        uint32  fromAccountID;\r\n        uint32  toAccountID;\r\n        address from;\r\n        address to;\r\n        uint16  tokenID;\r\n        uint96  amount;\r\n        uint16  feeTokenID;\r\n        uint96  maxFee;\r\n        uint96  fee;\r\n        uint32  validUntil;\r\n        uint32  storageID;\r\n    }\r\n\r\n    // Auxiliary data for each transfer\r\n    struct TransferAuxiliaryData\r\n    {\r\n        bytes  signature;\r\n        uint96 maxFee;\r\n        uint32 validUntil;\r\n    }\r\n\r\n    function process(\r\n        ExchangeData.State        storage S,\r\n        ExchangeData.BlockContext memory  ctx,\r\n        bytes                     memory  data,\r\n        uint                              offset,\r\n        bytes                     memory  auxiliaryData\r\n        )\r\n        internal\r\n    {\r\n        // Read the transfer\r\n        Transfer memory transfer = readTx(data, offset);\r\n        TransferAuxiliaryData memory auxData = abi.decode(auxiliaryData, (TransferAuxiliaryData));\r\n\r\n        // Fill in withdrawal data missing from DA\r\n        transfer.validUntil = auxData.validUntil;\r\n        transfer.maxFee = auxData.maxFee == 0 ? transfer.fee : auxData.maxFee;\r\n        // Validate\r\n        require(ctx.timestamp < transfer.validUntil, \"TRANSFER_EXPIRED\");\r\n        require(transfer.fee <= transfer.maxFee, \"TRANSFER_FEE_TOO_HIGH\");\r\n\r\n        // Calculate the tx hash\r\n        bytes32 txHash = hashTx(ctx.DOMAIN_SEPARATOR, transfer);\r\n\r\n        // Check the on-chain authorization\r\n        S.requireAuthorizedTx(transfer.from, auxData.signature, txHash);\r\n    }\r\n\r\n    function readTx(\r\n        bytes memory data,\r\n        uint         offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (Transfer memory transfer)\r\n    {\r\n        uint _offset = offset;\r\n        // Check that this is a conditional transfer\r\n        require(data.toUint8(_offset) == 1, \"INVALID_AUXILIARYDATA_DATA\");\r\n        _offset += 1;\r\n\r\n        // Extract the transfer data\r\n        // We don't use abi.decode for this because of the large amount of zero-padding\r\n        // bytes the circuit would also have to hash.\r\n        transfer.fromAccountID = data.toUint32(_offset);\r\n        _offset += 4;\r\n        transfer.toAccountID = data.toUint32(_offset);\r\n        _offset += 4;\r\n        transfer.tokenID = data.toUint16(_offset);\r\n        _offset += 2;\r\n        transfer.amount = uint(data.toUint24(_offset)).decodeFloat(24);\r\n        _offset += 3;\r\n        transfer.feeTokenID = data.toUint16(_offset);\r\n        _offset += 2;\r\n        transfer.fee = uint(data.toUint16(_offset)).decodeFloat(16);\r\n        _offset += 2;\r\n        transfer.storageID = data.toUint32(_offset);\r\n        _offset += 4;\r\n        transfer.to = data.toAddress(_offset);\r\n        _offset += 20;\r\n        transfer.from = data.toAddress(_offset);\r\n        _offset += 20;\r\n    }\r\n\r\n    function hashTx(\r\n        bytes32 DOMAIN_SEPARATOR,\r\n        Transfer memory transfer\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return EIP712.hashPacked(\r\n            DOMAIN_SEPARATOR,\r\n            keccak256(\r\n                abi.encode(\r\n                    TRANSFER_TYPEHASH,\r\n                    transfer.from,\r\n                    transfer.to,\r\n                    transfer.tokenID,\r\n                    transfer.amount,\r\n                    transfer.feeTokenID,\r\n                    transfer.maxFee,\r\n                    transfer.validUntil,\r\n                    transfer.storageID\r\n                )\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title DepositTransaction\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary DepositTransaction\r\n{\r\n    using BytesUtil   for bytes;\r\n    using MathUint96  for uint96;\r\n\r\n    struct Deposit\r\n    {\r\n        address to;\r\n        uint32  toAccountID;\r\n        uint16  tokenID;\r\n        uint96  amount;\r\n    }\r\n\r\n    function process(\r\n        ExchangeData.State        storage S,\r\n        ExchangeData.BlockContext memory  /*ctx*/,\r\n        bytes                     memory  data,\r\n        uint                              offset,\r\n        bytes                     memory  /*auxiliaryData*/\r\n        )\r\n        internal\r\n    {\r\n        // Read in the deposit\r\n        Deposit memory deposit = readTx(data, offset);\r\n        if (deposit.amount == 0) {\r\n            return;\r\n        }\r\n\r\n        // Process the deposit\r\n        ExchangeData.Deposit memory pendingDeposit = S.pendingDeposits[deposit.to][deposit.tokenID];\r\n        // Make sure the deposit was actually done\r\n        require(pendingDeposit.timestamp > 0, \"DEPOSIT_DOESNT_EXIST\");\r\n\r\n        // Processing partial amounts of the deposited amount is allowed.\r\n        // This is done to ensure the user can do multiple deposits after each other\r\n        // without invalidating work done by the exchange owner for previous deposit amounts.\r\n\r\n        require(pendingDeposit.amount >= deposit.amount, \"INVALID_AMOUNT\");\r\n        pendingDeposit.amount = pendingDeposit.amount.sub(deposit.amount);\r\n\r\n        // If the deposit was fully consumed, reset it so the storage is freed up\r\n        // and the owner receives a gas refund.\r\n        if (pendingDeposit.amount == 0) {\r\n            delete S.pendingDeposits[deposit.to][deposit.tokenID];\r\n        } else {\r\n            S.pendingDeposits[deposit.to][deposit.tokenID] = pendingDeposit;\r\n        }\r\n    }\r\n\r\n    function readTx(\r\n        bytes memory data,\r\n        uint         offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (Deposit memory deposit)\r\n    {\r\n        uint _offset = offset;\r\n        // We don't use abi.decode for this because of the large amount of zero-padding\r\n        // bytes the circuit would also have to hash.\r\n        deposit.to = data.toAddress(_offset);\r\n        _offset += 20;\r\n        deposit.toAccountID = data.toUint32(_offset);\r\n        _offset += 4;\r\n        deposit.tokenID = data.toUint16(_offset);\r\n        _offset += 2;\r\n        deposit.amount = data.toUint96(_offset);\r\n        _offset += 12;\r\n    }\r\n}\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ExchangeMode.\r\n/// @dev All methods in this lib are internal, therefore, there is no need\r\n///      to deploy this library independently.\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\nlibrary ExchangeMode\r\n{\r\n    using MathUint  for uint;\r\n\r\n    function isInWithdrawalMode(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool result)\r\n    {\r\n        result = S.withdrawalModeStartTime > 0;\r\n    }\r\n\r\n    function isShutdown(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal // inline call\r\n        view\r\n        returns (bool)\r\n    {\r\n        return S.shutdownModeStartTime > 0;\r\n    }\r\n\r\n    function getNumAvailableForcedSlots(\r\n        ExchangeData.State storage S\r\n        )\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        return ExchangeData.MAX_OPEN_FORCED_REQUESTS() - S.numPendingForcedTransactions;\r\n    }\r\n}\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ExchangeWithdrawals.\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\nlibrary ExchangeWithdrawals\r\n{\r\n    enum WithdrawalCategory\r\n    {\r\n        DISTRIBUTION,\r\n        FROM_MERKLE_TREE,\r\n        FROM_DEPOSIT_REQUEST,\r\n        FROM_APPROVED_WITHDRAWAL\r\n    }\r\n\r\n    using AddressUtil       for address;\r\n    using AddressUtil       for address payable;\r\n    using BytesUtil         for bytes;\r\n    using MathUint          for uint;\r\n    using ExchangeBalances  for ExchangeData.State;\r\n    using ExchangeMode      for ExchangeData.State;\r\n    using ExchangeTokens    for ExchangeData.State;\r\n\r\n    event ForcedWithdrawalRequested(\r\n        address owner,\r\n        address token,\r\n        uint32  accountID\r\n    );\r\n\r\n    event WithdrawalCompleted(\r\n        uint8   category,\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint    amount\r\n    );\r\n\r\n    event WithdrawalFailed(\r\n        uint8   category,\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint    amount\r\n    );\r\n\r\n    function forceWithdraw(\r\n        ExchangeData.State storage S,\r\n        address owner,\r\n        address token,\r\n        uint32  accountID\r\n        )\r\n        public\r\n    {\r\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\r\n        // Limit the amount of pending forced withdrawals so that the owner cannot be overwhelmed.\r\n        require(S.getNumAvailableForcedSlots() > 0, \"TOO_MANY_REQUESTS_OPEN\");\r\n        require(accountID < ExchangeData.MAX_NUM_ACCOUNTS(), \"INVALID_ACCOUNTID\");\r\n\r\n        uint16 tokenID = S.getTokenID(token);\r\n\r\n        // A user needs to pay a fixed ETH withdrawal fee, set by the protocol.\r\n        uint withdrawalFeeETH = S.loopring.forcedWithdrawalFee();\r\n\r\n        // Check ETH value sent, can be larger than the expected withdraw fee\r\n        require(msg.value >= withdrawalFeeETH, \"INSUFFICIENT_FEE\");\r\n\r\n        // Send surplus of ETH back to the sender\r\n        uint feeSurplus = msg.value.sub(withdrawalFeeETH);\r\n        if (feeSurplus > 0) {\r\n            msg.sender.sendETHAndVerify(feeSurplus, gasleft());\r\n        }\r\n\r\n        // There can only be a single forced withdrawal per (account, token) pair.\r\n        require(\r\n            S.pendingForcedWithdrawals[accountID][tokenID].timestamp == 0,\r\n            \"WITHDRAWAL_ALREADY_PENDING\"\r\n        );\r\n\r\n        // Store the forced withdrawal request data\r\n        S.pendingForcedWithdrawals[accountID][tokenID] = ExchangeData.ForcedWithdrawal({\r\n            owner: owner,\r\n            timestamp: uint64(block.timestamp)\r\n        });\r\n\r\n        // Increment the number of pending forced transactions so we can keep count.\r\n        S.numPendingForcedTransactions++;\r\n\r\n        emit ForcedWithdrawalRequested(\r\n            owner,\r\n            token,\r\n            accountID\r\n        );\r\n    }\r\n\r\n    // We alow anyone to withdraw these funds for the account owner\r\n    function withdrawFromMerkleTree(\r\n        ExchangeData.State       storage S,\r\n        ExchangeData.MerkleProof calldata merkleProof\r\n        )\r\n        public\r\n    {\r\n        require(S.isInWithdrawalMode(), \"NOT_IN_WITHDRAW_MODE\");\r\n\r\n        address owner = merkleProof.accountLeaf.owner;\r\n        uint32 accountID = merkleProof.accountLeaf.accountID;\r\n        uint16 tokenID = merkleProof.balanceLeaf.tokenID;\r\n        uint96 balance = merkleProof.balanceLeaf.balance;\r\n\r\n        // Make sure the funds aren't withdrawn already.\r\n        require(S.withdrawnInWithdrawMode[accountID][tokenID] == false, \"WITHDRAWN_ALREADY\");\r\n\r\n        // Verify that the provided Merkle tree data is valid by using the Merkle proof.\r\n        ExchangeBalances.verifyAccountBalance(\r\n            uint(S.merkleRoot),\r\n            merkleProof\r\n        );\r\n\r\n        // Make sure the balance can only be withdrawn once\r\n        S.withdrawnInWithdrawMode[accountID][tokenID] = true;\r\n\r\n        // Transfer the tokens to the account owner\r\n        transferTokens(\r\n            S,\r\n            uint8(WithdrawalCategory.FROM_MERKLE_TREE),\r\n            owner,\r\n            owner,\r\n            tokenID,\r\n            balance,\r\n            new bytes(0),\r\n            gasleft(),\r\n            false\r\n        );\r\n    }\r\n\r\n    function withdrawFromDepositRequest(\r\n        ExchangeData.State storage S,\r\n        address owner,\r\n        address token\r\n        )\r\n        public\r\n    {\r\n        uint16 tokenID = S.getTokenID(token);\r\n        ExchangeData.Deposit storage deposit = S.pendingDeposits[owner][tokenID];\r\n        require(deposit.timestamp != 0, \"DEPOSIT_NOT_WITHDRAWABLE_YET\");\r\n\r\n        // Check if the deposit has indeed exceeded the time limit of if the exchange is in withdrawal mode\r\n        require(\r\n            block.timestamp >= deposit.timestamp + S.maxAgeDepositUntilWithdrawable ||\r\n            S.isInWithdrawalMode(),\r\n            \"DEPOSIT_NOT_WITHDRAWABLE_YET\"\r\n        );\r\n\r\n        uint amount = deposit.amount;\r\n\r\n        // Reset the deposit request\r\n        delete S.pendingDeposits[owner][tokenID];\r\n\r\n        // Transfer the tokens\r\n        transferTokens(\r\n            S,\r\n            uint8(WithdrawalCategory.FROM_DEPOSIT_REQUEST),\r\n            owner,\r\n            owner,\r\n            tokenID,\r\n            amount,\r\n            new bytes(0),\r\n            gasleft(),\r\n            false\r\n        );\r\n    }\r\n\r\n    function withdrawFromApprovedWithdrawals(\r\n        ExchangeData.State storage S,\r\n        address[] memory owners,\r\n        address[] memory tokens\r\n        )\r\n        public\r\n    {\r\n        require(owners.length == tokens.length, \"INVALID_INPUT_DATA\");\r\n        for (uint i = 0; i < owners.length; i++) {\r\n            address owner = owners[i];\r\n            uint16 tokenID = S.getTokenID(tokens[i]);\r\n            uint amount = S.amountWithdrawable[owner][tokenID];\r\n\r\n            // Make sure this amount can't be withdrawn again\r\n            delete S.amountWithdrawable[owner][tokenID];\r\n\r\n            // Transfer the tokens to the owner\r\n            transferTokens(\r\n                S,\r\n                uint8(WithdrawalCategory.FROM_APPROVED_WITHDRAWAL),\r\n                owner,\r\n                owner,\r\n                tokenID,\r\n                amount,\r\n                new bytes(0),\r\n                gasleft(),\r\n                false\r\n            );\r\n        }\r\n    }\r\n\r\n    function distributeWithdrawal(\r\n        ExchangeData.State storage S,\r\n        address from,\r\n        address to,\r\n        uint16  tokenID,\r\n        uint    amount,\r\n        bytes   memory extraData,\r\n        uint    gasLimit\r\n        )\r\n        public\r\n    {\r\n        // Try to transfer the tokens\r\n        bool success = transferTokens(\r\n            S,\r\n            uint8(WithdrawalCategory.DISTRIBUTION),\r\n            from,\r\n            to,\r\n            tokenID,\r\n            amount,\r\n            extraData,\r\n            gasLimit,\r\n            true\r\n        );\r\n        // If the transfer was successful there's nothing left to do.\r\n        // However, if the transfer failed the tokens are still in the contract and can be\r\n        // withdrawn later to `to` by anyone by using `withdrawFromApprovedWithdrawal.\r\n        if (!success) {\r\n            S.amountWithdrawable[to][tokenID] = S.amountWithdrawable[to][tokenID].add(amount);\r\n        }\r\n    }\r\n\r\n    // == Internal and Private Functions ==\r\n\r\n    // If allowFailure is true the transfer can fail because of a transfer error or\r\n    // because the transfer uses more than `gasLimit` gas. The function\r\n    // will return true when successful, false otherwise.\r\n    // If allowFailure is false the transfer is guaranteed to succeed using\r\n    // as much gas as needed, otherwise it throws. The function always returns true.\r\n    function transferTokens(\r\n        ExchangeData.State storage S,\r\n        uint8   category,\r\n        address from,\r\n        address to,\r\n        uint16  tokenID,\r\n        uint    amount,\r\n        bytes   memory extraData,\r\n        uint    gasLimit,\r\n        bool    allowFailure\r\n        )\r\n        private\r\n        returns (bool success)\r\n    {\r\n        // Redirect withdrawals to address(0) to the protocol fee vault\r\n        if (to == address(0)) {\r\n            to = S.loopring.protocolFeeVault();\r\n        }\r\n        address token = S.getTokenAddress(tokenID);\r\n\r\n        // Transfer the tokens from the deposit contract to the owner\r\n        if (gasLimit > 0) {\r\n            try S.depositContract.withdraw{gas: gasLimit}(from, to, token, amount, extraData) {\r\n                success = true;\r\n            } catch {\r\n                success = false;\r\n            }\r\n        } else {\r\n            success = false;\r\n        }\r\n\r\n        require(allowFailure || success, \"TRANSFER_FAILURE\");\r\n\r\n        if (success) {\r\n            emit WithdrawalCompleted(category, from, to, token, amount);\r\n\r\n            // Keep track of when the protocol fees were last withdrawn\r\n            // (only done to make this data easier available).\r\n            if (from == address(0)) {\r\n                S.protocolFeeLastWithdrawnTime[token] = block.timestamp;\r\n            }\r\n        } else {\r\n            emit WithdrawalFailed(category, from, to, token, amount);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title WithdrawTransaction\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev The following 4 types of withdrawals are supported:\r\n///      - withdrawType = 0: offchain withdrawals with EdDSA signatures\r\n///      - withdrawType = 1: offchain withdrawals with ECDSA signatures or onchain appprovals\r\n///      - withdrawType = 2: onchain valid forced withdrawals (owner and accountID match), or\r\n///                          offchain operator-initiated withdrawals for protocol fees or for\r\n///                          users in shutdown mode\r\n///      - withdrawType = 3: onchain invalid forced withdrawals (owner and accountID mismatch)\r\nlibrary WithdrawTransaction\r\n{\r\n    using BytesUtil            for bytes;\r\n    using FloatUtil            for uint;\r\n    using MathUint             for uint;\r\n    using ExchangeMode         for ExchangeData.State;\r\n    using ExchangeSignatures   for ExchangeData.State;\r\n    using ExchangeWithdrawals  for ExchangeData.State;\r\n\r\n    bytes32 constant public WITHDRAWAL_TYPEHASH = keccak256(\r\n        \"Withdrawal(address owner,uint32 accountID,uint16 tokenID,uint96 amount,uint16 feeTokenID,uint96 maxFee,address to,bytes extraData,uint256 minGas,uint32 validUntil,uint32 storageID)\"\r\n    );\r\n\r\n    struct Withdrawal\r\n    {\r\n        uint    withdrawalType;\r\n        address from;\r\n        uint32  fromAccountID;\r\n        uint16  tokenID;\r\n        uint96  amount;\r\n        uint16  feeTokenID;\r\n        uint96  maxFee;\r\n        uint96  fee;\r\n        address to;\r\n        bytes   extraData;\r\n        uint    minGas;\r\n        uint32  validUntil;\r\n        uint32  storageID;\r\n        bytes20 onchainDataHash;\r\n    }\r\n\r\n    // Auxiliary data for each withdrawal\r\n    struct WithdrawalAuxiliaryData\r\n    {\r\n        bool  storeRecipient;\r\n        uint  gasLimit;\r\n        bytes signature;\r\n\r\n        uint    minGas;\r\n        address to;\r\n        bytes   extraData;\r\n        uint96  maxFee;\r\n        uint32  validUntil;\r\n    }\r\n\r\n    function process(\r\n        ExchangeData.State        storage S,\r\n        ExchangeData.BlockContext memory  ctx,\r\n        bytes                     memory  data,\r\n        uint                              offset,\r\n        bytes                     memory  auxiliaryData\r\n        )\r\n        internal\r\n    {\r\n        Withdrawal memory withdrawal = readTx(data, offset);\r\n        WithdrawalAuxiliaryData memory auxData = abi.decode(auxiliaryData, (WithdrawalAuxiliaryData));\r\n\r\n        // Validate the withdrawal data not directly part of the DA\r\n        bytes20 onchainDataHash = hashOnchainData(\r\n            auxData.minGas,\r\n            auxData.to,\r\n            auxData.extraData\r\n        );\r\n        // Only the 20 MSB are used, which is still 80-bit of security, which is more\r\n        // than enough, especially when combined with validUntil.\r\n        require(withdrawal.onchainDataHash == onchainDataHash, \"INVALID_WITHDRAWAL_DATA\");\r\n\r\n        // Fill in withdrawal data missing from DA\r\n        withdrawal.to = auxData.to;\r\n        withdrawal.minGas = auxData.minGas;\r\n        withdrawal.extraData = auxData.extraData;\r\n        withdrawal.maxFee = auxData.maxFee == 0 ? withdrawal.fee : auxData.maxFee;\r\n        withdrawal.validUntil = auxData.validUntil;\r\n\r\n        // If the account has an owner, don't allow withdrawing to the zero address\r\n        // (which will be the protocol fee vault contract).\r\n        require(withdrawal.from == address(0) || withdrawal.to != address(0), \"INVALID_WITHDRAWAL_RECIPIENT\");\r\n\r\n        if (withdrawal.withdrawalType == 0) {\r\n            // Signature checked offchain, nothing to do\r\n        } else if (withdrawal.withdrawalType == 1) {\r\n            // Validate\r\n            require(ctx.timestamp < withdrawal.validUntil, \"WITHDRAWAL_EXPIRED\");\r\n            require(withdrawal.fee <= withdrawal.maxFee, \"WITHDRAWAL_FEE_TOO_HIGH\");\r\n\r\n            // Check appproval onchain\r\n            // Calculate the tx hash\r\n            bytes32 txHash = hashTx(ctx.DOMAIN_SEPARATOR, withdrawal);\r\n            // Check onchain authorization\r\n            S.requireAuthorizedTx(withdrawal.from, auxData.signature, txHash);\r\n        } else if (withdrawal.withdrawalType == 2 || withdrawal.withdrawalType == 3) {\r\n            // Forced withdrawals cannot make use of certain features because the\r\n            // necessary data is not authorized by the account owner.\r\n            // For protocol fee withdrawals, `owner` and `to` are both address(0).\r\n            require(withdrawal.from == withdrawal.to, \"INVALID_WITHDRAWAL_ADDRESS\");\r\n\r\n            // Forced withdrawal fees are charged when the request is submitted.\r\n            require(withdrawal.fee == 0, \"FEE_NOT_ZERO\");\r\n\r\n            require(withdrawal.extraData.length == 0, \"AUXILIARY_DATA_NOT_ALLOWED\");\r\n\r\n            ExchangeData.ForcedWithdrawal memory forcedWithdrawal =\r\n                S.pendingForcedWithdrawals[withdrawal.fromAccountID][withdrawal.tokenID];\r\n\r\n            if (forcedWithdrawal.timestamp != 0) {\r\n                if (withdrawal.withdrawalType == 2) {\r\n                    require(withdrawal.from == forcedWithdrawal.owner, \"INCONSISENT_OWNER\");\r\n                } else { //withdrawal.withdrawalType == 3\r\n                    require(withdrawal.from != forcedWithdrawal.owner, \"INCONSISENT_OWNER\");\r\n                    require(withdrawal.amount == 0, \"UNAUTHORIZED_WITHDRAWAL\");\r\n                }\r\n\r\n                // delete the withdrawal request and free a slot\r\n                delete S.pendingForcedWithdrawals[withdrawal.fromAccountID][withdrawal.tokenID];\r\n                S.numPendingForcedTransactions--;\r\n            } else {\r\n                // Allow the owner to submit full withdrawals without authorization\r\n                // - when in shutdown mode\r\n                // - to withdraw protocol fees\r\n                require(\r\n                    withdrawal.fromAccountID == ExchangeData.ACCOUNTID_PROTOCOLFEE() ||\r\n                    S.isShutdown(),\r\n                    \"FULL_WITHDRAWAL_UNAUTHORIZED\"\r\n                );\r\n            }\r\n        } else {\r\n            revert(\"INVALID_WITHDRAWAL_TYPE\");\r\n        }\r\n\r\n        // Check if there is a withdrawal recipient\r\n        address recipient = S.withdrawalRecipient[withdrawal.from][withdrawal.to][withdrawal.tokenID][withdrawal.amount][withdrawal.storageID];\r\n        if (recipient != address(0)) {\r\n            // Auxiliary data is not supported\r\n            require (withdrawal.extraData.length == 0, \"AUXILIARY_DATA_NOT_ALLOWED\");\r\n\r\n            // Set the new recipient address\r\n            withdrawal.to = recipient;\r\n            // Allow any amount of gas to be used on this withdrawal (which allows the transfer to be skipped)\r\n            withdrawal.minGas = 0;\r\n\r\n            // Do NOT delete the recipient to prevent replay attack\r\n            // delete S.withdrawalRecipient[withdrawal.owner][withdrawal.to][withdrawal.tokenID][withdrawal.amount][withdrawal.storageID];\r\n        } else if (auxData.storeRecipient) {\r\n            // Store the destination address to mark the withdrawal as done\r\n            require(withdrawal.to != address(0), \"INVALID_DESTINATION_ADDRESS\");\r\n            S.withdrawalRecipient[withdrawal.from][withdrawal.to][withdrawal.tokenID][withdrawal.amount][withdrawal.storageID] = withdrawal.to;\r\n        }\r\n\r\n        // Validate gas provided\r\n        require(auxData.gasLimit >= withdrawal.minGas, \"OUT_OF_GAS_FOR_WITHDRAWAL\");\r\n\r\n        // Try to transfer the tokens with the provided gas limit\r\n        S.distributeWithdrawal(\r\n            withdrawal.from,\r\n            withdrawal.to,\r\n            withdrawal.tokenID,\r\n            withdrawal.amount,\r\n            withdrawal.extraData,\r\n            auxData.gasLimit\r\n        );\r\n    }\r\n\r\n    function readTx(\r\n        bytes memory data,\r\n        uint         offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (Withdrawal memory withdrawal)\r\n    {\r\n        uint _offset = offset;\r\n        // Extract the transfer data\r\n        // We don't use abi.decode for this because of the large amount of zero-padding\r\n        // bytes the circuit would also have to hash.\r\n        withdrawal.withdrawalType = data.toUint8(_offset);\r\n        _offset += 1;\r\n        withdrawal.from = data.toAddress(_offset);\r\n        _offset += 20;\r\n        withdrawal.fromAccountID = data.toUint32(_offset);\r\n        _offset += 4;\r\n        withdrawal.tokenID = data.toUint16(_offset);\r\n        _offset += 2;\r\n        withdrawal.amount = data.toUint96(_offset);\r\n        _offset += 12;\r\n        withdrawal.feeTokenID = data.toUint16(_offset);\r\n        _offset += 2;\r\n        withdrawal.fee = uint(data.toUint16(_offset)).decodeFloat(16);\r\n        _offset += 2;\r\n        withdrawal.storageID = data.toUint32(_offset);\r\n        _offset += 4;\r\n        withdrawal.onchainDataHash = data.toBytes20(_offset);\r\n        _offset += 20;\r\n    }\r\n\r\n    function hashTx(\r\n        bytes32 DOMAIN_SEPARATOR,\r\n        Withdrawal memory withdrawal\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return EIP712.hashPacked(\r\n            DOMAIN_SEPARATOR,\r\n            keccak256(\r\n                abi.encode(\r\n                    WITHDRAWAL_TYPEHASH,\r\n                    withdrawal.from,\r\n                    withdrawal.fromAccountID,\r\n                    withdrawal.tokenID,\r\n                    withdrawal.amount,\r\n                    withdrawal.feeTokenID,\r\n                    withdrawal.maxFee,\r\n                    withdrawal.to,\r\n                    keccak256(withdrawal.extraData),\r\n                    withdrawal.minGas,\r\n                    withdrawal.validUntil,\r\n                    withdrawal.storageID\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    function hashOnchainData(\r\n        uint    minGas,\r\n        address to,\r\n        bytes   memory extraData\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes20)\r\n    {\r\n        // Only the 20 MSB are used, which is still 80-bit of security, which is more\r\n        // than enough, especially when combined with validUntil.\r\n        return bytes20(keccak256(\r\n            abi.encodePacked(\r\n                minGas,\r\n                to,\r\n                extraData\r\n            )\r\n        ));\r\n    }\r\n}\r\n\r\n\r\n/// @title TransactionReader\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Utility library to read transactions.\r\nlibrary TransactionReader {\r\n    using BlockReader       for ExchangeData.Block;\r\n    using TransactionReader for ExchangeData.Block;\r\n    using BytesUtil         for bytes;\r\n\r\n    function readDeposit(\r\n        ExchangeData.Block memory _block,\r\n        uint txIdx\r\n        )\r\n        internal\r\n        pure\r\n        returns (DepositTransaction.Deposit memory)\r\n    {\r\n        bytes memory data = _block.readTx(txIdx, ExchangeData.TransactionType.DEPOSIT);\r\n        return DepositTransaction.readTx(data, 1);\r\n    }\r\n\r\n    function readWithdrawal(\r\n        ExchangeData.Block memory _block,\r\n        uint txIdx\r\n        )\r\n        internal\r\n        pure\r\n        returns (WithdrawTransaction.Withdrawal memory)\r\n    {\r\n        bytes memory data = _block.readTx(txIdx, ExchangeData.TransactionType.WITHDRAWAL);\r\n        return WithdrawTransaction.readTx(data, 1);\r\n    }\r\n\r\n    function readAmmUpdate(\r\n        ExchangeData.Block memory _block,\r\n        uint txIdx\r\n        )\r\n        internal\r\n        pure\r\n        returns (AmmUpdateTransaction.AmmUpdate memory)\r\n    {\r\n        bytes memory data = _block.readTx(txIdx, ExchangeData.TransactionType.AMM_UPDATE);\r\n        return AmmUpdateTransaction.readTx(data, 1);\r\n    }\r\n\r\n    function readTransfer(\r\n        ExchangeData.Block memory _block,\r\n        uint txIdx\r\n        )\r\n        internal\r\n        pure\r\n        returns (TransferTransaction.Transfer memory)\r\n    {\r\n        bytes memory data = _block.readTx(txIdx, ExchangeData.TransactionType.TRANSFER);\r\n        return TransferTransaction.readTx(data, 1);\r\n    }\r\n\r\n    function readTx(\r\n        ExchangeData.Block memory _block,\r\n        uint txIdx,\r\n        ExchangeData.TransactionType txType\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes memory data)\r\n    {\r\n        data = _block.readTransactionData(txIdx);\r\n        require(txType == ExchangeData.TransactionType(data.toUint8(0)), \"UNEXPTECTED_TX_TYPE\");\r\n    }\r\n\r\n    function createMinimalBlock(\r\n        ExchangeData.Block memory _block,\r\n        uint txIdx,\r\n        uint16 numTransactions\r\n        )\r\n        internal\r\n        pure\r\n        returns (ExchangeData.Block memory)\r\n    {\r\n        ExchangeData.Block memory minimalBlock = ExchangeData.Block({\r\n            blockType: _block.blockType,\r\n            blockSize: numTransactions,\r\n            blockVersion: _block.blockVersion,\r\n            data: new bytes(0),\r\n            proof: _block.proof,\r\n            storeBlockInfoOnchain: _block.storeBlockInfoOnchain,\r\n            auxiliaryData: new ExchangeData.AuxiliaryData[](0),\r\n            offchainData: new bytes(0)\r\n        });\r\n\r\n        bytes memory header = _block.data.slice(0, BlockReader.OFFSET_TO_TRANSACTIONS);\r\n\r\n        // Extract the data of the transactions we want\r\n        // Part 1\r\n        uint txDataOffset = BlockReader.OFFSET_TO_TRANSACTIONS +\r\n            txIdx * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_1();\r\n        bytes memory dataPart1 = _block.data.slice(txDataOffset, numTransactions * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_1());\r\n        // Part 2\r\n        txDataOffset = BlockReader.OFFSET_TO_TRANSACTIONS +\r\n            _block.blockSize * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_1() +\r\n            txIdx * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_2();\r\n        bytes memory dataPart2 = _block.data.slice(txDataOffset, numTransactions * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_2());\r\n\r\n        // Set the data on the block in the standard format\r\n        minimalBlock.data = header.concat(dataPart1).concat(dataPart2);\r\n\r\n        return minimalBlock;\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\ninterface IAgent{}\r\n\r\ninterface IAgentRegistry\r\n{\r\n    /// @dev Returns whether an agent address is an agent of an account owner\r\n    /// @param owner The account owner.\r\n    /// @param agent The agent address\r\n    /// @return True if the agent address is an agent for the account owner, else false\r\n    function isAgent(\r\n        address owner,\r\n        address agent\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Returns whether an agent address is an agent of all account owners\r\n    /// @param owners The account owners.\r\n    /// @param agent The agent address\r\n    /// @return True if the agent address is an agent for the account owner, else false\r\n    function isAgent(\r\n        address[] calldata owners,\r\n        address            agent\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title IBlockVerifier\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nabstract contract IBlockVerifier is Claimable\r\n{\r\n    // -- Events --\r\n\r\n    event CircuitRegistered(\r\n        uint8  indexed blockType,\r\n        uint16         blockSize,\r\n        uint8          blockVersion\r\n    );\r\n\r\n    event CircuitDisabled(\r\n        uint8  indexed blockType,\r\n        uint16         blockSize,\r\n        uint8          blockVersion\r\n    );\r\n\r\n    // -- Public functions --\r\n\r\n    /// @dev Sets the verifying key for the specified circuit.\r\n    ///      Every block permutation needs its own circuit and thus its own set of\r\n    ///      verification keys. Only a limited number of block sizes per block\r\n    ///      type are supported.\r\n    /// @param blockType The type of the block\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @param vk The verification key\r\n    function registerCircuit(\r\n        uint8    blockType,\r\n        uint16   blockSize,\r\n        uint8    blockVersion,\r\n        uint[18] calldata vk\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Disables the use of the specified circuit.\r\n    /// @param blockType The type of the block\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    function disableCircuit(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Verifies blocks with the given public data and proofs.\r\n    ///      Verifying a block makes sure all requests handled in the block\r\n    ///      are correctly handled by the operator.\r\n    /// @param blockType The type of block\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @param publicInputs The hash of all the public data of the blocks\r\n    /// @param proofs The ZK proofs proving that the blocks are correct\r\n    /// @return True if the block is valid, false otherwise\r\n    function verifyProofs(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion,\r\n        uint[] calldata publicInputs,\r\n        uint[] calldata proofs\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Checks if a circuit with the specified parameters is registered.\r\n    /// @param blockType The type of the block\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @return True if the circuit is registered, false otherwise\r\n    function isCircuitRegistered(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Checks if a circuit can still be used to commit new blocks.\r\n    /// @param blockType The type of the block\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @return True if the circuit is enabled, false otherwise\r\n    function isCircuitEnabled(\r\n        uint8  blockType,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title IDepositContract.\r\n/// @dev   Contract storing and transferring funds for an exchange.\r\n///\r\n///        ERC1155 tokens can be supported by registering pseudo token addresses calculated\r\n///        as `address(keccak256(real_token_address, token_params))`. Then the custom\r\n///        deposit contract can look up the real token address and paramsters with the\r\n///        pseudo token address before doing the transfers.\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\ninterface IDepositContract\r\n{\r\n    /// @dev Returns if a token is suppoprted by this contract.\r\n    function isTokenSupported(address token)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Transfers tokens from a user to the exchange. This function will\r\n    ///      be called when a user deposits funds to the exchange.\r\n    ///      In a simple implementation the funds are simply stored inside the\r\n    ///      deposit contract directly. More advanced implementations may store the funds\r\n    ///      in some DeFi application to earn interest, so this function could directly\r\n    ///      call the necessary functions to store the funds there.\r\n    ///\r\n    ///      This function needs to throw when an error occurred!\r\n    ///\r\n    ///      This function can only be called by the exchange.\r\n    ///\r\n    /// @param from The address of the account that sends the tokens.\r\n    /// @param token The address of the token to transfer (`0x0` for ETH).\r\n    /// @param amount The amount of tokens to transfer.\r\n    /// @param extraData Opaque data that can be used by the contract to handle the deposit\r\n    /// @return amountReceived The amount to deposit to the user's account in the Merkle tree\r\n    function deposit(\r\n        address from,\r\n        address token,\r\n        uint96  amount,\r\n        bytes   calldata extraData\r\n        )\r\n        external\r\n        payable\r\n        returns (uint96 amountReceived);\r\n\r\n    /// @dev Transfers tokens from the exchange to a user. This function will\r\n    ///      be called when a withdrawal is done for a user on the exchange.\r\n    ///      In the simplest implementation the funds are simply stored inside the\r\n    ///      deposit contract directly so this simply transfers the requested tokens back\r\n    ///      to the user. More advanced implementations may store the funds\r\n    ///      in some DeFi application to earn interest so the function would\r\n    ///      need to get those tokens back from the DeFi application first before they\r\n    ///      can be transferred to the user.\r\n    ///\r\n    ///      This function needs to throw when an error occurred!\r\n    ///\r\n    ///      This function can only be called by the exchange.\r\n    ///\r\n    /// @param from The address from which 'amount' tokens are transferred.\r\n    /// @param to The address to which 'amount' tokens are transferred.\r\n    /// @param token The address of the token to transfer (`0x0` for ETH).\r\n    /// @param amount The amount of tokens transferred.\r\n    /// @param extraData Opaque data that can be used by the contract to handle the withdrawal\r\n    function withdraw(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint    amount,\r\n        bytes   calldata extraData\r\n        )\r\n        external\r\n        payable;\r\n\r\n    /// @dev Transfers tokens (ETH not supported) for a user using the allowance set\r\n    ///      for the exchange. This way the approval can be used for all functionality (and\r\n    ///      extended functionality) of the exchange.\r\n    ///      Should NOT be used to deposit/withdraw user funds, `deposit`/`withdraw`\r\n    ///      should be used for that as they will contain specialised logic for those operations.\r\n    ///      This function can be called by the exchange to transfer onchain funds of users\r\n    ///      necessary for Agent functionality.\r\n    ///\r\n    ///      This function needs to throw when an error occurred!\r\n    ///\r\n    ///      This function can only be called by the exchange.\r\n    ///\r\n    /// @param from The address of the account that sends the tokens.\r\n    /// @param to The address to which 'amount' tokens are transferred.\r\n    /// @param token The address of the token to transfer (ETH is and cannot be suppported).\r\n    /// @param amount The amount of tokens transferred.\r\n    function transfer(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint    amount\r\n        )\r\n        external\r\n        payable;\r\n\r\n    /// @dev Checks if the given address is used for depositing ETH or not.\r\n    ///      Is used while depositing to send the correct ETH amount to the deposit contract.\r\n    ///\r\n    ///      Note that 0x0 is always registered for deposting ETH when the exchange is created!\r\n    ///      This function allows additional addresses to be used for depositing ETH, the deposit\r\n    ///      contract can implement different behaviour based on the address value.\r\n    ///\r\n    /// @param addr The address to check\r\n    /// @return True if the address is used for depositing ETH, else false.\r\n    function isETH(address addr)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n/// @title ILoopringV3\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\nabstract contract ILoopringV3 is Claimable\r\n{\r\n    // == Events ==\r\n    event ExchangeStakeDeposited(address exchangeAddr, uint amount);\r\n    event ExchangeStakeWithdrawn(address exchangeAddr, uint amount);\r\n    event ExchangeStakeBurned(address exchangeAddr, uint amount);\r\n    event SettingsUpdated(uint time);\r\n\r\n    // == Public Variables ==\r\n    mapping (address => uint) internal exchangeStake;\r\n\r\n    uint    public totalStake;\r\n    address public blockVerifierAddress;\r\n    uint    public forcedWithdrawalFee;\r\n    uint    public tokenRegistrationFeeLRCBase;\r\n    uint    public tokenRegistrationFeeLRCDelta;\r\n    uint8   public protocolTakerFeeBips;\r\n    uint8   public protocolMakerFeeBips;\r\n\r\n    address payable public protocolFeeVault;\r\n\r\n    // == Public Functions ==\r\n\r\n    /// @dev Returns the LRC token address\r\n    /// @return the LRC token address\r\n    function lrcAddress()\r\n        external\r\n        view\r\n        virtual\r\n        returns (address);\r\n\r\n    /// @dev Updates the global exchange settings.\r\n    ///      This function can only be called by the owner of this contract.\r\n    ///\r\n    ///      Warning: these new values will be used by existing and\r\n    ///      new Loopring exchanges.\r\n    function updateSettings(\r\n        address payable _protocolFeeVault,   // address(0) not allowed\r\n        address _blockVerifierAddress,       // address(0) not allowed\r\n        uint    _forcedWithdrawalFee\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Updates the global protocol fee settings.\r\n    ///      This function can only be called by the owner of this contract.\r\n    ///\r\n    ///      Warning: these new values will be used by existing and\r\n    ///      new Loopring exchanges.\r\n    function updateProtocolFeeSettings(\r\n        uint8 _protocolTakerFeeBips,\r\n        uint8 _protocolMakerFeeBips\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Gets the amount of staked LRC for an exchange.\r\n    /// @param exchangeAddr The address of the exchange\r\n    /// @return stakedLRC The amount of LRC\r\n    function getExchangeStake(\r\n        address exchangeAddr\r\n        )\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Burns a certain amount of staked LRC for a specific exchange.\r\n    ///      This function is meant to be called only from exchange contracts.\r\n    /// @return burnedLRC The amount of LRC burned. If the amount is greater than\r\n    ///         the staked amount, all staked LRC will be burned.\r\n    function burnExchangeStake(\r\n        uint amount\r\n        )\r\n        external\r\n        virtual\r\n        returns (uint burnedLRC);\r\n\r\n    /// @dev Stakes more LRC for an exchange.\r\n    /// @param  exchangeAddr The address of the exchange\r\n    /// @param  amountLRC The amount of LRC to stake\r\n    /// @return stakedLRC The total amount of LRC staked for the exchange\r\n    function depositExchangeStake(\r\n        address exchangeAddr,\r\n        uint    amountLRC\r\n        )\r\n        external\r\n        virtual\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Withdraws a certain amount of staked LRC for an exchange to the given address.\r\n    ///      This function is meant to be called only from within exchange contracts.\r\n    /// @param  recipient The address to receive LRC\r\n    /// @param  requestedAmount The amount of LRC to withdraw\r\n    /// @return amountLRC The amount of LRC withdrawn\r\n    function withdrawExchangeStake(\r\n        address recipient,\r\n        uint    requestedAmount\r\n        )\r\n        external\r\n        virtual\r\n        returns (uint amountLRC);\r\n\r\n    /// @dev Gets the protocol fee values for an exchange.\r\n    /// @return takerFeeBips The protocol taker fee\r\n    /// @return makerFeeBips The protocol maker fee\r\n    function getProtocolFeeValues(\r\n        )\r\n        public\r\n        virtual\r\n        view\r\n        returns (\r\n            uint8 takerFeeBips,\r\n            uint8 makerFeeBips\r\n        );\r\n}\r\n\r\n\r\n\r\n/// @title ExchangeData\r\n/// @dev All methods in this lib are internal, therefore, there is no need\r\n///      to deploy this library independently.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeData\r\n{\r\n    // -- Enums --\r\n    enum TransactionType\r\n    {\r\n        NOOP,\r\n        DEPOSIT,\r\n        WITHDRAWAL,\r\n        TRANSFER,\r\n        SPOT_TRADE,\r\n        ACCOUNT_UPDATE,\r\n        AMM_UPDATE\r\n    }\r\n\r\n    // -- Structs --\r\n    struct Token\r\n    {\r\n        address token;\r\n    }\r\n\r\n    struct ProtocolFeeData\r\n    {\r\n        uint32 syncedAt; // only valid before 2105 (85 years to go)\r\n        uint8  takerFeeBips;\r\n        uint8  makerFeeBips;\r\n        uint8  previousTakerFeeBips;\r\n        uint8  previousMakerFeeBips;\r\n    }\r\n\r\n    // General auxiliary data for each conditional transaction\r\n    struct AuxiliaryData\r\n    {\r\n        uint  txIndex;\r\n        bytes data;\r\n    }\r\n\r\n    // This is the (virtual) block the owner  needs to submit onchain to maintain the\r\n    // per-exchange (virtual) blockchain.\r\n    struct Block\r\n    {\r\n        uint8      blockType;\r\n        uint16     blockSize;\r\n        uint8      blockVersion;\r\n        bytes      data;\r\n        uint256[8] proof;\r\n\r\n        // Whether we should store the @BlockInfo for this block on-chain.\r\n        bool storeBlockInfoOnchain;\r\n\r\n        // Block specific data that is only used to help process the block on-chain.\r\n        // It is not used as input for the circuits and it is not necessary for data-availability.\r\n        AuxiliaryData[] auxiliaryData;\r\n\r\n        // Arbitrary data, mainly for off-chain data-availability, i.e.,\r\n        // the multihash of the IPFS file that contains the block data.\r\n        bytes offchainData;\r\n    }\r\n\r\n    struct BlockInfo\r\n    {\r\n        // The time the block was submitted on-chain.\r\n        uint32  timestamp;\r\n        // The public data hash of the block (the 28 most significant bytes).\r\n        bytes28 blockDataHash;\r\n    }\r\n\r\n    // Represents an onchain deposit request.\r\n    struct Deposit\r\n    {\r\n        uint96 amount;\r\n        uint64 timestamp;\r\n    }\r\n\r\n    // A forced withdrawal request.\r\n    // If the actual owner of the account initiated the request (we don't know who the owner is\r\n    // at the time the request is being made) the full balance will be withdrawn.\r\n    struct ForcedWithdrawal\r\n    {\r\n        address owner;\r\n        uint64  timestamp;\r\n    }\r\n\r\n    struct Constants\r\n    {\r\n        uint SNARK_SCALAR_FIELD;\r\n        uint MAX_OPEN_FORCED_REQUESTS;\r\n        uint MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE;\r\n        uint TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS;\r\n        uint MAX_NUM_ACCOUNTS;\r\n        uint MAX_NUM_TOKENS;\r\n        uint MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED;\r\n        uint MIN_TIME_IN_SHUTDOWN;\r\n        uint TX_DATA_AVAILABILITY_SIZE;\r\n        uint MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND;\r\n    }\r\n\r\n    function SNARK_SCALAR_FIELD() internal pure returns (uint) {\r\n        // This is the prime number that is used for the alt_bn128 elliptic curve, see EIP-196.\r\n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    }\r\n    function MAX_OPEN_FORCED_REQUESTS() internal pure returns (uint16) { return 4096; }\r\n    function MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 15 days; }\r\n    function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 7 days; }\r\n    function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 32; }\r\n    function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 16; }\r\n    function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 7 days; }\r\n    function MIN_TIME_IN_SHUTDOWN() internal pure returns (uint32) { return 30 days; }\r\n    // The amount of bytes each rollup transaction uses in the block data for data-availability.\r\n    // This is the maximum amount of bytes of all different transaction types.\r\n    function TX_DATA_AVAILABILITY_SIZE() internal pure returns (uint32) { return 68; }\r\n    function MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND() internal pure returns (uint32) { return 15 days; }\r\n    function ACCOUNTID_PROTOCOLFEE() internal pure returns (uint32) { return 0; }\r\n\r\n    function TX_DATA_AVAILABILITY_SIZE_PART_1() internal pure returns (uint32) { return 29; }\r\n    function TX_DATA_AVAILABILITY_SIZE_PART_2() internal pure returns (uint32) { return 39; }\r\n\r\n    struct AccountLeaf\r\n    {\r\n        uint32   accountID;\r\n        address  owner;\r\n        uint     pubKeyX;\r\n        uint     pubKeyY;\r\n        uint32   nonce;\r\n        uint     feeBipsAMM;\r\n    }\r\n\r\n    struct BalanceLeaf\r\n    {\r\n        uint16   tokenID;\r\n        uint96   balance;\r\n        uint96   weightAMM;\r\n        uint     storageRoot;\r\n    }\r\n\r\n    struct MerkleProof\r\n    {\r\n        ExchangeData.AccountLeaf accountLeaf;\r\n        ExchangeData.BalanceLeaf balanceLeaf;\r\n        uint[48]                 accountMerkleProof;\r\n        uint[24]                 balanceMerkleProof;\r\n    }\r\n\r\n    struct BlockContext\r\n    {\r\n        bytes32 DOMAIN_SEPARATOR;\r\n        uint32  timestamp;\r\n    }\r\n\r\n    // Represents the entire exchange state except the owner of the exchange.\r\n    struct State\r\n    {\r\n        uint32  maxAgeDepositUntilWithdrawable;\r\n        bytes32 DOMAIN_SEPARATOR;\r\n\r\n        ILoopringV3      loopring;\r\n        IBlockVerifier   blockVerifier;\r\n        IAgentRegistry   agentRegistry;\r\n        IDepositContract depositContract;\r\n\r\n\r\n        // The merkle root of the offchain data stored in a Merkle tree. The Merkle tree\r\n        // stores balances for users using an account model.\r\n        bytes32 merkleRoot;\r\n\r\n        // List of all blocks\r\n        mapping(uint => BlockInfo) blocks;\r\n        uint  numBlocks;\r\n\r\n        // List of all tokens\r\n        Token[] tokens;\r\n\r\n        // A map from a token to its tokenID + 1\r\n        mapping (address => uint16) tokenToTokenId;\r\n\r\n        // A map from an accountID to a tokenID to if the balance is withdrawn\r\n        mapping (uint32 => mapping (uint16 => bool)) withdrawnInWithdrawMode;\r\n\r\n        // A map from an account to a token to the amount withdrawable for that account.\r\n        // This is only used when the automatic distribution of the withdrawal failed.\r\n        mapping (address => mapping (uint16 => uint)) amountWithdrawable;\r\n\r\n        // A map from an account to a token to the forced withdrawal (always full balance)\r\n        mapping (uint32 => mapping (uint16 => ForcedWithdrawal)) pendingForcedWithdrawals;\r\n\r\n        // A map from an address to a token to a deposit\r\n        mapping (address => mapping (uint16 => Deposit)) pendingDeposits;\r\n\r\n        // A map from an account owner to an approved transaction hash to if the transaction is approved or not\r\n        mapping (address => mapping (bytes32 => bool)) approvedTx;\r\n\r\n        // A map from an account owner to a destination address to a tokenID to an amount to a storageID to a new recipient address\r\n        mapping (address => mapping (address => mapping (uint16 => mapping (uint => mapping (uint32 => address))))) withdrawalRecipient;\r\n\r\n\r\n        // Counter to keep track of how many of forced requests are open so we can limit the work that needs to be done by the owner\r\n        uint32 numPendingForcedTransactions;\r\n\r\n        // Cached data for the protocol fee\r\n        ProtocolFeeData protocolFeeData;\r\n\r\n        // Time when the exchange was shutdown\r\n        uint shutdownModeStartTime;\r\n\r\n        // Time when the exchange has entered withdrawal mode\r\n        uint withdrawalModeStartTime;\r\n\r\n        // Last time the protocol fee was withdrawn for a specific token\r\n        mapping (address => uint) protocolFeeLastWithdrawnTime;\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\nabstract contract ERC1271 {\r\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\r\n\r\n    function isValidSignature(\r\n        bytes32      _hash,\r\n        bytes memory _signature)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bytes4 magicValueB32);\r\n\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\ninterface IAmmSharedConfig\r\n{\r\n    function maxForcedExitAge() external view returns (uint);\r\n    function maxForcedExitCount() external view returns (uint);\r\n    function forcedExitFee() external view returns (uint);\r\n}\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title SignatureUtil\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// @dev This method supports multihash standard. Each signature's last byte indicates\r\n///      the signature's type.\r\nlibrary SignatureUtil\r\n{\r\n    using BytesUtil     for bytes;\r\n    using MathUint      for uint;\r\n    using AddressUtil   for address;\r\n\r\n    enum SignatureType {\r\n        ILLEGAL,\r\n        INVALID,\r\n        EIP_712,\r\n        ETH_SIGN,\r\n        WALLET   // deprecated\r\n    }\r\n\r\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\r\n\r\n    function verifySignatures(\r\n        bytes32          signHash,\r\n        address[] memory signers,\r\n        bytes[]   memory signatures\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(signers.length == signatures.length, \"BAD_SIGNATURE_DATA\");\r\n        address lastSigner;\r\n        for (uint i = 0; i < signers.length; i++) {\r\n            require(signers[i] > lastSigner, \"INVALID_SIGNERS_ORDER\");\r\n            lastSigner = signers[i];\r\n            if (!verifySignature(signHash, signers[i], signatures[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function verifySignature(\r\n        bytes32        signHash,\r\n        address        signer,\r\n        bytes   memory signature\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (signer == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        return signer.isContract()?\r\n            verifyERC1271Signature(signHash, signer, signature):\r\n            verifyEOASignature(signHash, signer, signature);\r\n    }\r\n\r\n    function recoverECDSASigner(\r\n        bytes32      signHash,\r\n        bytes memory signature\r\n        )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        if (signature.length != 65) {\r\n            return address(0);\r\n        }\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8   v;\r\n        // we jump 32 (0x20) as the first slot of bytes contains the length\r\n        // we jump 65 (0x41) per signature\r\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := and(mload(add(signature, 0x41)), 0xff)\r\n        }\r\n        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n        if (v == 27 || v == 28) {\r\n            return ecrecover(signHash, v, r, s);\r\n        } else {\r\n            return address(0);\r\n        }\r\n    }\r\n\r\n    function verifyEOASignature(\r\n        bytes32        signHash,\r\n        address        signer,\r\n        bytes   memory signature\r\n        )\r\n        private\r\n        pure\r\n        returns (bool success)\r\n    {\r\n        if (signer == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint signatureTypeOffset = signature.length.sub(1);\r\n        SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));\r\n\r\n        // Strip off the last byte of the signature by updating the length\r\n        assembly {\r\n            mstore(signature, signatureTypeOffset)\r\n        }\r\n\r\n        if (signatureType == SignatureType.EIP_712) {\r\n            success = (signer == recoverECDSASigner(signHash, signature));\r\n        } else if (signatureType == SignatureType.ETH_SIGN) {\r\n            bytes32 hash = keccak256(\r\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", signHash)\r\n            );\r\n            success = (signer == recoverECDSASigner(hash, signature));\r\n        } else {\r\n            success = false;\r\n        }\r\n\r\n        // Restore the signature length\r\n        assembly {\r\n            mstore(signature, add(signatureTypeOffset, 1))\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function verifyERC1271Signature(\r\n        bytes32 signHash,\r\n        address signer,\r\n        bytes   memory signature\r\n        )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            ERC1271.isValidSignature.selector,\r\n            signHash,\r\n            signature\r\n        );\r\n        (bool success, bytes memory result) = signer.staticcall(callData);\r\n        return (\r\n            success &&\r\n            result.length == 32 &&\r\n            result.toBytes4(0) == ERC1271_MAGICVALUE\r\n        );\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title IExchangeV3\r\n/// @dev Note that Claimable and RentrancyGuard are inherited here to\r\n///      ensure all data members are declared on IExchangeV3 to make it\r\n///      easy to support upgradability through proxies.\r\n///\r\n///      Subclasses of this contract must NOT define constructor to\r\n///      initialize data.\r\n///\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\nabstract contract IExchangeV3 is Claimable\r\n{\r\n    // -- Events --\r\n\r\n    event ExchangeCloned(\r\n        address exchangeAddress,\r\n        address owner,\r\n        bytes32 genesisMerkleRoot\r\n    );\r\n\r\n    event TokenRegistered(\r\n        address token,\r\n        uint16  tokenId\r\n    );\r\n\r\n    event Shutdown(\r\n        uint timestamp\r\n    );\r\n\r\n    event WithdrawalModeActivated(\r\n        uint timestamp\r\n    );\r\n\r\n    event BlockSubmitted(\r\n        uint    indexed blockIdx,\r\n        bytes32         merkleRoot,\r\n        bytes32         publicDataHash\r\n    );\r\n\r\n    event DepositRequested(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint16  tokenId,\r\n        uint96  amount\r\n    );\r\n\r\n    event ForcedWithdrawalRequested(\r\n        address owner,\r\n        address token,\r\n        uint32  accountID\r\n    );\r\n\r\n    event WithdrawalCompleted(\r\n        uint8   category,\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint    amount\r\n    );\r\n\r\n    event WithdrawalFailed(\r\n        uint8   category,\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint    amount\r\n    );\r\n\r\n    event ProtocolFeesUpdated(\r\n        uint8 takerFeeBips,\r\n        uint8 makerFeeBips,\r\n        uint8 previousTakerFeeBips,\r\n        uint8 previousMakerFeeBips\r\n    );\r\n\r\n    event TransactionApproved(\r\n        address owner,\r\n        bytes32 transactionHash\r\n    );\r\n\r\n\r\n    // -- Initialization --\r\n    /// @dev Initializes this exchange. This method can only be called once.\r\n    /// @param  loopring The LoopringV3 contract address.\r\n    /// @param  owner The owner of this exchange.\r\n    /// @param  genesisMerkleRoot The initial Merkle tree state.\r\n    function initialize(\r\n        address loopring,\r\n        address owner,\r\n        bytes32 genesisMerkleRoot\r\n        )\r\n        virtual\r\n        external;\r\n\r\n    /// @dev Initialized the agent registry contract used by the exchange.\r\n    ///      Can only be called by the exchange owner once.\r\n    /// @param agentRegistry The agent registry contract to be used\r\n    function setAgentRegistry(address agentRegistry)\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Gets the agent registry contract used by the exchange.\r\n    /// @return the agent registry contract\r\n    function getAgentRegistry()\r\n        external\r\n        virtual\r\n        view\r\n        returns (IAgentRegistry);\r\n\r\n    ///      Can only be called by the exchange owner once.\r\n    /// @param depositContract The deposit contract to be used\r\n    function setDepositContract(address depositContract)\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Gets the deposit contract used by the exchange.\r\n    /// @return the deposit contract\r\n    function getDepositContract()\r\n        external\r\n        virtual\r\n        view\r\n        returns (IDepositContract);\r\n\r\n    // @dev Exchange owner withdraws fees from the exchange.\r\n    // @param token Fee token address\r\n    // @param feeRecipient Fee recipient address\r\n    function withdrawExchangeFees(\r\n        address token,\r\n        address feeRecipient\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    // -- Constants --\r\n    /// @dev Returns a list of constants used by the exchange.\r\n    /// @return constants The list of constants.\r\n    function getConstants()\r\n        external\r\n        virtual\r\n        pure\r\n        returns(ExchangeData.Constants memory);\r\n\r\n    // -- Mode --\r\n    /// @dev Returns hether the exchange is in withdrawal mode.\r\n    /// @return Returns true if the exchange is in withdrawal mode, else false.\r\n    function isInWithdrawalMode()\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Returns whether the exchange is shutdown.\r\n    /// @return Returns true if the exchange is shutdown, else false.\r\n    function isShutdown()\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool);\r\n\r\n    // -- Tokens --\r\n    /// @dev Registers an ERC20 token for a token id. Note that different exchanges may have\r\n    ///      different ids for the same ERC20 token.\r\n    ///\r\n    ///      Please note that 1 is reserved for Ether (ETH), 2 is reserved for Wrapped Ether (ETH),\r\n    ///      and 3 is reserved for Loopring Token (LRC).\r\n    ///\r\n    ///      This function is only callable by the exchange owner.\r\n    ///\r\n    /// @param  tokenAddress The token's address\r\n    /// @return tokenID The token's ID in this exchanges.\r\n    function registerToken(\r\n        address tokenAddress\r\n        )\r\n        external\r\n        virtual\r\n        returns (uint16 tokenID);\r\n\r\n    /// @dev Returns the id of a registered token.\r\n    /// @param  tokenAddress The token's address\r\n    /// @return tokenID The token's ID in this exchanges.\r\n    function getTokenID(\r\n        address tokenAddress\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (uint16 tokenID);\r\n\r\n    /// @dev Returns the address of a registered token.\r\n    /// @param  tokenID The token's ID in this exchanges.\r\n    /// @return tokenAddress The token's address\r\n    function getTokenAddress(\r\n        uint16 tokenID\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (address tokenAddress);\r\n\r\n    // -- Stakes --\r\n    /// @dev Gets the amount of LRC the owner has staked onchain for this exchange.\r\n    ///      The stake will be burned if the exchange does not fulfill its duty by\r\n    ///      processing user requests in time. Please note that order matching may potentially\r\n    ///      performed by another party and is not part of the exchange's duty.\r\n    ///\r\n    /// @return The amount of LRC staked\r\n    function getExchangeStake()\r\n        external\r\n        virtual\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev Withdraws the amount staked for this exchange.\r\n    ///      This can only be done if the exchange has been correctly shutdown:\r\n    ///      - The exchange owner has shutdown the exchange\r\n    ///      - All deposit requests are processed\r\n    ///      - All funds are returned to the users (merkle root is reset to initial state)\r\n    ///\r\n    ///      Can only be called by the exchange owner.\r\n    ///\r\n    /// @return amountLRC The amount of LRC withdrawn\r\n    function withdrawExchangeStake(\r\n        address recipient\r\n        )\r\n        external\r\n        virtual\r\n        returns (uint amountLRC);\r\n\r\n    /// @dev Can by called by anyone to burn the stake of the exchange when certain\r\n    ///      conditions are fulfilled.\r\n    ///\r\n    ///      Currently this will only burn the stake of the exchange if\r\n    ///      the exchange is in withdrawal mode.\r\n    function burnExchangeStake()\r\n        external\r\n        virtual;\r\n\r\n    // -- Blocks --\r\n\r\n    /// @dev Gets the current Merkle root of this exchange's virtual blockchain.\r\n    /// @return The current Merkle root.\r\n    function getMerkleRoot()\r\n        external\r\n        virtual\r\n        view\r\n        returns (bytes32);\r\n\r\n    /// @dev Gets the height of this exchange's virtual blockchain. The block height for a\r\n    ///      new exchange is 1.\r\n    /// @return The virtual blockchain height which is the index of the last block.\r\n    function getBlockHeight()\r\n        external\r\n        virtual\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev Gets some minimal info of a previously submitted block that's kept onchain.\r\n    ///      A DEX can use this function to implement a payment receipt verification\r\n    ///      contract with a challange-response scheme.\r\n    /// @param blockIdx The block index.\r\n    function getBlockInfo(uint blockIdx)\r\n        external\r\n        virtual\r\n        view\r\n        returns (ExchangeData.BlockInfo memory);\r\n\r\n    /// @dev Sumbits new blocks to the rollup blockchain.\r\n    ///\r\n    ///      This function can only be called by the exchange operator.\r\n    ///\r\n    /// @param blocks The blocks being submitted\r\n    ///      - blockType: The type of the new block\r\n    ///      - blockSize: The number of onchain or offchain requests/settlements\r\n    ///        that have been processed in this block\r\n    ///      - blockVersion: The circuit version to use for verifying the block\r\n    ///      - storeBlockInfoOnchain: If the block info for this block needs to be stored on-chain\r\n    ///      - data: The data for this block\r\n    ///      - offchainData: Arbitrary data, mainly for off-chain data-availability, i.e.,\r\n    ///        the multihash of the IPFS file that contains the block data.\r\n    function submitBlocks(ExchangeData.Block[] calldata blocks)\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Gets the number of available forced request slots.\r\n    /// @return The number of available slots.\r\n    function getNumAvailableForcedSlots()\r\n        external\r\n        virtual\r\n        view\r\n        returns (uint);\r\n\r\n    // -- Deposits --\r\n\r\n    /// @dev Deposits Ether or ERC20 tokens to the specified account.\r\n    ///\r\n    ///      This function is only callable by an agent of 'from'.\r\n    ///\r\n    ///      A fee to the owner is paid in ETH to process the deposit.\r\n    ///      The operator is not forced to do the deposit and the user can send\r\n    ///      any fee amount.\r\n    ///\r\n    /// @param from The address that deposits the funds to the exchange\r\n    /// @param to The account owner's address receiving the funds\r\n    /// @param tokenAddress The address of the token, use `0x0` for Ether.\r\n    /// @param amount The amount of tokens to deposit\r\n    /// @param auxiliaryData Optional extra data used by the deposit contract\r\n    function deposit(\r\n        address from,\r\n        address to,\r\n        address tokenAddress,\r\n        uint96  amount,\r\n        bytes   calldata auxiliaryData\r\n        )\r\n        external\r\n        virtual\r\n        payable;\r\n\r\n    /// @dev Gets the amount of tokens that may be added to the owner's account.\r\n    /// @param owner The destination address for the amount deposited.\r\n    /// @param tokenAddress The address of the token, use `0x0` for Ether.\r\n    /// @return The amount of tokens pending.\r\n    function getPendingDepositAmount(\r\n        address owner,\r\n        address tokenAddress\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (uint96);\r\n\r\n    // -- Withdrawals --\r\n    /// @dev Submits an onchain request to force withdraw Ether or ERC20 tokens.\r\n    ///      This request always withdraws the full balance.\r\n    ///\r\n    ///      This function is only callable by an agent of the account.\r\n    ///\r\n    ///      The total fee in ETH that the user needs to pay is 'withdrawalFee'.\r\n    ///      If the user sends too much ETH the surplus is sent back immediately.\r\n    ///\r\n    ///      Note that after such an operation, it will take the owner some\r\n    ///      time (no more than MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE) to process the request\r\n    ///      and create the deposit to the offchain account.\r\n    ///\r\n    /// @param owner The expected owner of the account\r\n    /// @param tokenAddress The address of the token, use `0x0` for Ether.\r\n    /// @param accountID The address the account in the Merkle tree.\r\n    function forceWithdraw(\r\n        address owner,\r\n        address tokenAddress,\r\n        uint32  accountID\r\n        )\r\n        external\r\n        virtual\r\n        payable;\r\n\r\n    /// @dev Checks if a forced withdrawal is pending for an account balance.\r\n    /// @param  accountID The accountID of the account to check.\r\n    /// @param  token The token address\r\n    /// @return True if a request is pending, false otherwise\r\n    function isForcedWithdrawalPending(\r\n        uint32  accountID,\r\n        address token\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Submits an onchain request to withdraw Ether or ERC20 tokens from the\r\n    ///      protocol fees account. The complete balance is always withdrawn.\r\n    ///\r\n    ///      Anyone can request a withdrawal of the protocol fees.\r\n    ///\r\n    ///      Note that after such an operation, it will take the owner some\r\n    ///      time (no more than MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE) to process the request\r\n    ///      and create the deposit to the offchain account.\r\n    ///\r\n    /// @param tokenAddress The address of the token, use `0x0` for Ether.\r\n    function withdrawProtocolFees(\r\n        address tokenAddress\r\n        )\r\n        external\r\n        virtual\r\n        payable;\r\n\r\n    /// @dev Gets the time the protocol fee for a token was last withdrawn.\r\n    /// @param tokenAddress The address of the token, use `0x0` for Ether.\r\n    /// @return The time the protocol fee was last withdrawn.\r\n    function getProtocolFeeLastWithdrawnTime(\r\n        address tokenAddress\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev Allows anyone to withdraw funds for a specified user using the balances stored\r\n    ///      in the Merkle tree. The funds will be sent to the owner of the acount.\r\n    ///\r\n    ///      Can only be used in withdrawal mode (i.e. when the owner has stopped\r\n    ///      committing blocks and is not able to commit any more blocks).\r\n    ///\r\n    ///      This will NOT modify the onchain merkle root! The merkle root stored\r\n    ///      onchain will remain the same after the withdrawal. We store if the user\r\n    ///      has withdrawn the balance in State.withdrawnInWithdrawMode.\r\n    ///\r\n    /// @param  merkleProof The Merkle inclusion proof\r\n    function withdrawFromMerkleTree(\r\n        ExchangeData.MerkleProof calldata merkleProof\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Checks if the balance for the account was withdrawn with `withdrawFromMerkleTree`.\r\n    /// @param  accountID The accountID of the balance to check.\r\n    /// @param  token The token address\r\n    /// @return True if it was already withdrawn, false otherwise\r\n    function isWithdrawnInWithdrawalMode(\r\n        uint32  accountID,\r\n        address token\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Allows withdrawing funds deposited to the contract in a deposit request when\r\n    ///      it was never processed by the owner within the maximum time allowed.\r\n    ///\r\n    ///      Can be called by anyone. The deposited tokens will be sent back to\r\n    ///      the owner of the account they were deposited in.\r\n    ///\r\n    /// @param  owner The address of the account the withdrawal was done for.\r\n    /// @param  token The token address\r\n    function withdrawFromDepositRequest(\r\n        address owner,\r\n        address token\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Allows withdrawing funds after a withdrawal request (either onchain\r\n    ///      or offchain) was submitted in a block by the operator.\r\n    ///\r\n    ///      Can be called by anyone. The withdrawn tokens will be sent to\r\n    ///      the owner of the account they were withdrawn out.\r\n    ///\r\n    ///      Normally it is should not be needed for users to call this manually.\r\n    ///      Funds from withdrawal requests will be sent to the account owner\r\n    ///      immediately by the owner when the block is submitted.\r\n    ///      The user will however need to call this manually if the transfer failed.\r\n    ///\r\n    ///      Tokens and owners must have the same size.\r\n    ///\r\n    /// @param  owners The addresses of the account the withdrawal was done for.\r\n    /// @param  tokens The token addresses\r\n    function withdrawFromApprovedWithdrawals(\r\n        address[] calldata owners,\r\n        address[] calldata tokens\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Gets the amount that can be withdrawn immediately with `withdrawFromApprovedWithdrawals`.\r\n    /// @param  owner The address of the account the withdrawal was done for.\r\n    /// @param  token The token address\r\n    /// @return The amount withdrawable\r\n    function getAmountWithdrawable(\r\n        address owner,\r\n        address token\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev Notifies the exchange that the owner did not process a forced request.\r\n    ///      If this is indeed the case, the exchange will enter withdrawal mode.\r\n    ///\r\n    ///      Can be called by anyone.\r\n    ///\r\n    /// @param  accountID The accountID the forced request was made for\r\n    /// @param  token The token address of the the forced request\r\n    function notifyForcedRequestTooOld(\r\n        uint32  accountID,\r\n        address token\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Allows a withdrawal to be done to an adddresss that is different\r\n    ///      than initialy specified in the withdrawal request. This can be used to\r\n    ///      implement functionality like fast withdrawals.\r\n    ///\r\n    ///      This function can only be called by an agent.\r\n    ///\r\n    /// @param from The address of the account that does the withdrawal.\r\n    /// @param to The address to which 'amount' tokens were going to be withdrawn.\r\n    /// @param token The address of the token that is withdrawn ('0x0' for ETH).\r\n    /// @param amount The amount of tokens that are going to be withdrawn.\r\n    /// @param storageID The storageID of the withdrawal request.\r\n    /// @param newRecipient The new recipient address of the withdrawal.\r\n    function setWithdrawalRecipient(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint96  amount,\r\n        uint32  storageID,\r\n        address newRecipient\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Gets the withdrawal recipient.\r\n    ///\r\n    /// @param from The address of the account that does the withdrawal.\r\n    /// @param to The address to which 'amount' tokens were going to be withdrawn.\r\n    /// @param token The address of the token that is withdrawn ('0x0' for ETH).\r\n    /// @param amount The amount of tokens that are going to be withdrawn.\r\n    /// @param storageID The storageID of the withdrawal request.\r\n    function getWithdrawalRecipient(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint96  amount,\r\n        uint32  storageID\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (address);\r\n\r\n    /// @dev Allows an agent to transfer ERC-20 tokens for a user using the allowance\r\n    ///      the user has set for the exchange. This way the user only needs to approve a single exchange contract\r\n    ///      for all exchange/agent features, which allows for a more seamless user experience.\r\n    ///\r\n    ///      This function can only be called by an agent.\r\n    ///\r\n    /// @param from The address of the account that sends the tokens.\r\n    /// @param to The address to which 'amount' tokens are transferred.\r\n    /// @param token The address of the token to transfer (ETH is and cannot be suppported).\r\n    /// @param amount The amount of tokens transferred.\r\n    function onchainTransferFrom(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint    amount\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Allows an agent to approve a rollup tx.\r\n    ///\r\n    ///      This function can only be called by an agent.\r\n    ///\r\n    /// @param owner The owner of the account\r\n    /// @param txHash The hash of the transaction\r\n    function approveTransaction(\r\n        address owner,\r\n        bytes32 txHash\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Allows an agent to approve multiple rollup txs.\r\n    ///\r\n    ///      This function can only be called by an agent.\r\n    ///\r\n    /// @param owners The account owners\r\n    /// @param txHashes The hashes of the transactions\r\n    function approveTransactions(\r\n        address[] calldata owners,\r\n        bytes32[] calldata txHashes\r\n        )\r\n        external\r\n        virtual;\r\n\r\n    /// @dev Checks if a rollup tx is approved using the tx's hash.\r\n    ///\r\n    /// @param owner The owner of the account that needs to authorize the tx\r\n    /// @param txHash The hash of the transaction\r\n    /// @return True if the tx is approved, else false\r\n    function isTransactionApproved(\r\n        address owner,\r\n        bytes32 txHash\r\n        )\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool);\r\n\r\n    // -- Admins --\r\n    /// @dev Sets the max time deposits have to wait before becoming withdrawable.\r\n    /// @param newValue The new value.\r\n    /// @return  The old value.\r\n    function setMaxAgeDepositUntilWithdrawable(\r\n        uint32 newValue\r\n        )\r\n        external\r\n        virtual\r\n        returns (uint32);\r\n\r\n    /// @dev Returns the max time deposits have to wait before becoming withdrawable.\r\n    /// @return The value.\r\n    function getMaxAgeDepositUntilWithdrawable()\r\n        external\r\n        virtual\r\n        view\r\n        returns (uint32);\r\n\r\n    /// @dev Shuts down the exchange.\r\n    ///      Once the exchange is shutdown all onchain requests are permanently disabled.\r\n    ///      When all requirements are fulfilled the exchange owner can withdraw\r\n    ///      the exchange stake with withdrawStake.\r\n    ///\r\n    ///      Note that the exchange can still enter the withdrawal mode after this function\r\n    ///      has been invoked successfully. To prevent entering the withdrawal mode before the\r\n    ///      the echange stake can be withdrawn, all withdrawal requests still need to be handled\r\n    ///      for at least MIN_TIME_IN_SHUTDOWN seconds.\r\n    ///\r\n    ///      Can only be called by the exchange owner.\r\n    ///\r\n    /// @return success True if the exchange is shutdown, else False\r\n    function shutdown()\r\n        external\r\n        virtual\r\n        returns (bool success);\r\n\r\n    /// @dev Gets the protocol fees for this exchange.\r\n    /// @return syncedAt The timestamp the protocol fees were last updated\r\n    /// @return takerFeeBips The protocol taker fee\r\n    /// @return makerFeeBips The protocol maker fee\r\n    /// @return previousTakerFeeBips The previous protocol taker fee\r\n    /// @return previousMakerFeeBips The previous protocol maker fee\r\n    function getProtocolFeeValues()\r\n        external\r\n        virtual\r\n        view\r\n        returns (\r\n            uint32 syncedAt,\r\n            uint8 takerFeeBips,\r\n            uint8 makerFeeBips,\r\n            uint8 previousTakerFeeBips,\r\n            uint8 previousMakerFeeBips\r\n        );\r\n\r\n    /// @dev Gets the domain separator used in this exchange.\r\n    function getDomainSeparator()\r\n        external\r\n        virtual\r\n        view\r\n        returns (bytes32);\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title AmmUpdateProcess\r\nlibrary AmmUpdateProcess\r\n{\r\n    using AmmUtil           for AmmData.TransactionBuffer;\r\n    using TransactionReader for ExchangeData.Block;\r\n\r\n    function approveAmmUpdates(\r\n        AmmData.State      storage S,\r\n        AmmData.Context    memory  ctx,\r\n        ExchangeData.Block memory  _block\r\n        )\r\n        internal\r\n        view\r\n    {\r\n        for (uint i = 0; i < ctx.tokens.length; i++) {\r\n            // Check that the AMM update in the block matches the expected update\r\n            AmmUpdateTransaction.AmmUpdate memory update = _block.readAmmUpdate(ctx.txIdx++);\r\n\r\n            require(\r\n                update.owner == address(this) &&\r\n                update.accountID == ctx.accountID &&\r\n                update.tokenID == ctx.tokens[i].tokenID &&\r\n                update.feeBips == S.feeBips &&\r\n                update.tokenWeight == ctx.tokens[i].weight,\r\n                \"INVALID_AMM_UPDATE_TX_DATA\"\r\n            );\r\n\r\n            // Now approve this AMM update\r\n            update.validUntil = 0xffffffff;\r\n            bytes32 txHash = AmmUpdateTransaction.hashTx(ctx.exchangeDomainSeparator, update);\r\n            ctx.transactionBuffer.approveExchangeTransaction(address(this), txHash);\r\n\r\n            ctx.tokenBalancesL2[i] = update.balance;\r\n        }\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title AmmJoinProcess\r\nlibrary AmmJoinProcess\r\n{\r\n    using AmmPoolToken      for AmmData.State;\r\n    using AmmUtil           for AmmData.Context;\r\n    using AmmUtil           for uint96;\r\n    using MathUint          for uint;\r\n    using MathUint96        for uint96;\r\n    using SafeCast          for uint;\r\n    using SignatureUtil     for bytes32;\r\n    using TransactionReader for ExchangeData.Block;\r\n\r\n    // event JoinProcessed(address owner, uint96 mintAmount, uint96[] amounts);\r\n\r\n    function processJoin(\r\n        AmmData.State       storage S,\r\n        AmmData.Context     memory  ctx,\r\n        ExchangeData.Block  memory  _block,\r\n        AmmData.PoolJoin    memory  join,\r\n        bytes               memory  signature\r\n        )\r\n        internal\r\n    {\r\n        require(join.validUntil >= block.timestamp, \"EXPIRED\");\r\n\r\n        bytes32 txHash = AmmJoinRequest.hash(ctx.domainSeparator, join);\r\n\r\n        if (signature.length == 0) {\r\n            require(S.approvedTx[txHash], \"INVALID_ONCHAIN_APPROVAL\");\r\n            delete S.approvedTx[txHash];\r\n        } else {\r\n            require(txHash.verifySignature(join.owner, signature), \"INVALID_OFFCHAIN_APPROVAL\");\r\n        }\r\n\r\n        // Check if the requirements are fulfilled\r\n        (bool slippageOK, uint96 mintAmount, uint96[] memory amounts) = _calculateJoinAmounts(ctx, join);\r\n        require(slippageOK, \"JOIN_SLIPPAGE_INVALID\");\r\n\r\n        // Handle liquidity tokens\r\n        for (uint i = 0; i < ctx.tokens.length; i++) {\r\n            TransferTransaction.Transfer memory transfer = _block.readTransfer(ctx.txIdx++);\r\n\r\n            require(\r\n                // transfer.fromAccountID == UNKNOWN &&\r\n                transfer.toAccountID == ctx.accountID &&\r\n                transfer.from == join.owner &&\r\n                transfer.to == address(this) &&\r\n                transfer.tokenID == ctx.tokens[i].tokenID &&\r\n                transfer.amount.isAlmostEqualAmount(amounts[i]) &&\r\n                transfer.fee == 0 &&\r\n                (signature.length == 0 || transfer.storageID == join.joinStorageIDs[i]),\r\n                \"INVALID_JOIN_TRANSFER_TX_DATA\"\r\n            );\r\n\r\n            ctx.approveTransfer(transfer);\r\n\r\n            ctx.tokenBalancesL2[i] = ctx.tokenBalancesL2[i].add(transfer.amount);\r\n        }\r\n\r\n        _mintPoolTokenOnL2(ctx, _block, mintAmount, join.owner);\r\n\r\n        // emit JoinProcessed(join.owner, mintAmount, amounts);\r\n    }\r\n\r\n    function _mintPoolTokenOnL2(\r\n        AmmData.Context     memory  ctx,\r\n        ExchangeData.Block  memory  _block,\r\n        uint96                      amount,\r\n        address                     to\r\n        )\r\n        private\r\n        view\r\n    {\r\n        TransferTransaction.Transfer memory transfer = _block.readTransfer(ctx.txIdx++);\r\n\r\n        require(\r\n            transfer.fromAccountID == ctx.accountID &&\r\n            // transfer.toAccountID == UNKNOWN &&\r\n            transfer.from == address(this) &&\r\n            transfer.to == to &&\r\n            transfer.tokenID == ctx.poolTokenID &&\r\n            transfer.amount.isAlmostEqualAmount(amount) &&\r\n            transfer.feeTokenID == 0 &&\r\n            transfer.fee == 0,\r\n            // transfer.storageID == UNKNOWN &&\r\n            \"INVALID_MINT_TX_DATA\"\r\n        );\r\n\r\n        ctx.approveTransfer(transfer);\r\n\r\n        // Update pool balance\r\n        ctx.totalSupply = ctx.totalSupply.add(transfer.amount);\r\n    }\r\n\r\n    function _calculateJoinAmounts(\r\n        AmmData.Context  memory  ctx,\r\n        AmmData.PoolJoin memory  join\r\n        )\r\n        private\r\n        pure\r\n        returns(\r\n            bool            slippageOK,\r\n            uint96          mintAmount,\r\n            uint96[] memory amounts\r\n        )\r\n    {\r\n        // Check if we can still use this join\r\n        amounts = new uint96[](ctx.tokens.length);\r\n\r\n        if (ctx.totalSupply == 0) {\r\n            return(true, AmmData.POOL_TOKEN_BASE().toUint96(), join.joinAmounts);\r\n        }\r\n\r\n        // Calculate the amount of pool tokens that should be minted\r\n        bool initialized = false;\r\n        for (uint i = 0; i < ctx.tokens.length; i++) {\r\n            if (ctx.tokenBalancesL2[i] > 0) {\r\n                uint amountOut = uint(join.joinAmounts[i])\r\n                    .mul(ctx.totalSupply) / uint(ctx.tokenBalancesL2[i]);\r\n\r\n                if (!initialized) {\r\n                    initialized = true;\r\n                    mintAmount = amountOut.toUint96();\r\n                } else if (amountOut < mintAmount) {\r\n                    mintAmount = amountOut.toUint96();\r\n                }\r\n            }\r\n        }\r\n\r\n        if (mintAmount == 0) {\r\n            return (false, 0, amounts);\r\n        }\r\n\r\n        // Calculate the amounts to deposit\r\n        uint ratio = uint(AmmData.POOL_TOKEN_BASE()).mul(mintAmount) / ctx.totalSupply;\r\n\r\n        for (uint i = 0; i < ctx.tokens.length; i++) {\r\n            amounts[i] = (ratio.mul(ctx.tokenBalancesL2[i]) / AmmData.POOL_TOKEN_BASE()).toUint96();\r\n        }\r\n\r\n        slippageOK = (mintAmount >= join.mintMinAmount);\r\n        return (slippageOK, mintAmount, amounts);\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title AmmExitProcess\r\nlibrary AmmExitProcess\r\n{\r\n    using AmmPoolToken      for AmmData.State;\r\n    using AmmUtil           for AmmData.Context;\r\n    using AmmUtil           for uint96;\r\n    using ERC20SafeTransfer for address;\r\n    using MathUint          for uint;\r\n    using MathUint96        for uint96;\r\n    using SafeCast          for uint;\r\n    using SignatureUtil     for bytes32;\r\n    using TransactionReader for ExchangeData.Block;\r\n\r\n    event ForcedExitProcessed(address owner, uint96 burnAmount, uint96[] amounts);\r\n\r\n    function processExit(\r\n        AmmData.State       storage S,\r\n        AmmData.Context     memory  ctx,\r\n        ExchangeData.Block  memory  _block,\r\n        AmmData.PoolExit    memory  exit,\r\n        bytes               memory  signature\r\n        )\r\n        internal\r\n    {\r\n        require(exit.validUntil >= block.timestamp, \"EXPIRED\");\r\n\r\n        bytes32 txHash = AmmExitRequest.hash(ctx.domainSeparator, exit);\r\n        bool isForcedExit = false;\r\n\r\n        if (signature.length == 0) {\r\n            bytes32 forcedExitHash = AmmExitRequest.hash(ctx.domainSeparator, S.forcedExit[exit.owner]);\r\n            if (txHash == forcedExitHash) {\r\n                delete S.forcedExit[exit.owner];\r\n                S.forcedExitCount--;\r\n                isForcedExit = true;\r\n            } else {\r\n                require(S.approvedTx[txHash], \"INVALID_ONCHAIN_APPROVAL\");\r\n                delete S.approvedTx[txHash];\r\n            }\r\n        } else {\r\n            require(txHash.verifySignature(exit.owner, signature), \"INVALID_OFFCHAIN_APPROVAL\");\r\n        }\r\n\r\n        (bool slippageOK, uint96[] memory amounts) = _calculateExitAmounts(ctx, exit);\r\n\r\n        if (isForcedExit) {\r\n            if (!slippageOK) {\r\n                AmmUtil.transferOut(address(this), exit.burnAmount, exit.owner);\r\n                emit ForcedExitProcessed(exit.owner, 0, new uint96[](0));\r\n                return;\r\n            }\r\n\r\n            ctx.totalSupply = ctx.totalSupply.sub(exit.burnAmount);\r\n        } else {\r\n            require(slippageOK, \"EXIT_SLIPPAGE_INVALID\");\r\n            _burnPoolTokenOnL2(ctx, _block, exit.burnAmount, exit.owner, exit.burnStorageID, signature);\r\n        }\r\n\r\n        // Handle liquidity tokens\r\n        for (uint i = 0; i < ctx.tokens.length; i++) {\r\n            TransferTransaction.Transfer memory transfer = _block.readTransfer(ctx.txIdx++);\r\n\r\n            require(\r\n                transfer.fromAccountID == ctx.accountID &&\r\n                // transfer.toAccountID == UNKNOWN &&\r\n                // transfer.storageID == UNKNOWN &&\r\n                transfer.from == address(this) &&\r\n                transfer.to == exit.owner &&\r\n                transfer.tokenID == ctx.tokens[i].tokenID &&\r\n                transfer.amount.add(transfer.fee).isAlmostEqualAmount(amounts[i]),\r\n                \"INVALID_EXIT_TRANSFER_TX_DATA\"\r\n            );\r\n\r\n            if (transfer.fee > 0) {\r\n                require(\r\n                    i == ctx.tokens.length - 1 &&\r\n                    transfer.feeTokenID == ctx.tokens[i].tokenID &&\r\n                    transfer.fee <= exit.fee,\r\n                    \"INVALID_FEES\"\r\n                );\r\n            }\r\n\r\n            ctx.approveTransfer(transfer);\r\n\r\n            ctx.tokenBalancesL2[i] = ctx.tokenBalancesL2[i].sub(transfer.amount);\r\n        }\r\n\r\n        if (isForcedExit) {\r\n            emit ForcedExitProcessed(exit.owner, exit.burnAmount, amounts);\r\n        }\r\n    }\r\n\r\n    function _burnPoolTokenOnL2(\r\n        AmmData.Context     memory  ctx,\r\n        ExchangeData.Block  memory  _block,\r\n        uint96                      amount,\r\n        address                     from,\r\n        uint32                      burnStorageID,\r\n        bytes               memory  signature\r\n        )\r\n        internal\r\n        view\r\n    {\r\n        TransferTransaction.Transfer memory transfer = _block.readTransfer(ctx.txIdx++);\r\n\r\n        require(\r\n            // transfer.fromAccountID == UNKNOWN &&\r\n            transfer.toAccountID == ctx.accountID &&\r\n            transfer.from == from &&\r\n            transfer.to == address(this) &&\r\n            transfer.tokenID == ctx.poolTokenID &&\r\n            transfer.amount.isAlmostEqualAmount(amount) &&\r\n            transfer.feeTokenID == 0 &&\r\n            transfer.fee == 0 &&\r\n            (signature.length == 0 || transfer.storageID == burnStorageID),\r\n            \"INVALID_BURN_TX_DATA\"\r\n        );\r\n\r\n        ctx.approveTransfer(transfer);\r\n\r\n        // Update pool balance\r\n        ctx.totalSupply = ctx.totalSupply.sub(transfer.amount);\r\n    }\r\n\r\n    function _calculateExitAmounts(\r\n        AmmData.Context  memory  ctx,\r\n        AmmData.PoolExit memory  exit\r\n        )\r\n        private\r\n        pure\r\n        returns(\r\n            bool /* slippageOK */,\r\n            uint96[] memory amounts\r\n        )\r\n    {\r\n        amounts = new uint96[](ctx.tokens.length);\r\n\r\n        // Calculate how much will be withdrawn\r\n        uint ratio = uint(AmmData.POOL_TOKEN_BASE()).mul(exit.burnAmount) / ctx.totalSupply;\r\n\r\n        for (uint i = 0; i < ctx.tokens.length; i++) {\r\n            amounts[i] = (ratio.mul(ctx.tokenBalancesL2[i]) / AmmData.POOL_TOKEN_BASE()).toUint96();\r\n            if (amounts[i] < exit.exitMinAmounts[i]) {\r\n                return (false, amounts);\r\n            }\r\n        }\r\n\r\n        return (true, amounts);\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title AmmData\r\nlibrary AmmData\r\n{\r\n    function POOL_TOKEN_BASE() internal pure returns (uint) { return 100 * (10 ** 8); }\r\n    function POOL_TOKEN_MINTED_SUPPLY() internal pure returns (uint) { return uint96(-1); }\r\n\r\n    enum PoolTxType\r\n    {\r\n        NOOP,\r\n        JOIN,\r\n        EXIT\r\n    }\r\n\r\n    struct PoolConfig\r\n    {\r\n        address   sharedConfig;\r\n        address   exchange;\r\n        string    poolName;\r\n        uint32    accountID;\r\n        address[] tokens;\r\n        uint96[]  weights;\r\n        uint8     feeBips;\r\n        string    tokenSymbol;\r\n    }\r\n\r\n    struct PoolJoin\r\n    {\r\n        address   owner;\r\n        uint96[]  joinAmounts;\r\n        uint32[]  joinStorageIDs;\r\n        uint96    mintMinAmount;\r\n        uint32    validUntil;\r\n    }\r\n\r\n    struct PoolExit\r\n    {\r\n        address   owner;\r\n        uint96    burnAmount;\r\n        uint32    burnStorageID; // for pool token withdrawal from user to the pool\r\n        uint96[]  exitMinAmounts; // the amount to receive BEFORE paying the fee.\r\n        uint96    fee;\r\n        uint32    validUntil;\r\n    }\r\n\r\n    struct PoolTx\r\n    {\r\n        PoolTxType txType;\r\n        bytes      data;\r\n        bytes      signature;\r\n    }\r\n\r\n    struct Token\r\n    {\r\n        address addr;\r\n        uint96  weight;\r\n        uint16  tokenID;\r\n    }\r\n\r\n    struct Context\r\n    {\r\n        // functional parameters\r\n        uint txIdx;\r\n\r\n        // Exchange state variables\r\n        IExchangeV3 exchange;\r\n        bytes32     exchangeDomainSeparator;\r\n\r\n        // AMM pool state variables\r\n        bytes32 domainSeparator;\r\n        uint32  accountID;\r\n\r\n        uint16  poolTokenID;\r\n        uint    totalSupply;\r\n\r\n        Token[]  tokens;\r\n        uint96[] tokenBalancesL2;\r\n\r\n        TransactionBuffer transactionBuffer;\r\n    }\r\n\r\n    struct TransactionBuffer\r\n    {\r\n        uint      size;\r\n        address[] owners;\r\n        bytes32[] txHashes;\r\n    }\r\n\r\n    struct State {\r\n        // Pool token state variables\r\n        string poolName;\r\n        string symbol;\r\n        uint   _totalSupply;\r\n\r\n        mapping(address => uint) balanceOf;\r\n        mapping(address => mapping(address => uint)) allowance;\r\n        mapping(address => uint) nonces;\r\n\r\n        // AMM pool state variables\r\n        IAmmSharedConfig sharedConfig;\r\n\r\n        Token[]     tokens;\r\n\r\n        // The order of the following variables important to minimize loads\r\n        bytes32     exchangeDomainSeparator;\r\n        bytes32     domainSeparator;\r\n        IExchangeV3 exchange;\r\n        uint32      accountID;\r\n        uint16      poolTokenID;\r\n        uint8       feeBips;\r\n\r\n        address     exchangeOwner;\r\n\r\n        uint64      shutdownTimestamp;\r\n        uint16      forcedExitCount;\r\n\r\n        // A map from a user to the forced exit.\r\n        mapping (address => PoolExit) forcedExit;\r\n        mapping (bytes32 => bool) approvedTx;\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title AmmPoolToken\r\nlibrary AmmPoolToken\r\n{\r\n    using MathUint      for uint;\r\n    using MathUint96    for uint96;\r\n    using SignatureUtil for bytes32;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from,  address indexed to,      uint value);\r\n\r\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\r\n    function totalSupply(\r\n        AmmData.State storage S\r\n        )\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        return S._totalSupply;\r\n    }\r\n\r\n    function approve(\r\n        AmmData.State storage S,\r\n        address               spender,\r\n        uint                  value\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        _approve(S, msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(\r\n        AmmData.State storage S,\r\n        address               to,\r\n        uint                  value\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        _transfer(S, msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        AmmData.State storage S,\r\n        address               from,\r\n        address               to,\r\n        uint                  value\r\n        )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (msg.sender != address(this) &&\r\n            S.allowance[from][msg.sender] != uint(-1)) {\r\n            S.allowance[from][msg.sender] = S.allowance[from][msg.sender].sub(value);\r\n        }\r\n         _transfer(S, from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(\r\n        AmmData.State storage S,\r\n        address               owner,\r\n        address               spender,\r\n        uint256               value,\r\n        uint256               deadline,\r\n        bytes        calldata signature\r\n        )\r\n        internal\r\n    {\r\n        require(deadline >= block.timestamp, 'EXPIRED');\r\n\r\n        bytes32 hash = EIP712.hashPacked(\r\n            S.domainSeparator,\r\n            keccak256(\r\n                abi.encode(\r\n                    PERMIT_TYPEHASH,\r\n                    owner,\r\n                    spender,\r\n                    value,\r\n                    S.nonces[owner]++,\r\n                    deadline\r\n                )\r\n            )\r\n        );\r\n\r\n        require(hash.verifySignature(owner, signature), 'INVALID_SIGNATURE');\r\n        _approve(S, owner, spender, value);\r\n    }\r\n\r\n    function _approve(\r\n        AmmData.State storage S,\r\n        address               owner,\r\n        address               spender,\r\n        uint                  value\r\n        )\r\n        private\r\n    {\r\n        if (spender != address(this)) {\r\n            S.allowance[owner][spender] = value;\r\n            emit Approval(owner, spender, value);\r\n        }\r\n    }\r\n\r\n    function _transfer(\r\n        AmmData.State storage S,\r\n        address               from,\r\n        address               to,\r\n        uint                  value\r\n        )\r\n        private\r\n    {\r\n        S.balanceOf[from] = S.balanceOf[from].sub(value);\r\n        S.balanceOf[to] = S.balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title AmmJoinRequest\r\nlibrary AmmJoinRequest\r\n{\r\n    bytes32 constant private POOLJOIN_TYPEHASH = keccak256(\r\n        \"PoolJoin(address owner,uint96[] joinAmounts,uint32[] joinStorageIDs,uint96 mintMinAmount,uint32 validUntil)\"\r\n    );\r\n\r\n    event PoolJoinRequested(AmmData.PoolJoin join);\r\n\r\n    function joinPool(\r\n        AmmData.State storage S,\r\n        uint96[]     calldata joinAmounts,\r\n        uint96                mintMinAmount\r\n        )\r\n        public\r\n    {\r\n        require(joinAmounts.length == S.tokens.length,\"INVALID_PARAM_SIZE\");\r\n\r\n        for (uint i = 0; i < S.tokens.length; i++) {\r\n            require(joinAmounts[i] > 0, \"INVALID_VALUE\");\r\n        }\r\n\r\n        AmmData.PoolJoin memory join = AmmData.PoolJoin({\r\n            owner: msg.sender,\r\n            joinAmounts: joinAmounts,\r\n            joinStorageIDs: new uint32[](0),\r\n            mintMinAmount: mintMinAmount,\r\n            validUntil: uint32(block.timestamp + S.sharedConfig.maxForcedExitAge())\r\n        });\r\n\r\n        // Approve the join\r\n        bytes32 txHash = hash(S.domainSeparator, join);\r\n        S.approvedTx[txHash] = true;\r\n\r\n        emit PoolJoinRequested(join);\r\n    }\r\n\r\n    function hash(\r\n        bytes32 domainSeparator,\r\n        AmmData.PoolJoin memory join\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return EIP712.hashPacked(\r\n            domainSeparator,\r\n            keccak256(\r\n                abi.encode(\r\n                    POOLJOIN_TYPEHASH,\r\n                    join.owner,\r\n                    keccak256(abi.encodePacked(join.joinAmounts)),\r\n                    keccak256(abi.encodePacked(join.joinStorageIDs)),\r\n                    join.mintMinAmount,\r\n                    join.validUntil\r\n                )\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title AmmUtil\r\nlibrary AmmUtil\r\n{\r\n    using AddressUtil       for address;\r\n    using ERC20SafeTransfer for address;\r\n    using MathUint          for uint;\r\n\r\n    function approveTransfer(\r\n        AmmData.Context  memory  ctx,\r\n        TransferTransaction.Transfer memory transfer\r\n        )\r\n        internal\r\n        pure\r\n    {\r\n        transfer.validUntil = 0xffffffff;\r\n        transfer.maxFee = transfer.fee;\r\n        bytes32 hash = TransferTransaction.hashTx(ctx.exchangeDomainSeparator, transfer);\r\n        approveExchangeTransaction(ctx.transactionBuffer, transfer.from, hash);\r\n    }\r\n\r\n    function approveExchangeTransaction(\r\n        AmmData.TransactionBuffer memory buffer,\r\n        address                          owner,\r\n        bytes32                          txHash\r\n        )\r\n        internal\r\n        pure\r\n    {\r\n        buffer.owners[buffer.size] = owner;\r\n        buffer.txHashes[buffer.size] = txHash;\r\n        buffer.size++;\r\n    }\r\n\r\n    function isAlmostEqualAmount(\r\n        uint96 amount,\r\n        uint96 targetAmount\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (targetAmount == 0) {\r\n            return amount == 0;\r\n        } else {\r\n            // Max rounding error for a float24 is 2/100000\r\n            // But relayer may use float rounding multiple times\r\n            // so the range is expanded to [100000 - 8, 100000 + 8]\r\n            uint ratio = (uint(amount) * 100000) / uint(targetAmount);\r\n            return (100000 - 8) <= ratio && ratio <= (100000 + 8);\r\n        }\r\n    }\r\n\r\n    function isAlmostEqualFee(\r\n        uint96 amount,\r\n        uint96 targetAmount\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (targetAmount == 0) {\r\n            return amount == 0;\r\n        } else {\r\n            // Max rounding error for a float16 is 5/1000\r\n            uint ratio = (uint(amount) * 1000) / uint(targetAmount);\r\n            return (1000 - 5) <= ratio && ratio <= (1000 + 5);\r\n        }\r\n    }\r\n\r\n    function transferIn(\r\n        address token,\r\n        uint    amount\r\n        )\r\n        internal\r\n    {\r\n        if (token == address(0)) {\r\n            require(msg.value == amount, \"INVALID_ETH_VALUE\");\r\n        } else if (amount > 0) {\r\n            token.safeTransferFromAndVerify(msg.sender, address(this), amount);\r\n        }\r\n    }\r\n\r\n    function transferOut(\r\n        address token,\r\n        uint    amount,\r\n        address to\r\n        )\r\n        internal\r\n    {\r\n        if (token == address(0)) {\r\n            to.sendETHAndVerify(amount, gasleft());\r\n        } else {\r\n            token.safeTransferAndVerify(to, amount);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title AmmExitRequest\r\nlibrary AmmExitRequest\r\n{\r\n    bytes32 constant public POOLEXIT_TYPEHASH = keccak256(\r\n        \"PoolExit(address owner,uint96 burnAmount,uint32 burnStorageID,uint96[] exitMinAmounts,uint96 fee,uint32 validUntil)\"\r\n    );\r\n\r\n    event PoolExitRequested(AmmData.PoolExit exit, bool force);\r\n\r\n    function exitPool(\r\n        AmmData.State storage S,\r\n        uint96                burnAmount,\r\n        uint96[]     calldata exitMinAmounts,\r\n        bool                  force\r\n        )\r\n        public\r\n    {\r\n        require(burnAmount > 0, \"INVALID_BURN_AMOUNT\");\r\n        require(exitMinAmounts.length == S.tokens.length, \"INVALID_EXIT_AMOUNTS\");\r\n\r\n        AmmData.PoolExit memory exit = AmmData.PoolExit({\r\n            owner: msg.sender,\r\n            burnAmount: burnAmount,\r\n            burnStorageID: 0,\r\n            exitMinAmounts: exitMinAmounts,\r\n            fee: 0,\r\n            validUntil: uint32(block.timestamp + S.sharedConfig.maxForcedExitAge())\r\n        });\r\n\r\n        if (force) {\r\n            require(S.forcedExit[msg.sender].validUntil == 0, \"DUPLICATE\");\r\n            require(S.forcedExitCount < S.sharedConfig.maxForcedExitCount(), \"TOO_MANY_FORCED_EXITS\");\r\n\r\n            AmmUtil.transferIn(address(this), burnAmount);\r\n\r\n            uint feeAmount = S.sharedConfig.forcedExitFee();\r\n            AmmUtil.transferIn(address(0), feeAmount);\r\n            AmmUtil.transferOut(address(0), feeAmount, S.exchange.owner());\r\n\r\n            S.forcedExit[msg.sender] = exit;\r\n            S.forcedExitCount++;\r\n        } else {\r\n            AmmUtil.transferIn(address(0), 0);\r\n\r\n            bytes32 txHash = hash(S.domainSeparator, exit);\r\n            S.approvedTx[txHash] = true;\r\n        }\r\n\r\n        emit PoolExitRequested(exit, force);\r\n    }\r\n\r\n    function hash(\r\n        bytes32 domainSeparator,\r\n        AmmData.PoolExit memory exit\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return EIP712.hashPacked(\r\n            domainSeparator,\r\n            keccak256(\r\n                abi.encode(\r\n                    POOLEXIT_TYPEHASH,\r\n                    exit.owner,\r\n                    exit.burnAmount,\r\n                    exit.burnStorageID,\r\n                    keccak256(abi.encodePacked(exit.exitMinAmounts)),\r\n                    exit.fee,\r\n                    exit.validUntil\r\n                )\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title AmmBlockReceiver\r\nlibrary AmmBlockReceiver\r\n{\r\n    using AmmExitProcess    for AmmData.State;\r\n    using AmmJoinProcess    for AmmData.State;\r\n    using AmmPoolToken      for AmmData.State;\r\n    using AmmUpdateProcess  for AmmData.State;\r\n    using BlockReader       for ExchangeData.Block;\r\n\r\n    function beforeBlockSubmission(\r\n        AmmData.State      storage   S,\r\n        ExchangeData.Block memory   _block,\r\n        bytes              calldata data,\r\n        uint                        txIdx,\r\n        uint                        numTxs\r\n        )\r\n        internal\r\n    {\r\n        AmmData.Context memory ctx = _getContext(S, txIdx);\r\n\r\n        BlockReader.BlockHeader memory header = _block.readHeader();\r\n        require(header.exchange == address(ctx.exchange), \"INVALID_EXCHANGE\");\r\n\r\n        S.approveAmmUpdates(ctx, _block);\r\n\r\n        _processPoolTx(S, ctx, _block, data);\r\n\r\n        // Approve transactions\r\n        ctx.exchange.approveTransactions(ctx.transactionBuffer.owners, ctx.transactionBuffer.txHashes);\r\n\r\n        // Update state\r\n        S._totalSupply = ctx.totalSupply;\r\n\r\n        // Make sure we haven't consumed more transactions than expected\r\n        require(numTxs >= (ctx.txIdx - txIdx), \"INVALID_NUM_TXS\");\r\n    }\r\n\r\n    function _getContext(\r\n        AmmData.State      storage S,\r\n        uint                       txIdx\r\n        )\r\n        private\r\n        view\r\n        returns (AmmData.Context memory)\r\n    {\r\n        uint size = S.tokens.length;\r\n        return AmmData.Context({\r\n            txIdx: txIdx,\r\n            exchange: S.exchange,\r\n            exchangeDomainSeparator: S.exchangeDomainSeparator,\r\n            domainSeparator: S.domainSeparator,\r\n            accountID: S.accountID,\r\n            poolTokenID: S.poolTokenID,\r\n            totalSupply: S._totalSupply,\r\n            tokens: S.tokens,\r\n            tokenBalancesL2: new uint96[](size),\r\n            transactionBuffer: AmmData.TransactionBuffer({\r\n                size: 0,\r\n                owners: new address[](size*2 + 1),\r\n                txHashes: new bytes32[](size*2 + 1)\r\n            })\r\n        });\r\n    }\r\n\r\n    function _processPoolTx(\r\n        AmmData.State           storage   S,\r\n        AmmData.Context         memory    ctx,\r\n        ExchangeData.Block      memory    _block,\r\n        bytes                   calldata  poolTxData\r\n        )\r\n        private\r\n    {\r\n        AmmData.PoolTx memory poolTx = abi.decode(poolTxData, (AmmData.PoolTx));\r\n        if (poolTx.txType == AmmData.PoolTxType.JOIN) {\r\n            S.processJoin(\r\n                ctx,\r\n                _block,\r\n                abi.decode(poolTx.data, (AmmData.PoolJoin)),\r\n                poolTx.signature\r\n            );\r\n        } else if (poolTx.txType == AmmData.PoolTxType.EXIT) {\r\n            S.processExit(\r\n                ctx,\r\n                _block,\r\n                abi.decode(poolTx.data, (AmmData.PoolExit)),\r\n                poolTx.signature\r\n            );\r\n        } else {\r\n            revert(\"INVALID_POOL_TX_TYPE\");\r\n        }\r\n    }\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title IBlockReceiver\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nabstract contract IBlockReceiver\r\n{\r\n    function beforeBlockSubmission(\r\n        ExchangeData.Block memory _block,\r\n        bytes              memory data,\r\n        uint                      txIdx,\r\n        uint                      numTxs\r\n        )\r\n        external\r\n        virtual;\r\n}\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n// import \"../lib/Drainable.sol\";\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n/// @title ReentrancyGuard\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Exposes a modifier that guards a function against reentrancy\r\n///      Changing the value of the same storage value multiple times in a transaction\r\n///      is cheap (starting from Istanbul) so there is no need to minimize\r\n///      the number of times the value is changed\r\ncontract ReentrancyGuard\r\n{\r\n    //The default value must be 0 in order to work behind a proxy.\r\n    uint private _guardValue;\r\n\r\n    // Use this modifier on a function to prevent reentrancy\r\n    modifier nonReentrant()\r\n    {\r\n        // Check if the guard value has its original value\r\n        require(_guardValue == 0, \"REENTRANCY\");\r\n\r\n        // Set the value to something else\r\n        _guardValue = 1;\r\n\r\n        // Function body\r\n        _;\r\n\r\n        // Set the value back\r\n        _guardValue = 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title AmmStatus\r\nlibrary AmmStatus\r\n{\r\n    using AmmPoolToken      for AmmData.State;\r\n    using MathUint          for uint;\r\n    using MathUint96        for uint96;\r\n    using SignatureUtil     for bytes32;\r\n\r\n    event Shutdown(uint timestamp);\r\n\r\n    function isOnline(AmmData.State storage S)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return S.shutdownTimestamp == 0;\r\n    }\r\n\r\n    function setupPool(\r\n        AmmData.State      storage  S,\r\n        AmmData.PoolConfig calldata config\r\n        )\r\n        public\r\n    {\r\n        require(\r\n            bytes(config.poolName).length > 0 && bytes(config.tokenSymbol).length > 0,\r\n            \"INVALID_NAME_OR_SYMBOL\"\r\n        );\r\n        require(config.sharedConfig != address(0), \"INVALID_SHARED_CONFIG\");\r\n        require(config.tokens.length == config.weights.length, \"INVALID_DATA\");\r\n        require(config.tokens.length >= 2, \"INVALID_DATA\");\r\n        require(config.exchange != address(0), \"INVALID_EXCHANGE\");\r\n        require(config.accountID != 0, \"INVALID_ACCOUNT_ID\");\r\n        require(S.tokens.length == 0, \"ALREADY_INITIALIZED\");\r\n\r\n        S.sharedConfig = IAmmSharedConfig(config.sharedConfig);\r\n        IExchangeV3 exchange = IExchangeV3(config.exchange);\r\n        S.exchange = exchange;\r\n        S.exchangeOwner = exchange.owner();\r\n        S.exchangeDomainSeparator = exchange.getDomainSeparator();\r\n        S.accountID = config.accountID;\r\n        S.poolTokenID = exchange.getTokenID(address(this));\r\n        S.feeBips = config.feeBips;\r\n        S.domainSeparator = EIP712.hash(EIP712.Domain(config.poolName, \"1.0.0\", address(this)));\r\n\r\n        S.poolName = config.poolName;\r\n        S.symbol = config.tokenSymbol;\r\n\r\n        for (uint i = 0; i < config.tokens.length; i++) {\r\n            require(config.weights[i] > 0, \"INVALID_TOKEN_WEIGHT\");\r\n\r\n            address token = config.tokens[i];\r\n            S.tokens.push(AmmData.Token({\r\n                addr: token,\r\n                tokenID: exchange.getTokenID(token),\r\n                weight: config.weights[i]\r\n            }));\r\n        }\r\n\r\n        // Mint all liquidity tokens to the pool account on L2\r\n        S.balanceOf[address(this)] = AmmData.POOL_TOKEN_MINTED_SUPPLY();\r\n        S.allowance[address(this)][address(exchange.getDepositContract())] = uint(-1);\r\n        exchange.deposit(\r\n            address(this), // from\r\n            address(this), // to\r\n            address(this), // token\r\n            uint96(AmmData.POOL_TOKEN_MINTED_SUPPLY()),\r\n            new bytes(0)\r\n        );\r\n    }\r\n\r\n    // Anyone is able to shut down the pool when requests aren't being processed any more.\r\n    function shutdown(\r\n        AmmData.State storage S,\r\n        address               exitOwner\r\n        )\r\n        public\r\n    {\r\n        // If the exchange is in withdrawal mode allow the pool to be shutdown immediately\r\n        if (!S.exchange.isInWithdrawalMode()) {\r\n            uint64 validUntil = S.forcedExit[exitOwner].validUntil;\r\n            require(validUntil > 0 && validUntil < block.timestamp, \"INVALID_CHALLENGE\");\r\n\r\n            uint size = S.tokens.length;\r\n\r\n            for (uint i = 0; i < size; i++) {\r\n                S.exchange.forceWithdraw{value: msg.value / size}(\r\n                    address(this),\r\n                    S.tokens[i].addr,\r\n                    S.accountID\r\n                );\r\n            }\r\n        }\r\n        S.shutdownTimestamp = uint64(block.timestamp);\r\n        emit Shutdown(block.timestamp);\r\n    }\r\n\r\n    // Anyone is able to update the cached exchange owner to the current owner.\r\n    function updateExchangeOwner(AmmData.State storage S)\r\n        public\r\n    {\r\n        S.exchangeOwner = S.exchange.owner();\r\n    }\r\n}\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title AmmWithdrawal\r\nlibrary AmmWithdrawal\r\n{\r\n    using AmmPoolToken      for AmmData.State;\r\n    using AmmStatus         for AmmData.State;\r\n    using MathUint          for uint;\r\n\r\n    function withdrawWhenOffline(\r\n        AmmData.State storage S\r\n        )\r\n        public\r\n    {\r\n        _checkWithdrawalConditionInShutdown(S);\r\n\r\n        // Burn the full balance\r\n        uint poolAmount = S.balanceOf[msg.sender];\r\n        if (poolAmount > 0) {\r\n            S.transfer(address(this), poolAmount);\r\n        }\r\n\r\n        // Burn any additional pool tokens stuck in forced exits\r\n        AmmData.PoolExit storage exit = S.forcedExit[msg.sender];\r\n        if (exit.burnAmount > 0) {\r\n            poolAmount = poolAmount.add(exit.burnAmount);\r\n            delete S.forcedExit[msg.sender];\r\n        }\r\n\r\n        require(poolAmount > 0, \"ZERO_POOL_AMOUNT\");\r\n\r\n        // Withdraw the part owned of the pool\r\n        uint totalSupply = S.totalSupply();\r\n        for (uint i = 0; i < S.tokens.length; i++) {\r\n            address token = S.tokens[i].addr;\r\n            uint balance = token == address(0) ?\r\n                address(this).balance :\r\n                ERC20(token).balanceOf(address(this));\r\n\r\n            uint amount = balance.mul(poolAmount) / totalSupply;\r\n            AmmUtil.transferOut(token, amount, msg.sender);\r\n        }\r\n\r\n        S._totalSupply = S._totalSupply.sub(poolAmount);\r\n    }\r\n\r\n    function _checkWithdrawalConditionInShutdown(\r\n        AmmData.State storage S\r\n        )\r\n        private\r\n        view\r\n    {\r\n        IExchangeV3 exchange = S.exchange;\r\n        bool withdrawalMode = exchange.isInWithdrawalMode();\r\n\r\n        for (uint i = 0; i < S.tokens.length; i++) {\r\n            address token = S.tokens[i].addr;\r\n\r\n            require(\r\n                withdrawalMode && exchange.isWithdrawnInWithdrawalMode(S.accountID, token) ||\r\n                !withdrawalMode && !exchange.isForcedWithdrawalPending(S.accountID, token),\r\n                \"PENDING_WITHDRAWAL\"\r\n            );\r\n\r\n            // Check that nothing is withdrawable anymore.\r\n            require(\r\n                exchange.getAmountWithdrawable(address(this), token) == 0,\r\n                \"MORE_TO_WITHDRAW\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n// Copyright 2017 Loopring Technology Limited.\r\n\r\n\r\n\r\n\r\n\r\n/// @title ERC2612 Token with permit  712-signed approvals but with\r\n///        bytes as signature\r\n/// @dev see https://eips.ethereum.org/EIPS/eip-2612\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nabstract contract ERC2612 is ERC20\r\n{\r\n    function nonces(address owner)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint);\r\n\r\n    function permit(\r\n        address        owner,\r\n        address        spender,\r\n        uint256        value,\r\n        uint256        deadline,\r\n        bytes calldata signature\r\n        )\r\n        external\r\n        virtual;\r\n}\r\n\r\n\r\n\r\n\r\nabstract contract PoolToken is ERC2612 {\r\n    using MathUint     for uint;\r\n    using AmmPoolToken for AmmData.State;\r\n\r\n    uint   public constant decimals = 8;\r\n\r\n    AmmData.State state;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from,  address indexed to,      uint value);\r\n\r\n    function name()\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return state.poolName;\r\n    }\r\n\r\n    function symbol()\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return state.symbol;\r\n    }\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n        override\r\n        returns (uint)\r\n    {\r\n        return state.totalSupply();\r\n    }\r\n\r\n    function balanceOf(address owner)\r\n        public\r\n        view\r\n        override\r\n        returns (uint balance)\r\n    {\r\n        return state.balanceOf[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        override\r\n        returns (uint)\r\n    {\r\n        return spender == address(this) ?\r\n            uint(-1) :\r\n            state.allowance[owner][spender];\r\n    }\r\n\r\n    function nonces(address owner)\r\n        public\r\n        view\r\n        override\r\n        returns (uint)\r\n    {\r\n        return state.nonces[owner];\r\n    }\r\n\r\n    function approve(address spender, uint value)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        return state.approve(spender, value);\r\n    }\r\n\r\n    function transfer(address to, uint value)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        return state.transfer(to, value);\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n       return state.transferFrom(from, to, value);\r\n    }\r\n\r\n    function permit(\r\n        address        owner,\r\n        address        spender,\r\n        uint256        value,\r\n        uint256        deadline,\r\n        bytes calldata signature\r\n        )\r\n        external\r\n        override\r\n    {\r\n        state.permit(owner, spender, value, deadline, signature);\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title LoopringAmmPool\r\ncontract LoopringAmmPool is\r\n    PoolToken,\r\n    IAgent,\r\n    IBlockReceiver,\r\n    ReentrancyGuard\r\n{\r\n    using AmmBlockReceiver for AmmData.State;\r\n    using AmmJoinRequest   for AmmData.State;\r\n    using AmmExitRequest   for AmmData.State;\r\n    using AmmPoolToken     for AmmData.State;\r\n    using AmmStatus        for AmmData.State;\r\n    using AmmWithdrawal    for AmmData.State;\r\n\r\n    event PoolJoinRequested(AmmData.PoolJoin join);\r\n    event PoolExitRequested(AmmData.PoolExit exit, bool force);\r\n    event ForcedExitProcessed(address owner, uint96 burnAmount, uint96[] amounts);\r\n    event Shutdown(uint timestamp);\r\n\r\n    modifier onlyFromExchangeOwner()\r\n    {\r\n        require(msg.sender == state.exchangeOwner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenOnline()\r\n    {\r\n        require(state.isOnline(), \"NOT_ONLINE\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenOffline()\r\n    {\r\n        require(!state.isOnline(), \"NOT_OFFLINE\");\r\n        _;\r\n    }\r\n\r\n    function isOnline()\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return state.isOnline();\r\n    }\r\n\r\n    receive() payable external {}\r\n\r\n    function setupPool(AmmData.PoolConfig calldata config)\r\n        external\r\n        nonReentrant\r\n    {\r\n        state.setupPool(config);\r\n    }\r\n\r\n    // Anyone is able to shut down the pool when requests aren't being processed any more.\r\n    function shutdown(address exitOwner)\r\n        external\r\n        payable\r\n        onlyWhenOnline\r\n        nonReentrant\r\n    {\r\n        state.shutdown(exitOwner);\r\n    }\r\n\r\n    function joinPool(\r\n        uint96[]     calldata joinAmounts,\r\n        uint96                mintMinAmount\r\n        )\r\n        external\r\n        payable\r\n        onlyWhenOnline\r\n        nonReentrant\r\n    {\r\n        state.joinPool(joinAmounts, mintMinAmount);\r\n    }\r\n\r\n    function exitPool(\r\n        uint96            burnAmount,\r\n        uint96[] calldata exitMinAmounts\r\n        )\r\n        external\r\n        payable\r\n        onlyWhenOnline\r\n        nonReentrant\r\n    {\r\n        state.exitPool(burnAmount, exitMinAmounts, false);\r\n    }\r\n\r\n    function forceExitPool(\r\n        uint96            burnAmount,\r\n        uint96[] calldata exitMinAmounts\r\n        )\r\n        external\r\n        payable\r\n        onlyWhenOnline\r\n        nonReentrant\r\n    {\r\n        state.exitPool(burnAmount, exitMinAmounts, true);\r\n    }\r\n\r\n    function beforeBlockSubmission(\r\n        ExchangeData.Block memory   _block,\r\n        bytes              calldata data,\r\n        uint                        txIdx,\r\n        uint                        numTxs\r\n        )\r\n        external\r\n        override\r\n        onlyWhenOnline\r\n        onlyFromExchangeOwner\r\n        // nonReentrant     // Not needed, does not do any external calls (except to the exchange)\r\n                            // and can only be called by the exchange owner.\r\n    {\r\n        state.beforeBlockSubmission(_block, data, txIdx, numTxs);\r\n    }\r\n\r\n    function withdrawWhenOffline()\r\n        external\r\n        onlyWhenOffline\r\n        nonReentrant\r\n    {\r\n        state.withdrawWhenOffline();\r\n    }\r\n\r\n    function updateExchangeOwner()\r\n        external\r\n        nonReentrant\r\n    {\r\n        state.updateExchangeOwner();\r\n    }\r\n}"}}}