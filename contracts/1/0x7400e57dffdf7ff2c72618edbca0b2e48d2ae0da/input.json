{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":2000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Holder.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol@v4.3.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.3.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol@v4.3.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC165, IERC165)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC1155Receiver).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol@v4.3.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ncontract ERC1155Holder is ERC1155Receiver {\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n\r\n// File contracts/Interface.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/* is ERC165 */\r\ninterface ERC1155 {\r\n    /**\r\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\r\n        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\r\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\r\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\r\n        The `_id` argument MUST be the token type being transferred.\r\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\r\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\r\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).        \r\n    */\r\n    event TransferSingle(\r\n        address indexed _operator,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _id,\r\n        uint256 _value\r\n    );\r\n\r\n    /**\r\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).      \r\n        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\r\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\r\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\r\n        The `_ids` argument MUST be the list of tokens being transferred.\r\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\r\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\r\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).                \r\n    */\r\n    event TransferBatch(\r\n        address indexed _operator,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256[] _ids,\r\n        uint256[] _values\r\n    );\r\n\r\n    /**\r\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absence of an event assumes disabled).        \r\n    */\r\n    event ApprovalForAll(\r\n        address indexed _owner,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n\r\n    /**\r\n        @dev MUST emit when the URI is updated for a token ID.\r\n        URIs are defined in RFC 3986.\r\n        The URI MUST point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\r\n    */\r\n    event URI(string _value, uint256 indexed _id);\r\n\r\n    /**\r\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\r\n        MUST revert on any other error.\r\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\r\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).        \r\n        @param _from    Source address\r\n        @param _to      Target address\r\n        @param _id      ID of the token type\r\n        @param _value   Transfer amount\r\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\r\n    */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _id,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) external;\r\n\r\n    /**\r\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if length of `_ids` is not the same as length of `_values`.\r\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\r\n        MUST revert on any other error.        \r\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\r\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\r\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).                      \r\n        @param _from    Source address\r\n        @param _to      Target address\r\n        @param _ids     IDs of each token type (order and length must match _values array)\r\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\r\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\r\n    */\r\n    function safeBatchTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256[] calldata _ids,\r\n        uint256[] calldata _values,\r\n        bytes calldata _data\r\n    ) external;\r\n\r\n    /**\r\n        @notice Get the balance of an account's tokens.\r\n        @param _owner  The address of the token holder\r\n        @param _id     ID of the token\r\n        @return        The _owner's balance of the token type requested\r\n     */\r\n    function balanceOf(address _owner, uint256 _id)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Get the balance of multiple account/token pairs\r\n        @param _owners The addresses of the token holders\r\n        @param _ids    ID of the tokens\r\n        @return        The _owner's balance of the token types requested (i.e. balance for each (owner, id) pair)\r\n     */\r\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\r\n        @dev MUST emit the ApprovalForAll event on success.\r\n        @param _operator  Address to add to the set of authorized operators\r\n        @param _approved  True if the operator is approved, false to revoke approval\r\n    */\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /**\r\n        @notice Queries the approval status of an operator for a given owner.\r\n        @param _owner     The owner of the tokens\r\n        @param _operator  Address of authorized operator\r\n        @return           True if the operator is approved, false if not\r\n    */\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\ninterface ERC20 {\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n}\r\n\r\n// File contracts/StakeContract.sol\r\n\r\npragma solidity 0.8.0;\r\n\r\ncontract Holder is ERC1155Holder {\r\n    ERC1155 nft_contract;\r\n    ERC20 metagold_contract;\r\n\r\n    address public owner;\r\n\r\n    uint256 tokenYields = 10;\r\n    uint256 yieldTime = 1 days;\r\n    uint256 stakingTime = 365 * 5 days;\r\n    uint256 stakingStart;\r\n\r\n    mapping(uint256 => address) public stakers;\r\n    mapping(uint256 => uint256) public staking_time;\r\n\r\n    modifier tokenIdWhiteList(uint256[] memory tokenIds) {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            uint256 _tokenId = tokenIds[i];\r\n            require(\r\n                _tokenId <=\r\n                    13816368292405329361516153857659306852598365020171615076828770453862700023809 &&\r\n                    _tokenId >=\r\n                    13816368292405329361516153857659306852598365020171615076828769351052537364481,\r\n                \"Invalid token Id\"\r\n            );\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isStakingAlive() {\r\n        require(\r\n            stakingTime + stakingStart > block.timestamp,\r\n            \"Staking time ended\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier isStakingEnded() {\r\n        require(\r\n            stakingTime + stakingStart <= block.timestamp,\r\n            \"Staking time not ended\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _metagold_contract,\r\n        address _nft_contractAddress,\r\n        address _owner\r\n    ) {\r\n        metagold_contract = ERC20(_metagold_contract);\r\n        nft_contract = ERC1155(_nft_contractAddress);\r\n        stakingStart = block.timestamp;\r\n\r\n        owner = _owner;\r\n    }\r\n\r\n    function stake(uint256[] memory tokenIds, uint256[] memory tokenValues)\r\n        external\r\n        isStakingAlive\r\n        tokenIdWhiteList(tokenIds)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            nft_contract.isApprovedForAll(msg.sender, address(this)),\r\n            \"Opeartaor was not approved\"\r\n        );\r\n\r\n        // user must own the nfts\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            require(\r\n                nft_contract.balanceOf(msg.sender, tokenIds[i]) == 1,\r\n                \"User must own the NFT\"\r\n            );\r\n        }\r\n\r\n        nft_contract.safeBatchTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            tokenIds,\r\n            tokenValues,\r\n            \"\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            stakers[tokenIds[i]] = msg.sender;\r\n            staking_time[tokenIds[i]] = block.timestamp;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function unstake(uint256[] memory tokenIds, uint256[] memory tokenValues)\r\n        external\r\n        returns (bool)\r\n    {\r\n        // unstake logic\r\n        uint256 _tokenYield;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            require(\r\n                stakers[tokenIds[i]] == msg.sender,\r\n                \"User didn't stake the contract\"\r\n            );\r\n            _tokenYield += CalculateYield(tokenIds[i]);\r\n            stakers[tokenIds[i]] = address(0);\r\n            staking_time[tokenIds[i]] = 0;\r\n        }\r\n\r\n        nft_contract.safeBatchTransferFrom(\r\n            address(this),\r\n            msg.sender,\r\n            tokenIds,\r\n            tokenValues,\r\n            \"\"\r\n        );\r\n\r\n        // user gets rewards\r\n        require(metagold_contract.transfer(msg.sender, _tokenYield), \"failed\");\r\n\r\n        return true;\r\n    }\r\n\r\n    function claimRewrad(uint256[] memory tokenIds) external returns (bool) {\r\n        // unstake logic\r\n        uint256 _tokenYield;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            require(\r\n                stakers[tokenIds[i]] == msg.sender,\r\n                \"User didn't stake the contract\"\r\n            );\r\n            _tokenYield += CalculateYield(tokenIds[i]);\r\n            staking_time[tokenIds[i]] = block.timestamp;\r\n        }\r\n\r\n        metagold_contract.transfer(msg.sender, _tokenYield);\r\n\r\n        return true;\r\n    }\r\n\r\n    function CalculateYield(uint256 tokenId) public view returns (uint256) {\r\n        require(\r\n            stakers[tokenId] == msg.sender,\r\n            \"User haven't staked the token\"\r\n        );\r\n        uint256 timeStaked;\r\n        if (block.timestamp <= stakingTime + stakingStart) {\r\n            // staking time is valid\r\n            timeStaked = block.timestamp - staking_time[tokenId];\r\n        } else {\r\n            // staking time ended\r\n            timeStaked = stakingTime + stakingStart - staking_time[tokenId];\r\n        }\r\n        uint256 yield = (timeStaked / yieldTime) * tokenYields;\r\n        return yield * 1 ether;\r\n    }\r\n\r\n    function SafeNFTWithdraw(\r\n        uint256[] memory tokenIds,\r\n        uint256[] memory tokenValues\r\n    ) external returns (bool) {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            require(\r\n                stakers[tokenIds[i]] == msg.sender,\r\n                \"User didn't stake the contract\"\r\n            );\r\n            stakers[tokenIds[i]] = address(0);\r\n            staking_time[tokenIds[i]] = 0;\r\n        }\r\n\r\n        nft_contract.safeBatchTransferFrom(\r\n            address(this),\r\n            msg.sender,\r\n            tokenIds,\r\n            tokenValues,\r\n            \"\"\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    function postStakeWithdraw() external onlyOwner isStakingEnded {\r\n        uint256 remaning = metagold_contract.balanceOf(address(this));\r\n        require(metagold_contract.transfer(msg.sender, remaning));\r\n    }\r\n\r\n    function changeAdmin(address _newAdmin) external onlyOwner {\r\n        require(_newAdmin != address(0));\r\n        owner = _newAdmin;\r\n    }\r\n}"}}}