{"language":"Solidity","settings":{"evmVersion":"london","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":100},"remappings":[],"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}},"sources":{"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"},"contracts/GmDataInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface GmDataInterface {\n    struct GmDataSet {\n        bytes imageName;\n        bytes compressedImage;\n        uint256 compressedSize;\n    }\n\n    function getSvg(uint256 index) external pure returns (GmDataSet memory);\n}\n"},"contracts/GmRenderer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {InflateLib} from \"./InflateLib.sol\";\nimport {GmDataInterface} from \"./GmDataInterface.sol\";\nimport {StringsUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\ninterface ICourierFont {\n    function font() external view returns (string memory);\n}\n\ncontract GmRenderer {\n    ICourierFont private immutable font;\n    GmDataInterface private immutable gmData1;\n    GmDataInterface private immutable gmData2;\n\n    struct Color {\n        bytes hexNum;\n        bytes name;\n    }\n\n    constructor(\n        ICourierFont fontAddress,\n        GmDataInterface gmData1Address,\n        GmDataInterface gmData2Address\n    ) {\n        font = fontAddress;\n        gmData1 = gmData1Address;\n        gmData2 = gmData2Address;\n    }\n\n    /// @notice decompresses the GmDataSet\n    /// @param gmData, compressed ascii svg data\n    function decompress(GmDataInterface.GmDataSet memory gmData)\n        public\n        pure\n        returns (bytes memory, bytes memory)\n    {\n        (, bytes memory inflated) = InflateLib.puff(\n            gmData.compressedImage,\n            gmData.compressedSize\n        );\n        return (gmData.imageName, inflated);\n    }\n\n    /// @notice returns an svg filter\n    /// @param index, a random number derived from the seed\n    function _getFilter(uint256 index) internal pure returns (bytes memory) {\n\n        // 1 || 2 || 3 || 4 || 5 -> noise 5%\n        if (\n            (index == 1) ||\n            (index == 2) ||\n            (index == 3) ||\n            (index == 4) ||\n            (index == 5)\n        ) {\n            return \"noise\";\n        }\n\n        // 7 || 8 || 98 -> scribble 3%\n        if ((index == 7) || (index == 8) || (index == 9)) {\n            return \"scribble\";\n        }\n\n        // 10 - 29 -> morph 20%\n        if (((100 - index) > 70) && ((100 - index) <= 90)) {\n            return \"morph\";\n        }\n\n        // 30 - 39 -> glow 10%\n        if (((100 - index) > 60) && ((100 - index) <= 70)) {\n            return \"glow\";\n        }\n\n        // 69 -> fractal 1%\n        if (index == 69) {\n            return \"fractal\";\n        }\n\n        return \"none\";\n    }\n\n    /// @notice returns a background color and font color\n    /// @param seed, pseudo random seed\n    function _getColors(bytes32 seed)\n        internal\n        pure\n        returns (Color memory bgColor, Color memory fontColor)\n    {\n        uint32 bgRand = uint32(bytes4(seed)) % 111;\n        uint32 fontJitter = uint32(bytes4(seed << 32)) % 5;\n        uint32 fontOperation = uint8(bytes1(seed << 64)) % 2;\n        uint32 fontRand;\n        if (fontOperation == 0) {\n            fontRand = (bgRand + (55 + fontJitter)) % 111;\n        } else {\n            fontRand = (bgRand + (55 - fontJitter)) % 111;\n        }\n\n        return (_getColor(bgRand), _getColor(fontRand));\n    }\n\n    /// @notice executes string comparison against two strings\n    /// @param a, first string\n    /// @param b, second string\n    function strCompare(string memory a, string memory b) internal pure returns (bool) {\n        if(bytes(a).length != bytes(b).length) {\n            return false;\n        } else {\n            return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n        }\n    }\n\n    /// @notice returns the raw svg yielded by seed\n    /// @param seed, pseudo random seed\n    function svgRaw(bytes32 seed)\n        external\n        view\n        returns (\n            bytes memory,\n            bytes memory,\n            bytes memory,\n            bytes memory,\n            bytes memory\n        )\n    {\n        uint32 style = uint32(bytes4(seed << 65)) % 69;\n        uint32 filterRand = uint32(bytes4(seed << 97)) % 100;\n        bytes memory filter = _getFilter(filterRand);\n\n        (Color memory bgColor, Color memory fontColor) = _getColors(seed);\n\n        bytes memory inner;\n        bytes memory name;\n        if (style < 50) {\n            (name, inner) = decompress(gmData1.getSvg(style));\n        } else {\n            (name, inner) = decompress(gmData2.getSvg(style));\n        }\n\n        if ((strCompare(string(name), \"Hex\")) || (strCompare(string(name), \"Binary\")) || (strCompare(string(name), \"Morse\")) || (strCompare(string(name), \"Mnemonic\"))){\n            filter = \"none\";\n        }\n\n        return (\n            abi.encodePacked(\n                svgPreambleString(bgColor.hexNum, fontColor.hexNum, filter),\n                inner,\n                \"</svg>\"\n            ),\n            name,\n            bgColor.name,\n            fontColor.name,\n            filter\n        );\n    }\n\n    /// @notice returns the svg filters\n    function svgFilterDefs() private view returns (bytes memory) {\n        return\n            abi.encodePacked(\n                '<defs><filter id=\"fractal\" filterUnits=\"objectBoundingBox\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\" ><feTurbulence id=\"turbulence\" type=\"fractalNoise\" baseFrequency=\"0.03\" numOctaves=\"1\" ><animate attributeName=\"baseFrequency\" values=\"0.01;0.4;0.01\" dur=\"100s\" repeatCount=\"indefinite\" /></feTurbulence><feDisplacementMap in=\"SourceGraphic\" scale=\"50\"></feDisplacementMap></filter><filter id=\"morph\"><feMorphology operator=\"dilate\" radius=\"0\"><animate attributeName=\"radius\" values=\"0;5;0\" dur=\"8s\" repeatCount=\"indefinite\" /></feMorphology></filter><filter id=\"glow\" filterUnits=\"objectBoundingBox\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\" ><feGaussianBlur stdDeviation=\"5\" result=\"blur2\" in=\"SourceGraphic\" /><feMerge><feMergeNode in=\"blur2\" /><feMergeNode in=\"SourceGraphic\" /></feMerge></filter><filter id=\"noise\"><feTurbulence baseFrequency=\"0.05\"/><feColorMatrix type=\"hueRotate\" values=\"0\"><animate attributeName=\"values\" from=\"0\" to=\"360\" dur=\"1s\" repeatCount=\"indefinite\"/></feColorMatrix><feColorMatrix type=\"matrix\" values=\"0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0\"/><feDisplacementMap in=\"SourceGraphic\" scale=\"10\"/></filter><filter id=\"none\"><feOffset></feOffset></filter><filter id=\"scribble\"><feTurbulence type=\"turbulence\" baseFrequency=\"0.05\" numOctaves=\"2\" result=\"turbulence\"/><feDisplacementMap in2=\"turbulence\" in=\"SourceGraphic\" scale=\"50\" xChannelSelector=\"R\" yChannelSelector=\"G\"/></filter><filter id=\"tile\" x=\"10\" y=\"10\" width=\"10%\" height=\"10%\"><feTile in=\"SourceGraphic\" x=\"10\" y=\"10\" width=\"10\" height=\"10\" /><feTile/></filter></defs>'\n            );\n    }\n\n    /// @notice returns the svg preamble\n    /// @param bgColor, color of the background as hex string\n    /// @param fontColor, color of the font as hex string\n    /// @param filter, filter for the svg\n    function svgPreambleString(\n        bytes memory bgColor,\n        bytes memory fontColor,\n        bytes memory filter\n    ) private view returns (bytes memory) {\n        return\n            abi.encodePacked(\n                \"<svg viewBox='0 0 640 640' width='100%' height='100%' xmlns='http://www.w3.org/2000/svg'><style> @font-face { font-family: CourierFont; src: url('\",\n                font.font(),\n                \"') format('opentype'); }\",\n                \".base{filter:url(#\",\n                filter,\n                \");fill:\",\n                fontColor,\n                \";font-family:CourierFont;font-size: 16px;}</style>\",\n                svgFilterDefs(),\n                '<rect width=\"100%\" height=\"100%\" fill=\"',\n                bgColor,\n                '\" /> '\n            );\n    }\n\n    /// @notice returns the Color yielded by index\n    /// @param index, random number determined by seed\n    function _getColor(uint32 index)\n        internal\n        pure\n        returns (Color memory color)\n    {\n        // AUTOGEN:START\n\n        if (index == 0) {\n            color.hexNum = \"#000000\";\n            color.name = \"Black\";\n        }\n\n        if (index == 1) {\n            color.hexNum = \"#004c6a\";\n            color.name = \"Navy Dark Blue\";\n        }\n\n        if (index == 2) {\n            color.hexNum = \"#0098d4\";\n            color.name = \"Bayern Blue\";\n        }\n\n        if (index == 3) {\n            color.hexNum = \"#00e436\";\n            color.name = \"Lexaloffle Green\";\n        }\n\n        if (index == 4) {\n            color.hexNum = \"#1034a6\";\n            color.name = \"Egyptian Blue\";\n        }\n\n        if (index == 5) {\n            color.hexNum = \"#008811\";\n            color.name = \"Lush Garden\";\n        }\n\n        if (index == 6) {\n            color.hexNum = \"#06d078\";\n            color.name = \"Underwater Fern\";\n        }\n\n        if (index == 7) {\n            color.hexNum = \"#1c1cf0\";\n            color.name = \"Bluebonnet\";\n        }\n\n        if (index == 8) {\n            color.hexNum = \"#127453\";\n            color.name = \"Green Velvet\";\n        }\n\n        if (index == 9) {\n            color.hexNum = \"#14bab4\";\n            color.name = \"Super Rare Jade\";\n        }\n\n        if (index == 10) {\n            color.hexNum = \"#111122\";\n            color.name = \"Corbeau\";\n        }\n\n        if (index == 11) {\n            color.hexNum = \"#165d95\";\n            color.name = \"Lapis Jewel\";\n        }\n\n        if (index == 12) {\n            color.hexNum = \"#16b8f3\";\n            color.name = \"Zima Blue\";\n        }\n\n        if (index == 13) {\n            color.hexNum = \"#1ef876\";\n            color.name = \"Synthetic Spearmint\";\n        }\n\n        if (index == 14) {\n            color.hexNum = \"#214fc6\";\n            color.name = \"New Car\";\n        }\n\n        if (index == 15) {\n            color.hexNum = \"#249148\";\n            color.name = \"Paperboy's Lawn\";\n        }\n\n        if (index == 16) {\n            color.hexNum = \"#24da91\";\n            color.name = \"Reptile Green\";\n        }\n\n        if (index == 17) {\n            color.hexNum = \"#223311\";\n            color.name = \"Darkest Forest\";\n        }\n\n        if (index == 18) {\n            color.hexNum = \"#297f6d\";\n            color.name = \"Mermaid Sea\";\n        }\n\n        if (index == 19) {\n            color.hexNum = \"#22cccc\";\n            color.name = \"Mermaid Net\";\n        }\n\n        if (index == 20) {\n            color.hexNum = \"#2e2249\";\n            color.name = \"Elderberry\";\n        }\n\n        if (index == 21) {\n            color.hexNum = \"#326ab1\";\n            color.name = \"Dover Straits\";\n        }\n\n        if (index == 22) {\n            color.hexNum = \"#2bc51b\";\n            color.name = \"Felwood Leaves\";\n        }\n\n        if (index == 23) {\n            color.hexNum = \"#391285\";\n            color.name = \"Pixie Powder\";\n        }\n\n        if (index == 24) {\n            color.hexNum = \"#2e58e8\";\n            color.name = \"Veteran's Day Blue\";\n        }\n\n        if (index == 25) {\n            color.hexNum = \"#419f59\";\n            color.name = \"Chateau Green\";\n        }\n\n        if (index == 26) {\n            color.hexNum = \"#45e9c1\";\n            color.name = \"Aphrodite Aqua\";\n        }\n\n        if (index == 27) {\n            color.hexNum = \"#424330\";\n            color.name = \"Garden Path\";\n        }\n\n        if (index == 28) {\n            color.hexNum = \"#429395\";\n            color.name = \"Catalan\";\n        }\n\n        if (index == 29) {\n            color.hexNum = \"#44dd00\";\n            color.name = \"Magic Blade\";\n        }\n\n        if (index == 30) {\n            color.hexNum = \"#432e6f\";\n            color.name = \"Her Highness\";\n        }\n\n        if (index == 31) {\n            color.hexNum = \"#4477dd\";\n            color.name = \"Andrea Blue\";\n        }\n\n        if (index == 32) {\n            color.hexNum = \"#5ad33e\";\n            color.name = \"Verdant Fields\";\n        }\n\n        if (index == 33) {\n            color.hexNum = \"#3a18b1\";\n            color.name = \"Indigo Blue\";\n        }\n\n        if (index == 34) {\n            color.hexNum = \"#556611\";\n            color.name = \"Forestial Outpost\";\n        }\n\n        if (index == 35) {\n            color.hexNum = \"#55bb88\";\n            color.name = \"Bleached Olive\";\n        }\n\n        if (index == 36) {\n            color.hexNum = \"#5500ee\";\n            color.name = \"Tezcatlipoca Blue\";\n        }\n\n        if (index == 37) {\n            color.hexNum = \"#545554\";\n            color.name = \"Carbon Copy\";\n        }\n\n        if (index == 38) {\n            color.hexNum = \"#58a0bc\";\n            color.name = \"Dupain\";\n        }\n\n        if (index == 39) {\n            color.hexNum = \"#55ff22\";\n            color.name = \"Traffic Green\";\n        }\n\n        if (index == 40) {\n            color.hexNum = \"#5b3e90\";\n            color.name = \"Daisy Bush\";\n        }\n\n        if (index == 41) {\n            color.hexNum = \"#6688ff\";\n            color.name = \"Deep Denim\";\n        }\n\n        if (index == 42) {\n            color.hexNum = \"#61e160\";\n            color.name = \"Lightish Green\";\n        }\n\n        if (index == 43) {\n            color.hexNum = \"#6a31ca\";\n            color.name = \"Sagat Purple\";\n        }\n\n        if (index == 44) {\n            color.hexNum = \"#667c3e\";\n            color.name = \"Military Green\";\n        }\n\n        if (index == 45) {\n            color.hexNum = \"#68c89d\";\n            color.name = \"Intense Jade\";\n        }\n\n        if (index == 46) {\n            color.hexNum = \"#6d1008\";\n            color.name = \"Chestnut Brown\";\n        }\n\n        if (index == 47) {\n            color.hexNum = \"#696374\";\n            color.name = \"Purple Punch\";\n        }\n\n        if (index == 48) {\n            color.hexNum = \"#6fb7e0\";\n            color.name = \"Life Force\";\n        }\n\n        if (index == 49) {\n            color.hexNum = \"#770044\";\n            color.name = \"Dawn of the Fairies\";\n        }\n\n        if (index == 50) {\n            color.hexNum = \"#7851a9\";\n            color.name = \"Royal Lavender\";\n        }\n\n        if (index == 51) {\n            color.hexNum = \"#769c18\";\n            color.name = \"Luminescent Green\";\n        }\n\n        if (index == 52) {\n            color.hexNum = \"#7be892\";\n            color.name = \"Ragweed\";\n        }\n\n        if (index == 53) {\n            color.hexNum = \"#703be7\";\n            color.name = \"Bluish Purple\";\n        }\n\n        if (index == 54) {\n            color.hexNum = \"#7b8b5d\";\n            color.name = \"Sage Leaves\";\n        }\n\n        if (index == 55) {\n            color.hexNum = \"#82d9c5\";\n            color.name = \"Tender Turquoise\";\n        }\n\n        if (index == 56) {\n            color.hexNum = \"#7e2530\";\n            color.name = \"Scarlet Shade\";\n        }\n\n        if (index == 57) {\n            color.hexNum = \"#83769c\";\n            color.name = \"Voxatron Purple\";\n        }\n\n        if (index == 58) {\n            color.hexNum = \"#88cc00\";\n            color.name = \"Fabulous Frog\";\n        }\n\n        if (index == 59) {\n            color.hexNum = \"#881166\";\n            color.name = \"Possessed Purple\";\n        }\n\n        if (index == 60) {\n            color.hexNum = \"#8756e4\";\n            color.name = \"Gloomy Purple\";\n        }\n\n        if (index == 61) {\n            color.hexNum = \"#93b13d\";\n            color.name = \"Green Tea Ice Cream\";\n        }\n\n        if (index == 62) {\n            color.hexNum = \"#90fda9\";\n            color.name = \"Foam Green\";\n        }\n\n        if (index == 63) {\n            color.hexNum = \"#914b13\";\n            color.name = \"Parasite Brown\";\n        }\n\n        if (index == 64) {\n            color.hexNum = \"#919c81\";\n            color.name = \"Whispering Willow\";\n        }\n\n        if (index == 65) {\n            color.hexNum = \"#99eeee\";\n            color.name = \"Freezy Breezy\";\n        }\n\n        if (index == 66) {\n            color.hexNum = \"#983d53\";\n            color.name = \"Algae Red\";\n        }\n\n        if (index == 67) {\n            color.hexNum = \"#9c87c1\";\n            color.name = \"Petrified Purple\";\n        }\n\n        if (index == 68) {\n            color.hexNum = \"#98da2c\";\n            color.name = \"Effervescent Lime\";\n        }\n\n        if (index == 69) {\n            color.hexNum = \"#942193\";\n            color.name = \"Acai Juice\";\n        }\n\n        if (index == 70) {\n            color.hexNum = \"#a675fe\";\n            color.name = \"Purple Illusionist\";\n        }\n\n        if (index == 71) {\n            color.hexNum = \"#a4c161\";\n            color.name = \"Jungle Juice\";\n        }\n\n        if (index == 72) {\n            color.hexNum = \"#aa00cc\";\n            color.name = \"Ferocious Fuchsia\";\n        }\n\n        if (index == 73) {\n            color.hexNum = \"#a85e39\";\n            color.name = \"Earthen Jug\";\n        }\n\n        if (index == 74) {\n            color.hexNum = \"#aaa9a4\";\n            color.name = \"Ellie Grey\";\n        }\n\n        if (index == 75) {\n            color.hexNum = \"#aaee11\";\n            color.name = \"Glorious Green Glitter\";\n        }\n\n        if (index == 76) {\n            color.hexNum = \"#ad4379\";\n            color.name = \"Mystic Maroon\";\n        }\n\n        if (index == 77) {\n            color.hexNum = \"#b195e4\";\n            color.name = \"Dreamy Candy Forest\";\n        }\n\n        if (index == 78) {\n            color.hexNum = \"#b1dd52\";\n            color.name = \"Conifer\";\n        }\n\n        if (index == 79) {\n            color.hexNum = \"#c034af\";\n            color.name = \"Pink Perennial\";\n        }\n\n        if (index == 80) {\n            color.hexNum = \"#b78727\";\n            color.name = \"University of California Gold\";\n        }\n\n        if (index == 81) {\n            color.hexNum = \"#b9d08b\";\n            color.name = \"Young Leaves\";\n        }\n\n        if (index == 82) {\n            color.hexNum = \"#bb11ee\";\n            color.name = \"Promiscuous Pink\";\n        }\n\n        if (index == 83) {\n            color.hexNum = \"#c06960\";\n            color.name = \"Tapestry Red\";\n        }\n\n        if (index == 84) {\n            color.hexNum = \"#bebbc9\";\n            color.name = \"Silverberry\";\n        }\n\n        if (index == 85) {\n            color.hexNum = \"#bf0a30\";\n            color.name = \"Old Glory Red\";\n        }\n\n        if (index == 86) {\n            color.hexNum = \"#c35b99\";\n            color.name = \"Llilacquered\";\n        }\n\n        if (index == 87) {\n            color.hexNum = \"#caa906\";\n            color.name = \"Christmas Gold\";\n        }\n\n        if (index == 88) {\n            color.hexNum = \"#c2f177\";\n            color.name = \"Cucumber Milk\";\n        }\n\n        if (index == 89) {\n            color.hexNum = \"#d648d7\";\n            color.name = \"Pinkish Purple\";\n        }\n\n        if (index == 90) {\n            color.hexNum = \"#cf9346\";\n            color.name = \"Fleshtone Shade Wash\";\n        }\n\n        if (index == 91) {\n            color.hexNum = \"#d3e0b1\";\n            color.name = \"Rockmelon Rind\";\n        }\n\n        if (index == 92) {\n            color.hexNum = \"#d22d1d\";\n            color.name = \"Pure Red\";\n        }\n\n        if (index == 93) {\n            color.hexNum = \"#d28083\";\n            color.name = \"Galah\";\n        }\n\n        if (index == 94) {\n            color.hexNum = \"#d5c7e8\";\n            color.name = \"Foggy Love\";\n        }\n\n        if (index == 95) {\n            color.hexNum = \"#db1459\";\n            color.name = \"Rubylicious\";\n        }\n\n        if (index == 96) {\n            color.hexNum = \"#dd66bb\";\n            color.name = \"Pink Charge\";\n        }\n\n        if (index == 97) {\n            color.hexNum = \"#e2b227\";\n            color.name = \"Gold Tips\";\n        }\n\n        if (index == 98) {\n            color.hexNum = \"#ee0099\";\n            color.name = \"Love Vessel\";\n        }\n\n        if (index == 99) {\n            color.hexNum = \"#dd55ff\";\n            color.name = \"Flaming Flamingo\";\n        }\n\n        if (index == 100) {\n            color.hexNum = \"#eda367\";\n            color.name = \"Adventure Orange\";\n        }\n\n        if (index == 101) {\n            color.hexNum = \"#e9f1d0\";\n            color.name = \"Yellowish White\";\n        }\n\n        if (index == 102) {\n            color.hexNum = \"#ef3939\";\n            color.name = \"Vivaldi Red\";\n        }\n\n        if (index == 103) {\n            color.hexNum = \"#e78ea5\";\n            color.name = \"Underwater Flare\";\n        }\n\n        if (index == 104) {\n            color.hexNum = \"#eedd11\";\n            color.name = \"Yellow Buzzing\";\n        }\n\n        if (index == 105) {\n            color.hexNum = \"#ee2277\";\n            color.name = \"Furious Fuchsia\";\n        }\n\n        if (index == 106) {\n            color.hexNum = \"#f075e6\";\n            color.name = \"Lian Hong Lotus Pink\";\n        }\n\n        if (index == 107) {\n            color.hexNum = \"#f7c34c\";\n            color.name = \"Creamy Sweet Corn\";\n        }\n\n        if (index == 108) {\n            color.hexNum = \"#fc0fc0\";\n            color.name = \"CGA Pink\";\n        }\n\n        if (index == 109) {\n            color.hexNum = \"#ff6622\";\n            color.name = \"Sparrows Fire\";\n        }\n\n        if (index == 110) {\n            color.hexNum = \"#fbaf8d\";\n            color.name = \"Orange Grove\";\n        }\n\n        // AUTOGEN:END\n    }\n}\n"},"contracts/InflateLib.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.9.0;\n\n//\n// inflate content script:\n// var pako = require('pako')\n// var deflate = (str) => [str.length,Buffer.from(pako.deflateRaw(Buffer.from(str, 'utf-8'), {level: 9})).toString('hex')]\n//\n\n/// @notice Based on https://github.com/madler/zlib/blob/master/contrib/puff\nlibrary InflateLib {\n    // Maximum bits in a code\n    uint256 constant MAXBITS = 15;\n    // Maximum number of literal/length codes\n    uint256 constant MAXLCODES = 286;\n    // Maximum number of distance codes\n    uint256 constant MAXDCODES = 30;\n    // Maximum codes lengths to read\n    uint256 constant MAXCODES = (MAXLCODES + MAXDCODES);\n    // Number of fixed literal/length codes\n    uint256 constant FIXLCODES = 288;\n\n    // Error codes\n    enum ErrorCode {\n        ERR_NONE, // 0 successful inflate\n        ERR_NOT_TERMINATED, // 1 available inflate data did not terminate\n        ERR_OUTPUT_EXHAUSTED, // 2 output space exhausted before completing inflate\n        ERR_INVALID_BLOCK_TYPE, // 3 invalid block type (type == 3)\n        ERR_STORED_LENGTH_NO_MATCH, // 4 stored block length did not match one's complement\n        ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, // 5 dynamic block code description: too many length or distance codes\n        ERR_CODE_LENGTHS_CODES_INCOMPLETE, // 6 dynamic block code description: code lengths codes incomplete\n        ERR_REPEAT_NO_FIRST_LENGTH, // 7 dynamic block code description: repeat lengths with no first length\n        ERR_REPEAT_MORE, // 8 dynamic block code description: repeat more than specified lengths\n        ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, // 9 dynamic block code description: invalid literal/length code lengths\n        ERR_INVALID_DISTANCE_CODE_LENGTHS, // 10 dynamic block code description: invalid distance code lengths\n        ERR_MISSING_END_OF_BLOCK, // 11 dynamic block code description: missing end-of-block code\n        ERR_INVALID_LENGTH_OR_DISTANCE_CODE, // 12 invalid literal/length or distance code in fixed or dynamic block\n        ERR_DISTANCE_TOO_FAR, // 13 distance is too far back in fixed or dynamic block\n        ERR_CONSTRUCT // 14 internal: error in construct()\n    }\n\n    // Input and output state\n    struct State {\n        //////////////////\n        // Output state //\n        //////////////////\n        // Output buffer\n        bytes output;\n        // Bytes written to out so far\n        uint256 outcnt;\n        /////////////////\n        // Input state //\n        /////////////////\n        // Input buffer\n        bytes input;\n        // Bytes read so far\n        uint256 incnt;\n        ////////////////\n        // Temp state //\n        ////////////////\n        // Bit buffer\n        uint256 bitbuf;\n        // Number of bits in bit buffer\n        uint256 bitcnt;\n        //////////////////////////\n        // Static Huffman codes //\n        //////////////////////////\n        Huffman lencode;\n        Huffman distcode;\n    }\n\n    // Huffman code decoding tables\n    struct Huffman {\n        uint256[] counts;\n        uint256[] symbols;\n    }\n\n    function bits(State memory s, uint256 need)\n        private\n        pure\n        returns (ErrorCode, uint256)\n    {\n        // Bit accumulator (can use up to 20 bits)\n        uint256 val;\n\n        // Load at least need bits into val\n        val = s.bitbuf;\n        while (s.bitcnt < need) {\n            if (s.incnt == s.input.length) {\n                // Out of input\n                return (ErrorCode.ERR_NOT_TERMINATED, 0);\n            }\n\n            // Load eight bits\n            val |= uint256(uint8(s.input[s.incnt++])) << s.bitcnt;\n            s.bitcnt += 8;\n        }\n\n        // Drop need bits and update buffer, always zero to seven bits left\n        s.bitbuf = val >> need;\n        s.bitcnt -= need;\n\n        // Return need bits, zeroing the bits above that\n        uint256 ret = (val & ((1 << need) - 1));\n        return (ErrorCode.ERR_NONE, ret);\n    }\n\n    function _stored(State memory s) private pure returns (ErrorCode) {\n        // Length of stored block\n        uint256 len;\n\n        // Discard leftover bits from current byte (assumes s.bitcnt < 8)\n        s.bitbuf = 0;\n        s.bitcnt = 0;\n\n        // Get length and check against its one's complement\n        if (s.incnt + 4 > s.input.length) {\n            // Not enough input\n            return ErrorCode.ERR_NOT_TERMINATED;\n        }\n        len = uint256(uint8(s.input[s.incnt++]));\n        len |= uint256(uint8(s.input[s.incnt++])) << 8;\n\n        if (\n            uint8(s.input[s.incnt++]) != (~len & 0xFF) ||\n            uint8(s.input[s.incnt++]) != ((~len >> 8) & 0xFF)\n        ) {\n            // Didn't match complement!\n            return ErrorCode.ERR_STORED_LENGTH_NO_MATCH;\n        }\n\n        // Copy len bytes from in to out\n        if (s.incnt + len > s.input.length) {\n            // Not enough input\n            return ErrorCode.ERR_NOT_TERMINATED;\n        }\n        if (s.outcnt + len > s.output.length) {\n            // Not enough output space\n            return ErrorCode.ERR_OUTPUT_EXHAUSTED;\n        }\n        while (len != 0) {\n            // Note: Solidity reverts on underflow, so we decrement here\n            len -= 1;\n            s.output[s.outcnt++] = s.input[s.incnt++];\n        }\n\n        // Done with a valid stored block\n        return ErrorCode.ERR_NONE;\n    }\n\n    function _decode(State memory s, Huffman memory h)\n        private\n        pure\n        returns (ErrorCode, uint256)\n    {\n        // Current number of bits in code\n        uint256 len;\n        // Len bits being decoded\n        uint256 code = 0;\n        // First code of length len\n        uint256 first = 0;\n        // Number of codes of length len\n        uint256 count;\n        // Index of first code of length len in symbol table\n        uint256 index = 0;\n        // Error code\n        ErrorCode err;\n\n        for (len = 1; len <= MAXBITS; len++) {\n            // Get next bit\n            uint256 tempCode;\n            (err, tempCode) = bits(s, 1);\n            if (err != ErrorCode.ERR_NONE) {\n                return (err, 0);\n            }\n            code |= tempCode;\n            count = h.counts[len];\n\n            // If length len, return symbol\n            if (code < first + count) {\n                return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\n            }\n            // Else update for next length\n            index += count;\n            first += count;\n            first <<= 1;\n            code <<= 1;\n        }\n\n        // Ran out of codes\n        return (ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE, 0);\n    }\n\n    function _construct(\n        Huffman memory h,\n        uint256[] memory lengths,\n        uint256 n,\n        uint256 start\n    ) private pure returns (ErrorCode) {\n        // Current symbol when stepping through lengths[]\n        uint256 symbol;\n        // Current length when stepping through h.counts[]\n        uint256 len;\n        // Number of possible codes left of current length\n        uint256 left;\n        // Offsets in symbol table for each length\n        uint256[MAXBITS + 1] memory offs;\n\n        // Count number of codes of each length\n        for (len = 0; len <= MAXBITS; len++) {\n            h.counts[len] = 0;\n        }\n        for (symbol = 0; symbol < n; symbol++) {\n            // Assumes lengths are within bounds\n            h.counts[lengths[start + symbol]]++;\n        }\n        // No codes!\n        if (h.counts[0] == n) {\n            // Complete, but decode() will fail\n            return (ErrorCode.ERR_NONE);\n        }\n\n        // Check for an over-subscribed or incomplete set of lengths\n\n        // One possible code of zero length\n        left = 1;\n\n        for (len = 1; len <= MAXBITS; len++) {\n            // One more bit, double codes left\n            left <<= 1;\n            if (left < h.counts[len]) {\n                // Over-subscribed--return error\n                return ErrorCode.ERR_CONSTRUCT;\n            }\n            // Deduct count from possible codes\n\n            left -= h.counts[len];\n        }\n\n        // Generate offsets into symbol table for each length for sorting\n        offs[1] = 0;\n        for (len = 1; len < MAXBITS; len++) {\n            offs[len + 1] = offs[len] + h.counts[len];\n        }\n\n        // Put symbols in table sorted by length, by symbol order within each length\n        for (symbol = 0; symbol < n; symbol++) {\n            if (lengths[start + symbol] != 0) {\n                h.symbols[offs[lengths[start + symbol]]++] = symbol;\n            }\n        }\n\n        // Left > 0 means incomplete\n        return left > 0 ? ErrorCode.ERR_CONSTRUCT : ErrorCode.ERR_NONE;\n    }\n\n    function _codes(\n        State memory s,\n        Huffman memory lencode,\n        Huffman memory distcode\n    ) private pure returns (ErrorCode) {\n        // Decoded symbol\n        uint256 symbol;\n        // Length for copy\n        uint256 len;\n        // Distance for copy\n        uint256 dist;\n        // TODO Solidity doesn't support constant arrays, but these are fixed at compile-time\n        // Size base for length codes 257..285\n        uint16[29] memory lens =\n            [\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                10,\n                11,\n                13,\n                15,\n                17,\n                19,\n                23,\n                27,\n                31,\n                35,\n                43,\n                51,\n                59,\n                67,\n                83,\n                99,\n                115,\n                131,\n                163,\n                195,\n                227,\n                258\n            ];\n        // Extra bits for length codes 257..285\n        uint8[29] memory lext =\n            [\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                1,\n                1,\n                1,\n                2,\n                2,\n                2,\n                2,\n                3,\n                3,\n                3,\n                3,\n                4,\n                4,\n                4,\n                4,\n                5,\n                5,\n                5,\n                5,\n                0\n            ];\n        // Offset base for distance codes 0..29\n        uint16[30] memory dists =\n            [\n                1,\n                2,\n                3,\n                4,\n                5,\n                7,\n                9,\n                13,\n                17,\n                25,\n                33,\n                49,\n                65,\n                97,\n                129,\n                193,\n                257,\n                385,\n                513,\n                769,\n                1025,\n                1537,\n                2049,\n                3073,\n                4097,\n                6145,\n                8193,\n                12289,\n                16385,\n                24577\n            ];\n        // Extra bits for distance codes 0..29\n        uint8[30] memory dext =\n            [\n                0,\n                0,\n                0,\n                0,\n                1,\n                1,\n                2,\n                2,\n                3,\n                3,\n                4,\n                4,\n                5,\n                5,\n                6,\n                6,\n                7,\n                7,\n                8,\n                8,\n                9,\n                9,\n                10,\n                10,\n                11,\n                11,\n                12,\n                12,\n                13,\n                13\n            ];\n        // Error code\n        ErrorCode err;\n\n        // Decode literals and length/distance pairs\n        while (symbol != 256) {\n            (err, symbol) = _decode(s, lencode);\n            if (err != ErrorCode.ERR_NONE) {\n                // Invalid symbol\n                return err;\n            }\n\n            if (symbol < 256) {\n                // Literal: symbol is the byte\n                // Write out the literal\n                if (s.outcnt == s.output.length) {\n                    return ErrorCode.ERR_OUTPUT_EXHAUSTED;\n                }\n                s.output[s.outcnt] = bytes1(uint8(symbol));\n                s.outcnt++;\n            } else if (symbol > 256) {\n                uint256 tempBits;\n                // Length\n                // Get and compute length\n                symbol -= 257;\n                if (symbol >= 29) {\n                    // Invalid fixed code\n                    return ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE;\n                }\n\n                (err, tempBits) = bits(s, lext[symbol]);\n                if (err != ErrorCode.ERR_NONE) {\n                    return err;\n                }\n                len = lens[symbol] + tempBits;\n\n                // Get and check distance\n                (err, symbol) = _decode(s, distcode);\n                if (err != ErrorCode.ERR_NONE) {\n                    // Invalid symbol\n                    return err;\n                }\n                (err, tempBits) = bits(s, dext[symbol]);\n                if (err != ErrorCode.ERR_NONE) {\n                    return err;\n                }\n                dist = dists[symbol] + tempBits;\n                if (dist > s.outcnt) {\n                    // Distance too far back\n                    return ErrorCode.ERR_DISTANCE_TOO_FAR;\n                }\n\n                // Copy length bytes from distance bytes back\n                if (s.outcnt + len > s.output.length) {\n                    return ErrorCode.ERR_OUTPUT_EXHAUSTED;\n                }\n                while (len != 0) {\n                    // Note: Solidity reverts on underflow, so we decrement here\n                    len -= 1;\n                    s.output[s.outcnt] = s.output[s.outcnt - dist];\n                    s.outcnt++;\n                }\n            } else {\n                s.outcnt += len;\n            }\n        }\n\n        // Done with a valid fixed or dynamic block\n        return ErrorCode.ERR_NONE;\n    }\n\n    function _build_fixed(State memory s) private pure returns (ErrorCode) {\n        // Build fixed Huffman tables\n        // TODO this is all a compile-time constant\n        uint256 symbol;\n        uint256[] memory lengths = new uint256[](FIXLCODES);\n\n        // Literal/length table\n        for (symbol = 0; symbol < 144; symbol++) {\n            lengths[symbol] = 8;\n        }\n        for (; symbol < 256; symbol++) {\n            lengths[symbol] = 9;\n        }\n        for (; symbol < 280; symbol++) {\n            lengths[symbol] = 7;\n        }\n        for (; symbol < FIXLCODES; symbol++) {\n            lengths[symbol] = 8;\n        }\n\n        _construct(s.lencode, lengths, FIXLCODES, 0);\n\n        // Distance table\n        for (symbol = 0; symbol < MAXDCODES; symbol++) {\n            lengths[symbol] = 5;\n        }\n\n        _construct(s.distcode, lengths, MAXDCODES, 0);\n\n        return ErrorCode.ERR_NONE;\n    }\n\n    function _fixed(State memory s) private pure returns (ErrorCode) {\n        // Decode data until end-of-block code\n        return _codes(s, s.lencode, s.distcode);\n    }\n\n    function _build_dynamic_lengths(State memory s)\n        private\n        pure\n        returns (ErrorCode, uint256[] memory)\n    {\n        uint256 ncode;\n        // Index of lengths[]\n        uint256 index;\n        // Descriptor code lengths\n        uint256[] memory lengths = new uint256[](MAXCODES);\n        // Error code\n        ErrorCode err;\n        // Permutation of code length codes\n        uint8[19] memory order =\n            [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n        (err, ncode) = bits(s, 4);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, lengths);\n        }\n        ncode += 4;\n\n        // Read code length code lengths (really), missing lengths are zero\n        for (index = 0; index < ncode; index++) {\n            (err, lengths[order[index]]) = bits(s, 3);\n            if (err != ErrorCode.ERR_NONE) {\n                return (err, lengths);\n            }\n        }\n        for (; index < 19; index++) {\n            lengths[order[index]] = 0;\n        }\n\n        return (ErrorCode.ERR_NONE, lengths);\n    }\n\n    function _build_dynamic(State memory s)\n        private\n        pure\n        returns (\n            ErrorCode,\n            Huffman memory,\n            Huffman memory\n        )\n    {\n        // Number of lengths in descriptor\n        uint256 nlen;\n        uint256 ndist;\n        // Index of lengths[]\n        uint256 index;\n        // Error code\n        ErrorCode err;\n        // Descriptor code lengths\n        uint256[] memory lengths = new uint256[](MAXCODES);\n        // Length and distance codes\n        Huffman memory lencode =\n            Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXLCODES));\n        Huffman memory distcode =\n            Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES));\n        uint256 tempBits;\n\n        // Get number of lengths in each table, check lengths\n        (err, nlen) = bits(s, 5);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, lencode, distcode);\n        }\n        nlen += 257;\n        (err, ndist) = bits(s, 5);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, lencode, distcode);\n        }\n        ndist += 1;\n\n        if (nlen > MAXLCODES || ndist > MAXDCODES) {\n            // Bad counts\n            return (\n                ErrorCode.ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES,\n                lencode,\n                distcode\n            );\n        }\n\n        (err, lengths) = _build_dynamic_lengths(s);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, lencode, distcode);\n        }\n\n        // Build huffman table for code lengths codes (use lencode temporarily)\n        err = _construct(lencode, lengths, 19, 0);\n        if (err != ErrorCode.ERR_NONE) {\n            // Require complete code set here\n            return (\n                ErrorCode.ERR_CODE_LENGTHS_CODES_INCOMPLETE,\n                lencode,\n                distcode\n            );\n        }\n\n        // Read length/literal and distance code length tables\n        index = 0;\n        while (index < nlen + ndist) {\n            // Decoded value\n            uint256 symbol;\n            // Last length to repeat\n            uint256 len;\n\n            (err, symbol) = _decode(s, lencode);\n            if (err != ErrorCode.ERR_NONE) {\n                // Invalid symbol\n                return (err, lencode, distcode);\n            }\n\n            if (symbol < 16) {\n                // Length in 0..15\n                lengths[index++] = symbol;\n            } else {\n                // Repeat instruction\n                // Assume repeating zeros\n                len = 0;\n                if (symbol == 16) {\n                    // Repeat last length 3..6 times\n                    if (index == 0) {\n                        // No last length!\n                        return (\n                            ErrorCode.ERR_REPEAT_NO_FIRST_LENGTH,\n                            lencode,\n                            distcode\n                        );\n                    }\n                    // Last length\n                    len = lengths[index - 1];\n                    (err, tempBits) = bits(s, 2);\n                    if (err != ErrorCode.ERR_NONE) {\n                        return (err, lencode, distcode);\n                    }\n                    symbol = 3 + tempBits;\n                } else if (symbol == 17) {\n                    // Repeat zero 3..10 times\n                    (err, tempBits) = bits(s, 3);\n                    if (err != ErrorCode.ERR_NONE) {\n                        return (err, lencode, distcode);\n                    }\n                    symbol = 3 + tempBits;\n                } else {\n                    // == 18, repeat zero 11..138 times\n                    (err, tempBits) = bits(s, 7);\n                    if (err != ErrorCode.ERR_NONE) {\n                        return (err, lencode, distcode);\n                    }\n                    symbol = 11 + tempBits;\n                }\n\n                if (index + symbol > nlen + ndist) {\n                    // Too many lengths!\n                    return (ErrorCode.ERR_REPEAT_MORE, lencode, distcode);\n                }\n                while (symbol != 0) {\n                    // Note: Solidity reverts on underflow, so we decrement here\n                    symbol -= 1;\n\n                    // Repeat last or zero symbol times\n                    lengths[index++] = len;\n                }\n            }\n        }\n\n        // Check for end-of-block code -- there better be one!\n        if (lengths[256] == 0) {\n            return (ErrorCode.ERR_MISSING_END_OF_BLOCK, lencode, distcode);\n        }\n\n        // Build huffman table for literal/length codes\n        err = _construct(lencode, lengths, nlen, 0);\n        if (\n            err != ErrorCode.ERR_NONE &&\n            (err == ErrorCode.ERR_NOT_TERMINATED ||\n                err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\n                nlen != lencode.counts[0] + lencode.counts[1])\n        ) {\n            // Incomplete code ok only for single length 1 code\n            return (\n                ErrorCode.ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS,\n                lencode,\n                distcode\n            );\n        }\n\n        // Build huffman table for distance codes\n        err = _construct(distcode, lengths, ndist, nlen);\n        if (\n            err != ErrorCode.ERR_NONE &&\n            (err == ErrorCode.ERR_NOT_TERMINATED ||\n                err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\n                ndist != distcode.counts[0] + distcode.counts[1])\n        ) {\n            // Incomplete code ok only for single length 1 code\n            return (\n                ErrorCode.ERR_INVALID_DISTANCE_CODE_LENGTHS,\n                lencode,\n                distcode\n            );\n        }\n\n        return (ErrorCode.ERR_NONE, lencode, distcode);\n    }\n\n    function _dynamic(State memory s) private pure returns (ErrorCode) {\n        // Length and distance codes\n        Huffman memory lencode;\n        Huffman memory distcode;\n        // Error code\n        ErrorCode err;\n\n        (err, lencode, distcode) = _build_dynamic(s);\n        if (err != ErrorCode.ERR_NONE) {\n            return err;\n        }\n\n        // Decode data until end-of-block code\n        return _codes(s, lencode, distcode);\n    }\n\n    function puff(bytes memory source, uint256 destlen)\n        internal\n        pure\n        returns (ErrorCode, bytes memory)\n    {\n        // Input/output state\n        State memory s =\n            State(\n                new bytes(destlen),\n                0,\n                source,\n                0,\n                0,\n                0,\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](FIXLCODES)),\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES))\n            );\n        // Temp: last bit\n        uint256 last;\n        // Temp: block type bit\n        uint256 t;\n        // Error code\n        ErrorCode err;\n\n        // Build fixed Huffman tables\n        err = _build_fixed(s);\n        if (err != ErrorCode.ERR_NONE) {\n            return (err, s.output);\n        }\n\n        // Process blocks until last block or error\n        while (last == 0) {\n            // One if last block\n            (err, last) = bits(s, 1);\n            if (err != ErrorCode.ERR_NONE) {\n                return (err, s.output);\n            }\n\n            // Block type 0..3\n            (err, t) = bits(s, 2);\n            if (err != ErrorCode.ERR_NONE) {\n                return (err, s.output);\n            }\n\n            err = (\n                t == 0\n                    ? _stored(s)\n                    : (\n                        t == 1\n                            ? _fixed(s)\n                            : (\n                                t == 2\n                                    ? _dynamic(s)\n                                    : ErrorCode.ERR_INVALID_BLOCK_TYPE\n                            )\n                    )\n            );\n            // type == 3, invalid\n\n            if (err != ErrorCode.ERR_NONE) {\n                // Return with error\n                break;\n            }\n        }\n\n        return (err, s.output);\n    }\n}\n"}}}