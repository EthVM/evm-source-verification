{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/helper/LendingDataV2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {_setPendingOwner} and {_acceptOwner}.\n */\ncontract Ownable {\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    address payable public owner;\n\n    /**\n     * @dev Returns the address of the current pending owner.\n     */\n    address payable public pendingOwner;\n\n    event NewOwner(address indexed previousOwner, address indexed newOwner);\n    event NewPendingOwner(\n        address indexed oldPendingOwner,\n        address indexed newPendingOwner\n    );\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"onlyOwner: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal {\n        owner = msg.sender;\n        emit NewOwner(address(0), msg.sender);\n    }\n\n    /**\n     * @dev Transfer contract control to a new owner. The newPendingOwner must call `_acceptOwner` to finish the transfer.\n     * @param newPendingOwner New pending owner.\n     *\n     * TODO: Maybe the new pending owenr should not be the current owner at the same time.\n     */\n    function _setPendingOwner(address payable newPendingOwner)\n        external\n        onlyOwner\n    {\n        require(\n            newPendingOwner != address(0),\n            \"_setPendingOwner: New owenr can not be zero address!\"\n        );\n        require(\n            newPendingOwner != pendingOwner,\n            \"_setPendingOwner: This owner has been set!\"\n        );\n\n        // Gets current owner.\n        address oldPendingOwner = pendingOwner;\n\n        // Sets new pending owner.\n        pendingOwner = newPendingOwner;\n\n        emit NewPendingOwner(oldPendingOwner, newPendingOwner);\n    }\n\n    /**\n     * @dev Accepts the admin rights, but only for pendingOwenr.\n     */\n    function _acceptOwner() external {\n        require(\n            msg.sender == pendingOwner,\n            \"_acceptOwner: Only for pending owner!\"\n        );\n\n        // Gets current values for events.\n        address oldOwner = owner;\n        address oldPendingOwner = pendingOwner;\n\n        // Set the new contract owner.\n        owner = pendingOwner;\n\n        // Clear the pendingOwner.\n        pendingOwner = address(0);\n\n        emit NewOwner(oldOwner, owner);\n        emit NewPendingOwner(oldPendingOwner, pendingOwner);\n    }\n}\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y > 0, \"ds-math-div-overflow\");\n        z = x / y;\n    }\n}\n\nlibrary SafeRatioMath {\n    using SafeMath for uint256;\n\n    uint256 private constant BASE = 10**18;\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.mul(y).div(BASE);\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.mul(BASE).div(y);\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 base\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n                case 0 {\n                    switch n\n                        case 0 {\n                            z := base\n                        }\n                        default {\n                            z := 0\n                        }\n                }\n                default {\n                    switch mod(n, 2)\n                        case 0 {\n                            z := base\n                        }\n                        default {\n                            z := x\n                        }\n                    let half := div(base, 2) // for rounding.\n\n                    for {\n                        n := div(n, 2)\n                    } n {\n                        n := div(n, 2)\n                    } {\n                        let xx := mul(x, x)\n                        if iszero(eq(div(xx, x), x)) {\n                            revert(0, 0)\n                        }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) {\n                            revert(0, 0)\n                        }\n                        x := div(xxRound, base)\n                        if mod(n, 2) {\n                            let zx := mul(z, x)\n                            if and(\n                                iszero(iszero(x)),\n                                iszero(eq(div(zx, x), z))\n                            ) {\n                                revert(0, 0)\n                            }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) {\n                                revert(0, 0)\n                            }\n                            z := div(zxRound, base)\n                        }\n                    }\n                }\n        }\n    }\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external;\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external;\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external;\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    // This function is not a standard ERC20 interface, just for compitable with market.\n    function decimals() external view returns (uint8);\n}\n\ninterface IInterestRateModel {\n    function blocksPerYear() external view returns (uint256);\n}\n\ninterface IPriceOracle {\n    /**\n     * @notice Get the underlying price of a iToken asset\n     * @param _iToken The iToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18).\n     *  Zero means the price is unavailable.\n     */\n    function getUnderlyingPrice(IiToken _iToken)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Get the price of a underlying asset\n     * @param _iToken The iToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18).\n     *  Zero means the price is unavailable and whether the price is valid.\n     */\n    function getUnderlyingPriceAndStatus(IiToken _iToken)\n        external\n        view\n        returns (uint256, bool);\n    function getAssetPriceStatus(IiToken _iToken) external view returns (bool);\n}\n\ninterface IRewardDistributor {\n    function updateDistributionState(IiToken _iToken, bool _isBorrow) external;\n\n    function updateReward(\n        IiToken _iToken,\n        address _account,\n        bool _isBorrow\n    ) external;\n\n    function updateRewardBatch(\n        address[] memory _holders,\n        IiToken[] memory _iTokens\n    ) external;\n\n    function reward(address _account) external view returns (uint256);\n}\n\ninterface IController {\n    function getAlliTokens() external view returns (IiToken[] memory);\n\n    function getEnteredMarkets(address _account)\n        external\n        view\n        returns (IiToken[] memory);\n    \n    function getBorrowedAssets(address _account) external view returns (IiToken[] memory);\n\n    function hasEnteredMarket(address _account, IiToken _iToken)\n        external\n        view\n        returns (bool);\n\n    function hasBorrowed(address _account, IiToken _iToken)\n        external\n        view\n        returns (bool);\n\n    function priceOracle() external view returns (IPriceOracle);\n\n    function markets(IiToken _asset)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool,\n            bool\n        );\n\n    function calcAccountEquity(address _account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function beforeRedeem(\n        address iToken,\n        address redeemer,\n        uint256 redeemAmount\n    ) external returns (bool);\n\n    function closeFactorMantissa() external view returns (uint256);\n\n    function liquidationIncentiveMantissa() external view returns (uint256);\n\n    function rewardDistributor() external view returns (address);\n}\n\ninterface IiToken {\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address _account) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function isSupported() external view returns (bool);\n    \n    function isiToken() external view returns (bool);\n\n    function underlying() external view returns (IERC20);\n\n    function getCash() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function balanceOfUnderlying(address _account) external returns (uint256);\n\n    function borrowBalanceStored(address _account)\n        external\n        view\n        returns (uint256);\n\n    function borrowBalanceCurrent(address _account) external returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function totalBorrows() external view returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function updateInterest() external returns (bool);\n\n    function interestRateModel() external view returns (IInterestRateModel);\n}\n\ncontract LendingDataV2 is Ownable {\n    using SafeMath for uint256;\n    using SafeRatioMath for uint256;\n    bool private initialized;\n\n    uint256 constant BASE = 1e18;\n\n    uint256 public blocksPerYear;\n    uint256 constant daysPerYear = 365;\n\n    IController public controller;\n    IiToken public priceToken;\n\n    IiToken[] public tokens;\n    uint256[] public amounts;\n    uint8[] public decimals;\n\n    constructor(\n        address _controller,\n        IiToken _priceToken,\n        uint256 _blocksPerYear\n    ) public {\n        initialize(_controller, _priceToken, _blocksPerYear);\n    }\n\n    function initialize(\n        address _controller,\n        IiToken _priceToken,\n        uint256 _blocksPerYear\n    ) public {\n        require(!initialized, \"initialize: Already initialized!\");\n        __Ownable_init();\n        controller = IController(_controller);\n        priceToken = _priceToken;\n        blocksPerYear = _blocksPerYear;\n        initialized = true;\n    }\n\n    function setController(IController _newController) external onlyOwner {\n        // Sets to new controller.\n        controller = _newController;\n    }\n\n    function setPriceToken(IiToken _newAsset) external onlyOwner {\n        priceToken = _newAsset;\n    }\n\n    struct totalValueLocalVars {\n        IiToken[] iTokens;\n        IController controller;\n        IPriceOracle priceOracle;\n        uint256 assetPrice;\n        uint256 collateralFactor;\n        uint256 sumCollateral;\n        uint256 sumBorrowed;\n        uint256 supplyValue;\n        uint256 collateralVaule;\n        uint256 borrowValue;\n    }\n\n    function getAccountTotalValue(address _account)\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        totalValueLocalVars memory _var;\n        _var.controller = controller;\n        _var.iTokens = _var.controller.getAlliTokens();\n        _var.priceOracle = _var.controller.priceOracle();\n        for (uint256 i = 0; i < _var.iTokens.length; i++) {\n            _var.assetPrice = _var.priceOracle.getUnderlyingPrice(\n                _var.iTokens[i]\n            );\n            _var.supplyValue = _var.supplyValue.add(\n                _var.iTokens[i].balanceOfUnderlying(_account).mul(\n                    _var.assetPrice\n                )\n            );\n            (_var.collateralFactor, , , , , , ) = controller.markets(_var.iTokens[i]);\n            if (\n                _var.controller.hasEnteredMarket(_account, _var.iTokens[i]) &&\n                _var.collateralFactor > 0\n            )\n                _var.collateralVaule = _var.collateralVaule.add(\n                    _var.iTokens[i].balanceOfUnderlying(_account).mul(\n                        _var.assetPrice\n                    )\n                );\n\n            if (_var.controller.hasBorrowed(_account, _var.iTokens[i]))\n                _var.borrowValue = _var.borrowValue.add(\n                    _var.iTokens[i].borrowBalanceCurrent(_account).mul(\n                        _var.assetPrice\n                    )\n                );\n        }\n        _var.assetPrice = getAssetUSDPrice(priceToken);\n        if (_var.assetPrice == 0) return (0, 0, 0, 0);\n\n        _var.supplyValue = _var.supplyValue.div(_var.assetPrice);\n        _var.collateralVaule = _var.collateralVaule.div(_var.assetPrice);\n        _var.borrowValue = _var.borrowValue.div(_var.assetPrice);\n        (, , _var.sumCollateral, _var.sumBorrowed) = calcAccountEquity(_account);\n        return (\n            _var.supplyValue,\n            _var.collateralVaule,\n            _var.borrowValue,\n            _var.sumBorrowed == 0 ? 0 : _var.sumCollateral.rdiv(_var.sumBorrowed)\n        );\n    }\n\n    function getAccountAssetStatus(IiToken _asset, address _account, uint256 _type) internal returns (bool, uint256) {\n        uint256 _balance;\n        if (_type == 0) {\n            _balance = _asset.balanceOfUnderlying(_account);\n            return ( _balance == 0 ? false : true, _balance);\n        }\n\n        bool _isiToken = _asset.isiToken();\n        if ((_type & 1 > 0 && _isiToken) || (_type & 2 > 0 && !_isiToken))\n            _balance = _asset.borrowBalanceCurrent(_account);\n\n        return ( _balance == 0 ? false : true, _balance);\n    }\n\n    function getAccountAssets(address _account, uint256 _type)\n        internal\n        returns (\n            IiToken[] memory,\n            uint256[] memory,\n            uint8[] memory\n        )\n    {\n        delete tokens;\n        delete amounts;\n        delete decimals;\n        uint256 _balance;\n        bool _status;\n        IiToken[] memory _iTokens = controller.getAlliTokens();\n        for (uint256 i = 0; i < _iTokens.length; i++) {\n            (_status, _balance) = getAccountAssetStatus(_iTokens[i], _account, _type);\n            if (_status) {\n                tokens.push(_iTokens[i]);\n                amounts.push(_balance);\n                decimals.push(_iTokens[i].decimals());\n            }\n        }\n\n        return (tokens, amounts, decimals);\n    }\n\n    \n    function getAccountSupplyTokens(address _account)\n        public\n        returns (\n            IiToken[] memory,\n            uint256[] memory,\n            uint8[] memory\n        )\n    {\n        return getAccountAssets(_account, 0);\n    }\n\n    function getAccountBorrowTokens(address _account)\n        public\n        returns (\n            IiToken[] memory,\n            uint256[] memory,\n            uint8[] memory\n        )\n    {\n        return getAccountAssets(_account, 1);\n    }\n\n    function getAccountMSDTokens(address _account)\n        public\n        returns (\n            IiToken[] memory,\n            uint256[] memory,\n            uint8[] memory\n        )\n    {\n        return getAccountAssets(_account, 2);\n    }\n\n    function getAccountTokens(address _account)\n        external\n        returns (\n            IiToken[] memory _supplyTokens,\n            uint256[] memory _supplyAmounts,\n            uint8[] memory _supplyDecimals,\n            IiToken[] memory _borrowTokens,\n            uint256[] memory _borrowAmounts,\n            uint8[] memory _borrowDecimals\n        )\n    {\n        (\n            _supplyTokens,\n            _supplyAmounts,\n            _supplyDecimals\n        ) = getAccountAssets(_account, 0);\n        (\n            _borrowTokens,\n            _borrowAmounts,\n            _borrowDecimals\n        ) = getAccountAssets(_account, 3);\n    }\n\n    function getAssetUSDPrice(IiToken _asset) public view returns (uint256) {\n        uint256 _USDPrice = controller.priceOracle().getUnderlyingPrice(\n                priceToken\n            );\n        if (_USDPrice == 0) return 0;\n\n        uint256 _assetUSDPrice = controller.priceOracle()\n                .getUnderlyingPrice(_asset)\n                .rdiv(_USDPrice);\n        uint8 _assetDecimals = _asset.decimals();\n        uint8 _priceTokenDecimals = priceToken.decimals();\n\n        return\n            _assetDecimals > _priceTokenDecimals\n                ? _assetUSDPrice.mul(\n                    10**(uint256(_assetDecimals - _priceTokenDecimals))\n                )\n                : _assetUSDPrice.div(\n                    10**(uint256(_priceTokenDecimals - _assetDecimals))\n                );\n    }\n\n    function getSupplyTokenData(IiToken _asset)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (uint256 _collateralFactor, , , , , , ) = controller.markets(_asset);\n        if (_asset.isiToken()) {\n            uint256 _blocksPerDay = _asset.supplyRatePerBlock() * _asset.interestRateModel().blocksPerYear() / daysPerYear;\n            return (\n                (_blocksPerDay + BASE).rpow(\n                    daysPerYear,\n                    BASE\n                ) - BASE,\n                _collateralFactor,\n                getAssetUSDPrice(_asset)\n            );\n        }\n        return (0, _collateralFactor, getAssetUSDPrice(_asset));\n    }\n\n    function getAccountSupplyInfo(\n        IiToken _asset,\n        address _account,\n        uint256 _safeMaxFactor\n    )\n        public\n        returns (\n            uint256 _assetPrice,\n            bool _asCollateral,\n            bool _executed,\n            bool _accountAvailable\n        )\n    {\n        _asCollateral = controller.hasEnteredMarket(_account, _asset);\n        if (!_asCollateral) {\n            (uint256 _collateralFactor, , , , , , ) = controller.markets(_asset);\n            _executed = _collateralFactor > 0 ? true : false;\n            _accountAvailable = true;\n        } else {\n            _executed = canAccountRemoveFromCollateral(\n                _asset,\n                _account,\n                _safeMaxFactor\n            );\n            _accountAvailable = getAccountAvailable(_account);\n        }\n        \n        uint256 _USDPrice = controller.priceOracle().getUnderlyingPrice(priceToken);\n        _assetPrice = _USDPrice == 0 ? 0 : getBalance(_asset, _account).mul(controller.priceOracle().getUnderlyingPrice(_asset)).div(_USDPrice);\n    }\n\n    struct removeFromCollateralLocalVars {\n        uint256 assetPrice;\n        uint256 collateralFactor;\n        uint256 accountEquity;\n        uint256 sumCollateral;\n        uint256 sumBorrowed;\n        uint256 safeAvailableToken;\n    }\n\n    function canAccountRemoveFromCollateral(\n        IiToken _asset,\n        address _account,\n        uint256 _safeMaxFactor\n    ) public returns (bool) {\n        if (getAccountBorrowStatus(_account)) {\n            removeFromCollateralLocalVars memory _var;\n\n            (_var.collateralFactor, , , , , , ) = controller.markets(_asset);\n            (\n                _var.accountEquity,\n                ,\n                _var.sumCollateral,\n                _var.sumBorrowed\n            ) = calcAccountEquity(_account);\n            if (_var.collateralFactor == 0 && _var.accountEquity > 0)\n                return true;\n\n            _var.assetPrice = controller.priceOracle()\n                .getUnderlyingPrice(_asset);\n            if (\n                _var.assetPrice == 0 ||\n                _var.collateralFactor == 0 ||\n                _var.accountEquity == 0\n            ) return false;\n\n            _var.safeAvailableToken = _var.sumCollateral >\n                _var.sumBorrowed.rdiv(_safeMaxFactor)\n                ? _var.sumCollateral.sub(_var.sumBorrowed.rdiv(_safeMaxFactor))\n                : 0;\n            _var.safeAvailableToken = _var\n                .safeAvailableToken\n                .div(_var.assetPrice)\n                .rdiv(_var.collateralFactor);\n\n            return\n                _var.safeAvailableToken >=\n                IiToken(_asset).balanceOfUnderlying(_account);\n        }\n\n        return true;\n    }\n\n    struct supplyLocalVars {\n        uint256 cash;\n        uint256 assetPrice;\n        uint256 collateralFactor;\n        uint256 supplyCapacity;\n        uint256 totalUnderlying;\n        uint256 accountEquity;\n        uint256 sumCollateral;\n        uint256 sumBorrowed;\n        uint256 availableToken;\n        uint256 safeAvailableToken;\n        uint256 suppliedBalance;\n        uint256 accountBalance;\n        uint256 maxMintAmount;\n        uint256 availableToWithdraw;\n        uint256 safeAvailableToWithdraw;\n        uint256 iTokenBalance;\n        uint8 decimals;\n    }\n\n    function getAccountSupplyData(\n        IiToken _asset,\n        address _account,\n        uint256 _safeMaxFactor\n    )\n        public\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint8\n        )\n    {\n        supplyLocalVars memory _var;\n        _var.suppliedBalance = _asset.balanceOfUnderlying(_account);\n        _var.accountBalance = getBalance(_asset, _account);\n        _var.iTokenBalance = _asset.balanceOf(_account);\n        _var.decimals = _asset.decimals();\n\n        _var.maxMintAmount = 0;\n        (_var.collateralFactor, , , _var.supplyCapacity, , ,) = controller.markets(\n            _asset\n        );\n        _var.totalUnderlying = _asset.totalSupply().rmul(\n            _asset.exchangeRateStored()\n        );\n        if (_var.supplyCapacity > _var.totalUnderlying) {\n            _var.maxMintAmount = _var.supplyCapacity.sub(_var.totalUnderlying);\n            _var.maxMintAmount = _var.maxMintAmount > _var.accountBalance\n                ? _var.accountBalance\n                : _var.maxMintAmount;\n        }\n\n        if (_asset.isiToken()) {\n            _var.cash = _asset.getCash();\n            _var.availableToWithdraw = _var.cash > _var.suppliedBalance\n                ? _var.suppliedBalance\n                : _var.cash;\n        }\n        _var.safeAvailableToWithdraw = _var.availableToWithdraw;\n\n        if (\n            controller.hasEnteredMarket(_account, _asset) &&\n            getAccountBorrowStatus(_account)\n        ) {\n            (\n                _var.accountEquity,\n                ,\n                _var.sumCollateral,\n                _var.sumBorrowed\n            ) = calcAccountEquity(_account);\n            if (_var.collateralFactor == 0 && _var.accountEquity > 0)\n                return (\n                    _var.suppliedBalance,\n                    _var.accountBalance,\n                    _var.maxMintAmount,\n                    _var.availableToWithdraw,\n                    _var.safeAvailableToWithdraw,\n                    _var.iTokenBalance,\n                    _var.decimals\n                );\n\n            _var.assetPrice = controller.priceOracle()\n                .getUnderlyingPrice(_asset);\n            if (\n                _var.assetPrice == 0 ||\n                _var.collateralFactor == 0 ||\n                _var.accountEquity == 0\n            )\n                return (\n                    _var.suppliedBalance,\n                    _var.accountBalance,\n                    _var.maxMintAmount,\n                    0,\n                    0,\n                    0,\n                    _var.decimals\n                );\n\n            _var.availableToken = _var.accountEquity.div(_var.assetPrice).rdiv(\n                _var.collateralFactor\n            );\n            _var.availableToWithdraw = _var.availableToWithdraw >\n                _var.availableToken\n                ? _var.availableToken\n                : _var.availableToWithdraw;\n\n            _var.safeAvailableToken = _var.sumCollateral >\n                _var.sumBorrowed.rdiv(_safeMaxFactor)\n                ? _var.sumCollateral.sub(_var.sumBorrowed.rdiv(_safeMaxFactor))\n                : 0;\n            _var.safeAvailableToken = _var\n                .safeAvailableToken\n                .div(_var.assetPrice)\n                .rdiv(_var.collateralFactor);\n            _var.safeAvailableToWithdraw = _var.safeAvailableToWithdraw >\n                _var.safeAvailableToken\n                ? _var.safeAvailableToken\n                : _var.safeAvailableToWithdraw;\n\n            _var.safeAvailableToWithdraw = _var.safeAvailableToWithdraw >\n                _var.availableToWithdraw\n                ? _var.availableToWithdraw\n                : _var.safeAvailableToWithdraw;\n        }\n\n        return (\n            _var.suppliedBalance,\n            _var.accountBalance,\n            _var.maxMintAmount,\n            _var.availableToWithdraw,\n            _var.safeAvailableToWithdraw,\n            _var.iTokenBalance,\n            _var.decimals\n        );\n    }\n\n    function getAccountBorrowValue(address _account) public returns (uint256 _borrowValue) {\n        IiToken[] memory _iTokens = controller.getAlliTokens();\n        IPriceOracle _priceOracle = controller.priceOracle();\n        for (uint256 i = 0; i < _iTokens.length; i++) {\n            if (controller.hasBorrowed(_account, _iTokens[i]))\n                _borrowValue = _borrowValue.add(\n                    _iTokens[i].borrowBalanceCurrent(_account).mul(_priceOracle.getUnderlyingPrice(_iTokens[i]))\n                );\n        }\n        return _borrowValue;\n    }\n\n    function getAccountBorrowStatus(address _account)\n        public\n        view\n        returns (bool)\n    {\n        IiToken[] memory _iTokens = controller.getAlliTokens();\n        for (uint256 i = 0; i < _iTokens.length; i++)\n            if (_iTokens[i].borrowBalanceStored(_account) > 0)\n                return true;\n\n        return false;\n    }\n\n    function getBorrowTokenData(IiToken _asset)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (_asset.isSupported()) {\n            (, uint256 _borrowFactor, , , , , ) = controller.markets(_asset);\n            uint256 _blocksPerYear = _asset.isiToken() ? _asset.interestRateModel().blocksPerYear() : blocksPerYear;\n            return (\n                _asset.getCash(),\n                _borrowFactor,\n                (_asset.borrowRatePerBlock() * _blocksPerYear / daysPerYear + BASE).rpow(\n                    daysPerYear,\n                    BASE\n                ) - BASE,\n                getAssetUSDPrice(_asset)\n            );\n        }\n        return (0, 0, 0, 0);\n    }\n\n    struct borrowInfoLocalVars {\n        IPriceOracle oracle;\n        uint256 assetPrice;\n        uint256 USDPrice;\n        uint256 accountEquity;\n        uint256 sumCollateral;\n        uint256 sumBorrowed;\n        uint256 borrowFactor;\n        uint256 maxBorrowValue;\n        uint256 safeBorrowValue;\n        bool accountAvailable;\n    }\n\n    function getAccountBorrowInfo(\n        IiToken _asset,\n        address _account,\n        uint256 _safeMaxFactor\n    )\n        public\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        borrowInfoLocalVars memory _var;\n        _var.oracle = controller.priceOracle();\n        _var.USDPrice = _var.oracle.getUnderlyingPrice(priceToken);\n        if (_var.oracle.getAssetPriceStatus(_asset))\n            _var.accountAvailable = getAccountAvailable(_account);\n\n        if (_var.USDPrice == 0) return (0, 0, 0, _var.accountAvailable);\n\n        IiToken(_asset).updateInterest();\n        (\n            _var.accountEquity,\n            ,\n            _var.sumCollateral,\n            _var.sumBorrowed\n        ) = calcAccountEquity(_account);\n        (, _var.borrowFactor, , , , , ) = controller.markets(_asset);\n\n        _var.maxBorrowValue = _var.accountEquity.rmul(_var.borrowFactor).div(\n            _var.USDPrice\n        );\n        _var.safeBorrowValue = _var.sumCollateral.rmul(_safeMaxFactor) >\n            _var.sumBorrowed\n            ? _var.sumCollateral.rmul(_safeMaxFactor).sub(_var.sumBorrowed)\n            : 0;\n        _var.safeBorrowValue = _var.safeBorrowValue.rmul(_var.borrowFactor).div(\n            _var.USDPrice\n        );\n\n        _var.assetPrice = _var.oracle.getUnderlyingPrice(_asset);\n        return (\n            _var.maxBorrowValue,\n            _var.safeBorrowValue,\n            getBalance(_asset, _account).mul(_var.assetPrice).div(_var.USDPrice),\n            _var.accountAvailable\n        );\n    }\n\n    struct borrowLocalVars {\n        uint256 cash;\n        uint256 assetPrice;\n        uint256 borrowCapacity;\n        uint256 accountEquity;\n        uint256 sumCollateral;\n        uint256 sumBorrowed;\n        uint256 borrowFactor;\n        uint256 totalBorrows;\n        uint256 canBorrows;\n        uint256 borrowedBalance;\n        uint256 availableToBorrow;\n        uint256 safeAvailableToBorrow;\n        uint256 accountBalance;\n        uint256 maxRepay;\n    }\n\n    function getAccountBorrowData(\n        IiToken _asset,\n        address _account,\n        uint256 _safeMaxFactor\n    )\n        public\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint8\n        )\n    {\n        borrowLocalVars memory _var;\n        _var.borrowedBalance = _asset.borrowBalanceCurrent(_account);\n        _var.accountBalance = getBalance(_asset, _account);\n        _var.maxRepay = _var.borrowedBalance > _var.accountBalance\n            ? _var.accountBalance\n            : _var.borrowedBalance;\n\n        _var.assetPrice = controller.priceOracle()\n            .getUnderlyingPrice(_asset);\n        (, _var.borrowFactor, _var.borrowCapacity, , , , ) = controller.markets(\n            _asset\n        );\n        if (\n            _var.assetPrice == 0 ||\n            _var.borrowCapacity == 0 ||\n            _var.borrowFactor == 0\n        )\n            return (\n                _var.borrowedBalance,\n                0,\n                0,\n                _var.accountBalance,\n                _var.maxRepay,\n                _asset.decimals()\n            );\n\n        (\n            _var.accountEquity,\n            ,\n            _var.sumCollateral,\n            _var.sumBorrowed\n        ) = calcAccountEquity(_account);\n        _var.availableToBorrow = _var.accountEquity.rmul(_var.borrowFactor).div(\n            _var.assetPrice\n        );\n\n        _var.safeAvailableToBorrow = _var.sumCollateral.rmul(_safeMaxFactor) >\n            _var.sumBorrowed\n            ? _var.sumCollateral.rmul(_safeMaxFactor).sub(_var.sumBorrowed)\n            : 0;\n        _var.safeAvailableToBorrow = _var\n            .safeAvailableToBorrow\n            .rmul(_var.borrowFactor)\n            .div(_var.assetPrice);\n\n        if (_asset.isiToken()) {\n            _var.cash = _asset.getCash();\n            _var.availableToBorrow = _var.availableToBorrow > _var.cash\n                ? _var.cash\n                : _var.availableToBorrow;\n\n            _var.safeAvailableToBorrow = _var.safeAvailableToBorrow > _var.cash\n                ? _var.cash\n                : _var.safeAvailableToBorrow;\n        }\n\n        _var.totalBorrows = _asset.totalBorrowsCurrent();\n        _var.canBorrows = _var.totalBorrows >= _var.borrowCapacity\n            ? 0\n            : _var.borrowCapacity.sub(_var.totalBorrows);\n\n        _var.availableToBorrow = _var.availableToBorrow > _var.canBorrows\n            ? _var.canBorrows\n            : _var.availableToBorrow;\n\n        _var.safeAvailableToBorrow = _var.safeAvailableToBorrow >\n            _var.canBorrows\n            ? _var.canBorrows\n            : _var.safeAvailableToBorrow;\n\n        return (\n            _var.borrowedBalance,\n            _var.canBorrows,\n            _var.safeAvailableToBorrow,\n            _var.accountBalance,\n            _var.maxRepay,\n            _asset.decimals()\n        );\n    }\n\n    struct availableToBorrowLocalVars {\n        uint256 borrowFactor;\n        uint256 accountEquity;\n        uint256 sumCollateral;\n        uint256 sumBorrowed;\n        uint256 availableToBorrow;\n        uint256 safeAvailableToBorrow;\n    }\n\n    function getBalance(IiToken _asset, address _account)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _asset.underlying() == IERC20(0)\n                ? _account.balance\n                : _asset.underlying().balanceOf(_account);\n    }\n\n    struct liquidateLocalVars {\n        IPriceOracle oracle;\n        uint256 priceBorrowed;\n        uint256 priceCollateral;\n        uint256 liquidatorBalance;\n        uint256 borrowerCollateralBalance;\n        uint256 shortfall;\n        uint256 exchangeRateCollateral;\n        uint256 maxRepay;\n        uint256 maxSeizediToken;\n        uint256 maxRepayByCollateral;\n        bool available;\n    }\n\n    function getLiquidationInfo(\n        address _borrower,\n        address _liquidator,\n        IiToken _assetBorrowed,\n        IiToken _assetCollateral\n    )\n        public\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        liquidateLocalVars memory _var;\n\n        _var.oracle = controller.priceOracle();\n        if (_var.oracle.getAssetPriceStatus(_assetCollateral))\n            _var.available = getAccountAvailable(_borrower);\n\n        _var.maxRepay = _assetBorrowed.borrowBalanceCurrent(_borrower)\n            .rmul(controller.closeFactorMantissa());\n        _var.exchangeRateCollateral = _assetCollateral.exchangeRateCurrent();\n\n        _var.liquidatorBalance = getBalance(_assetBorrowed, _liquidator);\n        (, _var.shortfall, , ) = calcAccountEquity(_borrower);\n        if (_var.shortfall == 0 || _borrower == _liquidator)\n            return (0, 0, _var.liquidatorBalance, _var.available);\n\n        _var.priceBorrowed = _var.oracle.getUnderlyingPrice(_assetBorrowed);\n        _var.priceCollateral = _var.oracle.getUnderlyingPrice(_assetCollateral);\n\n        _var.maxSeizediToken = _var\n            .maxRepay\n            .mul(_var.priceBorrowed)\n            .rmul(controller.liquidationIncentiveMantissa())\n            .rdiv(_var.exchangeRateCollateral)\n            .div(_var.priceCollateral);\n        _var.borrowerCollateralBalance = _assetCollateral.balanceOf(\n            _borrower\n        );\n        if (_var.maxSeizediToken < _var.borrowerCollateralBalance)\n            return (\n                _var.maxRepay,\n                _var.maxRepay,\n                _var.liquidatorBalance,\n                _var.available\n            );\n\n        _var.maxRepayByCollateral = _var\n            .borrowerCollateralBalance\n            .rmul(_var.exchangeRateCollateral)\n            .mul(_var.priceCollateral)\n            .div(_var.priceBorrowed)\n            .rdiv(controller.liquidationIncentiveMantissa());\n        return (\n            _var.maxRepay,\n            _var.maxRepayByCollateral,\n            _var.liquidatorBalance,\n            _var.available\n        );\n    }\n\n    function getAccountRewardAmount(address _account) external returns (uint256) {\n\n        IRewardDistributor _rewardDistributor = IRewardDistributor(controller.rewardDistributor());\n        address[] memory _accounts = new address[](1);\n        _accounts[0] = _account;\n        _rewardDistributor.updateRewardBatch(_accounts ,controller.getAlliTokens());\n        return _rewardDistributor.reward(_account);\n    }\n\n    struct AccountEquityLocalVars {\n        IiToken[] collateralITokens;\n        IiToken[] borrowedITokens;\n        uint256 collateralFactor;\n        uint256 borrowFactor;\n        uint256 sumCollateral;\n        uint256 sumBorrowed;\n    }\n\n    function calcAccountEquity(address _account) public view returns (uint256, uint256, uint256, uint256) {\n        AccountEquityLocalVars memory _var;\n        _var.collateralITokens = controller.getEnteredMarkets(_account);\n        for (uint256 i = 0; i < _var.collateralITokens.length; i++) {\n            (_var.collateralFactor, , , , , , ) = controller.markets(_var.collateralITokens[i]);\n            _var.sumCollateral = _var.sumCollateral.add(\n                _var.collateralITokens[i].balanceOf(_account)\n                .mul(controller.priceOracle().getUnderlyingPrice(_var.collateralITokens[i]))\n                .rmul(_var.collateralITokens[i].exchangeRateStored())\n                .rmul(_var.collateralFactor)\n            );\n        }\n        _var.borrowedITokens = controller.getBorrowedAssets(_account);\n        for (uint256 i = 0; i < _var.borrowedITokens.length; i++) {\n            (, _var.borrowFactor, , , , , ) = controller.markets(_var.borrowedITokens[i]);\n            _var.sumBorrowed = _var.sumBorrowed.add(\n                _var.borrowedITokens[i].borrowBalanceStored(_account)\n                .mul(controller.priceOracle().getUnderlyingPrice(_var.borrowedITokens[i]))\n                .rdiv(_var.borrowFactor)\n            );\n        }\n        return\n            _var.sumCollateral > _var.sumBorrowed\n                ? (\n                    _var.sumCollateral - _var.sumBorrowed,\n                    uint256(0),\n                    _var.sumCollateral,\n                    _var.sumBorrowed\n                )\n                : (\n                    uint256(0),\n                    _var.sumBorrowed - _var.sumCollateral,\n                    _var.sumCollateral,\n                    _var.sumBorrowed\n                );\n    }\n\n    function getAccountAvailable(address _account) public view returns (bool) {\n        \n        IiToken[] memory _collateralITokens = controller.getEnteredMarkets(_account);\n        for (uint256 i = 0; i < _collateralITokens.length; i++) {\n            if (!controller.priceOracle().getAssetPriceStatus(_collateralITokens[i]))\n                return false;\n        }\n        IiToken[] memory _borrowedITokens = controller.getBorrowedAssets(_account);\n        for (uint256 i = 0; i < _borrowedITokens.length; i++) {\n            if (!controller.priceOracle().getAssetPriceStatus(_borrowedITokens[i]))\n                return false;\n        }\n        return true;\n    }\n}\n"}}}