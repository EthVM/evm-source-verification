{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "Base64.sol": {
      "content": "/// SPDX-License-Identifier: MIT\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\n\npragma solidity ^0.8.0;\n\nlibrary Base64 {\n    bytes internal constant TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\n                )\n                out := shl(8, out)\n                out := add(\n                    out,\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\n                )\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}\n"
    },
    "ReflectionsMetadata.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./Base64.sol\";\n\ninterface ICorruptionsMetadata {\n    function tokenURI(uint256 tokenId, uint256 amount)\n        external\n        view\n        returns (string memory);\n}\n\ninterface ICorruptionsDataMapper {\n    function valueFor(uint256 mapIndex, uint256 key)\n        external\n        view\n        returns (uint256);\n}\n\ninterface ICorruptionsDeviationWriter {\n    function drawCanvas(uint256 tokenId, uint256 amount)\n        external\n        pure\n        returns (string[32] memory);\n}\n\ninterface ICorruptionsFont {\n    function font() external view returns (string memory);\n}\n\nstruct DeviationInfo {\n    string name;\n    address contractAddress;\n    uint256 extraData;\n}\n\ninterface ICorruptionsDeviationRegistry {\n    function valueFor(uint256 index)\n        external\n        view\n        returns (DeviationInfo memory);\n}\n\nstruct InsightMap {\n    uint256 savedXP;\n    uint256 lastSaveBlock;\n}\n\ninterface ICorruptions {\n    function insightMap(uint256 tokenID)\n        external\n        view\n        returns (InsightMap memory);\n}\n\ncontract ReflectionsMetadata is Ownable, ICorruptionsMetadata {\n    string public description;\n    ICorruptionsFont private font =\n        ICorruptionsFont(0xdf8A48979F33f12952Ab4cF6f960EA4071fc656b);\n    ICorruptionsDataMapper private dataMapper =\n        ICorruptionsDataMapper(0x7A96d95a787524a27a4df36b64a96910a2fDCF5B);\n    ICorruptionsDeviationRegistry private deviationRegistry =\n        ICorruptionsDeviationRegistry(\n            0x40f7ad19c7F37AcD76958d61Cbc783c77411cd9b\n        );\n    ICorruptions private corruptions =\n        ICorruptions(0x5BDf397bB2912859Dbd8011F320a222f79A28d2E);\n\n    struct RandParts {\n        string border;\n        string corruptor;\n        string phrase;\n        string checker;\n        bool omitInsight;\n        uint16 reduction;\n        bool alternate;\n    }\n\n    constructor() Ownable() {\n        description = \"Unknown\";\n    }\n\n    function setDescription(string memory desc) public onlyOwner {\n        description = desc;\n    }\n\n    function setFont(address fontAddress) public onlyOwner {\n        font = ICorruptionsFont(fontAddress);\n    }\n\n    function _blank(string[32] memory canvas)\n        public\n        pure\n        returns (string[32] memory)\n    {\n        for (uint8 i = 0; i < 32; i++) {\n            canvas[\n                i\n            ] = \"&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;\";\n        }\n        return canvas;\n    }\n\n    function _insert(\n        bytes memory canvasLine,\n        uint256 offset,\n        bytes memory str,\n        bool singleChar\n    ) private pure {\n        canvasLine[offset * 9 + 0] = str[0];\n        if (singleChar) {\n            canvasLine[offset * 9 + 1] = \"<\";\n            canvasLine[offset * 9 + 2] = \"!\";\n            canvasLine[offset * 9 + 3] = \"-\";\n            canvasLine[offset * 9 + 4] = \"-\";\n            canvasLine[offset * 9 + 5] = \" \";\n            canvasLine[offset * 9 + 6] = \"-\";\n            canvasLine[offset * 9 + 7] = \"-\";\n            canvasLine[offset * 9 + 8] = \">\";\n        } else {\n            canvasLine[offset * 9 + 1] = str[1];\n            canvasLine[offset * 9 + 2] = str[2];\n            canvasLine[offset * 9 + 3] = str[3];\n            canvasLine[offset * 9 + 4] = str[4];\n            canvasLine[offset * 9 + 5] = str[5];\n            canvasLine[offset * 9 + 6] = str[6];\n            canvasLine[offset * 9 + 7] = str[7];\n            canvasLine[offset * 9 + 8] = str[8];\n        }\n    }\n\n    function _box(\n        string[32] memory canvas,\n        string memory char,\n        uint256 x,\n        uint256 y,\n        uint256 w,\n        uint256 h,\n        bool singleChar\n    ) public pure returns (string[32] memory) {\n        bytes memory str = bytes(char);\n        for (uint256 iy = 0; iy < h; iy++) {\n            bytes memory canvasLine = bytes(canvas[iy + y]);\n            for (uint256 ix = 0; ix < w; ix++) {\n                _insert(canvasLine, ix + x, str, singleChar);\n            }\n        }\n        return canvas;\n    }\n\n    function _checkeredBox(\n        string[32] memory canvas,\n        string memory char,\n        string memory char2,\n        uint256 x,\n        uint256 y,\n        uint256 w,\n        uint256 h,\n        bool singleChar\n    ) public pure returns (string[32] memory) {\n        bytes memory str = bytes(char);\n        bytes memory str2 = bytes(char2);\n        for (uint256 iy = 0; iy < h; iy++) {\n            bytes memory canvasLine = bytes(canvas[iy + y]);\n            for (uint256 ix = 0; ix < w; ix++) {\n                _insert(\n                    canvasLine,\n                    ix + x,\n                    ((iy + y) + (ix + x)) % 2 == 0 ? str : str2,\n                    singleChar\n                );\n            }\n        }\n        return canvas;\n    }\n\n    function _drawCircle(\n        string[32] memory canvas,\n        string memory char,\n        uint256 xc,\n        uint256 yc,\n        uint256 x,\n        uint256 y,\n        bool singleChar\n    ) public pure returns (string[32] memory) {\n        bytes memory str = bytes(char);\n\n        _insert(bytes(canvas[yc + y]), xc + x, str, singleChar);\n        _insert(bytes(canvas[yc + y]), xc - x, str, singleChar);\n        _insert(bytes(canvas[yc - y]), xc + x, str, singleChar);\n        _insert(bytes(canvas[yc - y]), xc - x, str, singleChar);\n        _insert(bytes(canvas[yc + x]), xc + y, str, singleChar);\n        _insert(bytes(canvas[yc + x]), xc - y, str, singleChar);\n        _insert(bytes(canvas[yc - x]), xc + y, str, singleChar);\n        _insert(bytes(canvas[yc - x]), xc - y, str, singleChar);\n\n        return canvas;\n    }\n\n    function _circle(\n        string[32] memory canvas,\n        string memory char,\n        uint256 xc,\n        uint256 yc,\n        int8 r,\n        bool singleChar\n    ) public pure returns (string[32] memory) {\n        // https://www.geeksforgeeks.org/bresenhams-circle-drawing-algorithm/\n\n        int256 x = 0;\n        int256 y = int256(r);\n        int256 d = 3 - 2 * r;\n        canvas = _drawCircle(\n            canvas,\n            char,\n            xc,\n            yc,\n            uint256(x),\n            uint256(y),\n            singleChar\n        );\n        while (y >= x) {\n            x++;\n\n            if (d > 0) {\n                y--;\n                d = d + 4 * (x - y) + 10;\n            } else {\n                d = d + 4 * x + 6;\n            }\n            canvas = _drawCircle(\n                canvas,\n                char,\n                xc,\n                yc,\n                uint256(x),\n                uint256(y),\n                singleChar\n            );\n        }\n\n        return canvas;\n    }\n\n    function _middleBox(\n        string[32] memory canvas,\n        string memory char,\n        string memory char2,\n        uint256 size,\n        bool singleChar\n    ) public pure returns (string[32] memory) {\n        canvas = _checkeredBox(\n            canvas,\n            char,\n            char2,\n            15 - size,\n            15 - size,\n            size * 2 + 1,\n            size * 2 + 1,\n            singleChar\n        );\n        return canvas;\n    }\n\n    function _text(\n        string[32] memory canvas,\n        string memory message,\n        uint256 messageLength,\n        uint256 x,\n        uint256 y\n    ) public pure returns (string[32] memory) {\n        bytes memory canvasLine = bytes(canvas[y]);\n        for (uint256 i = 0; i < messageLength; i++) {\n            _insert(\n                canvasLine,\n                x + i,\n                abi.encodePacked(bytes(message)[i]),\n                true\n            );\n        }\n\n        return canvas;\n    }\n\n    function _richText(\n        string[32] memory canvas,\n        string memory message,\n        uint256 messageLength,\n        uint256 x,\n        uint256 y\n    ) public pure returns (string[32] memory) {\n        bytes memory canvasLine = bytes(canvas[y]);\n        for (uint256 i = 0; i < messageLength / 9; i++) {\n            bytes memory sequence = abi.encodePacked(\n                abi.encodePacked(\n                    bytes(message)[i * 9],\n                    bytes(message)[i * 9 + 1],\n                    bytes(message)[i * 9 + 2],\n                    bytes(message)[i * 9 + 3],\n                    bytes(message)[i * 9 + 4],\n                    bytes(message)[i * 9 + 5]\n                ),\n                bytes(message)[i * 9 + 6],\n                bytes(message)[i * 9 + 7],\n                bytes(message)[i * 9 + 8]\n            );\n            _insert(canvasLine, x + i, sequence, false);\n        }\n\n        return canvas;\n    }\n\n    function draw(\n        uint256 tokenId,\n        uint256 amount,\n        string[32] memory oCanvas\n    ) public view returns (string memory) {\n        string[31] memory lookup = [\n            \"20\",\n            \"31\",\n            \"42\",\n            \"53\",\n            \"64\",\n            \"75\",\n            \"86\",\n            \"97\",\n            \"108\",\n            \"119\",\n            \"130\",\n            \"141\",\n            \"152\",\n            \"163\",\n            \"174\",\n            \"185\",\n            \"196\",\n            \"207\",\n            \"218\",\n            \"229\",\n            \"240\",\n            \"251\",\n            \"262\",\n            \"273\",\n            \"284\",\n            \"295\",\n            \"306\",\n            \"317\",\n            \"328\",\n            \"339\",\n            \"350\"\n        ];\n\n        string[40] memory randomStrings = [\n            \"/\",\n            \"$\",\n            \"|\",\n            \"8\",\n            \"_\",\n            \"?\",\n            \"#\",\n            \"%\",\n            \"^\",\n            \"~\",\n            \":\",\n            \"#0D1302\",\n            \"#020A13\",\n            \"#130202\",\n            \"#1A1616\",\n            \"#000000\",\n            \"#040A27\",\n            \"#022FB7\",\n            \"#262A36\",\n            \"#A802B7\",\n            \"#3CB702\",\n            \"#B76F02\",\n            \"#B70284\",\n            \"BLOODLINES\",\n            \"COLLECTIVE\",\n            \"REFLECTION\",\n            \"COMPLETION\",\n            \"OMNIPOTENT\",\n            \"DREAMWORLD\",\n            \"REDEMPTION\",\n            \"RESOLUTION\",\n            \"ABSOLUTION\",\n            \"LIBERATION\",\n            \"|\",\n            \"-\",\n            \"=\",\n            \"+\",\n            \"\\\\\",\n            \":\",\n            \"~\"\n        ];\n\n        RandParts memory randParts;\n\n        randParts.border = randomStrings[\n            uint256(keccak256(abi.encodePacked(\"BORDER\", tokenId))) % 11\n        ];\n        randParts.corruptor = randomStrings[\n            uint256(keccak256(abi.encodePacked(\"CORRUPTOR\", tokenId))) % 11\n        ];\n        randParts.phrase = randomStrings[\n            23 + (uint256(keccak256(abi.encodePacked(\"PHRASE\", tokenId))) % 10)\n        ];\n        randParts.checker = randomStrings[\n            33 + (uint256(keccak256(abi.encodePacked(\"CHECKER\", tokenId))) % 7)\n        ];\n\n        string[32] memory canvas;\n\n        if (bytes(oCanvas[0]).length > 32) {\n            canvas = _blank(canvas);\n\n            randParts.omitInsight = true;\n            randParts.reduction = 64 + uint8(bytes(oCanvas[0])[tokenId % 32]);\n            randParts.alternate = true;\n\n            for (uint256 i = 0; i < 32; i++) {\n                canvas = _richText(\n                    canvas,\n                    oCanvas[i],\n                    bytes(oCanvas[i]).length,\n                    0,\n                    i\n                );\n            }\n        } else if (bytes(oCanvas[0]).length > 0) {\n            canvas = _blank(canvas);\n\n            randParts.omitInsight = true;\n            randParts.reduction = 64;\n\n            for (uint256 i = 0; i < 32; i++) {\n                canvas = _text(\n                    canvas,\n                    oCanvas[i],\n                    bytes(oCanvas[i]).length,\n                    0,\n                    i\n                );\n            }\n        } else {\n            canvas = _blank(canvas);\n\n            canvas = _box(canvas, randParts.border, 0, 0, 31, 1, true);\n            canvas = _box(canvas, randParts.border, 0, 30, 31, 1, true);\n            canvas = _box(canvas, randParts.border, 0, 0, 1, 31, true);\n            canvas = _box(canvas, randParts.border, 30, 0, 1, 31, true);\n\n            canvas = _circle(\n                canvas,\n                string(abi.encodePacked(bytes(randParts.phrase)[0])),\n                15,\n                15,\n                12,\n                true\n            );\n            canvas = _circle(\n                canvas,\n                string(abi.encodePacked(bytes(randParts.phrase)[1])),\n                15,\n                15,\n                11,\n                true\n            );\n            canvas = _circle(\n                canvas,\n                string(abi.encodePacked(bytes(randParts.phrase)[2])),\n                15,\n                15,\n                10,\n                true\n            );\n            canvas = _circle(\n                canvas,\n                string(abi.encodePacked(bytes(randParts.phrase)[3])),\n                15,\n                15,\n                9,\n                true\n            );\n            canvas = _circle(\n                canvas,\n                string(abi.encodePacked(bytes(randParts.phrase)[4])),\n                15,\n                15,\n                8,\n                true\n            );\n            canvas = _circle(\n                canvas,\n                string(abi.encodePacked(bytes(randParts.phrase)[5])),\n                15,\n                15,\n                7,\n                true\n            );\n            canvas = _circle(\n                canvas,\n                string(abi.encodePacked(bytes(randParts.phrase)[6])),\n                15,\n                15,\n                6,\n                true\n            );\n            canvas = _circle(\n                canvas,\n                string(abi.encodePacked(bytes(randParts.phrase)[7])),\n                15,\n                15,\n                5,\n                true\n            );\n            canvas = _circle(\n                canvas,\n                string(abi.encodePacked(bytes(randParts.phrase)[8])),\n                15,\n                15,\n                4,\n                true\n            );\n            canvas = _circle(\n                canvas,\n                string(abi.encodePacked(bytes(randParts.phrase)[9])),\n                15,\n                15,\n                3,\n                true\n            );\n        }\n\n        uint256 iterations = uint256(\n            keccak256(abi.encodePacked(\"CORRUPTION\", tokenId))\n        ) % 1024;\n        if (randParts.reduction > 0) {\n            iterations = iterations % randParts.reduction;\n        }\n        for (uint256 i = 0; i < iterations; i++) {\n            if (randParts.alternate && i % 2 == 0) {\n                canvas = _box(\n                    canvas,\n                    randParts.border,\n                    uint256(keccak256(abi.encodePacked(\"X\", i, tokenId))) % 30,\n                    uint256(keccak256(abi.encodePacked(\"Y\", i, tokenId))) % 30,\n                    1,\n                    1,\n                    true\n                );\n            } else {\n                canvas = _box(\n                    canvas,\n                    randParts.corruptor,\n                    uint256(keccak256(abi.encodePacked(\"X\", i, tokenId))) % 30,\n                    uint256(keccak256(abi.encodePacked(\"Y\", i, tokenId))) % 30,\n                    1,\n                    1,\n                    true\n                );\n            }\n        }\n\n        if (!randParts.omitInsight) {\n            uint256 length = 8 + bytes(toString(amount)).length;\n            canvas = _text(\n                canvas,\n                string(abi.encodePacked(\"INSIGHT \", toString(amount))),\n                length,\n                31 - length,\n                30\n            );\n\n            for (uint256 i = 10; i > 0; i--) {\n                if (amount >= i * 2) {\n                    canvas = _middleBox(\n                        canvas,\n                        string(\n                            abi.encodePacked(bytes(randParts.phrase)[i - 1])\n                        ),\n                        randParts.checker,\n                        i,\n                        true\n                    );\n                }\n            }\n        }\n\n        string memory output;\n        for (uint8 i = 0; i < 31; i++) {\n            output = string(\n                abi.encodePacked(\n                    output,\n                    '<text x=\"10\" y=\"',\n                    lookup[i],\n                    '\" class=\"base\">',\n                    canvas[i],\n                    \"</text>\"\n                )\n            );\n        }\n\n        string[12] memory parts;\n        parts[\n            0\n        ] = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 820 1460\" class=\"reflection\"><style>@font-face { font-family: CorruptionsFont; src: url(\"';\n        parts[1] = font.font();\n        parts[2] = '\") format(\"opentype\"); } .base { fill: ';\n        parts[3] = randomStrings[\n            11 + (uint256(keccak256(abi.encodePacked(\"BGCOLOR\", tokenId))) % 6)\n        ];\n        parts[\n            4\n        ] = '; font-family: CorruptionsFont; font-size: 10px; } .reflection g { -moz-transform: scale(-4, 4); -webkit-transform: scale(-4, 4); -o-transform: scale(-4, 4); -ms-transform: scale(-4, 4); transform: scale(-4, 4); }</style><g transform=\"scale(-4 4)\" transform-origin=\"164 0\"><rect width=\"205\" height=\"365\" fill=\"';\n        parts[5] = amount >= 2\n            ? randomStrings[\n                17 +\n                    (uint256(keccak256(abi.encodePacked(\"FGCOLOR\", tokenId))) %\n                        6)\n            ]\n            : randomStrings[\n                27 +\n                    (uint256(keccak256(abi.encodePacked(\"FGCOLOR\", tokenId))) %\n                        6)\n            ];\n        parts[6] = '\" />';\n        parts[7] = output;\n        parts[8] = \"\";\n        parts[9] = \"\";\n        parts[10] = \"\";\n        parts[11] = \"</g></svg>\";\n\n        if (amount >= 2) {\n            parts[8] = \"<!-- \";\n            parts[9] = randomStrings[\n                27 +\n                    (uint256(keccak256(abi.encodePacked(\"FGCOLOR\", tokenId))) %\n                        6)\n            ];\n            parts[10] = \" -->\";\n        }\n\n        output = string(\n            abi.encodePacked(\n                parts[0],\n                parts[1],\n                parts[2],\n                parts[3],\n                parts[4],\n                parts[5],\n                parts[6]\n            )\n        );\n        output = string(\n            abi.encodePacked(\n                output,\n                parts[7],\n                parts[8],\n                parts[9],\n                parts[10],\n                parts[11]\n            )\n        );\n        return Base64.encode(bytes(output));\n    }\n\n    function tokenURI(uint256 tokenId, uint256 amount)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        InsightMap memory insightMap = corruptions.insightMap(tokenId);\n        if (insightMap.lastSaveBlock <= 13604851 && tokenId != 3193) {\n            amount += 1; // fix early transfer bug\n        }\n        string memory json;\n        string[32] memory emptyCanvas;\n        DeviationInfo memory info = deviationRegistry.valueFor(\n            dataMapper.valueFor(0, tokenId)\n        );\n        json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"0x',\n                        toHexString(tokenId),\n                        '\", \"description\": \"',\n                        description,\n                        '\", \"image\": \"data:image/svg+xml;base64,',\n                        draw(tokenId, amount, emptyCanvas),\n                        '\", \"attributes\": [{\"trait_type\": \"Deviation\", \"value\": \"',\n                        info.name,\n                        '\"}, {\"trait_type\": \"Insight\", \"value\": \"',\n                        toString(amount),\n                        '\"}]}'\n                    )\n                )\n            )\n        );\n\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT license\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function toHexString(uint256 i) internal pure returns (string memory) {\n        // https://stackoverflow.com/a/69302348/424107\n\n        if (i == 0) return \"0\";\n        uint256 j = i;\n        uint256 length;\n        while (j != 0) {\n            length++;\n            j = j >> 4;\n        }\n        uint256 mask = 15;\n        bytes memory bstr = new bytes(length);\n        uint256 k = length;\n        while (i != 0) {\n            uint256 curr = (i & mask);\n            bstr[--k] = curr > 9\n                ? bytes1(uint8(55 + curr))\n                : bytes1(uint8(48 + curr)); // 55 = 65 - 10\n            i = i >> 4;\n        }\n        return string(bstr);\n    }\n}\n"
    }
  }
}