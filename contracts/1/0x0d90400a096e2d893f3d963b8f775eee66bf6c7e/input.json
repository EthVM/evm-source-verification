{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Mag.sol": {
      "content": "// SPDX-License-Identifier: MAG\n\n//mlm smartcontract code git link https://github.com/mageco24x7/SmartContract/blob/main/MAG_SOL_1506_v2%20(3)%20(2)\npragma solidity =0.8.4;\n\n\n\n\n\n\ncontract SafeMath {\n    \n    \n        function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n    \n    \n       function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n\n       function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n            require(b <= a, errorMessage);\n            uint256 c = a - b;\n            return c;\n        }\n\n\n        function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n\n    \n      function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n            return div(a, b, \"SafeMath: division by zero\");\n        }\n        \n    \n    \n    \n        function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n}\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor ()  { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address ) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\nabstract contract ERC20Interface {\n    function owner() public view  virtual returns (address);\n    function totalSupply() public view virtual returns (uint);\n    function soldtokensvalue()  public view virtual returns (uint);\n    function balanceOf(address tokenOwner) public view virtual returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view virtual returns (uint remaining);\n    function transfer(address to, uint tokens) public virtual returns (bool success);\n    function approve(address spender, uint tokens) public virtual returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);\n\n    // event Transfer(address indexed from, address indexed to, uint tokens);\n    // event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n\n\ncontract Ownable  {\n  address public _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor ()  {\n   \n    _owner = msg.sender;\n    emit OwnershipTransferred(address(0), msg.sender);\n  }\n\n\n  modifier onlyOwner() {\n    require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  \n  function renounceOwnership() public onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    _transferOwnership(newOwner);\n  }\n\n\n  function _transferOwnership(address newOwner) internal {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n\ncontract MAG is ERC20Interface, SafeMath ,Ownable,Context{\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n    uint  soldtokens;\n    bool lock;\n    \n    \n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n    \n    // Triggered whenever approve(address _spender, uint256 _value) is called.\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    // Triggered when tokens are transferred.\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    \n    constructor ()  {\n        symbol = \"MAG\";\n        name = \"Mutual Alliance Global\";\n        decimals = 18;\n        _totalSupply = 1000000000 *1e18;\n        balances[msg.sender] = _totalSupply; \n      \n        \n    }\n         /**\n   * @dev can act as protection for reentracy style attacks \n   * .\n   */\n    \n        modifier reentrancygaurd {\n            require(!lock,\"reentracy\");\n            lock = true;\n            _;\n            lock = false;\n    }\n    \n      /**\n   * @dev can view soldtokens \n   * Can only be called by the current owner.\n   */\n    \n    function soldtokensvalue()public  override view returns(uint){\n        return soldtokens;\n    }\n    \n         /**\n   * @dev can view totalSupply of tokens \n   */\n    \n    function totalSupply() public override view returns (uint256) {\n      return _totalSupply;\n    }\n\n  function owner() public override  view returns (address) {\n    return _owner;\n  }\n\n\n         /**\n   * @dev can transfer tokens to specific address \n   * function reverts back if sender addresss is invalid or address is zero\n   */\n    function transfer(address to, uint tokens) public reentrancygaurd override returns (bool success) {\n        require(to != address(0), \"invalid reciever address\");\n       \n        require(balances[msg.sender] >= tokens && safeAdd (balances[to],tokens) >= balances[to]);\n         \n         \n         \n          require (to!=msg.sender && tokens>0,\"cannot send to self address or zero amount\");\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n         if(msg.sender==_owner){\n            soldtokens=safeAdd(soldtokens,tokens);\n        }\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n    \n             /**\n   * @dev can approve tokens for another account to sell\n   * function reverts back if sender addresss is invalid or address is zero\n   */\n\n    function approve(address spender, uint tokens) public override returns (bool success) {\n         require(spender != address(0), \"invalid spender address\");\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    // function balanceOf(address _user) public override view returns (uint256 balance) {\n    //     return balances[owner];\n    // }\n    \n    \n      function balanceOf(address user) public override view returns (uint256 balance) {\n        return balances[user];\n    }\n\n             /**\n   * @dev can transfer tokens from specific address to specific address if having enough token allowances\n   * function reverts back if sender addresss is invalid or address is zero\n   */\n    function transferFrom(address from, address to, uint tokens) public reentrancygaurd override returns (bool success) {\n         require(from != address(0), \"invalid sender address\");\n         require(to != address(0), \"invalid reciever address\");\n          require(balances[from] >= tokens &&  safeAdd( balances[to],tokens) >= balances[to],\"insufficient funds\");\n           allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n\n           require(tokens>0 && from !=to,\"connot send to self address or zero balance\");\n            balances[from] = safeSub(balances[from], tokens);\n           \n            balances[to] = safeAdd(balances[to], tokens);\n               if(from==_owner){\n                soldtokens=safeAdd(soldtokens,tokens);\n            }\n        emit Transfer(from, to, tokens);\n           \n        return true;\n    }\n    \n     //to check owner ether balance \n     function getOwneretherBalance()public  view returns (uint) {\n        return _owner.balance;\n    }\n    \n    //to check the user etherbalance\n     function etherbalance(address _account)public  view returns (uint) {\n        return _account.balance;\n    }\n\n\n    function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n}\n"
    }
  }
}