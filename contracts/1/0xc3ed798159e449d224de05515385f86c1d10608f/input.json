{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "AllMarketsV2.sol": {
      "content": "// File: contracts/external/openzeppelin-solidity/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath128 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        uint128 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint128 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\r\n        require(b <= a, errorMessage);\r\n        uint128 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint128 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint128 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath64 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        uint64 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint64 a, uint64 b, string memory errorMessage) internal pure returns (uint64) {\r\n        require(b <= a, errorMessage);\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint64 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint64 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath32 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint32 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\r\n        require(b <= a, errorMessage);\r\n        uint32 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint32 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/external/proxy/Proxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function () external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n            }\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function implementation() public view returns (address);\r\n}\r\n\r\n// File: contracts/external/proxy/UpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param implementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    // Storage position of the address of the current implementation\r\n    bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.govblocks.proxy.implementation\");\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor() public {}\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the current implementation\r\n    * @param _newImplementation address representing the new implementation to be set\r\n    */\r\n    function _setImplementation(address _newImplementation) internal {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n        sstore(position, _newImplementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(address _newImplementation) internal {\r\n        address currentImplementation = implementation();\r\n        require(currentImplementation != _newImplementation);\r\n        _setImplementation(_newImplementation);\r\n        emit Upgraded(_newImplementation);\r\n    }\r\n}\r\n\r\n// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    // Storage position of the owner of the contract\r\n    bytes32 private constant PROXY_OWNER_POSITION = keccak256(\"org.govblocks.proxy.owner\");\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor(address _implementation) public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\r\n        require(_newOwner != address(0));\r\n        _setUpgradeabilityOwner(_newOwner);\r\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\r\n    * @param _implementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(address _implementation) public onlyProxyOwner {\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            sstore(position, _newProxyOwner)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IMarketUtility.sol\r\n\r\npragma solidity 0.5.7;\r\ncontract IMarketUtility {\r\n\r\n    function initialize(address payable[] calldata _addressParams, address _initiater) external;\r\n\r\n\t/**\r\n     * @dev to Set authorized address to update parameters \r\n     */\r\n    function setAuthorizedAddres() public;\r\n\r\n\t/**\r\n     * @dev to update uint parameters in Market Config \r\n     */\r\n    function updateUintParameters(bytes8 code, uint256 value) external;\r\n\r\n    /**\r\n     * @dev to Update address parameters in Market Config \r\n     */\r\n    function updateAddressParameters(bytes8 code, address payable value) external;\r\n \r\n     /**\r\n    * @dev Get Parameters required to initiate market\r\n    * @return Addresses of tokens to be distributed as incentives\r\n    * @return Cool down time for market\r\n    * @return Rate\r\n    * @return Commission percent for predictions with ETH\r\n    * @return Commission percent for predictions with PLOT\r\n    **/\r\n    function getMarketInitialParams() public view returns(address[] memory, uint , uint, uint, uint);\r\n\r\n    function getAssetPriceUSD(address _currencyAddress) external view returns(uint latestAnswer);\r\n\r\n    function getAssetValueETH(address _currencyAddress, uint256 _amount)\r\n        public\r\n        view\r\n        returns (uint256 tokenEthValue);\r\n    \r\n    function checkMultiplier(address _asset, address _user, uint _predictionStake, uint predictionPoints, uint _stakeValue) public view returns(uint, bool);\r\n  \r\n    function calculatePredictionPoints(address _user, bool multiplierApplied, uint _predictionStake, address _asset, uint64 totalPredictionPoints, uint64 predictionPointsOnOption) external view returns(uint64 predictionPoints, bool isMultiplierApplied);\r\n\r\n    function calculateOptionRange(uint _optionRangePerc, uint64 _decimals, uint8 _roundOfToNearest, address _marketFeed) external view returns(uint64 _minValue, uint64 _maxValue);\r\n    \r\n    function getOptionPrice(uint64 totalPredictionPoints, uint64 predictionPointsOnOption) public view returns(uint64 _optionPrice);\r\n    \r\n    function getPriceFeedDecimals(address _priceFeed) public view returns(uint8);\r\n\r\n    function getValueAndMultiplierParameters(address _asset, uint256 _amount)\r\n        public\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    function update() external;\r\n    \r\n    function calculatePredictionValue(uint[] memory params, address asset, address user, address marketFeedAddress, bool _checkMultiplier) public view returns(uint _predictionValue, bool _multiplierApplied);\r\n    \r\n    /**\r\n     * @dev Get basic market details\r\n     * @return Minimum amount required to predict in market\r\n     * @return Percentage of users leveraged amount to deduct when placed in wrong prediction\r\n     * @return Decimal points for prediction positions\r\n     **/\r\n    function getBasicMarketDetails()\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function getDisputeResolutionParams() public view returns (uint256);\r\n    function calculateOptionPrice(uint[] memory params, address marketFeedAddress) public view returns(uint _optionPrice);\r\n\r\n    /**\r\n     * @dev Get price of provided feed address\r\n     * @param _currencyFeedAddress  Feed Address of currency on which market options are based on\r\n     * @return Current price of the market currency\r\n     **/\r\n    function getSettlemetPrice(\r\n        address _currencyFeedAddress,\r\n        uint256 _settleTime\r\n    ) public view returns (uint256 latestAnswer, uint256 roundId);\r\n\r\n    function getSettlemetPriceByRoundId(\r\n        address _currencyFeedAddress,\r\n        uint256 _settleTime,\r\n        uint80 _roundId\r\n    ) public view returns (uint256 latestAnswer, uint256 roundId);\r\n}\r\n\r\n// File: contracts/external/govblocks-protocol/interfaces/IGovernance.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IGovernance { \r\n\r\n    event Proposal(\r\n        address indexed proposalOwner,\r\n        uint256 indexed proposalId,\r\n        uint256 dateAdd,\r\n        string proposalTitle,\r\n        string proposalSD,\r\n        string proposalDescHash\r\n    );\r\n\r\n    event Solution(\r\n        uint256 indexed proposalId,\r\n        address indexed solutionOwner,\r\n        uint256 indexed solutionId,\r\n        string solutionDescHash,\r\n        uint256 dateAdd\r\n    );\r\n\r\n    event Vote(\r\n        address indexed from,\r\n        uint256 indexed proposalId,\r\n        uint256 indexed voteId,\r\n        uint256 dateAdd,\r\n        uint256 solutionChosen\r\n    );\r\n\r\n    event RewardClaimed(\r\n        address indexed member,\r\n        uint gbtReward\r\n    );\r\n\r\n    /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal. \r\n    event VoteCast (uint256 proposalId);\r\n\r\n    /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can \r\n    ///      call any offchain actions\r\n    event ProposalAccepted (uint256 proposalId);\r\n\r\n    /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\r\n    event CloseProposalOnTime (\r\n        uint256 indexed proposalId,\r\n        uint256 time\r\n    );\r\n\r\n    /// @dev ActionSuccess event is called whenever an onchain action is executed.\r\n    event ActionSuccess (\r\n        uint256 proposalId\r\n    );\r\n\r\n    /// @dev Creates a new proposal\r\n    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n    function createProposal(\r\n        string calldata _proposalTitle,\r\n        string calldata _proposalSD,\r\n        string calldata _proposalDescHash,\r\n        uint _categoryId\r\n    ) \r\n        external;\r\n\r\n    /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\r\n    function categorizeProposal(\r\n        uint _proposalId, \r\n        uint _categoryId,\r\n        uint _incentives\r\n    ) \r\n        external;\r\n\r\n    /// @dev Submit proposal with solution\r\n    /// @param _proposalId Proposal id\r\n    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    function submitProposalWithSolution(\r\n        uint _proposalId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external;\r\n\r\n    /// @dev Creates a new proposal with solution and votes for the solution\r\n    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    function createProposalwithSolution(\r\n        string calldata _proposalTitle, \r\n        string calldata _proposalSD, \r\n        string calldata _proposalDescHash,\r\n        uint _categoryId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external;\r\n\r\n    /// @dev Casts vote\r\n    /// @param _proposalId Proposal id\r\n    /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\r\n    function submitVote(uint _proposalId, uint _solutionChosen) external;\r\n\r\n    function closeProposal(uint _proposalId) external;\r\n\r\n    function claimReward(address _memberAddress, uint _maxRecords) external returns(uint pendingDAppReward); \r\n\r\n    function proposal(uint _proposalId)\r\n        external\r\n        view\r\n        returns(\r\n            uint proposalId,\r\n            uint category,\r\n            uint status,\r\n            uint finalVerdict,\r\n            uint totalReward\r\n        );\r\n\r\n    function canCloseProposal(uint _proposalId) public view returns(uint closeValue);\r\n\r\n    function allowedToCatgorize() public view returns(uint roleId);\r\n\r\n    /**\r\n     * @dev Gets length of propsal\r\n     * @return length of propsal\r\n     */\r\n    function getProposalLength() external view returns(uint);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IToken.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IToken {\r\n\r\n    function decimals() external view returns(uint8);\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param account The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param recipient The address to transfer to.\r\n    * @param amount The amount to be transferred.\r\n    */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev function that mints an amount of the token and assigns it to\r\n    * an account.\r\n    * @param account The account that will receive the created tokens.\r\n    * @param amount The amount that will be created.\r\n    */\r\n    function mint(address account, uint256 amount) external returns (bool);\r\n    \r\n     /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burn(uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param sender address The address which you want to send tokens from\r\n    * @param recipient address The address which you want to transfer to\r\n    * @param amount uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/ITokenController.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract ITokenController {\r\n\taddress public token;\r\n    address public bLOTToken;\r\n\r\n    /**\r\n    * @dev Swap BLOT token.\r\n    * account.\r\n    * @param amount The amount that will be swapped.\r\n    */\r\n    function swapBLOT(address _of, address _to, uint256 amount) public;\r\n\r\n    function totalBalanceOf(address _of)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    function transferFrom(address _token, address _of, address _to, uint256 amount) public;\r\n\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason at a specific time\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     * @param _time The timestamp to query the lock tokens for\r\n     */\r\n    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burnCommissionTokens(uint256 amount) external returns(bool);\r\n \r\n    function initiateVesting(address _vesting) external;\r\n\r\n    function lockForGovernanceVote(address _of, uint _days) public;\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function mint(address _member, uint _amount) public;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IMarketCreationRewards.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IMarketCreationRewards {\r\n\r\n    function calculateMarketCreationIncentive(address _createdBy, uint256 _gasCosumed, uint64 _marketId) external;    \r\n\r\n    function depositMarketRewardPoolShare(uint256 _marketId, uint256 _ethShare, uint256 _plotShare, uint64 _ethDeposit, uint64 _plotDeposit) external payable;\r\n\r\n    function returnMarketRewardPoolShare(uint256 _marketId) external;\r\n\r\n    function getMarketCreatorRPoolShareParams(uint256 _market, uint256 plotStaked, uint256 ethStaked) external view returns(uint16, bool);\r\n\r\n    function transferAssets(address _asset, address _to, uint _amount) external;\r\n\r\n}\r\n\r\n// File: contracts/AllMarkets.sol\r\n\r\n/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IMaster {\r\n    mapping(address => bool) public whitelistedSponsor;\r\n    function dAppToken() public view returns(address);\r\n    function getLatestAddress(bytes2 _module) public view returns(address);\r\n}\r\n\r\n\r\ncontract Governed {\r\n\r\n    address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\r\n\r\n    /// @dev modifier that allows only the authorized addresses to execute the function\r\n    modifier onlyAuthorizedToGovern() {\r\n        IMaster ms = IMaster(masterAddress);\r\n        require(ms.getLatestAddress(\"GV\") == msg.sender);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract AllMarkets is Governed {\r\n    using SafeMath32 for uint32;\r\n    using SafeMath64 for uint64;\r\n    using SafeMath128 for uint128;\r\n    using SafeMath for uint;\r\n\r\n    enum PredictionStatus {\r\n      Live,\r\n      InSettlement,\r\n      Cooling,\r\n      InDispute,\r\n      Settled\r\n    }\r\n\r\n    event Deposited(address indexed user, uint256 plot, uint256 eth, uint256 timeStamp);\r\n    event Withdrawn(address indexed user, uint256 plot, uint256 eth, uint256 timeStamp);\r\n    event MarketTypes(uint256 indexed index, uint32 predictionTime, uint32 optionRangePerc, bool status);\r\n    event MarketCurrencies(uint256 indexed index, address feedAddress, bytes32 currencyName, bool status);\r\n    event MarketQuestion(uint256 indexed marketIndex, bytes32 currencyName, uint256 indexed predictionType, uint256 startTime, uint256 predictionTime, uint256 neutralMinValue, uint256 neutralMaxValue);\r\n    event SponsoredIncentive(uint256 indexed marketIndex, address incentiveTokenAddress, address sponsoredBy, uint256 amount);\r\n    event MarketResult(uint256 indexed marketIndex, uint256[] totalReward, uint256 winningOption, uint256 closeValue, uint256 roundId);\r\n    event ReturnClaimed(address indexed user, uint256 plotReward, uint256 ethReward);\r\n    event ClaimedIncentive(address indexed user, uint256[] marketsClaimed, address incentiveTokenAddress, uint256 incentive);\r\n    event PlacePrediction(address indexed user,uint256 value, uint256 predictionPoints, address predictionAsset,uint256 prediction,uint256 indexed marketIndex, uint256 commissionPercent);\r\n    event DisputeRaised(uint256 indexed marketIndex, address raisedBy, uint256 proposalId, uint256 proposedValue);\r\n    event DisputeResolved(uint256 indexed marketIndex, bool status);\r\n\r\n    struct PredictionData {\r\n      uint64 predictionPoints;\r\n      uint64 ethStaked;\r\n      uint64 plotStaked;\r\n    }\r\n    \r\n    struct UserMarketData {\r\n      bool claimedReward;\r\n      bool predictedWithBlot;\r\n      bool multiplierApplied;\r\n      bool incentiveClaimed;\r\n      mapping(uint => PredictionData) predictionData;\r\n    }\r\n\r\n    struct UserData {\r\n      uint128 totalEthStaked;\r\n      uint128 totalPlotStaked;\r\n      uint128 lastClaimedIndex;\r\n      uint[] marketsParticipated;\r\n      mapping(address => uint) currencyUnusedBalance;\r\n      mapping(uint => UserMarketData) userMarketData;\r\n    }\r\n\r\n    struct CommissionPercent {\r\n     uint64 ethCommission; \r\n     uint64 plotCommission; \r\n    }\r\n\r\n    struct MarketBasicData {\r\n      uint32 Mtype;\r\n      uint32 currency;\r\n      uint32 startTime;\r\n      uint32 predictionTime;\r\n      uint64 neutralMinValue;\r\n      uint64 neutralMaxValue;\r\n    }\r\n\r\n    struct MarketDataExtended {\r\n      uint32 WinningOption;\r\n      uint32 settleTime;\r\n      address incentiveToken;\r\n      address incentiveSponsoredBy;\r\n      address disputeRaisedBy;\r\n      uint64 disputeStakeAmount;\r\n      uint64 ethCommission;\r\n      uint64 plotCommission;\r\n      uint incentiveToDistribute;\r\n      uint[] rewardToDistribute;\r\n      PredictionStatus predictionStatus;\r\n    }\r\n\r\n    struct MarketTypeData {\r\n      uint32 predictionTime;\r\n      uint32 optionRangePerc;\r\n      bool paused;\r\n    }\r\n\r\n    struct MarketCurrency {\r\n      bytes32 currencyName;\r\n      address marketFeed;\r\n      uint8 decimals;\r\n      uint8 roundOfToNearest;\r\n    }\r\n\r\n    struct MarketCreationData {\r\n      uint32 initialStartTime;\r\n      uint64 latestMarket;\r\n      uint64 penultimateMarket;\r\n      bool paused;\r\n    }\r\n\r\n    address internal ETH_ADDRESS;\r\n    address internal plotToken;\r\n\r\n    ITokenController internal tokenController;\r\n    IMarketUtility internal marketUtility;\r\n    IGovernance internal governance;\r\n    IMarketCreationRewards internal marketCreationRewards;\r\n\r\n    // uint8[] constant roundOfToNearest = [25,1];\r\n    uint internal totalOptions;\r\n    uint internal predictionDecimalMultiplier;\r\n    uint internal defaultMaxRecords;\r\n\r\n    bool internal marketCreationPaused;\r\n    MarketCurrency[] internal marketCurrencies;\r\n    MarketTypeData[] internal marketTypeArray;\r\n    CommissionPercent internal commissionPercGlobal; //with 2 decimals\r\n    mapping(bytes32 => uint) internal marketCurrency;\r\n\r\n    mapping(uint64 => uint32) internal marketType;\r\n    mapping(uint256 => mapping(uint256 => MarketCreationData)) internal marketCreationData;\r\n\r\n    MarketBasicData[] internal marketBasicData;\r\n\r\n    mapping(uint256 => MarketDataExtended) internal marketDataExtended;\r\n    mapping(address => UserData) internal userData;\r\n\r\n    mapping(uint =>mapping(uint=>PredictionData)) internal marketOptionsAvailable;\r\n    mapping(uint256 => uint256) internal disputeProposalId;\r\n\r\n    /**\r\n    * @dev Add new market currency.\r\n    * @param _currencyName name of the currency\r\n    * @param _marketFeed Price Feed address of the currency\r\n    * @param decimals Decimals of the price provided by feed address\r\n    * @param roundOfToNearest Round of the price to nearest number\r\n    * @param _marketStartTime Start time of initial markets\r\n    */\r\n    function addMarketCurrency(bytes32 _currencyName, address _marketFeed, uint8 decimals, uint8 roundOfToNearest, uint32 _marketStartTime) external onlyAuthorizedToGovern {\r\n      require((marketCurrencies[marketCurrency[_currencyName]].currencyName != _currencyName));\r\n      require(decimals != 0);\r\n      require(roundOfToNearest != 0);\r\n      require(_marketFeed != address(0));\r\n      _addMarketCurrency(_currencyName, _marketFeed, decimals, roundOfToNearest, _marketStartTime);\r\n    }\r\n\r\n    function _addMarketCurrency(bytes32 _currencyName, address _marketFeed, uint8 decimals, uint8 roundOfToNearest, uint32 _marketStartTime) internal {\r\n      uint32 index = uint32(marketCurrencies.length);\r\n      marketCurrency[_currencyName] = index;\r\n      marketCurrencies.push(MarketCurrency(_currencyName, _marketFeed, decimals, roundOfToNearest));\r\n      emit MarketCurrencies(index, _marketFeed, _currencyName, true);      \r\n      for(uint32 i = 0;i < marketTypeArray.length; i++) {\r\n          marketCreationData[i][index].initialStartTime = _marketStartTime;\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Add new market type.\r\n    * @param _predictionTime The time duration of market.\r\n    * @param _optionRangePerc Option range percent of neutral min, max options (raised by 2 decimals)\r\n    */\r\n    function addMarketType(uint32 _predictionTime, uint32 _optionRangePerc, uint32 _marketStartTime) external onlyAuthorizedToGovern {\r\n      require(marketTypeArray[marketType[_predictionTime]].predictionTime != _predictionTime);\r\n      require(_predictionTime > 0);\r\n      require(_optionRangePerc > 0);\r\n      uint32 index = uint32(marketTypeArray.length);\r\n      _addMarketType(_predictionTime, _optionRangePerc);\r\n      for(uint32 i = 0;i < marketCurrencies.length; i++) {\r\n          marketCreationData[index][i].initialStartTime = _marketStartTime;\r\n      }\r\n    }\r\n\r\n    function _addMarketType(uint32 _predictionTime, uint32 _optionRangePerc) internal {\r\n      uint32 index = uint32(marketTypeArray.length);\r\n      marketType[_predictionTime] = index;\r\n      marketTypeArray.push(MarketTypeData(_predictionTime, _optionRangePerc, false));\r\n      emit MarketTypes(index, _predictionTime, _optionRangePerc, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the master address and update it's instance\r\n     */\r\n    function setMasterAddress() public {\r\n      OwnedUpgradeabilityProxy proxy =  OwnedUpgradeabilityProxy(address(uint160(address(this))));\r\n      require(msg.sender == proxy.proxyOwner());\r\n      IMaster ms = IMaster(msg.sender);\r\n      masterAddress = msg.sender;\r\n      plotToken = ms.dAppToken();\r\n      governance = IGovernance(ms.getLatestAddress(\"GV\"));\r\n      tokenController = ITokenController(ms.getLatestAddress(\"TC\"));\r\n    }\r\n\r\n    /**\r\n    * @dev Start the initial market and set initial variables.\r\n    */\r\n    function addInitialMarketTypesAndStart(address _marketCreationRewards,address _ethAddress, address _marketUtility, uint32 _marketStartTime, address _ethFeed, address _btcFeed) external {\r\n      require(marketTypeArray.length == 0);\r\n      \r\n      marketCreationRewards = IMarketCreationRewards(_marketCreationRewards);\r\n      \r\n      totalOptions = 3;\r\n      predictionDecimalMultiplier = 10;\r\n      defaultMaxRecords = 20;\r\n      marketUtility = IMarketUtility(_marketUtility);\r\n      ETH_ADDRESS = _ethAddress;\r\n\r\n      commissionPercGlobal.ethCommission = 10;\r\n      commissionPercGlobal.plotCommission = 5;\r\n      \r\n      _addMarketType(4 hours, 100);\r\n      _addMarketType(24 hours, 200);\r\n      _addMarketType(168 hours, 500);\r\n\r\n      _addMarketCurrency(\"ETH/USD\", _ethFeed, 8, 1, _marketStartTime);\r\n      _addMarketCurrency(\"BTC/USD\", _btcFeed, 8, 25, _marketStartTime);\r\n\r\n      marketBasicData.push(MarketBasicData(0,0,0, 0,0,0));\r\n      for(uint32 i = 0;i < marketTypeArray.length; i++) {\r\n          createMarket(0, i);\r\n          createMarket(1, i);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Create the market.\r\n    * @param _marketCurrencyIndex The index of market currency feed\r\n    * @param _marketTypeIndex The time duration of market.\r\n    */\r\n    function createMarket(uint32 _marketCurrencyIndex,uint32 _marketTypeIndex) public payable {\r\n      uint256 gasProvided = gasleft();\r\n      require(!marketCreationPaused && !marketTypeArray[_marketTypeIndex].paused);\r\n      _closePreviousMarket( _marketTypeIndex, _marketCurrencyIndex);\r\n      marketUtility.update();\r\n      uint32 _startTime = calculateStartTimeForMarket(_marketCurrencyIndex, _marketTypeIndex);\r\n      (uint64 _minValue, uint64 _maxValue) = marketUtility.calculateOptionRange(marketTypeArray[_marketTypeIndex].optionRangePerc, marketCurrencies[_marketCurrencyIndex].decimals, marketCurrencies[_marketCurrencyIndex].roundOfToNearest, marketCurrencies[_marketCurrencyIndex].marketFeed);\r\n      uint64 _marketIndex = uint64(marketBasicData.length);\r\n      marketBasicData.push(MarketBasicData(_marketTypeIndex,_marketCurrencyIndex,_startTime, marketTypeArray[_marketTypeIndex].predictionTime,_minValue,_maxValue));\r\n      marketDataExtended[_marketIndex].ethCommission = commissionPercGlobal.ethCommission;\r\n      marketDataExtended[_marketIndex].plotCommission = commissionPercGlobal.plotCommission;\r\n      (marketCreationData[_marketTypeIndex][_marketCurrencyIndex].penultimateMarket, marketCreationData[_marketTypeIndex][_marketCurrencyIndex].latestMarket) =\r\n       (marketCreationData[_marketTypeIndex][_marketCurrencyIndex].latestMarket, _marketIndex);\r\n      emit MarketQuestion(_marketIndex, marketCurrencies[_marketCurrencyIndex].currencyName, _marketTypeIndex, _startTime, marketTypeArray[_marketTypeIndex].predictionTime, _minValue, _maxValue);\r\n      marketCreationRewards.calculateMarketCreationIncentive(msg.sender, gasProvided - gasleft(), _marketIndex);\r\n    }\r\n\r\n    /**\r\n    * @dev Calculate start time for next market of provided currency and market type indexes\r\n    */\r\n    function calculateStartTimeForMarket(uint32 _marketCurrencyIndex, uint32 _marketType) public view returns(uint32 _marketStartTime) {\r\n      _marketStartTime = marketCreationData[_marketType][_marketCurrencyIndex].initialStartTime;\r\n      uint predictionTime = marketTypeArray[_marketType].predictionTime;\r\n      if(now > (predictionTime) + (_marketStartTime)) {\r\n        uint noOfMarketsCycles = ((now) - (_marketStartTime)) / (predictionTime);\r\n       _marketStartTime = uint32((noOfMarketsCycles * (predictionTime)) + (_marketStartTime));\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer the assets to specified address.\r\n    * @param _asset The asset transfer to the specific address.\r\n    * @param _recipient The address to transfer the asset of\r\n    * @param _amount The amount which is transfer.\r\n    */\r\n    function _transferAsset(address _asset, address _recipient, uint256 _amount) internal {\r\n      if(_amount > 0) { \r\n        if(_asset == ETH_ADDRESS) {\r\n          (address(uint160(_recipient))).transfer(_amount);\r\n        } else {\r\n          require(IToken(_asset).transfer(_recipient, _amount));\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to settle the previous market \r\n    */\r\n    function _closePreviousMarket(uint64 _marketTypeIndex, uint64 _marketCurrencyIndex) internal {\r\n      uint64 currentMarket = marketCreationData[_marketTypeIndex][_marketCurrencyIndex].latestMarket;\r\n      if(currentMarket != 0) {\r\n        require(marketStatus(currentMarket) >= PredictionStatus.InSettlement);\r\n        uint64 penultimateMarket = marketCreationData[_marketTypeIndex][_marketCurrencyIndex].penultimateMarket;\r\n        if(penultimateMarket > 0 && now >= marketSettleTime(penultimateMarket)) {\r\n          settleMarket(penultimateMarket);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Get market settle time\r\n    * @return the time at which the market result will be declared\r\n    */\r\n    function marketSettleTime(uint256 _marketId) public view returns(uint32) {\r\n      if(marketDataExtended[_marketId].settleTime > 0) {\r\n        return marketDataExtended[_marketId].settleTime;\r\n      }\r\n      return marketBasicData[_marketId].startTime + (marketBasicData[_marketId].predictionTime * 2);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the status of market.\r\n    * @return PredictionStatus representing the status of market.\r\n    */\r\n    function marketStatus(uint256 _marketId) public view returns(PredictionStatus){\r\n      if(marketDataExtended[_marketId].predictionStatus == PredictionStatus.Live && now >= marketExpireTime(_marketId)) {\r\n        return PredictionStatus.InSettlement;\r\n      } else if(marketDataExtended[_marketId].predictionStatus == PredictionStatus.Settled && now <= marketCoolDownTime(_marketId)) {\r\n        return PredictionStatus.Cooling;\r\n      }\r\n      return marketDataExtended[_marketId].predictionStatus;\r\n    }\r\n\r\n    /**\r\n    * @dev Get market cooldown time\r\n    * @return the time upto which user can raise the dispute after the market is settled\r\n    */\r\n    function marketCoolDownTime(uint256 _marketId) public view returns(uint256) {\r\n      return marketDataExtended[_marketId].settleTime + (marketBasicData[_marketId].predictionTime / 4);\r\n    }\r\n\r\n    /**\r\n    * @dev Updates Flag to pause creation of market.\r\n    */\r\n    function pauseMarketCreation() external onlyAuthorizedToGovern {\r\n      require(!marketCreationPaused);\r\n      marketCreationPaused = true;\r\n    }\r\n\r\n    /**\r\n    * @dev Updates Flag to resume creation of market.\r\n    */\r\n    function resumeMarketCreation() external onlyAuthorizedToGovern {\r\n      require(marketCreationPaused);\r\n      marketCreationPaused = false;\r\n    }\r\n\r\n    /**\r\n    * @dev Set the flag to pause/resume market creation of particular market type\r\n    */\r\n    function toggleMarketCreationType(uint64 _marketTypeIndex, bool _flag) external onlyAuthorizedToGovern {\r\n      require(marketTypeArray[_marketTypeIndex].paused != _flag);\r\n      marketTypeArray[_marketTypeIndex].paused = _flag;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to deposit PLOT/ETH for participation in markets\r\n    * @param _amount Amount of PLOT to deposit\r\n    * msg.value => Amount of ETH to deposit\r\n    */\r\n    function deposit(uint _amount) payable public {\r\n      require(_amount > 0 || msg.value > 0);\r\n      address _plotToken = plotToken;\r\n      if(msg.value > 0) {\r\n        userData[msg.sender].currencyUnusedBalance[ETH_ADDRESS] = userData[msg.sender].currencyUnusedBalance[ETH_ADDRESS].add(msg.value);\r\n      }\r\n      if(_amount > 0) {\r\n        IToken(_plotToken).transferFrom (msg.sender,address(this), _amount);\r\n        userData[msg.sender].currencyUnusedBalance[_plotToken] = userData[msg.sender].currencyUnusedBalance[_plotToken].add(_amount);\r\n      }\r\n      emit Deposited(msg.sender, _amount, msg.value, now);\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw maximum possible deposited and available assets\r\n    * @param _maxRecords Maximum number of records to check\r\n    */\r\n    function withdrawMax(uint _maxRecords) public {\r\n      (uint _plotLeft, uint _plotReward, uint _ethLeft, uint _ethReward) = getUserUnusedBalance(msg.sender);\r\n      _plotLeft = _plotLeft.add(_plotReward);\r\n      _ethLeft = _ethLeft.add(_ethReward);\r\n      _withdraw(_plotLeft, _ethLeft, _maxRecords, _plotLeft, _ethLeft);\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw provided amount of deposited and available assets\r\n    * @param _plot Amount of PLOT to withdraw\r\n    * @param _eth Amount of ETH to withdraw\r\n    * @param _maxRecords Maximum number of records to check\r\n    */\r\n    function withdraw(uint _plot, uint256 _eth, uint _maxRecords) public {\r\n      (uint _plotLeft, uint _plotReward, uint _ethLeft, uint _ethReward) = getUserUnusedBalance(msg.sender);\r\n      _plotLeft = _plotLeft.add(_plotReward);\r\n      _ethLeft = _ethLeft.add(_ethReward);\r\n      _withdraw(_plot, _eth, _maxRecords, _plotLeft, _ethLeft);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to withdraw deposited and available assets\r\n    * @param _plot Amount of PLOT to withdraw\r\n    * @param _eth Amount of ETH to withdraw\r\n    * @param _maxRecords Maximum number of records to check\r\n    * @param _plotLeft Amount of PLOT left unused for user\r\n    * @param _ethLeft Amount of ETH left unused for user\r\n    */\r\n    function _withdraw(uint _plot, uint256 _eth, uint _maxRecords, uint _plotLeft, uint _ethLeft) internal {\r\n      withdrawReward(_maxRecords);\r\n      address _plotToken = plotToken;\r\n      userData[msg.sender].currencyUnusedBalance[_plotToken] = _plotLeft.sub(_plot);\r\n      userData[msg.sender].currencyUnusedBalance[ETH_ADDRESS] = _ethLeft.sub(_eth);\r\n      require(_plot > 0 || _eth > 0);\r\n      _transferAsset(_plotToken, msg.sender, _plot);\r\n      _transferAsset(ETH_ADDRESS, msg.sender, _eth);\r\n      emit Withdrawn(msg.sender, _plot, _eth, now);\r\n    }\r\n\r\n    /**\r\n    * @dev Get market expire time\r\n    * @return the time upto which user can place predictions in market\r\n    */\r\n    function marketExpireTime(uint _marketId) internal view returns(uint256) {\r\n      return marketBasicData[_marketId].startTime + (marketBasicData[_marketId].predictionTime);\r\n    }\r\n\r\n    /**\r\n    * @dev Sponsor Incentive for the market\r\n    * @param _marketId Index of market to sponsor\r\n    * @param _token Address of token to sponsor\r\n    * @param _value Amount to sponsor\r\n    */\r\n    function sponsorIncentives(uint256 _marketId, address _token, uint256 _value) external {\r\n      require(IMaster(masterAddress).whitelistedSponsor(msg.sender));\r\n      require(marketStatus(_marketId) <= PredictionStatus.InSettlement);\r\n      require(marketDataExtended[_marketId].incentiveToken == address(0));\r\n      marketDataExtended[_marketId].incentiveToken = _token;\r\n      marketDataExtended[_marketId].incentiveToDistribute = _value;\r\n      marketDataExtended[_marketId].incentiveSponsoredBy = msg.sender;\r\n      IToken(_token).transferFrom(msg.sender, address(this), _value);\r\n      emit SponsoredIncentive(_marketId, _token, msg.sender, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev Deposit and Place prediction on the available options of the market.\r\n    * @param _marketId Index of the market\r\n    * @param _plotDeposit PLOT amount to deposit\r\n    * @param _asset The asset used by user during prediction whether it is plotToken address or in ether.\r\n    * @param _predictionStake The amount staked by user at the time of prediction.\r\n    * @param _prediction The option on which user placed prediction.\r\n    * _plotDeposit should be passed with 18 decimals, amount of ETH to deposit should be sent as msg.value\r\n    * _predictioStake should be passed with 8 decimals, reduced it to 8 decimals to reduce the storage space of prediction data\r\n    */\r\n    function depositAndPlacePrediction(uint _plotDeposit, uint _marketId, address _asset, uint64 _predictionStake, uint256 _prediction) external payable {\r\n      if(_asset == plotToken) {\r\n        require(msg.value == 0);\r\n      }\r\n      deposit(_plotDeposit);\r\n      placePrediction(_marketId, _asset, _predictionStake, _prediction);\r\n    }\r\n\r\n    /**\r\n    * @dev Place prediction on the available options of the market.\r\n    * @param _marketId Index of the market\r\n    * @param _asset The asset used by user during prediction whether it is plotToken address or in ether.\r\n    * @param _predictionStake The amount staked by user at the time of prediction.\r\n    * @param _prediction The option on which user placed prediction.\r\n    * _predictioStake should be passed with 8 decimals, reduced it to 8 decimals to reduce the storage space of prediction data\r\n    */\r\n    function placePrediction(uint _marketId, address _asset, uint64 _predictionStake, uint256 _prediction) public {\r\n      require(!marketCreationPaused && _prediction <= totalOptions && _prediction >0);\r\n      require(now >= marketBasicData[_marketId].startTime && now <= marketExpireTime(_marketId));\r\n      uint64 _commissionStake;\r\n      uint64 _commissionPercent;\r\n      if(_asset == ETH_ADDRESS) {\r\n        _commissionPercent = marketDataExtended[_marketId].ethCommission;\r\n      } else {\r\n        _commissionPercent = marketDataExtended[_marketId].plotCommission;\r\n      }\r\n      uint decimalMultiplier = 10**predictionDecimalMultiplier;\r\n      if(_asset == ETH_ADDRESS || _asset == plotToken) {\r\n        uint256 unusedBalance = userData[msg.sender].currencyUnusedBalance[_asset];\r\n        unusedBalance = unusedBalance.div(decimalMultiplier);\r\n        if(_predictionStake > unusedBalance)\r\n        {\r\n          withdrawReward(defaultMaxRecords);\r\n          unusedBalance = userData[msg.sender].currencyUnusedBalance[_asset];\r\n          unusedBalance = unusedBalance.div(decimalMultiplier);\r\n        }\r\n        require(_predictionStake <= unusedBalance);\r\n        _commissionStake = _calculateAmulBdivC(_commissionPercent, _predictionStake, 10000);\r\n        userData[msg.sender].currencyUnusedBalance[_asset] = (unusedBalance.sub(_predictionStake)).mul(decimalMultiplier);\r\n      } else {\r\n        require(_asset == tokenController.bLOTToken());\r\n        require(!userData[msg.sender].userMarketData[_marketId].predictedWithBlot);\r\n        userData[msg.sender].userMarketData[_marketId].predictedWithBlot = true;\r\n        tokenController.swapBLOT(msg.sender, address(this), (decimalMultiplier).mul(_predictionStake));\r\n        _asset = plotToken;\r\n        _commissionStake = _calculateAmulBdivC(_commissionPercent, _predictionStake, 10000);\r\n      }\r\n      //Storing prediction stake value in _commissionStake variable after deducting commission fee\r\n      _commissionStake = _predictionStake.sub(_commissionStake);\r\n      \r\n      uint64 predictionPoints = _calculatePredictionPointsAndMultiplier(msg.sender, _marketId, _prediction, _asset, _commissionStake);\r\n      require(predictionPoints > 0);\r\n\r\n      _storePredictionData(_marketId, _prediction, _commissionStake, _asset, predictionPoints);\r\n      emit PlacePrediction(msg.sender, _predictionStake, predictionPoints, _asset, _prediction, _marketId, _commissionPercent);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to calculate prediction points  and multiplier\r\n    */\r\n    function _calculatePredictionPointsAndMultiplier(address _user, uint256 _marketId, uint256 _prediction, address _asset, uint64 _stake) internal returns(uint64 predictionPoints){\r\n      bool isMultiplierApplied;\r\n      (predictionPoints, isMultiplierApplied) = marketUtility.calculatePredictionPoints(_user, userData[_user].userMarketData[_marketId].multiplierApplied, _stake, _asset, getTotalPredictionPoints(_marketId), marketOptionsAvailable[_marketId][_prediction].predictionPoints);\r\n      if(isMultiplierApplied) {\r\n        userData[_user].userMarketData[_marketId].multiplierApplied = true; \r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Settle the market, setting the winning option\r\n    */\r\n    function settleMarket(uint256 _marketId) public {\r\n      if(marketStatus(_marketId) == PredictionStatus.InSettlement) {\r\n        (uint256 _value, uint256 _roundId) = marketUtility.getSettlemetPrice(marketCurrencies[marketBasicData[_marketId].currency].marketFeed, marketSettleTime(_marketId));\r\n        _postResult(_value, _roundId, _marketId);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Calculate the result of market.\r\n    * @param _value The current price of market currency.\r\n    * @param _roundId Chainlink round Id\r\n    * @param _marketId Index of market\r\n    */\r\n    function _postResult(uint256 _value, uint256 _roundId, uint256 _marketId) internal {\r\n      require(now >= marketSettleTime(_marketId));\r\n      require(_value > 0);\r\n      if(marketDataExtended[_marketId].predictionStatus != PredictionStatus.InDispute) {\r\n        marketDataExtended[_marketId].settleTime = uint32(now);\r\n      } else {\r\n        delete marketDataExtended[_marketId].settleTime;\r\n      }\r\n      _setMarketStatus(_marketId, PredictionStatus.Settled);\r\n      uint32 _winningOption; \r\n      if(_value < marketBasicData[_marketId].neutralMinValue) {\r\n        _winningOption = 1;\r\n      } else if(_value > marketBasicData[_marketId].neutralMaxValue) {\r\n        _winningOption = 3;\r\n      } else {\r\n        _winningOption = 2;\r\n      }\r\n      marketDataExtended[_marketId].WinningOption = _winningOption;\r\n      uint64[] memory marketCreatorIncentive = new uint64[](2);\r\n      (uint64[] memory totalReward, uint64 tokenParticipation, uint64 ethParticipation, uint64 plotCommission, uint64 ethCommission) = _calculateRewardTally(_marketId, _winningOption);\r\n      (uint64 _rewardPoolShare, bool _thresholdReached) = marketCreationRewards.getMarketCreatorRPoolShareParams(_marketId, tokenParticipation, ethParticipation);\r\n      if(_thresholdReached) {\r\n        if(\r\n          marketOptionsAvailable[_marketId][_winningOption].predictionPoints == 0\r\n        ){\r\n          marketCreatorIncentive[0] = _calculateAmulBdivC(_rewardPoolShare, tokenParticipation, 10000);\r\n          marketCreatorIncentive[1] = _calculateAmulBdivC(_rewardPoolShare, ethParticipation, 10000);\r\n          tokenParticipation = tokenParticipation.sub(marketCreatorIncentive[0]);\r\n          ethParticipation = ethParticipation.sub(marketCreatorIncentive[1]);\r\n        } else {\r\n          marketCreatorIncentive[0] = _calculateAmulBdivC(_rewardPoolShare, totalReward[0], 10000);\r\n          marketCreatorIncentive[1] = _calculateAmulBdivC(_rewardPoolShare, totalReward[1], 10000);\r\n          totalReward[0] = totalReward[0].sub(marketCreatorIncentive[0]);\r\n          totalReward[1] = totalReward[1].sub(marketCreatorIncentive[1]);\r\n          tokenParticipation = 0;\r\n          ethParticipation = 0;\r\n        }\r\n      } else {\r\n        if(\r\n          marketOptionsAvailable[_marketId][_winningOption].predictionPoints > 0\r\n        ){\r\n          tokenParticipation = 0;\r\n          ethParticipation = 0;\r\n        }\r\n      }\r\n      marketDataExtended[_marketId].rewardToDistribute = totalReward;\r\n      tokenParticipation = tokenParticipation.add(plotCommission); \r\n      ethParticipation = ethParticipation.add(ethCommission);\r\n      _transferAsset(plotToken, address(marketCreationRewards), (10**predictionDecimalMultiplier).mul(marketCreatorIncentive[0].add(tokenParticipation)));\r\n      marketCreationRewards.depositMarketRewardPoolShare.value((10**predictionDecimalMultiplier).mul(marketCreatorIncentive[1].add(ethParticipation)))(_marketId, (10**predictionDecimalMultiplier).mul(marketCreatorIncentive[1]), (10**predictionDecimalMultiplier).mul(marketCreatorIncentive[0]), ethParticipation, tokenParticipation);\r\n      emit MarketResult(_marketId, marketDataExtended[_marketId].rewardToDistribute, _winningOption, _value, _roundId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to calculate the reward.\r\n    * @param _marketId Index of market\r\n    * @param _winningOption WinningOption of market\r\n    */\r\n    function _calculateRewardTally(uint256 _marketId, uint256 _winningOption) internal view returns(uint64[] memory totalReward, uint64 tokenParticipation, uint64 ethParticipation, uint64 plotCommission, uint64 ethCommission){\r\n      totalReward = new uint64[](2);\r\n      for(uint i=1;i <= totalOptions;i++){\r\n        uint64 _plotStakedOnOption = marketOptionsAvailable[_marketId][i].plotStaked;\r\n        uint64 _ethStakedOnOption = marketOptionsAvailable[_marketId][i].ethStaked;\r\n        tokenParticipation = tokenParticipation.add(_plotStakedOnOption);\r\n        ethParticipation = ethParticipation.add(_ethStakedOnOption);\r\n        if(i != _winningOption) {\r\n          totalReward[0] = totalReward[0].add(_plotStakedOnOption);\r\n          totalReward[1] = totalReward[1].add(_ethStakedOnOption);\r\n        }\r\n      }\r\n\r\n      /* Steps followed to calculate commission amount\r\n      * We were storing users particpation amount post dedcuting commission amount, in userParticipationAmount\r\n      * userParticipationAmount = Actual amount passed by user - commissionAmount\r\n      * actualAmountUserPassed = (100 * userParticipationAmount)/(100-commissionPercent)\r\n      * commissionAmount = actualAmountUserPassed - userParticipationAmount\r\n      */\r\n      plotCommission = _calculateAmulBdivC(10000, tokenParticipation, 10000 - marketDataExtended[_marketId].plotCommission) - tokenParticipation;\r\n      ethCommission = _calculateAmulBdivC(10000, ethParticipation, 10000 - marketDataExtended[_marketId].ethCommission) - ethParticipation;\r\n    }\r\n\r\n    /**\r\n    * @dev Claim the pending return of the market.\r\n    * @param maxRecords Maximum number of records to claim reward for\r\n    */\r\n    function withdrawReward(uint256 maxRecords) public {\r\n      uint256 i;\r\n      uint len = userData[msg.sender].marketsParticipated.length;\r\n      uint lastClaimed = len;\r\n      uint count;\r\n      uint ethReward = 0;\r\n      uint plotReward =0 ;\r\n      require(!marketCreationPaused);\r\n      for(i = userData[msg.sender].lastClaimedIndex; i < len && count < maxRecords; i++) {\r\n        (uint claimed, uint tempPlotReward, uint tempEthReward) = claimReturn(msg.sender, userData[msg.sender].marketsParticipated[i]);\r\n        if(claimed > 0) {\r\n          delete userData[msg.sender].marketsParticipated[i];\r\n          ethReward = ethReward.add(tempEthReward);\r\n          plotReward = plotReward.add(tempPlotReward);\r\n          count++;\r\n        } else {\r\n          if(lastClaimed == len) {\r\n            lastClaimed = i;\r\n          }\r\n        }\r\n      }\r\n      if(lastClaimed == len) {\r\n        lastClaimed = i;\r\n      }\r\n      emit ReturnClaimed(msg.sender, plotReward, ethReward);\r\n      userData[msg.sender].currencyUnusedBalance[plotToken] = userData[msg.sender].currencyUnusedBalance[plotToken].add(plotReward.mul(10**predictionDecimalMultiplier));\r\n      userData[msg.sender].currencyUnusedBalance[ETH_ADDRESS] = userData[msg.sender].currencyUnusedBalance[ETH_ADDRESS].add(ethReward.mul(10**predictionDecimalMultiplier));\r\n      userData[msg.sender].lastClaimedIndex = uint128(lastClaimed);\r\n    }\r\n\r\n    /**\r\n    * @dev FUnction to return users unused deposited balance including the return earned in markets\r\n    * @param _user Address of user\r\n    * return PLOT Unused in deposit\r\n    * return PLOT Return from market\r\n    * return ETH Unused in deposit\r\n    * return ETH Return from market\r\n    */\r\n    function getUserUnusedBalance(address _user) public view returns(uint256, uint256, uint256, uint256){\r\n      uint ethReward;\r\n      uint plotReward;\r\n      uint decimalMultiplier = 10**predictionDecimalMultiplier;\r\n      uint len = userData[_user].marketsParticipated.length;\r\n      uint[] memory _returnAmount = new uint256[](2);\r\n      for(uint i = userData[_user].lastClaimedIndex; i < len; i++) {\r\n        (_returnAmount, , ) = getReturn(_user, userData[_user].marketsParticipated[i]);\r\n        ethReward = ethReward.add(_returnAmount[1]);\r\n        plotReward = plotReward.add(_returnAmount[0]);\r\n      }\r\n      return (userData[_user].currencyUnusedBalance[plotToken], plotReward.mul(decimalMultiplier), userData[_user].currencyUnusedBalance[ETH_ADDRESS], ethReward.mul(decimalMultiplier));\r\n    }\r\n\r\n    /**\r\n    * @dev Gets number of positions user got in prediction\r\n    * @param _user Address of user\r\n    * @param _marketId Index of market\r\n    * @param _option Option Id\r\n    * return Number of positions user got in prediction\r\n    */\r\n    function getUserPredictionPoints(address _user, uint256 _marketId, uint256 _option) external view returns(uint64) {\r\n      return userData[_user].userMarketData[_marketId].predictionData[_option].predictionPoints;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the market data.\r\n    * @return _marketCurrency returns the currency name of the market.\r\n    * @return neutralMinValue Neutral min value deciding the option ranges of market\r\n    * @return neutralMaxValue Neutral max value deciding the option ranges of market\r\n    * @return _optionPrice uint[] memory representing the option price of each option ranges of the market.\r\n    * @return _ethStaked uint[] memory representing the ether staked on each option ranges of the market.\r\n    * @return _plotStaked uint[] memory representing the plot staked on each option ranges of the market.\r\n    * @return _predictionTime uint representing the type of market.\r\n    * @return _expireTime uint representing the time at which market closes for prediction\r\n    * @return _predictionStatus uint representing the status of the market.\r\n    */\r\n    function getMarketData(uint256 _marketId) external view returns\r\n       (bytes32 _marketCurrency,uint neutralMinValue,uint neutralMaxValue,\r\n        uint[] memory _optionPrice, uint[] memory _ethStaked, uint[] memory _plotStaked,uint _predictionTime,uint _expireTime, PredictionStatus _predictionStatus){\r\n        _marketCurrency = marketCurrencies[marketBasicData[_marketId].currency].currencyName;\r\n        _predictionTime = marketBasicData[_marketId].predictionTime;\r\n        _expireTime =marketExpireTime(_marketId);\r\n        _predictionStatus = marketStatus(_marketId);\r\n        neutralMinValue = marketBasicData[_marketId].neutralMinValue;\r\n        neutralMaxValue = marketBasicData[_marketId].neutralMaxValue;\r\n        \r\n        _optionPrice = new uint[](totalOptions);\r\n        _ethStaked = new uint[](totalOptions);\r\n        _plotStaked = new uint[](totalOptions);\r\n        uint64 totalPredictionPoints = getTotalPredictionPoints(_marketId);\r\n        for (uint i = 0; i < totalOptions; i++) {\r\n          _ethStaked[i] = marketOptionsAvailable[_marketId][i+1].ethStaked;\r\n          _plotStaked[i] = marketOptionsAvailable[_marketId][i+1].plotStaked;\r\n          uint64 predictionPointsOnOption = marketOptionsAvailable[_marketId][i+1].predictionPoints;\r\n          _optionPrice[i] = marketUtility.getOptionPrice(totalPredictionPoints, predictionPointsOnOption);\r\n       }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the incentive sponsorer of market to claim back his incentives incase of zero participation in market\r\n    * @param _marketId Index of market\r\n    */\r\n    function withdrawSponsoredIncentives(uint256 _marketId) external {\r\n      require(marketStatus(_marketId) == PredictionStatus.Settled);\r\n      require(getTotalPredictionPoints(_marketId) == 0);\r\n      _transferAsset(marketDataExtended[_marketId].incentiveToken, marketDataExtended[_marketId].incentiveSponsoredBy, marketDataExtended[_marketId].incentiveToDistribute);\r\n    }\r\n\r\n    /**\r\n    * @dev Claim the return amount of the specified address.\r\n    * @param _user User address\r\n    * @param _marketId Index of market\r\n    * @return Flag, if 0:cannot claim, 1: Already Claimed, 2: Claimed; Return in PLOT; Return in ETH\r\n    */\r\n    function claimReturn(address payable _user, uint _marketId) internal returns(uint256, uint256, uint256) {\r\n\r\n      if(marketStatus(_marketId) != PredictionStatus.Settled) {\r\n        return (0, 0 ,0);\r\n      }\r\n      if(userData[_user].userMarketData[_marketId].claimedReward) {\r\n        return (1, 0, 0);\r\n      }\r\n      userData[_user].userMarketData[_marketId].claimedReward = true;\r\n      uint[] memory _returnAmount = new uint256[](2);\r\n      (_returnAmount, , ) = getReturn(_user, _marketId);\r\n      return (2, _returnAmount[0], _returnAmount[1]);\r\n    }\r\n\r\n    /** \r\n    * @dev Allows users to claim sponsored incentives of market\r\n    * @param _user User address\r\n    * @param _markets Indexes of markets which user want to claim incentive for\r\n    * @param _incentiveToken Incentive token to check rewards for\r\n    * User will pass a list of market id's to check for incentive of given token address,\r\n    * Incentive will be transferred to user if user had any and the incentive token of market is same as the one user had passed\r\n    */\r\n    function claimIncentives(address payable _user, uint64[] calldata _markets, address _incentiveToken) external {\r\n      uint totalIncentive;\r\n      uint _index;\r\n      uint[] memory _marketsClaimed = new uint[](_markets.length);\r\n      for(uint64 i = 0; i < _markets.length; i++) {\r\n        ( , uint incentive, address incentiveToken) = getReturn(_user, _markets[i]);\r\n        if(incentive > 0 && incentiveToken == _incentiveToken && !userData[_user].userMarketData[_markets[i]].incentiveClaimed) {\r\n          userData[_user].userMarketData[_markets[i]].incentiveClaimed = true;\r\n          totalIncentive = totalIncentive.add(incentive);\r\n          _marketsClaimed[_index] = i;\r\n          _index++;\r\n        }\r\n\r\n      }\r\n      require(totalIncentive > 0);\r\n      _transferAsset(_incentiveToken, _user, totalIncentive);\r\n      emit ClaimedIncentive(_user, _marketsClaimed, _incentiveToken, totalIncentive);\r\n    }\r\n\r\n    /** \r\n    * @dev Gets the return amount of the specified address.\r\n    * @param _user The address to specify the return of\r\n    * @param _marketId Index of market\r\n    * @return returnAmount uint[] memory representing the return amount.\r\n    * @return incentive uint[] memory representing the amount incentive.\r\n    * @return _incentiveTokens address[] memory representing the incentive tokens.\r\n    */\r\n    function getReturn(address _user, uint _marketId) public view returns (uint[] memory returnAmount, uint incentive, address _incentiveToken){\r\n      uint256 _totalUserPredictionPoints = 0;\r\n      uint256 _totalPredictionPoints = 0;\r\n      returnAmount = new uint256[](2);\r\n      (_totalUserPredictionPoints, _totalPredictionPoints) = _calculatePredictionPoints(_user, _marketId);\r\n      if(marketStatus(_marketId) != PredictionStatus.Settled || _totalPredictionPoints == 0) {\r\n       return (returnAmount, incentive, marketDataExtended[_marketId].incentiveToken);\r\n      }\r\n      uint256 _winningOption = marketDataExtended[_marketId].WinningOption;\r\n      returnAmount = new uint256[](2);\r\n      returnAmount[0] = userData[_user].userMarketData[_marketId].predictionData[_winningOption].plotStaked;\r\n      returnAmount[1] = userData[_user].userMarketData[_marketId].predictionData[_winningOption].ethStaked;\r\n      uint256 userPredictionPointsOnWinngOption = userData[_user].userMarketData[_marketId].predictionData[_winningOption].predictionPoints;\r\n      if(userPredictionPointsOnWinngOption > 0) {\r\n        returnAmount = _addUserReward(_marketId, returnAmount, _winningOption, userPredictionPointsOnWinngOption);\r\n      }\r\n      if(marketDataExtended[_marketId].incentiveToDistribute > 0) {\r\n        incentive = _totalUserPredictionPoints.mul((marketDataExtended[_marketId].incentiveToDistribute).div(_totalPredictionPoints));\r\n      }\r\n      return (returnAmount, incentive, marketDataExtended[_marketId].incentiveToken);\r\n    }\r\n\r\n    /**\r\n    * @dev Adds the reward in the total return of the specified address.\r\n    * @param returnAmount The return amount.\r\n    * @return uint[] memory representing the return amount after adding reward.\r\n    */\r\n    function _addUserReward(uint256 _marketId, uint[] memory returnAmount, uint256 _winningOption, uint256 _userPredictionPointsOnWinngOption) internal view returns(uint[] memory){\r\n      for(uint j = 0; j< returnAmount.length; j++) {\r\n        returnAmount[j] = returnAmount[j].add(\r\n            _userPredictionPointsOnWinngOption.mul(marketDataExtended[_marketId].rewardToDistribute[j]).div(marketOptionsAvailable[_marketId][_winningOption].predictionPoints)\r\n          );\r\n      }\r\n      return returnAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculate the return of the specified address.\r\n    * @param _user The address to query the return of.\r\n    * @return _totalUserPredictionPoints uint representing the positions owned by the passed address.\r\n    * @return _totalPredictionPoints uint representing the total positions of winners.\r\n    */\r\n    function _calculatePredictionPoints(address _user, uint _marketId) internal view returns(uint _totalUserPredictionPoints, uint _totalPredictionPoints){\r\n      for(uint  i=1;i<=totalOptions;i++){\r\n        _totalUserPredictionPoints = _totalUserPredictionPoints.add(userData[_user].userMarketData[_marketId].predictionData[i].predictionPoints);\r\n        _totalPredictionPoints = _totalPredictionPoints.add(marketOptionsAvailable[_marketId][i].predictionPoints);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Basic function to perform mathematical operation of (`_a` * `_b` / `_c`)\r\n    * @param _a value of variable a\r\n    * @param _b value of variable b\r\n    * @param _c value of variable c\r\n    */\r\n    function _calculateAmulBdivC(uint64 _a, uint64 _b, uint64 _c) internal pure returns(uint64) {\r\n      return _a.mul(_b).div(_c);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns total assets staked in market by users\r\n    * @param _marketId Index of market\r\n    * @return ethStaked Total eth staked on market\r\n    * @return plotStaked Total PLOT staked on market\r\n    */\r\n    function getTotalAssetsStaked(uint _marketId) public view returns(uint256 ethStaked, uint256 plotStaked) {\r\n      for(uint256 i = 1; i<= totalOptions;i++) {\r\n        ethStaked = ethStaked.add(marketOptionsAvailable[_marketId][i].ethStaked);\r\n        plotStaked = plotStaked.add(marketOptionsAvailable[_marketId][i].plotStaked);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Returns total prediction points allocated to users\r\n    * @param _marketId Index of market\r\n    * @return predictionPoints total prediction points allocated to users\r\n    */\r\n    function getTotalPredictionPoints(uint _marketId) public view returns(uint64 predictionPoints) {\r\n      for(uint256 i = 1; i<= totalOptions;i++) {\r\n        predictionPoints = predictionPoints.add(marketOptionsAvailable[_marketId][i].predictionPoints);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Stores the prediction data.\r\n    * @param _prediction The option on which user place prediction.\r\n    * @param _predictionStake The amount staked by user at the time of prediction.\r\n    * @param _asset The asset used by user during prediction.\r\n    * @param predictionPoints The positions user got during prediction.\r\n    */\r\n    function _storePredictionData(uint _marketId, uint _prediction, uint64 _predictionStake, address _asset, uint64 predictionPoints) internal {\r\n      if(!_hasUserParticipated(_marketId, msg.sender)) {\r\n        userData[msg.sender].marketsParticipated.push(_marketId);\r\n      }\r\n      userData[msg.sender].userMarketData[_marketId].predictionData[_prediction].predictionPoints = userData[msg.sender].userMarketData[_marketId].predictionData[_prediction].predictionPoints.add(predictionPoints);\r\n      marketOptionsAvailable[_marketId][_prediction].predictionPoints = marketOptionsAvailable[_marketId][_prediction].predictionPoints.add(predictionPoints);\r\n      if(_asset == ETH_ADDRESS) {\r\n        userData[msg.sender].userMarketData[_marketId].predictionData[_prediction].ethStaked = userData[msg.sender].userMarketData[_marketId].predictionData[_prediction].ethStaked.add(_predictionStake);\r\n        marketOptionsAvailable[_marketId][_prediction].ethStaked = marketOptionsAvailable[_marketId][_prediction].ethStaked.add(_predictionStake);\r\n        userData[msg.sender].totalEthStaked = userData[msg.sender].totalEthStaked.add(_predictionStake);\r\n      } else {\r\n        userData[msg.sender].userMarketData[_marketId].predictionData[_prediction].plotStaked = userData[msg.sender].userMarketData[_marketId].predictionData[_prediction].plotStaked.add(_predictionStake);\r\n        marketOptionsAvailable[_marketId][_prediction].plotStaked = marketOptionsAvailable[_marketId][_prediction].plotStaked.add(_predictionStake);\r\n        userData[msg.sender].totalPlotStaked = userData[msg.sender].totalPlotStaked.add(_predictionStake);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check if user had participated in given market\r\n    * @param _marketId Index of market\r\n    * @param _user Address of user\r\n    */\r\n    function _hasUserParticipated(uint256 _marketId, address _user) internal view returns(bool _hasParticipated) {\r\n      for(uint i = 1;i <= totalOptions; i++) {\r\n        if(userData[_user].userMarketData[_marketId].predictionData[i].predictionPoints > 0) {\r\n          _hasParticipated = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Raise the dispute if wrong value passed at the time of market result declaration.\r\n    * @param _proposedValue The proposed value of market currency.\r\n    * @param proposalTitle The title of proposal created by user.\r\n    * @param description The description of dispute.\r\n    * @param solutionHash The ipfs solution hash.\r\n    */\r\n    function raiseDispute(uint256 _marketId, uint256 _proposedValue, string memory proposalTitle, string memory description, string memory solutionHash) public {\r\n      require(getTotalPredictionPoints(_marketId) > 0);\r\n      require(marketStatus(_marketId) == PredictionStatus.Cooling);\r\n      uint _stakeForDispute =  marketUtility.getDisputeResolutionParams();\r\n      IToken(plotToken).transferFrom(msg.sender, address(this), _stakeForDispute);\r\n      // marketRegistry.createGovernanceProposal(proposalTitle, description, solutionHash, abi.encode(address(this), proposedValue), _stakeForDispute, msg.sender, ethAmountToPool, tokenAmountToPool, proposedValue);\r\n      uint proposalId = governance.getProposalLength();\r\n      // marketBasicData[msg.sender].disputeStakes = DisputeStake(proposalId, _user, _stakeForDispute, _ethSentToPool, _tokenSentToPool);\r\n      marketDataExtended[_marketId].disputeRaisedBy = msg.sender;\r\n      marketDataExtended[_marketId].disputeStakeAmount = uint64(_stakeForDispute.div(10**predictionDecimalMultiplier));\r\n      disputeProposalId[proposalId] = _marketId;\r\n      governance.createProposalwithSolution(proposalTitle, proposalTitle, description, 10, solutionHash, abi.encode(_marketId, _proposedValue));\r\n      emit DisputeRaised(_marketId, msg.sender, proposalId, _proposedValue);\r\n      _setMarketStatus(_marketId, PredictionStatus.InDispute);\r\n    }\r\n\r\n    /**\r\n    * @dev Resolve the dispute if wrong value passed at the time of market result declaration.\r\n    * @param _marketId Index of market.\r\n    * @param _result The final proposed result of the market.\r\n    */\r\n    function resolveDispute(uint256 _marketId, uint256 _result) external onlyAuthorizedToGovern {\r\n      // delete marketCreationRewardData[_marketId].plotIncentive;\r\n      // delete marketCreationRewardData[_marketId].ethIncentive;\r\n      _resolveDispute(_marketId, true, _result);\r\n      emit DisputeResolved(_marketId, true);\r\n      _transferAsset(plotToken, marketDataExtended[_marketId].disputeRaisedBy, (10**predictionDecimalMultiplier).mul(marketDataExtended[_marketId].disputeStakeAmount));\r\n    }\r\n\r\n    /**\r\n    * @dev Resolve the dispute\r\n    * @param _marketId Index of market.\r\n    * @param accepted Flag mentioning if dispute is accepted or not\r\n    * @param finalResult The final correct value of market currency.\r\n    */\r\n    function _resolveDispute(uint256 _marketId, bool accepted, uint256 finalResult) internal {\r\n      require(marketStatus(_marketId) == PredictionStatus.InDispute);\r\n      if(accepted) {\r\n        marketCreationRewards.returnMarketRewardPoolShare(_marketId);\r\n        _postResult(finalResult, 0, _marketId);\r\n      }\r\n      _setMarketStatus(_marketId, PredictionStatus.Settled);\r\n    }\r\n\r\n    /**\r\n    * @dev Burns the tokens of member who raised the dispute, if dispute is rejected.\r\n    * @param _proposalId Id of dispute resolution proposal\r\n    */\r\n    function burnDisputedProposalTokens(uint _proposalId) external onlyAuthorizedToGovern {\r\n      uint256 _marketId = disputeProposalId[_proposalId];\r\n      _resolveDispute(_marketId, false, 0);\r\n      emit DisputeResolved(_marketId, false);\r\n      IToken(plotToken).burn((10**predictionDecimalMultiplier).mul(marketDataExtended[_marketId].disputeStakeAmount));\r\n    }\r\n\r\n    /**\r\n    * @dev function to update integer parameters\r\n    */\r\n    function updateUintParameters(bytes8 code, uint256 value) external onlyAuthorizedToGovern {\r\n      if(code == \"ETHC\") { // Commission percent for ETH based predictions(Raised be two decimals)\r\n        commissionPercGlobal.ethCommission = uint64(value);\r\n      } else if(code == \"TKNC\") { // Commission percent for PLOT based predictions(Raised be two decimals)\r\n        commissionPercGlobal.plotCommission = uint64(value);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Get flags set for user\r\n    * @param _marketId Index of market.\r\n    * @param _user User address\r\n    * @return Flag defining if user had predicted with bPLOT\r\n    * @return Flag defining if user had availed multiplier\r\n    */\r\n    function getUserFlags(uint256 _marketId, address _user) external view returns(bool, bool) {\r\n      return (\r\n              userData[_user].userMarketData[_marketId].predictedWithBlot,\r\n              userData[_user].userMarketData[_marketId].multiplierApplied\r\n      );\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the result of the market.\r\n    * @param _marketId Index of market.\r\n    * @return uint256 representing the winning option of the market.\r\n    * @return uint256 Value of market currently at the time closing market.\r\n    * @return uint256 representing the positions of the winning option.\r\n    * @return uint[] memory representing the reward to be distributed.\r\n    * @return uint256 representing the Eth staked on winning option.\r\n    * @return uint256 representing the PLOT staked on winning option.\r\n    */\r\n    function getMarketResults(uint256 _marketId) external view returns(uint256 _winningOption, uint256, uint256[] memory, uint256, uint256) {\r\n      _winningOption = marketDataExtended[_marketId].WinningOption;\r\n      return (_winningOption, marketOptionsAvailable[_marketId][_winningOption].predictionPoints, marketDataExtended[_marketId].rewardToDistribute, marketOptionsAvailable[_marketId][_winningOption].ethStaked, marketOptionsAvailable[_marketId][_winningOption].plotStaked);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns total assets value in PLOT staked on market\r\n    * @param _marketId Index of market\r\n    * @return plotStaked Total staked value in PLOT on market\r\n    */\r\n    function getTotalStakedValueInPLOT(uint256 _marketId) public view returns(uint256) {\r\n      (uint256 ethStaked, uint256 plotStaked) = getTotalAssetsStaked(_marketId);\r\n      (, ethStaked) = marketUtility.getValueAndMultiplierParameters(ETH_ADDRESS, ethStaked);\r\n      return plotStaked.add(ethStaked);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function set market status\r\n    * @param _marketId Index of market\r\n    * @param _status Status of market to set\r\n    */    \r\n    function _setMarketStatus(uint256 _marketId, PredictionStatus _status) internal {\r\n      marketDataExtended[_marketId].predictionStatus = _status;\r\n    }\r\n\r\n    /**\r\n    * @dev Payable Fallback function to receive funds\r\n    */\r\n    function () external payable {\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/AllMarketsV2.sol\r\n\r\n/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract AllMarketsV2 is AllMarkets {\r\n\r\n\t\t/**\r\n     * @dev Changes the master address and update it's instance\r\n     */\r\n    function setMasterAddress() public {\r\n    }\r\n\r\n    /**\r\n    * @dev Start the initial market and set initial variables.\r\n    */\r\n    function addInitialMarketTypesAndStart(address _marketCreationRewards,address _ethAddress, address _marketUtility, uint32 _marketStartTime, address _ethFeed, address _btcFeed) external {\r\n    }\r\n\r\n    /**\r\n    * @dev Create the market.\r\n    * @param _marketCurrencyIndex The index of market currency feed\r\n    * @param _marketTypeIndex The time duration of market.\r\n    */\r\n    function createMarket(uint32 _marketCurrencyIndex,uint32 _marketTypeIndex) public payable {\r\n    }\r\n\r\n    /**\r\n    * @dev Create the market and settle the prenultimate market.\r\n    * @param _marketCurrencyIndex The index of market currency feed\r\n    * @param _marketTypeIndex The time duration of market.\r\n    * @param _roundId The chainlink round id of the penultimate market, with the round updated time closest to market settlement time\r\n    */\r\n    function createMarketAndSettle(uint32 _marketCurrencyIndex,uint32 _marketTypeIndex, uint80 _roundId) public {\r\n    \tuint256 gasProvided = gasleft();\r\n      require(!marketCreationPaused && !marketTypeArray[_marketTypeIndex].paused);\r\n      _closePreviousMarketWithRoundId( _marketTypeIndex, _marketCurrencyIndex, _roundId);\r\n      marketUtility.update();\r\n      uint32 _startTime = calculateStartTimeForMarket(_marketCurrencyIndex, _marketTypeIndex);\r\n      (uint64 _minValue, uint64 _maxValue) = marketUtility.calculateOptionRange(marketTypeArray[_marketTypeIndex].optionRangePerc, marketCurrencies[_marketCurrencyIndex].decimals, marketCurrencies[_marketCurrencyIndex].roundOfToNearest, marketCurrencies[_marketCurrencyIndex].marketFeed);\r\n      uint64 _marketIndex = uint64(marketBasicData.length);\r\n      marketBasicData.push(MarketBasicData(_marketTypeIndex,_marketCurrencyIndex,_startTime, marketTypeArray[_marketTypeIndex].predictionTime,_minValue,_maxValue));\r\n      marketDataExtended[_marketIndex].ethCommission = commissionPercGlobal.ethCommission;\r\n      marketDataExtended[_marketIndex].plotCommission = commissionPercGlobal.plotCommission;\r\n      (marketCreationData[_marketTypeIndex][_marketCurrencyIndex].penultimateMarket, marketCreationData[_marketTypeIndex][_marketCurrencyIndex].latestMarket) =\r\n       (marketCreationData[_marketTypeIndex][_marketCurrencyIndex].latestMarket, _marketIndex);\r\n      emit MarketQuestion(_marketIndex, marketCurrencies[_marketCurrencyIndex].currencyName, _marketTypeIndex, _startTime, marketTypeArray[_marketTypeIndex].predictionTime, _minValue, _maxValue);\r\n      marketCreationRewards.calculateMarketCreationIncentive(msg.sender, gasProvided - gasleft(), _marketIndex);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to settle the previous market \r\n    */\r\n    function _closePreviousMarket(uint64 _marketTypeIndex, uint64 _marketCurrencyIndex) internal {\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to settle the previous market \r\n    */\r\n    function _closePreviousMarketWithRoundId(uint64 _marketTypeIndex, uint64 _marketCurrencyIndex, uint80 _roundId) internal {\r\n    \tuint64 currentMarket = marketCreationData[_marketTypeIndex][_marketCurrencyIndex].latestMarket;\r\n      if(currentMarket != 0) {\r\n        require(marketStatus(currentMarket) >= PredictionStatus.InSettlement);\r\n        uint64 penultimateMarket = marketCreationData[_marketTypeIndex][_marketCurrencyIndex].penultimateMarket;\r\n        if(penultimateMarket > 0 && now >= marketSettleTime(penultimateMarket)) {\r\n          settleMarketByRoundId(penultimateMarket, _roundId);\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Settle the market, setting the winning option\r\n    */\r\n    function settleMarket(uint256 _marketId) public {\r\n    }\r\n\r\n    /**\r\n    * @dev Settle the market, setting the winning option\r\n    * @param _marketId Index of market.\r\n    * @param _roundId Index of the nearest price feed round from which the price to be taken from.\r\n    */\r\n    function settleMarketByRoundId(uint256 _marketId, uint80 _roundId) public {\r\n      if(marketStatus(_marketId) == PredictionStatus.InSettlement) {\r\n        require(_roundId > 0);\r\n        (uint256 _value, uint256 _roundIdUsed) = marketUtility.getSettlemetPriceByRoundId(marketCurrencies[marketBasicData[_marketId].currency].marketFeed, marketSettleTime(_marketId), _roundId);\r\n        _postResult(_value, _roundIdUsed, _marketId);\r\n      }\r\n    }\r\n}"
    }
  }
}