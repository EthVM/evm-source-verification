{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "EnterpriseWallet721Auction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n\n// \n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// \n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transfered from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\n/**\n * @title IERC721 Non-Fungible Token Creator basic interface\n */\ninterface IERC721Creator {\n    /**\n     * @dev Gets the creator of the token\n     * @param _tokenId uint256 ID of the token\n     * @return address of the creator\n     */\n    function tokenCreator(uint256 _tokenId) external view returns (address);\n}\n\n// \n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// \n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// \n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// \n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// \n/**\n  * @title Escrow\n  * @dev Base escrow contract, holds funds designated for a payee until they\n  * withdraw them.\n  *\n  * Intended usage: This contract (and derived escrow contracts) should be a\n  * standalone contract, that only interacts with the contract that instantiated\n  * it. That way, it is guaranteed that all Ether will be handled according to\n  * the `Escrow` rules, and there is no need to check for payable functions or\n  * transfers in the inheritance tree. The contract that uses the escrow as its\n  * payment method should be its owner, and provide public methods redirecting\n  * to the escrow's deposit and withdraw.\n  */\ncontract Escrow is Ownable {\n    using SafeMath for uint256;\n    using Address for address payable;\n\n    event Deposited(address indexed payee, uint256 weiAmount);\n    event Withdrawn(address indexed payee, uint256 weiAmount);\n\n    mapping(address => uint256) private _deposits;\n\n    function depositsOf(address payee) public view returns (uint256) {\n        return _deposits[payee];\n    }\n\n    /**\n     * @dev Stores the sent amount as credit to be withdrawn.\n     * @param payee The destination address of the funds.\n     */\n    function deposit(address payee) public virtual payable onlyOwner {\n        uint256 amount = msg.value;\n        _deposits[payee] = _deposits[payee].add(amount);\n\n        emit Deposited(payee, amount);\n    }\n\n    /**\n     * @dev Withdraw accumulated balance for a payee, forwarding all gas to the\n     * recipient.\n     *\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\n     * Make sure you trust the recipient, or are either following the\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\n     *\n     * @param payee The address whose funds will be withdrawn and transferred to.\n     */\n    function withdraw(address payable payee) public virtual onlyOwner {\n        uint256 payment = _deposits[payee];\n\n        _deposits[payee] = 0;\n\n        payee.sendValue(payment);\n\n        emit Withdrawn(payee, payment);\n    }\n}\n\n// \n/**\n * @dev Simple implementation of a\n * https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls[pull-payment]\n * strategy, where the paying contract doesn't interact directly with the\n * receiver account, which must withdraw its payments itself.\n *\n * Pull-payments are often considered the best practice when it comes to sending\n * Ether, security-wise. It prevents recipients from blocking execution, and\n * eliminates reentrancy concerns.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * To use, derive from the `PullPayment` contract, and use {_asyncTransfer}\n * instead of Solidity's `transfer` function. Payees can query their due\n * payments with {payments}, and retrieve them with {withdrawPayments}.\n */\ncontract PullPayment {\n    Escrow private _escrow;\n\n    constructor () internal {\n        _escrow = new Escrow();\n    }\n\n    /**\n     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.\n     *\n     * Note that _any_ account can call this function, not just the `payee`.\n     * This means that contracts unaware of the `PullPayment` protocol can still\n     * receive funds this way, by having a separate account call\n     * {withdrawPayments}.\n     *\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\n     * Make sure you trust the recipient, or are either following the\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\n     *\n     * @param payee Whose payments will be withdrawn.\n     */\n    function withdrawPayments(address payable payee) public virtual {\n        _escrow.withdraw(payee);\n    }\n\n    /**\n     * @dev Returns the payments owed to an address.\n     * @param dest The creditor's address.\n     */\n    function payments(address dest) public view returns (uint256) {\n        return _escrow.depositsOf(dest);\n    }\n\n    /**\n     * @dev Called by the payer to store the sent amount as credit to be pulled.\n     * Funds sent in this way are stored in an intermediate {Escrow} contract, so\n     * there is no danger of them being spent before withdrawal.\n     *\n     * @param dest The destination address of the funds.\n     * @param amount The amount to transfer.\n     */\n    function _asyncTransfer(address dest, uint256 amount) internal virtual {\n        _escrow.deposit{ value: amount }(dest);\n    }\n}\n\ncontract EnterpriseWallet721Auction is Ownable {\n    using SafeMath for uint256;\n\n    /////////////////////////////////////////////////////////////////////////\n    // State Variables\n    /////////////////////////////////////////////////////////////////////////\n    // Mapping from ERC721 contract to mapping of tokenId to sale price.\n    mapping(address => mapping(uint256 => uint256)) private tokenPrices;\n\n    // Mapping from ERC721 contract to mapping of tokenId to token owner that set the sale price.\n    mapping(address => mapping(uint256 => address)) private priceSetters;\n\n    // Mapping of ERC721 contract to mapping of token ID to whether the token has been sold before.\n    mapping(address => mapping(uint256 => bool)) private tokenSolds;\n\n    // Mapping of ERC721 contract to mapping of token ID to the current bid amount.\n    mapping(address => mapping(uint256 => uint256)) private tokenCurrentBids;\n\n    // Mapping of ERC721 contract to mapping of token ID to the current bidder.\n    mapping(address => mapping(uint256 => address)) private tokenCurrentBidders;\n\n    // Marketplace fee paid to the owner of the contract.\n    uint256 private marketplaceFee = 3; // 3 %\n\n    // Royalty fee paid to the creator of a token on secondary sales.\n    uint256 private royaltyFee = 3; // 3 %\n\n    // Primary sale fee split.\n    uint256 private primarySaleFee = 15; // 15 %\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Events\n    /////////////////////////////////////////////////////////////////////////////\n    event Sold(\n        address indexed _originContract,\n        address indexed _buyer,\n        address indexed _seller,\n        uint256 _amount,\n        uint256 _tokenId\n    );\n\n    event SetSalePrice(\n        address indexed _originContract,\n        uint256 _amount,\n        uint256 _tokenId\n    );\n\n    event Bid(\n        address indexed _originContract,\n        address indexed _bidder,\n        uint256 _amount,\n        uint256 _tokenId\n    );\n\n    event AcceptBid(\n        address indexed _originContract,\n        address indexed _bidder,\n        address indexed _seller,\n        uint256 _amount,\n        uint256 _tokenId\n    );\n\n    /////////////////////////////////////////////////////////////////////////\n    // Modifiers\n    /////////////////////////////////////////////////////////////////////////\n    /**\n   * @dev Checks that the token owner is approved for the ERC721Market\n   * @param _originContract address of the contract storing the token.\n   * @param _tokenId uint256 ID of the token\n   */\n    modifier ownerMustHaveMarketplaceApproved(\n        address _originContract,\n        uint256 _tokenId\n    ) {\n        IERC721 erc721 = IERC721(_originContract);\n        address owner = erc721.ownerOf(_tokenId);\n        require(\n            erc721.isApprovedForAll(owner, address(this)),\n            \"owner must have approved contract\"\n        );\n        _;\n    }\n\n    /**\n   * @dev Checks that the token is owned by the sender\n   * @param _originContract address of the contract storing the token.\n   * @param _tokenId uint256 ID of the token\n   */\n    modifier senderMustBeTokenOwner(address _originContract, uint256 _tokenId) {\n        IERC721 erc721 = IERC721(_originContract);\n        require(\n            erc721.ownerOf(_tokenId) == msg.sender,\n            \"sender must be the token owner\"\n        );\n        _;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // setSalePrice\n    /////////////////////////////////////////////////////////////////////////\n    /**\n   * @dev Set the token for sale\n   * @param _originContract address of the contract storing the token.\n   * @param _tokenId uint256 ID of the token\n   * @param _amount uint256 wei value that the item is for sale\n   */\n    function setSalePrice(\n        address _originContract,\n        uint256 _tokenId,\n        uint256 _amount\n    )\n        public\n        ownerMustHaveMarketplaceApproved(_originContract, _tokenId)\n        senderMustBeTokenOwner(_originContract, _tokenId)\n    {\n        tokenPrices[_originContract][_tokenId] = _amount;\n        priceSetters[_originContract][_tokenId] = msg.sender;\n        emit SetSalePrice(_originContract, _amount, _tokenId);\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // buy\n    /////////////////////////////////////////////////////////////////////////\n    /**\n   * @dev Purchases the token if it is for sale.\n   * @param _originContract address of the contract storing the token.\n   * @param _tokenId uint256 ID of the token.\n   */\n    function buy(address _originContract, uint256 _tokenId)\n        public\n        payable\n        ownerMustHaveMarketplaceApproved(_originContract, _tokenId)\n    {\n        // Check that the person who set the price still owns the token.\n        require(\n            _priceSetterStillOwnsTheToken(_originContract, _tokenId),\n            \"Current token owner must be the person to have the latest price.\"\n        );\n\n        // Check that token is for sale.\n        uint256 tokenPrice = tokenPrices[_originContract][_tokenId];\n        require(tokenPrice > 0, \"Tokens priced at 0 are not for sale.\");\n\n        // Check that enough ether was sent.\n        uint256 requiredCost = tokenPrice + _calcMarketplaceFee(tokenPrice);\n        require(\n            requiredCost == msg.value,\n            \"Must purchase the token for the correct price\"\n        );\n\n        // Get token contract details.\n        IERC721 erc721 = IERC721(_originContract);\n        address tokenOwner = erc721.ownerOf(_tokenId);\n\n        // Payout all parties.\n        _payout(tokenPrice, tokenOwner, _originContract, _tokenId);\n\n        // Transfer token.\n        erc721.safeTransferFrom(tokenOwner, msg.sender, _tokenId);\n\n        // Wipe the token price.\n        _resetTokenPrice(_originContract, _tokenId);\n\n        // if the buyer had an existing bid, return it\n        if (_addressHasBidOnToken(msg.sender, _originContract, _tokenId)) {\n            _refundBid(_originContract, _tokenId);\n        }\n\n        // set the token as sold\n        _setTokenAsSold(_originContract, _tokenId);\n\n        emit Sold(\n            _originContract,\n            msg.sender,\n            tokenOwner,\n            tokenPrice,\n            _tokenId\n        );\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // tokenPrice\n    /////////////////////////////////////////////////////////////////////////\n    /**\n   * @dev Gets the sale price of the token\n   * @param _originContract address of the contract storing the token.\n   * @param _tokenId uint256 ID of the token\n   * @return sale price of the token\n   */\n    function tokenPrice(address _originContract, uint256 _tokenId)\n        public\n        view\n        returns (uint256)\n    {\n        if (_priceSetterStillOwnsTheToken(_originContract, _tokenId)) {\n            return tokenPrices[_originContract][_tokenId];\n        }\n        return 0;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // bid\n    /////////////////////////////////////////////////////////////////////////\n    /**\n   * @dev Bids on the token, replacing the bid if the bid is higher than the current bid. You cannot bid on a token you already own.\n   * @param _newBidAmount uint256 value in wei to bid, plus marketplace fee.\n   * @param _originContract address of the contract storing the token.\n   * @param _tokenId uint256 ID of the token\n   */\n    function bid(\n        uint256 _newBidAmount,\n        address _originContract,\n        uint256 _tokenId\n    ) public payable {\n        // Check that bid is greater than 0.\n        require(_newBidAmount > 0, \"Cannot bid 0 Wei.\");\n\n        // Check that bid is higher than previous bid\n        uint256 currentBidAmount = tokenCurrentBids[_originContract][_tokenId];\n        require(\n            _newBidAmount > currentBidAmount,\n            \"Must place higher bid than existing bid.\"\n        );\n\n        // Check that enough ether was sent.\n        uint256 requiredCost = _newBidAmount +\n            _calcMarketplaceFee(_newBidAmount);\n        require(\n            requiredCost == msg.value,\n            \"Must purchase the token for the correct price.\"\n        );\n\n        // Check that bidder is not owner.\n        IERC721 erc721 = IERC721(_originContract);\n        address tokenOwner = erc721.ownerOf(_tokenId);\n        address bidder = msg.sender;\n        require(tokenOwner != bidder, \"Bidder cannot be owner.\");\n\n        // Refund previous bidder.\n        _refundBid(_originContract, _tokenId);\n\n        // Set the new bid.\n        _setBid(_newBidAmount, bidder, _originContract, _tokenId);\n\n        emit Bid(_originContract, bidder, _newBidAmount, _tokenId);\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // acceptBid\n    /////////////////////////////////////////////////////////////////////////\n    /**\n   * @dev Accept the bid on the token.\n   * @param _originContract address of the contract storing the token.\n   * @param _tokenId uint256 ID of the token\n   */\n    function acceptBid(address _originContract, uint256 _tokenId)\n        public\n        ownerMustHaveMarketplaceApproved(_originContract, _tokenId)\n        senderMustBeTokenOwner(_originContract, _tokenId)\n    {\n        // Check that a bid exists.\n        require(\n            _tokenHasBid(_originContract, _tokenId),\n            \"Cannot accept a bid when there is none.\"\n        );\n\n        // Payout all parties.\n        (uint256 bidAmount, address bidder) = currentBidDetailsOfToken(\n            _originContract,\n            _tokenId\n        );\n        _payout(bidAmount, msg.sender, _originContract, _tokenId);\n\n        // Transfer token.\n        IERC721 erc721 = IERC721(_originContract);\n        erc721.safeTransferFrom(msg.sender, bidder, _tokenId);\n\n        // Wipe the token price and bid.\n        _resetTokenPrice(_originContract, _tokenId);\n        _resetBid(_originContract, _tokenId);\n\n        // set the token as sold\n        _setTokenAsSold(_originContract, _tokenId);\n\n        emit AcceptBid(\n            _originContract,\n            bidder,\n            msg.sender,\n            bidAmount,\n            _tokenId\n        );\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // currentBidDetailsOfToken\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Function to get current bid and bidder of a token.\n  * @param _originContract address of ERC721 contract.\n  * @param _tokenId uin256 id of the token.\n  */\n    function currentBidDetailsOfToken(address _originContract, uint256 _tokenId)\n        public\n        view\n        returns (uint256, address)\n    {\n        return (\n            tokenCurrentBids[_originContract][_tokenId],\n            tokenCurrentBidders[_originContract][_tokenId]\n        );\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // setMarketplaceFee\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Function to set the marketplace fee percentage.\n  * @param _percentage uint256 fee to take from purchases.\n  */\n    function setMarketplaceFee(uint256 _percentage) public onlyOwner {\n        marketplaceFee = _percentage;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // setRoyaltyFee\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Function to set the royalty fee percentage.\n  * @param _percentage uint256 royalty fee to take split between seller and creator.\n  */\n    function setRoyaltyFee(uint256 _percentage) public onlyOwner {\n        royaltyFee = _percentage;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // setPrimarySaleFee\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Function to set the primary sale fee percentage.\n  * @param _percentage uint256 fee to take from purchases.\n  */\n    function setPrimarySaleFee(uint256 _percentage) public onlyOwner {\n        primarySaleFee = _percentage;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _priceSetterStillOwnsTheToken\n    /////////////////////////////////////////////////////////////////////////\n    /**\n   * @dev Checks that the token is owned by the same person who set the sale price.\n   * @param _originContract address of the contract storing the token.\n   * @param _tokenId address of the contract storing the token.\n   */\n    function _priceSetterStillOwnsTheToken(\n        address _originContract,\n        uint256 _tokenId\n    ) internal view returns (bool) {\n        IERC721 erc721 = IERC721(_originContract);\n        address owner = erc721.ownerOf(_tokenId);\n        address priceSetter = priceSetters[_originContract][_tokenId];\n        return owner == priceSetter;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _payout\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Internal function to pay the seller, creator, and maintainer.\n  * @param _amount uint256 value to be split.\n  * @param _seller address seller of the token.\n  * @param _originContract address of the token contract.\n  * @param _tokenId uint256 ID of the token.\n  */\n    function _payout(\n        uint256 _amount,\n        address _seller,\n        address _originContract,\n        uint256 _tokenId\n    ) private {\n        address maintainer = this.owner();\n        address creator = IERC721Creator(_originContract).tokenCreator(\n            _tokenId\n        );\n\n        uint256 marketplacePayment = _calcMarketplacePayment(\n            _amount,\n            _originContract,\n            _tokenId\n        );\n        uint256 sellerPayment = _calcSellerPayment(\n            _amount,\n            _originContract,\n            _tokenId\n        );\n        uint256 royaltyPayment = _calcRoyaltyPayment(\n            _amount,\n            _originContract,\n            _tokenId\n        );\n\n        if (marketplacePayment > 0) {\n            _makePayable(maintainer).transfer(marketplacePayment);\n        }\n        if (sellerPayment > 0) {\n            _makePayable(_seller).transfer(sellerPayment);\n        }\n        if (royaltyPayment > 0) {\n            _makePayable(creator).transfer(royaltyPayment);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _calcMarketplacePayment\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Internal function to calculate Marketplace fees.\n  *      If primary sale:  fee + split with seller\n         otherwise:        just fee.\n  * @param _amount uint256 value to be split\n  * @param _originContract address of the token contract\n  * @param _tokenId id of the token\n  */\n    function _calcMarketplacePayment(\n        uint256 _amount,\n        address _originContract,\n        uint256 _tokenId\n    ) internal view returns (uint256) {\n        uint256 marketplaceFeePayment = _calcMarketplaceFee(_amount);\n        bool isPrimarySale = !tokenSolds[_originContract][_tokenId];\n        if (isPrimarySale) {\n            uint256 primarySalePayment = _amount.mul(primarySaleFee).div(100);\n            return marketplaceFeePayment + primarySalePayment;\n        }\n        return marketplaceFeePayment;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _calcRoyaltyPayment\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Internal function to calculate royalty payment.\n  *      If primary sale: 0\n  *      otherwise:       artist royalty.\n  * @param _amount uint256 value to be split\n  * @param _originContract address of the token contract\n  * @param _tokenId id of the token\n  */\n    function _calcRoyaltyPayment(\n        uint256 _amount,\n        address _originContract,\n        uint256 _tokenId\n    ) internal view returns (uint256) {\n        bool isPrimarySale = !tokenSolds[_originContract][_tokenId];\n        if (isPrimarySale) {\n            return 0;\n        }\n        return _amount.mul(royaltyFee).div(100);\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _calcSellerPayment\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Internal function to calculate seller payment.\n  *      If primary sale: _amount - split with marketplace,\n  *      otherwise:       _amount - artist royalty.\n  * @param _amount uint256 value to be split\n  * @param _originContract address of the token contract\n  * @param _tokenId id of the token\n  */\n    function _calcSellerPayment(\n        uint256 _amount,\n        address _originContract,\n        uint256 _tokenId\n    ) internal view returns (uint256) {\n        bool isPrimarySale = !tokenSolds[_originContract][_tokenId];\n        if (isPrimarySale) {\n            uint256 primarySalePayment = _amount.mul(primarySaleFee).div(100);\n            return _amount - primarySalePayment;\n        }\n        uint256 royaltyPayment = _calcRoyaltyPayment(\n            _amount,\n            _originContract,\n            _tokenId\n        );\n        return _amount - royaltyPayment;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _calcMarketplaceFee\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Internal function calculate marketplace fee for a given amount.\n  *      f(_amount) =  _amount * (fee % / 100)\n  * @param _amount uint256 value to be split.\n  */\n    function _calcMarketplaceFee(uint256 _amount)\n        internal\n        view\n        returns (uint256)\n    {\n        return _amount.mul(marketplaceFee).div(100);\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _setTokenAsSold\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Internal function to set a token as sold.\n  * @param _originContract address of ERC721 contract.\n  * @param _tokenId uin256 id of the token.\n  */\n    function _setTokenAsSold(address _originContract, uint256 _tokenId)\n        internal\n    {\n        if (tokenSolds[_originContract][_tokenId]) {\n            return;\n        }\n        tokenSolds[_originContract][_tokenId] = true;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _resetTokenPrice\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Internal function to set token price to 0 for a give contract.\n  * @param _originContract address of ERC721 contract.\n  * @param _tokenId uin256 id of the token.\n  */\n    function _resetTokenPrice(address _originContract, uint256 _tokenId)\n        internal\n    {\n        tokenPrices[_originContract][_tokenId] = 0;\n        priceSetters[_originContract][_tokenId] = address(0);\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _addressHasBidOnToken\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Internal function see if the given address has an existing bid on a token.\n  * @param _bidder address that may have a current bid.\n  * @param _originContract address of ERC721 contract.\n  * @param _tokenId uin256 id of the token.\n  */\n    function _addressHasBidOnToken(\n        address _bidder,\n        address _originContract,\n        uint256 _tokenId\n    ) internal view returns (bool) {\n        return tokenCurrentBidders[_originContract][_tokenId] == _bidder;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _tokenHasBid\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Internal function see if the token has an existing bid.\n  * @param _originContract address of ERC721 contract.\n  * @param _tokenId uin256 id of the token.\n  */\n    function _tokenHasBid(address _originContract, uint256 _tokenId)\n        internal\n        view\n        returns (bool)\n    {\n        return tokenCurrentBidders[_originContract][_tokenId] != address(0);\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _refundBid\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Internal function to return an existing bid on a token to the\n  *      bidder and reset bid.\n  * @param _originContract address of ERC721 contract.\n  * @param _tokenId uin256 id of the token.\n  */\n    function _refundBid(address _originContract, uint256 _tokenId) internal {\n        address currentBidder = tokenCurrentBidders[_originContract][_tokenId];\n        uint256 currentBid = tokenCurrentBids[_originContract][_tokenId];\n        uint256 valueToReturn = currentBid + _calcMarketplaceFee(currentBid);\n        if (currentBidder == address(0)) {\n            return;\n        }\n        _resetBid(_originContract, _tokenId);\n        _makePayable(currentBidder).transfer(valueToReturn);\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _resetBid\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Internal function to reset bid by setting bidder and bid to 0.\n  * @param _originContract address of ERC721 contract.\n  * @param _tokenId uin256 id of the token.\n  */\n    function _resetBid(address _originContract, uint256 _tokenId) internal {\n        tokenCurrentBidders[_originContract][_tokenId] = address(0);\n        tokenCurrentBids[_originContract][_tokenId] = 0;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _setBid\n    /////////////////////////////////////////////////////////////////////////\n    /**\n  * @dev Internal function to set a bid.\n  * @param _amount uint256 value in wei to bid. Does not include marketplace fee.\n  * @param _bidder address of the bidder.\n  * @param _originContract address of ERC721 contract.\n  * @param _tokenId uin256 id of the token.\n  */\n    function _setBid(\n        uint256 _amount,\n        address _bidder,\n        address _originContract,\n        uint256 _tokenId\n    ) internal {\n        // Check bidder not 0 address.\n        require(_bidder != address(0), \"Bidder cannot be 0 address.\");\n\n        // Set bid.\n        tokenCurrentBidders[_originContract][_tokenId] = _bidder;\n        tokenCurrentBids[_originContract][_tokenId] = _amount;\n    }\n\n    /////////////////////////////////////////////////////////////////////////\n    // _makePayable\n    /////////////////////////////////////////////////////////////////////////\n    /**\n     * @dev Internal function to set a bid.\n     * @param _address non-payable address\n     * @return payable address\n     */\n    function _makePayable(address _address)\n    internal\n    pure\n    returns (address payable)\n    {\n        return address(uint160(_address));\n    }\n}"
    }
  }
}