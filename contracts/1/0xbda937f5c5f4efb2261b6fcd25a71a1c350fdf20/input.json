{"language":"Solidity","settings":{"libraries":{"Primes.sol":{"PrimesTokenURI":"0x40614f51a985302d7060966a072b7e846a21e4e6"}},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Primes.sol":{"content":"pragma solidity ^0.8.7;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC165, IERC165)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        string memory baseURI = _baseURI();\r\n        return\r\n            bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, can be overriden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(\r\n            _isApprovedOrOwner(_msgSender(), tokenId),\r\n            \"ERC721: transfer caller is not owner nor approved\"\r\n        );\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        require(\r\n            _isApprovedOrOwner(_msgSender(), tokenId),\r\n            \"ERC721: transfer caller is not owner nor approved\"\r\n        );\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(from, to, tokenId, _data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner ||\r\n            getApproved(tokenId) == spender ||\r\n            isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, _data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n        // Clear approvals\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (\r\n                bytes4 retval\r\n            ) {\r\n                return retval == IERC721Receiver(to).onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract Initializable {\r\n    bool inited = false;\r\n\r\n    modifier initializer() {\r\n        require(!inited, \"already inited\");\r\n        _;\r\n        inited = true;\r\n    }\r\n}\r\n\r\ncontract EIP712Base is Initializable {\r\n    struct EIP712Domain {\r\n        string name;\r\n        string version;\r\n        address verifyingContract;\r\n        bytes32 salt;\r\n    }\r\n\r\n    string public constant ERC712_VERSION = \"1\";\r\n\r\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\r\n        keccak256(\r\n            bytes(\"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\")\r\n        );\r\n    bytes32 internal domainSeperator;\r\n\r\n    // supposed to be called once while initializing.\r\n    // one of the contracts that inherits this contract follows proxy pattern\r\n    // so it is not possible to do this in a constructor\r\n    function _initializeEIP712(string memory name) internal initializer {\r\n        _setDomainSeperator(name);\r\n    }\r\n\r\n    function _setDomainSeperator(string memory name) internal {\r\n        domainSeperator = keccak256(\r\n            abi.encode(\r\n                EIP712_DOMAIN_TYPEHASH,\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(ERC712_VERSION)),\r\n                address(this),\r\n                bytes32(getChainId())\r\n            )\r\n        );\r\n    }\r\n\r\n    function getDomainSeperator() public view returns (bytes32) {\r\n        return domainSeperator;\r\n    }\r\n\r\n    function getChainId() public view returns (uint256) {\r\n        uint256 id;\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Accept message hash and returns hash message in EIP712 compatible form\r\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\r\n     * https://eips.ethereum.org/EIPS/eip-712\r\n     * \"\\\\x19\" makes the encoding deterministic\r\n     * \"\\\\x01\" is the version byte to make it compatible to EIP-191\r\n     */\r\n    function toTypedMessageHash(bytes32 messageHash) internal view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(), messageHash));\r\n    }\r\n}\r\n\r\ncontract NativeMetaTransaction is EIP712Base {\r\n    bytes32 private constant META_TRANSACTION_TYPEHASH =\r\n        keccak256(bytes(\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\"));\r\n    event MetaTransactionExecuted(\r\n        address userAddress,\r\n        address payable relayerAddress,\r\n        bytes functionSignature\r\n    );\r\n    mapping(address => uint256) nonces;\r\n\r\n    /*\r\n     * Meta transaction structure.\r\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\r\n     * He should call the desired function directly in that case.\r\n     */\r\n    struct MetaTransaction {\r\n        uint256 nonce;\r\n        address from;\r\n        bytes functionSignature;\r\n    }\r\n\r\n    function executeMetaTransaction(\r\n        address userAddress,\r\n        bytes memory functionSignature,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) public payable returns (bytes memory) {\r\n        MetaTransaction memory metaTx = MetaTransaction({\r\n            nonce: nonces[userAddress],\r\n            from: userAddress,\r\n            functionSignature: functionSignature\r\n        });\r\n\r\n        require(verify(userAddress, metaTx, sigR, sigS, sigV), \"Signer and signature do not match\");\r\n\r\n        // increase nonce for user (to avoid re-use)\r\n        nonces[userAddress] += 1;\r\n\r\n        emit MetaTransactionExecuted(userAddress, payable(msg.sender), functionSignature);\r\n\r\n        // Append userAddress and relayer address at the end to extract it from calling context\r\n        (bool success, bytes memory returnData) = address(this).call(\r\n            abi.encodePacked(functionSignature, userAddress)\r\n        );\r\n        require(success, \"Function call not successful\");\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function hashMetaTransaction(MetaTransaction memory metaTx) internal pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    META_TRANSACTION_TYPEHASH,\r\n                    metaTx.nonce,\r\n                    metaTx.from,\r\n                    keccak256(metaTx.functionSignature)\r\n                )\r\n            );\r\n    }\r\n\r\n    function getNonce(address user) public view returns (uint256 nonce) {\r\n        nonce = nonces[user];\r\n    }\r\n\r\n    function verify(\r\n        address signer,\r\n        MetaTransaction memory metaTx,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) internal view returns (bool) {\r\n        require(signer != address(0), \"NativeMetaTransaction: INVALID_SIGNER\");\r\n        return\r\n            signer == ecrecover(toTypedMessageHash(hashMetaTransaction(metaTx)), sigV, sigR, sigS);\r\n    }\r\n}\r\n\r\nabstract contract ContextMixin {\r\n    function msgSender() internal view returns (address payable sender) {\r\n        if (msg.sender == address(this)) {\r\n            bytes memory array = msg.data;\r\n            uint256 index = msg.data.length;\r\n            assembly {\r\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\r\n                sender := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            }\r\n        } else {\r\n            sender = payable(msg.sender);\r\n        }\r\n        return sender;\r\n    }\r\n}\r\n\r\ncontract OwnableDelegateProxy {}\r\n\r\ncontract ProxyRegistry {\r\n    mapping(address => OwnableDelegateProxy) public proxies;\r\n}\r\n\r\nabstract contract ERC721Tradable is ContextMixin, Ownable, ERC721, NativeMetaTransaction {\r\n    address public proxyRegistryAddress;\r\n    uint256 private _currentTokenId = 0;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _proxyRegistryAddress\r\n    ) ERC721(_name, _symbol) Ownable() {\r\n        proxyRegistryAddress = _proxyRegistryAddress;\r\n        _initializeEIP712(_name);\r\n    }\r\n\r\n    /**\r\n     * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-less listings.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\r\n        // Whitelist OpenSea proxy contract for easy trading.\r\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\r\n        if (\r\n            proxyRegistryAddress != address(0) && address(proxyRegistry.proxies(owner)) == operator\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        return super.isApprovedForAll(owner, operator);\r\n    }\r\n\r\n    /**\r\n     * This is used instead of msg.sender as transactions won't be sent by the original token owner, but by OpenSea.\r\n     */\r\n    function _msgSender() internal view override returns (address sender) {\r\n        return ContextMixin.msgSender();\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nlibrary Packed16BitArray {\r\n    using Packed16BitArray for Packed16BitArray.PackedArray;\r\n\r\n    struct PackedArray {\r\n        uint256[] array;\r\n        uint256 length;\r\n    }\r\n\r\n    // Verifies that the higher level count is correct, and that the last uint256 is left packed with 0's\r\n    function initStruct(uint256[] memory _arr, uint256 _len)\r\n        internal\r\n        pure\r\n        returns (PackedArray memory)\r\n    {\r\n        uint256 actualLength = _arr.length;\r\n        uint256 len0 = _len / 16;\r\n        require(actualLength == len0 + 1, \"Invalid arr length\");\r\n\r\n        uint256 len1 = _len % 16;\r\n        uint256 leftPacked = uint256(_arr[len0] >> (len1 * 16));\r\n        require(leftPacked == 0, \"Invalid uint256 packing\");\r\n\r\n        return PackedArray(_arr, _len);\r\n    }\r\n\r\n    function getValue(PackedArray storage ref, uint256 _index) internal view returns (uint16) {\r\n        require(_index < ref.length, \"Invalid index\");\r\n        uint256 aid = _index / 16;\r\n        uint256 iid = _index % 16;\r\n        return uint16(ref.array[aid] >> (iid * 16));\r\n    }\r\n\r\n    function biDirectionalSearch(\r\n        PackedArray storage ref,\r\n        uint256 _startIndex,\r\n        uint16 _delta\r\n    ) internal view returns (uint16[2] memory hits) {\r\n        uint16 startVal = ref.getValue(_startIndex);\r\n\r\n        // Search down\r\n        if (startVal >= _delta && _startIndex > 0) {\r\n            uint16 tempVal = startVal;\r\n            uint256 tempIdx = _startIndex - 1;\r\n            uint16 target = startVal - _delta;\r\n\r\n            while (tempVal >= target) {\r\n                tempVal = ref.getValue(tempIdx);\r\n                if (tempVal == target) {\r\n                    hits[0] = tempVal;\r\n                    break;\r\n                }\r\n                if (tempIdx == 0) {\r\n                    break;\r\n                } else {\r\n                    tempIdx--;\r\n                }\r\n            }\r\n        }\r\n        {\r\n            // Search up\r\n            uint16 tempVal = startVal;\r\n            uint256 tempIdx = _startIndex + 1;\r\n            uint16 target = startVal + _delta;\r\n\r\n            while (tempVal <= target) {\r\n                if (tempIdx >= ref.length) break;\r\n                tempVal = ref.getValue(tempIdx++);\r\n                if (tempVal == target) {\r\n                    hits[1] = tempVal;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function setValue(\r\n        PackedArray storage ref,\r\n        uint256 _index,\r\n        uint16 _value\r\n    ) internal {\r\n        uint256 aid = _index / 16;\r\n        uint256 iid = _index % 16;\r\n\r\n        // 1. Do an && between old value and a mask\r\n        uint256 mask = uint256(~(uint256(65535) << (iid * 16)));\r\n        uint256 masked = ref.array[aid] & mask;\r\n        // 2. Do an |= between (1) and positioned _value\r\n        mask = uint256(_value) << (iid * 16);\r\n        ref.array[aid] = masked | mask;\r\n    }\r\n\r\n    function extractIndex(PackedArray storage ref, uint256 _index) internal {\r\n        // Get value at the end\r\n        uint16 endValue = ref.getValue(ref.length - 1);\r\n        ref.setValue(_index, endValue);\r\n        // TODO - could get rid of this and rely on length if need to reduce gas\r\n        // ref.setValue(ref.length - 1, 0);\r\n        ref.length--;\r\n    }\r\n}\r\n\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n}\r\n\r\n/// @title MathBlocks, Primes\r\n/********************************************\r\n * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM *\r\n * MMMMMMMMMMMMNmdddddddddddddddddmNMMMMMMM *\r\n * MMMMMMMMMmhyssooooooooooooooooosyhNMMMMM *\r\n * MMMMMMMmyso+/::::::::::::::::::/osyMMMMM *\r\n * MMMMMMhys+::/+++++++++++++++++/:+syNMMMM *\r\n * MMMMNyso/:/+/::::+/:::/+:::::::+oshMMMMM *\r\n * MMMMmys/-//:/++:/+://-++-+oooossydMMMMMM *\r\n * MMMMNyso+//+s+/:+/:+/:+/:+syddmNMMMMMMMM *\r\n * MMMMMNdyyyyso/:++:/+:/+/:+syNMMMMMMMMMMM *\r\n * MMMMMMMMMhso/:/+/:++:/++-+symMMMMMMMMMMM *\r\n * MMMMMMMMdys+:/++:/++:/++:/+syNMMMMMMMMMM *\r\n * MMMMMMMNys+:/++/:+s+:/+++:/oydMMMMMMMMMM *\r\n * MMMMMMMmys+:/+/:/oso/:///:/sydMMMMMMMMMM *\r\n * MMMMMMMMhso+///+osyso+///osyhMMMMMMMMMMM *\r\n * MMMMMMMMMmhyssyyhmMdhyssyydNMMMMMMMMMMMM *\r\n * MMMMMMMMMMMMMNMMMMMMMMMNMMMMMMMMMMMMMMMM *\r\n *******************************************/\r\nstruct CoreData {\r\n    bool isPrime;\r\n    uint16 primeIndex;\r\n    uint8 primeFactorCount;\r\n    uint16[2] parents;\r\n    uint32 lastBred;\r\n}\r\n\r\nstruct RentalData {\r\n    bool isRentable;\r\n    bool whitelistOnly;\r\n    uint96 studFee;\r\n    uint32 deadline;\r\n    uint16[6] suitors;\r\n}\r\n\r\nstruct PrimeData {\r\n    uint16[2] sexyPrimes;\r\n    uint16[2] twins;\r\n    uint16[2] cousins;\r\n}\r\n\r\nstruct NumberData {\r\n    CoreData core;\r\n    PrimeData prime;\r\n}\r\n\r\nstruct Activity {\r\n    uint8 tranche0;\r\n    uint8 tranche1;\r\n}\r\n\r\nenum Attribute {\r\n    TAXICAB_NUMBER,\r\n    PERFECT_NUMBER,\r\n    EULERS_LUCKY_NUMBER,\r\n    UNIQUE_PRIME,\r\n    FRIENDLY_NUMBER,\r\n    COLOSSALLY_ABUNDANT_NUMBER,\r\n    FIBONACCI_NUMBER,\r\n    REPDIGIT_NUMBER,\r\n    WEIRD_NUMBER,\r\n    TRIANGULAR_NUMBER,\r\n    SOPHIE_GERMAIN_PRIME,\r\n    STRONG_PRIME,\r\n    FRUGAL_NUMBER,\r\n    SQUARE_NUMBER,\r\n    EMIRP,\r\n    MAGIC_NUMBER,\r\n    LUCKY_NUMBER,\r\n    GOOD_PRIME,\r\n    HAPPY_NUMBER,\r\n    UNTOUCHABLE_NUMBER,\r\n    SEMIPERFECT_NUMBER,\r\n    HARSHAD_NUMBER,\r\n    EVIL_NUMBER\r\n}\r\n\r\ncontract TokenAttributes {\r\n    bytes32 public attributesRootHash;\r\n    mapping(uint256 => uint256) internal packedTokenAttrs;\r\n\r\n    event RevealedAttributes(uint256 tokenId, uint256 attributes);\r\n\r\n    constructor(bytes32 _attributesRootHash) {\r\n        attributesRootHash = _attributesRootHash;\r\n    }\r\n\r\n    /***************************************\r\n                    ATTRIBUTES\r\n    ****************************************/\r\n\r\n    function revealAttributes(\r\n        uint256 _tokenId,\r\n        uint256 _attributes,\r\n        bytes32[] memory _merkleProof\r\n    ) public {\r\n        bytes32 leaf = keccak256(abi.encodePacked(_tokenId, _attributes));\r\n        require(MerkleProof.verify(_merkleProof, attributesRootHash, leaf), \"Invalid merkle proof\");\r\n        packedTokenAttrs[_tokenId] = _attributes;\r\n        emit RevealedAttributes(_tokenId, _attributes);\r\n    }\r\n\r\n    function getAttributes(uint256 _tokenId) public view returns (bool[23] memory attributes) {\r\n        uint256 packed = packedTokenAttrs[_tokenId];\r\n        for (uint8 i = 0; i < 23; i++) {\r\n            attributes[i] = _getAttr(packed, i);\r\n        }\r\n        return attributes;\r\n    }\r\n\r\n    function _getAttr(uint256 _packed, uint256 _attribute) internal pure returns (bool attribute) {\r\n        uint256 flag = (_packed >> _attribute) & uint256(1);\r\n        attribute = flag == 1;\r\n    }\r\n}\r\n\r\nlibrary Base64 {\r\n    string internal constant TABLE_ENCODE =\r\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        if (data.length == 0) return \"\";\r\n\r\n        // load the table into memory\r\n        string memory table = TABLE_ENCODE;\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\r\n\r\n        // add some extra buffer at the end required for the writing\r\n        string memory result = new string(encodedLen + 32);\r\n\r\n        assembly {\r\n            // set the actual output length\r\n            mstore(result, encodedLen)\r\n\r\n            // prepare the lookup table\r\n            let tablePtr := add(table, 1)\r\n\r\n            // input ptr\r\n            let dataPtr := data\r\n            let endPtr := add(dataPtr, mload(data))\r\n\r\n            // result ptr, jump over length\r\n            let resultPtr := add(result, 32)\r\n\r\n            // run over the input, 3 bytes at a time\r\n            for {\r\n\r\n            } lt(dataPtr, endPtr) {\r\n\r\n            } {\r\n                // read 3 bytes\r\n                dataPtr := add(dataPtr, 3)\r\n                let input := mload(dataPtr)\r\n\r\n                // write 4 characters\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n            }\r\n\r\n            // padding with '='\r\n            switch mod(mload(data), 3)\r\n            case 1 {\r\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n            }\r\n            case 2 {\r\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nlibrary PrimesTokenURI {\r\n    string internal constant DESCRIPTION = \"Primes is MathBlocks Collection #1.\";\r\n    string internal constant STYLE =\r\n        \"<style>.p #bg{fill:#ddd} .c #bg{fill:#222} .p .factor,.p #text{fill:#222} .c .factor,.c #text{fill:#ddd} .sexy{fill:#e44C21} .cousin{fill:#348C47} .twin {fill:#3C4CE1} #grid .factor{r: 8} .c #icons *{fill: #ddd} .p #icons * {fill:#222} #icons .stroke *{fill:none} #icons .stroke {fill:none;stroke:#222;stroke-width:8} .c #icons .stroke{stroke:#ddd} .square{stroke-width:2;fill:none;stroke:#222;r:8} .c .square{stroke:#ddd} #icons #i-4 circle{stroke-width:20}</style>\";\r\n\r\n    function tokenURI(\r\n        uint256 _tokenId,\r\n        NumberData memory _numberData,\r\n        uint16[] memory _factors,\r\n        bool[23] memory _attributeValues\r\n    ) public pure returns (string memory output) {\r\n        string[24] memory parts;\r\n\r\n        // 23 attributes revealed with merkle proof\r\n        for (uint8 i = 0; i < 23; i++) {\r\n            parts[i] = _attributeValues[i]\r\n                ? string(abi.encodePacked('{ \"value\": \"', _attributeNames(i), '\" }'))\r\n                : \"\";\r\n        }\r\n\r\n        // Last attribute: Unit/Prime/Composite\r\n        parts[23] = string(\r\n            abi.encodePacked(\r\n                '{ \"value\": \"',\r\n                _tokenId == 1 ? \"Unit\" : _numberData.core.isPrime ? \"Prime\" : \"Composite\",\r\n                '\" }'\r\n            )\r\n        );\r\n\r\n        string memory json = string(\r\n            abi.encodePacked(\r\n                '{ \"name\": \"Primes #',\r\n                _toString(_tokenId),\r\n                '\", \"description\": \"',\r\n                DESCRIPTION,\r\n                '\", \"attributes\": [',\r\n                _getAttributes(parts),\r\n                '], \"image\": \"',\r\n                _getImage(_tokenId, _numberData, _factors, _attributeValues),\r\n                '\" }'\r\n            )\r\n        );\r\n\r\n        output = string(\r\n            abi.encodePacked(\"data:application/json;base64,\", Base64.encode(bytes(json)))\r\n        );\r\n    }\r\n\r\n    function _getImage(\r\n        uint256 _tokenId,\r\n        NumberData memory _numberData,\r\n        uint16[] memory _factors,\r\n        bool[23] memory _attributeValues\r\n    ) internal pure returns (string memory output) {\r\n        // 350x350 canvas\r\n        // padding: 14\r\n        // 14x14 grid (bottom row for icons etc)\r\n        // grid square: 23\r\n        // inner square: 16 (circle r=8)\r\n        string memory svg = string(\r\n            abi.encodePacked(\r\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"350\" height=\"350\">',\r\n                _svgContent(_tokenId, _numberData, _factors, _attributeValues),\r\n                \"</svg>\"\r\n            )\r\n        );\r\n\r\n        output = string(abi.encodePacked(\"data:image/svg+xml;base64,\", Base64.encode(bytes(svg))));\r\n    }\r\n\r\n    function _svgContent(\r\n        uint256 _tokenId,\r\n        NumberData memory _numberData,\r\n        uint16[] memory _factors,\r\n        bool[23] memory _attributeValues\r\n    ) internal pure returns (string memory output) {\r\n        output = string(\r\n            abi.encodePacked(\r\n                STYLE,\r\n                '<g class=\"',\r\n                _numberData.core.isPrime && _tokenId != 1 ? \"p\" : \"c\",\r\n                '\"><rect id=\"bg\" width=\"100%\" height=\"100%\" />',\r\n                _circles(_tokenId, _numberData, _factors),\r\n                _text(_tokenId),\r\n                _icons(_tokenId, _numberData.core.isPrime, _attributeValues),\r\n                \"</g>\"\r\n            )\r\n        );\r\n    }\r\n\r\n    function _text(uint256 _tokenId) internal pure returns (string memory output) {\r\n        uint256[] memory digits = _getDigits(_tokenId);\r\n\r\n        // 16384 has an extra row; move the text to the top right to avoid an overlap\r\n        uint256 dx = _tokenId == 16384 ? 277 : 18;\r\n        uint256 dy = _tokenId == 16384 ? 18 : 318;\r\n\r\n        output = string(\r\n            abi.encodePacked(\r\n                '<g id=\"text\" transform=\"translate(',\r\n                _toString(dx),\r\n                \",\",\r\n                _toString(dy),\r\n                ')\">',\r\n                _getNumeralPath(digits, 0),\r\n                _getNumeralPath(digits, 1),\r\n                _getNumeralPath(digits, 2),\r\n                _getNumeralPath(digits, 3),\r\n                _getNumeralPath(digits, 4),\r\n                \"</g>\"\r\n            )\r\n        );\r\n    }\r\n\r\n    function _getNumeralPath(uint256[] memory _digits, uint256 _index)\r\n        internal\r\n        pure\r\n        returns (string memory output)\r\n    {\r\n        if (_digits.length <= _index) {\r\n            return output;\r\n        }\r\n        output = string(\r\n            abi.encodePacked(\r\n                '<g transform=\"translate(',\r\n                _toString(_index * 12),\r\n                ',0)\"><path d=\"',\r\n                _getNumeralPathD(_digits[_index]),\r\n                '\" /></g>'\r\n            )\r\n        );\r\n    }\r\n\r\n    // Space Mono numerals\r\n    function _getNumeralPathD(uint256 _digit) internal pure returns (string memory) {\r\n        if (_digit == 0) {\r\n            return\r\n                \"M0 5.5a6 6 0 0 1 1.3-4C2 .4 3.3 0 4.7 0c1.5 0 2.7.5 3.5 1.4a6 6 0 0 1 1.3 4.1v3c0 1.8-.5 3.2-1.3 4.1-.8 1-2 1.4-3.5 1.4s-2.6-.5-3.5-1.4C.4 11.6 0 10.3 0 8.5v-3Zm4.7 7c1 0 1.8-.3 2.4-1 .5-.8.7-1.8.7-3.1V5.6L7.7 4 7 2.6l-1-.8c-.4-.2-.9-.3-1.4-.3-.5 0-1 0-1.3.3l-1 .8c-.3.4-.5.8-.6 1.3l-.2 1.7v2.8c0 1.3.3 2.3.8 3 .5.8 1.3 1.1 2.3 1.1ZM3.5 7c0-.3.1-.6.4-.9.2-.2.5-.3.8-.3.4 0 .7 0 .9.3.2.3.4.6.4.9 0 .3-.2.6-.4.9-.2.2-.5.3-.9.3-.3 0-.6 0-.8-.3-.3-.3-.4-.6-.4-.9Z\";\r\n        } else if (_digit == 1) {\r\n            return \"M4 12.2V1h-.2L1.6 6H0L2.5.2h3.2v12h3.8v1.4H.2v-1.5H4Z\";\r\n        } else if (_digit == 2) {\r\n            return\r\n                \"M9.2 12.2v1.5h-9v-2.3c0-.6 0-1.1.2-1.6.2-.4.5-.8.9-1.1.4-.4.8-.7 1.4-.9l1.8-.5c1.1-.3 2-.7 2.5-1.1.5-.5.7-1 .7-1.8l-.1-1.1-.6-1c-.2-.2-.5-.4-1-.5-.3-.2-.7-.3-1.3-.3a3 3 0 0 0-2.3.9c-.5.6-.8 1.4-.8 2.4v.9H0v-1l.3-1.8c.2-.5.5-1 1-1.5.3-.4.8-.8 1.4-1a5 5 0 0 1 2-.4c.8 0 1.5.1 2 .4.6.2 1.1.5 1.5 1 .4.3.7.7.9 1.2.2.5.2 1 .2 1.5v.4c0 1-.3 1.9-1 2.6-.6.7-1.6 1.2-3 1.6-1.2.2-2.1.6-2.7 1-.6.5-.9 1.1-.9 2v.5h7.5Z\";\r\n        } else if (_digit == 3) {\r\n            return\r\n                \"M3.3 7V4.8L7.7 2v-.2H.1V.3h9v2.4L4.7 5.5v.3h.8a3.7 3.7 0 0 1 4 3.8v.3a3.8 3.8 0 0 1-1.3 3A4.8 4.8 0 0 1 4.9 14c-.8 0-1.5-.1-2-.3a4.4 4.4 0 0 1-2.5-2.4C0 10.7 0 10.2 0 9.5v-1h1.6v1c0 .4 0 .8.2 1.2l.7 1 1 .6a3.8 3.8 0 0 0 2.5 0 3 3 0 0 0 1-.6c.3-.2.5-.5.6-.9.2-.3.2-.7.2-1v-.2c0-.8-.2-1.4-.7-1.9-.5-.4-1.2-.7-2-.7H3.4Z\";\r\n        } else if (_digit == 4) {\r\n            return \"M4.7.3h3.1v9.4H10v1.5H8v2.5H6.1v-2.5H0V9L4.7.3ZM1.4 9.5v.2h4.8V1H6L1.4 9.5Z\";\r\n        } else if (_digit == 5) {\r\n            return\r\n                \"M.2 7.4V.3h8.5v1.5H1.8v4.8H2l.5-.8a3.4 3.4 0 0 1 1.7-1l1.1-.2c.7 0 1.2.1 1.7.3a3.9 3.9 0 0 1 2.3 2.2c.2.6.3 1.1.3 1.8v.3c0 .7-.1 1.3-.3 1.9-.2.5-.5 1-1 1.5-.3.4-.8.8-1.4 1a5 5 0 0 1-2 .4c-.8 0-1.5-.1-2.1-.3-.6-.3-1.1-.6-1.5-1-.5-.4-.8-.9-1-1.4C.1 10.7 0 10 0 9.3V9h1.6v.4c0 1 .3 1.9.9 2.4.6.5 1.4.8 2.3.8.6 0 1 0 1.4-.3l1-.7.6-1.1L8 9V9a3 3 0 0 0-.8-2c-.2-.3-.5-.5-.9-.7a2.6 2.6 0 0 0-1.8 0 2 2 0 0 0-.6.2l-.4.4-.2.5h-3Z\";\r\n        } else if (_digit == 6) {\r\n            return\r\n                \"M7.5 4.2c0-.8-.3-1.5-.8-2s-1.2-.8-2.1-.8l-1.2.3c-.4.1-.7.3-1 .6a3.2 3.2 0 0 0-.8 2.4v2h.2c.4-.6.8-1 1.4-1.4.5-.3 1.2-.5 1.9-.5.6 0 1.2.1 1.7.4.5.1 1 .4 1.3.8l1 1.4.2 1.9v.2A4.5 4.5 0 0 1 8 12.8c-.4.3-.9.7-1.5.9a5.2 5.2 0 0 1-3.7 0c-.6-.2-1-.5-1.5-1-.4-.3-.7-.8-1-1.3L0 9.6v-5c0-.7.1-1.3.4-1.9.2-.5.5-1 1-1.4.4-.4.9-.8 1.4-1a5.4 5.4 0 0 1 3.6 0 4 4 0 0 1 2.7 3.9H7.5Zm-2.8 8.4c.4 0 .9 0 1.2-.2l1-.7c.3-.2.5-.6.6-1 .2-.3.2-.7.2-1.2v-.2c0-.4 0-.9-.2-1.2a2.7 2.7 0 0 0-1.6-1.6c-.4-.2-.8-.2-1.2-.2a3.1 3.1 0 0 0-2.2.8 3 3 0 0 0-.9 2.1v.4c0 .4 0 .8.2 1.2a2.7 2.7 0 0 0 1.6 1.6l1.3.2Z\";\r\n        } else if (_digit == 7) {\r\n            return\r\n                \"M0 .3h9v2.3l-5.7 8.6-.6 1a2 2 0 0 0-.2 1v.5H.9V12.4a3.9 3.9 0 0 1 .7-1.3l.5-.8L7.6 2v-.2H0V.3Z\";\r\n        } else if (_digit == 8) {\r\n            return\r\n                \"M4.5 14a6 6 0 0 1-1.8-.3L1.2 13l-.9-1.2c-.2-.4-.3-1-.3-1.5v-.2A3.3 3.3 0 0 1 .8 8a3.3 3.3 0 0 1 1.7-1v-.3a3 3 0 0 1-.8-.4c-.3-.1-.5-.4-.7-.6a3 3 0 0 1-.6-1.9v-.2A3.2 3.2 0 0 1 1.4 1a5.4 5.4 0 0 1 3.1-1h.1C5.4 0 6 0 6.5.3c.5.1 1 .4 1.3.7A3.1 3.1 0 0 1 9 3.5v.2c0 .4 0 .7-.2 1 0 .4-.2.7-.5.9a3 3 0 0 1-.6.6 3 3 0 0 1-.9.4V7a3.7 3.7 0 0 1 1.8 1 3.3 3.3 0 0 1 .7 2.2v.2A3.3 3.3 0 0 1 8.1 13l-1.4.7a6 6 0 0 1-1.9.3h-.3Zm.3-1.5c.9 0 1.6-.2 2.1-.6.6-.5.8-1 .8-1.8V10c0-.8-.3-1.4-.8-1.8-.6-.5-1.3-.7-2.2-.7-1 0-1.7.2-2.3.7-.5.4-.8 1-.8 1.8v.1c0 .7.3 1.3.8 1.8.6.4 1.3.6 2.2.6h.2ZM4.7 6a3 3 0 0 0 2-.6c.4-.5.7-1 .7-1.6v-.1A2 2 0 0 0 6.6 2a3 3 0 0 0-2-.6 3 3 0 0 0-2 .6A2 2 0 0 0 2 3.7c0 .7.2 1.2.7 1.7a3 3 0 0 0 2 .6Z\";\r\n        } else {\r\n            return\r\n                \"M1.8 9.8c0 .8.3 1.5.8 2a3 3 0 0 0 2.1.8c.5 0 .9-.1 1.2-.3.4-.1.7-.3 1-.6.3-.3.5-.6.6-1 .2-.4.2-.9.2-1.4v-2h-.2c-.3.6-.7 1-1.3 1.4-.5.3-1.2.5-1.9.5a5 5 0 0 1-1.7-.3A3.8 3.8 0 0 1 .3 6.6C.1 6.1 0 5.5 0 4.8v-.2c0-.7.1-1.3.3-1.9A4.2 4.2 0 0 1 2.8.3 5 5 0 0 1 4.7 0 4.9 4.9 0 0 1 8 1.3c.4.4.8.8 1 1.4.2.5.3 1.1.3 1.8v4.8a5 5 0 0 1-.3 2 4.3 4.3 0 0 1-2.5 2.4 5.5 5.5 0 0 1-3.6 0L1.5 13l-1-1.3-.3-1.8h1.6Zm2.9-8.4c-.5 0-1 .1-1.3.3a2.8 2.8 0 0 0-1.6 1.6l-.2 1.2v.3c0 .4 0 .8.2 1.2l.7 1 1 .5c.3.2.7.2 1.2.2.4 0 .8 0 1.2-.2a3 3 0 0 0 1-.6l.6-1c.2-.3.2-.7.2-1v-.4c0-.5 0-.9-.2-1.2-.1-.4-.3-.7-.6-1-.3-.3-.6-.5-1-.6-.3-.2-.8-.3-1.2-.3Z\";\r\n        }\r\n    }\r\n\r\n    function _getIconGeometry(uint256 _attribute) internal pure returns (string memory) {\r\n        if (_attribute == 0) {\r\n            // Taxicab Number\r\n            return\r\n                '<rect y=\"45\" width=\"15\" height=\"15\" rx=\"2\"/><rect x=\"15\" y=\"30\" width=\"15\" height=\"15\" rx=\"2\"/><rect x=\"30\" y=\"15\" width=\"15\" height=\"15\" rx=\"2\"/><path d=\"M45 2c0-1.1.9-2 2-2h11a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H47a2 2 0 0 1-2-2V2Z\"/><path d=\"M45 32c0-1.1.9-2 2-2h11a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H47a2 2 0 0 1-2-2V32Z\"/><path d=\"M30 47c0-1.1.9-2 2-2h11a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H32a2 2 0 0 1-2-2V47Z\"/><path d=\"M0 17c0-1.1.9-2 2-2h11a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V17Z\"/><path d=\"M15 2c0-1.1.9-2 2-2h11a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H17a2 2 0 0 1-2-2V2Z\"/>';\r\n        } else if (_attribute == 1) {\r\n            // Perfect Number\r\n            return\r\n                '<g class=\"stroke\"><path d=\"m12 12 37 37\"/><path d=\"m12 49 37-37\"/><path d=\"M5.4 30H56\"/><path d=\"M30.7 55.3V4.7\"/></g>';\r\n        } else if (_attribute == 2) {\r\n            // Euler's Lucky Numbers\r\n            return\r\n                '<path d=\"M30.8 7.3c-10 0-15.4 5.9-16.4 17.8 0 .6.3.8 1 .8h29c.6 0 1-.2 1-.8C44.8 13.2 40 7.3 30.7 7.3Zm2.3 52c-8.8 0-15.6-2.4-20.2-7.2C8.3 47 6 39.9 6 30c0-10 2.2-17.3 6.6-22A23.8 23.8 0 0 1 30.8 1C45 1 52.5 9.4 53.4 26.2c0 1.7-.5 3.2-1.8 4.4a6.2 6.2 0 0 1-4.5 1.7h-32c-.5 0-.8.3-.8 1C15 46.5 21.5 53 34 53c4 0 8.3-.8 12.6-2.3.8-.3 1.5-.2 2.3.3.7.4 1 1 1 2 0 2.4-1 4-3.3 4.5-4.6 1.1-9 1.7-13.4 1.7Z\"/>';\r\n        } else if (_attribute == 3) {\r\n            // Unique Prime\r\n            return '<circle class=\"stroke\" cx=\"30\" cy=\"30\" r=\"20\"/>';\r\n        } else if (_attribute == 4) {\r\n            // Friendly Number\r\n            return\r\n                '<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M30 60a30 30 0 1 0 0-60 30 30 0 0 0 0 60ZM17.5 31c3.6 0 6.5-4.3 6.5-9.5S21 12 17.5 12c-3.6 0-6.5 4.3-6.5 9.5s3 9.5 6.5 9.5ZM49 21.5c0 5.2-3 9.5-6.5 9.5-3.6 0-6.5-4.3-6.5-9.5s3-9.5 6.5-9.5c3.6 0 6.5 4.3 6.5 9.5Zm-2.8 21.9a4 4 0 1 0-6.4-4.8c-5.1 7-15.2 7.3-20.6 0a4 4 0 0 0-6.4 4.8 20.5 20.5 0 0 0 33.4 0Z\"/>';\r\n        } else if (_attribute == 5) {\r\n            // Colossally Abundant Number\r\n            return\r\n                '<path d=\"M34 4a4 4 0 0 0-8 0v22H4a4 4 0 0 0 0 8h22v22a4 4 0 0 0 8 0V34h22a4 4 0 0 0 0-8H34V4Z\"/>';\r\n        } else if (_attribute == 6) {\r\n            // Fibonacci Number\r\n            return\r\n                '<path class=\"stroke\" d=\"M31.3 23a.6.6 0 0 0 0-.4.6.6 0 0 0-.5-.2h-.3a.8.8 0 0 0-.5.3l-.1.4v.3a1 1 0 0 0 .5.7 1.2 1.2 0 0 0 .9.2l.5-.2.4-.5.2-.5a1.7 1.7 0 0 0-.3-1.3 2 2 0 0 0-1.3-.8h-.9l-.8.4c-.3.1-.5.4-.7.7-.2.3-.3.6-.3 1a3 3 0 0 0 .5 2.2 3.3 3.3 0 0 0 2.2 1.4h1.5a4 4 0 0 0 1.4-.7c.5-.3.9-.7 1.2-1.2a5.1 5.1 0 0 0-.2-5.6 5.8 5.8 0 0 0-3.9-2.4c-.8-.2-1.7-.2-2.6 0a7 7 0 0 0-2.5 1.2 8 8 0 0 0-2 2.1c-.5.9-.9 1.9-1 3a8.8 8.8 0 0 0 1.5 6.7 10 10 0 0 0 6.6 4.1c1.4.3 3 .3 4.4 0a13 13 0 0 0 7.8-5.6c1-1.6 1.6-3.4 2-5.2a15.2 15.2 0 0 0-2.7-11.6 17.2 17.2 0 0 0-11.5-7.2c-2.4-.4-5-.4-7.6.2-2.6.6-5.2 1.7-7.5 3.3a22.6 22.6 0 0 0-6 6.4 24.5 24.5 0 0 0-3.3 8.9A26.3 26.3 0 0 0 11 43a29.7 29.7 0 0 0 19.8 12.4A33.5 33.5 0 0 0 54.2 51\"/>';\r\n        } else if (_attribute == 7) {\r\n            // Repdigit Number\r\n            return\r\n                '<g class=\"stroke\"><path d=\"M44 20.8h13.8V7\"/><path d=\"M12 11a25.4 25.4 0 0 1 36 0l9.8 9.8\"/><path d=\"M16 37.2H2.3V51\"/><path d=\"M48 47a25.4 25.4 0 0 1-36 0l-9.8-9.8\"/></g>';\r\n        } else if (_attribute == 8) {\r\n            // Weird Number\r\n            return\r\n                '<path d=\"M28.8 41.6c-1.8 0-3.3-1.5-3-3.3.1-1.3.4-2.4.7-3.3a17 17 0 0 1 3.6-5.4l4.6-4.7c2-2.3 3-4.7 3-7.2s-.7-4.4-2-5.8c-1.3-1.4-3.2-2.1-5.6-2.1-2.4 0-4.3.6-5.8 1.9-.6.6-1.1 1.2-1.5 2-.8 1.6-2.1 3.1-3.9 3.1-1.8 0-3.3-1.5-2.9-3.2.6-2.4 1.8-4.4 3.7-6 2.7-2.3 6.1-3.5 10.4-3.5 4.4 0 7.9 1.2 10.3 3.6 2.5 2.4 3.7 5.6 3.7 9.8 0 4-1.9 8.1-5.6 12.1l-3.9 3.8a10 10 0 0 0-2.3 5c-.3 1.7-1.7 3.2-3.5 3.2Zm-3.5 11.1c0-1 .3-1.9 1-2.6.6-.7 1.5-1.1 2.8-1.1 1.3 0 2.2.4 2.9 1 .6.8 1 1.7 1 2.7 0 1-.4 2-1 2.7-.7.6-1.6 1-2.9 1-1.3 0-2.2-.4-2.9-1-.6-.7-1-1.6-1-2.7Z\"/>';\r\n        } else if (_attribute == 9) {\r\n            // Triangular Number\r\n            return\r\n                '<path d=\"M2 51 28.2 8.6a2 2 0 0 1 3.4 0L58.1 51a2 2 0 0 1-1.7 3.1H3.6A2 2 0 0 1 2 51Z\"/>';\r\n        } else if (_attribute == 10) {\r\n            // Sophie Germain Prime\r\n            return\r\n                '<path d=\"M11.6 32.2c-4.1-1.4-7-3.1-9-5.1C1 25.1 0 22.7 0 19.9c0-3.2 1-5.8 3-7.6 2-1.9 4.8-2.8 8.3-2.8 3.3 0 6.2.4 8.7 1.2.8.3 1.4.7 1.9 1.5.5.7.7 1.5.7 2.3 0 .6-.3 1.1-.8 1.5-.5.3-1 .3-1.7 0a21 21 0 0 0-8.3-1.7c-1.9 0-3.4.5-4.4 1.5-1 1-1.6 2.3-1.6 4a6 6 0 0 0 1.5 4c1 1.1 2.4 2 4.3 2.6 4.7 1.7 8 3.4 9.8 5.4 1.9 2 2.8 4.5 2.8 7.5 0 3.7-1 6.5-3.3 8.4-2.2 1.9-5.5 2.8-9.9 2.8-2.8 0-5.4-.4-7.7-1.3-1.6-.7-2.5-2-2.5-4 0-.7.3-1.1.8-1.4.6-.3 1-.3 1.6 0a15 15 0 0 0 7.3 1.8c5.2 0 7.8-2.1 7.8-6.3 0-1.6-.5-3-1.6-4.1-1-1.1-2.7-2.1-5.1-3Z\"/><path d=\"M47.6 50.5c-5.5 0-10-1.9-13.5-5.6A20.8 20.8 0 0 1 28.8 30c0-6.3 1.8-11.3 5.3-15 3.6-3.7 8.4-5.5 14.6-5.5 2.5 0 4.8.2 7 .5a3.1 3.1 0 0 1 2.5 3.1c0 .7-.3 1.2-.8 1.6a2 2 0 0 1-1.7.3c-2-.5-4-.7-6.5-.7-4.6 0-8.2 1.4-10.7 4C36 21 34.8 25 34.8 30a17 17 0 0 0 3.7 11.5c2.4 2.8 5.6 4.2 9.7 4.2 2 0 4-.3 5.8-.9.2 0 .3-.2.3-.5V31.5c0-.3-.1-.5-.4-.5H45c-.7 0-1.2-.2-1.7-.6-.4-.5-.6-1-.6-1.7s.2-1.2.6-1.7c.5-.4 1-.7 1.7-.7h11.8a3 3 0 0 1 2.2 1 3 3 0 0 1 .9 2.2v15.4c0 1-.3 1.8-.8 2.6s-1.2 1.3-2 1.6c-2.9 1-6 1.4-9.6 1.4Z\"/>';\r\n        } else if (_attribute == 11) {\r\n            // Strong Prime\r\n            return\r\n                '<g class=\"stroke\"><path d=\"M4 28h52\"/><path d=\"M16 40V15\"/><path d=\"M10 34V21\"/><path d=\"M43.6 40V15\"/><path d=\"M50 34.8V20.2\"/></g>';\r\n        } else if (_attribute == 12) {\r\n            // Frugal Number\r\n            return\r\n                '<circle cx=\"8\" cy=\"29\" r=\"8\"/><circle cx=\"30\" cy=\"29\" r=\"8\"/><circle cx=\"52\" cy=\"29\" r=\"8\"/>';\r\n        } else if (_attribute == 13) {\r\n            // Square Number\r\n            return '<rect width=\"60\" height=\"60\" rx=\"2\"/>';\r\n        } else if (_attribute == 14) {\r\n            // EMIRP\r\n            return\r\n                '<path d=\"m14.8 27.7 21.4-16.1a4 4 0 0 0 1.6-3.2V4a2 2 0 0 0-3.2-1.6L2.3 26.8l-.6.4c-.9.6-1.7 1.2-1.7 2.1 0 .7.3 1.4.7 1.7l33.8 28a2 2 0 0 0 3.3-1.5v-5.1a4 4 0 0 0-1.4-3L14.7 30.8a2 2 0 0 1 .1-3.2ZM59.8 5v52.6a2 2 0 0 1-3.3 1.5L22.7 31a2 2 0 0 1 0-3l34-25.7c1.2-1 3.1 1 3.1 2.6Z\"/>';\r\n        } else if (_attribute == 15) {\r\n            // Magic Number\r\n            return\r\n                '<path d=\"M28.1 2.9a2 2 0 0 1 3.8 0l5.5 16.9a2 2 0 0 0 2 1.4H57a2 2 0 0 1 1.2 3.6L44 35.3a2 2 0 0 0-.7 2.2l5.5 17a2 2 0 0 1-3.1 2.2L31.2 46.2a2 2 0 0 0-2.4 0L14.4 56.7a2 2 0 0 1-3-2.2l5.4-17a2 2 0 0 0-.7-2.2L1.7 24.8a2 2 0 0 1 1.2-3.6h17.8a2 2 0 0 0 1.9-1.4l5.5-17Z\"/>';\r\n        } else if (_attribute == 16) {\r\n            // Lucky Number\r\n            return\r\n                '<path d=\"M31.3 23.8a2 2 0 0 1-2.6 0C20.3 16.4 16 12.4 16 7.5 16 3.4 19.3 0 23.5 0a9 9 0 0 1 4.8 1.3c1 .7 2.4.7 3.4 0C33 .5 34.7 0 36.3 0 40.5 0 44 3.2 44 7.3c0 5-4.3 9.1-12.7 16.5Z\"/><path d=\"M23.8 28.7C16.4 20.3 12.4 16 7.3 16c-4 0-7.3 3.5-7.3 7.7 0 1.7.5 3.3 1.3 4.6.7 1 .7 2.4 0 3.4A9 9 0 0 0 0 36.5C0 40.7 3.4 44 7.5 44c4.9 0 9-4.3 16.3-12.7a2 2 0 0 0 0-2.6Z\"/><path d=\"M52.7 44c-5 0-9.1-4.3-16.5-12.7a2 2 0 0 1 0-2.6C43.6 20.3 47.6 16 52.5 16c4 0 7.5 3.3 7.5 7.5a9 9 0 0 1-1.3 4.8c-.7 1-.7 2.4 0 3.4.8 1.3 1.3 3 1.3 4.6 0 4.2-3.2 7.7-7.3 7.7Z\"/><path d=\"M28.7 36.2C20.3 43.6 16 47.6 16 52.7c0 4 3.5 7.3 7.7 7.3 1.7 0 3.3-.5 4.6-1.3 1-.7 2.4-.7 3.4 0a9 9 0 0 0 4.8 1.3c4.2 0 7.5-3.4 7.5-7.5 0-4.9-4.3-9-12.7-16.3a2 2 0 0 0-2.6 0Z\"/>';\r\n        } else if (_attribute == 17) {\r\n            // Good Prime\r\n            return\r\n                '<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M56.6 8.3c2 1.4 2.5 4.2 1 6.3l-29.2 42a4.5 4.5 0 0 1-7.3.1L2.4 32.2a4.5 4.5 0 1 1 7.2-5.4l15 19.6 25.7-37c1.4-2 4.2-2.5 6.3-1Z\"/>';\r\n        } else if (_attribute == 18) {\r\n            // Happy Number\r\n            return\r\n                '<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M30 60a30 30 0 1 0 0-60 30 30 0 0 0 0 60ZM17.5 23c5 0 6.5 3.7 6.5-1.5S21 12 17.5 12c-3.6 0-6.5 4.3-6.5 9.5s1.5 1.5 6.5 1.5ZM49 21.5c0 5.2-2 1.5-6.5 1.5-5 0-6.5 3.7-6.5-1.5s3-9.5 6.5-9.5c3.6 0 6.5 4.3 6.5 9.5Zm-2.8 21.9c1.3-1.8 1.4-5.6-.8-5.6H13.6a4 4 0 0 0-.8 5.6 20.5 20.5 0 0 0 33.4 0Z\"/>';\r\n        } else if (_attribute == 19) {\r\n            // Untouchable Number\r\n            return\r\n                '<path d=\"M8.8 2.2a4 4 0 0 0-5.6 5.6l21.6 21.7L3.2 51.2a4 4 0 1 0 5.6 5.6l21.7-21.6 21.7 21.6a4 4 0 1 0 5.6-5.6L36.2 29.5 57.8 7.8a4 4 0 1 0-5.6-5.6L30.5 23.8 8.8 2.2Z\"/>';\r\n        } else if (_attribute == 20) {\r\n            // Semiperfect Number\r\n            return\r\n                '<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M42.7 1a4 4 0 0 1 4 4v50.6a4 4 0 1 1-8 0V40.2l-11.9 12a4 4 0 1 1-5.6-5.7l12.1-12.2H17a4 4 0 0 1 0-8h15.3L21.2 15a4 4 0 1 1 5.6-5.6l12 11.8V5a4 4 0 0 1 4-4Z\"/>';\r\n        } else if (_attribute == 21) {\r\n            // Harshad Number\r\n            return\r\n                '<path d=\"M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0Z\"/><path d=\"M3.2 57.8a4 4 0 0 1 0-5.6l49-49a4 4 0 0 1 5.6 5.6l-49 49a4 4 0 0 1-5.6 0Z\"/><path d=\"M52 60a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z\"/>';\r\n        } else if (_attribute == 22) {\r\n            // Evil Number\r\n            return\r\n                '<path d=\"M28.3 2.6 23 11a2 2 0 0 0 1.7 3.1H26v12h-7a6 6 0 0 1-6-6v-6h.4a2 2 0 0 0 1.8-3L13 7.4V7h-.3l-2.5-4.2a2 2 0 0 0-3.4 0l-5 8.2a2 2 0 0 0 1.8 3H5v6a14 14 0 0 0 14 14h7v22a4 4 0 1 0 8 0V34h8a14 14 0 0 0 14-14v-6h.4a2 2 0 0 0 1.8-3L56 7.4V7h-.3l-2.5-4.2a2 2 0 0 0-3.4 0l-5 8.2a2 2 0 0 0 1.8 3H48v6a6 6 0 0 1-6 6h-8V14h1.3a2 2 0 0 0 1.7-3l-5.3-8.4a2 2 0 0 0-3.4 0Z\"/>';\r\n        } else if (_attribute == 23) {\r\n            // Unit\r\n            return\r\n                '<path d=\"M30-.5c.7 0 1.4.2 2 .5h12a4 4 0 0 1 0 8h-9.5v44H44a4 4 0 0 1 0 8H32a4.5 4.5 0 0 1-4 0H17a4 4 0 0 1 0-8h8.5V8H17a4 4 0 0 1 0-8h11c.6-.3 1.3-.5 2-.5Z\"/>';\r\n        } else if (_attribute == 24) {\r\n            // Prime\r\n            return '<circle cx=\"30\" cy=\"30\" r=\"30\"/>';\r\n        } else {\r\n            // Composite\r\n            return '<circle class=\"stroke\" cx=\"30\" cy=\"30\" r=\"26\"/>';\r\n        }\r\n    }\r\n\r\n    function _icons(\r\n        uint256 _tokenId,\r\n        bool _isPrime,\r\n        bool[23] memory _attributeValues\r\n    ) internal pure returns (string memory output) {\r\n        string memory icons;\r\n        uint256 count = 0;\r\n        for (uint256 i = 24; i > 0; i--) {\r\n            string memory icon;\r\n\r\n            if (i == 24) {\r\n                uint256 specialIdx = _tokenId == 1 ? 23 : _isPrime ? 24 : 25;\r\n                icon = _getIconGeometry(specialIdx);\r\n            } else if (_attributeValues[i - 1]) {\r\n                icon = _getIconGeometry(i - 1);\r\n            } else {\r\n                continue;\r\n            }\r\n\r\n            // icon geom width = 60\r\n            // scale = 16/60 = 0.266\r\n            // spacing = (60/16) * 23 = 86.25\r\n            uint256 x = ((count * 1e2) * (8625)) / 1e2;\r\n            icons = string(\r\n                abi.encodePacked(\r\n                    icons,\r\n                    '<g id=\"i-',\r\n                    _toString(i),\r\n                    '\" transform=\"scale(.266) translate(-',\r\n                    _toDecimalString(x, 2),\r\n                    ',0)\">',\r\n                    icon,\r\n                    \"</g>\"\r\n                )\r\n            );\r\n            count = count + 1;\r\n        }\r\n        output = string(\r\n            abi.encodePacked('<g id=\"icons\" transform=\"translate(317,317)\">', icons, \"</g>\")\r\n        );\r\n    }\r\n\r\n    function _circles(\r\n        uint256 _tokenId,\r\n        NumberData memory _numberData,\r\n        uint16[] memory _factors\r\n    ) internal pure returns (string memory output) {\r\n        uint256 nFactor = _factors.length;\r\n        string memory factorStr;\r\n        string memory twinStr;\r\n        string memory cousinStr;\r\n        string memory sexyStr;\r\n        string memory squareStr;\r\n\r\n        {\r\n            bool[14][] memory factorRows = _getBitRows(_factors);\r\n            for (uint256 i = 0; i < nFactor; i++) {\r\n                for (uint256 j = 0; j < 14; j++) {\r\n                    if (factorRows[i][j]) {\r\n                        factorStr = string(abi.encodePacked(factorStr, _circle(j, i, \"factor\")));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        {\r\n            uint16[] memory squares = _getSquares(_tokenId);\r\n            bool[14][] memory squareRows = _getBitRows(squares);\r\n\r\n            for (uint256 i = 0; i < squareRows.length; i++) {\r\n                for (uint256 j = 0; j < 14; j++) {\r\n                    if (squareRows[i][j]) {\r\n                        squareStr = string(\r\n                            abi.encodePacked(squareStr, _circle(j, nFactor + i, \"square\"))\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n            squareStr = string(abi.encodePacked('<g opacity=\".2\">', squareStr, \"</g>\"));\r\n        }\r\n\r\n        {\r\n            bool[14][] memory twinRows = _getBitRows(_numberData.prime.twins);\r\n            bool[14][] memory cousinRows = _getBitRows(_numberData.prime.cousins);\r\n            bool[14][] memory sexyRows = _getBitRows(_numberData.prime.sexyPrimes);\r\n\r\n            for (uint256 i = 0; i < 2; i++) {\r\n                for (uint256 j = 0; j < 14; j++) {\r\n                    if (twinRows[i][j]) {\r\n                        twinStr = string(\r\n                            abi.encodePacked(twinStr, _circle(j, nFactor + i, \"twin\"))\r\n                        );\r\n                    }\r\n                    if (cousinRows[i][j]) {\r\n                        cousinStr = string(\r\n                            abi.encodePacked(cousinStr, _circle(j, nFactor + 2 + i, \"cousin\"))\r\n                        );\r\n                    }\r\n                    if (sexyRows[i][j]) {\r\n                        sexyStr = string(\r\n                            abi.encodePacked(sexyStr, _circle(j, nFactor + 4 + i, \"sexy\"))\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        output = string(\r\n            abi.encodePacked(\r\n                '<g id=\"grid\" transform=\"translate(26,26)\">',\r\n                squareStr,\r\n                twinStr,\r\n                cousinStr,\r\n                sexyStr,\r\n                factorStr,\r\n                \"</g>\"\r\n            )\r\n        );\r\n    }\r\n\r\n    function _getSquares(uint256 _tokenId) internal pure returns (uint16[] memory) {\r\n        uint16[] memory squares = new uint16[](14);\r\n        if (_tokenId > 1) {\r\n            for (uint256 i = 0; i < 14; i++) {\r\n                uint256 square = _tokenId**(i + 2);\r\n                if (square > 16384) {\r\n                    break;\r\n                }\r\n                squares[i] = uint16(square);\r\n            }\r\n        }\r\n        return squares;\r\n    }\r\n\r\n    function _circle(\r\n        uint256 _xIndex,\r\n        uint256 _yIndex,\r\n        string memory _class\r\n    ) internal pure returns (string memory output) {\r\n        string memory duration;\r\n\r\n        uint256 index = (_yIndex * 14) + _xIndex + 1;\r\n        if (index == 1) {\r\n            duration = \"40\";\r\n        } else {\r\n            uint256 reciprocal = (1e6 * 1e6) / (1e6 * index);\r\n            duration = _toDecimalString(reciprocal * 40, 6);\r\n        }\r\n\r\n        output = string(\r\n            abi.encodePacked(\r\n                '<circle r=\"8\" cx=\"',\r\n                _toString(23 * _xIndex),\r\n                '\" cy=\"',\r\n                _toString(23 * _yIndex),\r\n                '\" class=\"',\r\n                _class,\r\n                '\">',\r\n                '<animate attributeName=\"opacity\" values=\"1;.3;1\" dur=\"',\r\n                duration,\r\n                's\" repeatCount=\"indefinite\"/>',\r\n                \"</circle>\"\r\n            )\r\n        );\r\n    }\r\n\r\n    function _getBits(uint16 _input) internal pure returns (bool[14] memory) {\r\n        bool[14] memory bits;\r\n        for (uint8 i = 0; i < 14; i++) {\r\n            uint16 flag = (_input >> i) & uint16(1);\r\n            bits[i] = flag == 1;\r\n        }\r\n        return bits;\r\n    }\r\n\r\n    function _getBitRows(uint16[] memory _inputs) internal pure returns (bool[14][] memory) {\r\n        bool[14][] memory rows = new bool[14][](_inputs.length);\r\n        for (uint8 i = 0; i < _inputs.length; i++) {\r\n            rows[i] = _getBits(_inputs[i]);\r\n        }\r\n        return rows;\r\n    }\r\n\r\n    function _getBitRows(uint16[2] memory _inputs) internal pure returns (bool[14][] memory) {\r\n        bool[14][] memory rows = new bool[14][](_inputs.length);\r\n        for (uint8 i = 0; i < _inputs.length; i++) {\r\n            rows[i] = _getBits(_inputs[i]);\r\n        }\r\n        return rows;\r\n    }\r\n\r\n    function _getAttributes(string[24] memory _parts) internal pure returns (string memory output) {\r\n        for (uint256 i = 0; i < _parts.length; i++) {\r\n            string memory input = _parts[i];\r\n\r\n            if (bytes(input).length == 0) {\r\n                continue;\r\n            }\r\n\r\n            output = string(abi.encodePacked(output, bytes(output).length > 0 ? \",\" : \"\", input));\r\n        }\r\n        return output;\r\n    }\r\n\r\n    function _getDigits(uint256 _value) internal pure returns (uint256[] memory) {\r\n        if (_value == 0) {\r\n            uint256[] memory zero = new uint256[](1);\r\n            return zero;\r\n        }\r\n        uint256 temp = _value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        uint256[] memory result = new uint256[](digits);\r\n        temp = _value;\r\n        while (temp != 0) {\r\n            digits -= 1;\r\n            result[digits] = uint256(temp % 10);\r\n            temp /= 10;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function _toString(uint256 _value) internal pure returns (string memory) {\r\n        uint256[] memory digits = _getDigits(uint256(_value));\r\n        bytes memory buffer = new bytes(digits.length);\r\n        for (uint256 i = 0; i < digits.length; i++) {\r\n            buffer[i] = bytes1(uint8(48 + digits[i]));\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    function _toDecimalString(uint256 _value, uint256 _decimals)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        if (_decimals == 0 || _value == 0) {\r\n            return _toString(_value);\r\n        }\r\n\r\n        uint256[] memory digits = _getDigits(_value);\r\n        uint256 len = digits.length;\r\n        bool undersized = len <= _decimals;\r\n\r\n        // Index of the decimal point\r\n        uint256 ptIdx = undersized ? 1 : len - _decimals;\r\n\r\n        // Leading zeroes\r\n        uint256 leading = undersized ? 1 + (_decimals - len) : 0;\r\n\r\n        // Create buffer for total length\r\n        uint256 bufferLen = len + 1 + leading;\r\n        bytes memory buffer = new bytes(bufferLen);\r\n        uint256 offset = 0;\r\n\r\n        // Fill buffer\r\n        for (uint256 i = 0; i < bufferLen; i++) {\r\n            if (i == ptIdx) {\r\n                // Add decimal point\r\n                buffer[i] = bytes1(uint8(46));\r\n                offset++;\r\n            } else if (leading > 0 && i <= leading) {\r\n                // Add leading zero\r\n                buffer[i] = bytes1(uint8(48));\r\n                offset++;\r\n            } else {\r\n                // Add digit with index offset for added bytes\r\n                buffer[i] = bytes1(uint8(48 + digits[i - offset]));\r\n            }\r\n        }\r\n\r\n        return string(buffer);\r\n    }\r\n\r\n    function _attributeNames(uint256 _i) internal pure returns (string memory) {\r\n        string[23] memory attributeNames = [\r\n            \"Taxicab\",\r\n            \"Perfect\",\r\n            \"Euler's Lucky Number\",\r\n            \"Unique Prime\",\r\n            \"Friendly\",\r\n            \"Colossally Abundant\",\r\n            \"Fibonacci\",\r\n            \"Repdigit\",\r\n            \"Weird\",\r\n            \"Triangular\",\r\n            \"Sophie Germain Prime\",\r\n            \"Strong Prime\",\r\n            \"Frugal\",\r\n            \"Square\",\r\n            \"Emirp\",\r\n            \"Magic\",\r\n            \"Lucky\",\r\n            \"Good Prime\",\r\n            \"Happy\",\r\n            \"Untouchable\",\r\n            \"Semiperfect\",\r\n            \"Harshad\",\r\n            \"Evil\"\r\n        ];\r\n        return attributeNames[_i];\r\n    }\r\n}\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n/// @title MathBlocks, Primes\r\n/********************************************\r\n * MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM *\r\n * MMMMMMMMMMMMNmdddddddddddddddddmNMMMMMMM *\r\n * MMMMMMMMMmhyssooooooooooooooooosyhNMMMMM *\r\n * MMMMMMMmyso+/::::::::::::::::::/osyMMMMM *\r\n * MMMMMMhys+::/+++++++++++++++++/:+syNMMMM *\r\n * MMMMNyso/:/+/::::+/:::/+:::::::+oshMMMMM *\r\n * MMMMmys/-//:/++:/+://-++-+oooossydMMMMMM *\r\n * MMMMNyso+//+s+/:+/:+/:+/:+syddmNMMMMMMMM *\r\n * MMMMMNdyyyyso/:++:/+:/+/:+syNMMMMMMMMMMM *\r\n * MMMMMMMMMhso/:/+/:++:/++-+symMMMMMMMMMMM *\r\n * MMMMMMMMdys+:/++:/++:/++:/+syNMMMMMMMMMM *\r\n * MMMMMMMNys+:/++/:+s+:/+++:/oydMMMMMMMMMM *\r\n * MMMMMMMmys+:/+/:/oso/:///:/sydMMMMMMMMMM *\r\n * MMMMMMMMhso+///+osyso+///osyhMMMMMMMMMMM *\r\n * MMMMMMMMMmhyssyyhmMdhyssyydNMMMMMMMMMMMM *\r\n * MMMMMMMMMMMMMNMMMMMMMMMNMMMMMMMMMMMMMMMM *\r\n *******************************************/\r\ncontract Primes is ERC721Tradable, ReentrancyGuard, TokenAttributes {\r\n    using Packed16BitArray for Packed16BitArray.PackedArray;\r\n\r\n    // Periods\r\n    uint256 internal constant RESCUE_SALE_GRACE_PERIOD = 48 hours;\r\n    uint256 internal constant WHITELIST_ONLY_PERIOD = 24 hours;\r\n    uint256 internal constant BATCH_0_GRACE_PERIOD = 2 hours;\r\n    uint256 internal constant BATCH_1_GRACE_PERIOD = 2 hours;\r\n    uint256 internal constant BATCH_2_GRACE_PERIOD = 12 hours;\r\n\r\n    // Prices: 0.05 ETH for FLC, 0.075 for EGS\r\n    uint256 internal constant BATCH_0_PRICE = 5e16;\r\n    uint256 internal constant BATCH_1_PRICE = 75e15;\r\n\r\n    Packed16BitArray.PackedArray internal packedPrimes;\r\n\r\n    Packed16BitArray.PackedArray internal batch0;\r\n    Packed16BitArray.PackedArray internal batch1;\r\n    Packed16BitArray.PackedArray internal batch2;\r\n\r\n    bytes32 public whitelistRootHash;\r\n\r\n    mapping(uint256 => CoreData) public data;\r\n    mapping(uint256 => RentalData) public rental;\r\n    mapping(address => Activity) public users;\r\n\r\n    address public auctionHouse;\r\n\r\n    uint256 public batchStartTime;\r\n    uint256 public nonce;\r\n    address public immutable setupAddr;\r\n    uint256 public immutable BREEDING_COOLDOWN;\r\n\r\n    event Initialized();\r\n    event PrimeClaimed(uint256 tokenId);\r\n    event BatchStarted(uint256 batchId);\r\n    event Bred(uint16 tokenId, uint256 parent1, uint256 parent2);\r\n    event Listed(uint16 tokenId);\r\n    event UnListed(uint16 tokenId);\r\n\r\n    constructor(\r\n        address _dao,\r\n        uint256 _breedCooldown,\r\n        address _proxyRegistryAddress,\r\n        bytes32 _attributesRootHash,\r\n        bytes32 _whitelistRootHash\r\n    )\r\n        ERC721Tradable(\"Primes\", \"PRIME\", _proxyRegistryAddress)\r\n        TokenAttributes(_attributesRootHash)\r\n    {\r\n        setupAddr = msg.sender;\r\n        transferOwnership(_dao);\r\n        BREEDING_COOLDOWN = _breedCooldown;\r\n        whitelistRootHash = _whitelistRootHash;\r\n    }\r\n\r\n    /***************************************\r\n                    VIEWS\r\n    ****************************************/\r\n\r\n    function fetchPrime(uint256 _index) public view returns (uint16 primeNumber) {\r\n        return packedPrimes.getValue(_index);\r\n    }\r\n\r\n    function getNumberData(uint256 _tokenId) public view returns (NumberData memory) {\r\n        require(_tokenId <= 2**14, \"Number too large\");\r\n        CoreData memory core = data[_tokenId];\r\n        return\r\n            NumberData({\r\n                core: core,\r\n                prime: PrimeData({\r\n                    sexyPrimes: sexyPrimes(core.primeIndex),\r\n                    twins: twins(core.primeIndex),\r\n                    cousins: cousins(core.primeIndex)\r\n                })\r\n            });\r\n    }\r\n\r\n    function getSuitors(uint256 _tokenId) public view returns (uint16[6] memory) {\r\n        return rental[_tokenId].suitors;\r\n    }\r\n\r\n    function getParents(uint256 _tokenId) public view returns (uint16[2] memory) {\r\n        return data[_tokenId].parents;\r\n    }\r\n\r\n    /***************************************\r\n                    BREEDING\r\n    ****************************************/\r\n\r\n    function breedPrimes(\r\n        uint16 _parent1,\r\n        uint16 _parent2,\r\n        uint256 _attributes,\r\n        bytes32[] memory _merkleProof\r\n    ) external nonReentrant {\r\n        BreedInput memory input1 = _getInput(_parent1);\r\n        BreedInput memory input2 = _getInput(_parent2);\r\n        require(input1.owns && input2.owns, \"Breeder must own input token\");\r\n        _breed(input1, input2, _attributes, _merkleProof);\r\n    }\r\n\r\n    function crossBreed(\r\n        uint16 _parent1,\r\n        uint16 _parent2,\r\n        uint256 _attributes,\r\n        bytes32[] memory _merkleProof\r\n    ) external payable nonReentrant {\r\n        BreedInput memory input1 = _getInput(_parent1);\r\n        BreedInput memory input2 = _getInput(_parent2);\r\n        require(input1.owns, \"Must own first input\");\r\n        require(input2.rentalData.isRentable, \"Must be rentable\");\r\n        require(msg.value >= input2.rentalData.studFee, \"Must pay stud fee\");\r\n        payable(input2.owner).transfer((msg.value * 9) / 10);\r\n        require(block.timestamp < input2.rentalData.deadline, \"Rental passed deadline\");\r\n        if (input2.rentalData.whitelistOnly) {\r\n            bool isSuitor;\r\n            for (uint256 i = 0; i < 6; i++) {\r\n                isSuitor = isSuitor || input2.rentalData.suitors[i] == _parent1;\r\n            }\r\n            require(isSuitor, \"Must be whitelisted suitor\");\r\n        }\r\n        _breed(input1, input2, _attributes, _merkleProof);\r\n    }\r\n\r\n    function _breed(\r\n        BreedInput memory _input1,\r\n        BreedInput memory _input2,\r\n        uint256 _attributes,\r\n        bytes32[] memory _merkleProof\r\n    ) internal {\r\n        // VALIDATION\r\n        // 1. Check less than max uint16\r\n        uint256 childVal = uint256(_input1.id) * uint256(_input2.id);\r\n        require(childVal <= 2**14, \"Number too large\");\r\n        uint16 scaledVal = uint16(childVal);\r\n\r\n        // 2. Number doesn't exist\r\n        require(!_exists(scaledVal), \"Number already taken\");\r\n\r\n        // 3. Tokens passed cooldown\r\n        require(\r\n            block.timestamp > _input1.tokenData.lastBred + BREEDING_COOLDOWN &&\r\n                block.timestamp > _input2.tokenData.lastBred + BREEDING_COOLDOWN,\r\n            \"Cannot breed so quickly\"\r\n        );\r\n\r\n        // 4. Composites can't self-breed\r\n        require(\r\n            !(_input1.id == _input2.id && !_input1.tokenData.isPrime),\r\n            \"Composites cannot self-breed\"\r\n        );\r\n\r\n        // Breed\r\n        data[_input1.id].lastBred = uint32(block.timestamp);\r\n        data[_input2.id].lastBred = uint32(block.timestamp);\r\n        data[scaledVal] = CoreData({\r\n            isPrime: false,\r\n            primeIndex: 0,\r\n            primeFactorCount: _input1.tokenData.primeFactorCount +\r\n                _input2.tokenData.primeFactorCount,\r\n            parents: [_input1.id, _input2.id],\r\n            lastBred: uint32(block.timestamp)\r\n        });\r\n        _safeMint(msg.sender, scaledVal);\r\n        if (_attributes > 0) {\r\n            revealAttributes(scaledVal, _attributes, _merkleProof);\r\n        }\r\n        _burnAfterBreeding(_input1, _input2);\r\n\r\n        emit Bred(scaledVal, _input1.id, _input2.id);\r\n    }\r\n\r\n    function _burnAfterBreeding(BreedInput memory _input1, BreedInput memory _input2) internal {\r\n        // Both primes, no burn\r\n        if (_input1.tokenData.isPrime && _input2.tokenData.isPrime) return;\r\n        // One prime,\r\n        if (_input1.tokenData.isPrime) {\r\n            require(_input2.owns, \"Breeder must own burning\");\r\n            _burn(_input2.id);\r\n        } else if (_input2.tokenData.isPrime) {\r\n            require(_input1.owns, \"Breeder must own burning\");\r\n            _burn(_input1.id);\r\n        }\r\n        // No primes, both burn\r\n        else {\r\n            require(_input1.owns && _input2.owns, \"Breeder must own burning\");\r\n            _burn(_input1.id);\r\n            _burn(_input2.id);\r\n        }\r\n    }\r\n\r\n    function list(\r\n        uint16 _tokenId,\r\n        uint96 _fee,\r\n        uint32 _deadline,\r\n        uint16[] memory _suitors\r\n    ) external {\r\n        require(msg.sender == ownerOf(_tokenId), \"Must own said token\");\r\n\r\n        uint16[6] memory suitors;\r\n        uint256 len = _suitors.length;\r\n        if (len > 0) {\r\n            require(len < 6, \"Max 6 suitors\");\r\n            for (uint256 i = 0; i < len; i++) {\r\n                suitors[i] = _suitors[i];\r\n            }\r\n        }\r\n\r\n        rental[_tokenId] = RentalData({\r\n            isRentable: true,\r\n            whitelistOnly: len > 0,\r\n            studFee: _fee,\r\n            deadline: _deadline,\r\n            suitors: suitors\r\n        });\r\n\r\n        emit Listed(_tokenId);\r\n    }\r\n\r\n    function unlist(uint16 _tokenId) external {\r\n        require(msg.sender == ownerOf(_tokenId), \"Must own said token\");\r\n\r\n        uint16[6] memory empty6;\r\n        rental[_tokenId] = RentalData(false, false, 0, 0, empty6);\r\n\r\n        emit UnListed(_tokenId);\r\n    }\r\n\r\n    struct BreedInput {\r\n        bool owns;\r\n        address owner;\r\n        uint16 id;\r\n        CoreData tokenData;\r\n        RentalData rentalData;\r\n    }\r\n\r\n    function _getInput(uint16 _breedInput) internal view returns (BreedInput memory) {\r\n        address owner = ownerOf(_breedInput);\r\n        return\r\n            BreedInput({\r\n                owns: owner == msg.sender,\r\n                owner: owner,\r\n                id: _breedInput,\r\n                tokenData: data[_breedInput],\r\n                rentalData: rental[_breedInput]\r\n            });\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n        uint16[6] memory empty6;\r\n        rental[tokenId] = RentalData(false, false, 0, 0, empty6);\r\n    }\r\n\r\n    /***************************************\r\n                    TOKEN URI\r\n    ****************************************/\r\n\r\n    function tokenURI(uint256 _tokenId) public view override returns (string memory output) {\r\n        NumberData memory numberData = getNumberData(_tokenId);\r\n        bool[23] memory attributeValues = getAttributes(_tokenId);\r\n        uint16[] memory factors = getPrimeFactors(uint16(_tokenId), numberData);\r\n        return PrimesTokenURI.tokenURI(_tokenId, numberData, factors, attributeValues);\r\n    }\r\n\r\n    function getPrimeFactors(uint16 _tokenId, NumberData memory _numberData)\r\n        public\r\n        view\r\n        returns (uint16[] memory factors)\r\n    {\r\n        factors = _getFactors(_tokenId, _numberData.core);\r\n        factors = _insertion(factors);\r\n    }\r\n\r\n    function _getFactors(uint16 _tokenId, CoreData memory _core)\r\n        internal\r\n        view\r\n        returns (uint16[] memory factors)\r\n    {\r\n        if (_core.isPrime) {\r\n            factors = new uint16[](1);\r\n            factors[0] = _tokenId;\r\n        } else {\r\n            uint16[] memory parent1Factors = _getFactors(_core.parents[0], data[_core.parents[0]]);\r\n            uint256 len1 = parent1Factors.length;\r\n            uint16[] memory parent2Factors = _getFactors(_core.parents[1], data[_core.parents[1]]);\r\n            uint256 len2 = parent2Factors.length;\r\n            factors = new uint16[](len1 + len2);\r\n            for (uint256 i = 0; i < len1; i++) {\r\n                factors[i] = parent1Factors[i];\r\n            }\r\n            for (uint256 i = 0; i < len2; i++) {\r\n                factors[len1 + i] = parent2Factors[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function _insertion(uint16[] memory _arr) internal pure returns (uint16[] memory) {\r\n        uint256 length = _arr.length;\r\n        for (uint256 i = 1; i < length; i++) {\r\n            uint16 key = _arr[i];\r\n            uint256 j = i - 1;\r\n            while ((int256(j) >= 0) && (_arr[j] > key)) {\r\n                _arr[j + 1] = _arr[j];\r\n                unchecked {\r\n                    j--;\r\n                }\r\n            }\r\n            unchecked {\r\n                _arr[j + 1] = key;\r\n            }\r\n        }\r\n        return _arr;\r\n    }\r\n\r\n    function sexyPrimes(uint256 _primeIndex) public view returns (uint16[2] memory matches) {\r\n        if (_primeIndex > 0) {\r\n            matches = packedPrimes.biDirectionalSearch(_primeIndex, 6);\r\n            if (_primeIndex == 4) {\r\n                // 7: 1 is not prime but is in packedPrimes; exclude it here\r\n                matches[0] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function twins(uint256 _primeIndex) public view returns (uint16[2] memory matches) {\r\n        if (_primeIndex > 0) {\r\n            matches = packedPrimes.biDirectionalSearch(_primeIndex, 2);\r\n            if (_primeIndex == 2) {\r\n                // 3: 1 is not prime but is in packedPrimes; exclude it here\r\n                matches[0] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function cousins(uint256 _primeIndex) public view returns (uint16[2] memory matches) {\r\n        if (_primeIndex > 0) {\r\n            matches = packedPrimes.biDirectionalSearch(_primeIndex, 4);\r\n            if (_primeIndex == 3) {\r\n                // 5: 1 is not prime but is in packedPrimes; exclude it here\r\n                matches[0] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    MINTING\r\n    ****************************************/\r\n\r\n    function mintRandomPrime(\r\n        uint256 _batch0Cap,\r\n        uint256 _batch1Cap,\r\n        bytes32[] memory _merkleProof\r\n    ) external payable {\r\n        mintRandomPrimes(1, _batch0Cap, _batch1Cap, _merkleProof);\r\n    }\r\n\r\n    function mintRandomPrimes(\r\n        uint256 _count,\r\n        uint256 _batch0Cap,\r\n        uint256 _batch1Cap,\r\n        bytes32[] memory _merkleProof\r\n    ) public payable nonReentrant {\r\n        (bool active, uint256 batchId, uint256 remaining, ) = batchCheck();\r\n        require(active && batchId < 2, \"Batch not active\");\r\n        require(remaining >= _count, \"Not enough Primes available\");\r\n        require(_count <= 20, \"Cannot mint >20 Primes at once\");\r\n\r\n        uint256 unitPrice = batchId == 0 ? BATCH_0_PRICE : BATCH_1_PRICE;\r\n        require(msg.value >= _count * unitPrice, \"Requires value\");\r\n\r\n        _validateUser(batchId, _count, _batch0Cap, _batch1Cap, _merkleProof);\r\n        for (uint256 i = 0; i < _count; i++) {\r\n            _getPrime(batchId);\r\n        }\r\n    }\r\n\r\n    function getNextPrime() external nonReentrant returns (uint256 tokenId) {\r\n        require(msg.sender == auctionHouse, \"Must be the auctioneer\");\r\n\r\n        (bool active, uint256 batchId, uint256 remaining, ) = batchCheck();\r\n        require(active && batchId == 2, \"Batch not active\");\r\n        require(remaining > 0, \"No more Primes\");\r\n\r\n        uint256 idx = batch2.length - 1;\r\n        uint16 primeIndex = batch2.getValue(idx);\r\n        batch2.extractIndex(idx);\r\n\r\n        tokenId = _mintLocal(msg.sender, primeIndex);\r\n    }\r\n\r\n    // After each batch has begun, the DAO can mint to ensure no bottleneck\r\n    function rescueSale() external onlyOwner nonReentrant {\r\n        (bool active, uint256 batchId, uint256 remaining, ) = batchCheck();\r\n        require(active, \"Batch not active\");\r\n        require(\r\n            block.timestamp > batchStartTime + RESCUE_SALE_GRACE_PERIOD,\r\n            \"Must wait for sale to elapse\"\r\n        );\r\n        uint256 rescueCount = remaining < 20 ? remaining : 20;\r\n        for (uint256 i = 0; i < rescueCount; i++) {\r\n            _getPrime(batchId);\r\n        }\r\n    }\r\n\r\n    function withdraw() external onlyOwner nonReentrant {\r\n        payable(owner()).transfer(address(this).balance);\r\n    }\r\n\r\n    function batchCheck()\r\n        public\r\n        view\r\n        returns (\r\n            bool active,\r\n            uint256 batch,\r\n            uint256 remaining,\r\n            uint256 startTime\r\n        )\r\n    {\r\n        uint256 ts = batchStartTime;\r\n        if (ts == 0) {\r\n            return (false, 0, 0, 0);\r\n        }\r\n        if (batch0.length > 0) {\r\n            startTime = batchStartTime + BATCH_0_GRACE_PERIOD;\r\n            return (block.timestamp > startTime, 0, batch0.length, startTime);\r\n        }\r\n        if (batch1.length > 0) {\r\n            startTime = batchStartTime + BATCH_1_GRACE_PERIOD;\r\n            return (block.timestamp > startTime, 1, batch1.length, startTime);\r\n        }\r\n        startTime = batchStartTime + BATCH_2_GRACE_PERIOD;\r\n        return (block.timestamp > startTime, 2, batch2.length, startTime);\r\n    }\r\n\r\n    /***************************************\r\n                MINTING - INTERNAL\r\n    ****************************************/\r\n\r\n    function _getPrime(uint256 _batchId) internal {\r\n        uint256 seed = _rand();\r\n        uint16 primeIndex;\r\n        if (_batchId == 0) {\r\n            uint256 idx = seed % batch0.length;\r\n            primeIndex = batch0.getValue(idx);\r\n            batch0.extractIndex(idx);\r\n            _triggerTimestamp(_batchId, batch0.length);\r\n        } else if (_batchId == 1) {\r\n            uint256 idx = seed % batch1.length;\r\n            primeIndex = batch1.getValue(idx);\r\n            batch1.extractIndex(idx);\r\n            _triggerTimestamp(_batchId, batch1.length);\r\n        } else {\r\n            revert(\"Invalid batchId\");\r\n        }\r\n\r\n        _mintLocal(msg.sender, primeIndex);\r\n    }\r\n\r\n    function _mintLocal(address _beneficiary, uint16 _primeIndex)\r\n        internal\r\n        returns (uint256 tokenId)\r\n    {\r\n        uint16[2] memory empty;\r\n        tokenId = fetchPrime(_primeIndex);\r\n        data[tokenId] = CoreData({\r\n            isPrime: true,\r\n            primeIndex: _primeIndex,\r\n            primeFactorCount: 1,\r\n            parents: empty,\r\n            lastBred: uint32(block.timestamp)\r\n        });\r\n        _safeMint(_beneficiary, tokenId);\r\n        emit PrimeClaimed(tokenId);\r\n    }\r\n\r\n    function _validateUser(\r\n        uint256 _batchId,\r\n        uint256 _count,\r\n        uint256 _batch0Cap,\r\n        uint256 _batch1Cap,\r\n        bytes32[] memory _merkleProof\r\n    ) internal {\r\n        if (block.timestamp < batchStartTime + WHITELIST_ONLY_PERIOD) {\r\n            bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _batch0Cap, _batch1Cap));\r\n            require(\r\n                MerkleProof.verify(_merkleProof, whitelistRootHash, leaf),\r\n                \"Invalid merkle proof\"\r\n            );\r\n\r\n            uint8 countAfter = (\r\n                _batchId == 0 ? users[msg.sender].tranche0 : users[msg.sender].tranche1\r\n            ) + uint8(_count);\r\n\r\n            if (_batchId == 0) {\r\n                require(countAfter <= _batch0Cap, \"Exceeding cap\");\r\n                users[msg.sender].tranche0 = countAfter;\r\n            } else {\r\n                require(countAfter <= _batch1Cap, \"Exceeding cap\");\r\n                users[msg.sender].tranche1 = countAfter;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _triggerTimestamp(uint256 _batchId, uint256 _len) internal {\r\n        if (_len == 0) {\r\n            batchStartTime = block.timestamp;\r\n            emit BatchStarted(_batchId + 1);\r\n        }\r\n    }\r\n\r\n    function _rand() internal virtual returns (uint256 seed) {\r\n        nonce++;\r\n        seed = uint256(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    block.timestamp +\r\n                        block.difficulty +\r\n                        ((uint256(keccak256(abi.encodePacked(block.coinbase)))) /\r\n                            (block.timestamp)) +\r\n                        block.gaslimit +\r\n                        ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (block.timestamp)) +\r\n                        block.number,\r\n                    nonce\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    /***************************************\r\n                INITIALIZING\r\n    ****************************************/\r\n\r\n    modifier onlyInitializer() {\r\n        require(msg.sender == setupAddr, \"Only initializer\");\r\n        _;\r\n    }\r\n\r\n    function initPrimes(uint256[] calldata _data, uint256 _length) external onlyInitializer {\r\n        require(packedPrimes.length == 0, \"Already initialized\");\r\n        packedPrimes = Packed16BitArray.initStruct(_data, _length);\r\n    }\r\n\r\n    function initBatch0(uint256[] calldata _data, uint256 _length) external onlyInitializer {\r\n        require(batch0.length == 0, \"Already initialized\");\r\n        batch0 = Packed16BitArray.initStruct(_data, _length);\r\n    }\r\n\r\n    function initBatch1(uint256[] calldata _data, uint256 _length) external onlyInitializer {\r\n        require(batch1.length == 0, \"Already initialized\");\r\n        batch1 = Packed16BitArray.initStruct(_data, _length);\r\n    }\r\n\r\n    function initBatch2(uint256[] calldata _data, uint256 _length) external onlyInitializer {\r\n        require(batch2.length == 0, \"Already initialized\");\r\n        batch2 = Packed16BitArray.initStruct(_data, _length);\r\n    }\r\n\r\n    function start(address _auctionHouse) external onlyInitializer {\r\n        require(\r\n            packedPrimes.length > 0 && batch0.length > 0 && batch1.length > 0 && batch2.length > 0,\r\n            \"Not initialized\"\r\n        );\r\n        batchStartTime = block.timestamp;\r\n        auctionHouse = _auctionHouse;\r\n\r\n        _mintLocal(owner(), 0);\r\n\r\n        emit Initialized();\r\n    }\r\n}"}}}