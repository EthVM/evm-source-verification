{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/SMILE-LibFree.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\nabstract contract Token {\n\n    /// @return supply - total amount of tokens\n    function totalSupply() external virtual returns (uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance - The balance\n    function balanceOf(address _owner) virtual public returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success - Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) virtual public returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success - Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success - Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) virtual public returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining - Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) virtual public returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\nabstract contract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) override public returns (bool success) {\n        require(paused == false, \"Contract Paused\");\n        \n        // Assumes totalSupply can't be over max (2^256 - 1).\n        if (balances[msg.sender] >= _value && _value > 0) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            emit Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) override public returns (bool success) {\n        require(paused == false, \"Contract Paused\");\n        \n        // Assumes totalSupply can't be over max (2^256 - 1).\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n            balances[_to] += _value;\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            emit Transfer(_from, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function balanceOf(address _owner) override public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) override public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) override public view returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    function setPaused(bool _paused) public {\n        require(msg.sender == owner, \"You are not the owner\");\n        paused = _paused;\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public override totalSupply;\n    bool public paused;\n    address public owner;\n}\n\n\ncontract SMILECoin is StandardToken {\n    \n    /* Public variables of the token */\n    mapping (address => uint256) public amount;\n    string public name;\n    string public symbol;\n    uint256 public decimals;\n    string public version;\n\n    // if ETH is sent to this address, send it back.\n    fallback() external payable { revert(); }\n    receive() external payable { revert(); }\n    \n    constructor () {\n        // Tokennomics\n        name = \"Smile Coin\";\n        decimals = 10;\n        symbol = \"SMILE\";\n        version = \"1.0\";\n        \n        owner = msg.sender;\n        setPaused(false);\n        \n        // Mint 10,000,000,000 Tokens and assign them to the Smile Reserve Wallet\n        totalSupply = 10000000000 * (10 ** uint256(decimals));\n        balances[msg.sender] = totalSupply;\n    }\n}"
    }
  }
}