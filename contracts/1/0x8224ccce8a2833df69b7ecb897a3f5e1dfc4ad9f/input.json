{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "YFOSIphone12Components.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.6.0;\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://eips.ethereum.org/EIPS/eip-165\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\nabstract contract IERC721 is IERC165 {\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function balanceOf(address owner)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId)\r\n        public\r\n        virtual\r\n        view\r\n        returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public virtual;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        public\r\n        virtual\r\n        view\r\n        returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public virtual;\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        virtual\r\n        view\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public virtual;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\nabstract contract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public virtual returns (bytes4);\r\n}\r\n\r\ncontract StringUtils {\r\n    function integerToString(uint256 _i) internal pure returns (string memory) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 j = _i;\r\n        uint256 len;\r\n\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint256 k = len - 1;\r\n\r\n        while (_i != 0) {\r\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function _indexOf(\r\n        string memory _base,\r\n        string memory _value,\r\n        uint256 _offset\r\n    ) internal pure returns (int256) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        bytes memory _valueBytes = bytes(_value);\r\n\r\n        assert(_valueBytes.length == 1);\r\n\r\n        for (uint256 i = _offset; i < _baseBytes.length; i++) {\r\n            if (_baseBytes[i] == _valueBytes[0]) {\r\n                return int256(i);\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    function indexOf(string memory _base, string memory _value)\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return _indexOf(_base, _value, 0);\r\n    }\r\n\r\n    function length(string memory _base) internal pure returns (uint256) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        return _baseBytes.length;\r\n    }\r\n\r\n    function charAt(string memory _base, uint256 index)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        return bytes32ToString(_baseBytes[index]);\r\n    }\r\n\r\n    function bytes32ToString(bytes32 _bytes32)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        uint8 i = 0;\r\n        while (i < 32 && _bytes32[i] != 0) {\r\n            i++;\r\n        }\r\n        bytes memory bytesArray = new bytes(i);\r\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\r\n            bytesArray[i] = _bytes32[i];\r\n        }\r\n        return string(bytesArray);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/drafts/Counters.sol\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\n/**\r\n * @title ERC165\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    /*\r\n     * 0x01ffc9a7 ===\r\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\r\n     */\r\n\r\n    /**\r\n     * @dev a mapping of interface id to whether or not it's supported\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /**\r\n     * @dev A contract implementing SupportsInterfaceWithLookup\r\n     * implement ERC165 itself\r\n     */\r\n    constructor() internal {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev implement supportsInterface(bytes4) using a lookup table\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        external\r\n        override\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev internal method for registering an interface\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff);\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721 is ERC165, IERC721, Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping(uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping(address => Counters.Counter) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    /*\r\n     * 0x80ac58cd ===\r\n     *     bytes4(keccak256('balanceOf(address)')) ^\r\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\r\n     *     bytes4(keccak256('approve(address,uint256)')) ^\r\n     *     bytes4(keccak256('getApproved(uint256)')) ^\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n     */\r\n\r\n    constructor() public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public override view returns (uint256) {\r\n        require(owner != address(0));\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public override view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public override {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId)\r\n        public\r\n        override\r\n        view\r\n        returns (address)\r\n    {\r\n        require(_exists(tokenId));\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf\r\n     * @param to operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address to, bool approved)\r\n        public\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(to != msg.sender);\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        virtual\r\n        override\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address\r\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public override {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public override {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return bool whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     * is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner ||\r\n            getApproved(tokenId) == spender ||\r\n            isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0));\r\n        require(!_exists(tokenId));\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal virtual {\r\n        require(ownerOf(tokenId) == owner);\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[owner].decrement();\r\n        _tokenOwner[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual {\r\n        require(ownerOf(tokenId) == from);\r\n        require(to != address(0));\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address\r\n     * The call is not executed if the target address is not a contract\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal returns (bool) {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(\r\n            msg.sender,\r\n            from,\r\n            tokenId,\r\n            _data\r\n        );\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to clear current approval of a given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\nabstract contract IERC721Enumerable is IERC721 {\r\n    function totalSupply() public virtual view returns (uint256);\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index)\r\n        public\r\n        virtual\r\n        view\r\n        returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) public virtual view returns (uint256);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint256[]) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n    uint256 public _burnTokens;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n\r\n    /*\r\n     * 0x780e9d63 ===\r\n     *     bytes4(keccak256('totalSupply()')) ^\r\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n     *     bytes4(keccak256('tokenByIndex(uint256)'))\r\n     */\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor() public {\r\n        // register the supported interface to conform to ERC721Enumerable via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n     * @param owner address owning the tokens list to be accessed\r\n     * @param index uint256 representing the index to be accessed of the requested tokens list\r\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index)\r\n        public\r\n        override\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(index < balanceOf(owner));\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of tokens stored by the contract\r\n     * @return uint256 representing the total amount of tokens\r\n     */\r\n    function totalSupply() public override view returns (uint256) {\r\n        return _allTokens.length.sub(_burnTokens);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of all the tokens in this contract\r\n     * Reverts if the index is greater or equal to the total number of tokens\r\n     * @param index uint256 representing the index to be accessed of the tokens list\r\n     * @return uint256 token ID at the given index of the tokens list\r\n     */\r\n    function tokenByIndex(uint256 index)\r\n        public\r\n        override\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(index < totalSupply());\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        super._transferFrom(from, to, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(from, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param to address the beneficiary that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual override {\r\n        super._mint(to, tokenId);\r\n\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n\r\n        _addTokenToAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal virtual override {\r\n        super._burn(owner, tokenId);\r\n\r\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\r\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\r\n        _ownedTokensIndex[tokenId] = 0;\r\n        _burnTokens++;\r\n        _removeTokenFromAllTokensEnumeration(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the list of token IDs of the requested owner\r\n     * @param owner address owning the tokens\r\n     * @return uint256[] List of token IDs owned by the requested address\r\n     */\r\n    function _tokensOfOwner(address owner)\r\n        internal\r\n        view\r\n        returns (uint256[] storage)\r\n    {\r\n        return _ownedTokens[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\r\n        _ownedTokens[to].push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\r\n        private\r\n    {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        _ownedTokens[from].pop();\r\n\r\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\r\n        // lastTokenId, or just over the end of the array if the token was the last one).\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        _allTokens.pop();\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\nabstract contract IERC721Metadata is IERC721 {\r\n    function name() external virtual view returns (string memory);\r\n\r\n    function symbol() external virtual view returns (string memory);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol\r\n\r\nabstract contract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x93254542; // name, symbol\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor(string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token name\r\n     * @return string representing the token name\r\n     */\r\n    function name() external override view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol() external override view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n}\r\n\r\n// File: contracts/TradeableERC721Token.sol\r\n\r\ncontract OwnableDelegateProxy {\r\n\r\n}\r\n\r\ncontract ProxyRegistry {\r\n    mapping(address => OwnableDelegateProxy) public proxies;\r\n}\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract IPhoneFactory is Ownable {\r\n    using SafeMath for uint256;\r\n    uint256 public _currentTokenId;\r\n    uint8 public IPHONE_SUCCESS = 1;\r\n    uint8 public IPHONE_FAILED = 0;\r\n    uint8 public IPHONE_MADE_MAX = 3;\r\n    uint8 public successIphoneMade = 0;\r\n    uint8 public createdIphoneMade = 0;\r\n    address public AppleInc;\r\n\r\n    uint256[] public _IPhonesMade;\r\n    mapping(address => bool) public _iCompanies;\r\n\r\n    modifier requireManufactory {\r\n        require(_iCompanies[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAppleInc {\r\n        require(msg.sender == AppleInc);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        AppleInc = msg.sender;\r\n    }\r\n\r\n    struct IProp {\r\n        uint256 iType;\r\n        uint256 iData;\r\n    }\r\n\r\n    event CreatePropIphone(uint256 indexed tokenId, IProp prop);\r\n\r\n    mapping(uint256 => IProp) public _iProps;\r\n\r\n    function random() public view returns (uint256) {\r\n        uint256 randomnumber = uint256(\r\n            keccak256(abi.encodePacked(now, msg.sender, _currentTokenId))\r\n        ) % 999;\r\n        randomnumber = randomnumber.add(1);\r\n        return randomnumber;\r\n    }\r\n\r\n    function create(uint256 tokenId, uint256 _type) internal {\r\n        _create(tokenId, _type, random());\r\n    }\r\n\r\n    function _create(\r\n        uint256 tokenId,\r\n        uint256 _type,\r\n        uint256 _data\r\n    ) internal {\r\n        IProp memory iProp = IProp({iType: _type, iData: _data});\r\n        _iProps[tokenId] = iProp;\r\n        emit CreatePropIphone(tokenId, iProp);\r\n    }\r\n\r\n    function setAppleInc(address _newAppleInc) public onlyOwner {\r\n        AppleInc = _newAppleInc;\r\n    }\r\n\r\n    function addManufactory(address _newManufactory) public onlyAppleInc {\r\n        _iCompanies[_newManufactory] = true;\r\n    }\r\n\r\n    function removeManufactory(address _company) public onlyAppleInc {\r\n        require(_iCompanies[_company]);\r\n        _iCompanies[_company] = false;\r\n    }\r\n\r\n    function assembleYourIPhone(\r\n        uint256 tokenChip,\r\n        uint256 tokenRom,\r\n        uint256 tokenColor\r\n    ) public virtual {}\r\n}\r\n\r\ncontract YFOSIphone12Components is\r\n    ERC721,\r\n    ERC721Enumerable,\r\n    ERC721Metadata,\r\n    IPhoneFactory,\r\n    StringUtils\r\n{\r\n    address proxyRegistryAddress;\r\n\r\n    constructor(string memory _name, string memory _symbol)\r\n        public\r\n        ERC721Metadata(_name, _symbol)\r\n    {}\r\n\r\n    function _mint(address to, uint256 tokenId)\r\n        internal\r\n        override(ERC721Enumerable, ERC721)\r\n    {\r\n        super._mint(to, tokenId);\r\n        _incrementTokenId();\r\n    }\r\n\r\n    function mintTo(address to) public requireManufactory {\r\n        uint256 nextTokenId = _getNextTokenId();\r\n        _mint(to, nextTokenId);\r\n        super.create(nextTokenId, block.timestamp);\r\n    }\r\n\r\n    function multiMint(address to, uint256 amount) public requireManufactory{\r\n        require(amount <= 10);\r\n        for (uint256 index = 0; index < amount; index++) {\r\n            uint256 nextTokenId = _getNextTokenId();\r\n            _mint(to, nextTokenId);\r\n            super.create(nextTokenId, block.timestamp.add(random()));\r\n        }\r\n    }\r\n\r\n    function create(\r\n        address to,\r\n        uint256 _type,\r\n        uint256 _data\r\n    ) public onlyAppleInc {\r\n        uint256 nextTokenId = _getNextTokenId();\r\n        _mint(to, nextTokenId);\r\n        super._create(nextTokenId, _type, _data);\r\n    }\r\n\r\n    function _burn(address owner, uint256 tokenId)\r\n        internal\r\n        override(ERC721Enumerable, ERC721)\r\n    {\r\n        require(ownerOf(tokenId) == owner);\r\n        super._burn(owner, tokenId);\r\n    }\r\n\r\n    function burn(uint256 tokenId) public {\r\n        _burn(msg.sender, tokenId);\r\n    }\r\n\r\n    function _transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public override(ERC721Enumerable, ERC721) {\r\n        super._transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev calculates the next token ID based on value of _currentTokenId\r\n     * @return uint256 for the next token ID\r\n     */\r\n    function _getNextTokenId() private view returns (uint256) {\r\n        return _currentTokenId.add(1);\r\n    }\r\n\r\n    /**\r\n     * @dev increments the value of _currentTokenId\r\n     */\r\n    function _incrementTokenId() private {\r\n        _currentTokenId++;\r\n    }\r\n\r\n    /**\r\n     * Override isApprovedForAll to whitelist user's proxy accounts.\r\n     */\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        override\r\n        view\r\n        returns (bool)\r\n    {\r\n        // Whitelist proxy contract for easy trading.\r\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\r\n        if (address(proxyRegistry.proxies(owner)) == operator) {\r\n            return true;\r\n        }\r\n\r\n        return super.isApprovedForAll(owner, operator);\r\n    }\r\n\r\n    function updateProxyRegistryAddress(address _proxyRegistryAddress)\r\n        public\r\n        onlyOwner\r\n    {\r\n        proxyRegistryAddress = _proxyRegistryAddress;\r\n    }\r\n\r\n    uint256 WHITE = 111; // White Iphone\r\n    uint256 BLACK = 222; // Black Iphone\r\n    uint256 BLUE = 333; // Blue Iphone\r\n    uint256 GREEN = 444; // Green Iphone\r\n    uint256 RED = 555; // Red Iphone\r\n    uint256 GRAPHITE = 666; // Graphite Iphone\r\n    uint256 SILVER = 777; // Silver Iphone\r\n    uint256 GOLD = 888; // Gold Iphone\r\n    uint256 PACIFIC_BLUE = 999; // Pacific Blue Iphone\r\n    uint256[] COLORS = [\r\n        WHITE,\r\n        BLACK,\r\n        BLUE,\r\n        GREEN,\r\n        RED,\r\n        GRAPHITE,\r\n        SILVER,\r\n        GOLD,\r\n        PACIFIC_BLUE\r\n    ];\r\n\r\n    uint256 A14_1 = 123; // CHIP A14\r\n    uint256 A14_2 = 456; // CHIP A14\r\n    uint256 A14_3 = 789; // CHIP A14\r\n    uint256[] CHIPS = [A14_1, A14_2, A14_3];\r\n\r\n    uint256 ROM_64GB_1 = 100;\r\n    uint256 ROM_64GB_2 = 200;\r\n    uint256 ROM_128GB_1 = 300;\r\n    uint256 ROM_128GB_2 = 400;\r\n    uint256 ROM_256GB_1 = 500;\r\n    uint256 ROM_256GB_2 = 600;\r\n    uint256 ROM_512GB_1 = 700;\r\n    uint256 ROM_512GB_2 = 800;\r\n    uint256[] ROMS = [\r\n        ROM_64GB_1,\r\n        ROM_64GB_2,\r\n        ROM_128GB_1,\r\n        ROM_128GB_2,\r\n        ROM_256GB_1,\r\n        ROM_256GB_2,\r\n        ROM_512GB_1,\r\n        ROM_512GB_2\r\n    ];\r\n\r\n    string _CHIP = \"0369\";\r\n    string _ROM = \"258\";\r\n    string _COLOR = \"147\";\r\n\r\n    enum TYPE_ID {INVALID_TYPE, COLOR, CHIP, ROM}\r\n\r\n    function contains(uint256[] memory intArr, uint256 _int)\r\n        public\r\n        pure\r\n        returns (bool isContains)\r\n    {\r\n        for (uint256 index = 0; index < intArr.length; index++) {\r\n            if (_int == intArr[index]) {\r\n                isContains = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function isValidValueProp(IProp memory iProp, uint256[] memory values)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return contains(values, iProp.iData);\r\n    }\r\n\r\n    function isValidTypeProp(IProp memory iProp, string memory typeProp)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (iProp.iType == IPHONE_SUCCESS || iProp.iType == IPHONE_FAILED) {\r\n            return false;\r\n        }\r\n        string memory iType = integerToString(iProp.iType);\r\n        int256 invalidIndex = -1;\r\n        return\r\n            indexOf(typeProp, charAt(iType, length(iType) - 1)) != invalidIndex;\r\n    }\r\n\r\n    function checkProp(uint256 tokenId)\r\n        public\r\n        view\r\n        returns (bool validPropValue, TYPE_ID iType)\r\n    {\r\n        validPropValue = false;\r\n        IProp memory iProp = _iProps[tokenId];\r\n        if (isValidTypeProp(iProp, _COLOR)) {\r\n            if (isValidValueProp(iProp, COLORS)) {\r\n                validPropValue = true;\r\n            }\r\n            return (validPropValue, TYPE_ID.COLOR);\r\n        }\r\n        if (isValidTypeProp(iProp, _CHIP)) {\r\n            if (isValidValueProp(iProp, CHIPS)) {\r\n                validPropValue = true;\r\n            }\r\n            return (validPropValue, TYPE_ID.CHIP);\r\n        }\r\n        if (isValidTypeProp(iProp, _ROM)) {\r\n            if (isValidValueProp(iProp, ROMS)) {\r\n                validPropValue = true;\r\n            }\r\n            return (validPropValue, TYPE_ID.ROM);\r\n        }\r\n        return (false, TYPE_ID.INVALID_TYPE);\r\n    }\r\n\r\n    mapping(uint256 => uint256[]) _iPhones;\r\n\r\n    function getIPhoneData(uint256 iPhoneId)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return _iPhones[iPhoneId];\r\n    }\r\n\r\n    function assembleYourIPhone(\r\n        uint256 tokenChip,\r\n        uint256 tokenRom,\r\n        uint256 tokenColor\r\n    ) public override {\r\n        require(successIphoneMade < IPHONE_MADE_MAX);\r\n        require(ownerOf(tokenChip) == ownerOf(tokenRom));\r\n        require(ownerOf(tokenRom) == ownerOf(tokenColor));\r\n        require(ownerOf(tokenColor) == msg.sender);\r\n\r\n        bool validIPhone = false;\r\n        (bool validPropChip, TYPE_ID iTypeChip) = checkProp(tokenChip);\r\n        (bool validPropRom, TYPE_ID iTypeRom) = checkProp(tokenRom);\r\n        (bool validPropColor, TYPE_ID iTypeColor) = checkProp(tokenColor);\r\n        require(\r\n            iTypeChip == TYPE_ID.CHIP &&\r\n                iTypeRom == TYPE_ID.ROM &&\r\n                iTypeColor == TYPE_ID.COLOR,\r\n            \"Invalid type prop.\"\r\n        );\r\n        uint256 newIphoneId = _getNextTokenId();\r\n        validIPhone = validPropChip && validPropRom && validPropColor;\r\n\r\n        burn(tokenChip);\r\n        burn(tokenRom);\r\n        burn(tokenColor);\r\n\r\n        _mint(msg.sender, newIphoneId);\r\n        if (validIPhone) {\r\n            _IPhonesMade.push(newIphoneId);\r\n            successIphoneMade++;\r\n        }\r\n        createdIphoneMade++;\r\n        _iPhones[newIphoneId] = [tokenChip, tokenRom, tokenColor];\r\n        super._create(\r\n            newIphoneId,\r\n            validIPhone ? IPHONE_SUCCESS : IPHONE_FAILED,\r\n            block.timestamp\r\n        );\r\n    }\r\n}"
    }
  }
}