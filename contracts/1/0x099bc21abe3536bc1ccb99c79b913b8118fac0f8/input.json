{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/wrapperSushi.sol": {
      "content": "/*\n                                       `.-:+osyhhhhhhyso+:-.`\n                                   .:+ydmNNNNNNNNNNNNNNNNNNmdy+:.\n                                .+ymNNNNNNNNNNNNNNNNNNNNNNNNNNNNmy+.\n                             `/hmNNNNNNNNmdys+//:::://+sydmNNNNNNNNmh/`\n                           .odNNNNNNNdy+-.`              `.-+ydNNNNNNNdo.\n                         `omNNNNNNdo-`                        `-odNNNNNNmo`\n                        :dNNNNNNh/`                              `/hNNNNNNd:\n                      `oNNNNNNh:                     /-/.           :hNNNNNNo`\n                     `yNNNNNm+`                      mNNm-           `+mNNNNNy`\n                    `hNNNNNd-                        hNNNm.            -dNNNNNh`\n                    yNNNNNd.                         .ymNNh             .dNNNNNy\n                   /NNNNNm.                            -mNNys+.          .mNNNNN/\n                  `mNNNNN:                           `:hNNNNNNNs`         :NNNNNm`\n                  /NNNNNh                          `+dNNNNNNNNNNd.         hNNNNN/\n                  yNNNNN/               .:+syyhhhhhmNNNNNNNNNNNNNm`        /NNNNNy\n                  dNNNNN.            `+dNNNNNNNNNNNNNNNNNNNNNNNmd+         .NNNNNd\n                  mNNNNN`           -dNNNNNNNNNNNNNNNNNNNNNNm-             `NNNNNm\n                  dNNNNN.          -NNNNNNNNNNNNNNNNNNNNNNNN+              .NNNNNd\n                  yNNNNN/          dNNNNNNNNNNNNNNNNNNNNNNNN:              /NNNNNy\n                  /NNNNNh         .NNNNNNNNNNNNNNNNNNNNNNNNd`              hNNNNN/\n                  `mNNNNN:        -NNNNNNNNNNNNNNNNNNNNNNNh.              :NNNNNm`\n                   /NNNNNm.       `NNNNNNNNNNNNNNNNNNNNNh:               .mNNNNN/\n                    yNNNNNd.      .yNNNNNNNNNNNNNNNdmNNN/               .dNNNNNy\n                    `hNNNNNd-    `dmNNNNNNNNNNNNdo-`.hNNh              -dNNNNNh`\n                     `yNNNNNm+`   oNNmmNNNNNNNNNy.   `sNNdo.         `+mNNNNNy`\n                      `oNNNNNNh:   ....++///+++++.     -+++.        :hNNNNNNo`\n                        :dNNNNNNh/`                              `/hNNNNNNd:\n                         `omNNNNNNdo-`                        `-odNNNNNNmo`\n                           .odNNNNNNNdy+-.`              `.-+ydNNNNNNNdo.\n                             `/hmNNNNNNNNmdys+//:::://+sydmNNNNNNNNmh/`\n                                .+ymNNNNNNNNNNNNNNNNNNNNNNNNNNNNmy+.\n                                   .:+ydmNNNNNNNNNNNNNNNNNNmdy+:.\n                                       `.-:+yourewelcome+:-.`\n /$$$$$$$  /$$                                               /$$      /$$\n| $$__  $$| $$                                              | $$$    /$$$\n| $$  \\ $$| $$  /$$$$$$  /$$   /$$ /$$   /$$  /$$$$$$$      | $$$$  /$$$$  /$$$$$$  /$$$$$$$   /$$$$$$  /$$   /$$\n| $$$$$$$/| $$ /$$__  $$|  $$ /$$/| $$  | $$ /$$_____/      | $$ $$/$$ $$ /$$__  $$| $$__  $$ /$$__  $$| $$  | $$\n| $$____/ | $$| $$$$$$$$ \\  $$$$/ | $$  | $$|  $$$$$$       | $$  $$$| $$| $$  \\ $$| $$  \\ $$| $$$$$$$$| $$  | $$\n| $$      | $$| $$_____/  >$$  $$ | $$  | $$ \\____  $$      | $$\\  $ | $$| $$  | $$| $$  | $$| $$_____/| $$  | $$\n| $$      | $$|  $$$$$$$ /$$/\\  $$|  $$$$$$/ /$$$$$$$/      | $$ \\/  | $$|  $$$$$$/| $$  | $$|  $$$$$$$|  $$$$$$$\n|__/      |__/ \\_______/|__/  \\__/ \\______/ |_______/       |__/     |__/ \\______/ |__/  |__/ \\_______/ \\____  $$\n                                                                                                        /$$  | $$\n                                                                                                       |  $$$$$$/\n                                                                                                       \\______/\n*/\n\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\n\npragma solidity 0.7.4;\n\n\ninterface ERC20 {\n    function totalSupply() external view returns(uint supply);\n\n    function balanceOf(address _owner) external view returns(uint balance);\n\n    function transfer(address _to, uint _value) external returns(bool success);\n\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\n\n    function approve(address _spender, uint _value) external returns(bool success);\n\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\n\n    function decimals() external view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ninterface WrappedETH {\n    function totalSupply() external view returns(uint supply);\n\n    function balanceOf(address _owner) external view returns(uint balance);\n\n    function transfer(address _to, uint _value) external returns(bool success);\n\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\n\n    function approve(address _spender, uint _value) external returns(bool success);\n\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\n\n    function decimals() external view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n\n}\n\ninterface UniswapFactory{\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ninterface LPERC20{\n\n    function token0() external view returns(address);\n    function token1() external view returns(address);\n}\n\n\n\ninterface SushiV2{\n\n\n   function addLiquidity ( address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB, uint256 liquidity );\n   function addLiquidityETH ( address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH, uint256 liquidity );\n   function removeLiquidityETH ( address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH );\n   function removeLiquidity ( address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB );\n\n   function swapExactTokensForTokens ( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns ( uint256[] memory amounts );\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n   function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n}\n\n\n\n\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal view returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal view returns (uint256) {\n    assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n\n\n  function sub(uint256 a, uint256 b) internal view returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal view returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n}\n\n\ncontract WrapAndUnWrap{\n\n  using SafeMath\n    for uint256;\n\n  address payable public owner;\n  //placehodler token address for specifying eth tokens\n  address public ETH_TOKEN_ADDRESS  = address(0x0);\n  address public WETH_TOKEN_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n  WrappedETH wethToken = WrappedETH(WETH_TOKEN_ADDRESS);\n  uint256 approvalAmount = 1000000000000000000000000000000;\n  uint256 longTimeFromNow = 1000000000000000000000000000;\n  address sushiAddress = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\n  address uniFactoryAddress = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n  SushiV2 sushiExchange = SushiV2(sushiAddress);\n  UniswapFactory factory = UniswapFactory(uniFactoryAddress);\n  mapping (address => address[]) public lpTokenAddressToPairs;\n  mapping(string=>address) public stablecoins;\n  mapping(address=>mapping(address=>address[])) public presetPaths;\n  bool public changeRecpientIsOwner;\n  uint256 public fee = 0;\n  uint256 public maxfee = 0;\n\n\n  modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"Only owner can call this function.\"\n        );\n        _;\n}\n\n    fallback() external payable {\n    }\n\n  constructor() public payable {\n         stablecoins[\"DAI\"] = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n         stablecoins[\"USDT\"] = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n         stablecoins[\"USDC\"] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n         changeRecpientIsOwner = false;\n        owner= msg.sender;\n\n  }\n\n  function wrap(address sourceToken, address[] memory destinationTokens, uint256 amount) public payable returns(address, uint256){\n\n\n    ERC20 sToken = ERC20(sourceToken);\n    ERC20 dToken = ERC20(destinationTokens[0]);\n\n      if(destinationTokens.length==1){\n\n        if(sourceToken != ETH_TOKEN_ADDRESS){\n          require(sToken.transferFrom(msg.sender, address(this), amount), \"You have not approved this contract or do not have enough token for this transfer 1\");\n          if(sToken.allowance(address(this), sushiAddress) < amount.mul(2)){\n                  sToken.approve(sushiAddress, amount.mul(3));\n            }\n        }\n\n        conductUniswap(sourceToken, destinationTokens[0], amount);\n        uint256 thisBalance = dToken.balanceOf(address(this));\n        dToken.transfer(msg.sender, thisBalance);\n        return (destinationTokens[0], thisBalance);\n\n      }\n\n      else{\n\n        bool updatedweth =false;\n        if(sourceToken == ETH_TOKEN_ADDRESS){\n          WrappedETH sToken1 = WrappedETH(WETH_TOKEN_ADDRESS);\n          sToken1.deposit{value:msg.value}();\n          sToken = ERC20(WETH_TOKEN_ADDRESS);\n          amount = msg.value;\n          sourceToken = WETH_TOKEN_ADDRESS;\n          updatedweth =true;\n        }\n\n\n        if(sourceToken != ETH_TOKEN_ADDRESS && updatedweth==false){\n          require(sToken.transferFrom(msg.sender, address(this), amount), \"You have not approved this contract or do not have enough token for this transfer  2\");\n          if(sToken.allowance(address(this), sushiAddress) < amount.mul(2)){\n                  sToken.approve(sushiAddress, amount.mul(3));\n            }\n        }\n\n        if(destinationTokens[0] == ETH_TOKEN_ADDRESS){\n              destinationTokens[0] = WETH_TOKEN_ADDRESS;\n        }\n        if(destinationTokens[1] == ETH_TOKEN_ADDRESS){\n            destinationTokens[1] = WETH_TOKEN_ADDRESS;\n        }\n\n\n\n        if(sourceToken !=destinationTokens[0]){\n            conductUniswap(sourceToken, destinationTokens[0], amount.div(2));\n        }\n        if(sourceToken !=destinationTokens[1]){\n\n            conductUniswap(sourceToken, destinationTokens[1], amount.div(2));\n        }\n\n        ERC20 dToken2 = ERC20(destinationTokens[1]);\n        uint256 dTokenBalance = dToken.balanceOf(address(this));\n        uint256 dTokenBalance2 = dToken2.balanceOf(address(this));\n\n        if(dToken.allowance(address(this), sushiAddress) < dTokenBalance.mul(2)){\n             dToken.approve(sushiAddress, dTokenBalance.mul(3));\n        }\n\n        if(dToken2.allowance(address(this), sushiAddress) < dTokenBalance2.mul(2)){\n            dToken2.approve(sushiAddress, dTokenBalance2.mul(3));\n        }\n\n        (,,uint liquidityCoins)  = sushiExchange.addLiquidity(destinationTokens[0],destinationTokens[1], dTokenBalance, dTokenBalance2, 1,1, address(this), longTimeFromNow);\n\n        address thisPairAddress = factory.getPair(destinationTokens[0],destinationTokens[1]);\n        ERC20 lpToken = ERC20(thisPairAddress);\n        lpTokenAddressToPairs[thisPairAddress] =[destinationTokens[0], destinationTokens[1]];\n        uint256 thisBalance =lpToken.balanceOf(address(this));\n\n        if(fee>0){\n            uint256 totalFee = (thisBalance.mul(fee)).div(10000);\n            if(totalFee >0){\n                lpToken.transfer(owner, totalFee);\n            }\n            thisBalance =lpToken.balanceOf(address(this));\n            lpToken.transfer(msg.sender, thisBalance);\n\n        }\n        else{\n            lpToken.transfer(msg.sender, thisBalance);\n        }\n\n\n        //transfer any change to changeRecipient (from a pair imbalance. Should never be more than a few basis points)\n        address changeRecipient = msg.sender;\n        if(changeRecpientIsOwner == true){\n            changeRecipient = owner;\n        }\n        if(dToken.balanceOf(address(this)) >0){\n            dToken.transfer(changeRecipient, dToken.balanceOf(address(this)));\n        }\n        if(dToken2.balanceOf(address(this)) >0){\n            dToken2.transfer(changeRecipient, dToken2.balanceOf(address(this)));\n        }\n\n        return (thisPairAddress,thisBalance) ;\n      }\n\n\n\n    }\n\n    function updateStableCoinAddress(string memory coinName, address newAddress) public onlyOwner returns(bool){\n        stablecoins[coinName] = newAddress;\n        return true;\n\n    }\n\n    function updatePresetPaths(address sellToken, address buyToken, address[] memory newPath ) public onlyOwner returns(bool){\n        presetPaths[sellToken][buyToken] = newPath;\n        return true;\n    }\n\n    //owner can turn on ability to collect a small fee from trade imbalances on LP conversions\n    function updateChangeRecipientBool(bool changeRecpientIsOwnerBool ) public onlyOwner returns(bool){\n        changeRecpientIsOwner = changeRecpientIsOwnerBool;\n        return true;\n    }\n\n\n\n      function unwrap(address sourceToken, address destinationToken, uint256 amount) public payable returns( uint256){\n\n        address originalDestinationToken = destinationToken;\n        ERC20 sToken = ERC20(sourceToken);\n        if(destinationToken == ETH_TOKEN_ADDRESS){\n            destinationToken = WETH_TOKEN_ADDRESS;\n        }\n        ERC20 dToken = ERC20(destinationToken);\n\n        if(sourceToken != ETH_TOKEN_ADDRESS){\n          require(sToken.transferFrom(msg.sender, address(this), amount), \"You have not approved this contract or do not have enough token for this transfer  3 unwrapping\");\n        }\n\n        LPERC20 thisLpInfo = LPERC20(sourceToken);\n        lpTokenAddressToPairs[sourceToken] = [thisLpInfo.token0(), thisLpInfo.token1()];\n\n          if(lpTokenAddressToPairs[sourceToken].length !=0){\n            if(sToken.allowance(address(this), sushiAddress) < amount.mul(2)){\n                  sToken.approve(sushiAddress, amount.mul(3));\n            }\n\n          sushiExchange.removeLiquidity(lpTokenAddressToPairs[sourceToken][0], lpTokenAddressToPairs[sourceToken][1], amount, 0,0, address(this), longTimeFromNow);\n\n          ERC20 pToken1 = ERC20(lpTokenAddressToPairs[sourceToken][0]);\n          ERC20 pToken2 = ERC20(lpTokenAddressToPairs[sourceToken][1]);\n\n          uint256 pTokenBalance = pToken1.balanceOf(address(this));\n          uint256 pTokenBalance2 = pToken2.balanceOf(address(this));\n\n           if(pToken1.allowance(address(this), sushiAddress) < pTokenBalance.mul(2)){\n                  pToken1.approve(sushiAddress, pTokenBalance.mul(3));\n            }\n\n            if(pToken2.allowance(address(this), sushiAddress) < pTokenBalance2.mul(2)){\n                  pToken2.approve(sushiAddress, pTokenBalance2.mul(3));\n            }\n\n          if(lpTokenAddressToPairs[sourceToken][0] != destinationToken){\n              conductUniswap(lpTokenAddressToPairs[sourceToken][0], destinationToken, pTokenBalance);\n          }\n          if(lpTokenAddressToPairs[sourceToken][1] != destinationToken){\n              conductUniswap(lpTokenAddressToPairs[sourceToken][1], destinationToken, pTokenBalance2);\n          }\n\n\n          uint256 destinationTokenBalance = dToken.balanceOf(address(this));\n\n          if(originalDestinationToken == ETH_TOKEN_ADDRESS){\n              wethToken.withdraw(destinationTokenBalance);\n              if(fee >0){\n                  uint256 totalFee = (address(this).balance.mul(fee)).div(10000);\n                  if(totalFee >0){\n                      owner.transfer(totalFee);\n                  }\n                  msg.sender.transfer(address(this).balance);\n              }\n              else{\n                msg.sender.transfer(address(this).balance);\n              }\n          }\n          else{\n              if(fee >0){\n                   uint256 totalFee = (destinationTokenBalance.mul(fee)).div(10000);\n                   if(totalFee >0){\n                       dToken.transfer(owner, totalFee);\n                   }\n                   destinationTokenBalance = dToken.balanceOf(address(this));\n                   dToken.transfer(msg.sender, destinationTokenBalance);\n\n              }\n              else{\n               dToken.transfer(msg.sender, destinationTokenBalance);\n              }\n          }\n\n\n          return destinationTokenBalance;\n\n        }\n\n        else{\n\n            if(sToken.allowance(address(this), sushiAddress) < amount.mul(2)){\n                  sToken.approve(sushiAddress, amount.mul(3));\n            }\n            if(sourceToken != destinationToken){\n                conductUniswap(sourceToken, destinationToken, amount);\n            }\n          uint256 destinationTokenBalance = dToken.balanceOf(address(this));\n          dToken.transfer(msg.sender, destinationTokenBalance);\n          return destinationTokenBalance;\n        }\n\n      }\n\n  function updateOwnerAddress(address payable newOwner) onlyOwner public returns (bool){\n     owner = newOwner;\n     return true;\n   }\n\n   function updateSushiExchange(address newAddress ) public onlyOwner returns (bool){\n\n    sushiExchange = SushiV2( newAddress);\n    sushiAddress = newAddress;\n    return true;\n\n  }\n\n  function updateUniswapFactory(address newAddress ) public onlyOwner returns (bool){\n\n   factory = UniswapFactory( newAddress);\n   uniFactoryAddress = newAddress;\n   return true;\n\n }\n\n\n  function conductUniswap(address sellToken, address buyToken, uint amount) internal returns (uint256 amounts1){\n\n            if(sellToken ==ETH_TOKEN_ADDRESS && buyToken == WETH_TOKEN_ADDRESS){\n                wethToken.deposit{value:msg.value}();\n            }\n            else if(sellToken == address(0x0)){\n\n               // address [] memory addresses = new address[](2);\n               address [] memory addresses = getBestPath(WETH_TOKEN_ADDRESS, buyToken, amount);\n                //addresses[0] = WETH_TOKEN_ADDRESS;\n                //addresses[1] = buyToken;\n                sushiExchange.swapExactETHForTokens{value:msg.value}(0, addresses, address(this), 1000000000000000 );\n\n            }\n\n            else if(sellToken == WETH_TOKEN_ADDRESS){\n                wethToken.withdraw(amount);\n\n                //address [] memory addresses = new address[](2);\n                address [] memory addresses = getBestPath(WETH_TOKEN_ADDRESS, buyToken, amount);\n                //addresses[0] = WETH_TOKEN_ADDRESS;\n                //addresses[1] = buyToken;\n                sushiExchange.swapExactETHForTokens{value:amount}(0, addresses, address(this), 1000000000000000 );\n\n            }\n\n\n\n            else{\n\n          address [] memory addresses = getBestPath(sellToken, buyToken, amount);\n           uint256 [] memory amounts = conductUniswapT4T(addresses, amount );\n           uint256 resultingTokens = amounts[amounts.length-1];\n           return resultingTokens;\n            }\n    }\n\n\n    //gets the best path to route the transaction on Uniswap\n    function getBestPath(address sellToken, address buyToken, uint256 amount) public view returns (address[] memory){\n\n        address [] memory defaultPath =new address[](2);\n        defaultPath[0]=sellToken;\n        defaultPath[1] = buyToken;\n\n\n        if(presetPaths[sellToken][buyToken].length !=0){\n            return presetPaths[sellToken][buyToken];\n        }\n\n\n        if(sellToken == stablecoins[\"DAI\"] || sellToken == stablecoins[\"USDC\"] || sellToken == stablecoins[\"USDT\"]){\n            return defaultPath;\n        }\n        if(buyToken == stablecoins[\"DAI\"] || buyToken == stablecoins[\"USDC\"] || buyToken == stablecoins[\"USDT\"]){\n            return defaultPath;\n        }\n\n\n\n        address[] memory daiPath = new address[](3);\n        address[] memory usdcPath =new address[](3);\n        address[] memory usdtPath =new address[](3);\n\n        daiPath[0] = sellToken;\n        daiPath[1] = stablecoins[\"DAI\"];\n        daiPath[2] = buyToken;\n\n        usdcPath[0] = sellToken;\n        usdcPath[1] = stablecoins[\"USDC\"];\n        usdcPath[2] = buyToken;\n\n        usdtPath[0] = sellToken;\n        usdtPath[1] = stablecoins[\"USDT\"];\n        usdtPath[2] = buyToken;\n\n\n        uint256 directPathOutput =  getPriceFromUniswap(defaultPath, amount)[1];\n\n\n        uint256[] memory daiPathOutputRaw = getPriceFromUniswap(daiPath, amount);\n        uint256[]  memory usdtPathOutputRaw = getPriceFromUniswap(usdtPath, amount);\n        uint256[]  memory usdcPathOutputRaw = getPriceFromUniswap(usdcPath, amount);\n\n        //uint256 directPathOutput = directPathOutputRaw[directPathOutputRaw.length-1];\n        uint256 daiPathOutput = daiPathOutputRaw[daiPathOutputRaw.length-1];\n        uint256 usdtPathOutput = usdtPathOutputRaw[usdtPathOutputRaw.length-1];\n        uint256 usdcPathOutput = usdcPathOutputRaw[usdcPathOutputRaw.length-1];\n\n        uint256 bestPathOutput = directPathOutput;\n        address[] memory bestPath = new address[](2);\n        address[] memory bestPath3 = new address[](3);\n        //return defaultPath;\n        bestPath = defaultPath;\n\n        bool isTwoPath = true;\n\n        if(directPathOutput < daiPathOutput){\n            isTwoPath=false;\n            bestPathOutput = daiPathOutput;\n            bestPath3 = daiPath;\n        }\n        if(bestPathOutput < usdcPathOutput){\n            isTwoPath=false;\n            bestPathOutput = usdcPathOutput;\n            bestPath3 = usdcPath;\n        }\n         if(bestPathOutput < usdtPathOutput){\n             isTwoPath=false;\n            bestPathOutput = usdtPathOutput;\n            bestPath3 = usdtPath;\n        }\n\n        require(bestPathOutput >0, \"This trade will result in getting zero tokens back. Reverting\");\n\n        if(isTwoPath==true){\n              return bestPath;\n        }\n        else{\n            return bestPath3;\n        }\n\n\n\n    }\n\n    function getPriceFromUniswap(address  [] memory theAddresses, uint amount) public view returns (uint256[] memory amounts1){\n\n\n        try sushiExchange.getAmountsOut(amount,theAddresses ) returns (uint256[] memory amounts){\n            return amounts;\n        }\n        catch  {\n            uint256 [] memory amounts2= new uint256[](2);\n            amounts2[0]=0;\n            amounts2[1]=0;\n            return amounts2;\n\n        }\n\n    }\n\n    function conductUniswapT4T(address  [] memory theAddresses, uint amount) internal returns (uint256[] memory amounts1){\n\n           uint256 deadline = 1000000000000000;\n           uint256 [] memory amounts =  sushiExchange.swapExactTokensForTokens(amount, 0, theAddresses, address(this),deadline );\n           return amounts;\n\n    }\n\n    function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          ERC20 tokenToken = ERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n      return true;\n  }\n\n\n  function setFee(uint256 newFee) public onlyOwner returns (bool){\n    require(newFee<=maxfee, \"Admin cannot set the fee higher than the current maxfee\");\n    fee = newFee;\n    return true;\n  }\n\n\n  function setMaxFee(uint256 newMax) public onlyOwner returns (bool){\n    require(maxfee==0, \"Admin can only set max fee once and it is perm\");\n    maxfee = newMax;\n    return true;\n  }\n\n  function addLPPair(address lpAddress, address token1, address token2) onlyOwner public returns (bool){\n      lpTokenAddressToPairs[lpAddress] = [token1, token2];\n      return true;\n  }\n\n  function getLPTokenByPair(address token1, address token2) view public returns (address lpAddr){\n      address thisPairAddress = factory.getPair(token1,token2);\n      return thisPairAddress;\n  }\n\n   function getUserTokenBalance(address userAddress, address tokenAddress) public view returns (uint256){\n    ERC20 token = ERC20(tokenAddress);\n    return token.balanceOf(userAddress);\n\n  }\n\n}"
    }
  }
}