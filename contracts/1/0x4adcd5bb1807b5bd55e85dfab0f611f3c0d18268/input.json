{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ninterface IERC20Mintable {\n  function mint( uint256 amount_ ) external;\n\n  function mint( address account_, uint256 ammount_ ) external;\n}\n"},"contracts/libraries/SafeMath.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function sqrrt(uint256 a) internal pure returns (uint c) {\n        if (a > 3) {\n            c = a;\n            uint b = add( div( a, 2), 1 );\n            while (b < c) {\n                c = b;\n                b = div( add( div( a, b ), b), 2 );\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n}\n"},"contracts/presale/AxeCirculatingSupply.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\\\npragma solidity 0.7.5;\n\nimport \"../interfaces/IERC20.sol\";\n\nimport \"../libraries/SafeMath.sol\";\n\ncontract AxeCirculatingSupply {\n    using SafeMath for uint;\n\n    bool public isInitialized;\n\n    address public AXE;\n    address public owner;\n    address[] public nonCirculatingAXEAddresses;\n\n    constructor( address _owner ) {\n        owner = _owner;\n    }\n\n    function initialize( address _axe ) external returns ( bool ) {\n        require( msg.sender == owner, \"caller is not owner\" );\n        require( isInitialized == false );\n\n        AXE = _axe;\n\n        isInitialized = true;\n\n        return true;\n    }\n\n    function AXECirculatingSupply() external view returns ( uint ) {\n        uint _totalSupply = IERC20( AXE ).totalSupply();\n\n        uint _circulatingSupply = _totalSupply.sub( getNonCirculatingAXE() );\n\n        return _circulatingSupply;\n    }\n\n    function getNonCirculatingAXE() public view returns ( uint ) {\n        uint _nonCirculatingAXE;\n\n        for( uint i=0; i < nonCirculatingAXEAddresses.length; i = i.add( 1 ) ) {\n            _nonCirculatingAXE = _nonCirculatingAXE.add( IERC20( AXE ).balanceOf( nonCirculatingAXEAddresses[i] ) );\n        }\n\n        return _nonCirculatingAXE;\n    }\n\n    function setNonCirculatingAXEAddresses( address[] calldata _nonCirculatingAddresses ) external returns ( bool ) {\n        require( msg.sender == owner, \"Sender is not owner\" );\n        nonCirculatingAXEAddresses = _nonCirculatingAddresses;\n\n        return true;\n    }\n\n    function transferOwnership( address _owner ) external returns ( bool ) {\n        require( msg.sender == owner, \"Sender is not owner\" );\n\n        owner = _owner;\n\n        return true;\n    }\n}\n"}}}