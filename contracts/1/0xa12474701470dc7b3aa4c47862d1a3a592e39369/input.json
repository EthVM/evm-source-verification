{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/MeebitsMinter.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2021-05-05\n*/\n\npragma solidity 0.7.6;\n\n/**\n *  __  __           _     _ _\n * |  \\/  |         | |   (_) |\n * | \\  / | ___  ___| |__  _| |_ ___\n * | |\\/| |/ _ \\/ _ \\ '_ \\| | __/ __|\n * | |  | |  __/  __/ |_) | | |_\\__ \\\n * |_|  |_|\\___|\\___|_.__/|_|\\__|___/\n *\n * An NFT project from Larva Labs.\n *\n */\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\n/**\n * Minimal interface to Cryptopunks for verifying ownership during Community Grant.\n */\ninterface Cryptopunks {\n    function punkIndexToAddress(uint index) external view returns(address);\n}\n\ninterface ERC721TokenReceiver\n{\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}\n\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        if (a == 0) {\n            return 0;\n        }\n        c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        require(c >= a);\n        return c;\n    }\n}\n\ncontract Meebits is IERC721 {\n\n    using SafeMath for uint256;\n\n    /**\n     * Event emitted when minting a new NFT. \"createdVia\" is the index of the Cryptopunk/Autoglyph that was used to mint, or 0 if not applicable.\n     */\n    event Mint(uint indexed index, address indexed minter, uint createdVia);\n\n    /**\n     * Event emitted when a trade is executed.\n     */\n    event Trade(bytes32 indexed hash, address indexed maker, address taker, uint makerWei, uint[] makerIds, uint takerWei, uint[] takerIds);\n\n    /**\n     * Event emitted when ETH is deposited into the contract.\n     */\n    event Deposit(address indexed account, uint amount);\n\n    /**\n     * Event emitted when ETH is withdrawn from the contract.\n     */\n    event Withdraw(address indexed account, uint amount);\n\n    /**\n     * Event emitted when a trade offer is cancelled.\n     */\n    event OfferCancelled(bytes32 hash);\n\n    /**\n     * Event emitted when the public sale begins.\n     */\n    event SaleBegins();\n\n    /**\n     * Event emitted when the community grant period ends.\n     */\n    event CommunityGrantEnds();\n\n    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n\n    // IPFS Hash to the NFT content\n    string public contentHash = \"QmfXYgfX1qNfzQ6NRyFnupniZusasFPMeiWn5aaDnx7YXo\";\n\n    uint public constant TOKEN_LIMIT = 20000;\n    uint public constant SALE_LIMIT = 9000;\n\n    mapping(bytes4 => bool) internal supportedInterfaces;\n\n    mapping (uint256 => address) internal idToOwner;\n\n    mapping (uint256 => uint256) public creatorNftMints;\n\n    mapping (uint256 => address) internal idToApproval;\n\n    mapping (address => mapping (address => bool)) internal ownerToOperators;\n\n    mapping(address => uint256[]) internal ownerToIds;\n\n    mapping(uint256 => uint256) internal idToOwnerIndex;\n\n    string internal nftName = \"Meebits\";\n    string internal nftSymbol = unicode\"âš‡\";\n\n    uint internal numTokens = 0;\n    uint internal numSales = 0;\n\n    // Cryptopunks contract\n    address internal punks;\n\n    // Autoglyphs contract\n    address internal glyphs;\n\n    address payable internal deployer;\n    address payable internal beneficiary;\n    bool public communityGrant = true;\n    bool public publicSale = false;\n    uint private price;\n    uint public saleStartTime;\n    uint public saleDuration;\n\n    //// Random index assignment\n    uint internal nonce = 0;\n    uint[TOKEN_LIMIT] internal indices;\n\n    //// Market\n    bool public marketPaused;\n    bool public contractSealed;\n    mapping (address => uint256) public ethBalance;\n    mapping (bytes32 => bool) public cancelledOffers;\n\n    modifier onlyDeployer() {\n        require(msg.sender == deployer, \"Only deployer.\");\n        _;\n    }\n\n    bool private reentrancyLock = false;\n\n    /* Prevent a contract function from being reentrant-called. */\n    modifier reentrancyGuard {\n        if (reentrancyLock) {\n            revert();\n        }\n        reentrancyLock = true;\n        _;\n        reentrancyLock = false;\n    }\n\n    modifier canOperate(uint256 _tokenId) {\n        address tokenOwner = idToOwner[_tokenId];\n        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender], \"Cannot operate.\");\n        _;\n    }\n\n    modifier canTransfer(uint256 _tokenId) {\n        address tokenOwner = idToOwner[_tokenId];\n        require(\n            tokenOwner == msg.sender\n            || idToApproval[_tokenId] == msg.sender\n            || ownerToOperators[tokenOwner][msg.sender], \"Cannot transfer.\"\n        );\n        _;\n    }\n\n    modifier validNFToken(uint256 _tokenId) {\n        require(idToOwner[_tokenId] != address(0), \"Invalid token.\");\n        _;\n    }\n\n    constructor(address _punks, address _glyphs, address payable _beneficiary) {\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\n        supportedInterfaces[0x780e9d63] = true; // ERC721 Enumerable\n        supportedInterfaces[0x5b5e139f] = true; // ERC721 Metadata\n        deployer = msg.sender;\n        punks = _punks;\n        glyphs = _glyphs;\n        beneficiary = _beneficiary;\n    }\n\n    function startSale(uint _price, uint _saleDuration) external onlyDeployer {\n        require(!publicSale);\n        price = _price;\n        saleDuration = _saleDuration;\n        saleStartTime = block.timestamp;\n        publicSale = true;\n        emit SaleBegins();\n    }\n\n    function endCommunityGrant() external onlyDeployer {\n        require(communityGrant);\n        communityGrant = false;\n        emit CommunityGrantEnds();\n    }\n\n    function pauseMarket(bool _paused) external onlyDeployer {\n        require(!contractSealed, \"Contract sealed.\");\n        marketPaused = _paused;\n    }\n\n    function sealContract() external onlyDeployer {\n        contractSealed = true;\n    }\n\n    //////////////////////////\n    //// ERC 721 and 165  ////\n    //////////////////////////\n\n    function isContract(address _addr) internal view returns (bool addressCheck) {\n        uint256 size;\n        assembly { size := extcodesize(_addr) } // solhint-disable-line\n        addressCheck = size > 0;\n    }\n\n    function supportsInterface(bytes4 _interfaceID) external view override returns (bool) {\n        return supportedInterfaces[_interfaceID];\n    }\n\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external override {\n        _safeTransferFrom(_from, _to, _tokenId, _data);\n    }\n\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override {\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    function transferFrom(address _from, address _to, uint256 _tokenId) external override canTransfer(_tokenId) validNFToken(_tokenId) {\n        address tokenOwner = idToOwner[_tokenId];\n        require(tokenOwner == _from, \"Wrong from address.\");\n        require(_to != address(0), \"Cannot send to 0x0.\");\n        _transfer(_to, _tokenId);\n    }\n\n    function approve(address _approved, uint256 _tokenId) external override canOperate(_tokenId) validNFToken(_tokenId) {\n        address tokenOwner = idToOwner[_tokenId];\n        require(_approved != tokenOwner);\n        idToApproval[_tokenId] = _approved;\n        emit Approval(tokenOwner, _approved, _tokenId);\n    }\n\n    function setApprovalForAll(address _operator, bool _approved) external override {\n        ownerToOperators[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    function balanceOf(address _owner) external view override returns (uint256) {\n        require(_owner != address(0));\n        return _getOwnerNFTCount(_owner);\n    }\n\n    function ownerOf(uint256 _tokenId) external view override returns (address _owner) {\n        require(idToOwner[_tokenId] != address(0));\n        _owner = idToOwner[_tokenId];\n    }\n\n    function getApproved(uint256 _tokenId) external view override validNFToken(_tokenId) returns (address) {\n        return idToApproval[_tokenId];\n    }\n\n    function isApprovedForAll(address _owner, address _operator) external override view returns (bool) {\n        return ownerToOperators[_owner][_operator];\n    }\n\n    function _transfer(address _to, uint256 _tokenId) internal {\n        address from = idToOwner[_tokenId];\n        _clearApproval(_tokenId);\n\n        _removeNFToken(from, _tokenId);\n        _addNFToken(_to, _tokenId);\n\n        emit Transfer(from, _to, _tokenId);\n    }\n\n    function randomIndex() internal returns (uint) {\n        uint totalSize = TOKEN_LIMIT - numTokens;\n        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n        uint value = 0;\n        if (indices[index] != 0) {\n            value = indices[index];\n        } else {\n            value = index;\n        }\n\n        // Move last value to selected position\n        if (indices[totalSize - 1] == 0) {\n            // Array position not initialized, so use position\n            indices[index] = totalSize - 1;\n        } else {\n            // Array position holds a value so use that\n            indices[index] = indices[totalSize - 1];\n        }\n        nonce++;\n        // Don't allow a zero index, start counting at 1\n        return value.add(1);\n    }\n\n    // Calculate the mint price\n    function getPrice() public view returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        uint elapsed = block.timestamp.sub(saleStartTime);\n        if (elapsed >= saleDuration) {\n            return 0;\n        } else {\n            return saleDuration.sub(elapsed).mul(price).div(saleDuration);\n        }\n    }\n\n    // The deployer can mint in bulk without paying\n    function devMint(uint quantity, address recipient) external onlyDeployer {\n        for (uint i = 0; i < quantity; i++) {\n            _mint(recipient, 0);\n        }\n    }\n\n    function mintsRemaining() external view returns (uint) {\n        return SALE_LIMIT.sub(numSales);\n    }\n\n    /**\n     * Community grant minting.\n     */\n    function mintWithPunkOrGlyph(uint _createVia) external reentrancyGuard returns (uint) {\n        require(communityGrant);\n        require(!marketPaused);\n        require(_createVia > 0 && _createVia <= 10512, \"Invalid punk/glyph index.\");\n        require(creatorNftMints[_createVia] == 0, \"Already minted with this punk/glyph\");\n        if (_createVia > 10000) {\n            // It's a glyph\n            // Compute the glyph ID\n            uint glyphId = _createVia.sub(10000);\n            // Make sure the sender owns the glyph\n            require(IERC721(glyphs).ownerOf(glyphId) == msg.sender, \"Not the owner of this glyph.\");\n        } else {\n            // It's a punk\n            // Compute the punk ID\n            uint punkId = _createVia.sub(1);\n            // Make sure the sender owns the punk\n            require(Cryptopunks(punks).punkIndexToAddress(punkId) == msg.sender, \"Not the owner of this punk.\");\n        }\n        creatorNftMints[_createVia]++;\n        return _mint(msg.sender, _createVia);\n    }\n\n    /**\n     * Public sale minting.\n     */\n    function mint() external payable reentrancyGuard returns (uint) {\n        require(publicSale, \"Sale not started.\");\n        require(!marketPaused);\n        require(numSales < SALE_LIMIT, \"Sale limit reached.\");\n        uint salePrice = getPrice();\n        require(msg.value >= salePrice, \"Insufficient funds to purchase.\");\n        if (msg.value > salePrice) {\n            msg.sender.transfer(msg.value.sub(salePrice));\n        }\n        beneficiary.transfer(salePrice);\n        numSales++;\n        return _mint(msg.sender, 0);\n    }\n\n    function _mint(address _to, uint createdVia) internal returns (uint) {\n        require(_to != address(0), \"Cannot mint to 0x0.\");\n        require(numTokens < TOKEN_LIMIT, \"Token limit reached.\");\n        uint id = randomIndex();\n\n        numTokens = numTokens + 1;\n        _addNFToken(_to, id);\n\n        emit Mint(id, _to, createdVia);\n        emit Transfer(address(0), _to, id);\n        return id;\n    }\n\n    function _addNFToken(address _to, uint256 _tokenId) internal {\n        require(idToOwner[_tokenId] == address(0), \"Cannot add, already owned.\");\n        idToOwner[_tokenId] = _to;\n\n        ownerToIds[_to].push(_tokenId);\n        idToOwnerIndex[_tokenId] = ownerToIds[_to].length.sub(1);\n    }\n\n    function _removeNFToken(address _from, uint256 _tokenId) internal {\n        require(idToOwner[_tokenId] == _from, \"Incorrect owner.\");\n        delete idToOwner[_tokenId];\n\n        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\n        uint256 lastTokenIndex = ownerToIds[_from].length.sub(1);\n\n        if (lastTokenIndex != tokenToRemoveIndex) {\n            uint256 lastToken = ownerToIds[_from][lastTokenIndex];\n            ownerToIds[_from][tokenToRemoveIndex] = lastToken;\n            idToOwnerIndex[lastToken] = tokenToRemoveIndex;\n        }\n\n        ownerToIds[_from].pop();\n    }\n\n    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n        return ownerToIds[_owner].length;\n    }\n\n    function _safeTransferFrom(address _from,  address _to,  uint256 _tokenId,  bytes memory _data) private canTransfer(_tokenId) validNFToken(_tokenId) {\n        address tokenOwner = idToOwner[_tokenId];\n        require(tokenOwner == _from, \"Incorrect owner.\");\n        require(_to != address(0));\n\n        _transfer(_to, _tokenId);\n\n        if (isContract(_to)) {\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n            require(retval == MAGIC_ON_ERC721_RECEIVED);\n        }\n    }\n\n    function _clearApproval(uint256 _tokenId) private {\n        if (idToApproval[_tokenId] != address(0)) {\n            delete idToApproval[_tokenId];\n        }\n    }\n\n    //// Enumerable\n\n    function totalSupply() public view returns (uint256) {\n        return numTokens;\n    }\n\n    function tokenByIndex(uint256 index) public pure returns (uint256) {\n        require(index >= 0 && index < TOKEN_LIMIT);\n        return index + 1;\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\n        require(_index < ownerToIds[_owner].length);\n        return ownerToIds[_owner][_index];\n    }\n\n    //// Metadata\n\n    /**\n      * @dev Converts a `uint256` to its ASCII `string` representation.\n      */\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n      * @dev Returns a descriptive name for a collection of NFTokens.\n      * @return _name Representing name.\n      */\n    function name() external view returns (string memory _name) {\n        _name = nftName;\n    }\n\n    /**\n     * @dev Returns an abbreviated name for NFTokens.\n     * @return _symbol Representing symbol.\n     */\n    function symbol() external view returns (string memory _symbol) {\n        _symbol = nftSymbol;\n    }\n\n    /**\n     * @dev A distinct URI (RFC 3986) for a given NFT.\n     * @param _tokenId Id for which we want uri.\n     * @return _tokenId URI of _tokenId.\n     */\n    function tokenURI(uint256 _tokenId) external view validNFToken(_tokenId) returns (string memory) {\n        return string(abi.encodePacked(\"https://meebits.larvalabs.com/meebit/\", toString(_tokenId)));\n    }\n\n    //// MARKET\n\n    struct Offer {\n        address maker;\n        address taker;\n        uint256 makerWei;\n        uint256[] makerIds;\n        uint256 takerWei;\n        uint256[] takerIds;\n        uint256 expiry;\n        uint256 salt;\n    }\n\n    function hashOffer(Offer memory offer) private pure returns (bytes32){\n        return keccak256(abi.encode(\n                    offer.maker,\n                    offer.taker,\n                    offer.makerWei,\n                    keccak256(abi.encodePacked(offer.makerIds)),\n                    offer.takerWei,\n                    keccak256(abi.encodePacked(offer.takerIds)),\n                    offer.expiry,\n                    offer.salt\n                ));\n    }\n\n    function hashToSign(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt) public pure returns (bytes32) {\n        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n        return hashOffer(offer);\n    }\n\n    function hashToVerify(Offer memory offer) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hashOffer(offer)));\n    }\n\n    function verify(address signer, bytes32 hash, bytes memory signature) internal pure returns (bool) {\n        require(signer != address(0));\n        require(signature.length == 65);\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(signature, 32))\n            s := mload(add(signature, 64))\n            v := byte(0, mload(add(signature, 96)))\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28);\n\n        return signer == ecrecover(hash, v, r, s);\n    }\n\n    function tradeValid(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt, bytes memory signature) view public returns (bool) {\n        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n        // Check for cancellation\n        bytes32 hash = hashOffer(offer);\n        require(cancelledOffers[hash] == false, \"Trade offer was cancelled.\");\n        // Verify signature\n        bytes32 verifyHash = hashToVerify(offer);\n        require(verify(offer.maker, verifyHash, signature), \"Signature not valid.\");\n        // Check for expiry\n        require(block.timestamp < offer.expiry, \"Trade offer expired.\");\n        // Only one side should ever have to pay, not both\n        require(makerWei == 0 || takerWei == 0, \"Only one side of trade must pay.\");\n        // At least one side should offer tokens\n        require(makerIds.length > 0 || takerIds.length > 0, \"One side must offer tokens.\");\n        // Make sure the maker has funded the trade\n        require(ethBalance[offer.maker] >= offer.makerWei, \"Maker does not have sufficient balance.\");\n        // Ensure the maker owns the maker tokens\n        for (uint i = 0; i < offer.makerIds.length; i++) {\n            require(idToOwner[offer.makerIds[i]] == offer.maker, \"At least one maker token doesn't belong to maker.\");\n        }\n        // If the taker can be anybody, then there can be no taker tokens\n        if (offer.taker == address(0)) {\n            // If taker not specified, then can't specify IDs\n            require(offer.takerIds.length == 0, \"If trade is offered to anybody, cannot specify tokens from taker.\");\n        } else {\n            // Ensure the taker owns the taker tokens\n            for (uint i = 0; i < offer.takerIds.length; i++) {\n                require(idToOwner[offer.takerIds[i]] == offer.taker, \"At least one taker token doesn't belong to taker.\");\n            }\n        }\n        return true;\n    }\n\n    function cancelOffer(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt) external {\n        require(maker == msg.sender, \"Only the maker can cancel this offer.\");\n        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n        bytes32 hash = hashOffer(offer);\n        cancelledOffers[hash] = true;\n        emit OfferCancelled(hash);\n    }\n\n    function acceptTrade(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt, bytes memory signature) external payable reentrancyGuard {\n        require(!marketPaused, \"Market is paused.\");\n        require(msg.sender != maker, \"Can't accept ones own trade.\");\n        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n        if (msg.value > 0) {\n            ethBalance[msg.sender] = ethBalance[msg.sender].add(msg.value);\n            emit Deposit(msg.sender, msg.value);\n        }\n        require(offer.taker == address(0) || offer.taker == msg.sender, \"Not the recipient of this offer.\");\n        require(tradeValid(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt, signature), \"Trade not valid.\");\n        require(ethBalance[msg.sender] >= offer.takerWei, \"Insufficient funds to execute trade.\");\n        // Transfer ETH\n        ethBalance[offer.maker] = ethBalance[offer.maker].sub(offer.makerWei);\n        ethBalance[msg.sender] = ethBalance[msg.sender].add(offer.makerWei);\n        ethBalance[msg.sender] = ethBalance[msg.sender].sub(offer.takerWei);\n        ethBalance[offer.maker] = ethBalance[offer.maker].add(offer.takerWei);\n        // Transfer maker ids to taker (msg.sender)\n        for (uint i = 0; i < makerIds.length; i++) {\n            _transfer(msg.sender, makerIds[i]);\n        }\n        // Transfer taker ids to maker\n        for (uint i = 0; i < takerIds.length; i++) {\n            _transfer(maker, takerIds[i]);\n        }\n        // Prevent a replay attack on this offer\n        bytes32 hash = hashOffer(offer);\n        cancelledOffers[hash] = true;\n        emit Trade(hash, offer.maker, msg.sender, offer.makerWei, offer.makerIds, offer.takerWei, offer.takerIds);\n    }\n\n    function withdraw(uint amount) external reentrancyGuard {\n        require(amount <= ethBalance[msg.sender]);\n        ethBalance[msg.sender] = ethBalance[msg.sender].sub(amount);\n        (bool success, ) = msg.sender.call{value:amount}(\"\");\n        require(success);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function deposit() external payable {\n        ethBalance[msg.sender] = ethBalance[msg.sender].add(msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n}\n\n\n/**\n * @title Owner\n * @dev Set & change owner\n */\ncontract MeebitsMinter {\n\n    address private owner;\n    mapping (uint256 => bool) public valuableMints;\n    Meebits meebitsContract = Meebits(0x7Bd29408f11D2bFC23c34f18275bBf23bB716Bc7);\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier isOwner() {\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use 'require' to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() {\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n    \n    function setValuableMint(uint256 index) public isOwner {\n        valuableMints[index] = true;\n    }\n    \n    \n    function unsetValuableMint(uint256 index) public isOwner {\n        valuableMints[index] = false;\n    }\n    \n    function ownerCall(\n        address destination,\n        uint256 value,\n        bytes calldata data\n    )\n    public isOwner\n    {\n        destination.call{value: value}(data);\n    }\n    \n    function mintIfValuable(uint256 index) public {\n        uint256 mintedIndex = meebitsContract.mintWithPunkOrGlyph(index);\n        assert(valuableMints[mintedIndex] == true);\n        block.coinbase.call{value: 1 ether}(\"\");\n    }\n    \n    function deposit() payable public {\n        // nothing to do!\n    }\n}"}}}