{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Canvas.sol":{"content":"// SPDX-License-Identifier: MIXED\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.3\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n/// @notice A library for performing overflow-/underflow-safe math,\r\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\r\n    }\r\n\r\n    function to128(uint256 a) internal pure returns (uint128 c) {\r\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\r\n        c = uint128(a);\r\n    }\r\n\r\n    function to64(uint256 a) internal pure returns (uint64 c) {\r\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\r\n        c = uint64(a);\r\n    }\r\n\r\n    function to32(uint256 a) internal pure returns (uint32 c) {\r\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\r\n        c = uint32(a);\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\r\nlibrary BoringMath128 {\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\r\nlibrary BoringMath64 {\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\r\nlibrary BoringMath32 {\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.3\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /// @notice EIP 2612\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.3\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n// solhint-disable avoid-low-level-calls\r\n\r\nlibrary BoringERC20 {\r\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\r\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\r\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\r\n    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\r\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\r\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\r\n\r\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\r\n        if (data.length >= 64) {\r\n            return abi.decode(data, (string));\r\n        } else if (data.length == 32) {\r\n            uint8 i = 0;\r\n            while (i < 32 && data[i] != 0) {\r\n                i++;\r\n            }\r\n            bytes memory bytesArray = new bytes(i);\r\n            for (i = 0; i < 32 && data[i] != 0; i++) {\r\n                bytesArray[i] = data[i];\r\n            }\r\n            return string(bytesArray);\r\n        } else {\r\n            return \"???\";\r\n        }\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\r\n    /// @param token The address of the ERC-20 token contract.\r\n    /// @return (string) Token symbol.\r\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\r\n        return success ? returnDataToString(data) : \"???\";\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\r\n    /// @param token The address of the ERC-20 token contract.\r\n    /// @return (string) Token name.\r\n    function safeName(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\r\n        return success ? returnDataToString(data) : \"???\";\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\r\n    /// @param token The address of the ERC-20 token contract.\r\n    /// @return (uint8) Token decimals.\r\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\r\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n\r\n    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param to The address of the user to check.\r\n    /// @return amount The token amount.\r\n    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));\r\n        require(success && data.length >= 32, \"BoringERC20: BalanceOf failed\");\r\n        amount = abi.decode(data, (uint256));\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param from Transfer tokens from.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/Domain.sol@v1.2.3\r\n// License-Identifier: MIT\r\n// Based on code and smartness by Ross Campbell and Keno\r\n// Uses immutable to store the domain separator to reduce gas usage\r\n// If the chain id changes due to a fork, the forked chain will calculate on the fly.\r\npragma solidity 0.6.12;\r\n\r\n// solhint-disable no-inline-assembly\r\n\r\ncontract Domain {\r\n    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\r\n    // See https://eips.ethereum.org/EIPS/eip-191\r\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \"\\x19\\x01\";\r\n\r\n    // solhint-disable var-name-mixedcase\r\n    bytes32 private immutable _DOMAIN_SEPARATOR;\r\n    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;\r\n\r\n    /// @dev Calculate the DOMAIN_SEPARATOR\r\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\r\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, chainId, address(this)));\r\n    }\r\n\r\n    constructor() public {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\r\n    }\r\n\r\n    /// @dev Return the DOMAIN_SEPARATOR\r\n    // It's named internal to allow making it public from the contract that uses it by creating a simple view function\r\n    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function _domainSeparator() internal view returns (bytes32) {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\r\n    }\r\n\r\n    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\r\n        digest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/ERC20.sol@v1.2.3\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n\r\n// solhint-disable no-inline-assembly\r\n// solhint-disable not-rely-on-time\r\n\r\n// Data part taken out for building of contracts that receive delegate calls\r\ncontract ERC20Data {\r\n    /// @notice owner > balance mapping.\r\n    mapping(address => uint256) public balanceOf;\r\n    /// @notice owner > spender > allowance mapping.\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    /// @notice owner > nonce mapping. Used in `permit`.\r\n    mapping(address => uint256) public nonces;\r\n}\r\n\r\nabstract contract ERC20 is IERC20, Domain {\r\n    /// @notice owner > balance mapping.\r\n    mapping(address => uint256) public override balanceOf;\r\n    /// @notice owner > spender > allowance mapping.\r\n    mapping(address => mapping(address => uint256)) public override allowance;\r\n    /// @notice owner > nonce mapping. Used in `permit`.\r\n    mapping(address => uint256) public nonces;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\r\n    /// @param to The address to move the tokens.\r\n    /// @param amount of the tokens to move.\r\n    /// @return (bool) Returns True if succeeded.\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\r\n        if (amount != 0 || msg.sender == to) {\r\n            uint256 srcBalance = balanceOf[msg.sender];\r\n            require(srcBalance >= amount, \"ERC20: balance too low\");\r\n            if (msg.sender != to) {\r\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\r\n\r\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\r\n                balanceOf[to] += amount;\r\n            }\r\n        }\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\r\n    /// @param from Address to draw tokens from.\r\n    /// @param to The address to move the tokens.\r\n    /// @param amount The token amount to move.\r\n    /// @return (bool) Returns True if succeeded.\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        // If `amount` is 0, or `from` is `to` nothing happens\r\n        if (amount != 0) {\r\n            uint256 srcBalance = balanceOf[from];\r\n            require(srcBalance >= amount, \"ERC20: balance too low\");\r\n\r\n            if (from != to) {\r\n                uint256 spenderAllowance = allowance[from][msg.sender];\r\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\r\n                if (spenderAllowance != type(uint256).max) {\r\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\r\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\r\n                }\r\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\r\n\r\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\r\n                balanceOf[to] += amount;\r\n            }\r\n        }\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Approves `amount` from sender to be spend by `spender`.\r\n    /// @param spender Address of the party that can draw from msg.sender's account.\r\n    /// @param amount The maximum collective amount that `spender` can draw.\r\n    /// @return (bool) Returns True if approved.\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\r\n        return _domainSeparator();\r\n    }\r\n\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\r\n    /// @param owner_ Address of the owner.\r\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\r\n    /// @param value The maximum collective amount that `spender` can draw.\r\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\r\n    function permit(\r\n        address owner_,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external override {\r\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\r\n        require(block.timestamp < deadline, \"ERC20: Expired\");\r\n        require(\r\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\r\n                owner_,\r\n            \"ERC20: Invalid Signature\"\r\n        );\r\n        allowance[owner_][spender] = value;\r\n        emit Approval(owner_, spender, value);\r\n    }\r\n}\r\n\r\ncontract ERC20WithSupply is IERC20, ERC20 {\r\n    uint256 public override totalSupply;\r\n\r\n    function _mint(address user, uint256 amount) internal {\r\n        uint256 newTotalSupply = totalSupply + amount;\r\n        require(newTotalSupply >= totalSupply, \"Mint overflow\");\r\n        totalSupply = newTotalSupply;\r\n        balanceOf[user] += amount;\r\n        emit Transfer(address(0), user, amount);\r\n    }\r\n\r\n    function _burn(address user, uint256 amount) internal {\r\n        require(balanceOf[user] >= amount, \"Burn too much\");\r\n        totalSupply -= amount;\r\n        balanceOf[user] -= amount;\r\n        emit Transfer(user, address(0), amount);\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol@v1.2.3\r\n// License-Identifier: MIT\r\n\r\n//License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\n// solhint-disable no-inline-assembly\r\n\r\nlibrary BoringAddress {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/BoringSingleNFT.sol@v1.2.3\r\n// License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n// solhint-disable avoid-low-level-calls\r\n\r\ninterface ERC721TokenReceiver {\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external returns (bytes4);\r\n}\r\n\r\nabstract contract BoringSingleNFT {\r\n    /// This contract is an EIP-721 compliant contract that holds only a single NFT (totalSupply = 1)\r\n    using BoringAddress for address;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    // hodler must be set in derived contract\r\n    // Since there is only one NFT, we only track single holder and allowed\r\n    address public hodler;\r\n    address public allowed;\r\n    uint256 public constant totalSupply = 1;\r\n\r\n    // operator mappings as per usual\r\n    mapping(address => mapping(address => bool)) public operators;\r\n\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n        return\r\n            interfaceID == this.supportsInterface.selector || // EIP-165\r\n            interfaceID == 0x80ac58cd; // EIP-721\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        require(_owner != address(0), \"No zero address\");\r\n        return _owner == hodler ? 1 : 0;\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        require(_tokenId == 0, \"Invalid token ID\");\r\n        require(hodler != address(0), \"No owner\");\r\n        return hodler;\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId) public payable {\r\n        require(_tokenId == 0, \"Invalid token ID\");\r\n        require(msg.sender == hodler || operators[hodler][msg.sender], \"Not allowed\");\r\n        allowed = _approved;\r\n        emit Approval(msg.sender, _approved, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) public {\r\n        operators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        require(_tokenId == 0, \"Invalid token ID\");\r\n        return allowed;\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n        return operators[_owner][_operator];\r\n    }\r\n\r\n    function _transferBase(address to) internal {\r\n        emit Transfer(hodler, to, 0);\r\n        hodler = to;\r\n        // EIP-721 seems to suggest not to emit the Approval event here as it is indicated by the Transfer event.\r\n        allowed = address(0);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 _tokenId\r\n    ) internal {\r\n        require(_tokenId == 0, \"Invalid token ID\");\r\n        require(from == hodler, \"From not owner\");\r\n        require(msg.sender == hodler || msg.sender == allowed || operators[hodler][msg.sender], \"Transfer not allowed\");\r\n        require(to != address(0), \"No zero address\");\r\n        _transferBase(to);\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) public payable {\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) public payable {\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes memory _data\r\n    ) public payable {\r\n        _transfer(_from, _to, _tokenId);\r\n        if (_to.isContract()) {\r\n            require(\r\n                ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) ==\r\n                    bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")),\r\n                \"Wrong return value\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) public pure returns (string memory) {\r\n        require(_tokenId == 0, \"Invalid token ID\");\r\n        return _tokenURI();\r\n    }\r\n\r\n    function _tokenURI() internal pure virtual returns (string memory);\r\n}\r\n\r\n// File contracts/Canvas.sol\r\n//License-Identifier: MIT\r\n//  _____ _          _   _____            \r\n// |  __ (_)        | | |_   _|           \r\n// | |__) |__  _____| |   | |  _ __   ___ \r\n// |  ___/ \\ \\/ / _ \\ |   | | | '_ \\ / __|\r\n// | |   | |>  <  __/ |  _| |_| | | | (__ \r\n// |_|   |_/_/\\_\\___|_| |_____|_| |_|\\___| Canvas\r\n//\r\n// Flung together by BoringCrypto during COVID-19 lockdown in 2021\r\n// Stay safe! \r\n\r\n// Alpha here https://bit.ly/3icxSru\r\n\r\npragma solidity ^0.6.12;\r\n\r\n\r\n\r\n\r\n// solhint-disable avoid-low-level-calls\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ninterface Pixel is IERC20 {\r\n    function burn(uint256 amount) external;\r\n}\r\n\r\ncontract Canvas is BoringSingleNFT {\r\n    using BoringMath for uint256;\r\n    using BoringERC20 for Pixel;\r\n\r\n    event Buy(address hodler, address buyer, uint256 price, uint256 hodler_share);\r\n\r\n    string public constant name = \"The Canvas of Pixel Inc\";\r\n    string public constant symbol = \"CANVAS\";\r\n\r\n    uint256 public price;\r\n    Pixel public immutable pixel;\r\n    string public info;\r\n\r\n    constructor(Pixel _pixel) public {\r\n        pixel = _pixel;\r\n        price = _pixel.totalSupply() / 200000;\r\n        _transferBase(address(_pixel));\r\n    }\r\n\r\n    function _tokenURI() internal override pure returns (string memory) {\r\n        // {\"name\": \"Canvas\", \"description\": \"The final canvas created by the Pixel Inc project, 1000x1000 pixels painted by many different collaborators. Be aware, the canvas is always for sale through the website, don't list this on marketplaces! All the image and link data is stored fully on-chain and can be retrieved by querying the contract. The javascript code for this is included in this contract.\", \"image\": \"ipfs://bafybeidhigbhrccj27qrgnfswebfcciiywa46y2pisbtlad6vi2h5iu3u4/\"}\r\n        return string(abi.encodePacked('data:application/json;base64,eyJuYW1lIjogIkNhbnZhcyIsICJkZXNjcmlwdGlvbiI6ICJUaGUgZmluYWwgY2FudmFzIGNyZWF0ZWQgYnkgdGhlIFBpeGVsIEluYyBwcm9qZWN0LCAxMDAweDEwMDAgcGl4ZWxzIHBhaW50ZWQgYnkgbWFueSBkaWZmZXJlbnQgY29sbGFib3JhdG9ycy4gQmUgYXdhcmUsIHRoZSBjYW52YXMgaXMgYWx3YXlzIGZvciBzYWxlIHRocm91Z2ggdGhlIHdlYnNpdGUsIGRvbid0IGxpc3QgdGhpcyBvbiBtYXJrZXRwbGFjZXMhIEFsbCB0aGUgaW1hZ2UgYW5kIGxpbmsgZGF0YSBpcyBzdG9yZWQgZnVsbHkgb24tY2hhaW4gYW5kIGNhbiBiZSByZXRyaWV2ZWQgYnkgcXVlcnlpbmcgdGhlIGNvbnRyYWN0LiBUaGUgamF2YXNjcmlwdCBjb2RlIGZvciB0aGlzIGlzIGluY2x1ZGVkIGluIHRoaXMgY29udHJhY3QuIiwgImltYWdlIjogImlwZnM6Ly9iYWZ5YmVpZGhpZ2JocmNjajI3cXJnbmZzd2ViZmNjaWl5d2E0NnkycGlzYnRsYWQ2dmkyaDVpdTN1NC8ifQ'));\r\n    }\r\n\r\n    function buy() external payable {\r\n        require(msg.value == price, \"Value != price\");\r\n\r\n        // Send original price paid + 10% back to the hodler with max 20.000 gas. If this fails, continue anyway to prevent grieving/blocking attacks.\r\n        uint256 hodler_share = hodler == address(pixel) ? 0 : price.mul(110) / 150;\r\n        bool success;\r\n        (success, ) = hodler.call{value: hodler_share, gas: 20000}(\"\");\r\n\r\n        emit Buy(hodler, msg.sender, price, hodler_share);\r\n\r\n        price = price.mul(150) / 100; // Increase price by 50%\r\n        _transferBase(msg.sender);\r\n    }\r\n\r\n    function redeem(uint256 amount) external {\r\n        uint256 share = address(this).balance.mul(amount) / pixel.totalSupply();\r\n        pixel.safeTransferFrom(msg.sender, address(this), amount);\r\n        pixel.burn(amount);\r\n        bool success;\r\n        (success, ) = msg.sender.call{value: share, gas: 20000}(\"\");\r\n        require(success, \"Sending of ETH failed\");\r\n    }\r\n\r\n    function setInfo(string memory info_) external {\r\n        require(msg.sender == hodler, \"Canvas: not hodler\");\r\n        info = info_;\r\n    }\r\n\r\n    function poll(address user) public view returns(address hodler_, address allowed_, uint256 price_, uint256 pool, uint256 share, string memory info_) {\r\n        return (hodler, allowed, price, address(this).balance, address(this).balance.mul(pixel.balanceOf(user)) / pixel.totalSupply(), info);\r\n    }\r\n\r\n    function getCanvasImageCode() public pure returns (string memory code) {\r\n        return \"if(process.argv[2]){const e=require('ethers'),t=new e.Contract('0x1590ABe3612Be1CB3ab5B0f28874D521576e97Dc',[{inputs:[{internalType:'uint256[]',name:'blockNumbers',type:'uint256[]'}],name:'getBlocks',outputs:[{components:[{internalType:'address',name:'owner',type:'address'},{internalType:'string',name:'url',type:'string'},{internalType:'string',name:'description',type:'string'},{internalType:'bytes',name:'pixels',type:'bytes'},{internalType:'uint128',name:'lastPrice',type:'uint128'},{internalType:'uint32',name:'number',type:'uint32'}],internalType:'struct PixelV2.ExportBlock[]',name:'blocks',type:'tuple[]'}],stateMutability:'view',type:'function'}],new e.providers.JsonRpcProvider(process.argv[2])),{Canvas:a,Image:b}=require('node-canvas');async function main(){const e=new a(1e3,1e3),n=e.getContext('2d');for(let e=0;e<100;e++){console.log(100*e);let a=await t.getBlocks([...Array(100).keys()].map(t=>t+100*e));for(let t in a){let s=parseInt(a[t].pixels.substr(2,2)),r=a[t].pixels.substr(4);if(s<=4){1==s&&(r='89504e470d0a1a0a0000000d494844520000000a0000000a08060000008d32cfbd0000'+r+'0000000049454e44ae426082'),3==s&&(r='ffd8ffe000104a46494600010100000100010000ffdb0043000a07070807060a0808080b0a0a0b0e18100e0d0d0e1d15161118231f2524221f2221262b372f26293429212230413134393b3e3e3e252e4449433c48373d3e3bffdb0043010a0b0b0e0d0e1c10101c3b2822283b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3b3bffc0001108000a000a03012200021101031101ffc400'+r+'ffd9');const a=new b;a.src=Buffer.from(r,'hex'),n.drawImage(a,10*t,10*e,10,10)}else if(5==s){let a=n.createImageData(10,10);for(let e=0;e<100;e++){let t=parseInt(r.substr(6*e,6),16);a.data.set([Math.floor(t/65536),Math.floor(t%65536/256),t%256,255],4*e)}n.putImageData(a,10*t,10*e)}else 6!=s&&r||(n.fillStyle='#'+(r||'000000'),n.fillRect(10*t,10*e,10,10))}}const s=e.toBuffer('image/png');require('fs').writeFileSync('canvas.png',s)}main()}else console.log('Usage: node getImage.js <RPC URL>');\";\r\n    }\r\n}"}}}