{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ConverterRegistry.sol":{"content":"\n// File: solidity/contracts/token/interfaces/IERC20Token.sol\n\n// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.6.12;\n\n/*\n    ERC20 Standard Token interface\n*/\ninterface IERC20Token {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n}\n\n// File: solidity/contracts/utility/TokenHandler.sol\n\n\npragma solidity 0.6.12;\n\n\ncontract TokenHandler {\n    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\n    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256(\"transfer(address,uint256)\"));\n    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n\n    /**\n     * @dev executes the ERC20 token's `approve` function and reverts upon failure\n     * the main purpose of this function is to prevent a non standard ERC20 token\n     * from failing silently\n     *\n     * @param _token   ERC20 token address\n     * @param _spender approved address\n     * @param _value   allowance amount\n     */\n    function safeApprove(\n        IERC20Token _token,\n        address _spender,\n        uint256 _value\n    ) internal {\n        (bool success, bytes memory data) = address(_token).call(\n            abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"ERR_APPROVE_FAILED\");\n    }\n\n    /**\n     * @dev executes the ERC20 token's `transfer` function and reverts upon failure\n     * the main purpose of this function is to prevent a non standard ERC20 token\n     * from failing silently\n     *\n     * @param _token   ERC20 token address\n     * @param _to      target address\n     * @param _value   transfer amount\n     */\n    function safeTransfer(\n        IERC20Token _token,\n        address _to,\n        uint256 _value\n    ) internal {\n        (bool success, bytes memory data) = address(_token).call(\n            abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"ERR_TRANSFER_FAILED\");\n    }\n\n    /**\n     * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\n     * the main purpose of this function is to prevent a non standard ERC20 token\n     * from failing silently\n     *\n     * @param _token   ERC20 token address\n     * @param _from    source address\n     * @param _to      target address\n     * @param _value   transfer amount\n     */\n    function safeTransferFrom(\n        IERC20Token _token,\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        (bool success, bytes memory data) = address(_token).call(\n            abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"ERR_TRANSFER_FROM_FAILED\");\n    }\n}\n\n// File: solidity/contracts/utility/interfaces/IOwned.sol\n\n\npragma solidity 0.6.12;\n\n/*\n    Owned contract interface\n*/\ninterface IOwned {\n    // this function isn't since the compiler emits automatically generated getter functions as external\n    function owner() external view returns (address);\n\n    function transferOwnership(address _newOwner) external;\n\n    function acceptOwnership() external;\n}\n\n// File: solidity/contracts/utility/Owned.sol\n\n\npragma solidity 0.6.12;\n\n\n/**\n * @dev This contract provides support and utilities for contract ownership.\n */\ncontract Owned is IOwned {\n    address public override owner;\n    address public newOwner;\n\n    /**\n     * @dev triggered when the owner is updated\n     *\n     * @param _prevOwner previous owner\n     * @param _newOwner  new owner\n     */\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n\n    /**\n     * @dev initializes a new Owned instance\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        _ownerOnly();\n        _;\n    }\n\n    // error message binary size optimization\n    function _ownerOnly() internal view {\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\n    }\n\n    /**\n     * @dev allows transferring the contract ownership\n     * the new owner still needs to accept the transfer\n     * can only be called by the contract owner\n     *\n     * @param _newOwner    new contract owner\n     */\n    function transferOwnership(address _newOwner) public override ownerOnly {\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\n        newOwner = _newOwner;\n    }\n\n    /**\n     * @dev used by a new owner to accept an ownership transfer\n     */\n    function acceptOwnership() public override {\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\n        emit OwnerUpdate(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\n// File: solidity/contracts/utility/Utils.sol\n\n\npragma solidity 0.6.12;\n\n/**\n * @dev Utilities & Common Modifiers\n */\ncontract Utils {\n    // verifies that a value is greater than zero\n    modifier greaterThanZero(uint256 _value) {\n        _greaterThanZero(_value);\n        _;\n    }\n\n    // error message binary size optimization\n    function _greaterThanZero(uint256 _value) internal pure {\n        require(_value > 0, \"ERR_ZERO_VALUE\");\n    }\n\n    // validates an address - currently only checks that it isn't null\n    modifier validAddress(address _address) {\n        _validAddress(_address);\n        _;\n    }\n\n    // error message binary size optimization\n    function _validAddress(address _address) internal pure {\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\n    }\n\n    // verifies that the address is different than this contract address\n    modifier notThis(address _address) {\n        _notThis(_address);\n        _;\n    }\n\n    // error message binary size optimization\n    function _notThis(address _address) internal view {\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\n    }\n}\n\n// File: solidity/contracts/utility/interfaces/IContractRegistry.sol\n\n\npragma solidity 0.6.12;\n\n/*\n    Contract Registry interface\n*/\ninterface IContractRegistry {\n    function addressOf(bytes32 _contractName) external view returns (address);\n}\n\n// File: solidity/contracts/utility/ContractRegistryClient.sol\n\n\npragma solidity 0.6.12;\n\n\n\n\n/**\n * @dev This is the base contract for ContractRegistry clients.\n */\ncontract ContractRegistryClient is Owned, Utils {\n    bytes32 internal constant CONTRACT_REGISTRY = \"ContractRegistry\";\n    bytes32 internal constant BANCOR_NETWORK = \"BancorNetwork\";\n    bytes32 internal constant BANCOR_FORMULA = \"BancorFormula\";\n    bytes32 internal constant CONVERTER_FACTORY = \"ConverterFactory\";\n    bytes32 internal constant CONVERSION_PATH_FINDER = \"ConversionPathFinder\";\n    bytes32 internal constant CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\n    bytes32 internal constant CONVERTER_REGISTRY = \"BancorConverterRegistry\";\n    bytes32 internal constant CONVERTER_REGISTRY_DATA = \"BancorConverterRegistryData\";\n    bytes32 internal constant BNT_TOKEN = \"BNTToken\";\n    bytes32 internal constant BANCOR_X = \"BancorX\";\n    bytes32 internal constant BANCOR_X_UPGRADER = \"BancorXUpgrader\";\n\n    IContractRegistry public registry; // address of the current contract-registry\n    IContractRegistry public prevRegistry; // address of the previous contract-registry\n    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\n\n    /**\n     * @dev verifies that the caller is mapped to the given contract name\n     *\n     * @param _contractName    contract name\n     */\n    modifier only(bytes32 _contractName) {\n        _only(_contractName);\n        _;\n    }\n\n    // error message binary size optimization\n    function _only(bytes32 _contractName) internal view {\n        require(msg.sender == addressOf(_contractName), \"ERR_ACCESS_DENIED\");\n    }\n\n    /**\n     * @dev initializes a new ContractRegistryClient instance\n     *\n     * @param  _registry   address of a contract-registry contract\n     */\n    constructor(IContractRegistry _registry) internal validAddress(address(_registry)) {\n        registry = IContractRegistry(_registry);\n        prevRegistry = IContractRegistry(_registry);\n    }\n\n    /**\n     * @dev updates to the new contract-registry\n     */\n    function updateRegistry() public {\n        // verify that this function is permitted\n        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, \"ERR_ACCESS_DENIED\");\n\n        // get the new contract-registry\n        IContractRegistry newRegistry = IContractRegistry(addressOf(CONTRACT_REGISTRY));\n\n        // verify that the new contract-registry is different and not zero\n        require(newRegistry != registry && address(newRegistry) != address(0), \"ERR_INVALID_REGISTRY\");\n\n        // verify that the new contract-registry is pointing to a non-zero contract-registry\n        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), \"ERR_INVALID_REGISTRY\");\n\n        // save a backup of the current contract-registry before replacing it\n        prevRegistry = registry;\n\n        // replace the current contract-registry with the new contract-registry\n        registry = newRegistry;\n    }\n\n    /**\n     * @dev restores the previous contract-registry\n     */\n    function restoreRegistry() public ownerOnly {\n        // restore the previous contract-registry\n        registry = prevRegistry;\n    }\n\n    /**\n     * @dev restricts the permission to update the contract-registry\n     *\n     * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\n     */\n    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) public ownerOnly {\n        // change the permission to update the contract-registry\n        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\n    }\n\n    /**\n     * @dev returns the address associated with the given contract name\n     *\n     * @param _contractName    contract name\n     *\n     * @return contract address\n     */\n    function addressOf(bytes32 _contractName) internal view returns (address) {\n        return registry.addressOf(_contractName);\n    }\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterAnchor.sol\n\n\npragma solidity 0.6.12;\n\n\n/*\n    Converter Anchor interface\n*/\ninterface IConverterAnchor is IOwned {\n\n}\n\n// File: solidity/contracts/converter/interfaces/IConverter.sol\n\n\npragma solidity 0.6.12;\n\n\n\n\n/*\n    Converter interface\n*/\ninterface IConverter is IOwned {\n    function converterType() external pure returns (uint16);\n\n    function anchor() external view returns (IConverterAnchor);\n\n    function isActive() external view returns (bool);\n\n    function targetAmountAndFee(\n        IERC20Token _sourceToken,\n        IERC20Token _targetToken,\n        uint256 _amount\n    ) external view returns (uint256, uint256);\n\n    function convert(\n        IERC20Token _sourceToken,\n        IERC20Token _targetToken,\n        uint256 _amount,\n        address _trader,\n        address payable _beneficiary\n    ) external payable returns (uint256);\n\n    function conversionFee() external view returns (uint32);\n\n    function maxConversionFee() external view returns (uint32);\n\n    function reserveBalance(IERC20Token _reserveToken) external view returns (uint256);\n\n    receive() external payable;\n\n    function transferAnchorOwnership(address _newOwner) external;\n\n    function acceptAnchorOwnership() external;\n\n    function setConversionFee(uint32 _conversionFee) external;\n\n    function withdrawTokens(\n        IERC20Token _token,\n        address _to,\n        uint256 _amount\n    ) external;\n\n    function withdrawETH(address payable _to) external;\n\n    function addReserve(IERC20Token _token, uint32 _ratio) external;\n\n    // deprecated, backward compatibility\n    function token() external view returns (IConverterAnchor);\n\n    function transferTokenOwnership(address _newOwner) external;\n\n    function acceptTokenOwnership() external;\n\n    function connectors(IERC20Token _address)\n        external\n        view\n        returns (\n            uint256,\n            uint32,\n            bool,\n            bool,\n            bool\n        );\n\n    function getConnectorBalance(IERC20Token _connectorToken) external view returns (uint256);\n\n    function connectorTokens(uint256 _index) external view returns (IERC20Token);\n\n    function connectorTokenCount() external view returns (uint16);\n\n    /**\n     * @dev triggered when the converter is activated\n     *\n     * @param _type        converter type\n     * @param _anchor      converter anchor\n     * @param _activated   true if the converter was activated, false if it was deactivated\n     */\n    event Activation(uint16 indexed _type, IConverterAnchor indexed _anchor, bool indexed _activated);\n\n    /**\n     * @dev triggered when a conversion between two tokens occurs\n     *\n     * @param _fromToken       source ERC20 token\n     * @param _toToken         target ERC20 token\n     * @param _trader          wallet that initiated the trade\n     * @param _amount          input amount in units of the source token\n     * @param _return          output amount minus conversion fee in units of the target token\n     * @param _conversionFee   conversion fee in units of the target token\n     */\n    event Conversion(\n        IERC20Token indexed _fromToken,\n        IERC20Token indexed _toToken,\n        address indexed _trader,\n        uint256 _amount,\n        uint256 _return,\n        int256 _conversionFee\n    );\n\n    /**\n     * @dev triggered when the rate between two tokens in the converter changes\n     * note that the event might be dispatched for rate updates between any two tokens in the converter\n     *\n     * @param  _token1 address of the first token\n     * @param  _token2 address of the second token\n     * @param  _rateN  rate of 1 unit of `_token1` in `_token2` (numerator)\n     * @param  _rateD  rate of 1 unit of `_token1` in `_token2` (denominator)\n     */\n    event TokenRateUpdate(IERC20Token indexed _token1, IERC20Token indexed _token2, uint256 _rateN, uint256 _rateD);\n\n    /**\n     * @dev triggered when the conversion fee is updated\n     *\n     * @param  _prevFee    previous fee percentage, represented in ppm\n     * @param  _newFee     new fee percentage, represented in ppm\n     */\n    event ConversionFeeUpdate(uint32 _prevFee, uint32 _newFee);\n}\n\n// File: solidity/contracts/converter/interfaces/ITypedConverterCustomFactory.sol\n\n\npragma solidity 0.6.12;\n\n/*\n    Typed Converter Custom Factory interface\n*/\ninterface ITypedConverterCustomFactory {\n    function converterType() external pure returns (uint16);\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterFactory.sol\n\n\npragma solidity 0.6.12;\n\n\n\n\n\n/*\n    Converter Factory interface\n*/\ninterface IConverterFactory {\n    function createAnchor(\n        uint16 _type,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) external returns (IConverterAnchor);\n\n    function createConverter(\n        uint16 _type,\n        IConverterAnchor _anchor,\n        IContractRegistry _registry,\n        uint32 _maxConversionFee\n    ) external returns (IConverter);\n\n    function customFactories(uint16 _type) external view returns (ITypedConverterCustomFactory);\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterRegistry.sol\n\n\npragma solidity 0.6.12;\n\n\n\ninterface IConverterRegistry {\n    function getAnchorCount() external view returns (uint256);\n\n    function getAnchors() external view returns (address[] memory);\n\n    function getAnchor(uint256 _index) external view returns (IConverterAnchor);\n\n    function isAnchor(address _value) external view returns (bool);\n\n    function getLiquidityPoolCount() external view returns (uint256);\n\n    function getLiquidityPools() external view returns (address[] memory);\n\n    function getLiquidityPool(uint256 _index) external view returns (IConverterAnchor);\n\n    function isLiquidityPool(address _value) external view returns (bool);\n\n    function getConvertibleTokenCount() external view returns (uint256);\n\n    function getConvertibleTokens() external view returns (address[] memory);\n\n    function getConvertibleToken(uint256 _index) external view returns (IERC20Token);\n\n    function isConvertibleToken(address _value) external view returns (bool);\n\n    function getConvertibleTokenAnchorCount(IERC20Token _convertibleToken) external view returns (uint256);\n\n    function getConvertibleTokenAnchors(IERC20Token _convertibleToken) external view returns (address[] memory);\n\n    function getConvertibleTokenAnchor(IERC20Token _convertibleToken, uint256 _index)\n        external\n        view\n        returns (IConverterAnchor);\n\n    function isConvertibleTokenAnchor(IERC20Token _convertibleToken, address _value) external view returns (bool);\n}\n\n// File: solidity/contracts/converter/interfaces/IConverterRegistryData.sol\n\n\npragma solidity 0.6.12;\n\n\n\ninterface IConverterRegistryData {\n    function addSmartToken(IConverterAnchor _anchor) external;\n\n    function removeSmartToken(IConverterAnchor _anchor) external;\n\n    function addLiquidityPool(IConverterAnchor _liquidityPoolAnchor) external;\n\n    function removeLiquidityPool(IConverterAnchor _liquidityPoolAnchor) external;\n\n    function addConvertibleToken(IERC20Token _convertibleToken, IConverterAnchor _anchor) external;\n\n    function removeConvertibleToken(IERC20Token _convertibleToken, IConverterAnchor _anchor) external;\n\n    function getSmartTokenCount() external view returns (uint256);\n\n    function getSmartTokens() external view returns (address[] memory);\n\n    function getSmartToken(uint256 _index) external view returns (IConverterAnchor);\n\n    function isSmartToken(address _value) external view returns (bool);\n\n    function getLiquidityPoolCount() external view returns (uint256);\n\n    function getLiquidityPools() external view returns (address[] memory);\n\n    function getLiquidityPool(uint256 _index) external view returns (IConverterAnchor);\n\n    function isLiquidityPool(address _value) external view returns (bool);\n\n    function getConvertibleTokenCount() external view returns (uint256);\n\n    function getConvertibleTokens() external view returns (address[] memory);\n\n    function getConvertibleToken(uint256 _index) external view returns (IERC20Token);\n\n    function isConvertibleToken(address _value) external view returns (bool);\n\n    function getConvertibleTokenSmartTokenCount(IERC20Token _convertibleToken) external view returns (uint256);\n\n    function getConvertibleTokenSmartTokens(IERC20Token _convertibleToken) external view returns (address[] memory);\n\n    function getConvertibleTokenSmartToken(IERC20Token _convertibleToken, uint256 _index)\n        external\n        view\n        returns (IConverterAnchor);\n\n    function isConvertibleTokenSmartToken(IERC20Token _convertibleToken, address _value) external view returns (bool);\n}\n\n// File: solidity/contracts/token/interfaces/IDSToken.sol\n\n\npragma solidity 0.6.12;\n\n\n\n\n/*\n    DSToken interface\n*/\ninterface IDSToken is IConverterAnchor, IERC20Token {\n    function issue(address _to, uint256 _amount) external;\n\n    function destroy(address _from, uint256 _amount) external;\n}\n\n// File: solidity/contracts/converter/ConverterRegistry.sol\n\n\npragma solidity 0.6.12;\n\n\n\n\n\n\n\n\n/**\n * @dev This contract maintains a list of all active converters in the Bancor Network.\n *\n * Since converters can be upgraded and thus their address can change, the registry actually keeps\n * converter anchors internally and not the converters themselves.\n * The active converter for each anchor can be easily accessed by querying the anchor's owner.\n *\n * The registry exposes 3 differnet lists that can be accessed and iterated, based on the use-case of the caller:\n * - Anchors - can be used to get all the latest / historical data in the network\n * - Liquidity pools - can be used to get all liquidity pools for funding, liquidation etc.\n * - Convertible tokens - can be used to get all tokens that can be converted in the network (excluding pool\n *   tokens), and for each one - all anchors that hold it in their reserves\n *\n *\n * The contract fires events whenever one of the primitives is added to or removed from the registry\n *\n * The contract is upgradable.\n */\ncontract ConverterRegistry is IConverterRegistry, ContractRegistryClient, TokenHandler {\n    uint32 private constant PPM_RESOLUTION = 1000000;\n\n    /**\n     * @dev triggered when a converter anchor is added to the registry\n     *\n     * @param _anchor anchor token\n     */\n    event ConverterAnchorAdded(IConverterAnchor indexed _anchor);\n\n    /**\n     * @dev triggered when a converter anchor is removed from the registry\n     *\n     * @param _anchor anchor token\n     */\n    event ConverterAnchorRemoved(IConverterAnchor indexed _anchor);\n\n    /**\n     * @dev triggered when a liquidity pool is added to the registry\n     *\n     * @param _liquidityPool liquidity pool\n     */\n    event LiquidityPoolAdded(IConverterAnchor indexed _liquidityPool);\n\n    /**\n     * @dev triggered when a liquidity pool is removed from the registry\n     *\n     * @param _liquidityPool liquidity pool\n     */\n    event LiquidityPoolRemoved(IConverterAnchor indexed _liquidityPool);\n\n    /**\n     * @dev triggered when a convertible token is added to the registry\n     *\n     * @param _convertibleToken convertible token\n     * @param _smartToken associated anchor token\n     */\n    event ConvertibleTokenAdded(IERC20Token indexed _convertibleToken, IConverterAnchor indexed _smartToken);\n\n    /**\n     * @dev triggered when a convertible token is removed from the registry\n     *\n     * @param _convertibleToken convertible token\n     * @param _smartToken associated anchor token\n     */\n    event ConvertibleTokenRemoved(IERC20Token indexed _convertibleToken, IConverterAnchor indexed _smartToken);\n\n    /**\n     * @dev deprecated, backward compatibility, use `ConverterAnchorAdded`\n     */\n    event SmartTokenAdded(IConverterAnchor indexed _smartToken);\n\n    /**\n     * @dev deprecated, backward compatibility, use `ConverterAnchorRemoved`\n     */\n    event SmartTokenRemoved(IConverterAnchor indexed _smartToken);\n\n    /**\n     * @dev initializes a new ConverterRegistry instance\n     *\n     * @param _registry address of a contract registry contract\n     */\n    constructor(IContractRegistry _registry) public ContractRegistryClient(_registry) {}\n\n    /**\n     * @dev creates a zero supply liquid token / empty liquidity pool and adds its converter to the registry\n     *\n     * @param _type                converter type, see ConverterBase contract main doc\n     * @param _name                token / pool name\n     * @param _symbol              token / pool symbol\n     * @param _decimals            token / pool decimals\n     * @param _maxConversionFee    maximum conversion-fee\n     * @param _reserveTokens       reserve tokens\n     * @param _reserveWeights      reserve weights\n     *\n     * @return new converter\n     */\n    function newConverter(\n        uint16 _type,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint32 _maxConversionFee,\n        IERC20Token[] memory _reserveTokens,\n        uint32[] memory _reserveWeights\n    ) public virtual returns (IConverter) {\n        uint256 length = _reserveTokens.length;\n        require(length == _reserveWeights.length, \"ERR_INVALID_RESERVES\");\n\n        // for standard pools, change type 1 to type 3\n        if (_type == 1 && isStandardPool(_reserveWeights)) {\n            _type = 3;\n        }\n\n        require(\n            getLiquidityPoolByConfig(_type, _reserveTokens, _reserveWeights) == IConverterAnchor(0),\n            \"ERR_ALREADY_EXISTS\"\n        );\n\n        IConverterFactory factory = IConverterFactory(addressOf(CONVERTER_FACTORY));\n        IConverterAnchor anchor = IConverterAnchor(factory.createAnchor(_type, _name, _symbol, _decimals));\n        IConverter converter = IConverter(factory.createConverter(_type, anchor, registry, _maxConversionFee));\n\n        anchor.acceptOwnership();\n        converter.acceptOwnership();\n\n        for (uint256 i = 0; i < length; i++) converter.addReserve(_reserveTokens[i], _reserveWeights[i]);\n\n        anchor.transferOwnership(address(converter));\n        converter.acceptAnchorOwnership();\n        converter.transferOwnership(msg.sender);\n\n        addConverterInternal(converter);\n        return converter;\n    }\n\n    /**\n     * @dev adds an existing converter to the registry\n     * can only be called by the owner\n     *\n     * @param _converter converter\n     */\n    function addConverter(IConverter _converter) public ownerOnly {\n        require(isConverterValid(_converter), \"ERR_INVALID_CONVERTER\");\n        addConverterInternal(_converter);\n    }\n\n    /**\n     * @dev removes a converter from the registry\n     * anyone can remove an existing converter from the registry, as long as the converter is invalid\n     * note that the owner can also remove valid converters\n     *\n     * @param _converter converter\n     */\n    function removeConverter(IConverter _converter) public {\n        require(msg.sender == owner || !isConverterValid(_converter), \"ERR_ACCESS_DENIED\");\n        removeConverterInternal(_converter);\n    }\n\n    /**\n     * @dev returns the number of converter anchors in the registry\n     *\n     * @return number of anchors\n     */\n    function getAnchorCount() public view override returns (uint256) {\n        return IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).getSmartTokenCount();\n    }\n\n    /**\n     * @dev returns the list of converter anchors in the registry\n     *\n     * @return list of anchors\n     */\n    function getAnchors() public view override returns (address[] memory) {\n        return IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).getSmartTokens();\n    }\n\n    /**\n     * @dev returns the converter anchor at a given index\n     *\n     * @param _index index\n     * @return anchor at the given index\n     */\n    function getAnchor(uint256 _index) public view override returns (IConverterAnchor) {\n        return IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).getSmartToken(_index);\n    }\n\n    /**\n     * @dev checks whether or not a given value is a converter anchor\n     *\n     * @param _value value\n     * @return true if the given value is an anchor, false if not\n     */\n    function isAnchor(address _value) public view override returns (bool) {\n        return IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).isSmartToken(_value);\n    }\n\n    /**\n     * @dev returns the number of liquidity pools in the registry\n     *\n     * @return number of liquidity pools\n     */\n    function getLiquidityPoolCount() public view override returns (uint256) {\n        return IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).getLiquidityPoolCount();\n    }\n\n    /**\n     * @dev returns the list of liquidity pools in the registry\n     *\n     * @return list of liquidity pools\n     */\n    function getLiquidityPools() public view override returns (address[] memory) {\n        return IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).getLiquidityPools();\n    }\n\n    /**\n     * @dev returns the liquidity pool at a given index\n     *\n     * @param _index index\n     * @return liquidity pool at the given index\n     */\n    function getLiquidityPool(uint256 _index) public view override returns (IConverterAnchor) {\n        return IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).getLiquidityPool(_index);\n    }\n\n    /**\n     * @dev checks whether or not a given value is a liquidity pool\n     *\n     * @param _value value\n     * @return true if the given value is a liquidity pool, false if not\n     */\n    function isLiquidityPool(address _value) public view override returns (bool) {\n        return IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).isLiquidityPool(_value);\n    }\n\n    /**\n     * @dev returns the number of convertible tokens in the registry\n     *\n     * @return number of convertible tokens\n     */\n    function getConvertibleTokenCount() public view override returns (uint256) {\n        return IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).getConvertibleTokenCount();\n    }\n\n    /**\n     * @dev returns the list of convertible tokens in the registry\n     *\n     * @return list of convertible tokens\n     */\n    function getConvertibleTokens() public view override returns (address[] memory) {\n        return IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).getConvertibleTokens();\n    }\n\n    /**\n     * @dev returns the convertible token at a given index\n     *\n     * @param _index index\n     * @return convertible token at the given index\n     */\n    function getConvertibleToken(uint256 _index) public view override returns (IERC20Token) {\n        return IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).getConvertibleToken(_index);\n    }\n\n    /**\n     * @dev checks whether or not a given value is a convertible token\n     *\n     * @param _value value\n     * @return true if the given value is a convertible token, false if not\n     */\n    function isConvertibleToken(address _value) public view override returns (bool) {\n        return IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).isConvertibleToken(_value);\n    }\n\n    /**\n     * @dev returns the number of converter anchors associated with a given convertible token\n     *\n     * @param _convertibleToken convertible token\n     * @return number of anchors associated with the given convertible token\n     */\n    function getConvertibleTokenAnchorCount(IERC20Token _convertibleToken) public view override returns (uint256) {\n        return\n            IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).getConvertibleTokenSmartTokenCount(\n                _convertibleToken\n            );\n    }\n\n    /**\n     * @dev returns the list of aoncerter anchors associated with a given convertible token\n     *\n     * @param _convertibleToken convertible token\n     * @return list of anchors associated with the given convertible token\n     */\n    function getConvertibleTokenAnchors(IERC20Token _convertibleToken) public view override returns (address[] memory) {\n        return\n            IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).getConvertibleTokenSmartTokens(\n                _convertibleToken\n            );\n    }\n\n    /**\n     * @dev returns the converter anchor associated with a given convertible token at a given index\n     *\n     * @param _index index\n     * @return anchor associated with the given convertible token at the given index\n     */\n    function getConvertibleTokenAnchor(IERC20Token _convertibleToken, uint256 _index)\n        public\n        view\n        override\n        returns (IConverterAnchor)\n    {\n        return\n            IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).getConvertibleTokenSmartToken(\n                _convertibleToken,\n                _index\n            );\n    }\n\n    /**\n     * @dev checks whether or not a given value is a converter anchor of a given convertible token\n     *\n     * @param _convertibleToken convertible token\n     * @param _value value\n     * @return true if the given value is an anchor of the given convertible token, false if not\n     */\n    function isConvertibleTokenAnchor(IERC20Token _convertibleToken, address _value)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA)).isConvertibleTokenSmartToken(\n                _convertibleToken,\n                _value\n            );\n    }\n\n    /**\n     * @dev returns a list of converters for a given list of anchors\n     * this is a utility function that can be used to reduce the number of calls to the contract\n     *\n     * @param _anchors list of converter anchors\n     * @return list of converters\n     */\n    function getConvertersByAnchors(address[] memory _anchors) public view returns (IConverter[] memory) {\n        IConverter[] memory converters = new IConverter[](_anchors.length);\n\n        for (uint256 i = 0; i < _anchors.length; i++)\n            converters[i] = IConverter(payable(IConverterAnchor(_anchors[i]).owner()));\n\n        return converters;\n    }\n\n    /**\n     * @dev checks whether or not a given converter is valid\n     *\n     * @param _converter converter\n     * @return true if the given converter is valid, false if not\n     */\n    function isConverterValid(IConverter _converter) public view returns (bool) {\n        // verify that the converter is active\n        return _converter.token().owner() == address(_converter);\n    }\n\n    /**\n     * @dev checks if a liquidity pool with given configuration is already registered\n     *\n     * @param _converter converter with specific configuration\n     * @return if a liquidity pool with the same configuration is already registered\n     */\n    function isSimilarLiquidityPoolRegistered(IConverter _converter) public view returns (bool) {\n        uint256 reserveTokenCount = _converter.connectorTokenCount();\n        IERC20Token[] memory reserveTokens = new IERC20Token[](reserveTokenCount);\n        uint32[] memory reserveWeights = new uint32[](reserveTokenCount);\n\n        // get the reserve-configuration of the converter\n        for (uint256 i = 0; i < reserveTokenCount; i++) {\n            IERC20Token reserveToken = _converter.connectorTokens(i);\n            reserveTokens[i] = reserveToken;\n            reserveWeights[i] = getReserveWeight(_converter, reserveToken);\n        }\n\n        // return if a liquidity pool with the same configuration is already registered\n        return\n            getLiquidityPoolByConfig(getConverterType(_converter, reserveTokenCount), reserveTokens, reserveWeights) !=\n            IConverterAnchor(0);\n    }\n\n    /**\n     * @dev searches for a liquidity pool with specific configuration\n     *\n     * @param _type            converter type, see ConverterBase contract main doc\n     * @param _reserveTokens   reserve tokens\n     * @param _reserveWeights  reserve weights\n     * @return the liquidity pool, or zero if no such liquidity pool exists\n     */\n    function getLiquidityPoolByConfig(\n        uint16 _type,\n        IERC20Token[] memory _reserveTokens,\n        uint32[] memory _reserveWeights\n    ) public view returns (IConverterAnchor) {\n        // verify that the input parameters represent a valid liquidity pool\n        if (_reserveTokens.length == _reserveWeights.length && _reserveTokens.length > 1) {\n            // get the anchors of the least frequent token (optimization)\n            address[] memory convertibleTokenAnchors = getLeastFrequentTokenAnchors(_reserveTokens);\n            // search for a converter with the same configuration\n            for (uint256 i = 0; i < convertibleTokenAnchors.length; i++) {\n                IConverterAnchor anchor = IConverterAnchor(convertibleTokenAnchors[i]);\n                IConverter converter = IConverter(payable(anchor.owner()));\n                if (isConverterReserveConfigEqual(converter, _type, _reserveTokens, _reserveWeights)) return anchor;\n            }\n        }\n\n        return IConverterAnchor(0);\n    }\n\n    /**\n     * @dev adds a converter anchor to the registry\n     *\n     * @param _anchor converter anchor\n     */\n    function addAnchor(IConverterRegistryData _converterRegistryData, IConverterAnchor _anchor) internal {\n        _converterRegistryData.addSmartToken(_anchor);\n        emit ConverterAnchorAdded(_anchor);\n        emit SmartTokenAdded(_anchor);\n    }\n\n    /**\n     * @dev removes a converter anchor from the registry\n     *\n     * @param _anchor converter anchor\n     */\n    function removeAnchor(IConverterRegistryData _converterRegistryData, IConverterAnchor _anchor) internal {\n        _converterRegistryData.removeSmartToken(_anchor);\n        emit ConverterAnchorRemoved(_anchor);\n        emit SmartTokenRemoved(_anchor);\n    }\n\n    /**\n     * @dev adds a liquidity pool to the registry\n     *\n     * @param _liquidityPoolAnchor liquidity pool converter anchor\n     */\n    function addLiquidityPool(IConverterRegistryData _converterRegistryData, IConverterAnchor _liquidityPoolAnchor)\n        internal\n    {\n        _converterRegistryData.addLiquidityPool(_liquidityPoolAnchor);\n        emit LiquidityPoolAdded(_liquidityPoolAnchor);\n    }\n\n    /**\n     * @dev removes a liquidity pool from the registry\n     *\n     * @param _liquidityPoolAnchor liquidity pool converter anchor\n     */\n    function removeLiquidityPool(IConverterRegistryData _converterRegistryData, IConverterAnchor _liquidityPoolAnchor)\n        internal\n    {\n        _converterRegistryData.removeLiquidityPool(_liquidityPoolAnchor);\n        emit LiquidityPoolRemoved(_liquidityPoolAnchor);\n    }\n\n    /**\n     * @dev adds a convertible token to the registry\n     *\n     * @param _convertibleToken    convertible token\n     * @param _anchor              associated converter anchor\n     */\n    function addConvertibleToken(\n        IConverterRegistryData _converterRegistryData,\n        IERC20Token _convertibleToken,\n        IConverterAnchor _anchor\n    ) internal {\n        _converterRegistryData.addConvertibleToken(_convertibleToken, _anchor);\n        emit ConvertibleTokenAdded(_convertibleToken, _anchor);\n    }\n\n    /**\n     * @dev removes a convertible token from the registry\n     *\n     * @param _convertibleToken    convertible token\n     * @param _anchor              associated converter anchor\n     */\n    function removeConvertibleToken(\n        IConverterRegistryData _converterRegistryData,\n        IERC20Token _convertibleToken,\n        IConverterAnchor _anchor\n    ) internal {\n        _converterRegistryData.removeConvertibleToken(_convertibleToken, _anchor);\n        emit ConvertibleTokenRemoved(_convertibleToken, _anchor);\n    }\n\n    /**\n     * @dev checks whether or not a given configuration depicts a standard pool\n     *\n     * @param _reserveWeights  reserve weights\n     *\n     * @return true if the given configuration depicts a standard pool, false otherwise\n     */\n    function isStandardPool(uint32[] memory _reserveWeights) internal view virtual returns (bool) {\n        this; // silent state mutability warning without generating additional bytecode\n        return\n            _reserveWeights.length == 2 &&\n            _reserveWeights[0] == PPM_RESOLUTION / 2 &&\n            _reserveWeights[1] == PPM_RESOLUTION / 2;\n    }\n\n    function addConverterInternal(IConverter _converter) private {\n        IConverterRegistryData converterRegistryData = IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA));\n        IConverterAnchor anchor = IConverter(_converter).token();\n        uint256 reserveTokenCount = _converter.connectorTokenCount();\n\n        // add the converter anchor\n        addAnchor(converterRegistryData, anchor);\n        if (reserveTokenCount > 1) addLiquidityPool(converterRegistryData, anchor);\n        else addConvertibleToken(converterRegistryData, IDSToken(address(anchor)), anchor);\n\n        // add all reserve tokens\n        for (uint256 i = 0; i < reserveTokenCount; i++)\n            addConvertibleToken(converterRegistryData, _converter.connectorTokens(i), anchor);\n    }\n\n    function removeConverterInternal(IConverter _converter) private {\n        IConverterRegistryData converterRegistryData = IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA));\n        IConverterAnchor anchor = IConverter(_converter).token();\n        uint256 reserveTokenCount = _converter.connectorTokenCount();\n\n        // remove the converter anchor\n        removeAnchor(converterRegistryData, anchor);\n        if (reserveTokenCount > 1) removeLiquidityPool(converterRegistryData, anchor);\n        else removeConvertibleToken(converterRegistryData, IDSToken(address(anchor)), anchor);\n\n        // remove all reserve tokens\n        for (uint256 i = 0; i < reserveTokenCount; i++)\n            removeConvertibleToken(converterRegistryData, _converter.connectorTokens(i), anchor);\n    }\n\n    function getLeastFrequentTokenAnchors(IERC20Token[] memory _reserveTokens) private view returns (address[] memory) {\n        IConverterRegistryData converterRegistryData = IConverterRegistryData(addressOf(CONVERTER_REGISTRY_DATA));\n        uint256 minAnchorCount = converterRegistryData.getConvertibleTokenSmartTokenCount(_reserveTokens[0]);\n        uint256 index = 0;\n\n        // find the reserve token which has the smallest number of converter anchors\n        for (uint256 i = 1; i < _reserveTokens.length; i++) {\n            uint256 convertibleTokenAnchorCount = converterRegistryData.getConvertibleTokenSmartTokenCount(\n                _reserveTokens[i]\n            );\n            if (minAnchorCount > convertibleTokenAnchorCount) {\n                minAnchorCount = convertibleTokenAnchorCount;\n                index = i;\n            }\n        }\n\n        return converterRegistryData.getConvertibleTokenSmartTokens(_reserveTokens[index]);\n    }\n\n    function isConverterReserveConfigEqual(\n        IConverter _converter,\n        uint16 _type,\n        IERC20Token[] memory _reserveTokens,\n        uint32[] memory _reserveWeights\n    ) private view returns (bool) {\n        uint256 reserveTokenCount = _converter.connectorTokenCount();\n\n        if (_type != getConverterType(_converter, reserveTokenCount)) return false;\n\n        if (_reserveTokens.length != reserveTokenCount) return false;\n\n        for (uint256 i = 0; i < _reserveTokens.length; i++) {\n            if (_reserveWeights[i] != getReserveWeight(_converter, _reserveTokens[i])) return false;\n        }\n\n        return true;\n    }\n\n    // utility to get the reserve weight (including from older converters that don't support the new getReserveWeight function)\n    function getReserveWeight(IConverter _converter, IERC20Token _reserveToken) private view returns (uint32) {\n        (, uint32 weight, , , ) = _converter.connectors(_reserveToken);\n        return weight;\n    }\n\n    bytes4 private constant CONVERTER_TYPE_FUNC_SELECTOR = bytes4(keccak256(\"converterType()\"));\n\n    // utility to get the converter type (including from older converters that don't support the new converterType function)\n    function getConverterType(IConverter _converter, uint256 _reserveTokenCount) private view returns (uint16) {\n        (bool success, bytes memory returnData) = address(_converter).staticcall(\n            abi.encodeWithSelector(CONVERTER_TYPE_FUNC_SELECTOR)\n        );\n        if (success && returnData.length == 32) return abi.decode(returnData, (uint16));\n        return _reserveTokenCount > 1 ? 1 : 0;\n    }\n\n    /**\n     * @dev deprecated, backward compatibility, use `getAnchorCount`\n     */\n    function getSmartTokenCount() public view returns (uint256) {\n        return getAnchorCount();\n    }\n\n    /**\n     * @dev deprecated, backward compatibility, use `getAnchors`\n     */\n    function getSmartTokens() public view returns (address[] memory) {\n        return getAnchors();\n    }\n\n    /**\n     * @dev deprecated, backward compatibility, use `getAnchor`\n     */\n    function getSmartToken(uint256 _index) public view returns (IConverterAnchor) {\n        return getAnchor(_index);\n    }\n\n    /**\n     * @dev deprecated, backward compatibility, use `isAnchor`\n     */\n    function isSmartToken(address _value) public view returns (bool) {\n        return isAnchor(_value);\n    }\n\n    /**\n     * @dev deprecated, backward compatibility, use `getConvertibleTokenAnchorCount`\n     */\n    function getConvertibleTokenSmartTokenCount(IERC20Token _convertibleToken) public view returns (uint256) {\n        return getConvertibleTokenAnchorCount(_convertibleToken);\n    }\n\n    /**\n     * @dev deprecated, backward compatibility, use `getConvertibleTokenAnchors`\n     */\n    function getConvertibleTokenSmartTokens(IERC20Token _convertibleToken) public view returns (address[] memory) {\n        return getConvertibleTokenAnchors(_convertibleToken);\n    }\n\n    /**\n     * @dev deprecated, backward compatibility, use `getConvertibleTokenAnchor`\n     */\n    function getConvertibleTokenSmartToken(IERC20Token _convertibleToken, uint256 _index)\n        public\n        view\n        returns (IConverterAnchor)\n    {\n        return getConvertibleTokenAnchor(_convertibleToken, _index);\n    }\n\n    /**\n     * @dev deprecated, backward compatibility, use `isConvertibleTokenAnchor`\n     */\n    function isConvertibleTokenSmartToken(IERC20Token _convertibleToken, address _value) public view returns (bool) {\n        return isConvertibleTokenAnchor(_convertibleToken, _value);\n    }\n\n    /**\n     * @dev deprecated, backward compatibility, use `getConvertersByAnchors`\n     */\n    function getConvertersBySmartTokens(address[] memory _smartTokens) public view returns (IConverter[] memory) {\n        return getConvertersByAnchors(_smartTokens);\n    }\n\n    /**\n     * @dev deprecated, backward compatibility, use `getLiquidityPoolByConfig`\n     */\n    function getLiquidityPoolByReserveConfig(IERC20Token[] memory _reserveTokens, uint32[] memory _reserveWeights)\n        public\n        view\n        returns (IConverterAnchor)\n    {\n        return getLiquidityPoolByConfig(_reserveTokens.length > 1 ? 1 : 0, _reserveTokens, _reserveWeights);\n    }\n}\n"}}}