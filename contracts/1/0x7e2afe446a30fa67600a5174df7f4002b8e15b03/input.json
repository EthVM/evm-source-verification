{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"OptionContract/OptionContract.sol":{"content":"pragma solidity ^0.8.2;\n\n// SPDX-License-Identifier: MIT\n\ninterface IERC20 {\n    \n    /**\n    * @dev Returns the amount of tokens in existence.\n    */\n    function totalSupply() external view returns (uint256);\n    \n    /**\n    * @dev Returns the token decimals.\n    */    \n    function decimals() external view returns (uint8);\n    \n    /**\n    * @dev Returns the token symbol.\n    */\n    function symbol() external view returns (string memory);\n    \n    /**\n    * @dev Returns the token name.\n    */\n    function name() external view returns (string memory);\n    \n    /**\n    * @dev Returns the bep token owner.\n    */\n    function getOwner() external view returns (address);\n    \n    /**\n    * @dev Returns the amount of tokens owned by `account`.\n    */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * Emits a {Transfer} event.\n    */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    \n    /**\n    * @dev Returns the remaining number of tokens that `spender` will be\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\n    * zero by default.\n    *\n    * This value changes when {approve} or {transferFrom} are called.\n    */\n    function allowance(address _owner, address spender) external view returns (uint256);\n    \n    /**\n    * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * IMPORTANT: Beware that changing an allowance with this method brings the risk\n    * that someone may use both the old and the new allowance by unfortunate\n    * transaction ordering. One possible solution to mitigate this race\n    * condition is to first reduce the spender's allowance to 0 and set the\n    * desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    *\n    * Emits an {Approval} event.\n    */\n    function approve(address spender, uint256 amount) external returns (bool);\n    \n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\n    * allowance mechanism. `amount` is then deducted from the caller's\n    * allowance.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * Emits a {Transfer} event.\n    */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    \n    /**\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\n    * another (`to`).\n    *\n    * Note that `value` may be zero.\n    */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /**\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n    * a call to {approve}. `value` is the new allowance.\n    */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract OptionSellingContract {\n    IERC20 buyingTokenContract;\n    uint buyingAmount;\n    \n    IERC20 sellingtokenContract;\n    uint sellingAmount;\n    \n    /**\n    * @dev Returns the Buyers address\n    */\n    address public buyerAddress;\n    \n    /**\n    * @dev Returns the sellers address\n    */\n    address public sellerAddress;\n    \n    /**\n    * @dev Returns the state of the contract, if true tokens are deposited and \n    * trades can be excecuted\n    */\n    bool public isInitialised;\n    \n    /**\n    * @dev Returns the amount of tokens that were sold through this contract\n    */\n    uint public soldAmount;\n    \n    /**\n    * @dev Returns the amount of tokens that were bought through this contract\n    */\n    uint public boughtAmount;\n    \n    /**\n    * @dev Initializes the contract setting the needed values for the trade.\n    */\n    constructor () {\n        buyingTokenContract = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n        buyingAmount = 40e8;\n        buyerAddress = 0x1574c679261C3715c789c02a496a443Fea7A1474;\n        sellingtokenContract = IERC20(0x191557728e4d8CAa4Ac94f86af842148c0FA8F7E);\n        sellingAmount = 120000000e8;\n        sellerAddress = 0x7c50038b33DE3679cf2A5783AAfF5FE358709680;\n    }\n    \n    /**\n    * @dev This method thakes the predefined amount of selling tokens from the \n    * sellers account and initializes the contract which means that \n    * trading can start.\n    * \n    * IMPORTANT: This method will not work if allowance on the selling token is \n    * not set to the appropriate ammount\n    */\n    function initializeContract() public {\n        require(msg.sender == sellerAddress);\n        require(!isInitialised, \"Contract is already initialised!\");\n        sellingtokenContract.transferFrom(msg.sender, address(this), sellingAmount);\n        isInitialised = true;\n    }\n    \n    /**\n    * @dev Creates the trade, it sends the amount of buying tokens that are ont the smart \n    * contract to the seller and withdraws the appropriate amount of selling tokens to the buyer\n    * \n    * IMPORTANT: This method will only work if contract is initialised and if balance of buying token is at leats 0.1.\n    */\n    function executeSell() public {\n        require(msg.sender == sellerAddress || msg.sender == buyerAddress);\n        require(buyingTokenContract.balanceOf(address(this)) >= 1e7, \"Selling ammount must me greater than 0.1 WBTC!\");\n        require(isInitialised, \"Contract is not initialised!\");\n        \n        uint buyingBalance = buyingTokenContract.balanceOf(address(this));\n        if (buyingAmount - boughtAmount < buyingBalance){\n            buyingTokenContract.transfer(buyerAddress, buyingBalance - (buyingAmount - boughtAmount));\n            buyingBalance = buyingAmount - boughtAmount;\n        }\n        boughtAmount += buyingBalance;\n        buyingTokenContract.transfer(sellerAddress, buyingBalance);\n        \n        \n        uint activeSoldAmount = (buyingBalance * (sellingAmount/buyingAmount));\n        soldAmount += activeSoldAmount;\n        sellingtokenContract.transfer(buyerAddress, activeSoldAmount);\n    }\n    \n    /**\n    * @dev Returns the amount of selling tokens on the smart contract\n    */\n    function sellingTokenBalance() public view returns (uint){\n        return sellingtokenContract.balanceOf(address(this));\n    }\n    \n    /**\n    * @dev Returns the amount of buying tokens on the smart contract\n    */\n    function buyingTokenBalance() public view returns (uint){\n        return buyingTokenContract.balanceOf(address(this));\n    }\n    \n    /**\n    * @dev After the trading is complete and all the tokens are sent \n    * appropriatly the buyer gets the control of the smart contract \n    * so he can salvage wrongly sent tokens.\n    */\n    function salvageTokensFromContract(address tokenAddress, address to, uint amount) public {\n        require(msg.sender == buyerAddress);\n        require(boughtAmount == buyingAmount);\n        IERC20(tokenAddress).transfer(to, amount);\n    }\n}\n"}}}