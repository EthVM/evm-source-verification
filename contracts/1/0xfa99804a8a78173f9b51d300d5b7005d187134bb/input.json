{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 5000000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "TellorTransition.sol": {
      "content": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Tellor Oracle Storage Library\r\n * @dev Contains all the variables/structs used by Tellor\r\n */\r\n\r\nlibrary TellorStorage {\r\n    //Internal struct for use in proof-of-work submission\r\n    struct Details {\r\n        uint256 value;\r\n        address miner;\r\n    }\r\n\r\n    struct Dispute {\r\n        bytes32 hash; //unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\r\n        int256 tally; //current tally of votes for - against measure\r\n        bool executed; //is the dispute settled\r\n        bool disputeVotePassed; //did the vote pass?\r\n        bool isPropFork; //true for fork proposal NEW\r\n        address reportedMiner; //miner who submitted the 'bad value' will get disputeFee if dispute vote fails\r\n        address reportingParty; //miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\r\n        address proposedForkAddress; //new fork address (if fork proposal)\r\n        mapping(bytes32 => uint256) disputeUintVars;\r\n        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\r\n        //e.g. TellorStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256(\"requestId\")]\r\n        //These are the variables saved in this mapping:\r\n        // uint keccak256(\"requestId\");//apiID of disputed value\r\n        // uint keccak256(\"timestamp\");//timestamp of disputed value\r\n        // uint keccak256(\"value\"); //the value being disputed\r\n        // uint keccak256(\"minExecutionDate\");//7 days from when dispute initialized\r\n        // uint keccak256(\"numberOfVotes\");//the number of parties who have voted on the measure\r\n        // uint keccak256(\"blockNumber\");// the blocknumber for which votes will be calculated from\r\n        // uint keccak256(\"minerSlot\"); //index in dispute array\r\n        // uint keccak256(\"fee\"); //fee paid corresponding to dispute\r\n        mapping(address => bool) voted; //mapping of address to whether or not they voted\r\n    }\r\n\r\n    struct StakeInfo {\r\n        uint256 currentStatus; //0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute 4=ReadyForUnlocking 5=Unlocked\r\n        uint256 startDate; //stake start date\r\n    }\r\n\r\n    //Internal struct to allow balances to be queried by blocknumber for voting purposes\r\n    struct Checkpoint {\r\n        uint128 fromBlock; // fromBlock is the block number that the value was generated from\r\n        uint128 value; // value is the amount of tokens at a specific block number\r\n    }\r\n\r\n    struct Request {\r\n        string queryString; //id to string api\r\n        string dataSymbol; //short name for api request\r\n        bytes32 queryHash; //hash of api string and granularity e.g. keccak256(abi.encodePacked(_api,_granularity))\r\n        uint256[] requestTimestamps; //array of all newValueTimestamps requested\r\n        mapping(bytes32 => uint256) apiUintVars;\r\n        //Each of the variables below is saved in the mapping apiUintVars for each api request\r\n        //e.g. requestDetails[_requestId].apiUintVars[keccak256(\"totalTip\")]\r\n        //These are the variables saved in this mapping:\r\n        // uint keccak256(\"granularity\"); //multiplier for miners\r\n        // uint keccak256(\"requestQPosition\"); //index in requestQ\r\n        // uint keccak256(\"totalTip\");//bonus portion of payout\r\n        mapping(uint256 => uint256) minedBlockNum; //[apiId][minedTimestamp]=>block.number\r\n        //This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\r\n        mapping(uint256 => uint256) finalValues;\r\n        mapping(uint256 => bool) inDispute; //checks if API id is in dispute or finalized.\r\n        mapping(uint256 => address[5]) minersByValue;\r\n        mapping(uint256 => uint256[5]) valuesByTimestamp;\r\n    }\r\n\r\n    struct TellorStorageStruct {\r\n        bytes32 currentChallenge; //current challenge to be solved\r\n        uint256[51] requestQ; //uint50 array of the top50 requests by payment amount\r\n        uint256[] newValueTimestamps; //array of all timestamps requested\r\n        Details[5] currentMiners; //This struct is for organizing the five mined values to find the median\r\n        mapping(bytes32 => address) addressVars;\r\n        //Address fields in the Tellor contract are saved the addressVars mapping\r\n        //e.g. addressVars[keccak256(\"tellorContract\")] = address\r\n        //These are the variables saved in this mapping:\r\n        // address keccak256(\"tellorContract\");//Tellor address\r\n        // address  keccak256(\"_owner\");//Tellor Owner address\r\n        // address  keccak256(\"_deity\");//Tellor Owner that can do things at will\r\n        // address  keccak256(\"pending_owner\"); // The proposed new owner\r\n        mapping(bytes32 => uint256) uintVars;\r\n        //uint fields in the Tellor contract are saved the uintVars mapping\r\n        //e.g. uintVars[keccak256(\"decimals\")] = uint\r\n        //These are the variables saved in this mapping:\r\n        // keccak256(\"decimals\");    //18 decimal standard ERC20\r\n        // keccak256(\"disputeFee\");//cost to dispute a mined value\r\n        // keccak256(\"disputeCount\");//totalHistoricalDisputes\r\n        // keccak256(\"total_supply\"); //total_supply of the token in circulation\r\n        // keccak256(\"stakeAmount\");//stakeAmount for miners (we can cut gas if we just hardcoded it in...or should it be variable?)\r\n        // keccak256(\"stakerCount\"); //number of parties currently staked\r\n        // keccak256(\"timeOfLastNewValue\"); // time of last challenge solved\r\n        // keccak256(\"difficulty\"); // Difficulty of current block\r\n        // keccak256(\"currentTotalTips\"); //value of highest api/timestamp PayoutPool\r\n        // keccak256(\"currentRequestId\"); //API being mined--updates with the ApiOnQ Id\r\n        // keccak256(\"requestCount\"); // total number of requests through the system\r\n        // keccak256(\"slotProgress\");//Number of miners who have mined this value so far\r\n        // keccak256(\"miningReward\");//Mining Reward in PoWo tokens given to all miners per value\r\n        // keccak256(\"timeTarget\"); //The time between blocks (mined Oracle values)\r\n        // keccak256(\"_tblock\"); //\r\n        // keccak256(\"runningTips\"); // VAriable to track running tips\r\n        // keccak256(\"currentReward\"); // The current reward\r\n        // keccak256(\"devShare\"); // The amount directed towards th devShare\r\n        // keccak256(\"currentTotalTips\"); //\r\n        //This is a boolean that tells you if a given challenge has been completed by a given miner\r\n        mapping(bytes32 => mapping(address => bool)) minersByChallenge;\r\n        mapping(uint256 => uint256) requestIdByTimestamp; //minedTimestamp to apiId\r\n        mapping(uint256 => uint256) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\r\n        mapping(uint256 => Dispute) disputesById; //disputeId=> Dispute details\r\n        mapping(address => Checkpoint[]) balances; //balances of a party given blocks\r\n        mapping(address => mapping(address => uint256)) allowed; //allowance for a given party and approver\r\n        mapping(address => StakeInfo) stakerDetails; //mapping from a persons address to their staking info\r\n        mapping(uint256 => Request) requestDetails; //mapping of apiID to details\r\n        mapping(bytes32 => uint256) requestIdByQueryHash; // api bytes32 gets an id = to count of requests array\r\n        mapping(bytes32 => uint256) disputeIdByDisputeHash; //maps a hash to an ID for each dispute\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n/**\r\n* @title Tellor Master\r\n* @dev This is a transaction contract designed to perform a temporary configuration on a Tellor Update.\r\n*/\r\ncontract TellorTransition {\r\n\r\n    TellorStorage.TellorStorageStruct tellor;\r\n\r\n    address public constant newTellor = 0xC5721b1b753B0E2129F88694762C718c36442e7c;\r\n    address public constant currentTellor = 0xF7914ebf0f021Adaf95114B068502d0C7D107bc9;\r\n\r\n    /**\r\n    * @dev Function to be executed before the first transaction to new version is called. After performing\r\n    * the necessary steps, it just sets the \"tellorContract\" to the actual new version. \r\n    */\r\n    function _transition() internal {\r\n        //Perfomr all necessary steps for the transition\r\n        tellor.uintVars[keccak256(\"timeTarget\")] = 240;\r\n\r\n        //After, change the \"tellorAddress\" to the new version\r\n        tellor.addressVars[keccak256(\"tellorContract\")] = newTellor;\r\n    } \r\n\r\n    /**\r\n    * @dev Function to be verify if the system is in the correct state for executing a transition.\r\n    *  Ex: we're not in the middle of a block;\r\n    */\r\n    function _isReady() internal view returns(bool){\r\n        if(tellor.uintVars[keccak256(\"slotProgress\")] == 0){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function() external payable{\r\n        \r\n        address addr = currentTellor;\r\n        //If contract is ready, perform the transition and set the definitive address as TellorContract;\r\n        if(_isReady()){\r\n            _transition();\r\n            addr = newTellor;\r\n        } \r\n        bytes memory _calldata = msg.data;\r\n        assembly {\r\n            let result := delegatecall(not(0), addr, add(_calldata, 0x20), mload(_calldata), 0, 0)\r\n            let size := returndatasize\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, size)\r\n                }\r\n                default {\r\n                    return(ptr, size)\r\n                }\r\n        }\r\n    }\r\n}"
    }
  }
}