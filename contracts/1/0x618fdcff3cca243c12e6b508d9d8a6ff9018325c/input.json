{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Tier2FarmController.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.4.22 <0.8.0;\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns(uint supply);\r\n\r\n    function balanceOf(address _owner) external view returns(uint balance);\r\n\r\n    function transfer(address _to, uint _value) external returns(bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\r\n\r\n    function approve(address _spender, uint _value) external returns(bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\r\n\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\ninterface StakingInterface {\r\n  function balanceOf ( address who ) external view returns ( uint256 );\r\n  //function controller (  ) external view returns ( address );\r\n  function exit (  ) external;\r\n  //function lpToken (  ) external view returns ( address );\r\n  function stake ( uint256 amount ) external;\r\n  //function valuePerShare (  ) external view returns ( uint256 );\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal view returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal view returns (uint256) {\r\n    assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n\r\n\r\n  function sub(uint256 a, uint256 b) internal view returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal view returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract Tier2FarmController{\r\n\r\n  using SafeMath\r\n    for uint256;\r\n\r\n\r\n  address payable public owner;\r\n  address public platformToken = 0xa0246c9032bC3A600820415aE600c6388619A14D;\r\n  address public tokenStakingContract = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\r\n  address ETH_TOKEN_ADDRESS  = address(0x0);\r\n  mapping (string => address) public stakingContracts;\r\n  mapping (address => address) public tokenToFarmMapping;\r\n  mapping (string => address) public stakingContractsStakingToken;\r\n  mapping (address => mapping (address => uint256)) public depositBalances;\r\n  uint256 public commission  = 400; // Default is 4 percent\r\n\r\n  \r\n  string public farmName = 'Harvest.Finance';\r\n  mapping (address => uint256) public totalAmountStaked;\r\n\r\n  modifier onlyOwner() {\r\n        if (msg.sender == owner) _;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n  constructor() public payable {\r\n        stakingContracts[\"FARM\"] = 0x25550Cccbd68533Fa04bFD3e3AC4D09f9e00Fc50;\r\n        stakingContractsStakingToken [\"FARM\"] = 0xa0246c9032bC3A600820415aE600c6388619A14D;\r\n        tokenToFarmMapping[stakingContractsStakingToken [\"FARM\"]] =  stakingContracts[\"FARM\"];\r\n        owner= msg.sender;\r\n\r\n  }\r\n\r\n\r\n  fallback() external payable {\r\n\r\n\r\n  }\r\n\r\n\r\n\r\n  function addOrEditStakingContract(string memory name, address stakingAddress, address stakingToken ) public onlyOwner returns (bool){\r\n\r\n    stakingContracts[name] = stakingAddress;\r\n    stakingContractsStakingToken[name] = stakingToken;\r\n    tokenToFarmMapping[stakingToken] = stakingAddress;\r\n    return true;\r\n\r\n  }\r\n\r\n  function updateCommission(uint amount) public onlyOwner returns(bool){\r\n      commission = amount;\r\n      return true;\r\n  }\r\n\r\n  function deposit(address tokenAddress, uint256 amount, address onBehalfOf) payable onlyOwner public returns (bool){\r\n\r\n\r\n       if(tokenAddress == 0x0000000000000000000000000000000000000000){\r\n\r\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + msg.value;\r\n\r\n             stake(amount, onBehalfOf, tokenAddress );\r\n             totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\r\n             emit Deposit(onBehalfOf, amount, tokenAddress);\r\n            return true;\r\n\r\n        }\r\n\r\n        ERC20 thisToken = ERC20(tokenAddress);\r\n        require(thisToken.transferFrom(msg.sender, address(this), amount), \"Not enough tokens to transferFrom or no approval\");\r\n\r\n        depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  + amount;\r\n        \r\n        uint256 approvedAmount = thisToken.allowance(address(this), tokenToFarmMapping[tokenAddress]);\r\n        if(approvedAmount < amount  ){\r\n            thisToken.approve(tokenToFarmMapping[tokenAddress], amount.mul(10000000));\r\n        }\r\n        stake(amount, onBehalfOf, tokenAddress );\r\n        \r\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].add(amount);\r\n\r\n        emit Deposit(onBehalfOf, amount, tokenAddress);\r\n        return true;\r\n   }\r\n\r\n   function stake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\r\n      \r\n      StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\r\n      staker.stake(amount);\r\n      return true;\r\n\r\n   }\r\n\r\n   function unstake(uint256 amount, address onBehalfOf, address tokenAddress) internal returns(bool){\r\n      StakingInterface staker  =  StakingInterface(tokenToFarmMapping[tokenAddress]);\r\n      staker.exit();\r\n      return true;\r\n\r\n   }\r\n\r\n\r\n   function getStakedPoolBalanceByUser(address _owner, address tokenAddress) public view returns(uint256){\r\n        StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\r\n        \r\n        uint256 numberTokens = staker.balanceOf(address(this));\r\n    \r\n        uint256 usersBalancePercentage = (depositBalances[_owner][tokenAddress].mul(1000000)).div(totalAmountStaked[tokenAddress]);\r\n        uint256 numberTokensPlusRewardsForUser= (numberTokens.mul(1000).mul(usersBalancePercentage)).div(1000000000);\r\n     \r\n        \r\n        return numberTokensPlusRewardsForUser;\r\n        \r\n    }  \r\n    \r\n\r\n  function withdraw(address tokenAddress, uint256 amount, address payable onBehalfOf) onlyOwner payable public returns(bool){\r\n\r\n      ERC20 thisToken = ERC20(tokenAddress);\r\n      //uint256 numberTokensPreWithdrawal = getStakedBalance(address(this), tokenAddress);\r\n\r\n        if(tokenAddress == 0x0000000000000000000000000000000000000000){\r\n            require(depositBalances[msg.sender][tokenAddress] >= amount, \"You didnt deposit enough eth\");\r\n\r\n            totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\r\n            depositBalances[onBehalfOf][tokenAddress] = depositBalances[onBehalfOf][tokenAddress]  - amount;\r\n            onBehalfOf.send(amount);\r\n            return true;\r\n\r\n        }\r\n\r\n        \r\n        require(depositBalances[onBehalfOf][tokenAddress] > 0, \"You dont have any tokens deposited\");\r\n\r\n        \r\n\r\n        //uint256 numberTokensPostWithdrawal = thisToken.balanceOf(address(this));\r\n\r\n        //uint256 usersBalancePercentage = depositBalances[onBehalfOf][tokenAddress].div(totalAmountStaked[tokenAddress]);\r\n\r\n        uint256 numberTokensPlusRewardsForUser1 = getStakedPoolBalanceByUser(onBehalfOf, tokenAddress);\r\n        uint256 commissionForDAO1 = calculateCommission(numberTokensPlusRewardsForUser1);\r\n        uint256 numberTokensPlusRewardsForUserMinusCommission = numberTokensPlusRewardsForUser1-commissionForDAO1;\r\n        \r\n        unstake(amount, onBehalfOf, tokenAddress);\r\n        \r\n        //staking platforms only withdraw all for the most part, and for security sticking to this\r\n        totalAmountStaked[tokenAddress] = totalAmountStaked[tokenAddress].sub(depositBalances[onBehalfOf][tokenAddress]);\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        depositBalances[onBehalfOf][tokenAddress] = 0;\r\n        require(numberTokensPlusRewardsForUserMinusCommission >0, \"For some reason numberTokensPlusRewardsForUserMinusCommission is zero\");\r\n        \r\n        require(thisToken.transfer(onBehalfOf, numberTokensPlusRewardsForUserMinusCommission), \"You dont have enough tokens inside this contract to withdraw from deposits\");\r\n        if(numberTokensPlusRewardsForUserMinusCommission >0){\r\n            thisToken.transfer(owner, commissionForDAO1);\r\n        }\r\n        \r\n        \r\n        uint256 remainingBalance = thisToken.balanceOf(address(this));\r\n        if(remainingBalance>0){\r\n            stake(remainingBalance, address(this), tokenAddress);\r\n        }\r\n        \r\n\r\n        emit Withdrawal(onBehalfOf, amount, tokenAddress);\r\n        return true;\r\n\r\n   }\r\n\r\n\r\n   function calculateCommission(uint256 amount) view public returns(uint256){\r\n     uint256 commissionForDAO = (amount.mul(1000).mul(commission)).div(10000000);\r\n     return commissionForDAO;\r\n   }\r\n\r\n   function changeOwner(address payable newOwner) onlyOwner public returns (bool){\r\n     owner = newOwner;\r\n     return true;\r\n   }\r\n   \r\n \r\n   function getStakedBalance(address _owner, address tokenAddress) public view returns(uint256){\r\n       \r\n       StakingInterface staker  = StakingInterface(tokenToFarmMapping[tokenAddress]);\r\n       return staker.balanceOf(_owner);\r\n   }\r\n   \r\n\r\n\r\n  function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\r\n\r\n\r\n\r\n      if (address(token) == ETH_TOKEN_ADDRESS) {\r\n          destination.transfer(amount);\r\n      }\r\n      else {\r\n          ERC20 tokenToken = ERC20(token);\r\n          require(tokenToken.transfer(destination, amount));\r\n      }\r\n\r\n      \r\n      \r\n\r\n      return true;\r\n  }\r\n\r\n\r\n\r\n function kill() virtual public onlyOwner {\r\n\r\n         selfdestruct(owner);\r\n\r\n }\r\n\r\n\r\n    event Deposit(address indexed user, uint256 amount, address token);\r\n    event Withdrawal(address indexed user, uint256 amount, address token);\r\n    \r\n   \r\n   \r\n\r\n}"
    }
  }
}