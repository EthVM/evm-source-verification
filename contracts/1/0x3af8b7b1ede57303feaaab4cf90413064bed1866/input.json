{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/AbqErc20.sol": {
      "content": "// SPDX-License-Identifier:MIT\r\npragma solidity >=0.7.0;\r\nimport \"./SafeMathTyped.sol\";\r\n\r\n// The MIT License\r\n//\r\n// Copyright (c) 2017-2018 0xcert, d.o.o. https://0xcert.org\r\n// \r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n// \r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE.\r\n/**\r\n * @title ERC20 standard token implementation.\r\n * @dev Standard ERC20 token. This contract follows the implementation at https://goo.gl/mLbAPJ.\r\n */\r\ncontract Token\r\n{\r\n  string internal tokenName;\r\n\r\n  string internal tokenSymbol;\r\n\r\n  uint8 internal tokenDecimals;\r\n\r\n  uint256 internal tokenTotalSupply;\r\n\r\n  mapping (address => uint256) internal balances;\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  /**\r\n   * @dev Trigger when tokens are transferred, including zero value transfers.\r\n   */\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  /**\r\n   * @dev Trigger on any successful call to approve(address _spender, uint256 _value).\r\n   */\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n\r\n  /**\r\n   * @dev Returns the name of the token.\r\n   */\r\n  function name()\r\n    external\r\n    view\r\n    returns (string memory _name)\r\n  {\r\n    _name = tokenName;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the symbol of the token.\r\n   */\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string memory _symbol)\r\n  {\r\n    _symbol = tokenSymbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of decimals the token uses.\r\n   */\r\n  function decimals()\r\n    external\r\n    view\r\n    returns (uint8 _decimals)\r\n  {\r\n    _decimals = tokenDecimals;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total token supply.\r\n   */\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256 _totalSupply)\r\n  {\r\n    _totalSupply = tokenTotalSupply;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the account balance of another account with address _owner.\r\n   * @param _owner The address from which the balance will be retrieved.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 _balance)\r\n  {\r\n    _balance = balances[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\r\n   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\r\n   * @param _to The address of the recipient.\r\n   * @param _value The amount of token to be transferred.\r\n   */\r\n  function transfer(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool _success)\r\n  {\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = SafeMathTyped.sub256(balances[msg.sender], _value);\r\n    balances[_to] = SafeMathTyped.add256(balances[_to], _value);\r\n\r\n    emit Transfer(msg.sender, _to, _value);\r\n    _success = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows _spender to withdraw from your account multiple times, up to the _value amount. If\r\n   * this function is called again it overwrites the current allowance with _value.\r\n   * @param _spender The address of the account able to transfer the tokens.\r\n   * @param _value The amount of tokens to be approved for transfer.\r\n   */\r\n  function approve(\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool _success)\r\n  {\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n\r\n    emit Approval(msg.sender, _spender, _value);\r\n    _success = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\r\n   * @param _owner The address of the account owning tokens.\r\n   * @param _spender The address of the account able to transfer the tokens.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 _remaining)\r\n  {\r\n    _remaining = allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\r\n   * Transfer event.\r\n   * @param _from The address of the sender.\r\n   * @param _to The address of the recipient.\r\n   * @param _value The amount of token to be transferred.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool _success)\r\n  {\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = SafeMathTyped.sub256(balances[_from], _value);\r\n    balances[_to] = SafeMathTyped.add256(balances[_to], _value);\r\n    allowed[_from][msg.sender] = SafeMathTyped.sub256(allowed[_from][msg.sender], _value);\r\n\r\n    emit Transfer(_from, _to, _value);\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n/// @notice This is the ABQ token. It allows the owner (the Aardbanq DAO) to mint new tokens. It also allow the \r\n/// owner to change owners. The ABQ token has 18 decimals.\r\ncontract AbqErc20 is Token\r\n{\r\n    /// @notice The owner of the ABQ Token. This is the Aardbanq DAO.\r\n    address public owner;\r\n    /// @notice The address for the founders' contract.\r\n    address public founderContract;\r\n\r\n    constructor(address _owner, address _founderContract)\r\n    {\r\n        tokenName = \"Aardbanq DAO\";\r\n        tokenSymbol = \"ABQ\";\r\n        tokenDecimals = 18;\r\n        tokenTotalSupply = 0;\r\n        owner = _owner;\r\n        founderContract = _founderContract;\r\n    }\r\n\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"ABQ/only-owner\");\r\n        _;\r\n    }\r\n\r\n    event OwnerChange(address indexed newOwner);\r\n    /// @notice Allows the owner to change the ownership to another address.\r\n    /// @param _newOwner The address that should be the new owner.\r\n    function changeOwner(address _newOwner)\r\n        external\r\n        onlyOwner()\r\n    {\r\n        owner = _newOwner;\r\n        emit OwnerChange(_newOwner);\r\n    }\r\n\r\n    /// @notice Allows the owner to mint tokens.\r\n    /// @param _target The address to mint the tokens to.\r\n    /// @param _abqAmount The amount of ABQ to mint.\r\n    function mint(address _target, uint256 _abqAmount)\r\n        external\r\n        onlyOwner()\r\n    {\r\n        balances[_target] = SafeMathTyped.add256(balances[_target], _abqAmount);\r\n        emit Transfer(address(0), _target, _abqAmount);\r\n\r\n        // CG: Founder's part 15% of total that will be issued\r\n        // MATH:\r\n        // totalIncrease = mintAmount + founderPart {A}\r\n        // also:\r\n        // founderPart = 0.15 * totalIncrease\r\n        // ... founderPart / 0.15 = totalIncrease   {B}\r\n        // substituting {A} in {B}\r\n        // ... founderPart / 0.15 = mintAmount + founderPart\r\n        // ... (founderPart / 0.15) - founderPart = mintAmount\r\n        // ... (founderPart - (0.15 * founderPart)) / 0.15 = mintAmount\r\n        // ... (0.85 * founderPart) / 0.15 = mintAmount\r\n        // ... 0.85 * founderPart = 0.15 * mintAmount\r\n        // ... founderPart = (0.15 / 0.85) * mintAmount\r\n        // ... founderPart ~= (mintAmount * 17647) / 100000\r\n        uint256 founderShare = SafeMathTyped.mul256(_abqAmount, 17647) / 100000;\r\n        balances[founderContract] = SafeMathTyped.add256(balances[founderContract], founderShare);\r\n        tokenTotalSupply = SafeMathTyped.add256(SafeMathTyped.add256(tokenTotalSupply, _abqAmount), founderShare);\r\n        emit Transfer(address(0), founderContract, founderShare);\r\n    }\r\n\r\n    /// @notice Allow the sender to burn tokens in their account.\r\n    /// @param _abqAmount The amount of tokens to burn from the msg.sender account.\r\n    function burn(uint256 _abqAmount)\r\n      external\r\n    {\r\n      tokenTotalSupply = SafeMathTyped.sub256(tokenTotalSupply, _abqAmount);\r\n      balances[msg.sender] = SafeMathTyped.sub256(balances[msg.sender], _abqAmount);\r\n      emit Transfer(msg.sender, address(0), _abqAmount);\r\n    }\r\n\r\n    event NameChange(string newName);\r\n    /// @notice Allow the owner to change the name of the token. \r\n    /// @param _newName The new name for the token\r\n    function changeName(string calldata _newName)\r\n      external\r\n      onlyOwner()\r\n    {\r\n      tokenName = _newName;\r\n      emit NameChange(_newName);\r\n    }\r\n\r\n    event SymbolChange(string newSymbol);\r\n    /// @notice Allow the owner to change the symbol of the token.\r\n    /// @param _newSymbol The new symbol for the token.\r\n    function changeSymbol(string calldata _newSymbol)\r\n      external\r\n      onlyOwner()\r\n    {\r\n      tokenSymbol = _newSymbol;\r\n      emit SymbolChange(_newSymbol);\r\n    }\r\n}"
    },
    "contracts/DelegateOwnershipManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n// This code is the property of the Aardbanq DAO.\r\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\r\n// It is the author's wish that this code should be open sourced under the MIT license, but the final \r\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \r\n// distributed.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\npragma solidity >=0.7.0;\r\nimport \"./Minter.sol\";\r\nimport \"./AbqErc20.sol\";\r\n\r\n/// @notice A delegate ownership manager to allow minting permissions to be set independent of ownership on the ABQ token.\r\ncontract DelegateOwnershipManager is Minter\r\n{\r\n    /// @notice The ABQ token.\r\n    AbqErc20 public abqToken;\r\n    /// @notice The owner of the DelegateOwnershipManager. This should be the Aardbanq DAO.\r\n    address public owner;\r\n    /// @notice The addresses that have mint permissions.\r\n    mapping(address => bool) public mintPermission;\r\n\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"ABQ/only-owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrMintPermission()\r\n    {\r\n        require(msg.sender == owner || mintPermission[msg.sender], \"ABQ/only-owner-or-mint-permission\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Construct a DelegateOwnershipManager.\r\n    /// @param _abqToken The ABQ token.\r\n    /// @param _owner The owner for this contract. This should be the Aardbanq DAO.\r\n    constructor (AbqErc20 _abqToken, address _owner)\r\n    {\r\n        abqToken = _abqToken;\r\n        owner = _owner;\r\n    }\r\n\r\n    /// @notice Event emitted when minting permission is set.\r\n    /// @param target The address to set permission for.\r\n    /// @param mayMint The permission state.\r\n    event MintPermission(address indexed target, bool mayMint);\r\n    /// @notice Set minting permission for a given address.\r\n    /// @param _target The address to set minting permission for.\r\n    /// @param _mayMint If set to true the _target address will be allowed to mint.\r\n    function setMintPermission(address _target, bool _mayMint)\r\n        onlyOwner()\r\n        external\r\n    {\r\n        mintPermission[_target] = _mayMint;\r\n        emit MintPermission(_target, _mayMint);\r\n    }\r\n\r\n    /// @notice The event emitted if the owner is changed.\r\n    /// @param newOwner The new owner for this contract.\r\n    event OwnerChange(address indexed newOwner);\r\n    /// @notice Allows the owner to change the ownership to another address.\r\n    /// @param _newOwner The address that should be the new owner.\r\n    function changeThisOwner(address _newOwner)\r\n        external\r\n        onlyOwner()\r\n    {\r\n        owner = _newOwner;\r\n        emit OwnerChange(_newOwner);\r\n    }\r\n\r\n    /// @notice Mint tokens should the msg.sender has permission to mint.\r\n    /// @param _target The address to mint tokens to.\r\n    /// @param _amount The amount of tokens to mint.\r\n    function mint(address _target, uint256 _amount)\r\n        onlyOwnerOrMintPermission()\r\n        override\r\n        external\r\n    {\r\n        abqToken.mint(_target, _amount);\r\n    }\r\n\r\n    /// @notice Change the owner of the token. Only the owner may call this.\r\n    /// @param _newOwner The new owner of the token.\r\n    function changeTokenOwner(address _newOwner)\r\n        onlyOwner()\r\n        external\r\n    {\r\n        abqToken.changeOwner(_newOwner);\r\n    }\r\n\r\n    /// @notice Change the name of the token. Only the owner may call this.\r\n    function changeName(string calldata _newName)\r\n        onlyOwner()\r\n        external\r\n    {\r\n        abqToken.changeName(_newName);\r\n    }\r\n\r\n    /// @notice Change the symbol of the token. Only the owner may call this.\r\n    function changeSymbol(string calldata _newSymbol)\r\n        onlyOwner()\r\n        external\r\n    {\r\n        abqToken.changeSymbol(_newSymbol);\r\n    }\r\n}"
    },
    "contracts/Erc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\ninterface Erc20\r\n{\r\n    function symbol() view external returns (string memory _symbol);\r\n    function decimals() view external returns (uint8 _decimals);\r\n    \r\n    function balanceOf(address _owner) \r\n        view\r\n        external\r\n        returns (uint256 _balance);\r\n        \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    function transfer(address _to, uint256 _amount) \r\n        external\r\n        returns (bool _success);\r\n    function transferFrom(address _from, address _to, uint256 _amount)\r\n        external\r\n        returns (bool _success);\r\n\r\n    function approve(address _spender, uint256 _amount) \r\n        external\r\n        returns (bool _success);\r\n}"
    },
    "contracts/ILiquidityEstablisher.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n// This code is the property of the Aardbanq DAO.\r\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\r\n// It is the author's wish that this code should be open sourced under the MIT license, but the final \r\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \r\n// distributed.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\npragma solidity >=0.7.0;\r\n\r\ninterface ILiquidityEstablisher\r\n{\r\n    function isLiquidityEstablishedOrExpired()\r\n        external\r\n        view\r\n        returns (bool _isEstablishedOrExpired);\r\n}"
    },
    "contracts/IPricer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n// This code is the property of the Aardbanq DAO.\r\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\r\n// It is the author's wish that this code should be open sourced under the MIT license, but the final \r\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \r\n// distributed.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\npragma solidity >=0.7.0;\r\n\r\ninterface IPricer\r\n{\r\n    function currentPrice()\r\n        view\r\n        external\r\n        returns (uint256 _currentPrice);\r\n}"
    },
    "contracts/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}"
    },
    "contracts/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}"
    },
    "contracts/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}"
    },
    "contracts/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\r\n\r\nimport './IUniswapV2Router01.sol';\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}"
    },
    "contracts/InitialLiquidityOffering.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n// This code is the property of the Aardbanq DAO.\r\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\r\n// It is the author's wish that this code should be open sourced under the MIT license, but the final \r\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \r\n// distributed.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\npragma solidity >=0.7.0;\r\nimport \"./Minter.sol\";\r\nimport \"./Erc20.sol\";\r\nimport \"./IUniswapV2Router02.sol\";\r\nimport \"./IUniswapV2Factory.sol\";\r\nimport \"./IUniswapV2Pair.sol\";\r\nimport \"./IPricer.sol\";\r\nimport \"./SafeMathTyped.sol\";\r\nimport \"./ILiquidityEstablisher.sol\";\r\n\r\n/// @notice A contract to offer initial liquidity purchase and an reward.\r\ncontract InitialLiquidityOffering is ILiquidityEstablisher\r\n{\r\n    /// @notice The time in unix (seconds) timestamp that the offer closes.\r\n    uint64 public offerCloseTime;\r\n    /// @notice The address funds are sent to.\r\n    address public treasury;\r\n    /// @notice The token that is offered.\r\n    Erc20 public tokenOffer;\r\n    /// @notice The time in unix (seconds) timestamp that the liquidity may be claimed.\r\n    uint64 public liquidityReleaseTime;\r\n    /// @notice The token liquidity will be established with.\r\n    Erc20 public liquidityToken;\r\n    /// @notice Flag to indicate if liquidity has been established.\r\n    bool public isLiquidityEstablished;\r\n    /// @notice The minter of the token on offer.\r\n    Minter public minter;\r\n    /// @notice The uniswap router used to establish liquidity.\r\n    IUniswapV2Router02 public uniswapRouter;\r\n    /// @notice The ICO used to establish the price at which liquidity will be established.\r\n    IPricer public pricer;\r\n    /// @notice The maximum liquidity (priced in liquidityToken) up for sale.\r\n    uint256 public maxLiquidityAllowed;\r\n    /// @notice The total liquidity sold so far.\r\n    uint256 public totalLiquidityProvided;\r\n\r\n    /// @notice The total liquidity provided by each address (priced in liquidityToken).\r\n    mapping(address => uint256) public liquidityBalances;\r\n\r\n    /// @notice Constructs an initial liquidity token offering.\r\n    /// @param _offerCloseTime The time in unix (seconds) timestamp that the offer closes.\r\n    /// @param _tokenOffer The token on offer.\r\n    /// @param _liquidityReleaseTime The time in unix (secods) timestamp that the liquidity will be released.\r\n    /// @param _liquidityToken The token liquidity will be sold in. (like DAI)\r\n    /// @param _minter The minter that can mint _tokenOffer tokens.\r\n    /// @param _uniswapRouter The uniswap router to use.\r\n    /// @param _maxLiquidityAllowed The maximum liquidity (priced in _liquidityToken) on sale.\r\n    constructor (uint64 _offerCloseTime, address _treasury, Erc20 _tokenOffer, uint64 _liquidityReleaseTime, Erc20 _liquidityToken, \r\n        Minter _minter, IUniswapV2Router02 _uniswapRouter, uint256 _maxLiquidityAllowed)\r\n    {\r\n        offerCloseTime = _offerCloseTime;\r\n        treasury = _treasury;\r\n        tokenOffer = _tokenOffer;\r\n        liquidityReleaseTime = _liquidityReleaseTime;\r\n        liquidityToken = _liquidityToken;\r\n        minter = _minter;\r\n        uniswapRouter = _uniswapRouter;\r\n        maxLiquidityAllowed = _maxLiquidityAllowed;\r\n    }\r\n\r\n    /// @notice Returns true if either liquidity has been established or the ILO has been closed for more than 7 days. False otherwise.\r\n    /// @return _isEstablishedOrExpired True if either liquidity has been established or the ILO has been closed for more than 7 days. False otherwise.\r\n    function isLiquidityEstablishedOrExpired()\r\n        external\r\n        override\r\n        view\r\n        returns (bool _isEstablishedOrExpired)\r\n    {\r\n        return isLiquidityEstablished || (offerCloseTime + 7 days <= block.timestamp); \r\n    }\r\n\r\n    /// @notice Set the ICO address to use to establish the price of the token on offer.\r\n    function setPricer(IPricer _pricer) \r\n        external\r\n    {\r\n        require(address(pricer) == address(0), \"ABQICO/pricer-already-set\");\r\n        pricer = _pricer;\r\n    }\r\n\r\n    /// @notice Event emitted when liquidity was provided.\r\n    /// @param to The address that provided the liquidity.\r\n    /// @param amount The amount of liquidity (priced in liquidityToken) that was provided.\r\n    event LiquidityOfferReceipt(address to, uint256 amount);\r\n    /// @notice Provide liquidity. Liquidity is paid for from the msg.sender.\r\n    /// @param _target The address that will own and receive the liquidity pool tokens and reward.\r\n    /// @param _amount The amount of liquidity to offer (priced in liquidityToken).\r\n    function provideLiquidity(address _target, uint256 _amount)\r\n        external\r\n    {\r\n        require(offerCloseTime >= block.timestamp && maxLiquidityAllowed > totalLiquidityProvided, \"ABQILO/offer-closed\");\r\n\r\n        // CG: ensure only whole token amounts have no values in the last 18 places\r\n        _amount = (_amount / 1 ether) * 1 ether;\r\n        require(_amount >= 1 ether, \"ABQILO/amount-too-small\");\r\n\r\n        // CG: ensure amounts don't go above max allowed\r\n        uint256 amountLeft = SafeMathTyped.sub256(maxLiquidityAllowed, totalLiquidityProvided);\r\n        if (_amount > amountLeft)\r\n        {\r\n            _amount = amountLeft;\r\n        }\r\n\r\n        // CG: transfer funds\r\n        bool couldTransfer = liquidityToken.transferFrom(msg.sender, address(this), _amount);\r\n        require(couldTransfer, \"ABQILO/could-not-transfer\");\r\n\r\n        // CG: account for funds\r\n        totalLiquidityProvided = SafeMathTyped.add256(totalLiquidityProvided, _amount);\r\n        liquidityBalances[_target] = SafeMathTyped.add256(liquidityBalances[_target], _amount);\r\n\r\n        emit LiquidityOfferReceipt(_target, _amount);\r\n    }\r\n\r\n    /// @notice Event emitted when liquidity is established.\r\n    /// @param liquidityAssetAmount The amount of liquidityToken that was contributed.\r\n    /// @param offerTokenAmount The amount of the token on offer that was added as liquidity.\r\n    /// @param liquidityTokenAmount The amount of liquidity pool tokens that was minted.\r\n    event LiquidityEstablishment(uint256 liquidityAssetAmount, uint256 offerTokenAmount, uint256 liquidityTokenAmount);\r\n    /// @notice Establish liquidity if the sale period ended or the liquidity sale has been sold out.\r\n    function establishLiquidity()\r\n        external\r\n    {\r\n        require(offerCloseTime < block.timestamp || maxLiquidityAllowed == totalLiquidityProvided, \"ABQILO/offer-still-open\");\r\n        require(!isLiquidityEstablished, \"ABQILO/liquidity-already-established\");\r\n\r\n        if (totalLiquidityProvided > 0)\r\n        {\r\n            uint256 currentPrice = pricer.currentPrice();\r\n            if (currentPrice > 10 ether)\r\n            {\r\n                // CG: in the event the ICO was sold out.\r\n                currentPrice = 10 ether;\r\n            }\r\n            uint256 totalOfferProvided = SafeMathTyped.mul256(totalLiquidityProvided / currentPrice, 1 ether);\r\n            minter.mint(address(this), totalOfferProvided);\r\n\r\n            bool isOfferApproved = tokenOffer.approve(address(uniswapRouter), totalOfferProvided);\r\n            require(isOfferApproved, \"ABQICO/could-not-approve-offer\");\r\n            bool isLiquidityApproved = liquidityToken.approve(address(uniswapRouter), totalLiquidityProvided);\r\n            require(isLiquidityApproved, \"ABQICO/could-not-approve-liquidity\");\r\n\r\n            (, , uint256 liquidityTokensCount) = uniswapRouter.addLiquidity(address(liquidityToken), address(tokenOffer), totalLiquidityProvided, totalOfferProvided, 0, 0, address(this), block.timestamp);\r\n\r\n            IUniswapV2Factory factory = IUniswapV2Factory(uniswapRouter.factory());\r\n            IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(address(tokenOffer), address(liquidityToken)));\r\n            require(address(pair) != address(0), \"ABQILO/pair-not-created\");\r\n            bool couldSendDaoShare = pair.transfer(treasury, liquidityTokensCount / 2);\r\n            require(couldSendDaoShare, \"ABQILO/could-not-send\");\r\n\r\n            emit LiquidityEstablishment(totalLiquidityProvided, totalOfferProvided, liquidityTokensCount);\r\n        }\r\n\r\n        isLiquidityEstablished = true;\r\n    }\r\n\r\n    /// @notice Event emitted when liquidity pool tokens are claimed.\r\n    /// @param to The address the claim was for.\r\n    /// @param amount The amount of liquidity pool tokens that was claimed.\r\n    /// @param reward The reward (in the token on offer) that was also claimed.\r\n    event Claim(address to, uint256 amount, uint256 reward);\r\n    /// @notice Claim liquidity pool tokens and the reward after liquidity has been released.\r\n    /// @param _for The address to release the liquidity pool tokens and the reward for.\r\n    function claim(address _for)\r\n        external\r\n    {\r\n        require(liquidityReleaseTime <= block.timestamp, \"ABQILO/liquidity-locked\");\r\n        require(isLiquidityEstablished, \"ABQILO/liquidity-not-established\");\r\n\r\n        // CG: we can divide be 1 ether since we made sure values does not include any values in the last 18 decimals. See the provideLiquidity token.\r\n        uint256 claimShareFull = liquidityBalances[_for];\r\n        if (claimShareFull == 0)\r\n        {\r\n            return;\r\n        }\r\n        uint256 claimShare = (claimShareFull / 1 ether);\r\n        uint256 claimPool = (totalLiquidityProvided / 1 ether);\r\n\r\n        // CG: remove claim share from accounts\r\n        totalLiquidityProvided = SafeMathTyped.sub256(totalLiquidityProvided, claimShareFull);\r\n        liquidityBalances[_for] = 0;\r\n\r\n        // CG: get uniswap pair\r\n        IUniswapV2Factory factory = IUniswapV2Factory(uniswapRouter.factory());\r\n        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(address(tokenOffer), address(liquidityToken)));\r\n        require(address(pair) != address(0), \"ABQILO/pair-not-created\");\r\n        uint256 pairBalance = pair.balanceOf(address(this));\r\n\r\n        // CG: transfer claim\r\n        uint256 claimTotal = SafeMathTyped.mul256(pairBalance, claimShare) / claimPool;\r\n        bool couldTransfer = pair.transfer(_for, claimTotal);\r\n        require(couldTransfer, \"ABQILO/could-not-transfer\");\r\n\r\n        // CG: mint reward: 25% of original contribution as reward tokens.\r\n        uint256 reward = SafeMathTyped.mul256(claimShareFull, 25) / 100;\r\n        minter.mint(_for, reward);\r\n\r\n        emit Claim(_for, claimTotal, reward);\r\n    }\r\n}"
    },
    "contracts/Minter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n// This code is the property of the Aardbanq DAO.\r\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\r\n// It is the author's wish that this code should be open sourced under the MIT license, but the final \r\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \r\n// distributed.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\npragma solidity >=0.7.0;\r\n\r\ninterface Minter\r\n{\r\n    function mint(address _target, uint256 _amount) external;\r\n}"
    },
    "contracts/SafeMathTyped.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMathTyped {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"uint256 overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"Can't divide by 0\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"uint256 underflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"uint256 overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"Can't mod by 0\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the greater of two numbers\r\n    */\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the lesser of two numbers\r\n    */\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n}"
    },
    "contracts/SaleRatification.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.7.0;\r\nimport \"./ScaleBuying.sol\";\r\nimport \"./InitialLiquidityOffering.sol\";\r\nimport \"./DelegateOwnershipManager.sol\";\r\nimport \"./AbqErc20.sol\";\r\n\r\ncontract SaleRatification\r\n{\r\n    function ratify(InitialLiquidityOffering _ilo, ScaleBuying _ico, address _treasury, DelegateOwnershipManager _ownershipManager, AbqErc20 _token)\r\n        external\r\n    {\r\n        _ilo.setPricer(_ico);\r\n        _ico.setLiquidityEstablisher(_ilo);\r\n        _token.changeOwner(address(_ownershipManager));\r\n        _ownershipManager.setMintPermission(address(_ilo), true);\r\n        _ownershipManager.setMintPermission(address(_ico), true);\r\n        _ownershipManager.mint(address(_ico), 11585 ether); // CG: Auction tokens\r\n        _ownershipManager.mint(address(_treasury), 50000 ether);    // CG: Bounty tokens\r\n    }\r\n}"
    },
    "contracts/ScaleBuying.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n// This code is the property of the Aardbanq DAO.\r\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\r\n// It is the author's wish that this code should be open sourced under the MIT license, but the final \r\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \r\n// distributed.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\npragma solidity >=0.7.0;\r\nimport \"./SafeMathTyped.sol\";\r\nimport \"./Erc20.sol\";\r\nimport './Minter.sol';\r\nimport \"./IPricer.sol\";\r\nimport \"./ILiquidityEstablisher.sol\";\r\n\r\n/// @notice Allow buying of tokens in batches of increasing price.\r\ncontract ScaleBuying is IPricer\r\n{\r\n    /// @notice The token to use for purchasing\r\n    Erc20 public paymentAsset;\r\n    /// @notice The token that is being bought\r\n    Erc20 public boughtAsset;\r\n    /// @notice The minter for the token being bought\r\n    Minter public minter;\r\n    /// @notice The date in unix timestamp (seconds) when the sale closes.\r\n    uint64 public closingDate;\r\n    /// @notice The address to which the funds should be sent to.\r\n    address public treasury;\r\n    /// @notice The location of the ILO, used to know when tokens can be claimed.\r\n    ILiquidityEstablisher public liquidityEstablisher;\r\n    /// @notice The amount that has been awarded so far.\r\n    uint256 public amountAwarded;\r\n    /// @notice The initial price for the sale.\r\n    uint256 public initialPrice;\r\n    /// @notice The price increase for each token block.\r\n    uint256 public priceIncrease;\r\n    /// @notice The amount of tokens per block.\r\n    uint256 public tokensPerPriceBlock;\r\n    /// @notice The number of blocks up for sale.\r\n    uint256 public maxBlocks;\r\n\r\n    /// @notice The amounts of tokens claimable by an address.\r\n    mapping(address => uint256) public amountsClaimable;\r\n\r\n    /// @notice Constructs a ScaleBuying\r\n    /// @param _paymentAsset The token address to be used for payment.\r\n    /// @param _boughtAsset The token address to be issued.\r\n    /// @param _minter The minter for the issued token.\r\n    /// @param _treasury The address to receive all funds.\r\n    /// @param _initialPrice The initial price per token.\r\n    /// @param _priceIncrease The increase of the price per token for each block.\r\n    /// @param _tokensPerPriceBlock The tokens in each block.\r\n    /// @param _maxBlocks The maximum number of blocks on sale.\r\n    /// @param _closingDate The date in unix (seconds) timestamp that the sale will close.\r\n    constructor (Erc20 _paymentAsset, Erc20 _boughtAsset, Minter _minter, address _treasury, uint256 _initialPrice, \r\n        uint256 _priceIncrease, uint256 _tokensPerPriceBlock, uint256 _maxBlocks, uint64 _closingDate)\r\n    {\r\n        paymentAsset = _paymentAsset;\r\n        boughtAsset = _boughtAsset;\r\n        minter = _minter;\r\n        treasury = _treasury;\r\n        amountAwarded = 0;\r\n        initialPrice = _initialPrice;\r\n        priceIncrease = _priceIncrease;\r\n        tokensPerPriceBlock = _tokensPerPriceBlock;\r\n        maxBlocks = _maxBlocks;\r\n        closingDate = _closingDate;\r\n\r\n        allocateTokensRaisedByAuction();\r\n    }\r\n\r\n    // CG: This allocates the amount of tokens that was already bought on auction before\\\r\n    //     switching over to this Scale Buying.\r\n    function allocateTokensRaisedByAuction() \r\n        private\r\n    {\r\n        uint256 price = initialPrice;\r\n        \r\n        uint256 buyerAAmount = 7165 ether;\r\n        amountsClaimable[0xEE779e4b3e7b11454ed80cFE12Cf48ee3Ff4579E] = buyerAAmount;\r\n        emit Bought(0xEE779e4b3e7b11454ed80cFE12Cf48ee3Ff4579E, buyerAAmount, price);\r\n        \r\n        uint256 buyerBAmount = 4065 ether;\r\n        amountsClaimable[0x6C4f3Db0E743A9e8f44A756b6585192B358D7664] = buyerBAmount;\r\n        emit Bought(0x6C4f3Db0E743A9e8f44A756b6585192B358D7664, buyerAAmount, price);\r\n\r\n        uint256 buyerCAmount = 355 ether;\r\n        amountsClaimable[0x0FB79E6C0F5447ffe36a0050221275Da487b0E09] = buyerCAmount;\r\n        emit Bought(0x0FB79E6C0F5447ffe36a0050221275Da487b0E09, buyerAAmount, price);\r\n\r\n        amountAwarded = buyerAAmount + buyerBAmount + buyerCAmount;\r\n    }\r\n\r\n    /// @notice Set the ILO to use to track if liquidity has been astablished and thus claims can be allowed.\r\n    /// @param _liquidityEstablisher The ILO.\r\n    function setLiquidityEstablisher(ILiquidityEstablisher _liquidityEstablisher)\r\n        external\r\n    {\r\n        require(address(liquidityEstablisher) == address(0), \"ABQDAO/already-set\");\r\n\r\n        liquidityEstablisher = _liquidityEstablisher;\r\n    }\r\n\r\n    /// @notice The event emitted when a claim is executed.\r\n    /// @param claimer The address the claim has been processed for.\r\n    /// @param amount The amount that was claimed.\r\n    event Claimed(address indexed claimer, uint256 amount);\r\n    /// @notice Claim ABQ bought for the given address. Claims can only be processed after liquidity has been established.\r\n    /// @param _target The address to process claims for.\r\n    function claim(address _target)\r\n        external\r\n    {\r\n        // CG: Claims cannot be executed before liquidity is established or closed more than a week ago.\r\n        require(liquidityEstablisher.isLiquidityEstablishedOrExpired(), \"ABQDAO/cannot-claim-yet\");\r\n\r\n        uint256 amountClaimable = amountsClaimable[_target];\r\n        if (amountClaimable > 0)\r\n        {\r\n            bool isSuccess = boughtAsset.transfer(_target, amountClaimable);\r\n            require(isSuccess, \"ABQDAO/could-not-transfer-claim\");\r\n            amountsClaimable[_target] = 0;\r\n            emit Claimed(_target, amountClaimable);\r\n        }\r\n    }\r\n\r\n    /// @notice The event emitted when tokens are bought.\r\n    /// @param buyer The address that may claim the tokens.\r\n    /// @param amount The amount of token bought.\r\n    /// @param pricePerToken The price per token that the tokens were bought for.\r\n    event Bought(address indexed buyer, uint256 amount, uint256 pricePerToken);\r\n    /// @notice Buy tokens in the current block.\r\n    /// @param _paymentAmount The amount to spend. This will be transfered from msg.sender who should approved this amount first.\r\n    /// @param _target The address that the amounts would be bought for. Tokens are distributed after calling the claim method.\r\n    function buy(uint256 _paymentAmount, address _target) \r\n        external\r\n        returns (uint256 _paymentLeft)\r\n    {\r\n        // CG: only allow buys before the ico closes.\r\n        require(block.timestamp <= closingDate, \"ABQDAO/ico-concluded\");\r\n\r\n        (uint256 paymentLeft, uint256 paymentDue) = buyInBlock(_paymentAmount, _target);\r\n        // CG: transfer payment\r\n        if (paymentDue > 0)\r\n        {\r\n            bool isSuccess = paymentAsset.transferFrom(msg.sender, treasury, paymentDue);\r\n            require(isSuccess, \"ABQDAO/could-not-pay\");\r\n        }\r\n        return paymentLeft;\r\n    }\r\n\r\n    function buyInBlock(uint256 _paymentAmount, address _target)\r\n        private\r\n        returns (uint256 _paymentLeft, uint256 _paymentDue)\r\n    {\r\n        uint256 currentBlockIndex = currentBlock();\r\n        uint256 tokensLeft = tokensLeftInBlock(currentBlockIndex);\r\n\r\n        if (currentBlockIndex >= maxBlocks)\r\n        {\r\n            // CG: If all block are sold out, then amount bought should be zero.\r\n            return (_paymentAmount, 0);\r\n        }\r\n        else\r\n        {\r\n            uint256 currentPriceLocal = currentPrice();\r\n            uint256 tokensCanPayFor = _paymentAmount / currentPriceLocal;\r\n            if (tokensCanPayFor == 0)\r\n            {\r\n                return (_paymentAmount, 0);\r\n            }\r\n            if (tokensCanPayFor > (tokensLeft / 1 ether))\r\n            {\r\n                tokensCanPayFor = tokensLeft / 1 ether;\r\n            }\r\n\r\n            // CG: Get the amount of tokens that can be bought in this block.\r\n            uint256 paymentDue = SafeMathTyped.mul256(tokensCanPayFor, currentPriceLocal);\r\n            tokensCanPayFor = SafeMathTyped.mul256(tokensCanPayFor, 1 ether);\r\n            amountsClaimable[_target] = SafeMathTyped.add256(amountsClaimable[_target], tokensCanPayFor);\r\n            amountAwarded = SafeMathTyped.add256(amountAwarded, tokensCanPayFor);\r\n            minter.mint(address(this), tokensCanPayFor);\r\n            emit Bought(_target, tokensCanPayFor, currentPriceLocal);\r\n            uint256 paymentLeft = SafeMathTyped.sub256(_paymentAmount, paymentDue);\r\n            \r\n            if (paymentLeft <= currentPriceLocal)\r\n            {\r\n                return (paymentLeft, paymentDue);\r\n            }\r\n            else\r\n            {\r\n                // CG: should this block be sold out, buy the remainder in the next box.\r\n                (uint256 subcallPaymentLeft, uint256 subcallPaymentDue) = buyInBlock(paymentLeft, _target);\r\n                paymentDue = SafeMathTyped.add256(paymentDue, subcallPaymentDue);\r\n                return (subcallPaymentLeft, paymentDue);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Get the current price per token.\r\n    /// @return _currentPrice The current price per token.\r\n    function currentPrice()\r\n        view\r\n        public\r\n        override\r\n        returns (uint256 _currentPrice)\r\n    {\r\n        return SafeMathTyped.add256(initialPrice, SafeMathTyped.mul256(currentBlock(), priceIncrease));\r\n    }\r\n\r\n    /// @notice Get the current block number, starting at 0.\r\n    function currentBlock() \r\n        view\r\n        public\r\n        returns (uint256 _currentBlock)\r\n    {\r\n        return amountAwarded / tokensPerPriceBlock;\r\n    }\r\n\r\n    /// @notice Get the amount of tokens left in a given block.\r\n    /// @param _block The block to get the number of tokens left for.\r\n    /// @return _tokensLeft The number of tokens left in the given _block.\r\n    function tokensLeftInBlock(uint256 _block)\r\n        view\r\n        public\r\n        returns (uint256 _tokensLeft)\r\n    {\r\n        uint256 currentBlockIndex = currentBlock();\r\n\r\n        if (_block > maxBlocks || _block < currentBlockIndex)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        if (_block == currentBlockIndex)\r\n        {\r\n            //CG: non overflow code: return ((currentBlockIndex + 1) * tokensPerPriceBlock) - amountAwarded;\r\n            return SafeMathTyped.sub256(SafeMathTyped.mul256(SafeMathTyped.add256(currentBlockIndex, 1), tokensPerPriceBlock), amountAwarded);\r\n        }\r\n        else\r\n        {\r\n            return tokensPerPriceBlock;\r\n        }\r\n    }\r\n}"
    }
  }
}