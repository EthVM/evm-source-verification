{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Fanaply.sol":{"content":"/*\r\nVERSION DATE: 21/11/2020\r\n*/\r\n\r\ncontract Owned \r\n{\r\n\taddress public owner;\r\n\r\n\tmapping(address => uint64) public admins;\r\n\t\r\n    constructor() public \r\n\t{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function changeOwner(address newOwner) public \r\n\t{\r\n\t\trequire(msg.sender == owner);\r\n        owner = newOwner;\r\n    }\r\n\t\r\n\tevent AddAdmin(address user, uint64 count);\r\n\tevent RemoveAdmin(address user);\r\n\t\t\r\n    function addAdmin(address addr, uint64 count) public \r\n\t{\r\n\t\trequire(msg.sender == owner);\r\n\t\trequire(addr != address(0));\r\n\t\tadmins[addr] = admins[addr] + count;\r\n\t\t\r\n\t\temit AddAdmin(addr, admins[addr]);\r\n    }\r\n\r\n    function removeAdmin(address addr) public\r\n\t{\r\n\t\trequire(msg.sender == owner);\r\n\t\trequire(admins[addr]>0);\r\n\t\tdelete admins[addr];\r\n\t\t\r\n\t\temit RemoveAdmin(addr);\r\n    }\r\n\t\r\n    function decAdmin(address addr) internal\r\n\t{\r\n\t\trequire(admins[addr]>0);\r\n\t\tadmins[addr]--;\r\n    }\t\r\n\t\r\n\tmodifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\t\r\n\tmodifier onlyAdmin {\r\n        require(admins[msg.sender]>0);\r\n        _;\r\n    }\r\n\t\r\n\tfunction timenow() public view returns(uint32) { return uint32(block.timestamp); }\r\n}\r\n\r\ncontract ERC721\r\n{\r\n\tfunction implementsERC721() public pure returns (bool);\r\n\tfunction balanceOf(address _owner) public view returns (uint256 balance);\r\n\tfunction ownerOf(uint256 _tokenId) public view returns (address owner);\r\n\tfunction approve(address _to, uint256 _tokenId) public;\r\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\tfunction transfer(address _to, uint256 _tokenId) public;\r\n \r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n}\r\n\r\ncontract ExpandedToken is ERC721, Owned\r\n{\r\n\tevent SetName(string _name, string _symbol);\r\n\r\n\tuint256 public totalSupply;\r\n\tuint256 public idCurToken = 0;\r\n\t\r\n\tstring public name = \"\";\r\n\tstring public symbol = \"\";\r\n\t\r\n\tfunction setName(string memory _name, string memory _symbol) public onlyOwner \r\n\t{\r\n\t\tname = _name;\r\n\t\tsymbol = _symbol;\r\n\t\temit SetName(name,symbol);\r\n\t}\r\n\r\n\t\r\n\t/*\r\n\tpacked 256 bits :\r\n\t[ idType ][ idLocalToken ][ time ]\r\n\t[   96   ][     128      ][  32  ]\t\r\n\t*/\r\n\t\r\n\tmapping(uint256 => uint256) tokensG2L;\t\t\t\t\t\t// globalId => packed\r\n\tmapping(uint256 => mapping (uint256 => uint256)) tokensL2G; // typeId => localTokenId => globalId\r\n\t\t\r\n\tfunction getGlobalId(uint typeId, uint localTokenId) public view returns ( uint tokenId )\t\t\r\n\t{\r\n\t\ttokenId = tokensL2G[typeId][localTokenId];\r\n\t}\r\n\t\r\n\tmapping (uint256 => address) private tokenIndexToOwner;\r\n\tmapping (address => uint256) public  ownershipTokenCount; \r\n\tmapping (uint256 => address) private tokenIndexToApproved;\r\n\t\r\n\tfunction implementsERC721() public pure returns (bool)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction balanceOf(address _owner) public view returns (uint256 count) \r\n\t{\r\n\t\treturn ownershipTokenCount[_owner];\r\n\t}\r\n\t\r\n\tfunction ownerOf(uint256 _tokenId) public view returns (address owner)\r\n\t{\r\n\t\tif(_tokenId > totalSupply || _tokenId==0) owner = address(0);\r\n\t\telse {\r\n\t\t\towner = tokenIndexToOwner[_tokenId];\r\n\t\t\tif (owner == address(0)) owner = address(this);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction _approve(uint256 _tokenId, address _approved) internal \r\n\t{\r\n\t\ttokenIndexToApproved[_tokenId] = _approved;\r\n\t}\r\n\t\r\n\tfunction _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool)\r\n\t{\r\n\t\treturn tokenIndexToApproved[_tokenId] == _claimant;\r\n\t}\r\n\t\r\n\tfunction approve( address _to, uint256 _tokenId ) public\r\n\t{\r\n\t\trequire(_owns(msg.sender, _tokenId));\r\n\t\t_approve(_tokenId, _to);\r\n\t\temit Approval(msg.sender, _to, _tokenId);\r\n\t}\r\n\t\r\n\tfunction transferFrom( address _from, address _to, uint256 _tokenId ) public\r\n\t{\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_to != address(this));\r\n\t\trequire(_approvedFor(msg.sender, _tokenId));\r\n\t\trequire(_owns(_from, _tokenId));\r\n\t\t_transfer(_from, _to, _tokenId);\r\n\t}\r\n\t\r\n\tfunction _owns(address _claimant, uint256 _tokenId) internal view returns (bool)\r\n\t{\t\r\n\t\tif (_tokenId > totalSupply || _tokenId==0) return false;\r\n\t\tif (tokenIndexToOwner[_tokenId] == _claimant) return true;\r\n\t\tif (tokenIndexToOwner[_tokenId] == address(0) && _claimant == address(this) ) return true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction _transfer(address _from, address _to, uint256 _tokenId) internal \r\n\t{\r\n\t\trequire( ownershipTokenCount[_from] > 0 );\r\n\t\t\r\n\t\townershipTokenCount[_to]++;\r\n\t\townershipTokenCount[_from]--;\r\n\t\t\r\n\t\ttokenIndexToOwner[_tokenId] = _to;\r\n\t\t\r\n\t\tdelete tokenIndexToApproved[_tokenId];\r\n\t\tdelete tokenAuction[_tokenId];\r\n\r\n\t\temit Transfer(_from, _to, _tokenId);\r\n\t}\r\n\t\r\n\tfunction transfer(address _to, uint256 _tokenId) public\r\n\t{\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_to != address(this));\r\n\t\trequire(_owns(msg.sender, _tokenId));\r\n\t\t_transfer(msg.sender, _to, _tokenId);\r\n\t}\r\n\r\n\tstruct Auction\r\n\t{\r\n        address seller;\r\n        uint startingPrice;\r\n        uint endingPrice;\r\n        uint32 startedAt;\r\n\t\tuint32 period;\r\n\t\tuint32 blocks;\r\n    }\r\n\r\n\tmapping (uint256 => Auction) tokenAuction;\r\n\t\r\n\tevent CreateAuction(uint256 tokenId, uint32 startedAt, uint256 startingPrice, uint256 endingPrice, uint32 period, uint32 blocks);\r\n\tevent CancelAuction(uint tokenId);\r\n\tevent CompleteAuction(uint tokenId);\r\n\t\r\n\tuint256 public feePercent;\r\n\taddress public constant feeAddress = 0x15b8a6F624C9666f7EE7D35BC093305eBfb8C8C2;\r\n\t\r\n\tfunction createAuction( uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint32 period, uint32 blocks ) public\r\n    {\r\n        require(_owns(msg.sender, tokenId));\r\n\t\trequire(tokenAuction[tokenId].startedAt==0);\r\n\t\trequire(period >= 1 minutes && period <= 30 days);\r\n\t\trequire(blocks>=1 && blocks <=10);\r\n\t\trequire(startingPrice > 0);\r\n\t\trequire(endingPrice > 0);\r\n\t\t\r\n        Auction memory auction = Auction(\r\n            msg.sender,\r\n            startingPrice,\r\n            endingPrice,\r\n            timenow(),\r\n\t\t\tperiod,\r\n\t\t\tblocks\r\n        );\r\n\t\t\r\n\t\ttokenAuction[tokenId] = auction;\r\n\t\t\r\n        emit CreateAuction(tokenId, timenow(), startingPrice, endingPrice, period, blocks);\r\n    }\r\n\r\n\tfunction cancelAuction(uint256 tokenId) public\r\n\t{\r\n        require(_owns(msg.sender, tokenId));\r\n\t\trequire(tokenAuction[tokenId].startedAt!=0);\r\n\r\n\t\tdelete tokenAuction[tokenId];\r\n\r\n        emit CancelAuction(tokenId);\r\n    }\r\n\r\n\tfunction getAuction(uint256 tokenId) public view returns\r\n    (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint32 startedAt,\r\n\t\tuint32 period,\r\n\t\tuint32 blocks,\r\n\t\tuint curPrice\r\n    ){\r\n        Auction storage auction = tokenAuction[tokenId];\r\n        if(tokenAuction[tokenId].startedAt!=0)\r\n\t\t{\r\n\t\t\tseller = auction.seller;\r\n\t\t\tstartingPrice = auction.startingPrice;\r\n\t\t\tendingPrice = auction.endingPrice;\r\n\t\t\tstartedAt = auction.startedAt;\r\n\t\t\tperiod = auction.period;\r\n\t\t\tblocks = auction.blocks;\r\n\t\t\tcurPrice = getCurrentPrice(tokenId);\r\n\t\t}\r\n    }\r\n\r\n\tfunction getCurrentPrice(uint256 tokenId) public view returns (uint)\r\n    {\r\n\t\tAuction storage auction = tokenAuction[tokenId];\r\n\r\n\t\tif(tokenAuction[tokenId].startedAt==0) return 0;\r\n\t\tif(timenow()>=auction.startedAt + auction.period) return auction.endingPrice;\r\n\t\t\r\n\t\tint changePriceOfStage = (int(auction.endingPrice) - int(auction.startingPrice)) / auction.blocks;\r\n\t\tuint32 periodOfStage = auction.period / auction.blocks;\r\n\t\tuint32 curStage = ( timenow() - auction.startedAt ) / periodOfStage;\r\n\t\tuint price = uint(int(auction.startingPrice) + changePriceOfStage * curStage);\r\n\t\t\t\t\r\n\t\treturn price;\r\n\t}\r\n\t\r\n\tfunction bid(uint256 tokenId) public payable\r\n\t{\r\n\t\tAuction storage auction = tokenAuction[tokenId];\r\n\t\t\r\n\t\trequire(auction.startedAt!=0);\r\n\t\t\r\n\t\tuint256 price = getCurrentPrice(tokenId);\r\n        require(msg.value == price);\r\n\t\t\r\n\t\taddress seller = auction.seller;\r\n\t\trequire(msg.sender != seller);\r\n\r\n\t\t_transfer(seller, msg.sender, tokenId);\r\n\t\t\r\n        uint256 curFee = price * feePercent / 100;\r\n        uint256 sendValue = price - curFee;\r\n\r\n        seller.transfer(sendValue);\r\n\t\tfeeAddress.transfer(curFee);\r\n\r\n\t\temit CompleteAuction(tokenId);\r\n\t}\r\n\t\r\n}\r\n\r\ncontract Variety is ExpandedToken\r\n{\r\n\tstruct Types\r\n\t{\r\n\t\tstring category;\r\n\t\tuint param;\r\n\t}\r\n\r\n\tuint countTypes = 0;\r\n\t\r\n\tmapping(uint256 => Types) typesById;\r\n\tmapping(string => uint256) private typesByName;\r\n\r\n\r\n\tfunction getTokenInfo(uint tokenId) public view returns ( \r\n\t\tuint32 time,\r\n\t\tuint idTypes,\r\n\t\tstring category,\r\n\t\tuint idLocalToken\r\n\t){\r\n\t\tuint256 token = tokensG2L[tokenId];\r\n\t\t\r\n\t\ttime = uint32(token & 0xFFFFFFFF);\r\n\t\tidLocalToken = uint128(token >> 32 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\t\tidTypes = uint128(token >> 160);\r\n\r\n\t\tcategory = typesById[idTypes].category;\r\n\t}\r\n\t\r\n\tfunction getTypesById(uint256 typeId) public view returns (\r\n\t\tstring category,\r\n\t\tuint32 time,\r\n\t\tuint count,\r\n\t\tuint issued\r\n\t){\r\n\t\tcategory = typesById[typeId].category;\r\n\t\t\r\n\t\tuint256 packed = typesById[typeId].param;\r\n\t\t\r\n\t\ttime = uint32(packed & 0xFFFFFFFF);\r\n\t\tcount = uint128(packed >> 32 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\t\tissued = uint128(packed >> 160);\r\n\t}\r\n\r\n\tfunction getTypesByName(string category) public view returns (\r\n\t\tuint idType,\r\n\t\tuint32 time,\r\n\t\tuint count,\r\n\t\tuint issued\r\n\t){\r\n\t\tidType = typesByName[category];\r\n\t\tuint256 packed = typesById[idType].param;\r\n\t\t\r\n\t\ttime = uint32(packed & 0xFFFFFFFF);\r\n\t\tcount = uint128(packed >> 32 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\t\tissued = uint128(packed >> 160);\r\n\t}\r\n\r\n\tevent CreateType(uint typeId, string category, uint count);\r\n\t\r\n\tfunction createTypes(string _category, uint _count) public onlyAdmin\r\n\t{\r\n\t\trequire( bytes(_category).length >= 3 );\r\n\t\trequire( _count > 0 );\r\n\t\t\r\n\t\tdecAdmin(msg.sender);\r\n\t\t\r\n\t\tcountTypes++;\r\n\t\t\r\n\t\ttotalSupply += _count;\r\n\t\townershipTokenCount[address(this)] += _count;\r\n\t\t\r\n\t\trequire( typesByName[_category] == 0 );\r\n\t\t\r\n\t\tuint256 packed = ( uint128(_count) << 32 ) + uint32(block.timestamp);\r\n\t\t\r\n\t\tTypes memory _type = Types({\r\n\t\t\tcategory: _category,\r\n\t\t\tparam: packed\r\n\t\t});\r\n\r\n\t\ttypesById[countTypes] = _type;\r\n\t\ttypesByName[_category] = countTypes;\r\n\t\t\r\n\t\temit CreateType(countTypes, _category, _count);\r\n\t}\r\n\t\r\n}\r\n\r\ncontract Fanaply is Variety\r\n{\r\n\tmapping (uint64 => bool) public nonces;\r\n\t\r\n\tconstructor(\r\n\t\tstring memory name,\r\n\t\tstring memory symbol,\r\n\t\taddress adminAddr,\r\n\t\tuint64 adminCount,\r\n\t\tuint feeValue ) public\r\n\t{\r\n\t\trequire( feeValue >=1 && feeValue <=50 );\r\n\t\t\r\n\t\tsetName(name, symbol);\t\r\n\r\n\t\taddAdmin(adminAddr, adminCount);\r\n\t\tfeePercent = feeValue;\r\n\t}\r\n\r\n\r\n\tevent ReturnToken(address user, uint typeId, uint localTokenId, uint tokenId);\r\n\t\t\r\n\tfunction returnToken(uint idToken) public\r\n\t{\r\n\t\trequire(tokensG2L[idToken]!=0);\r\n\r\n\t\trequire(ownerOf(idToken) == msg.sender);\r\n\t\t\r\n\t\t_transfer(msg.sender, address(this), idToken);\r\n\r\n\t\tuint256 token = tokensG2L[idToken];\r\n\t\tuint128 localId = uint128(token >> 32 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\t\tuint128 typeId = uint128(token >> 160);\r\n\t\t\r\n\t\tuint256 packed = typesById[typeId].param;\r\n\t\tuint32 time = uint32(packed & 0xFFFFFFFF);\r\n\t\tuint128 count = uint128(packed >> 32 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\t\tuint128 issued = uint128(packed >> 160);\r\n\r\n\t\trequire( issued > 0 );\r\n\t\t\r\n\t\tissued--;\r\n\t\tpacked = (uint256(issued) << 160) + (uint128(count) << 32) + uint32(time);\r\n\t\ttypesById[typeId].param = packed;\r\n\t\t\r\n\t\temit ReturnToken(msg.sender, typeId, localId, idToken);\r\n\t}\r\n\t\r\n\r\n\tevent TakeToken(address user, uint typeId, uint localTokenId, uint tokenId);\r\n\t\r\n\tfunction createToken(uint256 typeId, uint256 localTokenId) internal\r\n\t{\r\n\t\tuint global = tokensL2G[typeId][localTokenId];\r\n\t\trequire(global==0 || _owns(address(this), global));\r\n\t\t\r\n\t\tuint256 packed = typesById[typeId].param;\r\n\t\tuint32 time = uint32(packed & 0xFFFFFFFF);\r\n\t\tuint128 count = uint128(packed >> 32 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\t\tuint128 issued = uint128(packed >> 160);\r\n\t\trequire( issued < count );\r\n\t\t\r\n\t\tissued++;\r\n\t\tpacked = (uint256(issued) << 160) + (uint128(count) << 32) + uint32(time);\r\n\t\ttypesById[typeId].param = packed;\r\n\r\n\t\trequire( localTokenId <= count );\r\n\r\n\t\tuint idToken = 0;\r\n\t\tif (global==0) idToken = ++idCurToken;\r\n\t\t\telse idToken = global;\r\n\t\t\r\n\t\tuint256 token = ( uint256(typeId) << 160 ) + ( uint128(localTokenId) << 32 ) + uint32(block.timestamp);\r\n\t\ttokensG2L[idToken] = token;\r\n\t\ttokensL2G[typeId][localTokenId] = idToken;\r\n\t\t\r\n\t\t_transfer(address(this), msg.sender, idToken);\r\n\t\t\r\n\t\temit TakeToken(msg.sender, typeId, localTokenId, idToken);\r\n\t}\r\n\t\r\n\tfunction takeToken(uint256 typeId, uint256 localTokenId, uint64 nonce, bytes32 r, bytes32 s, uint8 v) public\r\n\t{\r\n\t\trequire(typeId>0);\r\n\t\trequire(localTokenId>0);\r\n\r\n\t\tbytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n\t\tbytes32 hash = keccak256( abi.encodePacked(address(this), msg.sender, nonce, typeId, localTokenId) );\r\n        address signer = ecrecover(keccak256( abi.encodePacked(prefix,hash)), v, r, s);\r\n\r\n\t\trequire(nonces[nonce] == false);\r\n\t\tnonces[nonce] = true;\r\n\t\tdecAdmin(signer);\r\n\t\r\n\t\tcreateToken(typeId, localTokenId);\r\n\t}\r\n\t\r\n\tfunction () onlyOwner payable public {}\r\n}"}}}