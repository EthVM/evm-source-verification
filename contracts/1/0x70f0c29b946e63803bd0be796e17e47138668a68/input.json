{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "data/source/raiden/SecretRegistry.sol": {
      "content": "pragma solidity 0.6.4;\n\n/// @title SecretRegistry\n/// @notice SecretRegistry contract for registering secrets from Raiden Network\n/// clients.\ncontract SecretRegistry {\n    // sha256(secret) => block number at which the secret was revealed\n    mapping(bytes32 => uint256) private secrethash_to_block;\n\n    event SecretRevealed(bytes32 indexed secrethash, bytes32 secret);\n\n    /// @notice Registers a hash time lock secret and saves the block number.\n    /// This allows the lock to be unlocked after the expiration block\n    /// @param secret The secret used to lock the hash time lock\n    /// @return true if secret was registered, false if the secret was already\n    /// registered\n    function registerSecret(bytes32 secret) public returns (bool) {\n        bytes32 secrethash = sha256(abi.encodePacked(secret));\n        if (secrethash_to_block[secrethash] > 0) {\n            return false;\n        }\n        secrethash_to_block[secrethash] = block.number;\n        emit SecretRevealed(secrethash, secret);\n        return true;\n    }\n\n    /// @notice Registers multiple hash time lock secrets and saves the block\n    /// number\n    /// @param secrets The array of secrets to be registered\n    /// @return true if all secrets could be registered, false otherwise\n    function registerSecretBatch(bytes32[] memory secrets) public returns (bool) {\n        bool completeSuccess = true;\n        for(uint i = 0; i < secrets.length; i++) {\n            if(!registerSecret(secrets[i])) {\n                completeSuccess = false;\n            }\n        }\n        return completeSuccess;\n    }\n\n    /// @notice Get the stored block number at which the secret was revealed\n    /// @param secrethash The hash of the registered secret `keccak256(secret)`\n    /// @return The block number at which the secret was revealed\n    function getSecretRevealBlockHeight(bytes32 secrethash) public view returns (uint256) {\n        return secrethash_to_block[secrethash];\n    }\n}\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"
    }
  }
}