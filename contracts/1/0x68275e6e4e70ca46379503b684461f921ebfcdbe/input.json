{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CustomERC20.sol":{"content":"// File: contracts/lib/SafeMath.sol\n\n/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title SafeMath\n * @author DODO Breeder\n *\n * @notice Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"MUL_ERROR\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"DIVIDING_ERROR\");\n        return a / b;\n    }\n\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 quotient = div(a, b);\n        uint256 remainder = a - quotient * b;\n        if (remainder > 0) {\n            return quotient + 1;\n        } else {\n            return quotient;\n        }\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SUB_ERROR\");\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ADD_ERROR\");\n        return c;\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = x / 2 + 1;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n}\n\n// File: contracts/lib/InitializableOwnable.sol\n\n/**\n * @title Ownable\n * @author DODO Breeder\n *\n * @notice Ownership related functions\n */\ncontract InitializableOwnable {\n    address public _OWNER_;\n    address public _NEW_OWNER_;\n    bool internal _INITIALIZED_;\n\n    // ============ Events ============\n\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // ============ Modifiers ============\n\n    modifier notInitialized() {\n        require(!_INITIALIZED_, \"DODO_INITIALIZED\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\n        _;\n    }\n\n    // ============ Functions ============\n\n    function initOwner(address newOwner) public notInitialized {\n        _INITIALIZED_ = true;\n        _OWNER_ = newOwner;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n        _NEW_OWNER_ = newOwner;\n    }\n\n    function claimOwnership() public {\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n        _OWNER_ = _NEW_OWNER_;\n        _NEW_OWNER_ = address(0);\n    }\n}\n\n// File: contracts/external/ERC20/CustomERC20.sol\n\n\ncontract CustomERC20 is InitializableOwnable {\n    using SafeMath for uint256;\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    uint256 public totalSupply;\n\n    uint256 public tradeBurnRatio;\n    uint256 public tradeFeeRatio;\n    address public team;\n    bool public isMintable;\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event Mint(address indexed user, uint256 value);\n    event Burn(address indexed user, uint256 value);\n\n    event ChangeTeam(address oldTeam, address newTeam);\n\n\n    function init(\n        address _creator,\n        uint256 _initSupply,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _tradeBurnRatio,\n        uint256 _tradeFeeRatio,\n        address _team,\n        bool _isMintable\n    ) public {\n        initOwner(_creator);\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _initSupply;\n        balances[_creator] = _initSupply;\n        require(_tradeBurnRatio >= 0 && _tradeBurnRatio <= 5000, \"TRADE_BURN_RATIO_INVALID\");\n        require(_tradeFeeRatio >= 0 && _tradeFeeRatio <= 5000, \"TRADE_FEE_RATIO_INVALID\");\n        tradeBurnRatio = _tradeBurnRatio;\n        tradeFeeRatio = _tradeFeeRatio;\n        team = _team;\n        isMintable = _isMintable;\n        emit Transfer(address(0), _creator, _initSupply);\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        _transfer(msg.sender,to,amount);\n        return true;\n    }\n\n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(amount <= allowed[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n        _transfer(from,to,amount);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        allowed[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowed[owner][spender];\n    }\n\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(balances[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        balances[sender] = balances[sender].sub(amount);\n\n        uint256 burnAmount;\n        uint256 feeAmount;\n        if(tradeBurnRatio > 0) {\n            burnAmount = amount.mul(tradeBurnRatio).div(10000);\n            balances[address(0)] = balances[address(0)].add(burnAmount);\n        }\n\n        if(tradeFeeRatio > 0) {\n            feeAmount = amount.mul(tradeFeeRatio).div(10000);\n            balances[team] = balances[team].add(feeAmount);\n        }\n\n        balances[recipient] = balances[recipient].add(amount.sub(burnAmount).sub(feeAmount));\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function burn(uint256 value) external {\n        require(isMintable, \"NOT_MINTABEL_TOKEN\");\n        require(balances[msg.sender] >= value, \"VALUE_NOT_ENOUGH\");\n\n        balances[msg.sender] = balances[msg.sender].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Burn(msg.sender, value);\n        emit Transfer(msg.sender, address(0), value);\n    }\n\n    //=================== Ownable ======================\n    function mint(address user, uint256 value) external onlyOwner {\n        require(isMintable, \"NOT_MINTABEL_TOKEN\");\n        require(user == _OWNER_, \"NOT_OWNER\");\n        \n        balances[user] = balances[user].add(value);\n        totalSupply = totalSupply.add(value);\n        emit Mint(user, value);\n        emit Transfer(address(0), user, value);\n    }\n\n    function changeTeamAccount(address newTeam) external onlyOwner {\n        require(tradeFeeRatio > 0, \"NOT_TRADE_FEE_TOKEN\");\n        emit ChangeTeam(team,newTeam);\n        team = newTeam;\n    }\n}\n"}}}