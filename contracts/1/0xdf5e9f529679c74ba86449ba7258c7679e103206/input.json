{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Contract_Code_v2_Base.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return a / b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title String\r\n * @dev This integrates the basic functions.\r\n */\r\nlibrary String {\r\n    /**\r\n     * @dev determine if strings are equal\r\n     * @param _str1 strings\r\n     * @param _str2 strings\r\n     * @return bool\r\n     */\r\n    function compareStr(string memory _str1, string memory _str2)\r\n        internal\r\n        pure\r\n        returns(bool)\r\n    {\r\n        return keccak256(abi.encodePacked(_str1)) == keccak256(abi.encodePacked(_str2));\r\n    }\r\n}\r\n\r\n/**\r\n * @title Rand\r\n * @dev Rand operations.\r\n */\r\ncontract Rand {\r\n\r\n    mapping(uint8 => uint) internal rNGMapping;\r\n\r\n    /**\r\n     * @dev the content of contract is Beginning\r\n     */\r\n\tconstructor () public\r\n    {\r\n        //init\r\n        rNGMapping[1] = _rand() % block.difficulty;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the get Random\r\n     * @param _length Random _length\r\n     * @return random Random\r\n     */\r\n    function rand(uint _length)\r\n        internal\r\n        returns(uint random)\r\n    {\r\n        random = _rand();\r\n        rNGMapping[1] = random;\r\n        return random % _length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the get Random\r\n     * @return Random\r\n     */\r\n    function _rand()\r\n        private\r\n        returns(uint)\r\n    {\r\n        return uint(keccak256(abi.encodePacked(\r\n            block.difficulty, block.gaslimit, now, tx.gasprice , tx.origin,\r\n            ++rNGMapping[0], rNGMapping[1]\r\n        )));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnerTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnerTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev modifier Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: it is not called by the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     * @return bool\r\n     */\r\n    function isOwner()\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n        emit OwnerTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner()\r\n        external\r\n        view\r\n        returns(address)\r\n    {\r\n        return _owner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an address access to this role\r\n     */\r\n    function add(Role storage _role, address _addr)\r\n        internal\r\n    {\r\n        require(!has(_role, _addr), \"Roles: addr already has role\");\r\n        _role.bearer[_addr] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an address' access to this role\r\n     */\r\n    function remove(Role storage _role, address _addr)\r\n        internal\r\n    {\r\n        require(has(_role, _addr), \"Roles: addr do not have role\");\r\n        _role.bearer[_addr] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an address has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage _role, address _addr)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(_addr != address(0), \"Roles: not the zero address\");\r\n        return _role.bearer[_addr];\r\n    }\r\n}\r\n\r\n/**\r\n * @title Whitelist\r\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\r\n * This simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Whitelist is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    Roles.Role private roles = Roles.Role();\r\n\r\n    event RoleAdded(address indexed operator);\r\n    event RoleRemoved(address indexed operator);\r\n\r\n    /**\r\n     * @dev Throws if operator is not whitelisted.\r\n     */\r\n    modifier onlyIfWhitelisted() {\r\n        require(checkWhitelist(), \"Whitelist: The operator is not whitelisted\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev check current operator is in whitelist\r\n     * @return bool\r\n     */\r\n    function checkWhitelist()\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return isWhitelist(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev add an address to the whitelist\r\n     * @param _operator address\r\n     */\r\n    function addAddressToWhitelist(address _operator)\r\n        external\r\n        onlyOwner\r\n    {\r\n        roles.add(_operator);\r\n        emit RoleAdded(_operator);\r\n    }\r\n\r\n    /**\r\n     * @dev remove an address from the whitelist\r\n     * @param _operator address\r\n     */\r\n    function removeAddressFromWhitelist(address _operator)\r\n        external\r\n        onlyOwner\r\n    {\r\n        roles.remove(_operator);\r\n        emit RoleRemoved(_operator);\r\n    }\r\n\r\n    /**\r\n     * @dev determine if address is in whitelist\r\n     * @param _operator address\r\n     * @return bool\r\n     */\r\n    function isWhitelist(address _operator)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return roles.has(_operator) || isOwner();\r\n    }\r\n}\r\n\r\n/**\r\n * @title DB interface\r\n * @dev This Provide database support services interface\r\n */\r\ninterface IDB {\r\n    /**\r\n     * @dev Create store user information\r\n     * @param addr user addr\r\n     * @param code user invite Code\r\n     * @param rCode recommend code\r\n     */\r\n    function registerUser(address addr, string calldata code, string calldata rCode) external;\r\n    /**\r\n     * @dev Set store user information\r\n     * @param addr user addr\r\n     * @param status user status\r\n     */\r\n    function setUser(address addr, uint8 status) external;\r\n    /**\r\n     * @dev Set store user information [level]\r\n     * @param addr user addr\r\n     * @param level user level\r\n     * @param levelStatus user level status\r\n     */\r\n    function setUserLevel(address addr, uint8 level, uint8 levelStatus) external;\r\n    /**\r\n     * @dev determine if user invite code is use (db)\r\n     * @param code user invite Code\r\n     * @return bool\r\n     */\r\n    function isUsedCode(string calldata code) external view returns (bool);\r\n    /**\r\n     * @dev get the user address of the corresponding user invite code (db)\r\n     * Authorization Required\r\n     * @param code user invite Code\r\n     * @return address\r\n     */\r\n    function getCodeMapping(string calldata code) external view returns (address);\r\n    /**\r\n     * @dev get the user address of the corresponding user id (db)\r\n     * Authorization Required\r\n     * @param uid user id\r\n     * @return address\r\n     */\r\n    function getIndexMapping(uint uid) external view returns (address);\r\n    /**\r\n     * @dev get the user address of the corresponding User info (db)\r\n     * Authorization Required or addr is owner\r\n     * @param addr user address\r\n     * @return info info[id,status,level,levelStatus]\r\n     * @return code code\r\n     * @return rCode rCode\r\n     */\r\n    function getUserInfo(address addr) external view returns (uint[4] memory info, string memory code, string memory rCode);\r\n    /**\r\n     * @dev get the current latest ID (db)\r\n     * Authorization Required\r\n     * @return current uid\r\n     */\r\n    function getCurrentUserID() external view returns (uint);\r\n    /**\r\n     * @dev get the rCodeMapping array length of the corresponding recommend Code (db)\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @return rCodeMapping array length\r\n     */\r\n    function getRCodeMappingLength(string calldata rCode) external view returns (uint);\r\n    /**\r\n     * @dev get the user invite code of the recommend Code [rCodeMapping] based on the index (db)\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @param index the index of [rCodeMapping]\r\n     * @return user invite code\r\n     */\r\n    function getRCodeMapping(string calldata rCode, uint index) external view returns (string memory);\r\n    /**\r\n     * @dev get the user offspring\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     */\r\n    function getRCodeOffspring(string calldata rCode) external view returns (string[] memory);\r\n}\r\n\r\n/**\r\n * @title DBUtilli\r\n * @dev This Provide database support services (db)\r\n */\r\ncontract DBUtilli is Whitelist {\r\n\r\n    //include other contract\r\n    IDB private db;\r\n\r\n    /**\r\n     * @dev DBUtilli is Beginning\r\n     * @param _dbAddr db contract addr\r\n     */\r\n    constructor(address _dbAddr)\r\n        public\r\n    {\r\n        db = IDB(_dbAddr);\r\n    }\r\n\r\n    /**\r\n     * @dev modifier check Permission\r\n     */\r\n\tmodifier _checkPermission() {\r\n\t\trequire(checkWhitelist(), \"DBUtilli: Permission denied\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev modifier check User Permission\r\n     * @param addr user addr\r\n     */\r\n\tmodifier _checkUserPermission(address addr) {\r\n\t\tcheckUserPermission(addr);\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check User Permission\r\n     * @param addr user addr\r\n     */\r\n    function checkUserPermission(address addr)\r\n        private\r\n        view\r\n    {\r\n        require(checkWhitelist() || msg.sender == addr, \"DBUtilli: Permission denied for view user's privacy\");\r\n\t}\r\n\r\n    /**\r\n     * @dev Create store user information (db)\r\n     * @param addr user address\r\n     * @param code user invite Code\r\n     * @param rCode recommend code\r\n     */\r\n    function _registerUser(address addr, string memory code, string memory rCode)\r\n        internal\r\n    {\r\n        db.registerUser(addr, code, rCode);\r\n\t}\r\n\r\n    /**\r\n     * @dev Set store user information\r\n     * @param addr user addr\r\n     * @param status user status\r\n     */\r\n    function _setUser(address addr, uint8 status)\r\n        internal\r\n    {\r\n\t\tdb.setUser(addr, status);\r\n\t}\r\n\r\n    /**\r\n     * @dev Set store user information [level]\r\n     * @param addr user addr\r\n     * @param level user level\r\n     * @param levelStatus user level status\r\n     */\r\n    function _setUserLevel(address addr, uint8 level, uint8 levelStatus)\r\n        internal\r\n    {\r\n        db.setUserLevel(addr, level, levelStatus);\r\n\t}\r\n\r\n    /**\r\n     * @dev determine if user invite code is use (db)\r\n     * @param code user invite Code\r\n     * @return isUser bool\r\n     */\r\n    function _isUsedCode(string memory code)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n\t\treturn db.isUsedCode(code);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user invite code (db)\r\n     * Authorization Required\r\n     * @param code user invite Code\r\n     * @return addr address\r\n     */\r\n    function _getCodeMapping(string memory code)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return db.getCodeMapping(code);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user id (db)\r\n     * Authorization Required\r\n     * @param uid user id\r\n     * @return addr address\r\n     */\r\n    function _getIndexMapping(uint uid)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n\t\treturn db.getIndexMapping(uid);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding User info (db)\r\n     * Authorization Required or addr is owner\r\n     * @param addr user address\r\n     * @return info info[id,status,level,levelStatus]\r\n     * @return code code\r\n     * @return rCode rCode\r\n     */\r\n    function _getUserInfo(address addr)\r\n        internal\r\n        view\r\n        returns (uint[4] memory info, string memory code, string memory rCode)\r\n    {\r\n\t\treturn db.getUserInfo(addr);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the current latest ID (db)\r\n     * Authorization Required\r\n     * @return uid current uid\r\n     */\r\n    function _getCurrentUserID()\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\treturn db.getCurrentUserID();\r\n\t}\r\n\r\n    /**\r\n     * @dev get the rCodeMapping array length of the corresponding recommend Code (db)\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @return length rCodeMapping array length\r\n     */\r\n    function _getRCodeMappingLength(string memory rCode)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\treturn db.getRCodeMappingLength(rCode);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user invite code of the recommend Code [rCodeMapping] based on the index (db)\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @param index the index of [rCodeMapping]\r\n     * @return code user invite code\r\n     */\r\n    function _getRCodeMapping(string memory rCode, uint index)\r\n        internal\r\n        view\r\n        returns (string memory)\r\n    {\r\n\t\treturn db.getRCodeMapping(rCode, index);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user offspring\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     */\r\n    function _getRCodeOffspring(string memory rCode)\r\n        internal\r\n        view\r\n        returns (string[] memory)\r\n    {\r\n\t\treturn db.getRCodeOffspring(rCode);\r\n\t}\r\n\r\n    /**\r\n     * @dev determine if user invite code is use (db)\r\n     * @param code user invite Code\r\n     * @return isUser bool\r\n     */\r\n    function isUsedCode(string calldata code)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n\t\treturn _isUsedCode(code);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user invite code (db)\r\n     * Authorization Required\r\n     * @param code user invite Code\r\n     * @return addr address\r\n     */\r\n    function getCodeMapping(string calldata code)\r\n        external\r\n        view\r\n        _checkPermission()\r\n        returns (address)\r\n    {\r\n\t\treturn _getCodeMapping(code);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user id (db)\r\n     * Authorization Required\r\n     * @param uid user id\r\n     * @return addr address\r\n     */\r\n    function getIndexMapping(uint uid)\r\n        external\r\n        view\r\n        _checkPermission()\r\n        returns (address)\r\n    {\r\n        return _getIndexMapping(uid);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding User info (db)\r\n     * Authorization Required or addr is owner\r\n     * @param addr user address\r\n     * @return info info[id,status,level,levelStatus]\r\n     * @return code code\r\n     * @return rCode rCode\r\n     */\r\n    function getUserInfo(address addr)\r\n        external\r\n        view\r\n        _checkUserPermission(addr)\r\n        returns (uint[4] memory, string memory, string memory)\r\n    {\r\n\t\treturn _getUserInfo(addr);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the rCodeMapping array length of the corresponding recommend Code (db)\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @return rCodeMapping array length\r\n     */\r\n    function getRCodeMappingLength(string calldata rCode)\r\n        external\r\n        view\r\n        _checkPermission()\r\n        returns (uint)\r\n    {\r\n\t\treturn _getRCodeMappingLength(rCode);\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IToken {\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\r\n     * total supply.\r\n     *\r\n     * If a send hook is registered for the caller, the corresponding function\r\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\r\n     *\r\n     * Emits a {Burned} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n}\r\n\r\n/**\r\n * @title Utillibrary\r\n * @dev This integrates the basic functions.\r\n */\r\ncontract Utillibrary is Whitelist, Rand {\r\n    //lib using list\r\n\tusing SafeMath for *;\r\n    using Address for address;\r\n\r\n    //struct\r\n\tstruct User {\r\n\t\tuint id;\r\n        uint addupBuyAmonut;//add up buy Amonut\r\n        uint addupBuyTicket;//add up buy Ticket\r\n        uint32 buyTicketRecordIndex;//buy Ticket Record Index\r\n        mapping(uint32 => BuyTicketData) buyTicketRecord;//buy Ticket Record data\r\n        uint investAmount;//add up invest Amount\r\n        uint investAmountOut;//add up invest Amount Out\r\n        uint32 investDataIndex;//invest Index\r\n        mapping(uint => InvestData) investData;\r\n        uint8 teamLevel;//user team Level\r\n        uint8 teamLevelLockDemotion;//team level Lock Demotion\r\n        uint32 refEffectiveMans;//The number of recommended\r\n        uint refEffectiveInvestAmount;//The Invest Amount of recommended\r\n        //team Achievememt,0 (1-8 generations),1 (9-10 generations),2 (11-12 generations),3 (12-15 generations)\r\n        mapping(uint8 => uint) teamAchievememt;\r\n        //0 static, 1 share, 2 team, 3 elite, 4 signIn\r\n        mapping(uint8 => uint32) rewardIndex;\r\n        mapping(uint8 => mapping(uint32 => AwardData)) rewardData;\r\n        uint takeWallet_ETT;//take ett Wallet\r\n        uint addupTakeWallet_ETT;//add up take ett Wallet\r\n        uint takeWallet_ETH;//take ETH Wallet\r\n        uint addupTakeWallet_ETH;//add up take eth Wallet\r\n        uint32 sgnInDataIndex;\r\n        mapping(uint => SignInData) sgnInData;\r\n        uint bonusStaticAmount;//add up static bonus amonut (static bonus)\r\n\t\tuint bonusDynamicAmonut;//add up dynamic bonus amonut (dynamic bonus)\r\n        uint burnTokenAmount;//add up burn Token\r\n        mapping(uint8 => uint32) cashOutIndex; //0: ETT Cash Out Index,1ï¼šETH Cash Out Index\r\n        mapping(uint8 => mapping(uint32 => CashOutData)) cashOutData;\r\n\t}\r\n\r\n    struct ResonanceData {\r\n        uint40 time;//Resonance time\r\n        uint ratio;//Resonance amount\r\n        uint sellMoney;//sell Money\r\n        uint burnMoney;//burn Money\r\n        uint poundageMoney;//poundage Money\r\n\t}\r\n\r\n    struct BuyTicketData {\r\n        uint40 time;//time\r\n        uint money;//Buy amount\r\n        uint exchangeMoney;//exchange amount\r\n        uint ratio;//Resonance amount\r\n        uint8 buyType;//0:normal,1:Node\r\n\t}\r\n\r\n    struct InvestData {\r\n        uint money;//invest amount\r\n        uint adduoStaticBonus;//add up settlement static bonus amonut\r\n        uint adduoDynamicBonus;//add up settlement dynamic bonus amonut\r\n        uint8 status;//invest status, 0:normal,1:out\r\n        uint8 level;//invest level\r\n        uint40 investTime;//invest time\r\n        uint40 lastRwTime;//last settlement time\r\n        uint40 outTime;//out time\r\n\t}\r\n\r\n\tstruct AwardData {\r\n        uint40 time;//settlement bonus time\r\n        uint amount;//bonus of reward amount\r\n\t}\r\n\r\n    struct SignInData {\r\n        uint40 time;//settlement bonus time\r\n        uint amount;//bonus of reward amount\r\n\t}\r\n\r\n    struct CashOutData {\r\n        uint40 time;//settlement bonus time\r\n        uint amount;//bonus of reward amount\r\n\t}\r\n\r\n    //Loglist\r\n    event BuyTicketEvent(address indexed _addr, uint _value, uint _ratio, uint _value2, uint time);\r\n    event InvestEvent(address indexed _addr, string _code, string _rCode, uint _value, uint time);\r\n    //event TakeBonusEvent(address indexed _addr, uint _value, uint time);\r\n\r\n    //ERC Token addr\r\n    address internal EntranceTicketToken;//entrance ticket\r\n\r\n    //base param setting\r\n\taddress internal devAddr;//The special account\r\n\taddress internal foundationAddr;//Foundation address\r\n\r\n    //addup\r\n    // uint internal AddupSellETT = 0;//paramsMapping[51]\r\n    // uint internal AddupBurnETT = 0;//paramsMapping[52]\r\n    // uint internal AddupPoundageETT = 0;//paramsMapping[53]\r\n    // uint internal AddupInvestETH = 0;//paramsMapping[54]\r\n    // uint internal AddupSignInGetETTAmonut = 0;//paramsMapping[55]\r\n    // uint internal AddupCirculateAmonut = 0;//paramsMapping[56]\r\n    mapping(uint => uint) internal DaySellMapping;//day index sell Mapping\r\n    mapping(uint => uint) internal DayInvestMapping;//day index Invest Mapping\r\n\r\n    mapping(uint => uint) internal DayETTCashOutMapping;//day index ETT Cash Out Mapping\r\n    mapping(uint => uint) internal DayETHCashOutMapping;//day index ETH Cash Out Mapping\r\n\r\n    //resonance\r\n    uint internal rid = 1;//sell Round id\r\n    mapping(uint => ResonanceData) internal resonanceDataMapping;//RoundID ResonanceData Mapping\r\n\r\n    //address User Mapping\r\n\tmapping(address => User) internal userMapping;\r\n\r\n    // uint private SettlementDiffTime = 1 days;\r\n\r\n    //Loglist\r\n    event TransferEvent(address indexed _from, address indexed _to, uint _value, uint time);\r\n    event TransferTokenEvent(address indexed _token, address indexed _from, address indexed _to, uint _value, uint time);\r\n\r\n    //base param setting\r\n    uint internal ETHWei = 1 ether;\r\n    uint internal ETTWei = 10 ** 18;\r\n    uint internal ETH_ETTWei_Ratio = 1 ether;\r\n    // uint internal ETHWei = 10 finney;//Test 0.01ether\r\n\r\n    //paramsMapping\r\n    mapping(uint => uint) internal paramsMapping;\r\n\r\n    mapping(uint => uint) internal TempVariable_Elite;//Temp variable (Elite)\r\n\r\n    /**\r\n     * @dev modifier to scope access to a Contract (uses tx.origin and msg.sender)\r\n     */\r\n\tmodifier isHuman() {\r\n\t\trequire(msg.sender == tx.origin, \"humans only\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check Zero Addr\r\n     */\r\n\tmodifier checkZeroAddr(address addr) {\r\n\t\trequire(addr != address(0), \"zero addr\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check Addr is Contract\r\n     */\r\n\tmodifier checkIsContract(address addr) {\r\n\t\trequire(addr.isContract(), \"not token addr\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev Transfer to designated user\r\n     * @param _addr user address\r\n     * @param _val transfer-out amount\r\n     */\r\n\tfunction sendToUser(address payable _addr, uint _val)\r\n        internal\r\n        checkZeroAddr(_addr)\r\n    {\r\n\t\tif (_val > 0) {\r\n            _addr.transfer(_val);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Transfer to designated user\r\n     * @param _taddr token address\r\n     * @param _addr user address\r\n     * @param _val transfer-out amount\r\n     */\r\n\tfunction sendTokenToUser(address _taddr, address _addr, uint _val)\r\n        internal\r\n        checkZeroAddr(_addr)\r\n        checkIsContract(_taddr)\r\n    {\r\n\t\tif (_val > 0) {\r\n            IToken(_taddr).transfer(_addr, _val);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Gets the amount from the specified user\r\n     * @param _taddr token address\r\n     * @param _addr user address\r\n     * @param _val transfer-get amount\r\n     */\r\n\tfunction getTokenFormUser(address _taddr, address _addr, uint _val)\r\n        internal\r\n        checkZeroAddr(_addr)\r\n        checkIsContract(_taddr)\r\n    {\r\n\t\tif (_val > 0) {\r\n            IToken(_taddr).transferFrom(_addr, address(this), _val);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev burn money\r\n     * @param _taddr token address\r\n     * @param _val burn amount\r\n     */\r\n\tfunction burnToken(address _taddr, uint _val)\r\n        internal\r\n        checkIsContract(_taddr)\r\n    {\r\n\t\tif (_val > 0) {\r\n            IToken(_taddr).burn(_val, \"\");\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Gets the current day index\r\n     * @return day index\r\n     */\r\n\tfunction getDayIndex()\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\treturn now / 1 days;\r\n\t}\r\n\r\n    /**\r\n     * @dev Check and correct transfer amount\r\n     * @param sendMoney transfer-out amount\r\n     * @return bool,amount\r\n     */\r\n\tfunction isEnoughTokneBalance(address _taddr, uint sendMoney)\r\n        internal\r\n        view\r\n        returns (bool, uint tokneBalance)\r\n    {\r\n        tokneBalance = IToken(_taddr).balanceOf(address(this));\r\n\t\tif (sendMoney >= tokneBalance) {\r\n\t\t\treturn (false, tokneBalance);\r\n\t\t} else {\r\n\t\t\treturn (true, sendMoney);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Check and correct transfer amount\r\n     * @param sendMoney transfer-out amount\r\n     * @return bool,amount\r\n     */\r\n\tfunction isEnoughBalance(uint sendMoney)\r\n        internal\r\n        view\r\n        returns (bool, uint)\r\n    {\r\n\t\tif (sendMoney >= address(this).balance) {\r\n\t\t\treturn (false, address(this).balance);\r\n\t\t} else {\r\n\t\t\treturn (true, 0);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Gets the get Random\r\n     * @param min Random min\r\n     * @param max Random max\r\n     * @return range random Random\r\n     */\r\n    function randRange(uint min, uint max)\r\n        internal\r\n        returns(uint)\r\n    {\r\n        //check index\r\n        require(max > min, \"invalid Range\");\r\n        return rand(max - min + 1) + min;\r\n    }\r\n\r\n    /**\r\n     * @dev get scale for the Algebra (*scale/1000)\r\n     * @param algebra algebra\r\n     * @return scale\r\n     */\r\n\tfunction getScaleByAlgebra(uint algebra)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\tif (algebra >= 1 && algebra <= 3) {\r\n\t\t\treturn paramsMapping[6000 + algebra];\r\n\t\t}\r\n        // if (algebra == 2) {\r\n\t\t// \treturn paramsMapping[6002];\r\n\t\t// }\r\n        // if (algebra == 3) {\r\n\t\t// \treturn paramsMapping[6003];\r\n\t\t// }\r\n\t\tif (algebra >= 4 && algebra <= 9) {\r\n\t\t\treturn paramsMapping[6004];\r\n\t\t}\r\n\t\tif (algebra >= 10 && algebra <= 15) {\r\n\t\t\treturn paramsMapping[6005];\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n    /**\r\n     * @dev get scale for the level (*scale/1000)\r\n     * @param level level\r\n     * @return scale\r\n     */\r\n\tfunction getScaleByLevel(uint level)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\tif (level >= 1 && level <= 4) {\r\n\t\t\treturn paramsMapping[5110 + level];\r\n\t\t}\r\n\t\t// if (level == 2) {\r\n\t\t// \treturn paramsMapping[5112];\r\n\t\t// }\r\n\t\t// if (level == 3) {\r\n\t\t// \treturn paramsMapping[5113];\r\n\t\t// }\r\n        // if (level == 4) {\r\n\t\t// \treturn paramsMapping[5114];\r\n\t\t// }\r\n\t\treturn 0;\r\n\t}\r\n\r\n    /**\r\n     * @dev get user level (time limit)\r\n     * @param level_v1 level (v1)\r\n     * @param level_v2 level (v2)\r\n     * @param levelStatus level Status (v1)\r\n     * @param limitTime level (v1) Valid time\r\n     * @param levelLockDemotion level (v2) Lock Demotion\r\n     * @return level\r\n     */\r\n\tfunction getLevelByValidTime(uint8 level_v1, uint8 level_v2, uint8 levelStatus, uint limitTime, uint8 levelLockDemotion)\r\n        internal\r\n        view\r\n        returns (uint8)\r\n    {\r\n        if(levelLockDemotion == 1) {\r\n            return level_v2;\r\n        }\r\n\t\tif(levelStatus == 1 && limitTime >= now && level_v1 > level_v2) {\r\n            return level_v1;\r\n        }\r\n\t\treturn level_v2;\r\n\t}\r\n\r\n    /**\r\n     * @dev countBonus AwardData\r\n     * @param user user storage\r\n     * @param bonusAmount Bonus Amount\r\n     * @param _type countBonus type (0 static, 1 share, 2 team, 3 elite, 4 signIn)\r\n     */\r\n    function countBonus_AwardData(User storage user, uint bonusAmount, uint8 _type)\r\n        internal\r\n    {\r\n        AwardData storage awData = user.rewardData[_type][user.rewardIndex[_type]];\r\n        awData.amount += bonusAmount;\r\n\t}\r\n}"},"browser/Contract_Code_v2_split_Modify.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './Contract_Code_v2_Base.sol';\r\n\r\ncontract Contract_Code_v2_split_Modify is DBUtilli, Utillibrary {\r\n    //lib using list\r\n\tusing SafeMath for *;\r\n    using String for string;\r\n\r\n    /**\r\n     * @dev the content of contract is Beginning\r\n     */\r\n\tconstructor ()\r\n        DBUtilli(msg.sender)//implementation of the proxy set\r\n        public\r\n    {\r\n\r\n\t}\r\n\r\n    /**\r\n     * @dev actSet_FoundationAndDevAddrAddr\r\n     * Authorization Required\r\n     * @param _devAddr _devAddr\r\n     * @param _foundationAddr _foundationAddr\r\n     */\r\n    function actSet_FoundationAndDevAddrAddr\r\n    (\r\n        address _devAddr,\r\n        address _foundationAddr\r\n    )\r\n        external\r\n        onlyIfWhitelisted\r\n    {\r\n        devAddr = _devAddr;\r\n        foundationAddr = _foundationAddr;\r\n    }\r\n}"}}}