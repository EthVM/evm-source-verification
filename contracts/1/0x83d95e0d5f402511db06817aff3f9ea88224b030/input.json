{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Oracle.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.2;\n\ninterface ManagementList {\n    function isManager(address accountAddress) external returns (bool);\n}\n\ncontract Manageable {\n    ManagementList public managementList;\n\n    constructor(address _managementListAddress) {\n        managementList = ManagementList(_managementListAddress);\n    }\n\n    modifier onlyManagers() {\n        bool isManager = managementList.isManager(msg.sender);\n        require(isManager, \"ManagementList: caller is not a manager\");\n        _;\n    }\n}\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n}\n\ncontract Oracle is Manageable {\n    address[] private _calculations;\n    address public usdcAddress;\n    mapping(address => address) public tokenAliases;\n\n    event TokenAliasAdded(address tokenAddress, address tokenAliasAddress);\n    event TokenAliasRemoved(address tokenAddress);\n\n    struct TokenAlias {\n        address tokenAddress;\n        address tokenAliasAddress;\n    }\n\n    constructor(address _managementListAddress, address _usdcAddress)\n        Manageable(_managementListAddress)\n    {\n        usdcAddress = _usdcAddress;\n    }\n\n    /**\n     * The oracle supports an array of calculation contracts. Each calculation contract must implement getPriceUsdc().\n     * When setting calculation contracts all calculations must be set at the same time (we intentionally do not support for adding/removing calculations).\n     * The order of calculation contracts matters as it determines the order preference in the cascading fallback mechanism.\n     */\n    function setCalculations(address[] memory calculationAddresses)\n        external\n        onlyManagers\n    {\n        _calculations = calculationAddresses;\n    }\n\n    function calculations() external view returns (address[] memory) {\n        return (_calculations);\n    }\n\n    function addTokenAlias(address tokenAddress, address tokenAliasAddress)\n        public\n        onlyManagers\n    {\n        tokenAliases[tokenAddress] = tokenAliasAddress;\n        emit TokenAliasAdded(tokenAddress, tokenAliasAddress);\n    }\n\n    function addTokenAliases(TokenAlias[] memory _tokenAliases)\n        public\n        onlyManagers\n    {\n        for (uint256 i = 0; i < _tokenAliases.length; i++) {\n            addTokenAlias(\n                _tokenAliases[i].tokenAddress,\n                _tokenAliases[i].tokenAliasAddress\n            );\n        }\n    }\n\n    function removeTokenAlias(address tokenAddress) public onlyManagers {\n        delete tokenAliases[tokenAddress];\n        emit TokenAliasRemoved(tokenAddress);\n    }\n\n    function getNormalizedValueUsdc(\n        address tokenAddress,\n        uint256 amount,\n        uint256 priceUsdc\n    ) public view returns (uint256) {\n        IERC20 token = IERC20(tokenAddress);\n        uint256 tokenDecimals = token.decimals();\n\n        uint256 usdcDecimals = 6;\n        uint256 decimalsAdjustment;\n        if (tokenDecimals >= usdcDecimals) {\n            decimalsAdjustment = tokenDecimals - usdcDecimals;\n        } else {\n            decimalsAdjustment = usdcDecimals - tokenDecimals;\n        }\n        uint256 value;\n        if (decimalsAdjustment > 0) {\n            value =\n                (amount * priceUsdc * (10**decimalsAdjustment)) /\n                10**(decimalsAdjustment + tokenDecimals);\n        } else {\n            value = (amount * priceUsdc) / 10**usdcDecimals;\n        }\n        return value;\n    }\n\n    function getNormalizedValueUsdc(address tokenAddress, uint256 amount)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 priceUsdc = getPriceUsdcRecommended(tokenAddress);\n        return getNormalizedValueUsdc(tokenAddress, amount, priceUsdc);\n    }\n\n    function getPriceUsdcRecommended(address tokenAddress)\n        public\n        view\n        returns (uint256)\n    {\n        address tokenAddressAlias = tokenAliases[tokenAddress];\n        address tokenToQuery = tokenAddress;\n        if (tokenAddressAlias != address(0)) {\n            tokenToQuery = tokenAddressAlias;\n        }\n        (bool success, bytes memory data) =\n            address(this).staticcall(\n                abi.encodeWithSignature(\"getPriceUsdc(address)\", tokenToQuery)\n            );\n        if (success) {\n            return abi.decode(data, (uint256));\n        }\n        return 0;\n    }\n\n    /**\n     * Cascading fallback proxy\n     *\n     * Loop through all contracts in _calculations and attempt to forward the method call to each underlying contract.\n     * This allows users to call getPriceUsdc() on the oracle contract and the result of the first non-reverting contract that\n     * implements getPriceUsdc() will be returned.\n     *\n     * This mechanism also exposes all public methods for calculation contracts. This allows a user to\n     * call oracle.isIronBankMarket() or oracle.isCurveLpToken() even though these methods live on different contracts.\n     */\n    fallback() external {\n        for (uint256 i = 0; i < _calculations.length; i++) {\n            address calculation = _calculations[i];\n            assembly {\n                let _target := calculation\n                calldatacopy(0, 0, calldatasize())\n                let success := staticcall(\n                    gas(),\n                    _target,\n                    0,\n                    calldatasize(),\n                    0,\n                    0\n                )\n                returndatacopy(0, 0, returndatasize())\n                if success {\n                    return(0, returndatasize())\n                }\n            }\n        }\n        revert(\"Oracle: Fallback proxy failed to return data\");\n    }\n}\n"}}}