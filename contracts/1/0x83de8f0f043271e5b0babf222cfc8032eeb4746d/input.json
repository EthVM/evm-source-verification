{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/fees.sol": {
      "content": "pragma solidity > 0.6.0;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract AdminAccount {\r\n    using SafeMath for uint256;\r\n\r\n    address public constant TOKEN = 0x0F7d6242c082FDb399163Bf24380785775f7021d;\r\n    uint256 public constant MAG = 10 ** 18;\r\n    \r\n    address[] ambassadorList  = [0x2D78B2491b384a79E41555CFEF5393450c96697C,\r\n                                 0xCA1F0623DeC82594a124e20024aFCC7F78B4A56f,\r\n                                 0xE42eE793dD4f083EaBcE3Dc77847f7366A482524,\r\n                                 0x5D3D55F4abd9843416254683933B093F06Cb0e72,\r\n                                 0x1343cB2C821848DF7Ac60bDefAE24A329917d3Cc,\r\n                                 0x92D165900a18430052b8434c61eCb35AD4E8faF8,\r\n                                 0xef9f9C7F5E6E4B1bfEF3AaF67D6bE1dD9b2db83b,\r\n                                 0x3dF3766E64C2C85Ce1baa858d2A14F96916d5087,\r\n                                 0x13216D1A245A3dF60cFcE85A84c5fe84b1706fd7,\r\n                                 0xd865697A2aCbBdf280EDD19d81FA1D9a4885a15e];\r\n    \r\n    mapping(address => uint256) public shares;\r\n    \r\n    modifier isAmbassador() {\r\n        require(shares[msg.sender] > uint256(0));\r\n        _;\r\n    }\r\n    \r\n   constructor() public {\r\n       shares[0x2D78B2491b384a79E41555CFEF5393450c96697C] = 5e15;\r\n       shares[0xCA1F0623DeC82594a124e20024aFCC7F78B4A56f] = 15e15;\r\n       shares[0xE42eE793dD4f083EaBcE3Dc77847f7366A482524] = 15e15;\r\n       shares[0x5D3D55F4abd9843416254683933B093F06Cb0e72] = 4e16;\r\n       shares[0x1343cB2C821848DF7Ac60bDefAE24A329917d3Cc] = 5e16;\r\n       shares[0x92D165900a18430052b8434c61eCb35AD4E8faF8] = 65e15;\r\n       shares[0xef9f9C7F5E6E4B1bfEF3AaF67D6bE1dD9b2db83b] = 65e15;\r\n       shares[0x3dF3766E64C2C85Ce1baa858d2A14F96916d5087] = 65e15;\r\n       shares[0x13216D1A245A3dF60cFcE85A84c5fe84b1706fd7] = 34e16;\r\n       shares[0xd865697A2aCbBdf280EDD19d81FA1D9a4885a15e] = 34e16;\r\n   }\r\n    \r\n   function disburseFees() isAmbassador external {\r\n       uint256 balance_ = IERC20(TOKEN).balanceOf(address(this));\r\n       require(balance_ > uint256(0), \"Nothing to withdraw\");\r\n       for(uint256 i = 0; i < ambassadorList.length; i++) {\r\n           address ambassador_ = ambassadorList[i];\r\n           uint256 share_ = shares[ambassador_];\r\n           uint256 amount_ = (share_.mul(balance_)).div(MAG);\r\n           TransferHelper.safeTransfer(TOKEN, ambassador_, amount_);\r\n       }\r\n   }\r\n    \r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}"
    }
  }
}