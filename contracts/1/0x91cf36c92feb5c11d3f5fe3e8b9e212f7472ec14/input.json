{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MoonCatAccessoryImages.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity 0.8.1;\r\n\r\n\r\ninterface IMoonCatReference {\r\n    function doc (address contractAddress) external view returns (string memory name, string memory description, string memory details);\r\n    function setDoc (address contractAddress, string calldata name, string calldata description) external;\r\n}\r\n\r\n\r\ninterface IMoonCatTraits {\r\n    function kTraitsOf (bytes5 catId) external view returns (bool genesis, bool pale, uint8 facing, uint8 expression, uint8 pattern, uint8 pose);\r\n}\r\n\r\ninterface IMoonCatColors {\r\n    function BasePalette (uint index) external view returns (uint8);\r\n    function colorsOf (bytes5 catId) external view returns (uint8[24] memory);\r\n    function accessoryColorsOf (bytes5 catId) external view returns (uint8[45] memory);\r\n    function colorAlpha (uint8 id) external pure returns (uint8);\r\n}\r\n\r\ninterface IMoonCatSVGs {\r\n    function flip (bytes memory svgData) external pure returns (bytes memory);\r\n    function getPixelData (uint8 facing, uint8 expression, uint8 pose, uint8 pattern, uint8[24] memory colors) external view returns (bytes memory);\r\n    function boundingBox (uint8 facing, uint8 pose) external view returns (uint8 x, uint8 y, uint8 width, uint8 height);\r\n    function glowGroup (bytes memory pixels, uint8 r, uint8 g, uint8 b) external pure returns (bytes memory);\r\n    function svgTag (uint8 x, uint8 y, uint8 w, uint8 h) external pure returns (bytes memory);\r\n    function uint2str (uint value) external pure returns (string memory);\r\n}\r\n\r\ninterface IMoonCatRescue {\r\n    function rescueOrder(uint256 tokenId) external view returns (bytes5);\r\n    function catOwners(bytes5 catId) external view returns (address);\r\n}\r\n\r\ninterface IMoonCatAccessories {\r\n    function accessoryImageData (uint256 accessoryId) external view returns (bytes2[4] memory positions,\r\n                                                                             bytes8[7] memory palettes,\r\n                                                                             uint8 width,\r\n                                                                             uint8 height,\r\n                                                                             uint8 meta,\r\n                                                                             bytes memory IDAT);\r\n\r\n    function doesMoonCatOwnAccessory (uint256 rescueOrder, uint256 accessoryId) external view returns (bool);\r\n    function balanceOf (uint256 rescueOrder) external view returns (uint256);\r\n    struct OwnedAccessory {\r\n        uint232 accessoryId;\r\n        uint8 paletteIndex;\r\n        uint16 zIndex;\r\n    }\r\n    function ownedAccessoryByIndex (uint256 rescueOrder, uint256 ownedAccessoryIndex) external view returns (OwnedAccessory memory);\r\n}\r\n\r\ninterface IMoonCatSVGS {\r\n    function imageOfExtended (bytes5 catId, bytes memory pre, bytes memory post) external view returns (string memory);\r\n}\r\n\r\n\r\ninterface IReverseResolver {\r\n    function claim(address owner) external returns (bytes32);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC721 {\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n}\r\n\r\nlibrary Base64 {\r\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    /// @notice Encodes some bytes to the base64 representation\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        uint256 len = data.length;\r\n        if (len == 0) return \"\";\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((len + 2) / 3);\r\n\r\n        // Add some extra buffer at the end\r\n        bytes memory result = new bytes(encodedLen + 32);\r\n\r\n        bytes memory table = TABLE;\r\n\r\n        assembly {\r\n            let tablePtr := add(table, 1)\r\n                let resultPtr := add(result, 32)\r\n\r\n                for {\r\n                     let i := 0\r\n                } lt(i, len) {\r\n\r\n            } {\r\n            i := add(i, 3)\r\n            let input := and(mload(add(data, i)), 0xffffff)\r\n\r\n            let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\r\n            out := shl(8, out)\r\n            out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\r\n            out := shl(8, out)\r\n            out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\r\n            out := shl(8, out)\r\n            out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\r\n            out := shl(224, out)\r\n\r\n            mstore(resultPtr, out)\r\n\r\n            resultPtr := add(resultPtr, 4)\r\n            }\r\n\r\n            switch mod(len, 3)\r\n                          case 1 {\r\n                                  mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n                }\r\n            case 2 {\r\n                    mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n\r\n            mstore(result, encodedLen)\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n}\r\n\r\n/**\r\n * @title AccessoryPNGs\r\n * @notice On Chain MoonCat Accessory Image Generation\r\n * @dev Builds PNGs of MoonCat Accessories\r\n */\r\ncontract MoonCatAccessoryImages {\r\n\r\n    /* External Contracts */\r\n\r\n    IMoonCatRescue MoonCatRescue = IMoonCatRescue(0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6);\r\n    IMoonCatAccessories MoonCatAccessories = IMoonCatAccessories(0x8d33303023723dE93b213da4EB53bE890e747C63);\r\n\r\n    IMoonCatReference MoonCatReference;\r\n    IMoonCatTraits MoonCatTraits;\r\n    IMoonCatColors MoonCatColors;\r\n    IMoonCatSVGs MoonCatSVGs;\r\n\r\n    address MoonCatAcclimatorAddress = 0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69;\r\n\r\n    /* CRC */\r\n\r\n    uint32[256] CRCTable = [0x0,0x77073096,0xee0e612c,0x990951ba,0x76dc419,0x706af48f,0xe963a535,0x9e6495a3,0xedb8832,0x79dcb8a4,0xe0d5e91e,0x97d2d988,0x9b64c2b,0x7eb17cbd,0xe7b82d07,0x90bf1d91,0x1db71064,0x6ab020f2,0xf3b97148,0x84be41de,0x1adad47d,0x6ddde4eb,0xf4d4b551,0x83d385c7,0x136c9856,0x646ba8c0,0xfd62f97a,0x8a65c9ec,0x14015c4f,0x63066cd9,0xfa0f3d63,0x8d080df5,0x3b6e20c8,0x4c69105e,0xd56041e4,0xa2677172,0x3c03e4d1,0x4b04d447,0xd20d85fd,0xa50ab56b,0x35b5a8fa,0x42b2986c,0xdbbbc9d6,0xacbcf940,0x32d86ce3,0x45df5c75,0xdcd60dcf,0xabd13d59,0x26d930ac,0x51de003a,0xc8d75180,0xbfd06116,0x21b4f4b5,0x56b3c423,0xcfba9599,0xb8bda50f,0x2802b89e,0x5f058808,0xc60cd9b2,0xb10be924,0x2f6f7c87,0x58684c11,0xc1611dab,0xb6662d3d,0x76dc4190,0x1db7106,0x98d220bc,0xefd5102a,0x71b18589,0x6b6b51f,0x9fbfe4a5,0xe8b8d433,0x7807c9a2,0xf00f934,0x9609a88e,0xe10e9818,0x7f6a0dbb,0x86d3d2d,0x91646c97,0xe6635c01,0x6b6b51f4,0x1c6c6162,0x856530d8,0xf262004e,0x6c0695ed,0x1b01a57b,0x8208f4c1,0xf50fc457,0x65b0d9c6,0x12b7e950,0x8bbeb8ea,0xfcb9887c,0x62dd1ddf,0x15da2d49,0x8cd37cf3,0xfbd44c65,0x4db26158,0x3ab551ce,0xa3bc0074,0xd4bb30e2,0x4adfa541,0x3dd895d7,0xa4d1c46d,0xd3d6f4fb,0x4369e96a,0x346ed9fc,0xad678846,0xda60b8d0,0x44042d73,0x33031de5,0xaa0a4c5f,0xdd0d7cc9,0x5005713c,0x270241aa,0xbe0b1010,0xc90c2086,0x5768b525,0x206f85b3,0xb966d409,0xce61e49f,0x5edef90e,0x29d9c998,0xb0d09822,0xc7d7a8b4,0x59b33d17,0x2eb40d81,0xb7bd5c3b,0xc0ba6cad,0xedb88320,0x9abfb3b6,0x3b6e20c,0x74b1d29a,0xead54739,0x9dd277af,0x4db2615,0x73dc1683,0xe3630b12,0x94643b84,0xd6d6a3e,0x7a6a5aa8,0xe40ecf0b,0x9309ff9d,0xa00ae27,0x7d079eb1,0xf00f9344,0x8708a3d2,0x1e01f268,0x6906c2fe,0xf762575d,0x806567cb,0x196c3671,0x6e6b06e7,0xfed41b76,0x89d32be0,0x10da7a5a,0x67dd4acc,0xf9b9df6f,0x8ebeeff9,0x17b7be43,0x60b08ed5,0xd6d6a3e8,0xa1d1937e,0x38d8c2c4,0x4fdff252,0xd1bb67f1,0xa6bc5767,0x3fb506dd,0x48b2364b,0xd80d2bda,0xaf0a1b4c,0x36034af6,0x41047a60,0xdf60efc3,0xa867df55,0x316e8eef,0x4669be79,0xcb61b38c,0xbc66831a,0x256fd2a0,0x5268e236,0xcc0c7795,0xbb0b4703,0x220216b9,0x5505262f,0xc5ba3bbe,0xb2bd0b28,0x2bb45a92,0x5cb36a04,0xc2d7ffa7,0xb5d0cf31,0x2cd99e8b,0x5bdeae1d,0x9b64c2b0,0xec63f226,0x756aa39c,0x26d930a,0x9c0906a9,0xeb0e363f,0x72076785,0x5005713,0x95bf4a82,0xe2b87a14,0x7bb12bae,0xcb61b38,0x92d28e9b,0xe5d5be0d,0x7cdcefb7,0xbdbdf21,0x86d3d2d4,0xf1d4e242,0x68ddb3f8,0x1fda836e,0x81be16cd,0xf6b9265b,0x6fb077e1,0x18b74777,0x88085ae6,0xff0f6a70,0x66063bca,0x11010b5c,0x8f659eff,0xf862ae69,0x616bffd3,0x166ccf45,0xa00ae278,0xd70dd2ee,0x4e048354,0x3903b3c2,0xa7672661,0xd06016f7,0x4969474d,0x3e6e77db,0xaed16a4a,0xd9d65adc,0x40df0b66,0x37d83bf0,0xa9bcae53,0xdebb9ec5,0x47b2cf7f,0x30b5ffe9,0xbdbdf21c,0xcabac28a,0x53b39330,0x24b4a3a6,0xbad03605,0xcdd70693,0x54de5729,0x23d967bf,0xb3667a2e,0xc4614ab8,0x5d681b02,0x2a6f2b94,0xb40bbe37,0xc30c8ea1,0x5a05df1b,0x2d02ef8d];\r\n\r\n    /**\r\n     * @dev Create a cyclic redundancy check (CRC) value for a given set of data.\r\n     *\r\n     * This is the error-detecting code used for the PNG data format to validate each chunk of data within the file. This Solidity implementation\r\n     * is needed to be able to dynamically create PNG files piecemeal.\r\n     */\r\n    function crc32 (bytes memory data) public view returns (uint32) {\r\n        uint32 crc = type(uint32).max;\r\n        for (uint i = 0; i < data.length; i++) {\r\n            uint8 byt;\r\n            assembly {\r\n            byt := mload(add(add(data, 0x1), i))\r\n            }\r\n            crc = (crc >> 8) ^ CRCTable[(crc & 255) ^ byt];\r\n        }\r\n        return ~crc;\r\n    }\r\n\r\n    /* accessoryPNGs */\r\n\r\n    uint64 constant public PNGHeader = 0x89504e470d0a1a0a;\r\n    uint96 constant public PNGFooter = 0x0000000049454e44ae426082;\r\n    uint40 constant internal IHDRDetails = 0x0803000000;\r\n\r\n    /**\r\n     * @dev Assemble a block of data into a valid PNG file chunk.\r\n     */\r\n    function generatePNGChunk (string memory typeCode, bytes memory data) public view returns (bytes memory) {\r\n        uint32 crc = crc32(abi.encodePacked(typeCode, data));\r\n        return abi.encodePacked(uint32(data.length),\r\n                                typeCode,\r\n                                data,\r\n                                crc);\r\n    }\r\n\r\n    /**\r\n     * @dev Take metadata about an individual Accessory and the MoonCat wearing it, and render the Accessory as a PNG image.\r\n     */\r\n    function assemblePNG (uint8[45] memory accessoryColors, bytes8 palette, uint8 width, uint8 height, bytes memory IDAT)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n\r\n        bytes memory colors = new bytes(27);\r\n        bytes memory alphas = new bytes(9);\r\n\r\n        for (uint i = 0; i < 8; i++) {\r\n            uint256 colorIndex = uint256(uint8(palette[i]));\r\n            alphas[i + 1] = bytes1(MoonCatColors.colorAlpha(uint8(colorIndex)));\r\n\r\n            if (colorIndex > 113) {\r\n                colorIndex = (colorIndex - 113) * 3;\r\n                colors[i * 3 + 3] = bytes1(accessoryColors[colorIndex]);\r\n                colors[i * 3 + 4] = bytes1(accessoryColors[colorIndex + 1]);\r\n                colors[i * 3 + 5] = bytes1(accessoryColors[colorIndex + 2]);\r\n            } else {\r\n                colorIndex = colorIndex * 3;\r\n                colors[i * 3 + 3] = bytes1(MoonCatColors.BasePalette(colorIndex));\r\n                colors[i * 3 + 4] = bytes1(MoonCatColors.BasePalette(colorIndex + 1));\r\n                colors[i * 3 + 5] = bytes1(MoonCatColors.BasePalette(colorIndex + 2));\r\n            }\r\n        }\r\n\r\n        return abi.encodePacked(PNGHeader,\r\n                                generatePNGChunk(\"IHDR\", abi.encodePacked(uint32(width), uint32(height), IHDRDetails)),\r\n                                generatePNGChunk(\"PLTE\", colors),//abi.encodePacked(colors)),\r\n                                generatePNGChunk(\"tRNS\", alphas),\r\n                                generatePNGChunk(\"IDAT\", IDAT),\r\n                                PNGFooter);\r\n    }\r\n\r\n    /**\r\n     * @dev For a given MoonCat rescue order and Accessory ID and palette ID, render as PNG.\r\n     * The PNG output is converted to a base64-encoded blob, which is the format used for encoding into an SVG or inline HTML.\r\n     */\r\n    function accessoryPNG (uint256 rescueOrder, uint256 accessoryId, uint16 paletteIndex) public view returns (string memory) {\r\n        require(rescueOrder < 25440, \"Invalid Rescue Order\");\r\n        bytes5 catId = MoonCatRescue.rescueOrder(rescueOrder);\r\n        uint8[45] memory accessoryColors = MoonCatColors.accessoryColorsOf(catId);\r\n        (,bytes8[7] memory palettes, uint8 width, uint8 height,,bytes memory IDAT) = MoonCatAccessories.accessoryImageData(accessoryId);\r\n        return string(abi.encodePacked(\"data:image/png;base64,\",\r\n                                       Base64.encode(assemblePNG(accessoryColors, palettes[paletteIndex], width, height, IDAT))));\r\n    }\r\n\r\n    /* Composite */\r\n\r\n    struct PreppedAccessory {\r\n        uint16 zIndex;\r\n\r\n        uint8 offsetX;\r\n        uint8 offsetY;\r\n        uint8 width;\r\n        uint8 height;\r\n\r\n        bool mirror;\r\n        bool background;\r\n\r\n        bytes8 palette;\r\n        bytes IDAT;\r\n    }\r\n\r\n    /**\r\n     * @dev Given a list of accessories, sort them by z-index.\r\n     */\r\n    function sortAccessories(PreppedAccessory[] memory pas) internal pure {\r\n        for (uint i = 1; i < pas.length; i++) {\r\n            PreppedAccessory memory pa = pas[i];\r\n            uint key = pa.zIndex;\r\n            uint j = i;\r\n            while (j > 0 && pas[j - 1].zIndex > key) {\r\n                pas[j] = pas[j - 1];\r\n                j--;\r\n            }\r\n            pas[j] = pa;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Given a MoonCat and accessory's basic information, derive colors and other metadata for them.\r\n     */\r\n    function prepAccessory (uint8 facing, uint8 pose,  bool allowUnverified, IMoonCatAccessories.OwnedAccessory memory accessory)\r\n        internal\r\n        view\r\n        returns (PreppedAccessory memory)\r\n    {\r\n        (bytes2[4] memory positions,\r\n         bytes8[7] memory palettes,\r\n         uint8 width, uint8 height,\r\n         uint8 meta,\r\n         bytes memory IDAT) = MoonCatAccessories.accessoryImageData(accessory.accessoryId);\r\n\r\n        bytes2 position = positions[pose];\r\n        uint8 offsetX = uint8(position[0]);\r\n        uint8 offsetY = uint8(position[1]);\r\n        bool mirror;\r\n        if (facing == 1) {\r\n            mirror = ((meta >> 1) & 1) == 1;\r\n            if (((meta >> 2) & 1) == 1) { // mirrorPlacement\r\n                if (!mirror) {\r\n                    offsetX = 128 - offsetX - width;\r\n                }\r\n            } else if (mirror) {\r\n                offsetX = 128 - offsetX - width;\r\n            }\r\n        }\r\n\r\n        uint16 zIndex = accessory.zIndex;\r\n        if (!allowUnverified) {\r\n            zIndex = zIndex * (meta >> 7); // check for approval\r\n        }\r\n\r\n        return PreppedAccessory(zIndex,\r\n                                offsetX, offsetY,\r\n                                width, height,\r\n                                mirror,\r\n                                (meta & 1) == 1, // background\r\n                                palettes[accessory.paletteIndex],\r\n                                IDAT);\r\n    }\r\n\r\n    /**\r\n     * @dev Given a MoonCat and a set of basic Accessories' information, derive their metadata and split into foreground/background lists.\r\n     */\r\n    function prepAccessories (uint256 rescueOrder, uint8 facing, uint8 pose, bool allowUnverified, IMoonCatAccessories.OwnedAccessory[] memory accessories) public view returns (PreppedAccessory[] memory, PreppedAccessory[] memory) {\r\n        PreppedAccessory[] memory preppedAccessories = new PreppedAccessory[](accessories.length);\r\n        uint bgCount = 0;\r\n        uint fgCount = 0;\r\n        for (uint i = 0; i < accessories.length; i++) {\r\n            IMoonCatAccessories.OwnedAccessory memory accessory = accessories[i];\r\n            require(MoonCatAccessories.doesMoonCatOwnAccessory(rescueOrder, accessory.accessoryId), \"Accessory Not Owned By MoonCat\");\r\n            if (accessory.zIndex > 0) {\r\n                preppedAccessories[i] = prepAccessory(facing, pose, allowUnverified, accessory);\r\n                if (preppedAccessories[i].background) {\r\n                    bgCount++;\r\n                } else {\r\n                    fgCount++;\r\n                }\r\n            }\r\n        }\r\n        PreppedAccessory[] memory background = new PreppedAccessory[](bgCount);\r\n        PreppedAccessory[] memory foreground = new PreppedAccessory[](fgCount);\r\n\r\n        bgCount = 0;\r\n        fgCount = 0;\r\n\r\n        for (uint i = 0; i < preppedAccessories.length; i++) {\r\n            if (preppedAccessories[i].zIndex > 0) {\r\n                if (preppedAccessories[i].background) {\r\n                    background[bgCount] = preppedAccessories[i];\r\n                    bgCount++;\r\n                } else {\r\n                    foreground[fgCount] = preppedAccessories[i];\r\n                    fgCount++;\r\n                }\r\n            }\r\n        }\r\n        sortAccessories(background);\r\n        sortAccessories(foreground);\r\n        return (background, foreground);\r\n    }\r\n\r\n    /**\r\n     * @dev Convert a MoonCat facing and pose trait information into an SVG viewBox definition to set that canvas size.\r\n     */\r\n    function initialBoundingBox (uint8 facing, uint8 pose) internal view returns (uint8, uint8, uint8, uint8) {\r\n        (uint8 x1, uint8 y1, uint8 width, uint8 height) = MoonCatSVGs.boundingBox(facing, pose);\r\n        return (x1, y1, x1 + width, y1 + height);\r\n    }\r\n\r\n    /**\r\n     * @dev Given a MoonCat's pose information and a list of Accessories, calculate a bounding box that will cover them all.\r\n     */\r\n    function getBoundingBox (uint8 facing, uint8 pose, PreppedAccessory[] memory background, PreppedAccessory[] memory foreground)\r\n        internal\r\n        view\r\n        returns (uint8, uint8, uint8, uint8)\r\n    {\r\n        (uint8 x1, uint8 y1, uint8 x2, uint8 y2) = initialBoundingBox(facing, pose);\r\n\r\n        uint8 offsetX;\r\n\r\n        for (uint i = 0; i < background.length; i++) {\r\n            PreppedAccessory memory pa = background[i];\r\n            if (pa.zIndex > 0) {\r\n                if (pa.mirror) {\r\n                    offsetX = 128 - pa.offsetX - pa.width;\r\n                } else {\r\n                    offsetX = pa.offsetX;\r\n                }\r\n                if (offsetX < x1) x1 = offsetX;\r\n                if (pa.offsetY < y1) y1 = pa.offsetY;\r\n                if ((offsetX + pa.width) > x2) x2 = offsetX + pa.width;\r\n                if ((pa.offsetY + pa.height) > y2) y2 = pa.offsetY + pa.height;\r\n            }\r\n        }\r\n\r\n        for (uint i = 0; i < foreground.length; i++) {\r\n            PreppedAccessory memory pa = foreground[i];\r\n            if (pa.zIndex > 0) {\r\n                if (pa.mirror) {\r\n                    offsetX = 128 - pa.offsetX - pa.width;\r\n                } else {\r\n                    offsetX = pa.offsetX;\r\n                }\r\n                if (offsetX < x1) x1 = offsetX;\r\n                if (pa.offsetY < y1) y1 = pa.offsetY;\r\n                if ((offsetX + pa.width) > x2) x2 = offsetX + pa.width;\r\n                if ((pa.offsetY + pa.height) > y2) y2 = pa.offsetY + pa.height;\r\n            }\r\n        }\r\n\r\n        return (x1, y1, x2 - x1, y2 - y1);\r\n    }\r\n\r\n    /**\r\n     * @dev Given an Accessory's metadata, generate a PNG image of that Accessory and wrap in an SVG image object.\r\n     */\r\n    function accessorySVGSnippet (PreppedAccessory memory pa, uint8[45] memory accessoryColors)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory img = assemblePNG(accessoryColors, pa.palette, pa.width, pa.height, pa.IDAT);\r\n        bytes memory snippet = abi.encodePacked(\"<image x=\\\"\", MoonCatSVGs.uint2str(pa.offsetX),\r\n                                                \"\\\" y=\\\"\", MoonCatSVGs.uint2str(pa.offsetY),\r\n                                                \"\\\" width=\\\"\", MoonCatSVGs.uint2str(pa.width),\r\n                                                \"\\\" height=\\\"\", MoonCatSVGs.uint2str(pa.height),\r\n                                                \"\\\" href=\\\"data:image/png;base64,\", Base64.encode(img),\r\n                                                \"\\\"/>\");\r\n\r\n        if (pa.mirror) {\r\n            return MoonCatSVGs.flip(snippet);\r\n        }\r\n\r\n        return snippet;\r\n    }\r\n\r\n    /**\r\n     * @dev Given a set of metadata about MoonCat and desired Accessories to render on it, generate an SVG of that appearance.\r\n     */\r\n    function assembleSVG (uint8 x,\r\n                          uint8 y,\r\n                          uint8 width,\r\n                          uint8 height,\r\n                          bytes memory mooncatPixelData,\r\n                          uint8[45] memory accessoryColors,\r\n                          PreppedAccessory[] memory background,\r\n                          PreppedAccessory[] memory foreground,\r\n                          uint8 glowLevel)\r\n        internal\r\n        view\r\n        returns (string memory)\r\n    {\r\n\r\n        bytes memory bg;\r\n        bytes memory fg;\r\n\r\n        for (uint i = background.length; i >= 1; i--) {\r\n            bg = abi.encodePacked(bg, accessorySVGSnippet(background[i - 1], accessoryColors));\r\n        }\r\n\r\n        for (uint i = 0; i < foreground.length; i++) {\r\n            fg = abi.encodePacked(fg, accessorySVGSnippet(foreground[i], accessoryColors));\r\n        }\r\n\r\n        if (glowLevel == 0) {\r\n            return string(abi.encodePacked(MoonCatSVGs.svgTag(x, y, width, height),\r\n                                           bg,\r\n                                           mooncatPixelData,\r\n                                           fg,\r\n                                           \"</svg>\"));\r\n        } else if (glowLevel == 1) {\r\n            return string(abi.encodePacked(MoonCatSVGs.svgTag(x, y, width, height),\r\n                                           MoonCatSVGs.glowGroup(mooncatPixelData,\r\n                                                                 accessoryColors[0],\r\n                                                                 accessoryColors[1],\r\n                                                                 accessoryColors[2]),\r\n                                           bg,\r\n                                           mooncatPixelData,\r\n                                           fg,\r\n                                           \"</svg>\"));\r\n        } else {\r\n            return string(abi.encodePacked(MoonCatSVGs.svgTag(x, y, width, height),\r\n                                           MoonCatSVGs.glowGroup(abi.encodePacked(bg,\r\n                                                                                  mooncatPixelData,\r\n                                                                                  fg),\r\n                                                                 accessoryColors[0],\r\n                                                                 accessoryColors[1],\r\n                                                                 accessoryColors[2]),\r\n                                           \"</svg>\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Given a set of metadata about MoonCat and desired Accessories to render on it, generate an SVG of that appearance.\r\n     */\r\n    function assembleSVG (uint8 facing,\r\n                          uint8 pose,\r\n                          bytes memory mooncatPixelData,\r\n                          uint8[45] memory accessoryColors,\r\n                          PreppedAccessory[] memory background,\r\n                          PreppedAccessory[] memory foreground,\r\n                          uint8 glowLevel)\r\n        internal\r\n        view\r\n        returns (string memory)\r\n    {\r\n        (uint8 x, uint8 y, uint8 width, uint8 height) = getBoundingBox(facing, pose, background, foreground);\r\n        return assembleSVG(x, y, width, height, mooncatPixelData, accessoryColors, background, foreground, glowLevel);\r\n    }\r\n\r\n    /**\r\n     * @dev Given a MoonCat Rescue Order and a list of Accessories they own, render an SVG of them wearing those accessories.\r\n     */\r\n    function accessorizedImageOf (uint256 rescueOrder, IMoonCatAccessories.OwnedAccessory[] memory accessories, uint8 glowLevel, bool allowUnverified)\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        uint8 facing;\r\n        uint8 pose;\r\n        bytes memory mooncatPixelData;\r\n        uint8[45] memory accessoryColors;\r\n        {\r\n            require(rescueOrder < 25440, \"Invalid Rescue Order\");\r\n            bytes5 catId = MoonCatRescue.rescueOrder(rescueOrder);\r\n            uint8[24] memory colors = MoonCatColors.colorsOf(catId);\r\n            {\r\n                uint8 expression;\r\n                uint8 pattern;\r\n                (,, facing, expression, pattern, pose) = MoonCatTraits.kTraitsOf(catId);\r\n                mooncatPixelData = MoonCatSVGs.getPixelData(facing, expression, pose, pattern, colors);\r\n            }\r\n            accessoryColors = MoonCatColors.accessoryColorsOf(catId);\r\n        }\r\n\r\n        (PreppedAccessory[] memory background, PreppedAccessory[] memory foreground) = prepAccessories(rescueOrder, facing, pose, allowUnverified, accessories);\r\n        return assembleSVG(facing, pose, mooncatPixelData, accessoryColors, background, foreground, glowLevel);\r\n    }\r\n\r\n    /**\r\n     * @dev Given a MoonCat Rescue Order, look up what Accessories they are currently wearing, and render an SVG of them wearing those accessories.\r\n     */\r\n    function accessorizedImageOf (uint256 rescueOrder, uint8 glowLevel, bool allowUnverified)\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        uint accessoryCount = MoonCatAccessories.balanceOf(rescueOrder);\r\n        IMoonCatAccessories.OwnedAccessory[] memory accessories = new IMoonCatAccessories.OwnedAccessory[](accessoryCount);\r\n        for (uint i = 0; i < accessoryCount; i++) {\r\n            accessories[i] = MoonCatAccessories.ownedAccessoryByIndex(rescueOrder, i);\r\n        }\r\n        return accessorizedImageOf(rescueOrder, accessories, glowLevel, allowUnverified);\r\n    }\r\n\r\n    /**\r\n     * @dev Given a MoonCat Rescue Order, look up what verified Accessories they are currently wearing, and render an SVG of them wearing those accessories.\r\n     */\r\n    function accessorizedImageOf (uint256 rescueOrder, uint8 glowLevel)\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return accessorizedImageOf(rescueOrder, glowLevel, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Given a MoonCat Rescue Order, look up what verified Accessories they are currently wearing, and render an unglowing SVG of them wearing those accessories.\r\n     */\r\n    function accessorizedImageOf (uint256 rescueOrder)\r\n        public\r\n        view\r\n        returns (string memory)\r\n    {\r\n        return accessorizedImageOf(rescueOrder, 0, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Given a MoonCat Rescue Order and an Accessory ID, return the bounding box of the Accessory, relative to the MoonCat.\r\n     */\r\n    function placementOf (uint256 rescueOrder, uint256 accessoryId)\r\n        public\r\n        view\r\n        returns (uint8 offsetX, uint8 offsetY, uint8 width, uint8 height, bool mirror, bool background)\r\n    {\r\n        bytes5 catId = MoonCatRescue.rescueOrder(rescueOrder);\r\n        (,, uint8 facing,,, uint8 pose) = MoonCatTraits.kTraitsOf(catId);\r\n        bytes2[4] memory positions;\r\n        uint8 meta;\r\n        (positions,, width, height, meta,) = MoonCatAccessories.accessoryImageData(accessoryId);\r\n        bytes2 position = positions[pose];\r\n\r\n        background = (meta & 1) == 1;\r\n\r\n        bool mirrorPlacement;\r\n        if (facing == 1) {\r\n            mirror = ((meta >> 1) & 1) == 1;\r\n            mirrorPlacement = ((meta >> 2) & 1) == 1;\r\n        }\r\n\r\n        offsetX = uint8(position[0]);\r\n        offsetY = uint8(position[1]);\r\n\r\n        if (mirrorPlacement) {\r\n            offsetX = 128 - offsetX - width;\r\n        }\r\n    }\r\n\r\n    /* General */\r\n\r\n    /**\r\n     * @dev Get documentation about this contract.\r\n     */\r\n    function doc() public view returns (string memory name, string memory description, string memory details) {\r\n        return MoonCatReference.doc(address(this));\r\n    }\r\n\r\n    constructor (address MoonCatReferenceAddress, address MoonCatTraitsAddress, address MoonCatColorsAddress, address MoonCatSVGsAddress) {\r\n        owner = payable(msg.sender);\r\n        // https://docs.ens.domains/contract-api-reference/reverseregistrar#claim-address\r\n        IReverseResolver(0x084b1c3C81545d370f3634392De611CaaBFf8148).claim(msg.sender);\r\n\r\n        MoonCatReference = IMoonCatReference(MoonCatReferenceAddress);\r\n        MoonCatTraits = IMoonCatTraits(MoonCatTraitsAddress);\r\n        MoonCatColors = IMoonCatColors(MoonCatColorsAddress);\r\n        MoonCatSVGs = IMoonCatSVGs(MoonCatSVGsAddress);\r\n    }\r\n\r\n    address payable public owner;\r\n\r\n    modifier onlyOwner () {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow current `owner` to transfer ownership to another address.\r\n     */\r\n    function transferOwnership (address payable newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the location of the Reference Contract.\r\n     */\r\n    function setReferenceContract (address referenceContract) public onlyOwner {\r\n        MoonCatReference = IMoonCatReference(referenceContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Rescue ERC20 assets sent directly to this contract.\r\n     */\r\n    function withdrawForeignERC20(address tokenContract) public onlyOwner {\r\n        IERC20 token = IERC20(tokenContract);\r\n        token.transfer(owner, token.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @dev Rescue ERC721 assets sent directly to this contract.\r\n     */\r\n    function withdrawForeignERC721(address tokenContract, uint256 tokenId) public onlyOwner {\r\n        IERC721(tokenContract).safeTransferFrom(address(this), owner, tokenId);\r\n    }\r\n}"
    }
  }
}