{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "AvnFTTreasury.sol": {
      "content": "// File: contracts\\interfaces\\IAvnFTTreasury.sol\n\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.5;\r\n\r\ninterface IAvnFTTreasury {\r\n  event LogFTTreasuryPermissionUpdated(address indexed treasurer, bool status);\r\n\r\n  function setTreasurerPermission(address treasurer, bool status) external;\r\n  function getTreasurers() external view returns(address[] memory);\r\n  function unlockERC777Tokens(address token, uint256 amount, bytes calldata data) external;\r\n  function unlockERC20Tokens(address token, uint256 amount) external;\r\n}\n\n// File: contracts\\interfaces\\IERC777.sol\n\n\r\npragma solidity 0.7.5;\r\n\r\n// As defined in https://eips.ethereum.org/EIPS/eip-777\r\ninterface IERC777 {\r\n  event Sent(address indexed operator, address indexed from, address indexed to, uint256 amount, bytes data,\r\n      bytes operatorData);\r\n  event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n  event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n  event AuthorizedOperator(address indexed operator,address indexed holder);\r\n  event RevokedOperator(address indexed operator, address indexed holder);\r\n\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address holder) external view returns (uint256);\r\n  function granularity() external view returns (uint256);\r\n  function defaultOperators() external view returns (address[] memory);\r\n  function isOperatorFor(address operator, address holder) external view returns (bool);\r\n  function authorizeOperator(address operator) external;\r\n  function revokeOperator(address operator) external;\r\n  function send(address to, uint256 amount, bytes calldata data) external;\r\n  function operatorSend(address from, address to, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\r\n  function burn(uint256 amount, bytes calldata data) external;\r\n  function operatorBurn( address from, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\r\n}\n\n// File: contracts\\interfaces\\IERC20.sol\n\n\r\npragma solidity 0.7.5;\r\n\r\n// As described in https://eips.ethereum.org/EIPS/eip-20\r\ninterface IERC20 {\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function name() external view returns (string memory); // optional method - see eip spec\r\n  function symbol() external view returns (string memory); // optional method - see eip spec\r\n  function decimals() external view returns (uint8); // optional method - see eip spec\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address owner) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n}\n\n// File: contracts\\thirdParty\\interfaces\\IERC1820Registry.sol\n\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/introspection/IERC1820Registry.sol\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the global ERC1820 Registry, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\r\n * implementers for interfaces in this registry, as well as query support.\r\n *\r\n * Implementers may be shared by multiple accounts, and can also implement more\r\n * than a single interface for each account. Contracts can implement interfaces\r\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\r\n * contract.\r\n *\r\n * {IERC165} interfaces can also be queried via the registry.\r\n *\r\n * For an in-depth explanation and source code analysis, see the EIP text.\r\n */\r\ninterface IERC1820Registry {\r\n    /**\r\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\r\n     * account is able to set interface implementers for it.\r\n     *\r\n     * By default, each account is its own manager. Passing a value of `0x0` in\r\n     * `newManager` will reset the manager to this initial state.\r\n     *\r\n     * Emits a {ManagerChanged} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     * @dev Returns the manager for `account`.\r\n     *\r\n     * See {setManager}.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\r\n     * `interfaceHash`.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     * The zero address can also be used in `implementer` to remove an old one.\r\n     *\r\n     * See {interfaceHash} to learn how these are created.\r\n     *\r\n     * Emits an {InterfaceImplementerSet} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\r\n     * end in 28 zeroes).\r\n     * - `implementer` must implement {IERC1820Implementer} and return true when\r\n     * queried for support, unless `implementer` is the caller. See\r\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\r\n     */\r\n    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\r\n\r\n    /**\r\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\r\n     * implementer is registered, returns the zero address.\r\n     *\r\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\r\n     * zeroes), `account` will be queried for support of it.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     */\r\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\r\n     * corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\r\n     */\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    /**\r\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     *  @param account Address of the contract for which to update the cache.\r\n     *  @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\r\n     *  If the result is not cached a direct lookup on the contract address is performed.\r\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     *  {updateERC165Cache} with the contract address.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n     *  @param account Address of the contract to check.\r\n     *  @param interfaceId ERC165 interface to check.\r\n     *  @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n}\n\n// File: contracts\\Owned.sol\n\n\r\npragma solidity 0.7.5;\r\n\r\ncontract Owned {\r\n\r\n  address public owner = msg.sender;\r\n\r\n  event LogOwnershipTransferred(address indexed owner, address indexed newOwner);\r\n\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner, \"Only owner\");\r\n    _;\r\n  }\r\n\r\n  function setOwner(address _owner)\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(_owner != address(0), \"Owner cannot be zero address\");\r\n    emit LogOwnershipTransferred(owner, _owner);\r\n    owner = _owner;\r\n  }\r\n}\n\n// File: ..\\contracts\\AvnFTTreasury.sol\n\n\r\npragma solidity 0.7.5;\r\r\r\r\r\r\n\r\ncontract AvnFTTreasury is IAvnFTTreasury, Owned {\r\n\r\n  // Universal address as defined in Registry Contract Address section of https://eips.ethereum.org/EIPS/eip-1820\r\n  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n  // keccak256(\"ERC777TokensRecipient\")\r\n  bytes32 constant internal ERC777_TOKENS_RECIPIENT_HASH = 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\r\n\r\n  mapping (address => bool) public isPermitted;\r\n  address[] public treasurers;\r\n\r\n  modifier onlyPermitted() {\r\n    require(isPermitted[msg.sender], \"FT Treasury access not permitted\");\r\n    _;\r\n  }\r\n\r\n  constructor()\r\n  {\r\n    ERC1820_REGISTRY.setInterfaceImplementer(address(this), ERC777_TOKENS_RECIPIENT_HASH, address(this));\r\n  }\r\n\r\n  function setTreasurerPermission(address _treasurer, bool _status)\r\n    onlyOwner\r\n    external\r\n    override\r\n  {\r\n    if (_status == isPermitted[_treasurer])\r\n      return;\r\n    else if (_status) {\r\n      isPermitted[_treasurer] = true;\r\n      treasurers.push(_treasurer);\r\n    } else {\r\n      isPermitted[_treasurer] = false;\r\n      uint256 endTreasurer = treasurers.length - 1;\r\n      for (uint256 i; i < endTreasurer; i++) {\r\n        if (treasurers[i] == _treasurer) {\r\n          treasurers[i] = treasurers[endTreasurer];\r\n          break;\r\n        }\r\n      }\r\n      treasurers.pop();\r\n    }\r\n    emit LogFTTreasuryPermissionUpdated(_treasurer, _status);\r\n  }\r\n\r\n  function getTreasurers()\r\n    external\r\n    view\r\n    override\r\n    returns (address[] memory)\r\n  {\r\n    return treasurers;\r\n  }\r\n\r\n  function tokensReceived(address _operator, address /*_from*/, address _to, uint256 /*_amount*/, bytes calldata /*_data*/,\r\n      bytes calldata /* _operatorData */)\r\n    external\r\n    view\r\n  {\r\n    require(isPermitted[_operator], \"Requires permission\");\r\n    assert(_to == address(this)); // will not reach this if permissions are handled correctly\r\n  }\r\n\r\n  function unlockERC777Tokens(address _token, uint256 _amount, bytes calldata _data)\r\n    onlyPermitted\r\n    external\r\n    override\r\n  {\r\n    IERC777(_token).send(msg.sender, _amount, _data);\r\n  }\r\n\r\n  function unlockERC20Tokens(address _token, uint256 _amount)\r\n    onlyPermitted\r\n    external\r\n    override\r\n  {\r\n    assert(IERC20(_token).transfer(msg.sender, _amount));\r\n  }\r\n}\n"
    }
  }
}