{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DECO.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract DECO {\r\n    using SafeMath for uint256;\r\n\r\n    /* address list begin\r\n     */\r\n\r\n    //Address for foundation\r\n    address public FoundationAddress =\r\n        0x9C6df1a389E2d45454eB6Cbd10a073aC0da488De;\r\n    //Address for airdrop\r\n    address public AirdropAddress = 0x918e4C3fC02e7bBbD8EF7689d8a7AA33C1787619;\r\n    //Address for community\r\n    address public CommunityAddress =\r\n        0x78B79929a290810eE07785F38A2956029E01600f;\r\n    //Address for mining\r\n    address public miningAddress = 0x37DcD4dCEe925AB3C13B5c5c6DBCd4680511DfDC;\r\n\r\n    //Address for North America community\r\n    address public USAddress = 0x06e67d3d32de2C8E440d59f609511d87688b6288;\r\n    //Address for ZhiZun community\r\n    address public ZhiZunAddress = 0x1237A7781BbCA0E74d8494E4d92CfF19acfb1277;\r\n    //Address for ZhongYing community\r\n    address public ZhongYingAddress =\r\n        0x35CdE5cb06DaAb9ca1f680A58667E6d03Cbe391b;\r\n    //Address for YongHeng community\r\n    address public YongHengAddress = 0x21d2CbAEF8EF3F08d7b7ED155fBB11dC3B1eE40C;\r\n    //Address for HongChang community\r\n    address public HongchangAddress =\r\n        0x446FDee43Caa3D72D644a23E9c4E3E87819883E3;\r\n    //ddress for HuiJu community\r\n    address public HuiJuAddress = 0x2D838F4D01B67587f634c9e56CC6Fb61F5df59c5;\r\n    //Address for ChongSheng community\r\n    address public ChongShengAddress =\r\n        0x69a40cE150087c21c2A586f480A22a5fBb7ADEeA;\r\n    //Address for ZhiQin community\r\n    address public ZhiQinAddress = 0xeDe3A506a00AE51B7B13e0842a0252aD6D574074;\r\n    //Address for WuKong community\r\n    address public WuKongAddress = 0xf40282A9fcF12fF47150ff998E51fE35B672cbF7;\r\n\r\n    //Address for administrator\r\n    address public owner = 0x3F863c8b3D522bB16485B230bd58B95417941828;\r\n    /* address list end\r\n     */\r\n\r\n    //baseline for decimal point 18\r\n    uint256 public decimalpoint = 1000000000000000000;\r\n    //token name\r\n    string public name;\r\n    //token symbol\r\n    string public symbol;\r\n    //token decimals\r\n    uint8 public decimals;\r\n    //token total supply\r\n    uint256 public totalSupply;\r\n    //token balanceOf\r\n    mapping(address => uint256) public balanceOf;\r\n    //token allowance\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    //Event for transfer\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    //contract deploy time\r\n    uint256 public deploytime;\r\n\r\n    constructor() public {\r\n        deploytime = now;\r\n        //total token is 12200\r\n        totalSupply = 12200 * decimalpoint;\r\n        name = \"Decentralized Consensus\";\r\n        symbol = \"DECO\";\r\n        decimals = 18;\r\n        //first airdrop token for everyone\r\n        //token for foundataion is 500\r\n        balanceOf[FoundationAddress] = 500 * decimalpoint;\r\n        //token for airdrop is 200\r\n        balanceOf[AirdropAddress] = 200 * decimalpoint;\r\n        //token for community is 500\r\n        balanceOf[CommunityAddress] = 500 * decimalpoint;\r\n        //token for  mining is 1500\r\n        balanceOf[miningAddress] = 1500 * decimalpoint;\r\n\r\n        //the top 9 community first token is 1425/9\r\n        balanceOf[USAddress] = (1425 * decimalpoint) / 9;\r\n        balanceOf[ZhiZunAddress] = (1425 * decimalpoint) / 9;\r\n        balanceOf[ZhongYingAddress] = (1425 * decimalpoint) / 9;\r\n        balanceOf[YongHengAddress] = (1425 * decimalpoint) / 9;\r\n        balanceOf[HongchangAddress] = (1425 * decimalpoint) / 9;\r\n        balanceOf[HuiJuAddress] = (1425 * decimalpoint) / 9;\r\n        balanceOf[ChongShengAddress] = (1425 * decimalpoint) / 9;\r\n        balanceOf[ZhiQinAddress] = (1425 * decimalpoint) / 9;\r\n        balanceOf[WuKongAddress] = (1425 * decimalpoint) / 9;\r\n\r\n        //the top 9 community every month release token\r\n        timelist[0] = 1609430401;\r\n        timelist[1] = 1612108801;\r\n        timelist[2] = 1614528001;\r\n        timelist[3] = 1617206401;\r\n        timelist[4] = 1619798401;\r\n        timelist[5] = 1622476801;\r\n        timelist[6] = 1625068801;\r\n        timelist[7] = 1627747201;\r\n        timelist[8] = 1630425601;\r\n    }\r\n\r\n    //get erc20 current time\r\n    function nowtime() public view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    //get the top 9 community release times\r\n    uint8 public nonces;\r\n\r\n    //get the top 9 community release time\r\n    uint256 public Communityreleasetime;\r\n\r\n    //the top 9 community every month release token\r\n    mapping(uint256 => uint256) public timelist;\r\n\r\n    //the top 9 community release function\r\n    function Communityrelease() public onlyOwner {\r\n        assert(nonces <= 8);\r\n        if (nonces < 8) {\r\n            if (now >= timelist[nonces]) {\r\n                balanceOf[USAddress].add((950 * decimalpoint) / 9);\r\n                balanceOf[ZhiZunAddress].add((950 * decimalpoint) / 9);\r\n                balanceOf[ZhongYingAddress].add((950 * decimalpoint) / 9);\r\n                balanceOf[YongHengAddress].add((950 * decimalpoint) / 9);\r\n                balanceOf[HongchangAddress].add((950 * decimalpoint) / 9);\r\n                balanceOf[HuiJuAddress].add((950 * decimalpoint) / 9);\r\n                balanceOf[ChongShengAddress].add((950 * decimalpoint) / 9);\r\n                balanceOf[ZhiQinAddress].add((950 * decimalpoint) / 9);\r\n                balanceOf[WuKongAddress].add((950 * decimalpoint) / 9);\r\n                nonces++;\r\n            }\r\n        } else if (nonces == 8 && now >= timelist[8]) {\r\n            balanceOf[USAddress].add((475 * decimalpoint) / 9);\r\n            balanceOf[ZhiZunAddress].add((475 * decimalpoint) / 9);\r\n            balanceOf[ZhongYingAddress].add((475 * decimalpoint) / 9);\r\n            balanceOf[YongHengAddress].add((475 * decimalpoint) / 9);\r\n            balanceOf[HongchangAddress].add((475 * decimalpoint) / 9);\r\n            balanceOf[HuiJuAddress].add((475 * decimalpoint) / 9);\r\n            balanceOf[ChongShengAddress].add((475 * decimalpoint) / 9);\r\n            balanceOf[ZhiQinAddress].add((475 * decimalpoint) / 9);\r\n            balanceOf[WuKongAddress].add((475 * decimalpoint) / 9);\r\n            nonces++;\r\n        }\r\n    }\r\n\r\n    //the top 9 community release function by address\r\n    function CommunityReleaseByAddress(string communityIDs) public onlyOwner {\r\n        assert(nonces <= 8);\r\n        if (nonces < 8) {\r\n            if (now >= timelist[nonces]) {\r\n                if (bytes(communityIDs)[0] == \"1\") {\r\n                    balanceOf[USAddress].add((950 * decimalpoint) / 9);\r\n                }\r\n                if (bytes(communityIDs)[1] == \"1\") {\r\n                    balanceOf[ZhiZunAddress].add((950 * decimalpoint) / 9);\r\n                }\r\n                if (bytes(communityIDs)[2] == \"1\") {\r\n                    balanceOf[ZhongYingAddress].add((950 * decimalpoint) / 9);\r\n                }\r\n                if (bytes(communityIDs)[3] == \"1\") {\r\n                    balanceOf[YongHengAddress].add((950 * decimalpoint) / 9);\r\n                }\r\n                if (bytes(communityIDs)[4] == \"1\") {\r\n                    balanceOf[HongchangAddress].add((950 * decimalpoint) / 9);\r\n                }\r\n                if (bytes(communityIDs)[5] == \"1\") {\r\n                    balanceOf[HuiJuAddress].add((950 * decimalpoint) / 9);\r\n                }\r\n                if (bytes(communityIDs)[6] == \"1\") {\r\n                    balanceOf[ChongShengAddress].add((950 * decimalpoint) / 9);\r\n                }\r\n                if (bytes(communityIDs)[7] == \"1\") {\r\n                    balanceOf[ZhiQinAddress].add((950 * decimalpoint) / 9);\r\n                }\r\n                if (bytes(communityIDs)[8] == \"1\") {\r\n                    balanceOf[WuKongAddress].add((950 * decimalpoint) / 9);\r\n                }\r\n                nonces++;\r\n            }\r\n        } else if (nonces == 8 && now >= timelist[8]) {\r\n            if (bytes(communityIDs)[0] == \"1\") {\r\n                balanceOf[USAddress].add((475 * decimalpoint) / 9);\r\n            }\r\n            if (bytes(communityIDs)[1] == \"1\") {\r\n                balanceOf[ZhiZunAddress].add((475 * decimalpoint) / 9);\r\n            }\r\n            if (bytes(communityIDs)[2] == \"1\") {\r\n                balanceOf[ZhongYingAddress].add((475 * decimalpoint) / 9);\r\n            }\r\n            if (bytes(communityIDs)[3] == \"1\") {\r\n                balanceOf[YongHengAddress].add((475 * decimalpoint) / 9);\r\n            }\r\n            if (bytes(communityIDs)[4] == \"1\") {\r\n                balanceOf[HongchangAddress].add((475 * decimalpoint) / 9);\r\n            }\r\n            if (bytes(communityIDs)[5] == \"1\") {\r\n                balanceOf[HuiJuAddress].add((475 * decimalpoint) / 9);\r\n            }\r\n            if (bytes(communityIDs)[6] == \"1\") {\r\n                balanceOf[ChongShengAddress].add((475 * decimalpoint) / 9);\r\n            }\r\n            if (bytes(communityIDs)[7] == \"1\") {\r\n                balanceOf[ZhiQinAddress].add((475 * decimalpoint) / 9);\r\n            }\r\n            if (bytes(communityIDs)[8] == \"1\") {\r\n                balanceOf[WuKongAddress].add((475 * decimalpoint) / 9);\r\n            }\r\n            nonces++;\r\n        }\r\n    }\r\n\r\n    //the foundation release function\r\n    /*\r\n    uint8 Foundationreleasecount=0;\r\n    function Foundationrelease()public onlyOwner{\r\n        assert(now>=deploytime+365 days);\r\n        assert(Foundationreleasecount==0);\r\n        balanceOf[FoundationAddress]=500*decimalpoint;\r\n        Foundationreleasecount=1;\r\n    }\r\n    */\r\n    \r\n    function firstairdrop(address[] _tos, uint256 _value) public returns (uint256) {\r\n        uint256 i = 0;\r\n        while (i < _tos.length) {\r\n          transfer(_tos[i], _value);\r\n          i += 1;\r\n        }\r\n        return(i);\r\n    }\r\n    \r\n    function batchtransfer(address[] _tos, uint256[] _values) public returns (uint256) {\r\n        uint256 i = 0;\r\n        while (i < _tos.length) {\r\n          transfer(_tos[i], _values[i]);\r\n          i += 1;\r\n        }\r\n        return(i);\r\n    }\r\n    \r\n\r\n    //send token\r\n    function transfer(address _to, uint256 _value) public {\r\n        require(_to != 0x0);\r\n        assert(_value > 0);\r\n        assert(balanceOf[msg.sender] >= _value);\r\n        assert(balanceOf[_to] + _value > balanceOf[_to]);\r\n        balanceOf[msg.sender] = SafeMath.sub(balanceOf[msg.sender], _value);\r\n        balanceOf[_to] = SafeMath.add(balanceOf[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        assert(_value > 0);\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    //require system administrator execute right\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // A contract attempts to get the token\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public returns (bool success) {\r\n        require(_to != 0x0);\r\n        assert(_value > 0);\r\n        assert(balanceOf[_from] >= _value);\r\n        assert(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        assert(_value <= allowance[_from][msg.sender]);\r\n        balanceOf[_from] = SafeMath.sub(balanceOf[_from], _value);\r\n        balanceOf[_to] = SafeMath.add(balanceOf[_to], _value);\r\n        allowance[_from][msg.sender] = SafeMath.sub(\r\n            allowance[_from][msg.sender],\r\n            _value\r\n        );\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // transfer balance to owner\r\n    function ETHbalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // transfer balance to owner\r\n    function withdrawEther(uint256 amount) public onlyOwner {\r\n        owner.transfer(amount);\r\n    }\r\n\r\n    // can accept ether\r\n    function() public payable {}\r\n}"}}}