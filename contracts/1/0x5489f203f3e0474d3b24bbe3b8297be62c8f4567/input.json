{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Shrimps.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.8.4;\n\nimport \"./Weighting.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\n\n\ncontract Shrimps {\n\n    address payable internal _shrimpBeneficiary;\n    address internal _shrimpWeightingContract;\n    uint internal _totalBid;\n    uint internal _maximumShrimpBid;\n    uint internal _minimumShrimpBid;\n    uint internal _shrimpLastBidTime;\n    uint internal _shrimpIncrement;\n    uint internal _shrimpReturnFee;\n    uint internal _firstDistributionCount;\n    uint internal _lastDistributionCount;\n    address[] internal shrimpAddresses;   \n    bool internal _returnedAllFunds;\n    bool private constant NOT_ENTERED = false;\n    bool private constant ENTERED = true;\n    Weighting scon;\n    \n    mapping(address => uint) internal _shrimpArray;\n    mapping(address => bool) internal _shrimpBid;\n    mapping(address => bool) internal _userShrimpReentrancy;\n    \n    receive() external payable {}\n    fallback() external payable {}\n    \n    modifier shrimpMultipleETH(){\n      require(msg.value % _shrimpIncrement * 10**18 == 0, \"Only 0,1 ETH multiples are accepted\"); //0.1 ether\n       _;\n    }\n   \n    modifier beforeShrimpAuction(uint _time) {\n        require(block.timestamp < _time, \"Shrimp auction has ended\");\n        _;\n    }\n    \n    modifier afterShrimpAuction(uint _time) {\n        require(block.timestamp >= _time, \"Shrimp auction did not end yet\");\n        _;\n    }\n    \n    modifier notShrimpOwner() {\n        require(msg.sender != _shrimpBeneficiary, \"Contract owner can not interract here\");\n        _;\n    }\n    \n    modifier onlyShrimpOwner(address messageSender) {\n        require(_shrimpBeneficiary == messageSender, \"Only the owner can use this function\");\n        _;\n    }\n    \n    modifier isShrimpWeighting() {\n        require(address(_shrimpWeightingContract) == msg.sender, \"Wrong contract passed. Contract is not Weighting\");\n        _;\n    }\n    \n    modifier highestBidMaximum() {\n        require(msg.value <= _maximumShrimpBid, \"Bid must be less than the set maximum bid\");\n        require((_shrimpArray[msg.sender] + msg.value) <= _maximumShrimpBid, \"Bid must be less than the set maximum bid\");\n        _;\n    }\n    \n    modifier lowestShrimpBidMinimum() {\n        require(msg.value >= _minimumShrimpBid/(1 ether), \"Minimum bid amount required\");\n        _;\n    }\n    \n    modifier returnedAllFunds() {\n        require(false == _returnedAllFunds, \"Funds have been returned to all users\");\n        _;\n    }\n    \n    modifier nonShrimpReentrant() {\n        require(_userShrimpReentrancy[msg.sender] != ENTERED, \"ReentrancyGuard: reentrant call\");\n        _userShrimpReentrancy[msg.sender] = ENTERED;\n        _;\n        _userShrimpReentrancy[msg.sender] = NOT_ENTERED;\n    }\n\n    constructor(\n        address payable shrimpBeneficiary,\n        uint maximumShrimpBid,\n        uint minimumShrimpBid,\n        address shrimpWeightingContract\n    )\n    {\n        _shrimpBeneficiary = shrimpBeneficiary;\n        _maximumShrimpBid = maximumShrimpBid;\n        _minimumShrimpBid = minimumShrimpBid;\n        _shrimpWeightingContract = shrimpWeightingContract;\n        scon = Weighting(payable(_shrimpWeightingContract));\n        _shrimpIncrement = 0.1 ether;\n        _shrimpReturnFee = 0.001 ether;\n        _firstDistributionCount = 0;\n        _lastDistributionCount = 100;\n        _returnedAllFunds = false;\n    }\n    \n    function shrimpsBid()\n        public\n        payable\n        beforeShrimpAuction(scon.getAuctionEndTime())\n        notShrimpOwner()\n        highestBidMaximum()\n        lowestShrimpBidMinimum()\n        shrimpMultipleETH()\n        nonShrimpReentrant()\n    {\n        _shrimpsBid();\n    }\n   \n    function _shrimpsBid()\n        internal\n    {\n        uint amount = msg.value;\n        \n        if(amount > 0){\n            _shrimpArray[msg.sender] = _shrimpArray[msg.sender] + amount;\n            if(_shrimpBid[msg.sender] == false){\n                _shrimpBid[msg.sender] = true;\n                shrimpAddresses.push(msg.sender);\n            }\n            _totalBid = _totalBid + amount;\n            _shrimpLastBidTime = block.timestamp;\n            \n            uint timeLeft = scon.getAuctionEndTime() - block.timestamp;\n            if(timeLeft <= 15 minutes){\n                scon.setAuctionEndTime();\n            }\n        }\n    }\n\n    function _returnShrimpFunds()\n        external\n        payable\n        isShrimpWeighting()\n        returnedAllFunds()\n        afterShrimpAuction(scon.getAuctionEndTime())\n    {\n        if (_lastDistributionCount > shrimpAddresses.length) {\n            _lastDistributionCount = shrimpAddresses.length;\n        }\n        for (uint j = _firstDistributionCount; j < _lastDistributionCount; j++) {\n            if(_shrimpArray[shrimpAddresses[j]] > 0){\n                uint amount = _shrimpArray[shrimpAddresses[j]] - _shrimpReturnFee;\n                if(payable(shrimpAddresses[j]).send(amount)){\n                    _shrimpArray[shrimpAddresses[j]] = 0;\n                }\n            }\n        }\n        _firstDistributionCount = _lastDistributionCount;\n        _lastDistributionCount += 100;\n        if (_firstDistributionCount >= shrimpAddresses.length) {\n            _returnedAllFunds = true;\n        }\n    }\n    \n    function transferShrimpOwnership(address payable newShrimpBeneficiary)\n        public\n        onlyShrimpOwner(msg.sender)\n        beforeShrimpAuction(scon.getAuctionEndTime())\n    {\n        _transferShrimpOwnership(newShrimpBeneficiary);\n    }\n   \n    function _transferShrimpOwnership(address payable newShrimpBeneficiary)\n        internal\n    {\n        require(newShrimpBeneficiary != address(0));\n        _shrimpBeneficiary = newShrimpBeneficiary;  \n    }\n    \n    function transferShrimpOwnershipToZero()\n        public\n        onlyShrimpOwner(msg.sender)\n        beforeShrimpAuction(scon.getAuctionEndTime())\n    {\n        _transferShrimpOwnershipToZero();\n    }\n   \n    function _transferShrimpOwnershipToZero()\n        internal\n    {\n        _shrimpBeneficiary = payable(address(0));  \n    }\n    \n    function shrimpsTransfer(address recipient, uint256 amount)\n        public \n        onlyShrimpOwner(msg.sender)\n        afterShrimpAuction(scon.getAuctionEndTime())\n        returns (bool) \n    {   \n        _shrimpsTransfer(msg.sender, recipient, amount);\n        return true;\n    }\n    \n    function _shrimpsTransfer(address sender, address recipient, uint256 amount) \n        internal\n        virtual \n    {\n        require(sender != address(0), \"Transfer from the zero address\");\n        require(recipient != address(0), \"Transfer to the zero address\");\n        uint256 senderBalance = address(this).balance;\n        require(senderBalance >= amount, \"Transfer amount exceeds balance\");\n\n        if(_shrimpBid[recipient] == true){\n            _shrimpArray[recipient] = _shrimpArray[recipient] - amount;\n            _totalBid = _totalBid - amount;\n            if(_shrimpArray[recipient] == 0){\n                delete _shrimpArray[recipient];\n            }\n        }\n        payable(recipient).transfer(amount);\n    }\n    \n    function shrimpsWithdrawERC20ContractTokens(IERC20 tokenAddress, address recipient)\n        public\n        onlyShrimpOwner(msg.sender)\n        returns(bool)\n    {\n        require(msg.sender != address(0), \"Sender is address zero\");\n        require(recipient != address(0), \"Receiver is address zero\");\n        tokenAddress.approve(address(this), tokenAddress.balanceOf(address(this)));\n        if(!tokenAddress.transferFrom(address(this), recipient, tokenAddress.balanceOf(address(this)))){\n            return false;\n        }\n        return true;\n    }\n    \n    function resetShrimpReentrancy(address user) \n        public\n        onlyShrimpOwner(msg.sender)\n    {\n        _userShrimpReentrancy[user] = NOT_ENTERED;\n    }\n\n    function getShrimpBeneficiary() \n        public\n        view\n        returns (address)\n    {\n        return _shrimpBeneficiary;\n    }\n    \n    function getShrimpAuctionEndTime() \n        public\n        view\n        returns (uint) \n    {\n        return scon.getAuctionEndTime();\n    }\n    \n    function getTotalBid() \n        public\n        view\n        returns (uint)\n    {\n        return _totalBid;\n    }\n    \n    function getShrimpReturnFee() \n        public\n        view\n        returns (uint256) \n    {\n        return _shrimpReturnFee;\n    }\n    \n    function getMaximumShrimpBid() \n        public\n        view\n        returns (uint) \n    {\n        return _maximumShrimpBid;\n    }\n    \n    function getMinimumShrimpBid() \n        public\n        view\n        returns (uint) \n    {\n        return _minimumShrimpBid;\n    }\n    \n    function checkIfShrimpExists(address shrimp) \n        public\n        view\n        returns (bool)\n    {\n        if(_shrimpBid[shrimp] == true){\n            return true;\n        }\n        return false;\n    }\n    \n    function getShrimpBid(address shrimpAddress) \n        public\n        view\n        returns (uint) \n    {\n        return _shrimpArray[shrimpAddress];\n    }\n    \n    function getShrimpReentrancyStatus(address user) \n        public\n        view\n        onlyShrimpOwner(msg.sender)\n        returns (bool) \n    {\n        return _userShrimpReentrancy[user];\n    }\n    \n    function getTotalAmountOfShrimps() \n        public\n        view\n        returns (uint) \n    {\n        return shrimpAddresses.length;\n    }\n    \n    function getShrimpLastBidTime()\n        public\n        view\n        returns (uint)\n    {\n        return _shrimpLastBidTime;\n    }\n    \n    function getShrimpIncrement() \n        public\n        view\n        returns (uint) \n    {\n        return _shrimpIncrement;\n    }\n    \n    function getShrimpAddress(uint id) \n        public\n        view\n        returns (address)\n    {\n        return shrimpAddresses[id];\n    }\n    \n    function getShrimpContractAddress() \n        public\n        view\n        returns (address)\n    {\n        return address(this);\n    }\n    \n    function getShrimpContractBalance() \n        public\n        view\n        returns (uint) \n    {\n        return address(this).balance;\n    }\n    \n}\n"},"Weighting.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.8.4;\n\nimport \"./Whales.sol\";\nimport \"./Shrimps.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\n\n\ncontract Weighting {\n    \n    address payable internal _weightingBeneficiary;\n    address internal _highestWhaleBidder;\n    address internal _winnerContract;\n    address internal _shrimpsContractAddress;\n    address internal _whalesContractAddress;\n    uint internal _highestWhaleBid;\n    uint internal _highestShrimpBid;\n    uint internal _whaleBidTime;\n    uint internal _shrimpBidTime;\n    uint internal _auctionEndTime;  \n    uint internal _paintingMinimalPricing;\n    uint internal _weightingWinner;\n    uint internal _weightingWinnerMidAuction;\n    bool internal _whaleWinnerCheck;\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    receive() external payable {}\n    fallback() external payable {}\n\n    modifier onlyOwner() {\n        require(msg.sender == _weightingBeneficiary, \"Only the owner can use this function\");\n        _;\n    }\n    \n    modifier afterAuction() {\n        require(block.timestamp >= _auctionEndTime, \"Auction time is incorrect\");\n        _;\n    }\n    \n    modifier beforeAuction() {\n        require(block.timestamp < _auctionEndTime, \"Auction time is incorrect\");\n        _;\n    }\n    modifier onlyShrimpsOrWhales() {\n        require(msg.sender == _whalesContractAddress || msg.sender == _shrimpsContractAddress, \"Not shrimps or whales contract calling\");\n        _;\n    }\n    \n   \n    constructor(\n        address payable weightingBeneficiary,\n        uint paintingMinimalPricing,\n        uint auctionEndTime\n    )\n    {\n        _weightingBeneficiary = weightingBeneficiary;\n        _paintingMinimalPricing = paintingMinimalPricing;\n        _auctionEndTime = auctionEndTime;\n        \n        _weightingWinner = 0;\n        _weightingWinnerMidAuction = 0;\n        _whaleWinnerCheck = false;\n    }\n   \n    function returnWhaleFunds(Whales whalesContract) \n        public\n        payable\n        onlyOwner()\n        afterAuction()\n    {\n        whalesContract._returnWhaleFunds();\n    }\n    \n    function returnShrimpFunds(Shrimps shrimpContract) \n        public\n        payable\n        onlyOwner()\n        afterAuction()\n    {\n        shrimpContract._returnShrimpFunds();\n    }\n    \n    function determineWinner(Whales whalesContract, Shrimps shrimpContract)\n        public\n        onlyOwner()\n        afterAuction()\n        returns(uint)\n    {\n        _highestWhaleBid = whalesContract.getHighestBid();\n        _highestShrimpBid = shrimpContract.getTotalBid();\n        \n        _whaleBidTime = whalesContract.getWhaleLastBidTime();\n        _shrimpBidTime = shrimpContract.getShrimpLastBidTime();\n    \n        if(_highestShrimpBid < _paintingMinimalPricing && _highestWhaleBid < _paintingMinimalPricing){\n            _weightingWinner = 3;\n            return(_weightingWinner);\n        }else{\n            if(_highestWhaleBid > _highestShrimpBid){\n                _weightingWinner = 1;\n                _winnerContract = address(whalesContract);\n            }else if (_highestWhaleBid < _highestShrimpBid){\n                _weightingWinner = 2;\n                _winnerContract = address(shrimpContract);\n            }else{\n                if(_whaleBidTime < _shrimpBidTime){\n                    _weightingWinner = 1;\n                    _winnerContract = address(whalesContract);\n                }else{\n                    _weightingWinner = 2;\n                    _winnerContract = address(shrimpContract);\n                }\n            }\n        }\n\n        return(_weightingWinner);\n    }\n    \n    function determineWinnerMidAuction(Whales whalesContract, Shrimps shrimpContract)\n        public\n        returns(uint, uint)\n    {\n        uint _highestWinnerBidMidAuction;\n        _highestWhaleBid = whalesContract.getHighestBid();\n        _highestShrimpBid = shrimpContract.getTotalBid();\n        \n        _whaleBidTime = whalesContract.getWhaleLastBidTime();\n        _shrimpBidTime = shrimpContract.getShrimpLastBidTime();\n        \n        if(_highestWhaleBid > _highestShrimpBid){\n            _weightingWinnerMidAuction = 1;\n            _highestWinnerBidMidAuction = _highestWhaleBid;\n        }else if (_highestWhaleBid < _highestShrimpBid){\n            _weightingWinnerMidAuction = 2;\n            _highestWinnerBidMidAuction = _highestShrimpBid;\n        }else{\n            if(_whaleBidTime < _shrimpBidTime){\n                _weightingWinnerMidAuction = 1;\n                _highestWinnerBidMidAuction = _highestWhaleBid;\n            }else{\n                _weightingWinnerMidAuction = 2;\n                _highestWinnerBidMidAuction = _highestShrimpBid;\n            }\n        }\n        return(_weightingWinnerMidAuction, _highestWinnerBidMidAuction);\n    }\n    \n    function weightingTransfer(address recipient, uint256 amount)\n        public \n        onlyOwner()\n        afterAuction()\n        returns (bool) \n    {\n        _weightingTransfer(msg.sender, recipient, amount);\n        return true;\n    }\n    \n    function _weightingTransfer(address sender, address recipient, uint256 amount) \n        internal\n        virtual \n    {\n        require(sender != address(0), \"Transfer from the zero address\");\n        require(recipient != address(0), \"Transfer to the zero address\");\n        uint256 senderBalance = address(this).balance;\n        require(senderBalance >= amount, \"Transfer amount exceeds balance\");\n\n        payable(recipient).transfer(amount);\n    }\n    \n    function weightingWithdrawERC20ContractTokens(IERC20 tokenAddress, address recipient)\n        public\n        onlyOwner()\n        returns(bool)\n    {\n        require(msg.sender != address(0), \"Sender is address zero\");\n        require(recipient != address(0), \"Receiver is address zero\");\n        tokenAddress.approve(address(this), tokenAddress.balanceOf(address(this)));\n        if(!tokenAddress.transferFrom(address(this), recipient, tokenAddress.balanceOf(address(this)))){\n            return false;\n        }\n        return true;\n    }\n    \n    function setAuctionEndTime() \n        external\n        onlyShrimpsOrWhales()\n    {\n        _auctionEndTime = block.timestamp + 15 minutes;\n    }\n    \n    function setPaintingMinimalPricing(uint newPrice) \n        public\n        onlyOwner()\n    {\n        _paintingMinimalPricing = newPrice;\n    }\n    \n    function setAuctionEndTimeManual(uint256 newtime) \n        public\n        onlyOwner()\n    {\n        _auctionEndTime = newtime;\n    }\n\n    function confirmWhaleWinner()\n        public\n        afterAuction()\n    {\n        require(msg.sender == _highestWhaleBidder, \"False winner interaction\");\n        _whaleWinnerCheck = true;\n    }\n    \n    function setWhalesContract(address whalesContractAddress) \n        public\n        onlyOwner()\n    {\n        _whalesContractAddress = whalesContractAddress;\n    }\n    \n    function setShrimpsContract(address shrimpsContractAddress) \n        public\n        onlyOwner()\n    {\n        _shrimpsContractAddress = shrimpsContractAddress;\n    }\n\n    function _passWinner()\n        external\n        view\n        afterAuction()\n        returns(uint)\n    {\n        return (_weightingWinner);\n    }\n    \n    function getWhaleData(Whales whalesContract)\n        public\n        onlyOwner()\n        returns (address, uint)\n    {\n        _highestWhaleBidder = whalesContract.getHighestBidder();\n        _highestWhaleBid = whalesContract.getHighestBid();\n        return (_highestWhaleBidder, _highestWhaleBid);\n    }\n    \n    function getShrimpData(Shrimps shrimpContract)\n        public\n        onlyOwner()\n        returns (uint)\n    {\n        _highestShrimpBid = shrimpContract.getTotalBid();\n        return (_highestShrimpBid);\n    }\n    \n    function getBeneficiary() \n        public\n        view\n        returns (address)\n    {\n        return _weightingBeneficiary;\n    }\n    \n    function getHighestWhaleBidder() \n        public\n        view\n        returns (address) \n    {\n        return _highestWhaleBidder;\n    }\n    \n    function getWinnerContract() \n        public\n        view\n        returns (address)\n    {\n        return _winnerContract;\n    }\n    \n    function getHighestWhaleBid() \n        public\n        view\n        returns (uint) \n    {\n        return _highestWhaleBid;\n    }\n    \n    function getHighestShrimpBid() \n        public\n        view\n        returns (uint) \n    {\n        return _highestShrimpBid;\n    }\n    \n    function getAuctionEndTime() \n        public\n        view\n        returns (uint) \n    {\n        return _auctionEndTime;\n    }\n    \n    function whaleWinnerContractInteraction() \n        public\n        afterAuction()\n        view\n        returns (bool) \n    {\n        return _whaleWinnerCheck;\n    }\n \n    function getWeightingContractAddress() \n        public\n        view\n        returns (address) \n    {\n        return address(this);\n    }\n    \n    function getShrimpsContractAddress() \n        public\n        view\n        returns (address) \n    {\n        return _shrimpsContractAddress;\n    }\n    \n    function getWhalesContractAddress() \n        public\n        view\n        returns (address) \n    {\n        return _whalesContractAddress;\n    }\n    \n}\n"},"Whales.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.8.4;\n\nimport \"./Weighting.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\n\n\ncontract Whales {\n   \n    address payable internal _whaleBeneficiary;\n    address internal _whaleWeightingContract;\n    address internal _whaleHighestBidder;\n    uint internal _highestBid;\n    uint internal _whaleLastBidTime;\n    uint internal _minimumWhaleBid;\n    uint internal _whaleIncrement;\n    uint internal _whaleReturnFee;\n    bool private constant NOT_ENTERED = false;\n    bool private constant ENTERED = true;\n    Weighting wcon;\n\n    receive() external payable {}\n    fallback() external payable {}\n   \n    mapping(address => uint) internal _pendingReturns;\n    mapping(address => bool) internal _userWhaleReentrancy;\n    \n    modifier whaleMultipleETH(){\n       require(msg.value % _whaleIncrement == 0, \"Only 1 ETH multiples are accepted\"); //1 ether\n       _;\n    }\n   \n    modifier beforeWhaleAuction(uint _time) {\n        require(block.timestamp < _time, \"Whale auction has ended\");\n        _;\n    }\n    \n    modifier afterWhaleAuction(uint _time) {\n        require(block.timestamp >= _time, \"Whale auction did not end yet\");\n        _;\n    }\n    \n    modifier notWhaleOwner() {\n        require(msg.sender != _whaleBeneficiary, \"Contract owner can not interract here\");\n        _;\n    }\n    \n    modifier onlyWhaleOwner(address messageSender) {\n        require(_whaleBeneficiary == messageSender, \"Only the owner can use this function\");\n        _;\n    }\n    \n    modifier isWhaleWeighting() {\n        require(address(_whaleWeightingContract) == msg.sender, \"Wrong contract passed. Contract is not Weighting\");\n        _;\n    }\n    \n    modifier cantBeFutureOwner(address newBeneficiaryW) {\n        require(_whaleHighestBidder != newBeneficiaryW, \"Can not pass ownership to highest bidder\");\n        _;\n    }\n    \n    modifier lowestWhaleBidMinimum() {\n        require(msg.value >= _minimumWhaleBid/(1 ether), \"Minimum bid amount required\");\n        _;\n    }\n    \n    modifier highestBidRequired() {\n        require(msg.value > _highestBid, \"Highest bidder amount required\");\n        _;\n    }\n    \n    modifier sameBidder() {\n        require(msg.sender == _whaleHighestBidder, \"Only the same bidder can add to amount\");\n        _;   \n    }\n    \n    modifier nonWhaleReentrant() {\n        require(_userWhaleReentrancy[msg.sender] != ENTERED, \"ReentrancyGuard: reentrant call\");\n        _userWhaleReentrancy[msg.sender] = ENTERED;\n        _;\n        _userWhaleReentrancy[msg.sender] = NOT_ENTERED;\n    }\n\n    constructor(\n        address payable whaleBeneficiary,\n        uint minimumWhaleBid,\n        address whaleWeightingContract\n    )\n    {\n        _whaleBeneficiary = whaleBeneficiary;\n        _minimumWhaleBid = minimumWhaleBid;\n        _whaleWeightingContract = whaleWeightingContract;\n        wcon = Weighting(payable(_whaleWeightingContract));\n        \n        _whaleIncrement = 1 ether;\n        _whaleReturnFee = 0.01 ether;\n    }\n    \n    function whalesBid()\n        public\n        payable\n        beforeWhaleAuction(wcon.getAuctionEndTime())\n        notWhaleOwner()\n        lowestWhaleBidMinimum()\n        highestBidRequired()\n        whaleMultipleETH()\n        nonWhaleReentrant()\n    {\n        _whalesBid();\n    }\n   \n    function _whalesBid()\n        internal\n    {\n        if (_highestBid != 0) {\n            _pendingReturns[_whaleHighestBidder] = _pendingReturns[_whaleHighestBidder] + _highestBid;\n            uint amount = _pendingReturns[_whaleHighestBidder];\n            if (amount > 0) {\n                _pendingReturns[_whaleHighestBidder] = 0;\n                if (!payable(_whaleHighestBidder).send(amount)) {\n                    _pendingReturns[_whaleHighestBidder] = amount;\n                }\n            }\n        }\n        \n        _whaleHighestBidder = msg.sender;\n        _highestBid = msg.value;\n        \n        uint timeLeft = wcon.getAuctionEndTime() - block.timestamp;\n        if(timeLeft <= 15 minutes){\n            wcon.setAuctionEndTime();\n        }\n        _whaleLastBidTime = block.timestamp;\n    }\n    \n    function addToWhalesBid()\n        public\n        payable\n        beforeWhaleAuction(wcon.getAuctionEndTime())\n        notWhaleOwner()\n        sameBidder()\n        whaleMultipleETH()\n        nonWhaleReentrant()\n    {\n        _addToBid();\n    }\n    \n    function _addToBid()\n        internal\n    {\n        if(msg.value > 0 && _highestBid > 0){\n            _highestBid = _highestBid + msg.value;\n            _whaleLastBidTime = block.timestamp;\n        }\n    }\n\n    function _returnWhaleFunds() \n        external\n        payable\n        isWhaleWeighting()\n        afterWhaleAuction(wcon.getAuctionEndTime())\n    {\n        if (_highestBid > 0) {\n            uint amount =  address(this).balance - _whaleReturnFee;\n            payable(_whaleHighestBidder).transfer(amount);\n        }\n    }\n    \n    function transferWhaleOwnership(address payable newWhaleBeneficiary)\n        public\n        onlyWhaleOwner(msg.sender)\n        beforeWhaleAuction(wcon.getAuctionEndTime())\n        cantBeFutureOwner(newWhaleBeneficiary)\n    {\n        _transferWhaleOwnership(newWhaleBeneficiary);\n    }\n   \n    function _transferWhaleOwnership(address payable newWhaleBeneficiary)\n        internal\n    {\n        require(newWhaleBeneficiary != address(0));\n        _whaleBeneficiary = newWhaleBeneficiary;  \n    }\n    \n        \n    function transferWhaleOwnershipToZero()\n        public\n        onlyWhaleOwner(msg.sender)\n        beforeWhaleAuction(wcon.getAuctionEndTime())\n    {\n        _transferWhaleOwnershipToZero();\n    }\n   \n    function _transferWhaleOwnershipToZero()\n        internal\n    {\n        _whaleBeneficiary = payable(address(0));  \n    }\n    \n    function whalesTransfer(address recipient, uint256 amount)\n        public \n        onlyWhaleOwner(msg.sender)\n        afterWhaleAuction(wcon.getAuctionEndTime())\n        returns (bool) \n    {\n        _whalesTransfer(msg.sender, recipient, amount);\n        return true;\n    }\n    \n    function _whalesTransfer(address sender, address recipient, uint256 amount) \n        internal\n        virtual \n    {\n        require(sender != address(0), \"Transfer from the zero address\");\n        require(recipient != address(0), \"Transfer to the zero address\");\n        uint256 senderBalance = address(this).balance;\n        require(senderBalance >= amount, \"Transfer amount exceeds balance\");\n        \n        if(recipient == _whaleHighestBidder){\n            _highestBid = _highestBid - amount;\n            if(_highestBid == 0){\n                _whaleHighestBidder = address(0);\n            }\n        }\n        payable(recipient).transfer(amount);\n    }\n    \n    function whalesWithdrawERC20ContractTokens(IERC20 tokenAddress, address recipient)\n        public\n        onlyWhaleOwner(msg.sender)\n        returns(bool)\n    {\n        require(msg.sender != address(0), \"Sender is address zero\");\n        require(recipient != address(0), \"Receiver is address zero\");\n        tokenAddress.approve(address(this), tokenAddress.balanceOf(address(this)));\n        if(!tokenAddress.transferFrom(address(this), recipient, tokenAddress.balanceOf(address(this)))){\n            return false;\n        }\n        return true;\n    }\n    \n    function resetWhaleReentrancy(address user) \n        public\n        onlyWhaleOwner(msg.sender)\n    {\n        _userWhaleReentrancy[user] = NOT_ENTERED;\n    }\n    \n    function getPendingReturns(address user) \n        public\n        view\n        onlyWhaleOwner(msg.sender)\n        returns (uint256) \n    {\n        return _pendingReturns[user];\n    }\n    \n    function getWhaleReturnFee() \n        public\n        view\n        returns (uint256) \n    {\n        return _whaleReturnFee;\n    }\n    \n    function getWhaleReentrancyStatus(address user) \n        public\n        view\n        onlyWhaleOwner(msg.sender)\n        returns (bool) \n    {\n        return _userWhaleReentrancy[user];\n    }\n\n    function getWhaleBeneficiary() \n        public\n        view\n        returns (address) \n    {\n        return _whaleBeneficiary;\n    }\n    \n    function getHighestBidder() \n        public\n        view\n        returns (address) \n    {\n        return _whaleHighestBidder;\n    }\n    \n    function getWhaleAuctionEndTime() \n        public\n        view\n        returns (uint)\n    {\n        return wcon.getAuctionEndTime();\n    }\n    \n    function getWhaleLastBidTime()\n        public\n        view\n        returns (uint)\n    {\n        return _whaleLastBidTime;\n    }\n    \n    function getHighestBid() \n        public\n        view\n        returns (uint) \n    {\n        return _highestBid;\n    }\n    \n    function getWhaleIncrement() \n        public\n        view\n        returns (uint) \n    {\n        return _whaleIncrement;\n    }\n    \n    function getMinimumWhaleBid() \n        public\n        view\n        returns (uint)\n    {\n        return _minimumWhaleBid;\n    }\n\n    function getWhaleContractAddress() \n        public\n        view\n        returns (address)\n    {\n        return address(this);\n    }\n    \n    function getWhaleContractBalance() \n        public\n        view\n        returns (uint) \n    {\n        return address(this).balance;\n    }\n    \n}\n"},"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"}}}