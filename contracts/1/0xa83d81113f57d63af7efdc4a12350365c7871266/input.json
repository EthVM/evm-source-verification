{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ShareTokenSale.sol": {
      "content": "pragma solidity ^0.7.1;\r\n\r\n/**\r\n * @title Context\r\n * @dev Provide context functions\r\n */\r\nabstract contract Context {\r\n    address public owner;            //Contract owner address\r\n    bool public isContractActive;           //Make sure this contract can be used or not\r\n    \r\n    /**\r\n     * Make sure the sender is the owner of contract\r\n     */ \r\n    modifier onlyOwner{\r\n        require(_msgSender() == owner, \"Only owner can process\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Make sure the contract is active to execute\r\n    */ \r\n    modifier contractActive{\r\n        require(isContractActive, \"This contract is deactived\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor\r\n    * \r\n    * Implementations:\r\n    *   1. Set the owner of contract\r\n    *   2. Set contract is active\r\n    */\r\n    constructor(){\r\n       owner = _msgSender();           //Set owner address when contract is created\r\n       isContractActive = true;        //Contract is active when it is created\r\n    }\r\n\r\n    /**\r\n     * Get sender address\r\n     */ \r\n    function _msgSender() internal view returns(address){\r\n        return msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Get current time in unix timestamp\r\n     */\r\n    function _now() internal view returns(uint){\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n    * Update contract status to make sure this contract can be executed or not\r\n     */\r\n    function setContractStatus(bool status) external onlyOwner{\r\n        require(isContractActive != status,\"The current contract's status is the same with updating status\");\r\n        isContractActive = status;\r\n    }\r\n\r\n    /**\r\n    * @dev Change contract's owner\r\n    * @return If success return true; else return false\r\n    * \r\n    * Requirements:\r\n    *   1. Only current owner can execute\r\n    *   2. `newOwner` is not zero address\r\n    *   3. `newOwner` is not current owner\r\n    * \r\n    * Implementations:\r\n    *   1. Validate requirements\r\n    *   2. Set current owner is newOwner\r\n    *   3. Emit Events\r\n    *   4. Return result\r\n    */\r\n    function setOwner(address newOwner) external onlyOwner returns(bool){\r\n        require(newOwner != address(0), \"New owner is zero address\");\r\n        require(newOwner != owner, \"New owner is current owner\");\r\n\r\n        owner = newOwner;\r\n\r\n        emit OwnerChanged(owner);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Event that notifies contract's owner has been changed to `newOwner` \r\n    */\r\n    event OwnerChanged(address newOwner);\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint a, uint b) internal pure returns (uint) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IBNFToken{\r\n    function createShareHolder(address account, uint amount) external returns(bool);\r\n\r\n    /**\r\n    * @dev Transfer BNF token from sender to recipient when sender transfers BNU token to recipient\r\n    */\r\n    function shareholderTransfer(address sender, address recipient, uint amount) external returns(bool);\r\n}\r\n\r\n/**\r\n@title Share token sale BNU interface\r\n */\r\ninterface IBNUStore{\r\n    /**\r\n    * @dev Transfer BNU token from contract to `recipient`\r\n    */\r\n    function transfer(address recipient, uint amount) external returns(bool);\r\n}\r\n\r\ninterface IERC20Token{\r\n    function burnTokenSale(address account, uint amount) external returns(bool);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n}\r\n\r\ninterface IShareTokenSaleData{\r\n    /**\r\n    * @dev Add a new purchased history of `account` and Update total purchased token amount of `account` in round `round`\r\n    */\r\n    function updatePurchaseData(address account, uint round, uint tokenAmount) external returns(bool);\r\n\r\n    /**\r\n    * @dev Update properties for end round\r\n     */\r\n    function end(uint round, uint time) external returns(bool);\r\n\r\n    /**\r\n    * @dev Get the next time can be released for this round\r\n    */\r\n    function getNextReleaseTime(uint round) external view returns(uint);\r\n\r\n    /**\r\n    * @dev Get release count by round\r\n    */\r\n    function getReleasedCountByRound(uint round) external view returns(uint);\r\n\r\n    /**\r\n    * @dev Get release count by round and holder\r\n    */\r\n    function getReleasedCountByRoundAndHolder(uint round, address account) external view returns(uint);\r\n\r\n    /**\r\n    * @dev Get release count by round\r\n    */\r\n    function getReleasedPercentByRound(uint round) external view returns(uint);\r\n\r\n    /**\r\n    * @dev Get total count can be released by round `round`\r\n    */\r\n    function getTotalCanReleaseCountByRound(uint round) external view returns(uint);\r\n\r\n    /**\r\n    * @dev Update released data when releasing\r\n    */\r\n    function updateReleasedData(uint round) external returns(bool);\r\n\r\n    /**\r\n    * @dev Update released data when releasing\r\n    */\r\n    function updateWithdrawData(address account, uint round) external returns(bool);\r\n\r\n    /**\r\n    * @dev Get the state to check whether shareholders can transfer BNU or not\r\n    */\r\n    function getShareholderCanTransfer() external view returns(bool);\r\n\r\n    /**\r\n    * @dev Get shareholder list \r\n    */\r\n    function getShareholders() external view returns(address[] memory);\r\n\r\n    /**\r\n    * @dev Set the state to check whether shareholders can transfer BNU or not\r\n    */\r\n    function setShareholderCanTransfer(bool value) external;\r\n\r\n    /**\r\n    @dev Update all transfer data when a transfer request is maked\r\n    *\r\n    */\r\n    function updateShareholderTransferData(address from, address to, uint amount, uint round) external returns(bool);\r\n\r\n    /**\r\n    * @dev Get shareholder's token balance by `round`\r\n    */\r\n    function getShareholderBalance(address account, uint round) external view returns(uint);\r\n\r\n    /**\r\n    * @dev Get end time of `round` \r\n    */\r\n    function getTokenSaleEndTime(uint round)  external view returns(uint);\r\n}\r\n\r\n/**\r\n@title Base contract for contract to interact with BNU Store contract\r\n */\r\ncontract BaseBNUStoreClient is Context{\r\n    IBNUStore internal _bnuStoreContract;\r\n\r\n    function setBNUStoreContract(address contractAddress) external onlyOwner contractActive{\r\n        _setBNUStoreContract(contractAddress);\r\n    }\r\n\r\n    function _setBNUStoreContract(address contractAddress) internal{\r\n        _bnuStoreContract = IBNUStore(contractAddress);\r\n    }\r\n}\r\n\r\ncontract ShareTokenSale is BaseBNUStoreClient{\r\n    using SafeMath for uint;\r\n\r\n    IShareTokenSaleData internal _dbContract;\r\n    IBNFToken internal _bnfTokenContract;\r\n\r\n    function setBnfTokenContract(address contractAddress) external onlyOwner contractActive{\r\n        _setBnfTokenContract(contractAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Set contract addresses\r\n    * @param dbAddress new database contract address\r\n    * @param bnuStoreAddress new BNU contract address\r\n    * @param bnfAddress new BNF contract address\r\n    */\r\n    function setContracts(address dbAddress, address bnuStoreAddress, address bnfAddress) external onlyOwner contractActive{\r\n        _setDbContract(dbAddress);\r\n        _setBNUStoreContract(bnuStoreAddress);\r\n        _setBnfTokenContract(bnfAddress);\r\n    }\r\n\r\n    function setDbContract(address contractAddress) external onlyOwner contractActive{\r\n        _setDbContract(contractAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev End current round\r\n    * Requirements\r\n    *   Current round should be Seed or Private\r\n    *\r\n    * Implementations\r\n    *   1. Validate requirements\r\n    *   2. Update _canPurchase property\r\n    *   3. Burn all remain tokens of this round\r\n    *   4. Call to dbContract to end current round\r\n    */\r\n    function end(uint round, uint time) external onlyOwner returns(bool){\r\n        uint endTime = _dbContract.getTokenSaleEndTime(round);\r\n        require(endTime == 0, \"ShareTokenSaleFactory.end: This round has been ended before\");\r\n\r\n        //Update end round stage and emit event\r\n        _end(round, time);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Process to purchase token\r\n    * @param account account address to purchase\r\n    * @param tokenAmount purchased amount\r\n    * @param round round to purchase\r\n    * \r\n    * Requirements:\r\n    *   1. Can purchase\r\n    *   2. Time to purchase is available\r\n    *   3. Remain token amount is greater than or equals `amount`\r\n    *\r\n    * Implementations:\r\n    *   1. Validate the remain token amount\r\n    *   2. Update purchased token amount for `account`\r\n    *   3. Create purchased history for `account`\r\n    *   4. Reduce remain amount for this round\r\n    *   5. Process to raise BNF fund\r\n    *   6. Check to end current round if all tokens are sold\r\n    *   7. Emit event\r\n    */\r\n    function purchase(address account, uint tokenAmount, uint round) external onlyOwner returns(bool){\r\n        require(tokenAmount > 0, \"Token amount is zero\");\r\n\r\n        require(round == 0 || round == 1, \"Current round should be Seed or Private\");\r\n\r\n        //Create purchased history\r\n        require(_dbContract.updatePurchaseData(account, round, tokenAmount),\"purchase: Can not add new purchased history\");\r\n\r\n        //Raise BNF fund\r\n        require(_bnfTokenContract.createShareHolder(account, tokenAmount), \"Can not create share holder\");\r\n\r\n        //emit Events\r\n        emit Purchase(account, tokenAmount, round);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Get the state to check whether shareholders can transfer BNU or not\r\n    */\r\n    function getShareholderCanTransfer() external view returns(bool){\r\n        return _getShareholderCanTransfer();\r\n    }\r\n\r\n    /**\r\n    * @dev Set the state to check whether shareholders can transfer BNU or not\r\n    */\r\n    function setShareholderCanTransfer(bool value) external onlyOwner{\r\n        _dbContract.setShareholderCanTransfer(value);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer BNU between shareholders\r\n    * @param from shareholder sender\r\n    * @param to shareholder receiver\r\n    * @param amount BNU token amount to transfer\r\n    * @param round Seed or Private round\r\n    * \r\n    * Requirements\r\n    *   1. Can transfer BNU now\r\n    *   1. `from` and `to` is not zero address\r\n    *   2. `amount` is greater than zero\r\n    *   3. `from` has enough `amount` token in `round`\r\n    *\r\n    * Implementations\r\n    *   1. Validate requirements\r\n    *   2. Update from and to BNU amount: Decrease from BNU token amount and increase to BNU token amount\r\n    *   3. Update from and to BNF amount: Decrease from BNF token amount and increase to BNF token amount\r\n    *   4. emit Events\r\n    */\r\n    function shareholderTransfer(address from, address to, uint amount, uint round) external onlyOwner returns(bool){\r\n        require(_getShareholderCanTransfer(),\"ShareTokenSaleFactory.shareHolderTransfer: Can not transfer now\");\r\n        //Requirements\r\n        require(from != address(0) && to != address(0), \"ShareTokenSaleFactory.shareHolderTransfer: From or to is address zero\");\r\n        require(from != to, \"ShareTokenSaleFactory.shareHolderTransfer: Sender and recipient are the same\");\r\n        require(amount > 0, \"ShareTokenSaleFactory.shareHolderTransfer: amount is zero\");\r\n        require(_getShareholderBalance(from, round) >= amount, \"ShareTokenSaleFactory.shareHolderTransfer: Balance is not enough\");\r\n\r\n        //Update transfer data: Create transfer history, Update shareholder balance\r\n        require(_dbContract.updateShareholderTransferData(from, to, amount, round),\"ShareTokenSaleFactory.shareHolderTransfer: Can not update transfer data\");\r\n\r\n        //Update BNF for sender and receiver\r\n        require(_bnfTokenContract.shareholderTransfer(from, to, amount), \"ShareTokenSaleFactory.shareHolderTransfer: Can not update shareholders' BNF balances\");\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Get shareholder's token balance by `round`\r\n    */\r\n    function getShareholderBalance(address account, uint round) external view returns(uint){\r\n        return _getShareholderBalance(account, round);\r\n    }\r\n\r\n    /**\r\n    * @dev Release token for each stage of specific round\r\n    *\r\n    * @param round Round to release token\r\n    *\r\n    * Requirements:\r\n    *   1. Round should be Seed or Private\r\n    *   2. Processing round percent should be less than or equals 100%\r\n    *\r\n    * Implementations:\r\n    *   1. Get all shareholders to process\r\n    *   2. For each shareholder, calculate released token and pay\r\n    *   3. Create released history\r\n    *   4. Increase total release percent\r\n    */\r\n    function release(uint round) external onlyOwner returns(bool){\r\n        require(round == 0 || round == 1, \"Round should be Seed or Private round\");\r\n\r\n        uint releaseCountByRound = _dbContract.getReleasedCountByRound(round);\r\n        //Can release more\r\n        require(releaseCountByRound <  _dbContract.getTotalCanReleaseCountByRound(round), \"All token has been released\");\r\n\r\n        //Enough time to release\r\n        require(_now() >= _dbContract.getNextReleaseTime(round),\"ShareTokenSaleFactory.release: Can not release this time\");\r\n\r\n        uint releasePercent = _dbContract.getReleasedPercentByRound(round);\r\n\r\n        address[] memory shareholders = _getShareholders();\r\n\r\n        bool result = false;\r\n        if(shareholders.length > 0){\r\n            for(uint index = 0; index < shareholders.length; index++){\r\n                if(_getReleasedCountByRoundAndHolder(round, shareholders[index]) <= releaseCountByRound){\r\n                    require(\r\n                        _processRelease(shareholders[index], _getShareholderBalance(shareholders[index], round).mul(releasePercent).div(1000), round),\r\n                        \"Can not process token releasing\");\r\n\r\n                    result = true;\r\n                }\r\n            }\r\n\r\n            //Update total release percent of round\r\n            require(_dbContract.updateReleasedData(round),\"Can not update release data\");\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n    * @dev Holders can withdraw released token for each round in released time\r\n    */\r\n    function withdraw(uint round) external returns(bool){\r\n        address account = _msgSender();\r\n        require(round == 0 || round == 1, \"Round should be Seed or Private round\");\r\n\r\n        uint releaseCountByRound = _dbContract.getReleasedCountByRound(round);\r\n        //Can release more\r\n        require(releaseCountByRound <  _dbContract.getTotalCanReleaseCountByRound(round), \"All token has been released\");\r\n\r\n        //Enough time to release\r\n        require(_now() >= _dbContract.getNextReleaseTime(round),\"ShareTokenSaleFactory.release: Can not release this time\");\r\n\r\n        if(_getReleasedCountByRoundAndHolder(round, account) <= releaseCountByRound){\r\n            uint releasePercent = _dbContract.getReleasedPercentByRound(round);\r\n            require(_processRelease(account, _getShareholderBalance(account, round).mul(releasePercent).div(1000), round), \"Can not process token releasing\");\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * @dev Process releasing tokens after validating\r\n     */\r\n    function _processRelease(address recipient, uint amount, uint round) internal returns(bool){\r\n        require(_bnuStoreContract.transfer(recipient, amount), \"_processRelease: Can not transfer token to receiver\");\r\n\r\n        //Update total release percent of round\r\n        require(_dbContract.updateWithdrawData(recipient, round),\"Can not update withdraw data\");\r\n\r\n        //Emit event\r\n        emit Release(recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Get shareholder's token balance by `round`\r\n    */\r\n    function _getShareholderBalance(address account, uint round) internal view returns(uint){\r\n        return _dbContract.getShareholderBalance(account, round);\r\n    }\r\n\r\n    /**\r\n    * @dev End current round after validating all requirements\r\n    */\r\n    function _end(uint round, uint time) internal {\r\n        //Call db contract to end\r\n        require(_dbContract.end(round, time), \"ShareTokenSaleFactory._end: Can not end current round\");\r\n\r\n        //emit event\r\n        emit EndTokenSale(round, time);\r\n    }\r\n\r\n    function _getReleasedCountByRoundAndHolder(uint round, address account) internal view returns(uint){\r\n        return _dbContract.getReleasedCountByRoundAndHolder(round, account);\r\n    }\r\n\r\n    /**\r\n    * @dev Get shareholder list \r\n    */\r\n    function _getShareholders() internal view returns(address[] memory){\r\n        return _dbContract.getShareholders();\r\n    }\r\n\r\n    /**\r\n    * @dev Set database contract address\r\n    * @param contractAddress new database contract address\r\n    */\r\n    function _setDbContract(address contractAddress) internal{\r\n        _dbContract = IShareTokenSaleData(contractAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Set BNU contract address\r\n    * @param contractAddress new BNU contract address\r\n    */\r\n    function _setBnfTokenContract(address contractAddress) internal{\r\n        _bnfTokenContract = IBNFToken(contractAddress);\r\n    }\r\n\r\n    function _getShareholderCanTransfer() internal view returns(bool){\r\n        return _dbContract.getShareholderCanTransfer();\r\n    }\r\n\r\n    event EndTokenSale(uint round, uint time);\r\n    event Purchase(address account, uint amount, uint round);\r\n    event Release(address account, uint amount);\r\n}\r\n\r\n//SPDX-License-Identifier: MIT"
    }
  }
}