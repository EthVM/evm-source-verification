{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "PleStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\nlibrary EnumerableSet {\n    struct Set {\n        bytes32[] _values;\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            set._values[toDeleteIndex] = lastvalue;\n\n            set._indexes[lastvalue] = toDeleteIndex + 1;\n\n            set._values.pop();\n\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _contains(Set storage set, bytes32 value)\n        private\n        view\n        returns (bool)\n    {\n        return set._indexes[value] != 0;\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _at(Set storage set, uint256 index)\n        private\n        view\n        returns (bytes32)\n    {\n        require(\n            set._values.length > index,\n            \"EnumerableSet: index out of bounds\"\n        );\n        return set._values[index];\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    function add(AddressSet storage set, address value)\n        internal\n        returns (bool)\n    {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    function remove(AddressSet storage set, address value)\n        internal\n        returns (bool)\n    {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    function contains(AddressSet storage set, address value)\n        internal\n        view\n        returns (bool)\n    {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(AddressSet storage set, uint256 index)\n        internal\n        view\n        returns (address)\n    {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(UintSet storage set, uint256 value)\n        internal\n        returns (bool)\n    {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function contains(UintSet storage set, uint256 value)\n        internal\n        view\n        returns (bool)\n    {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(UintSet storage set, uint256 index)\n        internal\n        view\n        returns (uint256)\n    {\n        return uint256(_at(set._inner, index));\n    }\n}\n\ninterface IERC20 {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    // Mutative functions\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ncontract PleStaking {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    event RewardsTransferred(address holder, uint256 amount);\n\n    IERC20 public tokenContract;\n\n    address public tokenFeeAddress;\n\n    // reward rate 40.00% per year\n    uint256 public constant rewardRate = 4000;\n    uint256 public constant rewardInterval = 365 days;\n\n    // staking fee 1.50 percent\n    uint256 public constant stakingFeeRate = 150;\n\n    // unstaking fee 0.50 percent\n    uint256 public constant unstakingFeeRate = 50;\n\n    uint256 public totalClaimedRewards = 0;\n\n    EnumerableSet.AddressSet private holders;\n\n    mapping(address => uint256) public depositedTokens;\n    mapping(address => uint256) public stakingTime;\n    mapping(address => uint256) public lastClaimedTime;\n    mapping(address => uint256) public totalEarnedTokens;\n\n    constructor(address _tokenAddress, address _tokenFeeAddress) public {\n        tokenContract = IERC20(_tokenAddress);\n        tokenFeeAddress = _tokenFeeAddress;\n    }\n\n    function getBalance() private view returns (uint256) {\n        return tokenContract.balanceOf(address(this));\n    }\n\n    function getRewardToken() private view returns (uint256) {\n        uint256 totalDepositedAmount = 0;\n        uint256 length = getNumberOfHolders();\n        for (uint256 i = 0; i < length; i = i.add(1)) {\n            uint256 depositedAmount = depositedTokens[holders.at(i)];\n            totalDepositedAmount = totalDepositedAmount.add(depositedAmount);\n        }\n\n        return tokenContract.balanceOf(address(this)).sub(totalDepositedAmount);\n    }\n\n    function distributeToken(address account) private {\n        uint256 pendingDivs = getPendingDivs(account);\n        if (pendingDivs > 0) {\n            tokenContract.balanceOf(address(this)).sub(pendingDivs);\n            tokenContract.balanceOf(account).add(pendingDivs);\n            require(\n                tokenContract.transfer(account, pendingDivs),\n                \"Could not transfer tokens.\"\n            );\n            totalEarnedTokens[account] = totalEarnedTokens[account].add(\n                pendingDivs\n            );\n            totalClaimedRewards = totalClaimedRewards.add(pendingDivs);\n            emit RewardsTransferred(account, pendingDivs);\n        }\n       lastClaimedTime[account] = now;\n    }\n  \n   \n    function getPendingDivs(address _holder) public view returns (uint256) {\n        if (!holders.contains(_holder)) return 0;\n        if (depositedTokens[_holder] == 0) return 0;\n        if (getRewardToken() == 0) return 0;\n\n        uint256 timeDiff = now.sub(lastClaimedTime[_holder]);\n        uint256 stakedAmount = depositedTokens[_holder];\n        \n        uint256 pendingDivs = stakedAmount.mul(timeDiff).mul(rewardRate).div(rewardInterval).div(1e4);\n\n        return pendingDivs;\n    }\n\n    function getNumberOfHolders() public view returns (uint256) {\n        return holders.length();\n    }\n\n    function stake(uint256 amountToStake) public {\n        require(amountToStake > 0, \"Cannot deposit 0 Tokens\");\n        require(\n            tokenContract.transferFrom(\n                msg.sender,\n                address(this),\n                amountToStake\n            ),\n            \"Insufficient Token Allowance\"\n        );\n        \n      \n\n        uint256 fee = amountToStake.mul(stakingFeeRate).div(1e4);\n        uint256 amountAfterFee = amountToStake.sub(fee);\n\n        require(\n            tokenContract.transfer(tokenFeeAddress, fee),\n            \"Could not transfer deposit fee.\"\n        );\n\n        depositedTokens[msg.sender] = depositedTokens[msg.sender].add(\n            amountAfterFee\n        );\n\n        if (!holders.contains(msg.sender)) {\n            holders.add(msg.sender);\n            stakingTime[msg.sender] = now;\n            lastClaimedTime[msg.sender] = now;\n        }\n    }\n\n    function unstake(uint256 amountToWithdraw) public {\n        require(\n            depositedTokens[msg.sender] >= amountToWithdraw,\n            \"Invalid amount to withdraw\"\n        );\n        \n     \n        \n        uint256 fee = amountToWithdraw.mul(unstakingFeeRate).div(1e4);\n        uint256 amountAfterFee = amountToWithdraw.sub(fee);\n        require(\n            tokenContract.transfer(tokenFeeAddress, fee),\n            \"Could not transfer unstaking fee.\"\n        );\n        require(\n            tokenContract.transfer(msg.sender, amountAfterFee),\n            \"Could not transfer tokens.\"\n        );\n\n        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(\n            amountToWithdraw\n        );\n\n        if (holders.contains(msg.sender) && depositedTokens[msg.sender] == 0) {\n            holders.remove(msg.sender);\n        }\n    }\n\n    function claimDivs() public {\n        distributeToken(msg.sender);\n    }\n\n    function getStakersList(uint256 startIndex, uint256 endIndex)\n        public\n        view\n        returns (\n            address[] memory stakers,\n            uint256[] memory stakingTimestamps,\n            uint256[] memory lastClaimedTimeStamps,\n            uint256[] memory stakedTokens\n        )\n    {\n        require(startIndex < endIndex);\n\n        uint256 length = endIndex.sub(startIndex);\n        address[] memory _stakers = new address[](length);\n        uint256[] memory _stakingTimestamps = new uint256[](length);\n        uint256[] memory _lastClaimedTimeStamps = new uint256[](length);\n        uint256[] memory _stakedTokens = new uint256[](length);\n\n        for (uint256 i = startIndex; i < endIndex; i = i.add(1)) {\n            address staker = holders.at(i);\n            uint256 listIndex = i.sub(startIndex);\n            _stakers[listIndex] = staker;\n            _stakingTimestamps[listIndex] = stakingTime[staker];\n            _lastClaimedTimeStamps[listIndex] = lastClaimedTime[staker];\n            _stakedTokens[listIndex] = depositedTokens[staker];\n        }\n\n        return (\n            _stakers,\n            _stakingTimestamps,\n            _lastClaimedTimeStamps,\n            _stakedTokens\n        );\n    }\n}\n"
    }
  }
}