{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"NAVFeed.sol":{"content":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/borrower/feed/navfeed.sol\npragma solidity >=0.5.15 >=0.5.15 <0.6.0;\npragma experimental ABIEncoderV2;\n\n////// lib/tinlake-auth/lib/ds-note/src/note.sol\n/// note.sol -- the `note' modifier, for logging calls as events\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n/* pragma solidity >=0.5.15; */\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint256           wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        _;\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n    }\n}\n\n////// lib/tinlake-auth/src/auth.sol\n// Copyright (C) Centrifuge 2020, based on MakerDAO dss https://github.com/makerdao/dss\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.5.15 <0.6.0; */\n\n/* import \"ds-note/note.sol\"; */\n\ncontract Auth is DSNote {\n    mapping (address => uint) public wards;\n    function rely(address usr) public auth note { wards[usr] = 1; }\n    function deny(address usr) public auth note { wards[usr] = 0; }\n    modifier auth { require(wards[msg.sender] == 1); _; }\n}\n\n////// lib/tinlake-math/src/math.sol\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.5.15 <0.6.0; */\n\ncontract Math {\n    uint256 constant ONE = 10 ** 27;\n\n    function safeAdd(uint x, uint y) public pure returns (uint z) {\n        require((z = x + y) >= x, \"safe-add-failed\");\n    }\n\n    function safeSub(uint x, uint y) public pure returns (uint z) {\n        require((z = x - y) <= x, \"safe-sub-failed\");\n    }\n\n    function safeMul(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"safe-mul-failed\");\n    }\n\n    function safeDiv(uint x, uint y) public pure returns (uint z) {\n        z = x / y;\n    }\n\n    function rmul(uint x, uint y) public pure returns (uint z) {\n        z = safeMul(x, y) / ONE;\n    }\n\n    function rdiv(uint x, uint y) public pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        z = safeAdd(safeMul(x, ONE), y / 2) / y;\n    }\n\n    function rdivup(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        // always rounds up\n        z = safeAdd(safeMul(x, ONE), safeSub(y, 1)) / y;\n    }\n\n\n}\n\n////// lib/tinlake-math/src/interest.sol\n// Copyright (C) 2018 Rain <rainbreak@riseup.net> and Centrifuge, referencing MakerDAO dss => https://github.com/makerdao/dss/blob/master/src/pot.sol\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.5.15 <0.6.0; */\n\n/* import \"./math.sol\"; */\n\ncontract Interest is Math {\n    // @notice This function provides compounding in seconds\n    // @param chi Accumulated interest rate over time\n    // @param ratePerSecond Interest rate accumulation per second in RAD(10ˆ27)\n    // @param lastUpdated When the interest rate was last updated\n    // @param pie Total sum of all amounts accumulating under one interest rate, divided by that rate\n    // @return The new accumulated rate, as well as the difference between the debt calculated with the old and new accumulated rates.\n    function compounding(uint chi, uint ratePerSecond, uint lastUpdated, uint pie) public view returns (uint, uint) {\n        require(block.timestamp >= lastUpdated, \"tinlake-math/invalid-timestamp\");\n        require(chi != 0);\n        // instead of a interestBearingAmount we use a accumulated interest rate index (chi)\n        uint updatedChi = _chargeInterest(chi ,ratePerSecond, lastUpdated, block.timestamp);\n        return (updatedChi, safeSub(rmul(updatedChi, pie), rmul(chi, pie)));\n    }\n\n    // @notice This function charge interest on a interestBearingAmount\n    // @param interestBearingAmount is the interest bearing amount\n    // @param ratePerSecond Interest rate accumulation per second in RAD(10ˆ27)\n    // @param lastUpdated last time the interest has been charged\n    // @return interestBearingAmount + interest\n    function chargeInterest(uint interestBearingAmount, uint ratePerSecond, uint lastUpdated) public view returns (uint) {\n        if (block.timestamp >= lastUpdated) {\n            interestBearingAmount = _chargeInterest(interestBearingAmount, ratePerSecond, lastUpdated, block.timestamp);\n        }\n        return interestBearingAmount;\n    }\n\n    function _chargeInterest(uint interestBearingAmount, uint ratePerSecond, uint lastUpdated, uint current) internal pure returns (uint) {\n        return rmul(rpow(ratePerSecond, current - lastUpdated, ONE), interestBearingAmount);\n    }\n\n\n    // convert pie to debt/savings amount\n    function toAmount(uint chi, uint pie) public pure returns (uint) {\n        return rmul(pie, chi);\n    }\n\n    // convert debt/savings amount to pie\n    function toPie(uint chi, uint amount) public pure returns (uint) {\n        return rdivup(amount, chi);\n    }\n\n    function rpow(uint x, uint n, uint base) public pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                let xx := mul(x, x)\n                if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                let xxRound := add(xx, half)\n                if lt(xxRound, xx) { revert(0,0) }\n                x := div(xxRound, base)\n                if mod(n,2) {\n                    let zx := mul(z, x)\n                    if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                    let zxRound := add(zx, half)\n                    if lt(zxRound, zx) { revert(0,0) }\n                    z := div(zxRound, base)\n                }\n            }\n            }\n        }\n    }\n}\n\n////// src/borrower/feed/buckets.sol\n// Copyright (C) 2020 Centrifuge\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n/* pragma solidity >=0.5.15; */\n\n// the buckets contract stores values in a map using a timestamp as a key\n// each value store a pointer the next value in a linked list\n// to improve performance/gas efficiency while iterating over all values in a timespan\ncontract Buckets {\n    // abstract contract\n    constructor() internal {}\n\n    struct Bucket {\n        uint value;\n        uint next;\n    }\n\n    // timestamp => bucket\n    mapping (uint => Bucket) public buckets;\n\n    // pointer to the first bucket and last bucket\n    uint public firstBucket;\n    uint public lastBucket;\n\n    uint constant public NullDate = 1;\n\n    function addBucket(uint timestamp, uint value) internal {\n        buckets[timestamp].value = value;\n\n        if (firstBucket == 0) {\n            firstBucket = timestamp;\n            buckets[timestamp].next = NullDate;\n            lastBucket = firstBucket;\n            return;\n        }\n\n        // new bucket before first one\n        if (timestamp < firstBucket) {\n            buckets[timestamp].next = firstBucket;\n            firstBucket = timestamp;\n            return;\n        }\n\n        // find predecessor bucket by going back in time\n        // instead of iterating the linked list from the first bucket\n        // assuming its more gas efficient to iterate over time instead of iterating the list from the beginning\n        // not true if buckets are only sparsely populated over long periods of time\n        uint prev = timestamp;\n        while(buckets[prev].next == 0) {prev = prev - 1 days;}\n\n        if (buckets[prev].next == NullDate) {\n            lastBucket = timestamp;\n        }\n        buckets[timestamp].next = buckets[prev].next;\n        buckets[prev].next = timestamp;\n    }\n\n    function removeBucket(uint timestamp) internal {\n        buckets[timestamp].value = 0;\n        _removeBucket(timestamp);\n        buckets[timestamp].next = 0;\n    }\n\n    function _removeBucket(uint timestamp) internal {\n        if(firstBucket == lastBucket) {\n            lastBucket = 0;\n            firstBucket = 0;\n            return;\n        }\n\n        if (timestamp != firstBucket) {\n            uint prev = timestamp - 1 days;\n            // assuming its more gas efficient to iterate over time instead of iterating the list from the beginning\n            // not true if buckets are only sparsely populated over long periods of time\n            while(buckets[prev].next != timestamp) {prev = prev - 1 days;}\n            buckets[prev].next = buckets[timestamp].next;\n            if(timestamp == lastBucket) {\n                lastBucket = prev;\n            }\n            return;\n        }\n\n        firstBucket = buckets[timestamp].next;\n    }\n}\n\n////// src/borrower/feed/nftfeed.sol\n// Copyright (C) 2020 Centrifuge\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.5.15 <0.6.0; */\n\n/* import \"ds-note/note.sol\"; */\n/* import \"tinlake-auth/auth.sol\"; */\n/* import \"tinlake-math/math.sol\"; */\n\ncontract ShelfLike_2 {\n    function shelf(uint loan) public view returns (address registry, uint tokenId);\n    function nftlookup(bytes32 nftID) public returns (uint loan);\n}\n\ncontract PileLike_2 {\n    function setRate(uint loan, uint rate) public;\n    function debt(uint loan) public returns (uint);\n    function pie(uint loan) public returns (uint);\n    function changeRate(uint loan, uint newRate) public;\n    function loanRates(uint loan) public returns (uint);\n    function file(bytes32, uint, uint) public;\n    function rates(uint rate) public view returns (uint, uint, uint ,uint48, uint);\n    function total() public view returns (uint);\n    function rateDebt(uint rate) public view returns (uint);\n}\n\n// The NFTFeed stores values and risk group of nfts that are used as collateral in tinlake. A risk group contains: thresholdRatio, ceilingRatio & interstRate.\n// The risk groups for a tinlake deployment are defined on contract creation and can not be changed afterwards.\n// Loan parameters like interstRate, max borrow amount and liquidation threshold are determined based on the value and risk group of the underlying collateral nft.\ncontract BaseNFTFeed is DSNote, Auth, Math {\n\n    // nftID => nftValues\n    mapping (bytes32 => uint) public nftValues;\n    // nftID => risk\n    mapping (bytes32 => uint) public risk;\n\n    // risk => thresholdRatio\n    // thresholdRatio is used to determine the liquidation threshold of the loan. thresholdRatio * nftValue = liquidation threshold\n    // When loan debt reaches the liquidation threshold, it can be seized and collected by a whitelisted keeper.\n    mapping (uint => uint) public thresholdRatio;\n\n    // risk => ceilingRatio\n    // ceilingRatio is used to determine the ax borrow amount (ceiling) of a loan. ceilingRatio * nftValue = max borrow amount\n    // When loan debt reaches the liquidation threshold, it can be seized and collected by a whitelisted keeper.\n    mapping (uint => uint) public ceilingRatio;\n\n    // loan => borrowed\n    // stores the already borrowed amounts for each loan\n    // required to track the borrowed currency amount without accrued interest\n    mapping (uint => uint) public borrowed;\n\n    PileLike_2 pile;\n    ShelfLike_2 shelf;\n\n    constructor () public {\n        wards[msg.sender] = 1;\n    }\n\n     // part of Feed interface\n    function file(bytes32 name, uint value) public auth {}\n\n    /// sets the dependency to another contract\n    function depend(bytes32 contractName, address addr) external auth {\n        if (contractName == \"pile\") {pile = PileLike_2(addr);}\n        else if (contractName == \"shelf\") { shelf = ShelfLike_2(addr); }\n        else revert();\n    }\n\n    // returns a unique id based on the nft registry and tokenId\n    // the nftID is used to set the risk group and value for nfts\n    function nftID(address registry, uint tokenId) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(registry, tokenId));\n    }\n\n    // returns the nftID for the underlying collateral nft\n    function nftID(uint loan) public view returns (bytes32) {\n        (address registry, uint tokenId) = shelf.shelf(loan);\n        return nftID(registry, tokenId);\n    }\n\n    function file(bytes32 name, uint risk_, uint thresholdRatio_, uint ceilingRatio_, uint rate_) public auth {\n        if(name == \"riskGroupNFT\") {\n            require(ceilingRatio[risk_] == 0, \"risk-group-in-usage\");\n            thresholdRatio[risk_] = thresholdRatio_;\n            ceilingRatio[risk_] = ceilingRatio_;\n            // set interestRate for risk group\n            pile.file(\"rate\", risk_, rate_);\n        } else {revert (\"unkown name\");}\n    }\n\n    ///  -- Oracle Updates --\n\n    // The nft value is to be updated by authenticated oracles\n    function update(bytes32 nftID_,  uint value) public auth {\n        // switch of collateral risk group results in new: ceiling, threshold for existing loan\n        nftValues[nftID_] = value;\n    }\n\n     // The nft value & risk group is to be updated by authenticated oracles\n    function update(bytes32 nftID_, uint value, uint risk_) public auth {\n        // the risk group has to exist\n        require(thresholdRatio[risk_] != 0, \"threshold for risk group not defined\");\n\n        // switch of collateral risk group results in new: ceiling, threshold and interest rate for existing loan\n        // change to new rate interestRate immediately in pile if loan debt exists\n        uint loan = shelf.nftlookup(nftID_);\n        if (pile.pie(loan) != 0) {\n            pile.changeRate(loan, risk_);\n        }\n        risk[nftID_] = risk_;\n        nftValues[nftID_] = value;\n    }\n\n    // function checks if the borrow amount does not exceed the max allowed borrow amount (=ceiling)\n    function borrow(uint loan, uint amount) external auth returns (uint) {\n        // increase borrowed amount -> note: max allowed borrow amount does not include accrued interest\n        borrowed[loan] = safeAdd(borrowed[loan], amount);\n\n        require(currentCeiling(loan) >= borrowed[loan], \"borrow-amount-too-high\");\n        return amount;\n    }\n\n    // part of Feed interface\n    function repay(uint, uint amount) external auth returns (uint) {\n        // note: borrowed amount is not decreased as the feed implements the principal and not credit line method\n        return amount;\n    }\n\n    // borrowEvent is called by the shelf in the borrow method\n    function borrowEvent(uint loan) public auth {\n        uint risk_ = risk[nftID(loan)];\n\n        // when issued every loan has per default interest rate of risk group 0.\n        // correct interest rate has to be set on first borrow event\n        if(pile.loanRates(loan) != risk_) {\n            // set loan interest rate to the one of the correct risk group\n            pile.setRate(loan, risk_);\n        }\n    }\n\n    // part of Feed interface\n    function unlockEvent(uint loan) public auth {}\n\n    ///  -- Getter methods --\n    // returns the ceiling of a loan\n    // the ceiling defines the maximum amount which can be borrowed\n    function ceiling(uint loan) public view returns (uint) {\n        if (borrowed[loan] > currentCeiling(loan)) {\n            return 0;\n        }\n        return safeSub(currentCeiling(loan), borrowed[loan]);\n    }\n\n    function currentCeiling(uint loan) public view returns(uint) {\n        bytes32 nftID_ = nftID(loan);\n        return rmul(nftValues[nftID_], ceilingRatio[risk[nftID_]]);\n    }\n\n    // returns the threshold of a loan\n    // if the loan debt is above the loan threshold the NFT can be seized\n    function threshold(uint loan) public view returns (uint) {\n        bytes32 nftID_ = nftID(loan);\n        return rmul(nftValues[nftID_], thresholdRatio[risk[nftID_]]);\n    }\n\n    /// implements feed interface and returns poolValue as the total debt of all loans\n    function totalValue() public view returns (uint) {\n        return pile.total();\n    }\n}\n\n////// src/fixed_point.sol\n// Copyright (C) 2020 Centrifuge\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.5.15 <0.6.0; */\n\ncontract FixedPoint {\n    struct Fixed27 {\n        uint value;\n    }\n}\n\n////// src/borrower/feed/navfeed.sol\n// Copyright (C) 2020 Centrifuge\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n/* pragma solidity >=0.5.15 <0.6.0; */\n/* pragma experimental ABIEncoderV2; */\n\n/* import \"ds-note/note.sol\"; */\n/* import \"tinlake-auth/auth.sol\"; */\n/* import \"tinlake-math/interest.sol\"; */\n/* import \"./nftfeed.sol\"; */\n/* import \"./buckets.sol\"; */\n/* import \"../../fixed_point.sol\"; */\n\n// The Nav Feed contract extends the functionality of the NFT Feed by the Net Asset Value (NAV) computation of a Tinlake pool.\n// NAV is computed as the sum of all discounted future values (fv) of ongoing loans (debt > 0) in the pool.\n// The applied discountRate is dependant on the maturity data of the underlying collateral. The discount decreases with the maturity date approaching.\n// To optimize the NAV calculation the discounting of future values happens bucketwise. FVs from assets with the same maturity date are added to one bucket.\n// This safes iterations & gas, as the same discountRates can be applied per bucket.\ncontract NAVFeed is BaseNFTFeed, Interest, Buckets, FixedPoint {\n\n    // maturityDate is the expected date of repayment for an asset\n    // nftID => maturityDate\n    mapping (bytes32 => uint) public maturityDate;\n\n    // recoveryRatePD is a combined rate that includes the probability of default for an asset of a certain risk group and its recovery rate\n    // risk => recoveryRatePD\n    mapping (uint => Fixed27) public recoveryRatePD;\n\n    // futureValue of an asset based on the loan debt, interest rate, maturity date and recoveryRatePD\n    // nftID => futureValue\n    mapping (bytes32 => uint) public futureValue;\n\n    WriteOff [5] public writeOffs;\n\n    struct WriteOff {\n        uint rateGroup;\n        // denominated in (10^27)\n        Fixed27 percentage;\n    }\n\n    // discount rate applied on every asset's fv depending on its maturityDate. The discount decreases with the maturityDate approaching.\n    Fixed27 public discountRate;\n\n    // approximatedNAV is calculated in case of borrows & repayments between epoch executions.\n    // It decreases/increases the NAV by the repaid/borrowed amount without running the NAV calculation routine.\n    // This is required for more accurate Senior & JuniorAssetValue estimations between epochs\n    uint public approximatedNAV;\n\n    // rate group for write-offs in pile contract\n    uint constant public  WRITE_OFF_PHASE_A = 1000;\n    uint constant public  WRITE_OFF_PHASE_B = 1001;\n    uint constant public  WRITE_OFF_PHASE_C = 1002;\n    uint constant public  WRITE_OFF_PHASE_D = 1003;\n    uint constant public  WRITE_OFF_PHASE_E = 1004;\n\n    constructor () public {\n        wards[msg.sender] = 1;\n    }\n\n    function init() public {\n        require(ceilingRatio[0] == 0, \"already-initialized\");\n\n        // gas optimized initialization of writeOffs and risk groups\n        // write off are hardcoded in the contract instead of init function params\n\n        // risk groups are extended by the recoveryRatePD parameter compared with NFTFeed\n\n        // The following score cards just examples that are mostly optimized for the system test cases\n\n        // risk group: 0\n\n        // risk group: 0 - APR: 2.78%  \n        file(\"riskGroup\", 0, ONE, ONE, uint(1000000000881532217148655504), 99.9836*10**25);\n        // risk group: 1 - APR: 3.02%\n        file(\"riskGroup\", 1, ONE, ONE, uint(1000000000957635717909690512), 99.9803*10**25);\n        // risk group: 2 - APR: 3.26%\n        file(\"riskGroup\", 2, ONE, ONE, uint(1000000001033739218670725520), 99.977*10**25);\n        // risk group: 3 - APR: 3.5%\n        file(\"riskGroup\", 3, ONE, ONE, uint(1000000001109842719431760527), 99.9737*10**25);\n        // risk group: 4 - APR: 3.75%\n        file(\"riskGroup\", 4, ONE, ONE, uint(1000000001189117199391171993), 99.9704*10**25);\n        // risk group: 5 - APR: 3.99%\n        file(\"riskGroup\", 5, ONE, ONE, uint(1000000001265220700152207001), 99.9671*10**25);\n        // risk group: 6 - APR: 4.23%\n        file(\"riskGroup\", 6, ONE, ONE, uint(1000000001341324200913242009), 99.9638*10**25);\n        // risk group: 7 - APR: 4.47%\n        file(\"riskGroup\", 7, ONE, ONE, uint(1000000001417427701674277016), 99.9605*10**25);\n        // risk group: 8 - APR: 4.7%\n        file(\"riskGroup\", 8, ONE, ONE, uint(1000000001490360223236935565), 99.9573*10**25);\n        // risk group: 9 - APR: 4.94%\n        file(\"riskGroup\", 9, ONE, ONE, uint(1000000001566463723997970573), 99.954*10**25);\n        // risk group: 10 - APR: 5.18%\n        file(\"riskGroup\", 10, ONE, ONE, uint(1000000001642567224759005580), 99.9507*10**25);\n        // risk group: 11 - APR: 5.42%\n        file(\"riskGroup\", 11, ONE, ONE, uint(1000000001718670725520040588), 99.9474*10**25);\n        // risk group: 12 - APR: 5.65%\n        file(\"riskGroup\", 12, ONE, ONE, uint(1000000001791603247082699137), 99.9441*10**25);\n        // risk group: 13 - APR: 5.89%\n        file(\"riskGroup\", 13, ONE, ONE, uint(1000000001867706747843734145), 99.9408*10**25);\n        // risk group: 14 - APR: 6.13%\n        file(\"riskGroup\", 14, ONE, ONE, uint(1000000001943810248604769152), 99.9375*10**25);\n        // risk group: 15 - APR: 6.36%\n        file(\"riskGroup\", 15, ONE, ONE, uint(1000000002016742770167427701), 99.9342*10**25);\n        // risk group: 16 - APR: 6.59%\n        file(\"riskGroup\", 16, ONE, ONE, uint(1000000002089675291730086250), 99.931*10**25);\n        // risk group: 17 - APR: 6.83%\n        file(\"riskGroup\", 17, ONE, ONE, uint(1000000002165778792491121258), 99.9277*10**25);\n        // risk group: 18 - APR: 7.06%\n        file(\"riskGroup\", 18, ONE, ONE, uint(1000000002238711314053779807), 99.9244*10**25);\n        // risk group: 19 - APR: 7.29%\n        file(\"riskGroup\", 19, ONE, ONE, uint(1000000002311643835616438356), 99.9211*10**25);\n        // risk group: 20 - APR: 7.53%\n        file(\"riskGroup\", 20, ONE, ONE, uint(1000000002387747336377473363), 99.9178*10**25);\n        // risk group: 21 - APR: 7.76%\n        file(\"riskGroup\", 21, ONE, ONE, uint(1000000002460679857940131912), 99.9145*10**25);\n        // risk group: 22 - APR: 7.99%\n        file(\"riskGroup\", 22, ONE, ONE, uint(1000000002533612379502790461), 99.9112*10**25);\n        // risk group: 23 - APR: 8.22%\n        file(\"riskGroup\", 23, ONE, ONE, uint(1000000002606544901065449010), 99.9079*10**25);\n        // risk group: 24 - APR: 8.45%\n        file(\"riskGroup\", 24, ONE, ONE, uint(1000000002679477422628107559), 99.9047*10**25);\n        // risk group: 25 - APR: 8.68%\n        file(\"riskGroup\", 25, ONE, ONE, uint(1000000002752409944190766108), 99.9014*10**25);\n        // risk group: 26 - APR: 8.91%\n        file(\"riskGroup\", 26, ONE, ONE, uint(1000000002825342465753424657), 99.8981*10**25);\n        // risk group: 27 - APR: 9.14%\n        file(\"riskGroup\", 27, ONE, ONE, uint(1000000002898274987316083206), 99.8948*10**25);\n        // risk group: 28 - APR: 9.36%\n        file(\"riskGroup\", 28, ONE, ONE, uint(1000000002968036529680365296), 99.8915*10**25);\n        // risk group: 29 - APR: 9.59%\n        file(\"riskGroup\", 29, ONE, ONE, uint(1000000003040969051243023845), 99.8882*10**25);\n        // risk group: 30 - APR: 9.82%\n        file(\"riskGroup\", 30, ONE, ONE, uint(1000000003113901572805682394), 99.8849*10**25);\n        // risk group: 31 - APR: 10.04%\n        file(\"riskGroup\", 31, ONE, ONE, uint(1000000003183663115169964485), 99.8816*10**25);\n        // risk group: 32 - APR: 10.27%\n        file(\"riskGroup\", 32, ONE, ONE, uint(1000000003256595636732623033), 99.8784*10**25);\n        // risk group: 33 - APR: 10.5%\n        file(\"riskGroup\", 33, ONE, ONE, uint(1000000003329528158295281582), 99.8751*10**25);\n        // risk group: 34 - APR: 10.72%\n        file(\"riskGroup\", 34, ONE, ONE, uint(1000000003399289700659563673), 99.8718*10**25);\n        // risk group: 35 - APR: 10.95%\n        file(\"riskGroup\", 35, ONE, ONE, uint(1000000003472222222222222222), 99.8685*10**25);\n        // risk group: 36 - APR: 11.17%\n        file(\"riskGroup\", 36, ONE, ONE, uint(1000000003541983764586504312), 99.8652*10**25);\n        // risk group: 37 - APR: 11.39%\n        file(\"riskGroup\", 37, ONE, ONE, uint(1000000003611745306950786402), 99.8619*10**25);\n        // risk group: 38 - APR: 11.62%\n        file(\"riskGroup\", 38, ONE, ONE, uint(1000000003684677828513444951), 99.8586*10**25);\n        // risk group: 39 - APR: 11.84%\n        file(\"riskGroup\", 39, ONE, ONE, uint(1000000003754439370877727042), 99.8553*10**25);\n        // risk group: 40 - APR: 12.06% \n        file(\"riskGroup\", 40, ONE, ONE, uint(1000000003824200913242009132), 99.8521*10**25);\n                \n        /// Overdue loans (= loans that were not repaid by the maturityDate) are moved to write Offs\n        // write-off group: 0 - 0% write off, 7.50% interest\n        setWriteOff(0, WRITE_OFF_PHASE_A, uint(1000000002378234398782343987), ONE);\n        // write-off group: 1 - 10% write off, 7.50% interest\n        setWriteOff(1, WRITE_OFF_PHASE_B, uint(1000000002378234398782343987), 90*10**25);\n        // write-off group: 2 - 25% write off\n        setWriteOff(2, WRITE_OFF_PHASE_C, uint(1000000000000000000000000000), 75*10**25);\n        // write-off group: 3 - 50% write off\n        setWriteOff(3, WRITE_OFF_PHASE_D, uint(1000000000000000000000000000), 50*10**25);\n        // write-off group: 4 - 100% write off\n        setWriteOff(4, WRITE_OFF_PHASE_E, uint(1000000000000000000000000000), 0);\n\n\n    }\n\n    function file(bytes32 name, uint risk_, uint thresholdRatio_, uint ceilingRatio_, uint rate_, uint recoveryRatePD_) public auth  {\n        if(name == \"riskGroup\") {\n            file(\"riskGroupNFT\", risk_, thresholdRatio_, ceilingRatio_, rate_);\n            recoveryRatePD[risk_] = Fixed27(recoveryRatePD_);\n\n        } else {revert (\"unknown name\");}\n    }\n\n    function setWriteOff(uint phase_, uint group_, uint rate_, uint writeOffPercentage_) internal {\n        writeOffs[phase_] = WriteOff(group_, Fixed27(writeOffPercentage_));\n        pile.file(\"rate\", group_, rate_);\n    }\n\n    function uniqueDayTimestamp(uint timestamp) public pure returns (uint) {\n        return (1 days) * (timestamp/(1 days));\n    }\n\n    /// maturityDate is a unix timestamp\n    function file(bytes32 name, bytes32 nftID_, uint maturityDate_) public auth {\n        // maturity date only can be changed when there is no debt on the collateral -> futureValue == 0\n        if (name == \"maturityDate\") {\n            require((futureValue[nftID_] == 0), \"can-not-change-maturityDate-outstanding-debt\");\n            maturityDate[nftID_] = uniqueDayTimestamp(maturityDate_);\n        } else { revert(\"unknown config parameter\");}\n    }\n\n    function file(bytes32 name, uint value) public auth {\n        if (name == \"discountRate\") {\n            discountRate = Fixed27(value);\n        } else { revert(\"unknown config parameter\");}\n    }\n\n    // In case of successful borrow the approximatedNAV is increased by the borrowed amount\n    function borrow(uint loan, uint amount) external auth returns(uint navIncrease) {\n        navIncrease = _borrow(loan, amount);\n        approximatedNAV = safeAdd(approximatedNAV, navIncrease);\n        return navIncrease;\n    }\n\n    // On borrow: the discounted future value of the asset is computed based on the loan amount and addeed to the bucket with the according maturity Date\n    function _borrow(uint loan, uint amount) internal returns(uint navIncrease) {\n        // ceiling check uses existing loan debt\n        require(ceiling(loan) >= safeAdd(borrowed[loan], amount), \"borrow-amount-too-high\");\n\n        bytes32 nftID_ = nftID(loan);\n        uint maturityDate_ = maturityDate[nftID_];\n        // maturity date has to be a value in the future\n        require(maturityDate_ > block.timestamp, \"maturity-date-is-not-in-the-future\");\n\n        // calculate amount including fixed fee if applicatable\n        (, , , , uint fixedRate) = pile.rates(pile.loanRates(loan));\n        uint amountIncludingFixed =  safeAdd(amount, rmul(amount, fixedRate));\n        // calculate future value FV\n        uint fv = calcFutureValue(loan, amountIncludingFixed, maturityDate_, recoveryRatePD[risk[nftID_]].value);\n        futureValue[nftID_] = safeAdd(futureValue[nftID_], fv);\n\n        // add future value to the bucket of assets with the same maturity date\n        if (buckets[maturityDate_].value == 0) {\n            addBucket(maturityDate_, fv);\n        } else {\n            buckets[maturityDate_].value = safeAdd(buckets[maturityDate_].value, fv);\n        }\n\n        // increase borrowed amount for future ceiling computations\n        borrowed[loan] = safeAdd(borrowed[loan], amount);\n\n        // return increase NAV amount\n        return calcDiscount(fv, uniqueDayTimestamp(block.timestamp), maturityDate_);\n    }\n\n    // calculate the future value based on the amount, maturityDate interestRate and recoveryRate\n    function calcFutureValue(uint loan, uint amount, uint maturityDate_, uint recoveryRatePD_) public returns(uint) {\n        // retrieve interest rate from the pile\n        (, ,uint loanInterestRate, ,) = pile.rates(pile.loanRates(loan));\n        return rmul(rmul(rpow(loanInterestRate, safeSub(maturityDate_, uniqueDayTimestamp(now)), ONE), amount), recoveryRatePD_);\n    }\n\n    /// update the nft value and change the risk group\n    function update(bytes32 nftID_, uint value, uint risk_) public auth {\n        nftValues[nftID_] = value;\n\n        // no change in risk group\n        if (risk_ == risk[nftID_]) {\n            return;\n        }\n\n        // nfts can only be added to risk groups that are part of the score card\n        require(thresholdRatio[risk_] != 0, \"risk group not defined in contract\");\n        risk[nftID_] = risk_;\n\n        // no currencyAmount borrowed yet\n        if (futureValue[nftID_] == 0) {\n            return;\n        }\n\n        uint loan = shelf.nftlookup(nftID_);\n        uint maturityDate_ = maturityDate[nftID_];\n\n        // Changing the risk group of an nft, might lead to a new interest rate for the dependant loan.\n        // New interest rate leads to a future value.\n        // recalculation required\n        buckets[maturityDate_].value = safeSub(buckets[maturityDate_].value, futureValue[nftID_]);\n\n        futureValue[nftID_] = calcFutureValue(loan, pile.debt(loan), maturityDate[nftID_], recoveryRatePD[risk[nftID_]].value);\n        buckets[maturityDate_].value = safeAdd(buckets[maturityDate_].value, futureValue[nftID_]);\n    }\n\n    // In case of successful repayment the approximatedNAV is decreased by the repaid amount\n    function repay(uint loan, uint amount) external auth returns (uint navDecrease) {\n        navDecrease = _repay(loan, amount);\n        if (navDecrease > approximatedNAV) {\n            approximatedNAV = 0;\n        }\n\n        if(navDecrease < approximatedNAV) {\n            approximatedNAV = safeSub(approximatedNAV, navDecrease);\n            return navDecrease;\n        }\n\n        approximatedNAV = 0;\n        return navDecrease;\n    }\n\n    // On repayment: adjust future value bucket according to repayment amount\n    function _repay(uint loan, uint amount) internal returns (uint navDecrease) {\n        bytes32 nftID_ = nftID(loan);\n        uint maturityDate_ = maturityDate[nftID_];\n\n\n        // no fv decrease calculation needed if maturity date is in the past\n        if (maturityDate_ < uniqueDayTimestamp(block.timestamp)) {\n            // if a loan is overdue, the portfolio value is initially equal to the existing debt\n            // it will be reduced by a write off factor once it is moved to a write off group\n            return amount;\n        }\n\n        // remove future value for loan from bucket\n        buckets[maturityDate_].value = safeSub(buckets[maturityDate_].value, futureValue[nftID_]);\n\n        uint debt = pile.debt(loan);\n        debt = safeSub(debt, amount);\n\n        uint fv = 0;\n        uint preFutureValue = futureValue[nftID_];\n\n        // in case of partial repayment, compute the fv of the remaining debt and add to the according fv bucket\n        if (debt != 0) {\n            fv = calcFutureValue(loan, debt, maturityDate_, recoveryRatePD[risk[nftID_]].value);\n            buckets[maturityDate_].value = safeAdd(buckets[maturityDate_].value, fv);\n        }\n\n        futureValue[nftID_] = fv;\n\n        // remove buckets if no remaining assets\n        if (buckets[maturityDate_].value == 0 && firstBucket != 0) {\n            removeBucket(maturityDate_);\n        }\n\n        // return decrease NAV amount\n        return calcDiscount(safeSub(preFutureValue, fv), uniqueDayTimestamp(block.timestamp), maturityDate_);\n    }\n\n    function calcDiscount(uint amount, uint normalizedBlockTimestamp, uint maturityDate_) public view returns (uint result) {\n        return rdiv(amount, rpow(discountRate.value, safeSub(maturityDate_, normalizedBlockTimestamp), ONE));\n    }\n\n\n    /// calculates the total discount of all buckets with a timestamp > block.timestamp\n    function calcTotalDiscount() public view returns(uint) {\n        uint normalizedBlockTimestamp = uniqueDayTimestamp(block.timestamp);\n        uint sum = 0;\n\n        uint currDate = normalizedBlockTimestamp;\n\n        if (currDate > lastBucket) {\n            return 0;\n        }\n\n        // only buckets after the block.timestamp are relevant for the discount\n        // assuming its more gas efficient to iterate over time to find the first one instead of iterating the list from the beginning\n        // not true if buckets are only sparsely populated over long periods of time\n        while(buckets[currDate].next == 0) { currDate = currDate + 1 days; }\n\n        while(currDate != NullDate)\n        {\n            sum = safeAdd(sum, calcDiscount(buckets[currDate].value, normalizedBlockTimestamp, currDate));\n            currDate = buckets[currDate].next;\n        }\n        return sum;\n    }\n\n    /// returns the NAV (net asset value) of the pool\n    function currentNAV() public view returns(uint) {\n        // calculates the NAV for ongoing loans with a maturityDate date in the future\n        uint nav_ = calcTotalDiscount();\n        // include ovedue assets to the current NAV calculation\n        for (uint i = 0; i < writeOffs.length; i++) {\n            // multiply writeOffGroupDebt with the writeOff rate\n            nav_ = safeAdd(nav_, rmul(pile.rateDebt(writeOffs[i].rateGroup), writeOffs[i].percentage.value));\n        }\n        return nav_;\n    }\n\n    function calcUpdateNAV() public returns(uint) {\n        // approximated NAV is updated and at this point in time 100% correct\n        approximatedNAV = currentNAV();\n        return approximatedNAV;\n    }\n\n    /// workaround for transition phase between V2 & V3\n    function totalValue() public view returns(uint) {\n        return currentNAV();\n    }\n\n    function dateBucket(uint timestamp) public view returns (uint) {\n        return buckets[timestamp].value;\n    }\n}\n"}}}