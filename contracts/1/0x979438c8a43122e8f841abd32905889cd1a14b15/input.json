{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {
      "DMGYieldFarmingV2.sol": {
        "DMGYieldFarmingV2Lib": "0x801a0e49b2c0828d73c1a5273b46c89fda91d7fe"
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "DMGYieldFarmingV2.sol": {
      "content": "// File: @openzeppelin/upgrades/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/external/uniswap/interfaces/IUniswapV2Pair.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(\r\n        address indexed sender,\r\n        uint amount0,\r\n        uint amount1\r\n    );\r\n\r\n    event Burn(\r\n        address indexed sender,\r\n        uint amount0,\r\n        uint amount1,\r\n        address indexed to\r\n    );\r\n\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n\r\n    function price1CumulativeLast() external view returns (uint);\r\n\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n\r\n}\r\n\r\n// File: contracts/governance/dmg/IDMGToken.sol\r\n\r\n/*\r\n * Copyright 2020 DMM Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\npragma solidity ^0.5.13;\r\n\r\ninterface IDMGToken {\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint64 fromBlock;\r\n        uint128 votes;\r\n    }\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint128);\r\n\r\n    function delegates(address delegator) external view returns (address);\r\n\r\n    function burn(uint amount) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/utils/IERC20WithDecimals.sol\r\n\r\n/*\r\n * Copyright 2020 DMM Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface IERC20WithDecimals {\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n}\r\n\r\n// File: contracts/external/uniswap/interfaces/IUniswapV2Router01.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ncontract IUniswapV2Router01 {\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(\r\n        uint amountA,\r\n        uint reserveA,\r\n        uint reserveB\r\n    ) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(\r\n        uint amountIn,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(\r\n        uint amountOut,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[]\r\n        calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint amountOut,\r\n        address[]\r\n        calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n}\r\n\r\n// File: contracts/external/uniswap/interfaces/IUniswapV2Router02.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\n\r\ncontract IUniswapV2Router02 is IUniswapV2Router01 {\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n// File: contracts/external/uniswap/libs/UniswapV2Library.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\nlibrary UniswapV2Library {\r\n\r\n    using SafeMath for uint;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB,\r\n        bytes32 initCodeHash\r\n    ) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                initCodeHash\r\n            ))));\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB,\r\n        bytes32 initCodeHash\r\n    ) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB, initCodeHash)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(\r\n        uint amountA,\r\n        uint reserveA,\r\n        uint reserveB\r\n    ) internal pure returns (uint amountB) {\r\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(\r\n        uint amountIn,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(\r\n        uint amountOut,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(\r\n        address factory,\r\n        uint amountIn,\r\n        address[] memory path,\r\n        bytes32 initCodeHash\r\n    ) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1], initCodeHash);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(\r\n        address factory,\r\n        uint amountOut,\r\n        address[] memory path,\r\n        bytes32 initCodeHash\r\n    ) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i], initCodeHash);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/protocol/interfaces/InterestRateInterface.sol\r\n\r\n/*\r\n * Copyright 2020 DMM Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface InterestRateInterface {\r\n\r\n    /**\r\n      * @dev Returns the current interest rate for the given DMMA and corresponding total supply & active supply\r\n      *\r\n      * @param dmmTokenId The DMMA whose interest should be retrieved\r\n      * @param totalSupply The total supply fot he DMM token\r\n      * @param activeSupply The supply that's currently being lent by users\r\n      * @return The interest rate in APY, which is a number with 18 decimals\r\n      */\r\n    function getInterestRate(uint dmmTokenId, uint totalSupply, uint activeSupply) external view returns (uint);\r\n\r\n}\r\n\r\n// File: contracts/protocol/interfaces/IUnderlyingTokenValuator.sol\r\n\r\n/*\r\n * Copyright 2020 DMM Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface IUnderlyingTokenValuator {\r\n\r\n    /**\r\n      * @dev Gets the tokens value in terms of USD.\r\n      *\r\n      * @return The value of the `amount` of `token`, as a number with the same number of decimals as `amount` passed\r\n      *         in to this function.\r\n      */\r\n    function getTokenValue(address token, uint amount) external view returns (uint);\r\n\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/Blacklistable.sol\r\n\r\n/*\r\n * Copyright 2020 DMM Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Allows accounts to be blacklisted by the owner of the contract.\r\n *\r\n *  Taken from USDC's contract for blacklisting certain addresses from owning and interacting with the token.\r\n */\r\ncontract Blacklistable is Ownable {\r\n\r\n    string public constant BLACKLISTED = \"BLACKLISTED\";\r\n\r\n    mapping(address => bool) internal blacklisted;\r\n\r\n    event Blacklisted(address indexed account);\r\n    event UnBlacklisted(address indexed account);\r\n    event BlacklisterChanged(address indexed newBlacklister);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the creator of this contract\r\n    */\r\n    modifier onlyBlacklister() {\r\n        require(msg.sender == owner(), \"MUST_BE_BLACKLISTER\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if `account` is blacklisted\r\n     *\r\n     * @param account The address to check\r\n    */\r\n    modifier notBlacklisted(address account) {\r\n        require(blacklisted[account] == false, BLACKLISTED);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if `account` is blacklisted. Reverts with `BLACKLISTED` if blacklisted.\r\n    */\r\n    function checkNotBlacklisted(address account) public view {\r\n        require(!blacklisted[account], BLACKLISTED);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if `account` is blacklisted\r\n     *\r\n     * @param account The address to check\r\n    */\r\n    function isBlacklisted(address account) public view returns (bool) {\r\n        return blacklisted[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Adds `account` to blacklist\r\n     *\r\n     * @param account The address to blacklist\r\n    */\r\n    function blacklist(address account) public onlyBlacklister {\r\n        blacklisted[account] = true;\r\n        emit Blacklisted(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes account from blacklist\r\n     *\r\n     * @param account The address to remove from the blacklist\r\n    */\r\n    function unBlacklist(address account) public onlyBlacklister {\r\n        blacklisted[account] = false;\r\n        emit UnBlacklisted(account);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/protocol/interfaces/IDmmController.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\ninterface IDmmController {\r\n\r\n    event TotalSupplyIncreased(uint oldTotalSupply, uint newTotalSupply);\r\n    event TotalSupplyDecreased(uint oldTotalSupply, uint newTotalSupply);\r\n\r\n    event AdminDeposit(address indexed sender, uint amount);\r\n    event AdminWithdraw(address indexed receiver, uint amount);\r\n\r\n    /**\r\n     * @dev Creates a new mToken using the provided data.\r\n     *\r\n     * @param underlyingToken   The token that should be wrapped to create a new DMMA\r\n     * @param symbol            The symbol of the new DMMA, IE mDAI or mUSDC\r\n     * @param name              The name of this token, IE `DMM: DAI`\r\n     * @param decimals          The number of decimals of the underlying token, and therefore the number for this DMMA\r\n     * @param minMintAmount     The minimum amount that can be minted for any given transaction.\r\n     * @param minRedeemAmount   The minimum amount that can be redeemed any given transaction.\r\n     * @param totalSupply       The initial total supply for this market.\r\n     */\r\n    function addMarket(\r\n        address underlyingToken,\r\n        string calldata symbol,\r\n        string calldata name,\r\n        uint8 decimals,\r\n        uint minMintAmount,\r\n        uint minRedeemAmount,\r\n        uint totalSupply\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Creates a new mToken using the already-existing token.\r\n     *\r\n     * @param dmmToken          The token that should be added to this controller.\r\n     * @param underlyingToken   The token that should be wrapped to create a new DMMA.\r\n     */\r\n    function addMarketFromExistingDmmToken(\r\n        address dmmToken,\r\n        address underlyingToken\r\n    ) external;\r\n\r\n    /**\r\n     * @param newController The new controller who should receive ownership of the provided DMM token IDs.\r\n     */\r\n    function transferOwnershipToNewController(\r\n        address newController\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Enables the corresponding DMMA to allow minting new tokens.\r\n     *\r\n     * @param dmmTokenId  The DMMA that should be enabled.\r\n     */\r\n    function enableMarket(uint dmmTokenId) external;\r\n\r\n    /**\r\n     * @dev Disables the corresponding DMMA from minting new tokens. This allows the market to close over time, since\r\n     *      users are only able to redeem tokens.\r\n     *\r\n     * @param dmmTokenId  The DMMA that should be disabled.\r\n     */\r\n    function disableMarket(uint dmmTokenId) external;\r\n\r\n    /**\r\n     * @dev Sets the new address that will serve as the guardian for this controller.\r\n     *\r\n     * @param newGuardian   The new address that will serve as the guardian for this controller.\r\n     */\r\n    function setGuardian(address newGuardian) external;\r\n\r\n    /**\r\n     * @dev Sets a new contract that implements the `DmmTokenFactory` interface.\r\n     *\r\n     * @param newDmmTokenFactory  The new contract that implements the `DmmTokenFactory` interface.\r\n     */\r\n    function setDmmTokenFactory(address newDmmTokenFactory) external;\r\n\r\n    /**\r\n     * @dev Sets a new contract that implements the `DmmEtherFactory` interface.\r\n     *\r\n     * @param newDmmEtherFactory  The new contract that implements the `DmmEtherFactory` interface.\r\n     */\r\n    function setDmmEtherFactory(address newDmmEtherFactory) external;\r\n\r\n    /**\r\n     * @dev Sets a new contract that implements the `InterestRate` interface.\r\n     *\r\n     * @param newInterestRateInterface  The new contract that implements the `InterestRateInterface` interface.\r\n     */\r\n    function setInterestRateInterface(address newInterestRateInterface) external;\r\n\r\n    /**\r\n     * @dev Sets a new contract that implements the `IOffChainAssetValuator` interface.\r\n     *\r\n     * @param newOffChainAssetValuator The new contract that implements the `IOffChainAssetValuator` interface.\r\n     */\r\n    function setOffChainAssetValuator(address newOffChainAssetValuator) external;\r\n\r\n    /**\r\n     * @dev Sets a new contract that implements the `IOffChainAssetValuator` interface.\r\n     *\r\n     * @param newOffChainCurrencyValuator The new contract that implements the `IOffChainAssetValuator` interface.\r\n     */\r\n    function setOffChainCurrencyValuator(address newOffChainCurrencyValuator) external;\r\n\r\n    /**\r\n     * @dev Sets a new contract that implements the `UnderlyingTokenValuator` interface\r\n     *\r\n     * @param newUnderlyingTokenValuator The new contract that implements the `UnderlyingTokenValuator` interface\r\n     */\r\n    function setUnderlyingTokenValuator(address newUnderlyingTokenValuator) external;\r\n\r\n    /**\r\n     * @dev Allows the owners of the DMM Ecosystem to withdraw funds from a DMMA. These withdrawn funds are then\r\n     *      allocated to real-world assets that will be used to pay interest into the DMMA.\r\n     *\r\n     * @param newMinCollateralization   The new min collateralization (with 18 decimals) at which the DMME must be in\r\n     *                                  order to add to the total supply of DMM.\r\n     */\r\n    function setMinCollateralization(uint newMinCollateralization) external;\r\n\r\n    /**\r\n     * @dev Allows the owners of the DMM Ecosystem to withdraw funds from a DMMA. These withdrawn funds are then\r\n     *      allocated to real-world assets that will be used to pay interest into the DMMA.\r\n     *\r\n     * @param newMinReserveRatio   The new ratio (with 18 decimals) that is used to enforce a certain percentage of assets\r\n     *                          are kept in each DMMA.\r\n     */\r\n    function setMinReserveRatio(uint newMinReserveRatio) external;\r\n\r\n    /**\r\n     * @dev Increases the max supply for the provided `dmmTokenId` by `amount`. This call reverts with\r\n     *      INSUFFICIENT_COLLATERAL if there isn't enough collateral in the Chainlink contract to cover the controller's\r\n     *      requirements for minimum collateral.\r\n     */\r\n    function increaseTotalSupply(uint dmmTokenId, uint amount) external;\r\n\r\n    /**\r\n     * @dev Increases the max supply for the provided `dmmTokenId` by `amount`.\r\n     */\r\n    function decreaseTotalSupply(uint dmmTokenId, uint amount) external;\r\n\r\n    /**\r\n     * @dev Allows the owners of the DMM Ecosystem to withdraw funds from a DMMA. These withdrawn funds are then\r\n     *      allocated to real-world assets that will be used to pay interest into the DMMA.\r\n     *\r\n     * @param dmmTokenId        The ID of the DMM token whose underlying will be funded.\r\n     * @param underlyingAmount  The amount underlying the DMM token that will be deposited into the DMMA.\r\n     */\r\n    function adminWithdrawFunds(uint dmmTokenId, uint underlyingAmount) external;\r\n\r\n    /**\r\n     * @dev Allows the owners of the DMM Ecosystem to deposit funds into a DMMA. These funds are used to disburse\r\n     *      interest payments and add more liquidity to the specific market.\r\n     *\r\n     * @param dmmTokenId        The ID of the DMM token whose underlying will be funded.\r\n     * @param underlyingAmount  The amount underlying the DMM token that will be deposited into the DMMA.\r\n     */\r\n    function adminDepositFunds(uint dmmTokenId, uint underlyingAmount) external;\r\n\r\n    /**\r\n     * @return  All of the DMM token IDs that are currently in the ecosystem. NOTE: this is an unfiltered list.\r\n     */\r\n    function getDmmTokenIds() external view returns (uint[] memory);\r\n\r\n    /**\r\n     * @dev Gets the collateralization of the system assuming 1-year's worth of interest payments are due by dividing\r\n     *      the total value of all the collateralized assets plus the value of the underlying tokens in each DMMA by the\r\n     *      aggregate interest owed (plus the principal), assuming each DMMA was at maximum usage.\r\n     *\r\n     * @return  The 1-year collateralization of the system, as a number with 18 decimals. For example\r\n     *          `1010000000000000000` is 101% or 1.01.\r\n     */\r\n    function getTotalCollateralization() external view returns (uint);\r\n\r\n    /**\r\n     * @dev Gets the current collateralization of the system assuming by dividing the total value of all the\r\n     *      collateralized assets plus the value of the underlying tokens in each DMMA by the aggregate interest owed\r\n     *      (plus the principal), using the current usage of each DMMA.\r\n     *\r\n     * @return  The active collateralization of the system, as a number with 18 decimals. For example\r\n     *          `1010000000000000000` is 101% or 1.01.\r\n     */\r\n    function getActiveCollateralization() external view returns (uint);\r\n\r\n    /**\r\n     * @dev Gets the interest rate from the underlying token, IE DAI or USDC.\r\n     *\r\n     * @return  The current interest rate, represented using 18 decimals. Meaning `65000000000000000` is 6.5% APY or\r\n     *          0.065.\r\n     */\r\n    function getInterestRateByUnderlyingTokenAddress(address underlyingToken) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Gets the interest rate from the DMM token, IE DMM: DAI or DMM: USDC.\r\n     *\r\n     * @return  The current interest rate, represented using 18 decimals. Meaning, `65000000000000000` is 6.5% APY or\r\n     *          0.065.\r\n     */\r\n    function getInterestRateByDmmTokenId(uint dmmTokenId) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Gets the interest rate from the DMM token, IE DMM: DAI or DMM: USDC.\r\n     *\r\n     * @return  The current interest rate, represented using 18 decimals. Meaning, `65000000000000000` is 6.5% APY or\r\n     *          0.065.\r\n     */\r\n    function getInterestRateByDmmTokenAddress(address dmmToken) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Gets the exchange rate from the underlying to the DMM token, such that\r\n     *      `DMM: Token = underlying / exchangeRate`\r\n     *\r\n     * @return  The current exchange rate, represented using 18 decimals. Meaning, `200000000000000000` is 0.2.\r\n     */\r\n    function getExchangeRateByUnderlying(address underlyingToken) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Gets the exchange rate from the underlying to the DMM token, such that\r\n     *      `DMM: Token = underlying / exchangeRate`\r\n     *\r\n     * @return  The current exchange rate, represented using 18 decimals. Meaning, `200000000000000000` is 0.2.\r\n     */\r\n    function getExchangeRate(address dmmToken) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Gets the DMM token for the provided underlying token. For example, sending DAI returns DMM: DAI.\r\n     */\r\n    function getDmmTokenForUnderlying(address underlyingToken) external view returns (address);\r\n\r\n    /**\r\n     * @dev Gets the underlying token for the provided DMM token. For example, sending DMM: DAI returns DAI.\r\n     */\r\n    function getUnderlyingTokenForDmm(address dmmToken) external view returns (address);\r\n\r\n    /**\r\n     * @return True if the market is enabled for this DMMA or false if it is not enabled.\r\n     */\r\n    function isMarketEnabledByDmmTokenId(uint dmmTokenId) external view returns (bool);\r\n\r\n    /**\r\n     * @return True if the market is enabled for this DMM token (IE DMM: DAI) or false if it is not enabled.\r\n     */\r\n    function isMarketEnabledByDmmTokenAddress(address dmmToken) external view returns (bool);\r\n\r\n    /**\r\n     * @return True if the market is enabled for this underlying token (IE DAI) or false if it is not enabled.\r\n     */\r\n    function getTokenIdFromDmmTokenAddress(address dmmTokenAddress) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Gets the DMM token contract address for the provided DMM token ID. For example, `1` returns the mToken\r\n     *      contract address for that token ID.\r\n     */\r\n    function getDmmTokenAddressByDmmTokenId(uint dmmTokenId) external view returns (address);\r\n\r\n    function blacklistable() external view returns (Blacklistable);\r\n\r\n    function underlyingTokenValuator() external view returns (IUnderlyingTokenValuator);\r\n\r\n}\r\n\r\n// File: contracts/external/farming/DMGYieldFarmingData.sol\r\n\r\n/*\r\n * Copyright 2020 DMM Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n//import \"./v2/DMGYieldFarmingV2Lib.sol\";\r\n\r\ncontract DMGYieldFarmingData is Initializable {\r\n\r\n    // /////////////////////////\r\n    // BEGIN V1 State Variables\r\n    // /////////////////////////\r\n\r\n    // counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n    address internal _owner;\r\n\r\n    address internal _dmgToken;\r\n    address internal _guardian;\r\n    address internal _dmmController;\r\n    address[] internal _supportedFarmTokens;\r\n    /// @notice How much DMG is earned every second of farming. This number is represented as a fraction with 18\r\n    //          decimal places, whereby 0.01 == 1000000000000000.\r\n    uint internal _dmgGrowthCoefficient;\r\n\r\n    bool internal _isFarmActive;\r\n    uint internal _seasonIndex;\r\n    mapping(address => uint16) internal _tokenToRewardPointMap;\r\n    mapping(address => mapping(address => bool)) internal _userToSpenderToIsApprovedMap;\r\n    mapping(uint => mapping(address => mapping(address => uint))) internal _seasonIndexToUserToTokenToEarnedDmgAmountMap;\r\n    mapping(uint => mapping(address => mapping(address => uint64))) internal _seasonIndexToUserToTokenToDepositTimestampMap;\r\n    mapping(address => address) internal _tokenToUnderlyingTokenMap;\r\n    mapping(address => uint8) internal _tokenToDecimalsMap;\r\n    mapping(address => uint) internal _tokenToIndexPlusOneMap;\r\n    mapping(address => mapping(address => uint)) internal _addressToTokenToBalanceMap;\r\n    mapping(address => bool) internal _globalProxyToIsTrustedMap;\r\n\r\n    // /////////////////////////\r\n    // BEGIN V2 State Variables\r\n    // /////////////////////////\r\n\r\n    address internal _underlyingTokenValuator;\r\n    address internal _uniswapV2Router;\r\n    address internal _weth;\r\n    mapping(address => DMGYieldFarmingV2Lib.TokenType) internal _tokenToTokenType;\r\n    mapping(address => uint16) internal _tokenToFeeAmountMap;\r\n    bool internal _isDmgBalanceInitialized;\r\n    mapping(uint => uint64) internal _seasonIndexToStartTimestamp;\r\n\r\n    // /////////////////////////\r\n    // END State Variables\r\n    // /////////////////////////\r\n\r\n    // /////////////////////////\r\n    // Events\r\n    // /////////////////////////\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // /////////////////////////\r\n    // Functions\r\n    // /////////////////////////\r\n\r\n    function initialize(address owner) public initializer {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n\r\n        _owner = owner;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"DMGYieldFarmingData::transferOwnership: INVALID_OWNER\");\r\n\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    // /////////////////////////\r\n    // Modifiers\r\n    // /////////////////////////\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"DMGYieldFarmingData: NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"DMGYieldFarmingData: REENTRANCY\");\r\n    }\r\n\r\n    // /////////////////////////\r\n    // Constants\r\n    // /////////////////////////\r\n\r\n    uint8 public constant POINTS_DECIMALS = 2;\r\n\r\n    uint16 public constant POINTS_FACTOR = uint16(10 ** uint(POINTS_DECIMALS));\r\n\r\n    uint8 public constant DMG_GROWTH_COEFFICIENT_DECIMALS = 18;\r\n\r\n    uint public constant DMG_GROWTH_COEFFICIENT_FACTOR = 10 ** uint(DMG_GROWTH_COEFFICIENT_DECIMALS);\r\n\r\n    uint8 public constant USD_VALUE_DECIMALS = 18;\r\n\r\n    uint public constant USD_VALUE_FACTOR = 10 ** uint(USD_VALUE_DECIMALS);\r\n\r\n    uint8 public constant FEE_AMOUNT_DECIMALS = 4;\r\n\r\n    uint16 public constant FEE_AMOUNT_FACTOR = uint16(10 ** uint(FEE_AMOUNT_DECIMALS));\r\n\r\n}\r\n\r\n// File: contracts/external/farming/v2/DMGYieldFarmingV2Lib.sol\r\n\r\n/*\r\n * Copyright 2020 DMM Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//import \"./IDMGYieldFarmingV2.sol\";\r\n\r\nlibrary DMGYieldFarmingV2Lib {\r\n\r\n    using SafeMath for uint;\r\n    using SafeERC20 for IERC20;\r\n    using UniswapV2Library for *;\r\n\r\n    // ////////////////////\r\n    // Enums\r\n    // ////////////////////\r\n\r\n    enum TokenType {\r\n        Unknown,\r\n        UniswapLpToken,\r\n        UniswapPureLpToken // Does not have an mToken base pairing. IE DMG-ETH\r\n    }\r\n\r\n    // ////////////////////\r\n    // Events\r\n    // ////////////////////\r\n\r\n    /**\r\n     * @param tokenAmountToConvert  The amount of `token` to be converted to DMG and burned.\r\n     * @param dmgAmountBurned       The amount of DMG burned after `tokenAmountToConvert` was converted to DMG.\r\n     */\r\n    event HarvestFeePaid(address indexed owner, address indexed token, uint tokenAmountToConvert, uint dmgAmountBurned);\r\n\r\n    // ////////////////////\r\n    // Functions\r\n    // ////////////////////\r\n\r\n    /**\r\n     * @return  The dollar value of `tokenAmount`, formatted as a number with 18 decimal places\r\n     */\r\n    function _getUsdValueByTokenAndTokenAmount(\r\n        IDMGYieldFarmingV2 state,\r\n        address __farmToken,\r\n        uint __tokenAmount\r\n    ) public view returns (uint) {\r\n        address underlyingToken = state.getUnderlyingTokenByFarmToken(__farmToken);\r\n        address __underlyingTokenValuator = state.underlyingTokenValuator();\r\n        DMGYieldFarmingV2Lib.TokenType tokenType = state.getTokenTypeByToken(__farmToken);\r\n\r\n        if (tokenType == DMGYieldFarmingV2Lib.TokenType.UniswapLpToken) {\r\n            return _getUsdValueByTokenAndAmountForUniswapLpToken(\r\n                __farmToken,\r\n                __tokenAmount,\r\n                underlyingToken,\r\n                state.getTokenDecimalsByToken(__farmToken),\r\n                state.dmmController(),\r\n                __underlyingTokenValuator\r\n            );\r\n        } else if (tokenType == DMGYieldFarmingV2Lib.TokenType.UniswapPureLpToken) {\r\n            (address otherToken, uint underlyingTokenReserveAmount, uint otherTokenReserveAmount) = _getUniswapParams(__farmToken, underlyingToken);\r\n\r\n            uint totalSupply = IERC20(__farmToken).totalSupply();\r\n            require(\r\n                totalSupply > 0,\r\n                \"DMGYieldFarmingV2::_getUsdValueByTokenAndTokenAmount: INVALID_TOTAL_SUPPLY\"\r\n            );\r\n            uint8 underlyingTokenDecimals = state.getTokenDecimalsByToken(__farmToken);\r\n\r\n            uint underlyingTokenUsdValue = _getUnderlyingTokenUsdValueFromUniswapPool(\r\n                __tokenAmount,\r\n                totalSupply,\r\n                underlyingToken,\r\n                underlyingTokenReserveAmount,\r\n                underlyingTokenDecimals,\r\n                __underlyingTokenValuator\r\n            );\r\n\r\n            uint otherTokenUsdValue = _getUnderlyingTokenUsdValueFromUniswapPool(\r\n                __tokenAmount,\r\n                totalSupply,\r\n                otherToken,\r\n                otherTokenReserveAmount,\r\n                underlyingTokenDecimals,\r\n                __underlyingTokenValuator\r\n            );\r\n\r\n            return underlyingTokenUsdValue.add(otherTokenUsdValue);\r\n        } else {\r\n            revert(\"DMGYieldFarmingV2::_getUsdValueByTokenAndTokenAmount: INVALID_TOKEN_TYPE\");\r\n        }\r\n    }\r\n\r\n    function _getUsdValueByTokenAndAmountForUniswapLpToken(\r\n        address __farmToken,\r\n        uint __farmTokenAmount,\r\n        address __underlyingToken,\r\n        uint8 __underlyingTokenDecimals,\r\n        address __dmmController,\r\n        address __underlyingTokenValuator\r\n    ) internal view returns (uint) {\r\n        (address mToken, uint underlyingTokenAmount, uint mTokenAmount) = _getUniswapParams(__farmToken, __underlyingToken);\r\n\r\n        uint totalSupply = IERC20(__farmToken).totalSupply();\r\n        require(\r\n            totalSupply > 0,\r\n            \"DMGYieldFarmingV2::_getUsdValueByTokenAndTokenAmount: INVALID_TOTAL_SUPPLY\"\r\n        );\r\n\r\n        uint underlyingTokenUsdValue = _getUnderlyingTokenUsdValueFromUniswapPool(\r\n            __farmTokenAmount,\r\n            totalSupply,\r\n            __underlyingToken,\r\n            underlyingTokenAmount,\r\n            __underlyingTokenDecimals,\r\n            __underlyingTokenValuator\r\n        );\r\n\r\n        uint mTokenUsdValue = _getMTokenUsdValueFromUniswapPool(\r\n            __farmTokenAmount,\r\n            totalSupply,\r\n            mToken,\r\n            mTokenAmount,\r\n            __underlyingTokenDecimals,\r\n            __dmmController,\r\n            __underlyingTokenValuator\r\n        );\r\n\r\n        return underlyingTokenUsdValue.add(mTokenUsdValue);\r\n    }\r\n\r\n    function _getUniswapParams(\r\n        address __farmToken,\r\n        address __underlyingToken\r\n    ) public view returns (address otherToken, uint underlyingTokenAmount, uint otherTokenAmount) {\r\n        address token0 = IUniswapV2Pair(__farmToken).token0();\r\n        address token1 = IUniswapV2Pair(__farmToken).token1();\r\n\r\n        require(\r\n            __underlyingToken == token0 || __underlyingToken == token1,\r\n            \"DMGYieldFarmingV2Lib::_getUniswapParams: INVALID_UNDERLYING\"\r\n        );\r\n\r\n        otherToken = __underlyingToken == token0 ? token1 : token0;\r\n\r\n        (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(__farmToken).getReserves();\r\n        underlyingTokenAmount = __underlyingToken == token0 ? reserve0 : reserve1;\r\n        otherTokenAmount = __underlyingToken == token0 ? reserve1 : reserve0;\r\n    }\r\n\r\n    function _getUnderlyingTokenUsdValueFromUniswapPool(\r\n        uint __tokenAmount,\r\n        uint __totalSupply,\r\n        address __underlyingToken,\r\n        uint __underlyingTokenReserveAmount,\r\n        uint8 __underlyingTokenDecimals,\r\n        address __underlyingTokenValuator\r\n    ) public view returns (uint) {\r\n        uint underlyingTokenAmount = __tokenAmount\r\n        .mul(__underlyingTokenReserveAmount)\r\n        .div(__totalSupply);\r\n\r\n        return _getUsdValueForUnderlyingTokenAmount(\r\n            __underlyingToken,\r\n            __underlyingTokenValuator,\r\n            __underlyingTokenDecimals,\r\n            underlyingTokenAmount\r\n        );\r\n    }\r\n\r\n    function _getMTokenUsdValueFromUniswapPool(\r\n        uint __tokenAmount,\r\n        uint __totalSupply,\r\n        address __mToken,\r\n        uint __mTokenReserveAmount,\r\n        uint8 __mTokenDecimals,\r\n        address __dmmController,\r\n        address __underlyingTokenValuator\r\n    ) public view returns (uint) {\r\n        uint mTokenAmount = __tokenAmount\r\n        .mul(__mTokenReserveAmount)\r\n        .div(__totalSupply);\r\n\r\n        // The exchange rate always has 18 decimals.\r\n        return _getUsdValueForUnderlyingTokenAmount(\r\n            IDmmController(__dmmController).getUnderlyingTokenForDmm(__mToken),\r\n            __underlyingTokenValuator,\r\n            __mTokenDecimals,\r\n            mTokenAmount.mul(IDmmController(__dmmController).getExchangeRate(__mToken)).div(1e18)\r\n        );\r\n    }\r\n\r\n    function _getUsdValueForUnderlyingTokenAmount(\r\n        address __underlyingToken,\r\n        address __underlyingTokenValuator,\r\n        uint8 __decimals,\r\n        uint __amount\r\n    ) public view returns (uint) {\r\n        if (__decimals < 18) {\r\n            __amount = __amount.mul((10 ** (18 - uint(__decimals))));\r\n        } else if (__decimals > 18) {\r\n            __amount = __amount.div((10 ** (uint(__decimals) - 18)));\r\n        }\r\n        return IUnderlyingTokenValuator(__underlyingTokenValuator).getTokenValue(__underlyingToken, __amount);\r\n    }\r\n\r\n    /**\r\n     * @return The amount of `__token` paid for the burn.\r\n     */\r\n    function _payHarvestFee(\r\n        IDMGYieldFarmingV2 state,\r\n        address __user,\r\n        address __token,\r\n        uint __tokenAmount\r\n    ) public returns (uint) {\r\n        uint fees = state.getFeesByToken(__token);\r\n        if (fees > 0) {\r\n            uint tokenFeeAmount = __tokenAmount.mul(fees).div(uint(DMGYieldFarmingData(address(state)).FEE_AMOUNT_FACTOR()));\r\n            require(\r\n                tokenFeeAmount > 0,\r\n                \"DMGYieldFarmingV2Lib::_payHarvestFee: TOKEN_AMOUNT_TOO_SMALL_FOR_FEE\"\r\n            );\r\n\r\n            DMGYieldFarmingV2Lib.TokenType tokenType = state.getTokenTypeByToken(__token);\r\n            require(\r\n                tokenType != DMGYieldFarmingV2Lib.TokenType.Unknown,\r\n                \"DMGYieldFarmingV2Lib::_payHarvestFee: UNKNOWN_TOKEN_TYPE\"\r\n            );\r\n\r\n            if (tokenType == DMGYieldFarmingV2Lib.TokenType.UniswapLpToken ||\r\n                tokenType == DMGYieldFarmingV2Lib.TokenType.UniswapPureLpToken) {\r\n                _payFeesWithUniswapToken(\r\n                    state,\r\n                    __user,\r\n                    __token,\r\n                    tokenFeeAmount,\r\n                    state.getUnderlyingTokenByFarmToken(__token)\r\n                );\r\n            } else {\r\n                revert(\r\n                    \"DMGYieldFarmingV2Lib::_payHarvestFee UNCAUGHT_TOKEN_TYPE\"\r\n                );\r\n            }\r\n\r\n            return tokenFeeAmount;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function _payFeesWithUniswapToken(\r\n        IDMGYieldFarmingV2 state,\r\n        address __user,\r\n        address __uniswapToken,\r\n        uint __tokenFeeAmount,\r\n        address underlyingToken\r\n    ) public {\r\n\r\n        // This is the token that is NOT the underlyingToken. Meaning, it needs to be converted to underlyingToken so\r\n        // it can be added to underlyingToken amount, swapped (as underlyingToken) to DMG, and burned.\r\n        address tokenToSwap;\r\n        address token0;\r\n        uint amountToBurn;\r\n        uint amountToSwap;\r\n        {\r\n            // New context - to prevent the stack too deep error\r\n            // --------------------------------------------------\r\n            // This code is taken from the `UniswapV2Router02` to more efficiently convert the LP __token *TO* its\r\n            // reserve tokens\r\n            IERC20(__uniswapToken).safeTransfer(__uniswapToken, __tokenFeeAmount);\r\n            (uint amount0, uint amount1) = IUniswapV2Pair(__uniswapToken).burn(address(this));\r\n            token0 = IUniswapV2Pair(__uniswapToken).token0();\r\n\r\n            tokenToSwap = token0 == underlyingToken ? IUniswapV2Pair(__uniswapToken).token1() : token0;\r\n\r\n            amountToBurn = token0 == underlyingToken ? amount0 : amount1;\r\n            amountToSwap = token0 != underlyingToken ? amount0 : amount1;\r\n        }\r\n\r\n        address dmg = state.dmgToken();\r\n        if (tokenToSwap != dmg) {\r\n            // Exchanges `tokenToSwap` to `underlyingToken`, so `underlyingToken` can be swapped to DMG and burned.\r\n            // This code is taken from the `UniswapV2Router02` to more efficiently swap *TO* the underlying __token\r\n            IERC20(tokenToSwap).safeTransfer(__uniswapToken, amountToSwap);\r\n            (uint reserve0, uint reserve1,) = IUniswapV2Pair(__uniswapToken).getReserves();\r\n            uint amountOut = UniswapV2Library.getAmountOut(\r\n                amountToSwap,\r\n                tokenToSwap == token0 ? reserve0 : reserve1,\r\n                tokenToSwap != token0 ? reserve0 : reserve1\r\n            );\r\n\r\n            (uint amount0Out, uint amount1Out) = tokenToSwap == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            IUniswapV2Pair(__uniswapToken).swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n\r\n            amountToBurn = amountToBurn.add(amountOut);\r\n        }\r\n\r\n        uint dmgToBurn = _swapTokensForDmgViaUniswap(state, amountToBurn, underlyingToken, state.weth(), dmg);\r\n\r\n        if (tokenToSwap == dmg) {\r\n            // We can just add the DMG to be swapped with the amount to burn.\r\n            amountToSwap = amountToSwap.add(dmgToBurn);\r\n            IDMGToken(dmg).burn(amountToSwap);\r\n            emit HarvestFeePaid(__user, __uniswapToken, __tokenFeeAmount, amountToSwap);\r\n        } else {\r\n            IDMGToken(dmg).burn(dmgToBurn);\r\n            emit HarvestFeePaid(__user, __uniswapToken, __tokenFeeAmount, dmgToBurn);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return  The amount of DMG received from the swap\r\n     */\r\n    function _swapTokensForDmgViaUniswap(\r\n        IDMGYieldFarmingV2 state,\r\n        uint __amountToBurn,\r\n        address __underlyingToken,\r\n        address __weth,\r\n        address __dmg\r\n    ) public returns (uint) {\r\n        address[] memory paths;\r\n        if (__underlyingToken == __weth) {\r\n            paths = new address[](2);\r\n            paths[0] = __weth;\r\n            paths[1] = __dmg;\r\n        } else {\r\n            paths = new address[](3);\r\n            paths[0] = __underlyingToken;\r\n            paths[1] = __weth;\r\n            paths[2] = __dmg;\r\n        }\r\n        // We sell the underlyingToken to DMG and burn it.\r\n        uint[] memory amountsOut = IUniswapV2Router02(state.uniswapV2Router()).swapExactTokensForTokens(\r\n            __amountToBurn,\r\n        /* amountOutMin */ 1,\r\n            paths,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        return amountsOut[amountsOut.length - 1];\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/external/farming/v2/IDMGYieldFarmingV2.sol\r\n\r\n/*\r\n * Copyright 2020 DMM Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ninterface IDMGYieldFarmingV2 {\r\n\r\n    // ////////////////////\r\n    // Admin Events\r\n    // ////////////////////\r\n\r\n    event GlobalProxySet(address indexed proxy, bool isTrusted);\r\n\r\n    event TokenAdded(address indexed token, address indexed underlyingToken, uint8 underlyingTokenDecimals, uint16 points, uint16 fees);\r\n    event TokenRemoved(address indexed token);\r\n\r\n    event FarmSeasonBegun(uint indexed seasonIndex, uint dmgAmount);\r\n    event FarmSeasonExtended(uint indexed seasonIndex, uint dmgAmount);\r\n    event FarmSeasonEnd(uint indexed seasonIndex, address dustRecipient, uint dustyDmgAmount);\r\n\r\n    event DmgGrowthCoefficientSet(uint coefficient);\r\n    event RewardPointsSet(address indexed token, uint16 points);\r\n\r\n    event UnderlyingTokenValuatorChanged(address newUnderlyingTokenValutor, address oldUnderlyingTokenValutor);\r\n    event UniswapV2RouterChanged(address newUniswapV2Router, address oldUniswapV2Router);\r\n    event FeesChanged(address indexed token, uint16 feeAmount);\r\n    event TokenTypeChanged(address indexed token, DMGYieldFarmingV2Lib.TokenType tokenType);\r\n\r\n    // ////////////////////\r\n    // User Events\r\n    // ////////////////////\r\n\r\n    event Approval(address indexed user, address indexed spender, bool isTrusted);\r\n\r\n    event BeginFarming(address indexed owner, address indexed token, uint depositedAmount);\r\n    event EndFarming(address indexed owner, address indexed token, uint withdrawnAmount, uint earnedDmgAmount);\r\n\r\n    event WithdrawOutOfSeason(address indexed owner, address indexed token, address indexed recipient, uint amount);\r\n\r\n    event Harvest(address indexed owner, address indexed token, uint earnedDmgAmount);\r\n\r\n    /**\r\n     * @param tokenAmountToConvert  The amount of `token` to be converted to DMG and burned.\r\n     * @param dmgAmountBurned       The amount of DMG burned after `tokenAmountToConvert` was converted to DMG.\r\n     */\r\n    event HarvestFeePaid(address indexed owner, address indexed token, uint tokenAmountToConvert, uint dmgAmountBurned);\r\n\r\n    // ////////////////////\r\n    // Admin Functions\r\n    // ////////////////////\r\n\r\n    /**\r\n     * Sets the `proxy` as a trusted contract, allowing it to interact with the user, on the user's behalf.\r\n     *\r\n     * @param proxy     The address that can interact on the user's behalf.\r\n     * @param isTrusted True if the proxy is trusted or false if it's not (should be removed).\r\n     */\r\n    function approveGloballyTrustedProxy(\r\n        address proxy,\r\n        bool isTrusted\r\n    ) external;\r\n\r\n    /**\r\n     * @return  true if the provided `proxy` is globally trusted and may interact with the yield farming contract on a\r\n     *          user's behalf or false otherwise.\r\n     */\r\n    function isGloballyTrustedProxy(\r\n        address proxy\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @param token                     The address of the token to be supported for farming.\r\n     * @param underlyingToken           The token to which this token is pegged. IE a Uniswap-V2 LP equity token for\r\n     *                                  DAI-mDAI has an underlying token of DAI.\r\n     * @param underlyingTokenDecimals   The number of decimals that the `underlyingToken` has.\r\n     * @param points                    The amount of reward points for the provided token.\r\n     * @param fees                      The fees to be paid in `underlyingToken` when the user performs a harvest.\r\n     * @param tokenType                 The type of token that is being added. Used for unwrapping it and paying harvest\r\n      *                                 fees.\r\n     */\r\n    function addAllowableToken(\r\n        address token,\r\n        address underlyingToken,\r\n        uint8 underlyingTokenDecimals,\r\n        uint16 points,\r\n        uint16 fees,\r\n        DMGYieldFarmingV2Lib.TokenType tokenType\r\n    ) external;\r\n\r\n    /**\r\n     * @param token The address of the token that will be removed from farming.\r\n     */\r\n    function removeAllowableToken(\r\n        address token\r\n    ) external;\r\n\r\n    /**\r\n     * Changes the reward points for the provided tokens. Reward points are a weighting system that enables certain\r\n     * tokens to accrue DMG faster than others, allowing the protocol to prioritize certain deposits. At the start of\r\n     * season 1, mETH had points of 100 (equalling 1) and the stablecoins had 200, doubling their weight against mETH.\r\n     */\r\n    function setRewardPointsByTokens(\r\n        address[] calldata tokens,\r\n        uint16[] calldata points\r\n    ) external;\r\n\r\n    /**\r\n     * Sets the DMG growth coefficient to use the new parameter provided. This variable is used to define how much\r\n     * DMG is earned every second, for each dollar being farmed accrued.\r\n     */\r\n    function setDmgGrowthCoefficient(\r\n        uint dmgGrowthCoefficient\r\n    ) external;\r\n\r\n    /**\r\n     * Begins the farming process so users that accumulate DMG by locking tokens can start for this rotation. Calling\r\n     * this function increments the currentSeasonIndex, starting a new season. This function reverts if there is\r\n     * already an active season.\r\n     *\r\n     * @param dmgAmount The amount of DMG that will be used to fund this campaign.\r\n     */\r\n    function beginFarmingSeason(\r\n        uint dmgAmount\r\n    ) external;\r\n\r\n    /**\r\n     * Adds DMG to the already-existing farming season, if there is one. Else, this function reverts.\r\n     *\r\n     * @param dmgAmount The amount of DMG that will be added to the existing campaign.\r\n     */\r\n    function addToFarmingSeason(\r\n        uint dmgAmount\r\n    ) external;\r\n\r\n    /**\r\n     * Ends the active farming process if the admin calls this function. Otherwise, anyone may call this function once\r\n     * all DMG have been drained from the contract.\r\n     *\r\n     * @param dustRecipient The recipient of any leftover DMG in this contract, when the campaign finishes.\r\n     */\r\n    function endActiveFarmingSeason(\r\n        address dustRecipient\r\n    ) external;\r\n\r\n    function setUnderlyingTokenValuator(\r\n        address underlyingTokenValuator\r\n    ) external;\r\n\r\n    function setWethToken(\r\n        address weth\r\n    ) external;\r\n\r\n    function setUniswapV2Router(\r\n        address uniswapV2Router\r\n    ) external;\r\n\r\n    function setFeesByTokens(\r\n        address[] calldata tokens,\r\n        uint16[] calldata fees\r\n    ) external;\r\n\r\n    function setTokenTypeByToken(\r\n        address token,\r\n        DMGYieldFarmingV2Lib.TokenType tokenType\r\n    ) external;\r\n\r\n    /**\r\n     * Used to initialize the protocol, mid-season since the Protocol kept track of DMG balances differently on v1.\r\n     */\r\n    function initializeDmgBalance() external;\r\n\r\n    // ////////////////////\r\n    // User Functions\r\n    // ////////////////////\r\n\r\n    /**\r\n     * Approves the spender from `msg.sender` to transfer funds into the contract on the user's behalf. If `isTrusted`\r\n     * is marked as false, removes the spender.\r\n     */\r\n    function approve(address spender, bool isTrusted) external;\r\n\r\n    /**\r\n     * True if the `spender` can transfer tokens on the user's behalf to this contract.\r\n     */\r\n    function isApproved(\r\n        address user,\r\n        address spender\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * Begins a farm by transferring `amount` of `token` from `user` to this contract and adds it to the balance of\r\n     * `user`. `user` must be either 1) msg.sender or 2) a wallet who has approved msg.sender as a proxy; else this\r\n     * function reverts. `funder` must be either 1) msg.sender or `user`; else this function reverts.\r\n     */\r\n    function beginFarming(\r\n        address user,\r\n        address funder,\r\n        address token,\r\n        uint amount\r\n    ) external;\r\n\r\n    /**\r\n     * Ends a farm by transferring all of `token` deposited by `from` to `recipient`, from this contract, as well as\r\n     * all earned DMG for farming `token` to `recipient`. `from` must be either 1) msg.sender or 2) an approved\r\n     * proxy; else this function reverts.\r\n     *\r\n     * @return  The amount of `token` withdrawn and the amount of DMG earned for farming. Both values are sent to\r\n     *          `recipient`.\r\n     */\r\n    function endFarmingByToken(\r\n        address from,\r\n        address recipient,\r\n        address token\r\n    ) external returns (uint, uint);\r\n\r\n    /**\r\n     * Ends a farm by transferring `amount` of `token` deposited by `from` to `recipient`, from this contract, as well\r\n     * as a proportional amount of the earned DMG for farming `token` to `recipient`. `from` must be either\r\n     * 1) msg.sender or 2) an approved proxy; else this function reverts.\r\n     *\r\n     * @param from          The user that is ending the harvest\r\n     * @param recipient     The address that should receive the withdrawn token as well as the earned DMG.\r\n     * @param token         The token being withdrawn.\r\n     * @param amount        The balance of the user that should be withdrawn, along with a proportional amount of the\r\n     *                      harvest.\r\n     * @return              The amount of `token` withdrawn and the amount of DMG earned for farming. Both values are\r\n     *                      sent to `recipient`.\r\n     */\r\n    function endFarmingByTokenAndAmount(\r\n        address from,\r\n        address recipient,\r\n        address token,\r\n        uint amount\r\n    ) external returns (uint, uint);\r\n\r\n    /**\r\n     * Withdraws all of `msg.sender`'s tokens from the farm to `recipient`. This function reverts if there is an active\r\n     * farm. `user` must be either 1) msg.sender or 2) an approved proxy; else this function reverts.\r\n     *\r\n     * @return  Each token and the amount of each withdrawn.\r\n     */\r\n    function withdrawAllWhenOutOfSeason(\r\n        address user,\r\n        address recipient\r\n    ) external returns (address[] memory, uint[] memory);\r\n\r\n    /**\r\n     * Withdraws all of `user` `token` from the farm to `recipient`. This function reverts if there is an active farm and the token is NOT removed.\r\n     * `user` must be either 1) msg.sender or 2) an approved proxy; else this function reverts.\r\n     *\r\n     * @return The amount of tokens sent to `recipient`\r\n     */\r\n    function withdrawByTokenWhenOutOfSeason(\r\n        address user,\r\n        address recipient,\r\n        address token\r\n    ) external returns (uint);\r\n\r\n    /**\r\n     * @return  The amount of DMG that this owner has earned in the active farm. If there are no active season, this\r\n     *          function returns `0`.\r\n     */\r\n    function getRewardBalanceByOwner(\r\n        address owner\r\n    ) external view returns (uint);\r\n\r\n    /**\r\n     * @return  The amount of DMG that this owner has earned in the active farm for the provided token. If there is no\r\n     *          active season, this function returns `0`.\r\n     */\r\n    function getRewardBalanceByOwnerAndToken(\r\n        address owner,\r\n        address token\r\n    ) external view returns (uint);\r\n\r\n    /**\r\n     * @return  The amount of `token` that this owner has deposited into this contract. The user may withdraw this\r\n     *          non-zero balance by invoking `endFarming` or `endFarmingByToken` if there is an active farm. If there is\r\n     *          NO active farm, the user may withdraw his/her funds by invoking\r\n     */\r\n    function balanceOf(\r\n        address owner,\r\n        address token\r\n    ) external view returns (uint);\r\n\r\n    /**\r\n     * @return  The most recent timestamp at which the `owner` deposited `token` into the yield farming contract for\r\n     *          the current season. If there is no active season, this function returns `0`.\r\n     */\r\n    function getMostRecentDepositTimestampByOwnerAndToken(\r\n        address owner,\r\n        address token\r\n    ) external view returns (uint64);\r\n\r\n    /**\r\n     * @return  The most recent indexed amount of DMG earned by the `owner` for the deposited `token` which is being\r\n     *          farmed for the most-recent season. If there is no active season, this function returns `0`.\r\n     */\r\n    function getMostRecentIndexedDmgEarnedByOwnerAndToken(\r\n        address owner,\r\n        address token\r\n    ) external view returns (uint);\r\n\r\n    /**\r\n     * Harvests any earned DMG from the provided token for the given user and farmable token. User must be either\r\n     * 1) `msg.sender` or 2) an approved proxy for `user`. The DMG is sent to `recipient`.\r\n     */\r\n    function harvestDmgByUserAndToken(\r\n        address user,\r\n        address recipient,\r\n        address token\r\n    ) external returns (uint);\r\n\r\n    /**\r\n     * Harvests any earned DMG from the provided token for the given user and farmable token. User must be either\r\n     * 1) `msg.sender` or 2) an approved proxy for `user`. The DMG is sent to `recipient`.\r\n     */\r\n    function harvestDmgByUser(\r\n        address user,\r\n        address recipient\r\n    ) external returns (uint);\r\n\r\n    /**\r\n     * Gets the underlying token for the corresponding farmable token.\r\n     */\r\n    function getUnderlyingTokenByFarmToken(\r\n        address farmToken\r\n    ) external view returns (address);\r\n\r\n    // ////////////////////\r\n    // Misc Functions\r\n    // ////////////////////\r\n\r\n    /**\r\n     * @return  The tokens that the farm supports.\r\n     */\r\n    function getFarmTokens() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @return  True if the provided token is supported for farming, or false if it's not.\r\n     */\r\n    function isSupportedToken(address token) external view returns (bool);\r\n\r\n    /**\r\n     * @return  True if there is an active season for farming, or false if there isn't one.\r\n     */\r\n    function isFarmActive() external view returns (bool);\r\n\r\n    function dmmController() external view returns (address);\r\n\r\n    /**\r\n     * The address that acts as a \"secondary\" owner with quicker access to function calling than the owner. Typically,\r\n     * this is the DMMF.\r\n     */\r\n    function guardian() external view returns (address);\r\n\r\n    /**\r\n     * @return The DMG token.\r\n     */\r\n    function dmgToken() external view returns (address);\r\n\r\n    /**\r\n     * @return  The growth coefficient for earning DMG while farming. Each unit represents how much DMG is earned per\r\n     *          point\r\n     */\r\n    function dmgGrowthCoefficient() external view returns (uint);\r\n\r\n    /**\r\n     * @return  The amount of points that the provided token earns for each unit of token deposited. Defaults to `1`\r\n     *          if the provided `token` does not exist or does not have a special weight. This number is `2` decimals.\r\n     */\r\n    function getRewardPointsByToken(address token) external view returns (uint16);\r\n\r\n    /**\r\n     * @return  The number of decimals that the underlying token has.\r\n     */\r\n    function getTokenDecimalsByToken(address token) external view returns (uint8);\r\n\r\n    /**\r\n     * @return  The type of token this farm token is.\r\n     */\r\n    function getTokenTypeByToken(address token) external view returns (DMGYieldFarmingV2Lib.TokenType);\r\n\r\n    /**\r\n     * @return  The index into the array returned from `getFarmTokens`, plus 1. 0 if the token isn't found. If the\r\n     *          index returned is non-zero, subtract 1 from it to get the real index into the array.\r\n     */\r\n    function getTokenIndexPlusOneByToken(address token) external view returns (uint);\r\n\r\n    function underlyingTokenValuator() external view returns (address);\r\n\r\n    function weth() external view returns (address);\r\n\r\n    function uniswapV2Router() external view returns (address);\r\n\r\n    function getFeesByToken(address token) external view returns (uint16);\r\n\r\n}\r\n\r\n// File: contracts/external/farming/v2/DMGYieldFarmingV2.sol\r\n\r\n/*\r\n * Copyright 2020 DMM Foundation\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract DMGYieldFarmingV2 is IDMGYieldFarmingV2, DMGYieldFarmingData {\r\n\r\n    using SafeMath for uint;\r\n    using SafeERC20 for IERC20;\r\n    using DMGYieldFarmingV2Lib for IDMGYieldFarmingV2;\r\n\r\n    address constant private ZERO_ADDRESS = address(0);\r\n\r\n    modifier isSpenderApproved(address __user) {\r\n        require(\r\n            msg.sender == __user || _globalProxyToIsTrustedMap[msg.sender] || _userToSpenderToIsApprovedMap[__user][msg.sender],\r\n            \"DMGYieldFarmingV2:: UNAPPROVED\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrGuardian {\r\n        require(\r\n            msg.sender == _owner || msg.sender == _guardian,\r\n            \"DMGYieldFarmingV2:: UNAUTHORIZED\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier farmIsActive {\r\n        require(\r\n            _isFarmActive,\r\n            \"DMGYieldFarmingV2:: FARM_NOT_ACTIVE\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier requireIsFarmToken(address __token) {\r\n        require(\r\n            _tokenToIndexPlusOneMap[__token] != 0,\r\n            \"DMGYieldFarmingV2:: TOKEN_UNSUPPORTED\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier farmIsNotActive {\r\n        require(\r\n            !_isFarmActive,\r\n            \"DMGYieldFarmingV2:: FARM_IS_ACTIVE\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ////////////////////\r\n    // Admin Functions\r\n    // ////////////////////\r\n\r\n    function approveGloballyTrustedProxy(\r\n        address __proxy,\r\n        bool __isTrusted\r\n    )\r\n    public\r\n    nonReentrant\r\n    onlyOwnerOrGuardian {\r\n        _globalProxyToIsTrustedMap[__proxy] = __isTrusted;\r\n        emit GlobalProxySet(__proxy, __isTrusted);\r\n    }\r\n\r\n    function isGloballyTrustedProxy(\r\n        address __proxy\r\n    ) public view returns (bool) {\r\n        return _globalProxyToIsTrustedMap[__proxy];\r\n    }\r\n\r\n    function addAllowableToken(\r\n        address __token,\r\n        address __underlyingToken,\r\n        uint8 __underlyingTokenDecimals,\r\n        uint16 __points,\r\n        uint16 __fees,\r\n        DMGYieldFarmingV2Lib.TokenType __tokenType\r\n    )\r\n    public\r\n    onlyOwnerOrGuardian\r\n    nonReentrant {\r\n        uint index = _tokenToIndexPlusOneMap[__token];\r\n        require(\r\n            index == 0,\r\n            \"DMGYieldFarmingV2::addAllowableToken: TOKEN_ALREADY_SUPPORTED\"\r\n        );\r\n        _verifyTokenFee(__fees);\r\n        _verifyTokenType(__tokenType, __underlyingToken, __token, __underlyingTokenDecimals);\r\n        _verifyPoints(__points);\r\n\r\n        _tokenToIndexPlusOneMap[__token] = _supportedFarmTokens.push(__token);\r\n        _tokenToFeeAmountMap[__token] = __fees;\r\n        _tokenToRewardPointMap[__token] = __points;\r\n        _tokenToDecimalsMap[__token] = __underlyingTokenDecimals;\r\n        _tokenToTokenType[__token] = __tokenType;\r\n        _tokenToUnderlyingTokenMap[__token] = __underlyingToken;\r\n        emit TokenAdded(__token, __underlyingToken, __underlyingTokenDecimals, __points, __fees);\r\n    }\r\n\r\n    function removeAllowableToken(\r\n        address __token\r\n    )\r\n    public\r\n    onlyOwnerOrGuardian\r\n    nonReentrant\r\n    farmIsNotActive {\r\n        uint index = _tokenToIndexPlusOneMap[__token];\r\n        require(\r\n            index != 0,\r\n            \"DMGYieldFarmingV2::removeAllowableToken: TOKEN_NOT_SUPPORTED\"\r\n        );\r\n        _tokenToIndexPlusOneMap[__token] = 0;\r\n        _tokenToRewardPointMap[__token] = 0;\r\n        delete _supportedFarmTokens[index - 1];\r\n        emit TokenRemoved(__token);\r\n    }\r\n\r\n    function beginFarmingSeason(\r\n        uint __dmgAmount\r\n    )\r\n    public\r\n    onlyOwnerOrGuardian\r\n    nonReentrant {\r\n        require(\r\n            !_isFarmActive,\r\n            \"DMGYieldFarmingV2::beginFarmingSeason: FARM_ALREADY_ACTIVE\"\r\n        );\r\n\r\n        _seasonIndex += 1;\r\n        _isFarmActive = true;\r\n        address dmgToken = _dmgToken;\r\n        IERC20(dmgToken).safeTransferFrom(msg.sender, address(this), __dmgAmount);\r\n        _addressToTokenToBalanceMap[ZERO_ADDRESS][dmgToken] = _addressToTokenToBalanceMap[ZERO_ADDRESS][dmgToken].add(__dmgAmount);\r\n        _seasonIndexToStartTimestamp[_seasonIndex] = uint64(block.timestamp);\r\n\r\n        emit FarmSeasonBegun(_seasonIndex, __dmgAmount);\r\n    }\r\n\r\n    function addToFarmingSeason(\r\n        uint __dmgAmount\r\n    )\r\n    public\r\n    onlyOwnerOrGuardian\r\n    nonReentrant {\r\n        require(\r\n            _isFarmActive,\r\n            \"DMGYieldFarmingV2::addToFarmingSeason: FARM_NOT_ACTIVE\"\r\n        );\r\n\r\n        address dmgToken = _dmgToken;\r\n        IERC20(dmgToken).safeTransferFrom(msg.sender, address(this), __dmgAmount);\r\n        _addressToTokenToBalanceMap[ZERO_ADDRESS][dmgToken] = _addressToTokenToBalanceMap[ZERO_ADDRESS][dmgToken].add(__dmgAmount);\r\n\r\n        emit FarmSeasonExtended(_seasonIndex, __dmgAmount);\r\n    }\r\n\r\n    function endActiveFarmingSeason(\r\n        address __dustRecipient\r\n    )\r\n    public\r\n    nonReentrant {\r\n        address dmgToken = _dmgToken;\r\n        uint dmgBalance = _getDmgRewardBalance(dmgToken);\r\n        // Anyone can end the farm if the DMG balance has been drawn down to 0.\r\n        require(\r\n            dmgBalance == 0 || msg.sender == owner() || msg.sender == _guardian,\r\n            \"DMGYieldFarmingV2::endActiveFarmingSeason: FARM_ACTIVE_OR_INVALID_SENDER\"\r\n        );\r\n\r\n        _isFarmActive = false;\r\n        if (dmgBalance > 0) {\r\n            IERC20(dmgToken).safeTransfer(__dustRecipient, dmgBalance);\r\n        }\r\n\r\n        emit FarmSeasonEnd(_seasonIndex, __dustRecipient, dmgBalance);\r\n    }\r\n\r\n    function setDmgGrowthCoefficient(\r\n        uint __dmgGrowthCoefficient\r\n    )\r\n    public\r\n    nonReentrant\r\n    onlyOwnerOrGuardian {\r\n        _verifyDmgGrowthCoefficient(__dmgGrowthCoefficient);\r\n\r\n        _dmgGrowthCoefficient = __dmgGrowthCoefficient;\r\n        emit DmgGrowthCoefficientSet(__dmgGrowthCoefficient);\r\n    }\r\n\r\n    function setRewardPointsByTokens(\r\n        address[] calldata __tokens,\r\n        uint16[] calldata __points\r\n    )\r\n    external\r\n    nonReentrant\r\n    onlyOwnerOrGuardian {\r\n        require(\r\n            __tokens.length == __points.length,\r\n            \"DMGYieldFarmingV2::setRewardPointsByTokens INVALID_PARAMS\"\r\n        );\r\n\r\n        for (uint i = 0; i < __tokens.length; i++) {\r\n            _setRewardPointsByToken(__tokens[i], __points[i]);\r\n        }\r\n    }\r\n\r\n    function setUnderlyingTokenValuator(\r\n        address __underlyingTokenValuator\r\n    )\r\n    onlyOwnerOrGuardian\r\n    nonReentrant\r\n    public {\r\n        require(\r\n            __underlyingTokenValuator != address(0),\r\n            \"DMGYieldFarmingV2::setUnderlyingTokenValuator: INVALID_VALUATOR\"\r\n        );\r\n        address oldUnderlyingTokenValuator = _underlyingTokenValuator;\r\n        _underlyingTokenValuator = __underlyingTokenValuator;\r\n        emit UnderlyingTokenValuatorChanged(__underlyingTokenValuator, oldUnderlyingTokenValuator);\r\n    }\r\n\r\n    function setWethToken(\r\n        address __weth\r\n    )\r\n    onlyOwnerOrGuardian\r\n    nonReentrant\r\n    public {\r\n        require(\r\n            _weth == address(0),\r\n            \"DMGYieldFarmingV2::setWethToken: WETH_ALREADY_SET\"\r\n        );\r\n        _weth = __weth;\r\n    }\r\n\r\n    function setUniswapV2Router(\r\n        address __uniswapV2Router\r\n    )\r\n    onlyOwnerOrGuardian\r\n    nonReentrant\r\n    public {\r\n        require(\r\n            __uniswapV2Router != address(0),\r\n            \"DMGYieldFarmingV2::setUnderlyingTokenValuator: INVALID_VALUATOR\"\r\n        );\r\n        address oldUniswapV2Router = _uniswapV2Router;\r\n        _uniswapV2Router = __uniswapV2Router;\r\n        emit UniswapV2RouterChanged(__uniswapV2Router, oldUniswapV2Router);\r\n    }\r\n\r\n    function setFeesByTokens(\r\n        address[] calldata __tokens,\r\n        uint16[] calldata __fees\r\n    )\r\n    onlyOwnerOrGuardian\r\n    nonReentrant\r\n    external {\r\n        require(\r\n            __tokens.length == __fees.length,\r\n            \"DMGYieldFarmingV2::setFeesByTokens: INVALID_PARAMS\"\r\n        );\r\n\r\n        for (uint i = 0; i < __tokens.length; i++) {\r\n            _setFeeByToken(__tokens[i], __fees[i]);\r\n        }\r\n    }\r\n\r\n    function setTokenTypeByToken(\r\n        address __token,\r\n        DMGYieldFarmingV2Lib.TokenType __tokenType\r\n    )\r\n    onlyOwnerOrGuardian\r\n    nonReentrant\r\n    requireIsFarmToken(__token)\r\n    public {\r\n        _verifyTokenType(__tokenType, _tokenToUnderlyingTokenMap[__token], __token, _tokenToDecimalsMap[__token]);\r\n        _tokenToTokenType[__token] = __tokenType;\r\n        emit TokenTypeChanged(__token, __tokenType);\r\n    }\r\n\r\n    function initializeDmgBalance() nonReentrant external {\r\n        require(\r\n            !_isDmgBalanceInitialized,\r\n            \"DMGYieldFarmingV2::initializeDmgBalance: ALREADY_INITIALIZED\"\r\n        );\r\n        _isDmgBalanceInitialized = true;\r\n        _addressToTokenToBalanceMap[ZERO_ADDRESS][_dmgToken] = IERC20(_dmgToken).balanceOf(address(this));\r\n    }\r\n\r\n    // ////////////////////\r\n    // Misc Functions\r\n    // ////////////////////\r\n\r\n    function getFarmTokens() public view returns (address[] memory) {\r\n        return _supportedFarmTokens;\r\n    }\r\n\r\n    function isSupportedToken(address __token) public view returns (bool) {\r\n        return _tokenToIndexPlusOneMap[__token] > 0;\r\n    }\r\n\r\n    function isFarmActive() external view returns (bool) {\r\n        return _isFarmActive;\r\n    }\r\n\r\n    function dmmController() external view returns (address) {\r\n        return _dmmController;\r\n    }\r\n\r\n    function guardian() external view returns (address) {\r\n        return _guardian;\r\n    }\r\n\r\n    function dmgToken() external view returns (address) {\r\n        return _dmgToken;\r\n    }\r\n\r\n    function dmgGrowthCoefficient() external view returns (uint) {\r\n        return _dmgGrowthCoefficient;\r\n    }\r\n\r\n    function getRewardPointsByToken(\r\n        address __token\r\n    ) public view returns (uint16) {\r\n        uint16 rewardPoints = _tokenToRewardPointMap[__token];\r\n        return rewardPoints == 0 ? POINTS_FACTOR : rewardPoints;\r\n    }\r\n\r\n    function getTokenDecimalsByToken(\r\n        address __token\r\n    ) public view returns (uint8) {\r\n        return _tokenToDecimalsMap[__token];\r\n    }\r\n\r\n    function getTokenIndexPlusOneByToken(\r\n        address __token\r\n    ) public view returns (uint) {\r\n        return _tokenToIndexPlusOneMap[__token];\r\n    }\r\n\r\n    function getTokenTypeByToken(\r\n        address __token\r\n    ) public view returns (DMGYieldFarmingV2Lib.TokenType) {\r\n        return _tokenToTokenType[__token];\r\n    }\r\n\r\n    // ////////////////////\r\n    // User Functions\r\n    // ////////////////////\r\n\r\n    function approve(\r\n        address __spender,\r\n        bool __isTrusted\r\n    ) public {\r\n        _userToSpenderToIsApprovedMap[msg.sender][__spender] = __isTrusted;\r\n        emit Approval(msg.sender, __spender, __isTrusted);\r\n    }\r\n\r\n    function isApproved(\r\n        address __user,\r\n        address __spender\r\n    ) public view returns (bool) {\r\n        return _userToSpenderToIsApprovedMap[__user][__spender];\r\n    }\r\n\r\n    function beginFarming(\r\n        address __user,\r\n        address __funder,\r\n        address __token,\r\n        uint __amount\r\n    )\r\n    public\r\n    farmIsActive\r\n    requireIsFarmToken(__token)\r\n    isSpenderApproved(__user)\r\n    nonReentrant {\r\n        require(\r\n            __funder == msg.sender || __funder == __user,\r\n            \"DMGYieldFarmingV2::beginFarming: INVALID_FUNDER\"\r\n        );\r\n\r\n        if (__amount > 0) {\r\n            // In case the __user is reusing a non-zero balance they had before the start of this farm.\r\n            IERC20(__token).safeTransferFrom(__funder, address(this), __amount);\r\n        }\r\n\r\n        // We reindex before adding to the __user's balance, because the indexing process takes the __user's CURRENT\r\n        // balance and applies their earnings, so we can account for new deposits.\r\n        _reindexEarningsByTimestamp(__user, __token);\r\n\r\n        if (__amount > 0) {\r\n            _addressToTokenToBalanceMap[__user][__token] = _addressToTokenToBalanceMap[__user][__token].add(__amount);\r\n        }\r\n\r\n        emit BeginFarming(__user, __token, __amount);\r\n    }\r\n\r\n    function endFarmingByToken(\r\n        address __user,\r\n        address __recipient,\r\n        address __token\r\n    )\r\n    public\r\n    farmIsActive\r\n    requireIsFarmToken(__token)\r\n    isSpenderApproved(__user)\r\n    nonReentrant\r\n    returns (uint, uint) {\r\n        return _endFarmingByTokenAndAmount(\r\n            __user,\r\n            __recipient,\r\n            __token,\r\n            _addressToTokenToBalanceMap[__user][__token]\r\n        );\r\n    }\r\n\r\n    function endFarmingByTokenAndAmount(\r\n        address __user,\r\n        address __recipient,\r\n        address __token,\r\n        uint __withdrawalAmount\r\n    )\r\n    public\r\n    farmIsActive\r\n    requireIsFarmToken(__token)\r\n    isSpenderApproved(__user)\r\n    nonReentrant\r\n    returns (uint, uint) {\r\n        return _endFarmingByTokenAndAmount(\r\n            __user,\r\n            __recipient,\r\n            __token,\r\n            __withdrawalAmount\r\n        );\r\n    }\r\n\r\n    function withdrawAllWhenOutOfSeason(\r\n        address __user,\r\n        address __recipient\r\n    )\r\n    public\r\n    farmIsNotActive\r\n    isSpenderApproved(__user)\r\n    nonReentrant\r\n    returns (address[] memory, uint[] memory) {\r\n        address[] memory farmTokens = _supportedFarmTokens;\r\n        uint[] memory withdrawnAmounts = new uint[](farmTokens.length);\r\n        for (uint i = 0; i < farmTokens.length; i++) {\r\n            withdrawnAmounts[i] = _withdrawByTokenWhenOutOfSeason(__user, __recipient, farmTokens[i]);\r\n        }\r\n        return (farmTokens, withdrawnAmounts);\r\n    }\r\n\r\n    function withdrawByTokenWhenOutOfSeason(\r\n        address __user,\r\n        address __recipient,\r\n        address __token\r\n    )\r\n    isSpenderApproved(__user)\r\n    nonReentrant\r\n    public returns (uint) {\r\n        // The __user can only withdraw this way if the farm is NOT active or if the __token is no longer supported.\r\n        require(\r\n            !_isFarmActive || _tokenToIndexPlusOneMap[__token] == 0,\r\n            \"DMGYieldFarmingV2::withdrawByTokenWhenOutOfSeason: FARM_ACTIVE_OR_TOKEN_SUPPORTED\"\r\n        );\r\n\r\n        return _withdrawByTokenWhenOutOfSeason(__user, __recipient, __token);\r\n    }\r\n\r\n    function getRewardBalanceByOwner(\r\n        address __owner\r\n    ) public view returns (uint) {\r\n        if (_isFarmActive) {\r\n            return _getTotalRewardBalanceByUser(__owner, _seasonIndex);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getRewardBalanceByOwnerAndToken(\r\n        address __owner,\r\n        address __token\r\n    ) public view returns (uint) {\r\n        if (_isFarmActive) {\r\n            return _getTotalRewardBalanceByUserAndToken(__owner, __token, _seasonIndex);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getUsdBalanceByOwnerAndToken(\r\n        address __owner,\r\n        address __token\r\n    ) public view returns (uint) {\r\n        uint balance = _addressToTokenToBalanceMap[__owner][__token];\r\n        return DMGYieldFarmingV2Lib._getUsdValueByTokenAndTokenAmount(this, __token, balance);\r\n    }\r\n\r\n    function balanceOf(\r\n        address __owner,\r\n        address __token\r\n    ) public view returns (uint) {\r\n        return _addressToTokenToBalanceMap[__owner][__token];\r\n    }\r\n\r\n    function getMostRecentDepositTimestampByOwnerAndToken(\r\n        address __owner,\r\n        address __token\r\n    ) public view returns (uint64) {\r\n        if (_isFarmActive) {\r\n            return _seasonIndexToUserToTokenToDepositTimestampMap[_seasonIndex][__owner][__token];\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getMostRecentIndexedDmgEarnedByOwnerAndToken(\r\n        address __owner,\r\n        address __token\r\n    ) public view returns (uint) {\r\n        if (_isFarmActive) {\r\n            return _seasonIndexToUserToTokenToEarnedDmgAmountMap[_seasonIndex][__owner][__token];\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function harvestDmgByUserAndToken(\r\n        address __user,\r\n        address __recipient,\r\n        address __token\r\n    )\r\n    requireIsFarmToken(__token)\r\n    farmIsActive\r\n    isSpenderApproved(__user)\r\n    nonReentrant\r\n    public returns (uint) {\r\n        uint tokenBalance = _addressToTokenToBalanceMap[__user][__token];\r\n        return _harvestDmgByUserAndToken(__user, __recipient, __token, tokenBalance);\r\n    }\r\n\r\n    function harvestDmgByUser(\r\n        address __user,\r\n        address __recipient\r\n    )\r\n    farmIsActive\r\n    isSpenderApproved(__user)\r\n    nonReentrant\r\n    public returns (uint) {\r\n        address[] memory farmTokens = _supportedFarmTokens;\r\n        uint totalEarnedDmgAmount = 0;\r\n        for (uint i = 0; i < farmTokens.length; i++) {\r\n            uint farmTokenBalance = _addressToTokenToBalanceMap[__user][farmTokens[i]];\r\n            if (farmTokenBalance > 0) {\r\n                uint earnedDmgAmount = _harvestDmgByUserAndToken(__user, __recipient, farmTokens[i], farmTokenBalance);\r\n                totalEarnedDmgAmount = totalEarnedDmgAmount.add(earnedDmgAmount);\r\n            }\r\n        }\r\n        return totalEarnedDmgAmount;\r\n    }\r\n\r\n    function getUnderlyingTokenByFarmToken(\r\n        address __farmToken\r\n    ) public view returns (address) {\r\n        return _tokenToUnderlyingTokenMap[__farmToken];\r\n    }\r\n\r\n    function underlyingTokenValuator() external view returns (address) {\r\n        return _underlyingTokenValuator;\r\n    }\r\n\r\n    function weth() external view returns (address) {\r\n        return _weth;\r\n    }\r\n\r\n    function uniswapV2Router() external view returns (address) {\r\n        return _uniswapV2Router;\r\n    }\r\n\r\n    function getFeesByToken(\r\n        address __token\r\n    ) public view returns (uint16) {\r\n        uint16 fee = _tokenToFeeAmountMap[__token];\r\n        return fee == 0 ? 100 : fee;\r\n    }\r\n\r\n    // ////////////////////\r\n    // Internal Functions\r\n    // ////////////////////\r\n\r\n    function _endFarmingByTokenAndAmount(\r\n        address __user,\r\n        address __recipient,\r\n        address __token,\r\n        uint __withdrawalAmount\r\n    ) internal returns (uint, uint) {\r\n        (uint feeAmount, uint earnedDmgAmount) = _doHarvest(\r\n            __user,\r\n            __recipient,\r\n            __token,\r\n            __withdrawalAmount,\r\n            _dmgToken\r\n        );\r\n\r\n        _addressToTokenToBalanceMap[__user][__token] = _addressToTokenToBalanceMap[__user][__token].sub(__withdrawalAmount);\r\n        // The __user withdraws (__withdrawalAmount - fee) amount.\r\n        __withdrawalAmount = __withdrawalAmount.sub(feeAmount);\r\n        IERC20(__token).safeTransfer(__recipient, __withdrawalAmount);\r\n\r\n        emit EndFarming(__user, __token, __withdrawalAmount, earnedDmgAmount);\r\n\r\n        return (__withdrawalAmount, earnedDmgAmount);\r\n    }\r\n\r\n    /**\r\n     * This function updates state for the tracked amount of DMG that the user has earned. This function DOES NOT\r\n     * update state for the user's balance.\r\n     *\r\n     * @return The amount of `__token` paid in fees and the amount of DMG earned and sent to recipient.\r\n     */\r\n    function _doHarvest(\r\n        address __user,\r\n        address __recipient,\r\n        address __token,\r\n        uint __harvestAmount,\r\n        address __dmg\r\n    ) internal returns (uint, uint) {\r\n        require(\r\n            __harvestAmount > 0,\r\n            \"DMGYieldFarmingV2::_doHarvest: ZERO_HARVEST_AMOUNT\"\r\n        );\r\n\r\n        uint tokenBalance = _addressToTokenToBalanceMap[__user][__token];\r\n        require(\r\n            __harvestAmount <= tokenBalance,\r\n            \"DMGYieldFarmingV2::_doHarvest: INSUFFICIENT_BALANCE\"\r\n        );\r\n\r\n        uint earnedDmgAmount = _getTotalRewardBalanceByUserAndToken(__user, __token, _seasonIndex);\r\n        // Scale the amount of DMG earned by the user's balance and how much it's being harvested against\r\n        uint scaledEarnedDmgAmount = earnedDmgAmount.mul(__harvestAmount).div(tokenBalance);\r\n        require(\r\n            scaledEarnedDmgAmount > 0,\r\n            \"DMGYieldFarmingV2::_doHarvest: ZERO_EARNED\"\r\n        );\r\n\r\n        uint contractDmgRewardBalance = _getDmgRewardBalance(__dmg);\r\n        uint scaledHarvestAmount = __harvestAmount;\r\n        if (scaledEarnedDmgAmount > contractDmgRewardBalance) {\r\n            // Proportionally scale down the amounts to how much DMG is actually going to be redeemed\r\n            scaledHarvestAmount = scaledHarvestAmount.mul(contractDmgRewardBalance).div(scaledEarnedDmgAmount);\r\n            scaledEarnedDmgAmount = contractDmgRewardBalance;\r\n            require(\r\n                scaledEarnedDmgAmount > 0,\r\n                \"DMGYieldFarmingV2::_doHarvest: SCALED_ZERO_EARNED\"\r\n            );\r\n        }\r\n        _addressToTokenToBalanceMap[ZERO_ADDRESS][__dmg] = _addressToTokenToBalanceMap[ZERO_ADDRESS][__dmg].sub(scaledEarnedDmgAmount);\r\n\r\n        uint feeAmount = DMGYieldFarmingV2Lib._payHarvestFee(this, __user, __token, scaledHarvestAmount);\r\n        IERC20(__dmg).safeTransfer(__recipient, scaledEarnedDmgAmount);\r\n\r\n        // We set the earned dmg this user has acquired to the earned amount, minus what was actually withdrawn\r\n        _seasonIndexToUserToTokenToEarnedDmgAmountMap[_seasonIndex][__user][__token] = earnedDmgAmount.sub(scaledEarnedDmgAmount);\r\n        _seasonIndexToUserToTokenToDepositTimestampMap[_seasonIndex][__user][__token] = uint64(block.timestamp);\r\n\r\n        return (feeAmount, scaledEarnedDmgAmount);\r\n    }\r\n\r\n    function _setFeeByToken(\r\n        address __token,\r\n        uint16 __fee\r\n    ) internal {\r\n        _verifyTokenFee(__fee);\r\n        _tokenToFeeAmountMap[__token] = __fee;\r\n        emit FeesChanged(__token, __fee);\r\n    }\r\n\r\n    function _setRewardPointsByToken(\r\n        address __token,\r\n        uint16 __points\r\n    ) internal {\r\n        _verifyPoints(__points);\r\n        _tokenToRewardPointMap[__token] = __points;\r\n        emit RewardPointsSet(__token, __points);\r\n    }\r\n\r\n    function _verifyDmgGrowthCoefficient(\r\n        uint __dmgGrowthCoefficient\r\n    ) internal pure {\r\n        require(\r\n            __dmgGrowthCoefficient > 0,\r\n            \"DMGYieldFarmingV2::_verifyDmgGrowthCoefficient: INVALID_GROWTH_COEFFICIENT\"\r\n        );\r\n    }\r\n\r\n    function _verifyTokenType(\r\n        DMGYieldFarmingV2Lib.TokenType __tokenType,\r\n        address __underlyingToken,\r\n        address __farmToken,\r\n        uint8 __farmTokenDecimals\r\n    ) internal {\r\n        require(\r\n            __tokenType != DMGYieldFarmingV2Lib.TokenType.Unknown,\r\n            \"DMGYieldFarmingV2::_verifyTokenType: INVALID_TYPE\"\r\n        );\r\n\r\n        if (__tokenType == DMGYieldFarmingV2Lib.TokenType.UniswapLpToken) {\r\n            address __uniswapV2Router = _uniswapV2Router;\r\n            if (IERC20(__underlyingToken).allowance(address(this), __uniswapV2Router) == 0) {\r\n                IERC20(__underlyingToken).safeApprove(__uniswapV2Router, uint(- 1));\r\n            }\r\n        } else if (__tokenType == DMGYieldFarmingV2Lib.TokenType.UniswapPureLpToken) {\r\n            address __uniswapV2Router = _uniswapV2Router;\r\n            if (IERC20(__underlyingToken).allowance(address(this), __uniswapV2Router) == 0) {\r\n                IERC20(__underlyingToken).safeApprove(__uniswapV2Router, uint(- 1));\r\n            }\r\n            uint8 token0Decimals = IERC20WithDecimals(IUniswapV2Pair(__farmToken).token0()).decimals();\r\n            uint8 token1Decimals = IERC20WithDecimals(IUniswapV2Pair(__farmToken).token1()).decimals();\r\n            require(\r\n                token0Decimals == __farmTokenDecimals,\r\n                \"DMGYieldFarmingV2::_verifyTokenType: INVALID_TOKEN_0_DECIMALS\"\r\n            );\r\n            require(\r\n                token1Decimals == __farmTokenDecimals,\r\n                \"DMGYieldFarmingV2::_verifyTokenType: INVALID_TOKEN_1_DECIMALS\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function _verifyTokenFee(\r\n        uint16 __fee\r\n    ) internal pure {\r\n        require(\r\n            __fee < FEE_AMOUNT_FACTOR,\r\n            \"DMGYieldFarmingV2::_verifyTokenFee: INVALID_FEES\"\r\n        );\r\n    }\r\n\r\n    function _verifyPoints(\r\n        uint16 __points\r\n    ) internal pure {\r\n        require(\r\n            __points > 0,\r\n            \"DMGYieldFarmingV2::_verifyPoints: INVALID_POINTS\"\r\n        );\r\n    }\r\n\r\n    function _getDmgRewardBalance(\r\n        address __dmgToken\r\n    ) internal view returns (uint) {\r\n        return _addressToTokenToBalanceMap[ZERO_ADDRESS][__dmgToken];\r\n    }\r\n\r\n    /**\r\n     * @return  The amount of DMG earned by __user and sent to __recipient\r\n     */\r\n    function _harvestDmgByUserAndToken(\r\n        address __user,\r\n        address __recipient,\r\n        address __token,\r\n        uint __tokenBalance\r\n    ) internal returns (uint) {\r\n        (uint feeAmount, uint earnedDmgAmount) = _doHarvest(\r\n            __user,\r\n            __recipient,\r\n            __token,\r\n            __tokenBalance,\r\n            _dmgToken\r\n        );\r\n\r\n        _addressToTokenToBalanceMap[__user][__token] = _addressToTokenToBalanceMap[__user][__token].sub(feeAmount);\r\n\r\n        emit Harvest(__user, __token, earnedDmgAmount);\r\n\r\n        return earnedDmgAmount;\r\n    }\r\n\r\n    function _getUnindexedRewardsByUserAndToken(\r\n        address __owner,\r\n        address __token,\r\n        uint64 __previousIndexTimestamp\r\n    ) internal view returns (uint) {\r\n        uint balance = _addressToTokenToBalanceMap[__owner][__token];\r\n\r\n        if (balance > 0 && __previousIndexTimestamp != 0) {\r\n            uint usdValue = DMGYieldFarmingV2Lib._getUsdValueByTokenAndTokenAmount(this, __token, balance);\r\n            uint16 points = getRewardPointsByToken(__token);\r\n            return _calculateRewardBalance(\r\n                usdValue,\r\n                points,\r\n                _dmgGrowthCoefficient,\r\n                block.timestamp,\r\n                __previousIndexTimestamp\r\n            );\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function _reindexEarningsByTimestamp(\r\n        address __user,\r\n        address __token\r\n    ) internal {\r\n        uint seasonIndex = _seasonIndex;\r\n        uint64 previousIndexTimestamp = _seasonIndexToUserToTokenToDepositTimestampMap[seasonIndex][__user][__token];\r\n        if (previousIndexTimestamp != 0) {\r\n            uint dmgEarnedAmount = _getUnindexedRewardsByUserAndToken(__user, __token, previousIndexTimestamp);\r\n            if (dmgEarnedAmount > 0) {\r\n                _seasonIndexToUserToTokenToEarnedDmgAmountMap[seasonIndex][__user][__token] = _seasonIndexToUserToTokenToEarnedDmgAmountMap[seasonIndex][__user][__token].add(dmgEarnedAmount);\r\n            }\r\n        }\r\n        _seasonIndexToUserToTokenToDepositTimestampMap[seasonIndex][__user][__token] = uint64(block.timestamp);\r\n    }\r\n\r\n    function _getTotalRewardBalanceByUserAndToken(\r\n        address __owner,\r\n        address __token,\r\n        uint __seasonIndex\r\n    ) internal view returns (uint) {\r\n        uint64 previousIndexTimestamp = _seasonIndexToUserToTokenToDepositTimestampMap[__seasonIndex][__owner][__token];\r\n        if (previousIndexTimestamp == 0) {\r\n            // If the user has not deposited yet for this season, default to the season's start time. Why? Because this\r\n            // allows the user's balance to carry over from season to season, assuming that the user deposited in a\r\n            // prior season and left a non-zero balance.\r\n            previousIndexTimestamp = _seasonIndexToStartTimestamp[__seasonIndex];\r\n        }\r\n\r\n        return _getUnindexedRewardsByUserAndToken(__owner, __token, previousIndexTimestamp)\r\n        .add(_seasonIndexToUserToTokenToEarnedDmgAmountMap[__seasonIndex][__owner][__token]);\r\n    }\r\n\r\n    function _calculateRewardBalance(\r\n        uint __usdValue,\r\n        uint16 __points,\r\n        uint __dmgGrowthCoefficient,\r\n        uint __currentTimestamp,\r\n        uint __previousIndexTimestamp\r\n    ) internal pure returns (uint) {\r\n        if (__usdValue == 0) {\r\n            return 0;\r\n        } else {\r\n            uint elapsedTime = __currentTimestamp.sub(__previousIndexTimestamp);\r\n            // The number returned here has 18 decimal places (same as USD value), which is the same number as DMG.\r\n            // Perfect.\r\n            return elapsedTime\r\n            .mul(__dmgGrowthCoefficient)\r\n            .mul(__usdValue)\r\n            .div(DMG_GROWTH_COEFFICIENT_FACTOR)\r\n            .mul(__points)\r\n            .div(POINTS_FACTOR);\r\n        }\r\n    }\r\n\r\n    function _getTotalRewardBalanceByUser(\r\n        address __owner,\r\n        uint __seasonIndex\r\n    ) internal view returns (uint) {\r\n        address[] memory supportedFarmTokens = _supportedFarmTokens;\r\n        uint totalDmgEarned = 0;\r\n        for (uint i = 0; i < supportedFarmTokens.length; i++) {\r\n            totalDmgEarned = totalDmgEarned.add(_getTotalRewardBalanceByUserAndToken(__owner, supportedFarmTokens[i], __seasonIndex));\r\n        }\r\n        return totalDmgEarned;\r\n    }\r\n\r\n    function _withdrawByTokenWhenOutOfSeason(\r\n        address __user,\r\n        address __recipient,\r\n        address __token\r\n    ) internal returns (uint) {\r\n        uint amount = _addressToTokenToBalanceMap[__user][__token];\r\n        if (amount > 0) {\r\n            _addressToTokenToBalanceMap[__user][__token] = 0;\r\n            IERC20(__token).safeTransfer(__recipient, amount);\r\n        }\r\n\r\n        emit WithdrawOutOfSeason(__user, __token, __recipient, amount);\r\n\r\n        return amount;\r\n    }\r\n\r\n}"
    }
  }
}