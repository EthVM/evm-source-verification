{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":20000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/1_Storage.sol":{"content":"/*\n    .'''''''''''..     ..''''''''''''''''..       ..'''''''''''''''..\n    .;;;;;;;;;;;'.   .';;;;;;;;;;;;;;;;;;,.     .,;;;;;;;;;;;;;;;;;,.\n    .;;;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;,.    .,;;;;;;;;;;;;;;;;;;,.\n    .;;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;;,.   .;;;;;;;;;;;;;;;;;;;;,.\n    ';;;;;;;;'.  .';;;;;;;;;;;;;;;;;;;;;;,. .';;;;;;;;;;;;;;;;;;;;;,.\n    ';;;;;,..   .';;;;;;;;;;;;;;;;;;;;;;;,..';;;;;;;;;;;;;;;;;;;;;;,.\n    ......     .';;;;;;;;;;;;;,'''''''''''.,;;;;;;;;;;;;;,'''''''''..\n              .,;;;;;;;;;;;;;.           .,;;;;;;;;;;;;;.\n             .,;;;;;;;;;;;;,.           .,;;;;;;;;;;;;,.\n            .,;;;;;;;;;;;;,.           .,;;;;;;;;;;;;,.\n           .,;;;;;;;;;;;;,.           .;;;;;;;;;;;;;,.     .....\n          .;;;;;;;;;;;;;'.         ..';;;;;;;;;;;;;'.    .',;;;;,'.\n        .';;;;;;;;;;;;;'.         .';;;;;;;;;;;;;;'.   .';;;;;;;;;;.\n       .';;;;;;;;;;;;;'.         .';;;;;;;;;;;;;;'.    .;;;;;;;;;;;,.\n      .,;;;;;;;;;;;;;'...........,;;;;;;;;;;;;;;.      .;;;;;;;;;;;,.\n     .,;;;;;;;;;;;;,..,;;;;;;;;;;;;;;;;;;;;;;;,.       ..;;;;;;;;;,.\n    .,;;;;;;;;;;;;,. .,;;;;;;;;;;;;;;;;;;;;;;,.          .',;;;,,..\n   .,;;;;;;;;;;;;,.  .,;;;;;;;;;;;;;;;;;;;;;,.              ....\n    ..',;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;;,.\n       ..',;;;;'.    .,;;;;;;;;;;;;;;;;;;;'.\n          ...'..     .';;;;;;;;;;;;;;,,,'.\n                       ...............\n*/\n\n// https://github.com/trusttoken/smart-contracts\n// Dependency file: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\n// SPDX-License-Identifier: MIT\n\n// pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n// Dependency file: @openzeppelin/contracts/utils/ReentrancyGuard.sol\n\n\n// pragma solidity ^0.6.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\n// Dependency file: @openzeppelin/contracts/math/SafeMath.sol\n\n\n// pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n// Dependency file: @openzeppelin/contracts/utils/Address.sol\n\n\n// pragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\n// Dependency file: @openzeppelin/contracts/GSN/Context.sol\n\n\n// pragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\n// Dependency file: contracts/common/Initializable.sol\n\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/v3.0.0/contracts/Initializable.sol\n// Added public isInitialized() view of private initialized bool.\n\n// pragma solidity 0.6.10;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        assembly {\n            cs := extcodesize(self)\n        }\n        return cs == 0;\n    }\n\n    /**\n     * @dev Return true if and only if the contract has been initialized\n     * @return whether the contract has been initialized\n     */\n    function isInitialized() public view returns (bool) {\n        return initialized;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n}\n\n\n// Dependency file: contracts/common/UpgradeableERC20.sol\n\n// pragma solidity 0.6.10;\n\n// import {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n// import {Context} from \"@openzeppelin/contracts/GSN/Context.sol\";\n// import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// import {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n// import {Initializable} from \"contracts/common/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Initializable, Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_initialize(string memory name, string memory symbol) internal initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public virtual view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public override view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public override view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public virtual override view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\")\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function updateNameAndSymbol(string memory __name, string memory __symbol) internal {\n        _name = __name;\n        _symbol = __symbol;\n    }\n}\n\n\n// Dependency file: contracts/common/UpgradeableOwnable.sol\n\n// pragma solidity 0.6.10;\n\n// import {Context} from \"@openzeppelin/contracts/GSN/Context.sol\";\n\n// import {Initializable} from \"contracts/common/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Initializable, Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\n// Dependency file: contracts/truefi/interface/IYToken.sol\n\n// pragma solidity 0.6.10;\n\n// import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IYToken is IERC20 {\n    function getPricePerFullShare() external view returns (uint256);\n}\n\n\n// Dependency file: contracts/truefi/interface/ICurve.sol\n\n// pragma solidity 0.6.10;\n\n// import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// import {IYToken} from \"contracts/truefi/interface/IYToken.sol\";\n\ninterface ICurve {\n    function calc_token_amount(uint256[4] memory amounts, bool deposit) external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n}\n\ninterface ICurveGauge {\n    function balanceOf(address depositor) external view returns (uint256);\n\n    function minter() external returns (ICurveMinter);\n\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n}\n\ninterface ICurveMinter {\n    function mint(address gauge) external;\n\n    function token() external view returns (IERC20);\n}\n\ninterface ICurvePool {\n    function add_liquidity(uint256[4] memory amounts, uint256 min_mint_amount) external;\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount,\n        bool donate_dust\n    ) external;\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);\n\n    function token() external view returns (IERC20);\n\n    function curve() external view returns (ICurve);\n\n    function coins(int128 id) external view returns (IYToken);\n}\n\n\n// Dependency file: contracts/truefi/interface/ITrueFiPool.sol\n\n// pragma solidity 0.6.10;\n\n// import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * TruePool is an ERC20 which represents a share of a pool\n *\n * This contract can be used to wrap opportunities to be compatible\n * with TrueFi and allow users to directly opt-in through the TUSD contract\n *\n * Each TruePool is also a staking opportunity for TRU\n */\ninterface ITrueFiPool is IERC20 {\n    /// @dev pool token (TUSD)\n    function currencyToken() external view returns (IERC20);\n\n    /// @dev stake token (TRU)\n    function stakeToken() external view returns (IERC20);\n\n    /**\n     * @dev join pool\n     * 1. Transfer TUSD from sender\n     * 2. Mint pool tokens based on value to sender\n     */\n    function join(uint256 amount) external;\n\n    /**\n     * @dev exit pool\n     * 1. Transfer pool tokens from sender\n     * 2. Burn pool tokens\n     * 3. Transfer value of pool tokens in TUSD to sender\n     */\n    function exit(uint256 amount) external;\n\n    /**\n     * @dev borrow from pool\n     * 1. Transfer TUSD to sender\n     * 2. Only lending pool should be allowed to call this\n     */\n    function borrow(uint256 amount, uint256 fee) external;\n\n    /**\n     * @dev join pool\n     * 1. Transfer TUSD from sender\n     * 2. Only lending pool should be allowed to call this\n     */\n    function repay(uint256 amount) external;\n}\n\n\n// Dependency file: contracts/truefi/interface/ITrueLender.sol\n\n// pragma solidity 0.6.10;\n\ninterface ITrueLender {\n    function value() external view returns (uint256);\n\n    function distribute(\n        address recipient,\n        uint256 numerator,\n        uint256 denominator\n    ) external;\n}\n\n\n// Dependency file: contracts/truefi/interface/IUniswapRouter.sol\n\n// pragma solidity 0.6.10;\n\ninterface IUniswapRouter {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\n\n// Dependency file: contracts/truefi/Log.sol\n\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\n// pragma solidity 0.6.10;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n    /**\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n     * number.  Revert on overflow.\n     *\n     * @param x unsigned 256-bit integer number\n     * @return signed 64.64-bit fixed point number\n     */\n    function fromUInt(uint256 x) internal pure returns (int128) {\n        require(x <= 0x7FFFFFFFFFFFFFFF);\n        return int128(x << 64);\n    }\n\n    /**\n     * Calculate binary logarithm of x.  Revert if x <= 0.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function log_2(int128 x) internal pure returns (int128) {\n        require(x > 0);\n\n        int256 msb = 0;\n        int256 xc = x;\n        if (xc >= 0x10000000000000000) {\n            xc >>= 64;\n            msb += 64;\n        }\n        if (xc >= 0x100000000) {\n            xc >>= 32;\n            msb += 32;\n        }\n        if (xc >= 0x10000) {\n            xc >>= 16;\n            msb += 16;\n        }\n        if (xc >= 0x100) {\n            xc >>= 8;\n            msb += 8;\n        }\n        if (xc >= 0x10) {\n            xc >>= 4;\n            msb += 4;\n        }\n        if (xc >= 0x4) {\n            xc >>= 2;\n            msb += 2;\n        }\n        if (xc >= 0x2) msb += 1; // No need to shift xc anymore\n\n        int256 result = (msb - 64) << 64;\n        uint256 ux = uint256(x) << uint256(127 - msb);\n        for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n            ux *= ux;\n            uint256 b = ux >> 255;\n            ux >>= 127 + b;\n            result += bit * int256(b);\n        }\n\n        return int128(result);\n    }\n\n    /**\n     * Calculate natural logarithm of x.  Revert if x <= 0.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return signed 64.64-bit fixed point number\n     */\n    function ln(int128 x) internal pure returns (int128) {\n        require(x > 0);\n\n        return int128((uint256(log_2(x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128);\n    }\n}\n\n\n// Dependency file: contracts/truefi/interface/ICrvPriceOracle.sol\n\n// pragma solidity 0.6.10;\n\ninterface ICrvPriceOracle {\n    function usdToCrv(uint256 amount) external view returns (uint256);\n\n    function crvToUsd(uint256 amount) external view returns (uint256);\n}\n\n\n// Dependency file: contracts/common/interface/IPauseableContract.sol\n\n\n// pragma solidity 0.6.10;\n\n/**\n * @dev interface to allow standard pause function\n */\ninterface IPauseableContract {\n    function setPauseStatus(bool pauseStatus) external;\n}\n\n\n// Dependency file: contracts/truefi2/interface/ITrueLender2.sol\n\n// pragma solidity 0.6.10;\n\n// import {ITrueFiPool2} from \"contracts/truefi2/interface/ITrueFiPool2.sol\";\n\ninterface ITrueLender2 {\n    // @dev calculate overall value of the pools\n    function value(ITrueFiPool2 pool) external view returns (uint256);\n\n    // @dev distribute a basket of tokens for exiting user\n    function distribute(\n        address recipient,\n        uint256 numerator,\n        uint256 denominator\n    ) external;\n}\n\n\n// Dependency file: contracts/truefi2/interface/IERC20WithDecimals.sol\n\n// pragma solidity 0.6.10;\n\n// import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20WithDecimals is IERC20 {\n    function decimals() external view returns (uint256);\n}\n\n\n// Dependency file: contracts/truefi2/interface/ITrueFiPoolOracle.sol\n\n// pragma solidity 0.6.10;\n\n// import {IERC20WithDecimals} from \"contracts/truefi2/interface/IERC20WithDecimals.sol\";\n\n/**\n * @dev Oracle that converts any token to and from TRU\n * Used for liquidations and valuing of liquidated TRU in the pool\n */\ninterface ITrueFiPoolOracle {\n    // token address\n    function token() external view returns (IERC20WithDecimals);\n\n    // amount of tokens 1 TRU is worth\n    function truToToken(uint256 truAmount) external view returns (uint256);\n\n    // amount of TRU 1 token is worth\n    function tokenToTru(uint256 tokenAmount) external view returns (uint256);\n\n    // USD price of token with 18 decimals\n    function tokenToUsd(uint256 tokenAmount) external view returns (uint256);\n}\n\n\n// Dependency file: contracts/truefi2/interface/I1Inch3.sol\n\n// pragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\ninterface I1Inch3 {\n    struct SwapDescription {\n        address srcToken;\n        address dstToken;\n        address srcReceiver;\n        address dstReceiver;\n        uint256 amount;\n        uint256 minReturnAmount;\n        uint256 flags;\n        bytes permit;\n    }\n\n    function swap(\n        address caller,\n        SwapDescription calldata desc,\n        bytes calldata data\n    )\n        external\n        returns (\n            uint256 returnAmount,\n            uint256 gasLeft,\n            uint256 chiSpent\n        );\n\n    function unoswap(\n        address srcToken,\n        uint256 amount,\n        uint256 minReturn,\n        bytes32[] calldata /* pools */\n    ) external payable returns (uint256 returnAmount);\n}\n\n\n// Dependency file: contracts/truefi2/interface/ITrueFiPool2.sol\n\n// pragma solidity 0.6.10;\n\n// import {ERC20, IERC20} from \"contracts/common/UpgradeableERC20.sol\";\n// import {ITrueLender2} from \"contracts/truefi2/interface/ITrueLender2.sol\";\n// import {ITrueFiPoolOracle} from \"contracts/truefi2/interface/ITrueFiPoolOracle.sol\";\n// import {I1Inch3} from \"contracts/truefi2/interface/I1Inch3.sol\";\n\ninterface ITrueFiPool2 is IERC20 {\n    function initialize(\n        ERC20 _token,\n        ERC20 _stakingToken,\n        ITrueLender2 _lender,\n        I1Inch3 __1Inch,\n        address __owner\n    ) external;\n\n    function token() external view returns (ERC20);\n\n    function oracle() external view returns (ITrueFiPoolOracle);\n\n    /**\n     * @dev Join the pool by depositing tokens\n     * @param amount amount of tokens to deposit\n     */\n    function join(uint256 amount) external;\n\n    /**\n     * @dev borrow from pool\n     * 1. Transfer TUSD to sender\n     * 2. Only lending pool should be allowed to call this\n     */\n    function borrow(uint256 amount) external;\n\n    /**\n     * @dev pay borrowed money back to pool\n     * 1. Transfer TUSD from sender\n     * 2. Only lending pool should be allowed to call this\n     */\n    function repay(uint256 currencyAmount) external;\n}\n\n\n// Root file: contracts/truefi/TrueFiPool.sol\n\npragma solidity 0.6.10;\n\n// import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// import {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n// import {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n// import {ERC20} from \"contracts/common/UpgradeableERC20.sol\";\n// import {Ownable} from \"contracts/common/UpgradeableOwnable.sol\";\n// import {ICurveGauge, ICurveMinter, ICurvePool} from \"contracts/truefi/interface/ICurve.sol\";\n// import {ITrueFiPool} from \"contracts/truefi/interface/ITrueFiPool.sol\";\n// import {ITrueLender} from \"contracts/truefi/interface/ITrueLender.sol\";\n// import {IUniswapRouter} from \"contracts/truefi/interface/IUniswapRouter.sol\";\n// import {ABDKMath64x64} from \"contracts/truefi/Log.sol\";\n// import {ICrvPriceOracle} from \"contracts/truefi/interface/ICrvPriceOracle.sol\";\n// import {IPauseableContract} from \"contracts/common/interface/IPauseableContract.sol\";\n// import {ITrueFiPool2, ITrueFiPoolOracle, ITrueLender2} from \"contracts/truefi2/interface/ITrueFiPool2.sol\";\n\n/**\n * @title TrueFi Pool\n * @dev Lending pool which uses curve.fi to store idle funds\n * Earn high interest rates on currency deposits through uncollateralized loans\n *\n * Funds deposited in this pool are not fully liquid. Liquidity\n * Exiting the pool has 2 options:\n * - withdraw a basket of LoanTokens backing the pool\n * - take an exit penalty depending on pool liquidity\n * After exiting, an account will need to wait for LoanTokens to expire and burn them\n * It is recommended to perform a zap or swap tokens on Uniswap for increased liquidity\n *\n * Funds are managed through an external function to save gas on deposits\n */\ncontract TrueFiPool is ITrueFiPool, IPauseableContract, ERC20, ReentrancyGuard, Ownable {\n    using SafeMath for uint256;\n\n    // ================ WARNING ==================\n    // ===== THIS CONTRACT IS INITIALIZABLE ======\n    // === STORAGE VARIABLES ARE DECLARED BELOW ==\n    // REMOVAL OR REORDER OF VARIABLES WILL RESULT\n    // ========= IN STORAGE CORRUPTION ===========\n\n    ICurvePool public _curvePool;\n    ICurveGauge public _curveGauge;\n    IERC20 public token;\n    ITrueLender public _lender;\n    ICurveMinter public _minter;\n    IUniswapRouter public _uniRouter;\n\n    // fee for deposits\n    uint256 public joiningFee;\n    // track claimable fees\n    uint256 public claimableFees;\n\n    mapping(address => uint256) latestJoinBlock;\n\n    IERC20 public _stakeToken;\n\n    // cache values during sync for gas optimization\n    bool private inSync;\n    uint256 private yTokenValueCache;\n    uint256 private loansValueCache;\n\n    // TRU price oracle\n    ITrueFiPoolOracle public oracle;\n\n    // fund manager can call functions to help manage pool funds\n    // fund manager can be set to 0 or governance\n    address public fundsManager;\n\n    // allow pausing of deposits\n    bool public pauseStatus;\n\n    // CRV price oracle\n    ICrvPriceOracle public _crvOracle;\n\n    ITrueLender2 public _lender2;\n\n    // ======= STORAGE DECLARATION END ============\n\n    // curve.fi data\n    uint8 constant N_TOKENS = 4;\n    uint8 constant TUSD_INDEX = 3;\n\n    uint256 constant MAX_PRICE_SLIPPAGE = 200; // 2%\n\n    /**\n     * @dev Emitted when TrueFi oracle was changed\n     * @param newOracle New oracle address\n     */\n    event TruOracleChanged(ITrueFiPoolOracle newOracle);\n\n    /**\n     * @dev Emitted when CRV oracle was changed\n     * @param newOracle New oracle address\n     */\n    event CrvOracleChanged(ICrvPriceOracle newOracle);\n\n    /**\n     * @dev Emitted when funds manager is changed\n     * @param newManager New manager address\n     */\n    event FundsManagerChanged(address newManager);\n\n    /**\n     * @dev Emitted when fee is changed\n     * @param newFee New fee\n     */\n    event JoiningFeeChanged(uint256 newFee);\n\n    /**\n     * @dev Emitted when someone joins the pool\n     * @param staker Account staking\n     * @param deposited Amount deposited\n     * @param minted Amount of pool tokens minted\n     */\n    event Joined(address indexed staker, uint256 deposited, uint256 minted);\n\n    /**\n     * @dev Emitted when someone exits the pool\n     * @param staker Account exiting\n     * @param amount Amount unstaking\n     */\n    event Exited(address indexed staker, uint256 amount);\n\n    /**\n     * @dev Emitted when funds are flushed into curve.fi\n     * @param currencyAmount Amount of tokens deposited\n     */\n    event Flushed(uint256 currencyAmount);\n\n    /**\n     * @dev Emitted when funds are pulled from curve.fi\n     * @param yAmount Amount of pool tokens\n     */\n    event Pulled(uint256 yAmount);\n\n    /**\n     * @dev Emitted when funds are borrowed from pool\n     * @param borrower Borrower address\n     * @param amount Amount of funds borrowed from pool\n     * @param fee Fees collected from this transaction\n     */\n    event Borrow(address borrower, uint256 amount, uint256 fee);\n\n    /**\n     * @dev Emitted when borrower repays the pool\n     * @param payer Address of borrower\n     * @param amount Amount repaid\n     */\n    event Repaid(address indexed payer, uint256 amount);\n\n    /**\n     * @dev Emitted when fees are collected\n     * @param beneficiary Account to receive fees\n     * @param amount Amount of fees collected\n     */\n    event Collected(address indexed beneficiary, uint256 amount);\n\n    /**\n     * @dev Emitted when joining is paused or unpaused\n     * @param pauseStatus New pausing status\n     */\n    event PauseStatusChanged(bool pauseStatus);\n\n    /**\n     * @dev only lender can perform borrowing or repaying\n     */\n    modifier onlyLender() {\n        require(msg.sender == address(_lender) || msg.sender == address(_lender2), \"TrueFiPool: Caller is not the lender\");\n        _;\n    }\n\n    /**\n     * @dev pool can only be joined when it's unpaused\n     */\n    modifier joiningNotPaused() {\n        require(!pauseStatus, \"TrueFiPool: Joining the pool is paused\");\n        _;\n    }\n\n    /**\n     * @dev only lender can perform borrowing or repaying\n     */\n    modifier onlyOwnerOrManager() {\n        require(msg.sender == owner() || msg.sender == fundsManager, \"TrueFiPool: Caller is neither owner nor funds manager\");\n        _;\n    }\n\n    /**\n     * @dev ensure than as a result of running a function,\n     * balance of `token` increases by at least `expectedGain`\n     */\n    modifier exchangeProtector(uint256 expectedGain, IERC20 _token) {\n        uint256 balanceBefore = _token.balanceOf(address(this));\n        _;\n        uint256 balanceDiff = _token.balanceOf(address(this)).sub(balanceBefore);\n        require(balanceDiff >= conservativePriceEstimation(expectedGain), \"TrueFiPool: Not optimal exchange\");\n    }\n\n    /**\n     * Sync values to avoid making expensive calls multiple times\n     * Will set inSync to true, allowing getter functions to return cached values\n     * Wipes cached values to save gas\n     */\n    modifier sync() {\n        // sync\n        yTokenValueCache = yTokenValue();\n        loansValueCache = loansValue();\n        inSync = true;\n        _;\n        // wipe\n        inSync = false;\n        yTokenValueCache = 0;\n        loansValueCache = 0;\n    }\n\n    /// @dev support borrow function from pool V2\n    function borrow(uint256 amount) external {\n        borrow(amount, 0);\n    }\n\n    /**\n     * @dev get currency token address\n     * @return currency token address\n     */\n    function currencyToken() public override view returns (IERC20) {\n        return token;\n    }\n\n    /**\n     * @dev get stake token address\n     * @return stake token address\n     */\n    function stakeToken() public override view returns (IERC20) {\n        return _stakeToken;\n    }\n\n    /**\n     * @dev set TrueLenderV2\n     */\n    function setLender2(ITrueLender2 lender2) public onlyOwner {\n        require(address(_lender2) == address(0), \"TrueFiPool: Lender 2 is already set\");\n        _lender2 = lender2;\n    }\n\n    /**\n     * @dev set funds manager address\n     */\n    function setFundsManager(address newFundsManager) public onlyOwner {\n        fundsManager = newFundsManager;\n        emit FundsManagerChanged(newFundsManager);\n    }\n\n    /**\n     * @dev set TrueFi price oracle token address\n     * @param newOracle new oracle address\n     */\n    function setTruOracle(ITrueFiPoolOracle newOracle) public onlyOwner {\n        oracle = newOracle;\n        emit TruOracleChanged(newOracle);\n    }\n\n    /**\n     * @dev set CRV price oracle token address\n     * @param newOracle new oracle address\n     */\n    function setCrvOracle(ICrvPriceOracle newOracle) public onlyOwner {\n        _crvOracle = newOracle;\n        emit CrvOracleChanged(newOracle);\n    }\n\n    /**\n     * @dev Allow pausing of deposits in case of emergency\n     * @param status New deposit status\n     */\n    function setPauseStatus(bool status) external override onlyOwnerOrManager {\n        pauseStatus = status;\n        emit PauseStatusChanged(status);\n    }\n\n    /**\n     * @dev Get total balance of stake tokens\n     * @return Balance of stake tokens in this contract\n     */\n    function stakeTokenBalance() public view returns (uint256) {\n        return _stakeToken.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Get total balance of CRV tokens\n     * @return Balance of stake tokens in this contract\n     */\n    function crvBalance() public view returns (uint256) {\n        if (address(_minter) == address(0)) {\n            return 0;\n        }\n        return _minter.token().balanceOf(address(this));\n    }\n\n    /**\n     * @dev Get total balance of curve.fi pool tokens\n     * @return Balance of y pool tokens in this contract\n     */\n    function yTokenBalance() public view returns (uint256) {\n        return _curvePool.token().balanceOf(address(this)).add(_curveGauge.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Virtual value of yCRV tokens in the pool\n     * Will return sync value if inSync\n     * @return yTokenValue in USD.\n     */\n    function yTokenValue() public view returns (uint256) {\n        if (inSync) {\n            return yTokenValueCache;\n        }\n        return yTokenBalance().mul(_curvePool.curve().get_virtual_price()).div(1 ether);\n    }\n\n    /**\n     * @dev Price of TRU in USD\n     * @return Oracle price of TRU in USD\n     */\n    function truValue() public view returns (uint256) {\n        uint256 balance = stakeTokenBalance();\n        if (balance == 0 || address(oracle) == address(0)) {\n            return 0;\n        }\n        return conservativePriceEstimation(oracle.truToToken(balance));\n    }\n\n    /**\n     * @dev Price of CRV in USD\n     * @return Oracle price of TRU in USD\n     */\n    function crvValue() public view returns (uint256) {\n        uint256 balance = crvBalance();\n        if (balance == 0 || address(_crvOracle) == address(0)) {\n            return 0;\n        }\n        return conservativePriceEstimation(_crvOracle.crvToUsd(balance));\n    }\n\n    /**\n     * @dev Virtual value of liquid assets in the pool\n     * @return Virtual liquid value of pool assets\n     */\n    function liquidValue() public view returns (uint256) {\n        return currencyBalance().add(yTokenValue());\n    }\n\n    /**\n     * @dev Calculate pool value in TUSD\n     * \"virtual price\" of entire pool - LoanTokens, TUSD, curve y pool tokens\n     * @return pool value in USD\n     */\n    function poolValue() public view returns (uint256) {\n        // this assumes defaulted loans are worth their full value\n        return liquidValue().add(loansValue()).add(crvValue());\n    }\n\n    /**\n     * @dev Virtual value of loan assets in the pool\n     * Will return cached value if inSync\n     * @return Value of loans in pool\n     */\n    function loansValue() public view returns (uint256) {\n        if (inSync) {\n            return loansValueCache;\n        }\n        if (address(_lender2) != address(0)) {\n            return _lender.value().add(_lender2.value(ITrueFiPool2(address(this))));\n        }\n        return _lender.value();\n    }\n\n    /**\n     * @dev ensure enough curve.fi pool tokens are available\n     * Check if current available amount of TUSD is enough and\n     * withdraw remainder from gauge\n     * @param neededAmount amount required\n     */\n    function ensureEnoughTokensAreAvailable(uint256 neededAmount) internal {\n        uint256 currentlyAvailableAmount = _curvePool.token().balanceOf(address(this));\n        if (currentlyAvailableAmount < neededAmount) {\n            _curveGauge.withdraw(neededAmount.sub(currentlyAvailableAmount));\n        }\n    }\n\n    /**\n     * @dev set pool join fee\n     * @param fee new fee\n     */\n    function setJoiningFee(uint256 fee) external onlyOwner {\n        require(fee <= 10000, \"TrueFiPool: Fee cannot exceed transaction value\");\n        joiningFee = fee;\n        emit JoiningFeeChanged(fee);\n    }\n\n    /**\n     * @dev Join the pool by depositing currency tokens\n     * @param amount amount of currency token to deposit\n     */\n    function join(uint256 amount) external override joiningNotPaused {\n        uint256 fee = amount.mul(joiningFee).div(10000);\n        uint256 mintedAmount = mint(amount.sub(fee));\n        claimableFees = claimableFees.add(fee);\n\n        latestJoinBlock[tx.origin] = block.number;\n        require(token.transferFrom(msg.sender, address(this), amount));\n\n        emit Joined(msg.sender, amount, mintedAmount);\n    }\n\n    // prettier-ignore\n    /**\n     * @dev Exit pool\n     * This function will withdraw a basket of currencies backing the pool value\n     * @param amount amount of pool tokens to redeem for underlying tokens\n     */\n    function exit(uint256 amount) external override nonReentrant {\n        require(block.number != latestJoinBlock[tx.origin], \"TrueFiPool: Cannot join and exit in same block\");\n        require(amount <= balanceOf(msg.sender), \"TrueFiPool: insufficient funds\");\n\n        uint256 _totalSupply = totalSupply();\n\n        // get share of currency tokens kept in the pool\n        uint256 currencyAmountToTransfer = amount.mul(\n            currencyBalance()).div(_totalSupply);\n\n        // calculate amount of curve.fi pool tokens\n        uint256 curveLiquidityAmountToTransfer = amount.mul(\n            yTokenBalance()).div(_totalSupply);\n\n        // calculate amount of stake tokens\n        uint256 stakeTokenAmountToTransfer = amount.mul(\n            stakeTokenBalance()).div(_totalSupply);\n\n        // calculate amount of CRV\n        uint256 crvTokenAmountToTransfer = amount.mul(\n            crvBalance()).div(_totalSupply);\n\n        // burn tokens sent\n        _burn(msg.sender, amount);\n\n        // withdraw basket of loan tokens\n        _lender.distribute(msg.sender, amount, _totalSupply);\n        if (address(_lender2) != address(0)) {\n            _lender2.distribute(msg.sender, amount, _totalSupply);\n        }\n\n        // if currency remaining, transfer\n        if (currencyAmountToTransfer > 0) {\n            require(token.transfer(msg.sender, currencyAmountToTransfer));\n        }\n        // if curve tokens remaining, transfer\n        if (curveLiquidityAmountToTransfer > 0) {\n            ensureEnoughTokensAreAvailable(curveLiquidityAmountToTransfer);\n            require(_curvePool.token().transfer(msg.sender, curveLiquidityAmountToTransfer));\n        }\n\n        // if stake token remaining, transfer\n        if (stakeTokenAmountToTransfer > 0) {\n            require(_stakeToken.transfer(msg.sender, stakeTokenAmountToTransfer));\n        }\n\n        // if crv remaining, transfer\n        if (crvTokenAmountToTransfer > 0) {\n            require(_minter.token().transfer(msg.sender, crvTokenAmountToTransfer));\n        }\n\n        emit Exited(msg.sender, amount);\n    }\n\n    /**\n     * @dev Exit pool only with liquid tokens\n     * This function will withdraw TUSD but with a small penalty\n     * Uses the sync() modifier to reduce gas costs of using curve\n     * @param amount amount of pool tokens to redeem for underlying tokens\n     */\n    function liquidExit(uint256 amount) external nonReentrant sync {\n        require(block.number != latestJoinBlock[tx.origin], \"TrueFiPool: Cannot join and exit in same block\");\n        require(amount <= balanceOf(msg.sender), \"TrueFiPool: Insufficient funds\");\n\n        uint256 amountToWithdraw = poolValue().mul(amount).div(totalSupply());\n        amountToWithdraw = amountToWithdraw.mul(liquidExitPenalty(amountToWithdraw)).div(10000);\n        require(amountToWithdraw <= liquidValue(), \"TrueFiPool: Not enough liquidity in pool\");\n\n        // burn tokens sent\n        _burn(msg.sender, amount);\n\n        if (amountToWithdraw > currencyBalance()) {\n            removeLiquidityFromCurve(amountToWithdraw.sub(currencyBalance()));\n            require(amountToWithdraw <= currencyBalance(), \"TrueFiPool: Not enough funds were withdrawn from Curve\");\n        }\n\n        require(token.transfer(msg.sender, amountToWithdraw));\n\n        emit Exited(msg.sender, amountToWithdraw);\n    }\n\n    /**\n     * @dev Penalty (in % * 100) applied if liquid exit is performed with this amount\n     * returns 10000 if no penalty\n     */\n    function liquidExitPenalty(uint256 amount) public view returns (uint256) {\n        uint256 lv = liquidValue();\n        uint256 pv = poolValue();\n        if (amount == pv) {\n            return 10000;\n        }\n        uint256 liquidRatioBefore = lv.mul(10000).div(pv);\n        uint256 liquidRatioAfter = lv.sub(amount).mul(10000).div(pv.sub(amount));\n        return uint256(10000).sub(averageExitPenalty(liquidRatioAfter, liquidRatioBefore));\n    }\n\n    /**\n     * @dev Calculates integral of 5/(x+50)dx times 10000\n     */\n    function integrateAtPoint(uint256 x) public pure returns (uint256) {\n        return uint256(ABDKMath64x64.ln(ABDKMath64x64.fromUInt(x.add(50)))).mul(50000).div(2**64);\n    }\n\n    /**\n     * @dev Calculates average penalty on interval [from; to]\n     * @return average exit penalty\n     */\n    function averageExitPenalty(uint256 from, uint256 to) public pure returns (uint256) {\n        require(from <= to, \"TrueFiPool: To precedes from\");\n        if (from == 10000) {\n            // When all liquid, don't penalize\n            return 0;\n        }\n        if (from == to) {\n            return uint256(50000).div(from.add(50));\n        }\n        return integrateAtPoint(to).sub(integrateAtPoint(from)).div(to.sub(from));\n    }\n\n    /**\n     * @dev Deposit idle funds into curve.fi pool and stake in gauge\n     * Called by owner to help manage funds in pool and save on gas for deposits\n     * @param currencyAmount Amount of funds to deposit into curve\n     * @param minMintAmount Minimum amount to mint\n     */\n    function flush(uint256 currencyAmount, uint256 minMintAmount) external onlyOwner {\n        require(currencyAmount <= currencyBalance(), \"TrueFiPool: Insufficient currency balance\");\n\n        // add TUSD to curve\n        _flush(currencyAmount, minMintAmount);\n\n        // stake yCurve tokens in gauge\n        uint256 yBalance = _curvePool.token().balanceOf(address(this));\n        _curvePool.token().approve(address(_curveGauge), yBalance);\n        _curveGauge.deposit(yBalance);\n\n        emit Flushed(currencyAmount);\n    }\n\n    function _flush(uint256 currencyAmount, uint256 minMintAmount)\n        internal\n        exchangeProtector(calcTokenAmount(currencyAmount), _curvePool.token())\n    {\n        uint256[N_TOKENS] memory amounts = [0, 0, 0, currencyAmount];\n\n        token.approve(address(_curvePool), currencyAmount);\n        _curvePool.add_liquidity(amounts, minMintAmount);\n    }\n\n    /**\n     * @dev Remove liquidity from curve\n     * @param yAmount amount of curve pool tokens\n     * @param minCurrencyAmount minimum amount of tokens to withdraw\n     */\n    function pull(uint256 yAmount, uint256 minCurrencyAmount) external onlyOwnerOrManager {\n        require(yAmount <= yTokenBalance(), \"TrueFiPool: Insufficient Curve liquidity balance\");\n\n        // unstake in gauge\n        ensureEnoughTokensAreAvailable(yAmount);\n\n        // remove TUSD from curve\n        _curvePool.token().approve(address(_curvePool), yAmount);\n        _curvePool.remove_liquidity_one_coin(yAmount, TUSD_INDEX, minCurrencyAmount, false);\n\n        emit Pulled(yAmount);\n    }\n\n    // prettier-ignore\n    /**\n     * @dev Remove liquidity from curve if necessary and transfer to lender\n     * @param amount amount for lender to withdraw\n     */\n    function borrow(uint256 amount, uint256 fee) public override nonReentrant onlyLender {\n        // if there is not enough TUSD, withdraw from curve\n        if (amount > currencyBalance()) {\n            removeLiquidityFromCurve(amount.sub(currencyBalance()));\n            require(amount <= currencyBalance(), \"TrueFiPool: Not enough funds in pool to cover borrow\");\n        }\n\n        mint(fee);\n        require(token.transfer(msg.sender, amount.sub(fee)));\n\n        emit Borrow(msg.sender, amount, fee);\n    }\n\n    function removeLiquidityFromCurve(uint256 amountToWithdraw) internal {\n        // get rough estimate of how much yCRV we should sell\n        uint256 roughCurveTokenAmount = calcTokenAmount(amountToWithdraw).mul(1005).div(1000);\n        require(roughCurveTokenAmount <= yTokenBalance(), \"TrueFiPool: Not enough Curve liquidity tokens in pool to cover borrow\");\n        // pull tokens from gauge\n        ensureEnoughTokensAreAvailable(roughCurveTokenAmount);\n        // remove TUSD from curve\n        _curvePool.token().approve(address(_curvePool), roughCurveTokenAmount);\n        uint256 minAmount = roughCurveTokenAmount.mul(_curvePool.curve().get_virtual_price()).mul(999).div(1000).div(1 ether);\n        _curvePool.remove_liquidity_one_coin(roughCurveTokenAmount, TUSD_INDEX, minAmount, false);\n    }\n\n    /**\n     * @dev repay debt by transferring tokens to the contract\n     * @param currencyAmount amount to repay\n     */\n    function repay(uint256 currencyAmount) external override onlyLender {\n        require(token.transferFrom(msg.sender, address(this), currencyAmount));\n        emit Repaid(msg.sender, currencyAmount);\n    }\n\n    /**\n     * @dev Collect CRV tokens minted by staking at gauge\n     */\n    function collectCrv() external onlyOwnerOrManager {\n        _minter.mint(address(_curveGauge));\n    }\n\n    /**\n     * @dev Sell collected CRV on Uniswap\n     * - Selling CRV is managed by the contract owner\n     * - Calculations can be made off-chain and called based on market conditions\n     * - Need to pass path of exact pairs to go through while executing exchange\n     * For example, CRV -> WETH -> TUSD\n     *\n     * @param amountIn see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens\n     * @param amountOutMin see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens\n     * @param path see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens\n     */\n    function sellCrv(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) public exchangeProtector(_crvOracle.crvToUsd(amountIn), token) {\n        _minter.token().approve(address(_uniRouter), amountIn);\n        _uniRouter.swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), block.timestamp + 1 hours);\n    }\n\n    /**\n     * @dev Sell collected TRU on Uniswap\n     * - Selling TRU is managed by the contract owner\n     * - Calculations can be made off-chain and called based on market conditions\n     * - Need to pass path of exact pairs to go through while executing exchange\n     * For example, CRV -> WETH -> TUSD\n     *\n     * @param amountIn see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens\n     * @param amountOutMin see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens\n     * @param path see https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensfortokens\n     */\n    function sellStakeToken(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) public exchangeProtector(oracle.truToToken(amountIn), token) {\n        _stakeToken.approve(address(_uniRouter), amountIn);\n        _uniRouter.swapExactTokensForTokens(amountIn, amountOutMin, path, address(this), block.timestamp + 1 hours);\n    }\n\n    /**\n     * @dev Claim fees from the pool\n     * @param beneficiary account to send funds to\n     */\n    function collectFees(address beneficiary) external onlyOwnerOrManager {\n        uint256 amount = claimableFees;\n        claimableFees = 0;\n\n        if (amount > 0) {\n            require(token.transfer(beneficiary, amount));\n        }\n\n        emit Collected(beneficiary, amount);\n    }\n\n    /**\n     * @notice Expected amount of minted Curve.fi yDAI/yUSDC/yUSDT/yTUSD tokens.\n     * Can be used to control slippage\n     * Called in flush() function\n     * @param currencyAmount amount to calculate for\n     * @return expected amount minted given currency amount\n     */\n    function calcTokenAmount(uint256 currencyAmount) public view returns (uint256) {\n        // prettier-ignore\n        uint256 yTokenAmount = currencyAmount.mul(1e18).div(\n            _curvePool.coins(TUSD_INDEX).getPricePerFullShare());\n        uint256[N_TOKENS] memory yAmounts = [0, 0, 0, yTokenAmount];\n        return _curvePool.curve().calc_token_amount(yAmounts, true);\n    }\n\n    /**\n     * @dev Currency token balance\n     * @return Currency token balance\n     */\n    function currencyBalance() public view returns (uint256) {\n        return token.balanceOf(address(this)).sub(claimableFees);\n    }\n\n    /**\n     * @param depositedAmount Amount of currency deposited\n     * @return amount minted from this transaction\n     */\n    function mint(uint256 depositedAmount) internal returns (uint256) {\n        uint256 mintedAmount = depositedAmount;\n        if (mintedAmount == 0) {\n            return mintedAmount;\n        }\n\n        // first staker mints same amount deposited\n        if (totalSupply() > 0) {\n            mintedAmount = totalSupply().mul(depositedAmount).div(poolValue());\n        }\n        // mint pool tokens\n        _mint(msg.sender, mintedAmount);\n\n        return mintedAmount;\n    }\n\n    /**\n     * @dev Calculate price minus max percentage of slippage during exchange\n     * This will lead to the pool value become a bit undervalued\n     * compared to the oracle price but will ensure that the value doesn't drop\n     * when token exchanges are performed.\n     */\n    function conservativePriceEstimation(uint256 price) internal pure returns (uint256) {\n        return price.mul(uint256(10000).sub(MAX_PRICE_SLIPPAGE)).div(10000);\n    }\n}\n"}}}