{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Ethcrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\n/**\r\n * @title Ethcrow\r\n * @dev A low-fee decentralized Ethereum escrow service.\r\n * @author quiprr (@quiprr)\r\n */\r\ncontract Ethcrow {\r\n    struct EscrowDeposit {\r\n        address beneficiary;\r\n        address arbiter;\r\n        uint256 amount;\r\n    }\r\n    mapping(address => EscrowDeposit) outstanding;\r\n\r\n    event Deposit(address indexed depositor, address indexed beneficiary, address indexed arbiter, uint256 amount);\r\n    event Release(address indexed depositor, address indexed beneficiary, address indexed arbiter, uint256 amount);\r\n    event Cancellation(address indexed depositor, address indexed beneficiary, address indexed arbiter, uint256 amount);\r\n\r\n    function currentDeposit(address _depositor) public view returns (address beneficiary, address arbiter, uint256 amount) {\r\n        return (outstanding[_depositor].beneficiary, outstanding[_depositor].arbiter, outstanding[_depositor].amount);\r\n    }\r\n\r\n    function deposit(address _beneficiary) public payable {\r\n        require(outstanding[msg.sender].amount == 0, \"Cannot have more than one outstanding deposit\");\r\n        require(_beneficiary != address(0) && _beneficiary != msg.sender, \"Beneficiary cannot be the zero or your own address\");\r\n        require(msg.value > 0, \"Deposit value must be greater than zero\");\r\n\r\n        outstanding[msg.sender].beneficiary = _beneficiary;\r\n        outstanding[msg.sender].amount = msg.value;\r\n\r\n        emit Deposit(msg.sender, _beneficiary, address(0), msg.value);\r\n    }\r\n\r\n    function deposit(address _beneficiary, address _arbiter) public payable {\r\n        require(outstanding[msg.sender].amount == 0, \"Cannot have more than one outstanding deposit\");\r\n        require(_beneficiary != address(0) && _beneficiary != msg.sender, \"Beneficiary cannot be the zero or your own address\");\r\n        require(_arbiter != address(0) && _arbiter != msg.sender, \"Arbiter cannot be the zero or your own address\");\r\n        require(msg.value > 0, \"Deposit value must be greater than zero\");\r\n\r\n        outstanding[msg.sender].beneficiary = _beneficiary;\r\n        outstanding[msg.sender].arbiter = _arbiter;\r\n        outstanding[msg.sender].amount = msg.value;\r\n\r\n        emit Deposit(msg.sender, _beneficiary, _arbiter, msg.value);\r\n    }\r\n\r\n    function release(address _depositor) public {\r\n        require(outstanding[_depositor].amount != 0, \"No outstanding deposit\");\r\n        require(msg.sender == _depositor || msg.sender == outstanding[_depositor].arbiter, \"You are not the depositor or the arbiter\");\r\n\r\n        address beneficiary = outstanding[_depositor].beneficiary;\r\n        address arbiter = outstanding[_depositor].arbiter;\r\n        uint256 amount = outstanding[_depositor].amount;\r\n\r\n        delete outstanding[_depositor];\r\n\r\n        (bool success, ) = payable(beneficiary).call{\r\n            value: amount\r\n        }(\"\");\r\n        require(success, \"Failed to withdraw\");\r\n\r\n        emit Release(_depositor, beneficiary, arbiter, amount);\r\n    }\r\n\r\n    function cancel(address _depositor) public {\r\n        require(outstanding[_depositor].amount != 0, \"No outstanding deposit\");\r\n        require(outstanding[_depositor].beneficiary == msg.sender || outstanding[_depositor].arbiter == msg.sender, \"You are not the beneficiary or arbiter\");\r\n\r\n        address beneficiary = outstanding[_depositor].beneficiary;\r\n        address arbiter = outstanding[_depositor].arbiter;\r\n        uint256 amount = outstanding[_depositor].amount;\r\n        \r\n        delete outstanding[_depositor];\r\n\r\n        (bool success, ) = payable(_depositor).call{\r\n            value: amount\r\n        }(\"\");\r\n        require(success, \"Failed to withdraw\");\r\n\r\n        emit Cancellation(_depositor, beneficiary, arbiter, amount);\r\n    }\r\n}"
    }
  }
}