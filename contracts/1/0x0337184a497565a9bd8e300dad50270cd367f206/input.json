{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DynamicLiquidTokenConverter.sol":{"content":"// SPDX-License-Identifier: Bprotocol Foundation (Bancor) LICENSE\r\n\r\n// File: solidity/contracts/utility/interfaces/IOwned.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ninterface IOwned {\r\n    // this function isn't since the compiler emits automatically generated getter functions as external\r\n    function owner() external view returns (address);\r\n\r\n    function transferOwnership(address _newOwner) external;\r\n    function acceptOwnership() external;\r\n}\r\n\r\n// File: solidity/contracts/converter/interfaces/IConverterAnchor.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/*\r\n    Converter Anchor interface\r\n*/\r\ninterface IConverterAnchor is IOwned {\r\n}\r\n\r\n// File: solidity/contracts/token/interfaces/IERC20Token.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ninterface IERC20Token {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n}\r\n\r\n// File: solidity/contracts/utility/interfaces/IWhitelist.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/*\r\n    Whitelist interface\r\n*/\r\ninterface IWhitelist {\r\n    function isWhitelisted(address _address) external view returns (bool);\r\n}\r\n\r\n// File: solidity/contracts/converter/interfaces/IConverter.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n    Converter interface\r\n*/\r\ninterface IConverter is IOwned {\r\n    function converterType() external pure returns (uint16);\r\n    function anchor() external view returns (IConverterAnchor);\r\n    function isActive() external view returns (bool);\r\n\r\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) external view returns (uint256, uint256);\r\n    function convert(IERC20Token _sourceToken,\r\n                     IERC20Token _targetToken,\r\n                     uint256 _amount,\r\n                     address _trader,\r\n                     address payable _beneficiary) external payable returns (uint256);\r\n\r\n    function conversionWhitelist() external view returns (IWhitelist);\r\n    function conversionFee() external view returns (uint32);\r\n    function maxConversionFee() external view returns (uint32);\r\n    function reserveBalance(IERC20Token _reserveToken) external view returns (uint256);\r\n    receive() external payable;\r\n\r\n    function transferAnchorOwnership(address _newOwner) external;\r\n    function acceptAnchorOwnership() external;\r\n    function setConversionFee(uint32 _conversionFee) external;\r\n    function setConversionWhitelist(IWhitelist _whitelist) external;\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) external;\r\n    function withdrawETH(address payable _to) external;\r\n    function addReserve(IERC20Token _token, uint32 _ratio) external;\r\n\r\n    // deprecated, backward compatibility\r\n    function token() external view returns (IConverterAnchor);\r\n    function transferTokenOwnership(address _newOwner) external;\r\n    function acceptTokenOwnership() external;\r\n    function connectors(IERC20Token _address) external view returns (uint256, uint32, bool, bool, bool);\r\n    function getConnectorBalance(IERC20Token _connectorToken) external view returns (uint256);\r\n    function connectorTokens(uint256 _index) external view returns (IERC20Token);\r\n    function connectorTokenCount() external view returns (uint16);\r\n}\r\n\r\n// File: solidity/contracts/converter/interfaces/IConverterUpgrader.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/*\r\n    Converter Upgrader interface\r\n*/\r\ninterface IConverterUpgrader {\r\n    function upgrade(bytes32 _version) external;\r\n    function upgrade(uint16 _version) external;\r\n}\r\n\r\n// File: solidity/contracts/converter/interfaces/IBancorFormula.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/*\r\n    Bancor Formula interface\r\n*/\r\ninterface IBancorFormula {\r\n    function purchaseTargetAmount(uint256 _supply,\r\n                                  uint256 _reserveBalance,\r\n                                  uint32 _reserveWeight,\r\n                                  uint256 _amount)\r\n                                  external view returns (uint256);\r\n\r\n    function saleTargetAmount(uint256 _supply,\r\n                              uint256 _reserveBalance,\r\n                              uint32 _reserveWeight,\r\n                              uint256 _amount)\r\n                              external view returns (uint256);\r\n\r\n    function crossReserveTargetAmount(uint256 _sourceReserveBalance,\r\n                                      uint32 _sourceReserveWeight,\r\n                                      uint256 _targetReserveBalance,\r\n                                      uint32 _targetReserveWeight,\r\n                                      uint256 _amount)\r\n                                      external view returns (uint256);\r\n\r\n    function fundCost(uint256 _supply,\r\n                      uint256 _reserveBalance,\r\n                      uint32 _reserveRatio,\r\n                      uint256 _amount)\r\n                      external view returns (uint256);\r\n\r\n    function fundSupplyAmount(uint256 _supply,\r\n                              uint256 _reserveBalance,\r\n                              uint32 _reserveRatio,\r\n                              uint256 _amount)\r\n                              external view returns (uint256);\r\n\r\n    function liquidateReserveAmount(uint256 _supply,\r\n                                    uint256 _reserveBalance,\r\n                                    uint32 _reserveRatio,\r\n                                    uint256 _amount)\r\n                                    external view returns (uint256);\r\n\r\n    function balancedWeights(uint256 _primaryReserveStakedBalance,\r\n                             uint256 _primaryReserveBalance,\r\n                             uint256 _secondaryReserveBalance,\r\n                             uint256 _reserveRateNumerator,\r\n                             uint256 _reserveRateDenominator)\r\n                             external view returns (uint32, uint32);\r\n}\r\n\r\n// File: solidity/contracts/utility/Owned.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n  * @dev Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public override owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n      * @dev triggered when the owner is updated\r\n      *\r\n      * @param _prevOwner previous owner\r\n      * @param _newOwner  new owner\r\n    */\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n      * @dev initializes a new Owned instance\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        _ownerOnly();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _ownerOnly() internal view {\r\n        require(msg.sender == owner, \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev allows transferring the contract ownership\r\n      * the new owner still needs to accept the transfer\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public override ownerOnly {\r\n        require(_newOwner != owner, \"ERR_SAME_OWNER\");\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n      * @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() override public {\r\n        require(msg.sender == newOwner, \"ERR_ACCESS_DENIED\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: solidity/contracts/utility/Utils.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n  * @dev Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    // verifies that a value is greater than zero\r\n    modifier greaterThanZero(uint256 _value) {\r\n        _greaterThanZero(_value);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _greaterThanZero(uint256 _value) internal pure {\r\n        require(_value > 0, \"ERR_ZERO_VALUE\");\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        _validAddress(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validAddress(address _address) internal pure {\r\n        require(_address != address(0), \"ERR_INVALID_ADDRESS\");\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        _notThis(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _notThis(address _address) internal view {\r\n        require(_address != address(this), \"ERR_ADDRESS_IS_SELF\");\r\n    }\r\n}\r\n\r\n// File: solidity/contracts/utility/interfaces/IContractRegistry.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ninterface IContractRegistry {\r\n    function addressOf(bytes32 _contractName) external view returns (address);\r\n}\r\n\r\n// File: solidity/contracts/utility/ContractRegistryClient.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n/**\r\n  * @dev Base contract for ContractRegistry clients\r\n*/\r\ncontract ContractRegistryClient is Owned, Utils {\r\n    bytes32 internal constant CONTRACT_REGISTRY = \"ContractRegistry\";\r\n    bytes32 internal constant BANCOR_NETWORK = \"BancorNetwork\";\r\n    bytes32 internal constant BANCOR_FORMULA = \"BancorFormula\";\r\n    bytes32 internal constant CONVERTER_FACTORY = \"ConverterFactory\";\r\n    bytes32 internal constant CONVERSION_PATH_FINDER = \"ConversionPathFinder\";\r\n    bytes32 internal constant CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\r\n    bytes32 internal constant CONVERTER_REGISTRY = \"BancorConverterRegistry\";\r\n    bytes32 internal constant CONVERTER_REGISTRY_DATA = \"BancorConverterRegistryData\";\r\n    bytes32 internal constant BNT_TOKEN = \"BNTToken\";\r\n    bytes32 internal constant BANCOR_X = \"BancorX\";\r\n    bytes32 internal constant BANCOR_X_UPGRADER = \"BancorXUpgrader\";\r\n    bytes32 internal constant CHAINLINK_ORACLE_WHITELIST = \"ChainlinkOracleWhitelist\";\r\n\r\n    IContractRegistry public registry;      // address of the current contract-registry\r\n    IContractRegistry public prevRegistry;  // address of the previous contract-registry\r\n    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\r\n\r\n    /**\r\n      * @dev verifies that the caller is mapped to the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n    */\r\n    modifier only(bytes32 _contractName) {\r\n        _only(_contractName);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _only(bytes32 _contractName) internal view {\r\n        require(msg.sender == addressOf(_contractName), \"ERR_ACCESS_DENIED\");\r\n    }\r\n\r\n    /**\r\n      * @dev initializes a new ContractRegistryClient instance\r\n      *\r\n      * @param  _registry   address of a contract-registry contract\r\n    */\r\n    constructor(IContractRegistry _registry) internal validAddress(address(_registry)) {\r\n        registry = IContractRegistry(_registry);\r\n        prevRegistry = IContractRegistry(_registry);\r\n    }\r\n\r\n    /**\r\n      * @dev updates to the new contract-registry\r\n     */\r\n    function updateRegistry() public {\r\n        // verify that this function is permitted\r\n        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, \"ERR_ACCESS_DENIED\");\r\n\r\n        // get the new contract-registry\r\n        IContractRegistry newRegistry = IContractRegistry(addressOf(CONTRACT_REGISTRY));\r\n\r\n        // verify that the new contract-registry is different and not zero\r\n        require(newRegistry != registry && address(newRegistry) != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // verify that the new contract-registry is pointing to a non-zero contract-registry\r\n        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), \"ERR_INVALID_REGISTRY\");\r\n\r\n        // save a backup of the current contract-registry before replacing it\r\n        prevRegistry = registry;\r\n\r\n        // replace the current contract-registry with the new contract-registry\r\n        registry = newRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restores the previous contract-registry\r\n    */\r\n    function restoreRegistry() public ownerOnly {\r\n        // restore the previous contract-registry\r\n        registry = prevRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev restricts the permission to update the contract-registry\r\n      *\r\n      * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\r\n    */\r\n    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) public ownerOnly {\r\n        // change the permission to update the contract-registry\r\n        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the address associated with the given contract name\r\n      *\r\n      * @param _contractName    contract name\r\n      *\r\n      * @return contract address\r\n    */\r\n    function addressOf(bytes32 _contractName) internal view returns (address) {\r\n        return registry.addressOf(_contractName);\r\n    }\r\n}\r\n\r\n// File: solidity/contracts/utility/ReentrancyGuard.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n  * @dev ReentrancyGuard\r\n  *\r\n  * The contract provides protection against re-entrancy - calling a function (directly or\r\n  * indirectly) from within itself.\r\n*/\r\ncontract ReentrancyGuard {\r\n    // true while protected code is being executed, false otherwise\r\n    bool private locked = false;\r\n\r\n    /**\r\n      * @dev ensures instantiation only by sub-contracts\r\n    */\r\n    constructor() internal {}\r\n\r\n    // protects a function against reentrancy attacks\r\n    modifier protected() {\r\n        _protected();\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _protected() internal view {\r\n        require(!locked, \"ERR_REENTRANCY\");\r\n    }\r\n}\r\n\r\n// File: solidity/contracts/utility/SafeMath.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n  * @dev Library for basic math operations with overflow/underflow protection\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n      * @dev returns the sum of _x and _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   value 1\r\n      * @param _y   value 2\r\n      *\r\n      * @return sum\r\n    */\r\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        require(z >= _x, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\r\n      *\r\n      * @param _x   minuend\r\n      * @param _y   subtrahend\r\n      *\r\n      * @return difference\r\n    */\r\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_x >= _y, \"ERR_UNDERFLOW\");\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\r\n      *\r\n      * @param _x   factor 1\r\n      * @param _y   factor 2\r\n      *\r\n      * @return product\r\n    */\r\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        // gas optimization\r\n        if (_x == 0)\r\n            return 0;\r\n\r\n        uint256 z = _x * _y;\r\n        require(z / _x == _y, \"ERR_OVERFLOW\");\r\n        return z;\r\n    }\r\n\r\n    /**\r\n      * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n      *\r\n      * @param _x   dividend\r\n      * @param _y   divisor\r\n      *\r\n      * @return quotient\r\n    */\r\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        require(_y > 0, \"ERR_DIVIDE_BY_ZERO\");\r\n        uint256 c = _x / _y;\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: solidity/contracts/utility/TokenHandler.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ncontract TokenHandler {\r\n    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256(\"approve(address,uint256)\"));\r\n    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256(\"transfer(address,uint256)\"));\r\n    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\r\n\r\n    /**\r\n      * @dev executes the ERC20 token's `approve` function and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _spender approved address\r\n      * @param _value   allowance amount\r\n    */\r\n    function safeApprove(IERC20Token _token, address _spender, uint256 _value) internal {\r\n        (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_APPROVE_FAILED');\r\n    }\r\n\r\n    /**\r\n      * @dev executes the ERC20 token's `transfer` function and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n    */\r\n    function safeTransfer(IERC20Token _token, address _to, uint256 _value) internal {\r\n       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FAILED');\r\n    }\r\n\r\n    /**\r\n      * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\r\n      * the main purpose of this function is to prevent a non standard ERC20 token\r\n      * from failing silently\r\n      *\r\n      * @param _token   ERC20 token address\r\n      * @param _from    source address\r\n      * @param _to      target address\r\n      * @param _value   transfer amount\r\n    */\r\n    function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) internal {\r\n       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FROM_FAILED');\r\n    }\r\n}\r\n\r\n// File: solidity/contracts/utility/interfaces/ITokenHolder.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n/*\r\n    Token Holder interface\r\n*/\r\ninterface ITokenHolder is IOwned {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) external;\r\n}\r\n\r\n// File: solidity/contracts/utility/TokenHolder.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev We consider every contract to be a 'token holder' since it's currently not possible\r\n  * for a contract to deny receiving tokens.\r\n  *\r\n  * The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n  * the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n  *\r\n  * Note that we use the non standard ERC-20 interface which has no return value for transfer\r\n  * in order to support both non standard as well as standard token contracts.\r\n  * see https://github.com/ethereum/solidity/issues/4116\r\n*/\r\ncontract TokenHolder is ITokenHolder, TokenHandler, Owned, Utils {\r\n    /**\r\n      * @dev withdraws tokens held by the contract and sends them to an account\r\n      * can only be called by the owner\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        virtual\r\n        override\r\n        ownerOnly\r\n        validAddress(address(_token))\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        safeTransfer(_token, _to, _amount);\r\n    }\r\n}\r\n\r\n// File: solidity/contracts/token/interfaces/IEtherToken.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/*\r\n    Ether Token interface\r\n*/\r\ninterface IEtherToken is IERC20Token {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 _amount) external;\r\n    function depositTo(address _to) external payable;\r\n    function withdrawTo(address payable _to, uint256 _amount) external;\r\n}\r\n\r\n// File: solidity/contracts/bancorx/interfaces/IBancorX.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ninterface IBancorX {\r\n    function token() external view returns (IERC20Token);\r\n    function xTransfer(bytes32 _toBlockchain, bytes32 _to, uint256 _amount, uint256 _id) external;\r\n    function getXTransferAmount(uint256 _xTransferId, address _for) external view returns (uint256);\r\n}\r\n\r\n// File: solidity/contracts/converter/ConverterBase.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n  * @dev ConverterBase\r\n  *\r\n  * The converter contains the main logic for conversions between different ERC20 tokens.\r\n  *\r\n  * It is also the upgradable part of the mechanism (note that upgrades are opt-in).\r\n  *\r\n  * The anchor must be set on construction and cannot be changed afterwards.\r\n  * Wrappers are provided for some of the anchor's functions, for easier access.\r\n  *\r\n  * Once the converter accepts ownership of the anchor, it becomes the anchor's sole controller\r\n  * and can execute any of its functions.\r\n  *\r\n  * To upgrade the converter, anchor ownership must be transferred to a new converter, along with\r\n  * any relevant data.\r\n  *\r\n  * Note that the converter can transfer anchor ownership to a new converter that\r\n  * doesn't allow upgrades anymore, for finalizing the relationship between the converter\r\n  * and the anchor.\r\n  *\r\n  * Converter types (defined as uint16 type) -\r\n  * 0 = liquid token converter\r\n  * 1 = liquidity pool v1 converter\r\n  * 2 = liquidity pool v2 converter\r\n  *\r\n  * Note that converters don't currently support tokens with transfer fees.\r\n*/\r\nabstract contract ConverterBase is IConverter, TokenHandler, TokenHolder, ContractRegistryClient, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    uint32 internal constant PPM_RESOLUTION = 1000000;\r\n    IERC20Token internal constant ETH_RESERVE_ADDRESS = IERC20Token(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n    struct Reserve {\r\n        uint256 balance;    // reserve balance\r\n        uint32 weight;      // reserve weight, represented in ppm, 1-1000000\r\n        bool deprecated1;   // deprecated\r\n        bool deprecated2;   // deprecated\r\n        bool isSet;         // true if the reserve is valid, false otherwise\r\n    }\r\n\r\n    /**\r\n      * @dev version number\r\n    */\r\n    uint16 public constant version = 40;\r\n\r\n    IConverterAnchor public override anchor;            // converter anchor contract\r\n    IWhitelist public override conversionWhitelist;     // whitelist contract with list of addresses that are allowed to use the converter\r\n    IERC20Token[] public reserveTokens;                 // ERC20 standard token addresses (prior version 17, use 'connectorTokens' instead)\r\n    mapping (IERC20Token => Reserve) public reserves;   // reserve token addresses -> reserve data (prior version 17, use 'connectors' instead)\r\n    uint32 public reserveRatio = 0;                     // ratio between the reserves and the market cap, equal to the total reserve weights\r\n    uint32 public override maxConversionFee = 0;        // maximum conversion fee for the lifetime of the contract,\r\n                                                        // represented in ppm, 0...1000000 (0 = no fee, 100 = 0.01%, 1000000 = 100%)\r\n    uint32 public override conversionFee = 0;           // current conversion fee, represented in ppm, 0...maxConversionFee\r\n    bool public constant conversionsEnabled = true;     // deprecated, backward compatibility\r\n\r\n    /**\r\n      * @dev triggered when the converter is activated\r\n      *\r\n      * @param _type        converter type\r\n      * @param _anchor      converter anchor\r\n      * @param _activated   true if the converter was activated, false if it was deactivated\r\n    */\r\n    event Activation(uint16 indexed _type, IConverterAnchor indexed _anchor, bool indexed _activated);\r\n\r\n    /**\r\n      * @dev triggered when a conversion between two tokens occurs\r\n      *\r\n      * @param _fromToken       source ERC20 token\r\n      * @param _toToken         target ERC20 token\r\n      * @param _trader          wallet that initiated the trade\r\n      * @param _amount          amount converted, in the source token\r\n      * @param _return          amount returned, minus conversion fee\r\n      * @param _conversionFee   conversion fee\r\n    */\r\n    event Conversion(\r\n        IERC20Token indexed _fromToken,\r\n        IERC20Token indexed _toToken,\r\n        address indexed _trader,\r\n        uint256 _amount,\r\n        uint256 _return,\r\n        int256 _conversionFee\r\n    );\r\n\r\n    /**\r\n      * @dev triggered when the rate between two tokens in the converter changes\r\n      * note that the event might be dispatched for rate updates between any two tokens in the converter\r\n      * note that prior to version 28, you should use the 'PriceDataUpdate' event instead\r\n      *\r\n      * @param  _token1 address of the first token\r\n      * @param  _token2 address of the second token\r\n      * @param  _rateN  rate of 1 unit of `_token1` in `_token2` (numerator)\r\n      * @param  _rateD  rate of 1 unit of `_token1` in `_token2` (denominator)\r\n    */\r\n    event TokenRateUpdate(\r\n        IERC20Token indexed _token1,\r\n        IERC20Token indexed _token2,\r\n        uint256 _rateN,\r\n        uint256 _rateD\r\n    );\r\n\r\n    /**\r\n      * @dev triggered when the conversion fee is updated\r\n      *\r\n      * @param  _prevFee    previous fee percentage, represented in ppm\r\n      * @param  _newFee     new fee percentage, represented in ppm\r\n    */\r\n    event ConversionFeeUpdate(uint32 _prevFee, uint32 _newFee);\r\n\r\n    /**\r\n      * @dev used by sub-contracts to initialize a new converter\r\n      *\r\n      * @param  _anchor             anchor governed by the converter\r\n      * @param  _registry           address of a contract registry contract\r\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n    */\r\n    constructor(\r\n        IConverterAnchor _anchor,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee\r\n    )\r\n        validAddress(address(_anchor))\r\n        ContractRegistryClient(_registry)\r\n        internal\r\n        validConversionFee(_maxConversionFee)\r\n    {\r\n        anchor = _anchor;\r\n        maxConversionFee = _maxConversionFee;\r\n    }\r\n\r\n    // ensures that the converter is active\r\n    modifier active() {\r\n        _active();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _active() internal view {\r\n        require(isActive(), \"ERR_INACTIVE\");\r\n    }\r\n\r\n    // ensures that the converter is not active\r\n    modifier inactive() {\r\n        _inactive();\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _inactive() internal view {\r\n        require(!isActive(), \"ERR_ACTIVE\");\r\n    }\r\n\r\n    // validates a reserve token address - verifies that the address belongs to one of the reserve tokens\r\n    modifier validReserve(IERC20Token _address) {\r\n        _validReserve(_address);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validReserve(IERC20Token _address) internal view {\r\n        require(reserves[_address].isSet, \"ERR_INVALID_RESERVE\");\r\n    }\r\n\r\n    // validates conversion fee\r\n    modifier validConversionFee(uint32 _conversionFee) {\r\n        _validConversionFee(_conversionFee);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validConversionFee(uint32 _conversionFee) internal pure {\r\n        require(_conversionFee <= PPM_RESOLUTION, \"ERR_INVALID_CONVERSION_FEE\");\r\n    }\r\n\r\n    // validates reserve weight\r\n    modifier validReserveWeight(uint32 _weight) {\r\n        _validReserveWeight(_weight);\r\n        _;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _validReserveWeight(uint32 _weight) internal pure {\r\n        require(_weight > 0 && _weight <= PPM_RESOLUTION, \"ERR_INVALID_RESERVE_WEIGHT\");\r\n    }\r\n\r\n    // overrides interface declaration\r\n    function converterType() public pure virtual override returns (uint16);\r\n\r\n    // overrides interface declaration\r\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256, uint256);\r\n\r\n    /**\r\n      * @dev deposits ether\r\n      * can only be called if the converter has an ETH reserve\r\n    */\r\n    receive() external override payable {\r\n        require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_INVALID_RESERVE\"); // require(hasETHReserve(), \"ERR_INVALID_RESERVE\");\r\n        // a workaround for a problem when running solidity-coverage\r\n        // see https://github.com/sc-forks/solidity-coverage/issues/487\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws ether\r\n      * can only be called by the owner if the converter is inactive or by upgrader contract\r\n      * can only be called after the upgrader contract has accepted the ownership of this contract\r\n      * can only be called if the converter has an ETH reserve\r\n      *\r\n      * @param _to  address to send the ETH to\r\n    */\r\n    function withdrawETH(address payable _to)\r\n        public\r\n        override\r\n        virtual\r\n        protected\r\n        ownerOnly\r\n        validReserve(ETH_RESERVE_ADDRESS)\r\n    {\r\n        address converterUpgrader = addressOf(CONVERTER_UPGRADER);\r\n\r\n        // verify that the converter is inactive or that the owner is the upgrader contract\r\n        require(!isActive() || owner == converterUpgrader, \"ERR_ACCESS_DENIED\");\r\n        _to.transfer(address(this).balance);\r\n\r\n        // sync the ETH reserve balance\r\n        syncReserveBalance(ETH_RESERVE_ADDRESS);\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not the converter version is 28 or higher\r\n      *\r\n      * @return true, since the converter version is 28 or higher\r\n    */\r\n    function isV28OrHigher() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev allows the owner to update & enable the conversion whitelist contract address\r\n      * when set, only addresses that are whitelisted are actually allowed to use the converter\r\n      * note that the whitelist check is actually done by the BancorNetwork contract\r\n      *\r\n      * @param _whitelist    address of a whitelist contract\r\n    */\r\n    function setConversionWhitelist(IWhitelist _whitelist)\r\n        public\r\n        override\r\n        ownerOnly\r\n        notThis(address(_whitelist))\r\n    {\r\n        conversionWhitelist = _whitelist;\r\n    }\r\n\r\n    /**\r\n      * @dev returns true if the converter is active, false otherwise\r\n      *\r\n      * @return true if the converter is active, false otherwise\r\n    */\r\n    function isActive() public view virtual override returns (bool) {\r\n        return anchor.owner() == address(this);\r\n    }\r\n\r\n    /**\r\n      * @dev transfers the anchor ownership\r\n      * the new owner needs to accept the transfer\r\n      * can only be called by the converter upgrder while the upgrader is the owner\r\n      * note that prior to version 28, you should use 'transferAnchorOwnership' instead\r\n      *\r\n      * @param _newOwner    new token owner\r\n    */\r\n    function transferAnchorOwnership(address _newOwner)\r\n        public\r\n        virtual\r\n        override\r\n        ownerOnly\r\n        only(CONVERTER_UPGRADER)\r\n    {\r\n        anchor.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n      * @dev accepts ownership of the anchor after an ownership transfer\r\n      * most converters are also activated as soon as they accept the anchor ownership\r\n      * can only be called by the contract owner\r\n      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\r\n    */\r\n    function acceptAnchorOwnership() public virtual override ownerOnly {\r\n        // verify the the converter has at least one reserve\r\n        require(reserveTokenCount() > 0, \"ERR_INVALID_RESERVE_COUNT\");\r\n        anchor.acceptOwnership();\r\n        syncReserveBalances();\r\n    }\r\n\r\n    /**\r\n      * @dev updates the current conversion fee\r\n      * can only be called by the contract owner\r\n      *\r\n      * @param _conversionFee new conversion fee, represented in ppm\r\n    */\r\n    function setConversionFee(uint32 _conversionFee) public override ownerOnly {\r\n        require(_conversionFee <= maxConversionFee, \"ERR_INVALID_CONVERSION_FEE\");\r\n        emit ConversionFeeUpdate(conversionFee, _conversionFee);\r\n        conversionFee = _conversionFee;\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws tokens held by the converter and sends them to an account\r\n      * can only be called by the owner\r\n      * note that reserve tokens can only be withdrawn by the owner while the converter is inactive\r\n      * unless the owner is the converter upgrader contract\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        virtual\r\n        override(IConverter, TokenHolder)\r\n        protected\r\n        ownerOnly\r\n    {\r\n        address converterUpgrader = addressOf(CONVERTER_UPGRADER);\r\n\r\n        // if the token is not a reserve token, allow withdrawal\r\n        // otherwise verify that the converter is inactive or that the owner is the upgrader contract\r\n        require(!reserves[_token].isSet || !isActive() || owner == converterUpgrader, \"ERR_ACCESS_DENIED\");\r\n        super.withdrawTokens(_token, _to, _amount);\r\n\r\n        // if the token is a reserve token, sync the reserve balance\r\n        if (reserves[_token].isSet)\r\n            syncReserveBalance(_token);\r\n    }\r\n\r\n    /**\r\n      * @dev upgrades the converter to the latest version\r\n      * can only be called by the owner\r\n      * note that the owner needs to call acceptOwnership on the new converter after the upgrade\r\n    */\r\n    function upgrade() public ownerOnly {\r\n        IConverterUpgrader converterUpgrader = IConverterUpgrader(addressOf(CONVERTER_UPGRADER));\r\n\r\n        // trigger de-activation event\r\n        emit Activation(converterType(), anchor, false);\r\n\r\n        transferOwnership(address(converterUpgrader));\r\n        converterUpgrader.upgrade(version);\r\n        acceptOwnership();\r\n    }\r\n\r\n    /**\r\n      * @dev returns the number of reserve tokens defined\r\n      * note that prior to version 17, you should use 'connectorTokenCount' instead\r\n      *\r\n      * @return number of reserve tokens\r\n    */\r\n    function reserveTokenCount() public view returns (uint16) {\r\n        return uint16(reserveTokens.length);\r\n    }\r\n\r\n    /**\r\n      * @dev defines a new reserve token for the converter\r\n      * can only be called by the owner while the converter is inactive\r\n      *\r\n      * @param _token   address of the reserve token\r\n      * @param _weight  reserve weight, represented in ppm, 1-1000000\r\n    */\r\n    function addReserve(IERC20Token _token, uint32 _weight)\r\n        public\r\n        virtual\r\n        override\r\n        ownerOnly\r\n        inactive\r\n        validAddress(address(_token))\r\n        notThis(address(_token))\r\n        validReserveWeight(_weight)\r\n    {\r\n        // validate input\r\n        require(address(_token) != address(anchor) && !reserves[_token].isSet, \"ERR_INVALID_RESERVE\");\r\n        require(_weight <= PPM_RESOLUTION - reserveRatio, \"ERR_INVALID_RESERVE_WEIGHT\");\r\n        require(reserveTokenCount() < uint16(-1), \"ERR_INVALID_RESERVE_COUNT\");\r\n\r\n        Reserve storage newReserve = reserves[_token];\r\n        newReserve.balance = 0;\r\n        newReserve.weight = _weight;\r\n        newReserve.isSet = true;\r\n        reserveTokens.push(_token);\r\n        reserveRatio += _weight;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the reserve's weight\r\n      * added in version 28\r\n      *\r\n      * @param _reserveToken    reserve token contract address\r\n      *\r\n      * @return reserve weight\r\n    */\r\n    function reserveWeight(IERC20Token _reserveToken)\r\n        public\r\n        view\r\n        validReserve(_reserveToken)\r\n        returns (uint32)\r\n    {\r\n        return reserves[_reserveToken].weight;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the reserve's balance\r\n      * note that prior to version 17, you should use 'getConnectorBalance' instead\r\n      *\r\n      * @param _reserveToken    reserve token contract address\r\n      *\r\n      * @return reserve balance\r\n    */\r\n    function reserveBalance(IERC20Token _reserveToken)\r\n        public\r\n        override\r\n        view\r\n        validReserve(_reserveToken)\r\n        returns (uint256)\r\n    {\r\n        return reserves[_reserveToken].balance;\r\n    }\r\n\r\n    /**\r\n      * @dev checks whether or not the converter has an ETH reserve\r\n      *\r\n      * @return true if the converter has an ETH reserve, false otherwise\r\n    */\r\n    function hasETHReserve() public view returns (bool) {\r\n        return reserves[ETH_RESERVE_ADDRESS].isSet;\r\n    }\r\n\r\n    /**\r\n      * @dev converts a specific amount of source tokens to target tokens\r\n      * can only be called by the bancor network contract\r\n      *\r\n      * @param _sourceToken source ERC20 token\r\n      * @param _targetToken target ERC20 token\r\n      * @param _amount      amount of tokens to convert (in units of the source token)\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received (in units of the target token)\r\n    */\r\n    function convert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address payable _beneficiary)\r\n        public\r\n        override\r\n        payable\r\n        protected\r\n        only(BANCOR_NETWORK)\r\n        returns (uint256)\r\n    {\r\n        // validate input\r\n        require(_sourceToken != _targetToken, \"ERR_SAME_SOURCE_TARGET\");\r\n\r\n        // if a whitelist is set, verify that both and trader and the beneficiary are whitelisted\r\n        require(address(conversionWhitelist) == address(0) ||\r\n                (conversionWhitelist.isWhitelisted(_trader) && conversionWhitelist.isWhitelisted(_beneficiary)),\r\n                \"ERR_NOT_WHITELISTED\");\r\n\r\n        return doConvert(_sourceToken, _targetToken, _amount, _trader, _beneficiary);\r\n    }\r\n\r\n    /**\r\n      * @dev converts a specific amount of source tokens to target tokens\r\n      * called by ConverterBase and allows the inherited contracts to implement custom conversion logic\r\n      *\r\n      * @param _sourceToken source ERC20 token\r\n      * @param _targetToken target ERC20 token\r\n      * @param _amount      amount of tokens to convert (in units of the source token)\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received (in units of the target token)\r\n    */\r\n    function doConvert(\r\n        IERC20Token _sourceToken,\r\n        IERC20Token _targetToken,\r\n        uint256 _amount,\r\n        address _trader,\r\n        address payable _beneficiary)\r\n        internal\r\n        virtual\r\n        returns (uint256);\r\n\r\n    /**\r\n      * @dev returns the conversion fee for a given target amount\r\n      *\r\n      * @param _targetAmount  target amount\r\n      *\r\n      * @return conversion fee\r\n    */\r\n    function calculateFee(uint256 _targetAmount) internal view returns (uint256) {\r\n        return _targetAmount.mul(conversionFee).div(PPM_RESOLUTION);\r\n    }\r\n\r\n    /**\r\n      * @dev syncs the stored reserve balance for a given reserve with the real reserve balance\r\n      *\r\n      * @param _reserveToken    address of the reserve token\r\n    */\r\n    function syncReserveBalance(IERC20Token _reserveToken) internal validReserve(_reserveToken) {\r\n        if (_reserveToken == ETH_RESERVE_ADDRESS)\r\n            reserves[_reserveToken].balance = address(this).balance;\r\n        else\r\n            reserves[_reserveToken].balance = _reserveToken.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n      * @dev syncs all stored reserve balances\r\n    */\r\n    function syncReserveBalances() internal {\r\n        uint256 reserveCount = reserveTokens.length;\r\n        for (uint256 i = 0; i < reserveCount; i++)\r\n            syncReserveBalance(reserveTokens[i]);\r\n    }\r\n\r\n    /**\r\n      * @dev helper, dispatches the Conversion event\r\n      *\r\n      * @param _sourceToken     source ERC20 token\r\n      * @param _targetToken     target ERC20 token\r\n      * @param _trader          address of the caller who executed the conversion\r\n      * @param _amount          amount purchased/sold (in the source token)\r\n      * @param _returnAmount    amount returned (in the target token)\r\n    */\r\n    function dispatchConversionEvent(\r\n        IERC20Token _sourceToken,\r\n        IERC20Token _targetToken,\r\n        address _trader,\r\n        uint256 _amount,\r\n        uint256 _returnAmount,\r\n        uint256 _feeAmount)\r\n        internal\r\n    {\r\n        // fee amount is converted to 255 bits -\r\n        // negative amount means the fee is taken from the source token, positive amount means its taken from the target token\r\n        // currently the fee is always taken from the target token\r\n        // since we convert it to a signed number, we first ensure that it's capped at 255 bits to prevent overflow\r\n        assert(_feeAmount < 2 ** 255);\r\n        emit Conversion(_sourceToken, _targetToken, _trader, _amount, _returnAmount, int256(_feeAmount));\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated since version 28, backward compatibility - use only for earlier versions\r\n    */\r\n    function token() public view override returns (IConverterAnchor) {\r\n        return anchor;\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function transferTokenOwnership(address _newOwner) public override ownerOnly {\r\n        transferAnchorOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function acceptTokenOwnership() public override ownerOnly {\r\n        acceptAnchorOwnership();\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectors(IERC20Token _address) public view override returns (uint256, uint32, bool, bool, bool) {\r\n        Reserve memory reserve = reserves[_address];\r\n        return(reserve.balance, reserve.weight, false, false, reserve.isSet);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectorTokens(uint256 _index) public view override returns (IERC20Token) {\r\n        return ConverterBase.reserveTokens[_index];\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function connectorTokenCount() public view override returns (uint16) {\r\n        return reserveTokenCount();\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getConnectorBalance(IERC20Token _connectorToken) public view override returns (uint256) {\r\n        return reserveBalance(_connectorToken);\r\n    }\r\n\r\n    /**\r\n      * @dev deprecated, backward compatibility\r\n    */\r\n    function getReturn(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view returns (uint256, uint256) {\r\n        return targetAmountAndFee(_sourceToken, _targetToken, _amount);\r\n    }\r\n}\r\n\r\n// File: solidity/contracts/token/interfaces/IDSToken.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n/*\r\n    DSToken interface\r\n*/\r\ninterface IDSToken is IConverterAnchor, IERC20Token {\r\n    function issue(address _to, uint256 _amount) external;\r\n    function destroy(address _from, uint256 _amount) external;\r\n}\r\n\r\n// File: solidity/contracts/converter/types/liquid-token/LiquidTokenConverter.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n/**\r\n  * @dev Liquid Token Converter\r\n  *\r\n  * The liquid token converter is a specialized version of a converter that manages a liquid token.\r\n  *\r\n  * The converters govern a token with a single reserve and allow converting between the two.\r\n  * Liquid tokens usually have fractional reserve (reserve ratio smaller than 100%).\r\n*/\r\ncontract LiquidTokenConverter is ConverterBase {\r\n    /**\r\n      * @dev initializes a new LiquidTokenConverter instance\r\n      *\r\n      * @param  _token              liquid token governed by the converter\r\n      * @param  _registry           address of a contract registry contract\r\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n    */\r\n    constructor(\r\n        IDSToken _token,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee\r\n    )\r\n        ConverterBase(_token, _registry, _maxConversionFee)\r\n        public\r\n    {\r\n    }\r\n\r\n    /**\r\n      * @dev returns the converter type\r\n      *\r\n      * @return see the converter types in the the main contract doc\r\n    */\r\n    function converterType() public pure override returns (uint16) {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n      * @dev accepts ownership of the anchor after an ownership transfer\r\n      * also activates the converter\r\n      * can only be called by the contract owner\r\n      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\r\n    */\r\n    function acceptAnchorOwnership() public override ownerOnly {\r\n        super.acceptAnchorOwnership();\r\n\r\n        emit Activation(converterType(), anchor, true);\r\n    }\r\n\r\n    /**\r\n      * @dev defines the reserve token for the converter\r\n      * can only be called by the owner while the converter is inactive and the\r\n      * reserve wasn't defined yet\r\n      *\r\n      * @param _token   address of the reserve token\r\n      * @param _weight  reserve weight, represented in ppm, 1-1000000\r\n    */\r\n    function addReserve(IERC20Token _token, uint32 _weight) public override ownerOnly {\r\n        // verify that the converter doesn't have a reserve yet\r\n        require(reserveTokenCount() == 0, \"ERR_INVALID_RESERVE_COUNT\");\r\n        super.addReserve(_token, _weight);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the expected target amount of converting the source token to the\r\n      * target token along with the fee\r\n      *\r\n      * @param _sourceToken contract address of the source token\r\n      * @param _targetToken contract address of the target token\r\n      * @param _amount      amount of tokens received from the user\r\n      *\r\n      * @return expected target amount\r\n      * @return expected fee\r\n    */\r\n    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view override returns (uint256, uint256) {\r\n        if (_targetToken == IDSToken(address(anchor)) && reserves[_sourceToken].isSet)\r\n            return purchaseTargetAmount(_amount);\r\n        if (_sourceToken == IDSToken(address(anchor)) && reserves[_targetToken].isSet)\r\n            return saleTargetAmount(_amount);\r\n\r\n        // invalid input\r\n        revert(\"ERR_INVALID_TOKEN\");\r\n    }\r\n\r\n    /**\r\n      * @dev converts between the liquid token and its reserve\r\n      * can only be called by the bancor network contract\r\n      *\r\n      * @param _sourceToken source ERC20 token\r\n      * @param _targetToken target ERC20 token\r\n      * @param _amount      amount of tokens to convert (in units of the source token)\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of tokens received (in units of the target token)\r\n    */\r\n    function doConvert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address payable _beneficiary)\r\n        internal\r\n        override\r\n        returns (uint256)\r\n    {\r\n        uint256 targetAmount;\r\n        IERC20Token reserveToken;\r\n\r\n        if (_targetToken == IDSToken(address(anchor)) && reserves[_sourceToken].isSet) {\r\n            reserveToken = _sourceToken;\r\n            targetAmount = buy(_amount, _trader, _beneficiary);\r\n        }\r\n        else if (_sourceToken == IDSToken(address(anchor)) && reserves[_targetToken].isSet) {\r\n            reserveToken = _targetToken;\r\n            targetAmount = sell(_amount, _trader, _beneficiary);\r\n        }\r\n        else {\r\n            // invalid input\r\n            revert(\"ERR_INVALID_TOKEN\");\r\n        }\r\n\r\n        // dispatch rate update for the liquid token\r\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\r\n        uint32 reserveWeight = reserves[reserveToken].weight;\r\n        emit TokenRateUpdate(IDSToken(address(anchor)), reserveToken, reserveBalance(reserveToken).mul(PPM_RESOLUTION), totalSupply.mul(reserveWeight));\r\n\r\n        return targetAmount;\r\n    }\r\n\r\n    /**\r\n      * @dev returns the expected target amount of buying with a given amount of tokens\r\n      *\r\n      * @param _amount  amount of reserve tokens to get the target amount for\r\n      *\r\n      * @return amount of liquid tokens that the user will receive\r\n      * @return amount of liquid tokens that the user will pay as fee\r\n    */\r\n    function purchaseTargetAmount(uint256 _amount)\r\n        internal\r\n        view\r\n        active\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\r\n        IERC20Token reserveToken = reserveTokens[0];\r\n\r\n        // if the current supply is zero, then return the input amount divided by the normalized reserve-weight\r\n        if (totalSupply == 0)\r\n            return (_amount.mul(PPM_RESOLUTION).div(reserves[reserveToken].weight), 0);\r\n\r\n        uint256 amount = IBancorFormula(addressOf(BANCOR_FORMULA)).purchaseTargetAmount(\r\n            totalSupply,\r\n            reserveBalance(reserveToken),\r\n            reserves[reserveToken].weight,\r\n            _amount\r\n        );\r\n\r\n        // return the amount minus the conversion fee and the conversion fee\r\n        uint256 fee = calculateFee(amount);\r\n        return (amount - fee, fee);\r\n    }\r\n\r\n    /**\r\n      * @dev returns the expected target amount of selling a given amount of tokens\r\n      *\r\n      * @param _amount  amount of liquid tokens to get the target amount for\r\n      *\r\n      * @return expected reserve tokens\r\n      * @return expected fee\r\n    */\r\n    function saleTargetAmount(uint256 _amount)\r\n        internal\r\n        view\r\n        active\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\r\n\r\n        IERC20Token reserveToken = reserveTokens[0];\r\n\r\n        // if selling the entire supply, then return the entire reserve\r\n        if (totalSupply == _amount)\r\n            return (reserveBalance(reserveToken), 0);\r\n\r\n        uint256 amount = IBancorFormula(addressOf(BANCOR_FORMULA)).saleTargetAmount(\r\n            totalSupply,\r\n            reserveBalance(reserveToken),\r\n            reserves[reserveToken].weight,\r\n            _amount\r\n        );\r\n\r\n        // return the amount minus the conversion fee and the conversion fee\r\n        uint256 fee = calculateFee(amount);\r\n        return (amount - fee, fee);\r\n    }\r\n\r\n    /**\r\n      * @dev buys the liquid token by depositing in its reserve\r\n      *\r\n      * @param _amount      amount of reserve token to buy the token for\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of liquid tokens received\r\n    */\r\n    function buy(uint256 _amount, address _trader, address _beneficiary) internal returns (uint256) {\r\n        // get expected target amount and fee\r\n        (uint256 amount, uint256 fee) = purchaseTargetAmount(_amount);\r\n\r\n        // ensure the trade gives something in return\r\n        require(amount != 0, \"ERR_ZERO_TARGET_AMOUNT\");\r\n\r\n        IERC20Token reserveToken = reserveTokens[0];\r\n\r\n        // ensure that the input amount was already deposited\r\n        if (reserveToken == ETH_RESERVE_ADDRESS)\r\n            require(msg.value == _amount, \"ERR_ETH_AMOUNT_MISMATCH\");\r\n        else\r\n            require(msg.value == 0 && reserveToken.balanceOf(address(this)).sub(reserveBalance(reserveToken)) >= _amount, \"ERR_INVALID_AMOUNT\");\r\n\r\n        // sync the reserve balance\r\n        syncReserveBalance(reserveToken);\r\n\r\n        // issue new funds to the beneficiary in the liquid token\r\n        IDSToken(address(anchor)).issue(_beneficiary, amount);\r\n\r\n        // dispatch the conversion event\r\n        dispatchConversionEvent(reserveToken, IDSToken(address(anchor)), _trader, _amount, amount, fee);\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n      * @dev sells the liquid token by withdrawing from its reserve\r\n      *\r\n      * @param _amount      amount of liquid tokens to sell\r\n      * @param _trader      address of the caller who executed the conversion\r\n      * @param _beneficiary wallet to receive the conversion result\r\n      *\r\n      * @return amount of reserve tokens received\r\n    */\r\n    function sell(uint256 _amount, address _trader, address payable _beneficiary) internal returns (uint256) {\r\n        // ensure that the input amount was already deposited\r\n        require(_amount <= IDSToken(address(anchor)).balanceOf(address(this)), \"ERR_INVALID_AMOUNT\");\r\n\r\n        // get expected target amount and fee\r\n        (uint256 amount, uint256 fee) = saleTargetAmount(_amount);\r\n\r\n        // ensure the trade gives something in return\r\n        require(amount != 0, \"ERR_ZERO_TARGET_AMOUNT\");\r\n\r\n        IERC20Token reserveToken = reserveTokens[0];\r\n\r\n        // ensure that the trade will only deplete the reserve balance if the total supply is depleted as well\r\n        uint256 tokenSupply = IDSToken(address(anchor)).totalSupply();\r\n        uint256 rsvBalance = reserveBalance(reserveToken);\r\n        assert(amount < rsvBalance || (amount == rsvBalance && _amount == tokenSupply));\r\n\r\n        // destroy the tokens from the converter balance in the liquid token\r\n        IDSToken(address(anchor)).destroy(address(this), _amount);\r\n\r\n        // update the reserve balance\r\n        reserves[reserveToken].balance = reserves[reserveToken].balance.sub(amount);\r\n\r\n        // transfer funds to the beneficiary in the reserve token\r\n        if (reserveToken == ETH_RESERVE_ADDRESS)\r\n            _beneficiary.transfer(amount);\r\n        else\r\n            safeTransfer(reserveToken, _beneficiary, amount);\r\n\r\n        // dispatch the conversion event\r\n        dispatchConversionEvent(IDSToken(address(anchor)), reserveToken, _trader, _amount, amount, fee);\r\n\r\n        return amount;\r\n    }\r\n}\r\n\r\n// File: solidity/contracts/converter/types/liquid-token/DynamicLiquidTokenConverter.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n  * @dev Liquid Token Converter\r\n  *\r\n  * The dynamic liquid token converter is a specialized version of a converter that manages a liquid token\r\n  * and allows for a reduction in reserve weight within a predefined set of boundaries.\r\n  *\r\n  * The converters govern a token with a single reserve and allow converting between the two.\r\n  * Liquid tokens usually have fractional reserve (reserve ratio smaller than 100%).\r\n  * The weight can be reduced by the defined stepWeight any time the defined marketCapThreshold\r\n  * has been reached.\r\n*/\r\ncontract DynamicLiquidTokenConverter is LiquidTokenConverter {\r\n    uint32 public minimumWeight = 30000;\r\n    uint32 public stepWeight = 10000;\r\n    uint256 public marketCapThreshold = 10000 ether;\r\n    uint256 lastWeightAdjustmentMarketCap = 0;\r\n\r\n    event ReserveTokenWeightUpdate(uint32 _prevWeight, uint32 _newWeight, uint256 _percentage, uint256 _balance);\r\n\r\n    /**\r\n      * @dev initializes a new DyamicLiquidTokenConverter instance\r\n      *\r\n      * @param  _token              liquid token governed by the converter\r\n      * @param  _registry           address of a contract registry contract\r\n      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n    */\r\n    constructor(\r\n        IDSToken _token,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee\r\n    )\r\n        LiquidTokenConverter(_token, _registry, _maxConversionFee)\r\n        public\r\n    {\r\n    }\r\n\r\n    /**\r\n      * @dev updates the market cap threshold\r\n      * can only be called by the owner while inactive\r\n      * \r\n      * @param _marketCapThreshold new threshold\r\n    */\r\n    function setMarketCapThreshold(uint256 _marketCapThreshold)\r\n        public\r\n        ownerOnly\r\n        inactive\r\n    {\r\n        marketCapThreshold = _marketCapThreshold;\r\n    }\r\n\r\n    /**\r\n      * @dev updates the current minimum weight\r\n      * can only be called by the owner while inactive\r\n      * \r\n      * @param _minimumWeight new minimum weight, represented in ppm\r\n    */\r\n    function setMinimumWeight(uint32 _minimumWeight)\r\n        public\r\n        ownerOnly\r\n        inactive\r\n    {\r\n        minimumWeight = _minimumWeight;\r\n    }\r\n\r\n    /**\r\n      * @dev updates the current step weight\r\n      * can only be called by the owner while inactive\r\n      * \r\n      * @param _stepWeight new step weight, represented in ppm\r\n    */\r\n    function setStepWeight(uint32 _stepWeight)\r\n        public\r\n        ownerOnly\r\n        inactive\r\n    {\r\n        stepWeight = _stepWeight;\r\n    }\r\n\r\n    /**\r\n      * @dev updates the token reserve weight\r\n      * can only be called by the owner\r\n      * \r\n      * @param _reserveToken    address of the reserve token\r\n    */\r\n    function reduceWeight(IERC20Token _reserveToken)\r\n        public\r\n        validReserve(_reserveToken)\r\n        ownerOnly\r\n    {\r\n        uint256 currentMarketCap = getMarketCap(_reserveToken);\r\n        require(currentMarketCap > (lastWeightAdjustmentMarketCap.add(marketCapThreshold)), \"ERR_MARKET_CAP_BELOW_THRESHOLD\");\r\n\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        uint256 newWeight = uint256(reserve.weight).sub(stepWeight);\r\n        uint32 oldWeight = reserve.weight;\r\n        require(newWeight >= minimumWeight, \"ERR_INVALID_RESERVE_WEIGHT\");\r\n\r\n        uint256 percentage = uint256(PPM_RESOLUTION).sub(newWeight.mul(1e6).div(reserve.weight));\r\n\r\n        uint32 weight = uint32(newWeight);\r\n        reserve.weight = weight;\r\n        reserveRatio = weight;\r\n\r\n        uint256 balance = reserveBalance(_reserveToken).mul(percentage).div(1e6);\r\n\r\n        if (_reserveToken == ETH_RESERVE_ADDRESS)\r\n          msg.sender.transfer(balance);\r\n        else\r\n          safeTransfer(_reserveToken, msg.sender, balance);\r\n\r\n        lastWeightAdjustmentMarketCap = currentMarketCap;\r\n\r\n        syncReserveBalance(_reserveToken);\r\n\r\n        emit ReserveTokenWeightUpdate(oldWeight, weight, percentage, reserve.balance);\r\n    }\r\n\r\n    function getMarketCap(IERC20Token _reserveToken)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        return reserveBalance(_reserveToken).mul(1e6).div(reserve.weight);\r\n    }\r\n\r\n    /**\r\n      * Upgrade functions. Overriden to allow upgrades by owner.\r\n    **/\r\n\r\n    /**\r\n      * @dev withdraws ether\r\n      * can only be called by the owner\r\n      * can only be called if the converter has an ETH reserve\r\n      *\r\n      * @param _to  address to send the ETH to\r\n    */\r\n    function withdrawETH(address payable _to)\r\n        public\r\n        override\r\n        protected\r\n        ownerOnly\r\n        validReserve(ETH_RESERVE_ADDRESS)\r\n    {\r\n        _to.transfer(address(this).balance);\r\n\r\n        // sync the ETH reserve balance\r\n        syncReserveBalance(ETH_RESERVE_ADDRESS);\r\n    }\r\n\r\n    /**\r\n      * @dev transfers the anchor ownership\r\n      * the new owner needs to accept the transfer\r\n      *\r\n      * @param _newOwner    new token owner\r\n    */\r\n    function transferAnchorOwnership(address _newOwner)\r\n        public\r\n        override\r\n        ownerOnly\r\n    {\r\n        anchor.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n      * @dev withdraws tokens held by the converter and sends them to an account\r\n      * can only be called by the owner\r\n      *\r\n      * @param _token   ERC20 token contract address\r\n      * @param _to      account to receive the new amount\r\n      * @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        override\r\n        protected\r\n        ownerOnly\r\n    {\r\n        TokenHolder.withdrawTokens(_token, _to, _amount);\r\n\r\n        // if the token is a reserve token, sync the reserve balance\r\n        if (reserves[_token].isSet)\r\n            syncReserveBalance(_token);\r\n    }\r\n\r\n}"}}}