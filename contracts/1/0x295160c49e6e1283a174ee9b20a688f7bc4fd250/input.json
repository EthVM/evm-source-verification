{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Distributor.sol": {
      "content": "/**\r\n      ______     ______     __  __     ______   ______   ______    \r\n     /\\  ___\\   /\\  == \\   /\\ \\_\\ \\   /\\  == \\ /\\__  _\\ /\\  __ \\   \r\n     \\ \\ \\____  \\ \\  __<   \\ \\____ \\  \\ \\  _-/ \\/_/\\ \\/ \\ \\ \\/\\ \\  \r\n      \\ \\_____\\  \\ \\_\\ \\_\\  \\/\\_____\\  \\ \\_\\      \\ \\_\\  \\ \\_____\\ \r\n       \\/_____/   \\/_/ /_/   \\/_____/   \\/_/       \\/_/   \\/_____/ \r\n            ______   ______     __   __     __  __     ______      \r\n           /\\__  _\\ /\\  __ \\   /\\ \"-.\\ \\   /\\ \\/ /    /\\___  \\     \r\n           \\/_/\\ \\/ \\ \\  __ \\  \\ \\ \\-.  \\  \\ \\  _\"-.  \\/_/  /__    \r\n              \\ \\_\\  \\ \\_\\ \\_\\  \\ \\_\\\\\"\\_\\  \\ \\_\\ \\_\\   /\\_____\\   \r\n               \\/_/   \\/_/\\/_/   \\/_/ \\/_/   \\/_/\\/_/   \\/_____/   \r\n               \r\n   \r\n    Twitter: https://twitter.com/CryptoTankZ\r\n   \r\n    Gitbook: https://crypto-tankz.gitbook.io/\r\n   \r\n    Telegram: https://t.me/CryptoTankz\r\n   \r\n    Announcemnts: https://t.me/CryptoTankzCH\r\n    \r\n    Website: https://cryptotankz.com\r\n\r\n\r\n\r\n\tThis is special SmartContract helper for CryptoTankz.\r\n\tIt provides new player registration to database.\r\n\tSpecial paid game-items tracking.\r\n\tTokens distribution to the winners.\r\n\t\r\n\tAll reward-tokens are locked here. \r\n \r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.6;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n  \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n  \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n  \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {return 0;}\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n  \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n  \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n  \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n  \r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nabstract contract ERC20Detailed is IERC20 {\r\n    uint8 private _decimals;\r\n    string private _name;\r\n    string private _symbol;\r\n    \r\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\r\n        _decimals = decimals_;\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n    \r\n    function name() public view returns(string memory) {\r\n        return _name;\r\n    }\r\n    \r\n    function symbol() public view returns(string memory) {\r\n        return _symbol;\r\n    }\r\n    \r\n    function decimals() public view returns(uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\ncontract OwnableDistributor {\r\n    address internal _owner;\r\n    address internal _distributor;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event newDistributorSet(address indexed previousDistributor, address indexed newDistributor);\r\n\r\n    constructor () {\r\n        _distributor = address(0);\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function setDistributor(address _address) external onlyOwner {\r\n        require (_distributor == address(0));\r\n        _distributor = _address;\r\n        emit newDistributorSet(address(0), _address);\r\n    }\r\n    \r\n    function distributor() public view returns (address) {\r\n        return _distributor;\r\n    }\r\n    \r\n    modifier onlyDistributor() {\r\n        require(_distributor == msg.sender, \"caller is not rewards distributor\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract CryptoTankzDistributor is OwnableDistributor {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address uniswapV2router;\r\n    \r\n    // Game rewards conditions setup.\r\n    mapping (address => bool) private playersDatabase;\r\n    uint256 playerRewardLimit;\r\n    event playerAddedToDatabase (address playerAddress, bool isAdded);\r\n    event playerRemovedFromDatabase (address playerAddress, bool isAdded);\r\n    event rewardTransfered(address indexed from, address indexed to, uint256 value);\r\n    \r\n     // Game items database.\r\n    string[] private weapon = [\r\n        \"Small Cannon\",\r\n        \"Large Cannon\",\r\n        \"Double Cannon\",\r\n        \"Slow Machine Gun\",\r\n        \"Fast Machine Gun\",\r\n        \"Rocket Launcher\",\r\n        \"Ground Missile\",\r\n        \"Air Missile\",\r\n        \"Tracking Missile\",\r\n        \"Nuclear Missile\"\r\n    ];\r\n    string[] private armor = [\r\n        \"Metal Helm\",\r\n        \"War Belt\",\r\n        \"Anit-Fire Shield\",\r\n        \"Anti-Missile Shield\",\r\n        \"Additional Steel Body\",\r\n        \"Caterpillars Shield\",\r\n        \"Bulletproof Vest\",\r\n        \"Engine Protection\",\r\n        \"Shock Absorbers\",\r\n        \"Titanium Hatch\"\r\n    ];\r\n    string[] private health = [\r\n        \"First Aid Kit\",\r\n        \"Bandages\",\r\n        \"Painkillers\",\r\n        \"Food\",\r\n        \"Water\",\r\n        \"Repair Kit\",\r\n        \"Engine Oil\",\r\n        \"New Battery\",\r\n        \"New Caterpillars\",\r\n        \"New Suspension\"\r\n    ];\r\n    string[] private upgrade = [\r\n        \"Large Caterpillars\",\r\n        \"Climb Improvement\",\r\n        \"Engine Booster\",\r\n        \"Special Fuel\",\r\n        \"Large Exhaust\",\r\n        \"Bigger Fuel Tank\",\r\n        \"Double Fire\",\r\n        \"Auto Tracking\",\r\n        \"Wide Radar View\",\r\n        \"Artifacts Scanner\"\r\n    ];\r\n    string[] private artifact = [\r\n        \"Gold Ring\",\r\n        \"Human Bone\",\r\n        \"Garrison Flag\",\r\n        \"Rusty Knife\",\r\n        \"Binoculars\",\r\n        \"Eagle Plate\",\r\n        \"Purple Heart Medal\",\r\n        \"Soldier Dog Tag\",\r\n        \"Silver Bullet\",\r\n        \"Lucky Medallion\"\r\n    ];\r\n    \r\n    constructor(address router) {\r\n        uniswapV2router = router;\r\n        \r\n        name = \"CryptoTankz Distributor\";\r\n        symbol = \"CTDIST\";\r\n        decimals = 9;\r\n        playerRewardLimit = 3000000000000; //maximum amount of reward-tokens for player per game (3000) + decimals (9)\r\n    }\r\n    \r\n    /**\r\n     * @dev Functions to operate game items database.\r\n     */\r\n    function random(string memory input) internal pure returns (uint256) {\r\n        return uint256(keccak256(abi.encodePacked(input)));\r\n    }\r\n    \r\n    function gameItemWeapon(uint256 tokenNumber) public view returns (string memory) {\r\n        return itemName(tokenNumber, \"WEAPON\", weapon);\r\n    }\r\n    \r\n    function gameItemArmor(uint256 tokenNumber) public view returns (string memory) {\r\n        return itemName(tokenNumber, \"ARMOR\", armor);\r\n    }\r\n    \r\n    function gameItemHealth(uint256 tokenNumber) public view returns (string memory) {\r\n        return itemName(tokenNumber, \"HEALTH\", health);\r\n    }\r\n\r\n    function gameItemUpgrade(uint256 tokenNumber) public view returns (string memory) {\r\n        return itemName(tokenNumber, \"UPGRADE\", upgrade);\r\n    }\r\n    \r\n    function gameItemArtifact(uint256 tokenNumber) public view returns (string memory) {\r\n        return itemName(tokenNumber, \"ARTIFACT\", artifact);\r\n    }\r\n    \r\n    function itemName(uint256 tokenId, string memory keyPrefix, string[] memory sourceArray) internal pure returns (string memory) {\r\n        uint256 rand = random(string(abi.encodePacked(keyPrefix, toString(tokenId))));\r\n        string memory output = sourceArray[rand % sourceArray.length];\r\n        return output;\r\n    }\r\n     \r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n    \r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        _transfer(_from, _to, _value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) internal view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n  \r\n    function _transfer(address _from, address _to, uint256 _value) private {\r\n        require(_from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(_to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(_value > 0, \"Transfer amount must be greater than zero\");\r\n        balances[_from] = balances[_from].sub(_value, \"ERC20: transfer amount exceeds balance\");\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function addNewPlayerToDatabase(address _address) public onlyDistributor {\r\n        playersDatabase[_address] = true;\r\n        emit playerAddedToDatabase (_address, playersDatabase[_address]);\r\n    }\r\n\r\n    function removePlayerFromDatabase(address _address) public onlyDistributor {\r\n        playersDatabase[_address] = false;\r\n        emit playerRemovedFromDatabase (_address, playersDatabase[_address]);\r\n    }\r\n        \r\n    function isPlayerInDatabase(address _address) public view returns(bool) {\r\n        return playersDatabase[_address];\r\n    }\r\n    \r\n    // Returns the maximum amount of reward-tokens for the player per one game (decimals (9) are cut here for better clarity)\r\n    function maxRewardPerPlayer() public view returns (uint256) {\r\n        return playerRewardLimit.div(1*10**9);\r\n    }\r\n    \r\n    /**\r\n     * This function allow to send reward-tokens to player, but special conditions must be provided:\r\n     *\r\n     * -the owner must be zero address (completed renouceOwnership is required as first)\r\n     * -function can be called only by Distributor (not by contract owner or player)\r\n     * -distributor cannot send any reward to his own address or owner address.\r\n     * -the player by using another function has to be registered in database first.\r\n     * -amount of each reward-tokens cannot be greater than maximum limit, which is 3000 tokens.\r\n     * -function doesn't generate new tokens. Rewards end when the pool (tokens in the contract) will be empty.\r\n     */\r\n    function claimRewardForWinner(address _address, uint256 _rewardAmount) external onlyDistributor {\r\n        require (owner() == address(0), \"renouce owership required. The Owner must be zero address\");\r\n        require (_address != _distributor, \"distributor cannot send reward to himself\");\r\n        require (playersDatabase[_address] == true, \"address is not registred in players database\");\r\n        require (_rewardAmount <= playerRewardLimit, \"amount cannot be higher than limit\");\r\n        require (_address != address(0), \"zero address not allowed\");\r\n        require (_rewardAmount != 0, \"amount cannot be zero\");\r\n        balances[address(this)] = balances[address(this)].sub(_rewardAmount, \"reward pool is empty already\");\r\n        balances[_address] = balances[_address].add(_rewardAmount);\r\n        emit rewardTransfered(address(this), _address, _rewardAmount);\r\n    }\r\n} "
    }
  }
}