{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ArcxLiquidationSushi.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nlibrary SafeMath {\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, 'SafeMath: addition overflow');\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, 'SafeMath: subtraction overflow');\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, 'SafeMath: multiplication overflow');\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, 'SafeMath: division by zero');\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, 'SafeMath: modulo by zero');\n  }\n\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IWeth is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint amount) external;\n}\n\ninterface IXSushi is IERC20{\n    function leave(uint256 shares) external;\n    function sushi() external returns (IERC20);\n}\n\ninterface IUniswapRouter {\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);   \n\n}\n\ninterface IUniswapV2Pair{\n\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\nlibrary Math {\n    using SafeMath for uint256;\n\n    // ============ Library Functions ============\n\n    /*\n     * Return target * (numerator / denominator).\n     */\n    function getPartial(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return target.mul(numerator).div(denominator);\n    }\n\n    function to128(\n        uint256 number\n    )\n        internal\n        pure\n        returns (uint128)\n    {\n        uint128 result = uint128(number);\n        require(\n            result == number,\n            \"Math: Unsafe cast to uint128\"\n        );\n        return result;\n    }\n\n    function min(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function max(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a > b ? a : b;\n    }\n}\n\nlibrary Decimal {\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    uint256 constant BASE = 10**18;\n\n    // ============ Structs ============\n\n    struct D256 {\n        uint256 value;\n    }\n\n    // ============ Functions ============\n\n    function one()\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: BASE });\n    }\n\n    function onePlus(\n        D256 memory d\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: d.value.add(BASE) });\n    }\n\n    function mul(\n        uint256 target,\n        D256 memory d\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(target, d.value, BASE);\n    }\n\n    function mul(\n        D256 memory d1,\n        D256 memory d2\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return Decimal.D256({ value: Math.getPartial(d1.value, d2.value, BASE) });\n    }\n\n    function div(\n        uint256 target,\n        D256 memory d\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(target, BASE, d.value);\n    }\n\n    function add(\n        D256 memory d,\n        uint256 amount\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: d.value.add(amount) });\n    }\n\n    function sub(\n        D256 memory d,\n        uint256 amount\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: d.value.sub(amount) });\n    }\n\n}\n\ninterface IStructs{\n    enum Operation {\n        Open,\n        Borrow,\n        Repay,\n        Liquidate,\n        TransferOwnership\n    }\n\n    struct Principal {\n        bool sign; // true if positive\n        uint256 value;\n    }\n\n    struct Position {\n        address owner;\n        Principal collateralAmount;\n        Principal borrowedAmount;\n    }\n\n    struct OperationParams {\n        uint256 id;\n        uint256 amountOne;\n        uint256 amountTwo;\n        address addressOne;\n    }\n\n}\n\ninterface IOracle is IStructs{\n     function fetchCurrentPrice()\n        external\n        view\n        returns (Decimal.D256 memory);\n}\n\ninterface IarcxPool is IStructs{\n\n    function operateAction(\n        Operation operation,\n        OperationParams memory params\n    ) external ;\n\n    function getCurrentOracle() external view returns(address);\n\n    function calculateLiquidationPrice(Decimal.D256 memory currentPrice) external view returns(Decimal.D256 memory);\n\n    function calculateCollateralDelta(\n        Principal memory parSupply,\n        uint256 borrowedAmount,\n        Decimal.D256 memory price\n    )\n        external\n        view\n        returns (Principal memory);\n\n    function getPosition(uint256 position) external view returns (Position memory);\n\n    function getFees()\n    external\n    view\n    returns (\n        Decimal.D256 memory _liquidationUserFee,\n        Decimal.D256 memory _liquidationArcRatio\n    );\n}\n\n\ncontract ArcxLiquidations is IStructs {\n    \n    using SafeMath for uint256;\n    using Math for uint256;\n\n    IUniswapV2Pair stablexPair = IUniswapV2Pair(address(0x1BccE9E2Fd56E8311508764519d28E6ec22D4a47));\n\n    IUniswapRouter dex = IUniswapRouter(address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D));\n\n    IarcxPool arcxPool = IarcxPool(address(0xc3A5A0dC6241C922937c5cd90F5bACE23716AFB7));\n\n    IERC20 stablex = IERC20(address(0xcD91538B91B4ba7797D39a2f66E63810b50A33d0));\n\n    IERC20 usdc = IERC20(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48));\n\n    IWeth weth = IWeth(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\n    \n    IXSushi xsushi = IXSushi(address(0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272));\n\n    IERC20 sushi = IERC20(address(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2));\n\n    address owner;\n    \n    constructor() public {\n        owner = msg.sender;\n        sushi.approve(address(dex), uint256(-1));\n    }\n    \n    fallback() external payable {\n        \n    }\n    \n    receive() external payable {\n        \n    }\n\n    function uniswapV2Call(address pair, uint256 amount0Out, uint256 amount1Out, bytes memory data) external {\n\n        if(msg.sender != address(stablexPair)){\n            return;\n        }\n\n        (uint256 amount, uint256 amountUSDC, uint256 position, address ben) = abi.decode(data, (uint256, uint256, uint256, address));\n\n        OperationParams memory params = OperationParams({\n            id: position,\n            amountOne: 1,\n            amountTwo: 1,\n            addressOne: address(0)\n        });\n\n        arcxPool.operateAction(Operation.Liquidate, params);\n\n        require(xsushi.balanceOf(address(this)) > 0, \"!no collateral received\");\n        \n        xsushi.leave(xsushi.balanceOf(address(this)));\n\n        _swapToGetUSDC(sushi.balanceOf(address(this)));\n        \n        usdc.transfer(msg.sender, amountUSDC);\n        \n        usdc.transfer(ben, usdc.balanceOf(address(this)));\n\n    }\n\n    function withdrawErc20(address token) external {\n\n        require(msg.sender == owner, \"!owner\");\n        \n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\n        \n    }\n    \n    function withdraw() external {\n        \n        require(msg.sender == owner, \"!owner\");\n        \n        payable(msg.sender).transfer(address(this).balance);\n        \n    }\n\n\n    function getAmountOfStableXNeeded(uint256 posIndex) public view returns(uint256 borrowToLiquidate){\n\n        Decimal.D256 memory currentPrice = IOracle(arcxPool.getCurrentOracle()).fetchCurrentPrice();\n\n        Decimal.D256 memory liquidationPrice = arcxPool.calculateLiquidationPrice(currentPrice);\n\n        Position memory position = arcxPool.getPosition(posIndex);\n\n        Principal memory collateralDelta = arcxPool.calculateCollateralDelta(\n            position.collateralAmount,\n            position.borrowedAmount.value,\n            liquidationPrice\n        );\n\n        (Decimal.D256 memory liquidateUserFees, Decimal.D256 memory liquidateArcxFees) = arcxPool.getFees();\n\n        collateralDelta.value = Decimal.mul(\n            collateralDelta.value,\n            Decimal.add(\n                liquidateUserFees,\n                Decimal.one().value\n            )\n        );\n\n\n        borrowToLiquidate = Decimal.mul(\n            collateralDelta.value,\n            liquidationPrice\n        );\n\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) private returns (uint amountIn) {\n        require(amountOut > 0, 'ArcxLiquidation: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'ArcxLiquidation: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n\n    function run(address ben, uint256 posIndex) external {\n\n        require(msg.sender == owner, \"!owner\");\n\n        uint256 amount = getAmountOfStableXNeeded(posIndex);\n\n        (uint256 amount0Out, uint256 amount1Out) = stablexPair.token0() == address(stablex)?\n            (amount, uint256(0)):(uint256(0), amount);\n\n        (uint256 reserve0, uint256 reserve1, ) = stablexPair.getReserves();\n\n        (uint256 reserveIn, uint256 reserveOut) = stablexPair.token0() == address(stablex)? \n        (reserve1, reserve0) : (reserve0, reserve1); \n\n        uint256 amountIn = getAmountIn(amount, reserveIn, reserveOut);\n\n        bytes memory data = abi.encode(amount, amountIn, posIndex, ben);\n\n        stablexPair.swap(amount0Out, amount1Out, address(this), data);\n\n    }\n\n    function _swapToGetUSDC(uint _amountIn) internal {\n        // TODO\n        address[] memory path = new address[](3);\n        path[0] = address(sushi);\n        path[1] = address(weth);\n        path[2] = address(usdc);\n\n        dex.swapExactTokensForTokens(_amountIn, 0, path, address(this), now + 30);\n    }\n\n}"
    }
  }
}