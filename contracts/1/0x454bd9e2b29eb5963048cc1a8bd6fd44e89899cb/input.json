{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "DictatorDAO.sol": {
      "content": "// SPDX-License-Identifier: MIXED\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.1\r\n// License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n/// @notice A library for performing overflow-/underflow-safe math,\r\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\r\n    }\r\n\r\n    function to128(uint256 a) internal pure returns (uint128 c) {\r\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\r\n        c = uint128(a);\r\n    }\r\n\r\n    function to64(uint256 a) internal pure returns (uint64 c) {\r\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\r\n        c = uint64(a);\r\n    }\r\n\r\n    function to32(uint256 a) internal pure returns (uint32 c) {\r\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\r\n        c = uint32(a);\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\r\nlibrary BoringMath128 {\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\r\nlibrary BoringMath64 {\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\r\nlibrary BoringMath32 {\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/Domain.sol@v1.2.1\r\n// License-Identifier: MIT\r\n// Based on code and smartness by Ross Campbell and Keno\r\n// Uses immutable to store the domain separator to reduce gas usage\r\n// If the chain id changes due to a fork, the forked chain will calculate on the fly.\r\npragma solidity 0.6.12;\r\n\r\n// solhint-disable no-inline-assembly\r\n\r\ncontract Domain {\r\n    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\r\n    // See https://eips.ethereum.org/EIPS/eip-191\r\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \"\\x19\\x01\";\r\n\r\n    // solhint-disable var-name-mixedcase\r\n    bytes32 private immutable _DOMAIN_SEPARATOR;\r\n    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;    \r\n\r\n    /// @dev Calculate the DOMAIN_SEPARATOR\r\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\r\n        return keccak256(\r\n            abi.encode(\r\n                DOMAIN_SEPARATOR_SIGNATURE_HASH,\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    constructor() public {\r\n        uint256 chainId; assembly {chainId := chainid()}\r\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\r\n    }\r\n\r\n    /// @dev Return the DOMAIN_SEPARATOR\r\n    // It's named internal to allow making it public from the contract that uses it by creating a simple view function\r\n    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function _domainSeparator() internal view returns (bytes32) {\r\n        uint256 chainId; assembly {chainId := chainid()}\r\n        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\r\n    }\r\n\r\n    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\r\n        digest =\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\r\n                    _domainSeparator(),\r\n                    dataHash\r\n                )\r\n            );\r\n    }\r\n}\r\n\r\n// File contracts/interfaces/IERC20.sol\r\n//License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /// @notice EIP 2612\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n// File contracts/DictatorDAO.sol\r\n//License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n// DAO code/operator management/dutch auction, etc by BoringCrypto\r\n// Staking in DictatorDAO inspired by Chef Nomi's SushiBar (heavily modified) - MIT license (originally WTFPL)\r\n// TimeLock functionality Copyright 2020 Compound Labs, Inc. - BSD 3-Clause \"New\" or \"Revised\" License\r\ncontract DictatorDAO is IERC20, Domain {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n\r\n    string public symbol;\r\n    string public name;\r\n    uint8 public constant decimals = 18;\r\n    uint256 public override totalSupply;\r\n\r\n    IERC20 public immutable token;\r\n    address public operator;\r\n\r\n    mapping(address => address) public userVote;\r\n    mapping(address => uint256) public votes;\r\n\r\n    constructor(\r\n        string memory sharesSymbol,\r\n        string memory sharesName,\r\n        IERC20 token_,\r\n        address initialOperator\r\n    ) public {\r\n        symbol = sharesSymbol;\r\n        name = sharesName;\r\n        token = token_;\r\n        operator = initialOperator;\r\n    }\r\n\r\n    struct User {\r\n        uint128 balance;\r\n        uint128 lockedUntil;\r\n    }\r\n\r\n    /// @notice owner > balance mapping.\r\n    mapping(address => User) public users;\r\n    /// @notice owner > spender > allowance mapping.\r\n    mapping(address => mapping(address => uint256)) public override allowance;\r\n    /// @notice owner > nonce mapping. Used in `permit`.\r\n    mapping(address => uint256) public nonces;\r\n\r\n    function balanceOf(address user)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 balance)\r\n    {\r\n        return users[user].balance;\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 shares\r\n    ) internal {\r\n        User memory fromUser = users[from];\r\n        require(block.timestamp >= fromUser.lockedUntil, \"Locked\");\r\n        if (shares != 0) {\r\n            require(fromUser.balance >= shares, \"Low balance\");\r\n            if (from != to) {\r\n                require(to != address(0), \"Zero address\"); // Moved down so other failed calls save some gas\r\n                User memory toUser = users[to];\r\n\r\n                address userVoteTo = userVote[to];\r\n                address userVoteFrom = userVote[from];\r\n\r\n                users[from].balance = fromUser.balance - shares.to128(); // Underflow is checked\r\n                users[to].balance = toUser.balance + shares.to128(); // Can't overflow because totalSupply would be greater than 2^256-1\r\n\r\n                // The \"from\" user's nominee started with at least that user's\r\n                // votes, and votes correspond to 1:1 to balances. By the\r\n                // \"Low balance\" check above this will not underflow.\r\n                votes[userVoteFrom] -= shares;\r\n\r\n                // The \"to\" user's nominee started with at most `totalSupply`\r\n                // votes. By the above, they have at least `shares` fewer now.\r\n                // It follows that there can be no overflow.\r\n                votes[userVoteTo] += shares;\r\n            }\r\n        }\r\n        emit Transfer(from, to, shares);\r\n    }\r\n\r\n    function _useAllowance(address from, uint256 shares) internal {\r\n        if (msg.sender == from) {\r\n            return;\r\n        }\r\n        uint256 spenderAllowance = allowance[from][msg.sender];\r\n        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\r\n        if (spenderAllowance != type(uint256).max) {\r\n            require(spenderAllowance >= shares, \"Low allowance\");\r\n            allowance[from][msg.sender] = spenderAllowance - shares; // Underflow is checked\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers `shares` tokens from `msg.sender` to `to`.\r\n    /// @param to The address to move the tokens.\r\n    /// @param shares of the tokens to move.\r\n    /// @return (bool) Returns True if succeeded.\r\n    function transfer(address to, uint256 shares)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(msg.sender, to, shares);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfers `shares` tokens from `from` to `to`. Caller needs approval for `from`.\r\n    /// @param from Address to draw tokens from.\r\n    /// @param to The address to move the tokens.\r\n    /// @param shares The token shares to move.\r\n    /// @return (bool) Returns True if succeeded.\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 shares\r\n    ) external override returns (bool) {\r\n        _useAllowance(from, shares);\r\n        _transfer(from, to, shares);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Approves `amount` from sender to be spend by `spender`.\r\n    /// @param spender Address of the party that can draw from msg.sender's account.\r\n    /// @param amount The maximum collective amount that `spender` can draw.\r\n    /// @return (bool) Returns True if approved.\r\n    function approve(address spender, uint256 amount)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\r\n        return _domainSeparator();\r\n    }\r\n\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 private constant PERMIT_SIGNATURE_HASH =\r\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\r\n    /// @param owner_ Address of the owner.\r\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\r\n    /// @param value The maximum collective amount that `spender` can draw.\r\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\r\n    function permit(\r\n        address owner_,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external override {\r\n        require(owner_ != address(0), \"Zero owner\");\r\n        require(block.timestamp < deadline, \"Expired\");\r\n        require(\r\n            ecrecover(\r\n                _getDigest(\r\n                    keccak256(\r\n                        abi.encode(\r\n                            PERMIT_SIGNATURE_HASH,\r\n                            owner_,\r\n                            spender,\r\n                            value,\r\n                            nonces[owner_]++,\r\n                            deadline\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            ) == owner_,\r\n            \"Invalid Sig\"\r\n        );\r\n        allowance[owner_][spender] = value;\r\n        emit Approval(owner_, spender, value);\r\n    }\r\n\r\n    // Operator Setting\r\n    address public pendingOperator;\r\n    uint256 public pendingOperatorTime;\r\n\r\n    // Condition for safe math: totalSupply < 2^255, so that the doubling fits.\r\n    // A sufficient condition is for this to hold for token.totalSupply.\r\n    function setOperator(address newOperator) public {\r\n        require(newOperator != address(0), \"Zero operator\");\r\n        uint256 netVotes = totalSupply - votes[address(0)];\r\n        if (newOperator != pendingOperator) {\r\n            require(votes[newOperator] * 2 > netVotes, \"Not enough votes\");\r\n            pendingOperator = newOperator;\r\n            pendingOperatorTime = block.timestamp + 7 days;\r\n        } else {\r\n            if (votes[newOperator] * 2 > netVotes) {\r\n                require(block.timestamp >= pendingOperatorTime, \"Wait longer\");\r\n                operator = pendingOperator;\r\n            }\r\n            // If there aren't enough votes, then the pending operator failed\r\n            // to maintain a majority. If there are, then they are now the\r\n            // operator. In either situation:\r\n            pendingOperator = address(0);\r\n            pendingOperatorTime = 0;\r\n        }\r\n    }\r\n\r\n    /// math is ok, because amount, totalSupply and shares is always 0 <= amount <= 100.000.000 * 10^18\r\n    /// theoretically you can grow the amount/share ratio, but it's not practical and useless\r\n    function mint(uint256 amount, address operatorVote) public returns (bool) {\r\n        require(msg.sender != address(0), \"Zero address\");\r\n        User memory user = users[msg.sender];\r\n\r\n        uint256 totalTokens = token.balanceOf(address(this));\r\n        uint256 shares =\r\n            totalSupply == 0 ? amount : (amount * totalSupply) / totalTokens;\r\n\r\n        // Did we change our vote? Do this while we know our previous total:\r\n        address currentVote = userVote[msg.sender];\r\n        uint256 extraVotes = shares;\r\n        if (currentVote != operatorVote) {\r\n            if (user.balance > 0) {\r\n                // Safe, because the user must have added their balance before\r\n                votes[currentVote] -= user.balance;\r\n                extraVotes += user.balance;\r\n            }\r\n            userVote[msg.sender] = operatorVote;\r\n        }\r\n        votes[operatorVote] += extraVotes;\r\n\r\n        user.balance += shares.to128();\r\n        user.lockedUntil = (block.timestamp + 24 hours).to128();\r\n        users[msg.sender] = user;\r\n        totalSupply += shares;\r\n\r\n        token.transferFrom(msg.sender, address(this), amount);\r\n\r\n        emit Transfer(address(0), msg.sender, shares);\r\n        return true;\r\n    }\r\n\r\n    // Change your vote. Does not lock tokens.\r\n    function vote(address operatorVote) public returns (bool) {\r\n        address currentVote = userVote[msg.sender];\r\n        if (currentVote != operatorVote) {\r\n            User memory user = users[msg.sender];\r\n            if (user.balance > 0) {\r\n                votes[currentVote] -= user.balance;\r\n                votes[operatorVote] += user.balance;\r\n            }\r\n            userVote[msg.sender] = operatorVote;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _burn(\r\n        address from,\r\n        address to,\r\n        uint256 shares\r\n    ) internal {\r\n        require(to != address(0), \"Zero address\");\r\n        User memory user = users[from];\r\n        require(block.timestamp >= user.lockedUntil, \"Locked\");\r\n        uint256 amount =\r\n            (shares * token.balanceOf(address(this))) / totalSupply;\r\n        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow\r\n        totalSupply -= shares;\r\n        votes[userVote[from]] -= shares;\r\n\r\n        token.transfer(to, amount);\r\n\r\n        emit Transfer(from, address(0), shares);\r\n    }\r\n\r\n    function burn(address to, uint256 shares) public returns (bool) {\r\n        _burn(msg.sender, to, shares);\r\n        return true;\r\n    }\r\n\r\n    function burnFrom(\r\n        address from,\r\n        address to,\r\n        uint256 shares\r\n    ) public returns (bool) {\r\n        _useAllowance(from, shares);\r\n        _burn(from, to, shares);\r\n        return true;\r\n    }\r\n\r\n    event QueueTransaction(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        uint256 value,\r\n        bytes data,\r\n        uint256 eta\r\n    );\r\n    event CancelTransaction(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        uint256 value,\r\n        bytes data\r\n    );\r\n    event ExecuteTransaction(\r\n        bytes32 indexed txHash,\r\n        address indexed target,\r\n        uint256 value,\r\n        bytes data\r\n    );\r\n\r\n    uint256 public constant GRACE_PERIOD = 14 days;\r\n    uint256 public constant DELAY = 2 days;\r\n    mapping(bytes32 => uint256) public queuedTransactions;\r\n\r\n    function queueTransaction(\r\n        address target,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) public returns (bytes32) {\r\n        require(msg.sender == operator, \"Operator only\");\r\n        require(votes[operator] * 2 > totalSupply, \"Not enough votes\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, data));\r\n        uint256 eta = block.timestamp + DELAY;\r\n        queuedTransactions[txHash] = eta;\r\n\r\n        emit QueueTransaction(txHash, target, value, data, eta);\r\n        return txHash;\r\n    }\r\n\r\n    function cancelTransaction(\r\n        address target,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) public {\r\n        require(msg.sender == operator, \"Operator only\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, data));\r\n        queuedTransactions[txHash] = 0;\r\n\r\n        emit CancelTransaction(txHash, target, value, data);\r\n    }\r\n\r\n    function executeTransaction(\r\n        address target,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) public payable returns (bytes memory) {\r\n        require(msg.sender == operator, \"Operator only\");\r\n        require(votes[operator] * 2 > totalSupply, \"Not enough votes\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, data));\r\n        uint256 eta = queuedTransactions[txHash];\r\n        require(block.timestamp >= eta, \"Too early\");\r\n        require(block.timestamp <= eta + GRACE_PERIOD, \"Tx stale\");\r\n\r\n        queuedTransactions[txHash] = 0;\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) =\r\n            target.call{value: value}(data);\r\n        require(success, \"Tx reverted :(\");\r\n\r\n        emit ExecuteTransaction(txHash, target, value, data);\r\n\r\n        return returnData;\r\n    }\r\n}"
    }
  }
}