{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"raiden/Token.sol":{"content":"pragma solidity 0.6.4;\n\ninterface Token {\n\n    /// @return supply total amount of tokens\n    function totalSupply() external view returns (uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance The balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // Optionally implemented function to show the number of decimals for the token\n    function decimals() external view returns (uint8 decimals);\n}\n"},"raiden/Utils.sol":{"content":"pragma solidity 0.6.4;\n\n/// @title Utils\n/// @notice Utils contract for various helpers used by the Raiden Network smart\n/// contracts.\ncontract Utils {\n    enum MessageTypeId {\n        None,\n        BalanceProof,\n        BalanceProofUpdate,\n        Withdraw,\n        CooperativeSettle,\n        IOU,\n        MSReward\n    }\n\n    /// @notice Check if a contract exists\n    /// @param contract_address The address to check whether a contract is\n    /// deployed or not\n    /// @return True if a contract exists, false otherwise\n    function contractExists(address contract_address) public view returns (bool) {\n        uint size;\n\n        assembly {\n            size := extcodesize(contract_address)\n        }\n\n        return size > 0;\n    }\n}\n"},"services/UserDeposit.sol":{"content":"pragma solidity 0.6.4;\n\nimport \"raiden/Token.sol\";\nimport \"raiden/Utils.sol\";\n\ncontract UserDeposit is Utils {\n    uint constant public withdraw_delay = 100;  // time before withdraw is allowed in blocks\n\n    // Token to be used for the deposit\n    Token public token;\n\n    // Trusted contracts (can execute `transfer`)\n    address public msc_address;\n    address public one_to_n_address;\n\n    // Total amount of tokens that have been deposited. This is monotonous and\n    // doing a transfer or withdrawing tokens will not decrease total_deposit!\n    mapping(address => uint256) public total_deposit;\n    // Current user's balance, ignoring planned withdraws\n    mapping(address => uint256) public balances;\n    mapping(address => WithdrawPlan) public withdraw_plans;\n\n    // The sum of all balances\n    uint256 public whole_balance = 0;\n    // Deposit limit for this whole contract\n    uint256 public whole_balance_limit;\n\n    /*\n     *  Structs\n     */\n    struct WithdrawPlan {\n        uint256 amount;\n        uint256 withdraw_block;  // earliest block at which withdraw is allowed\n    }\n\n    /*\n     *  Events\n     */\n\n    event BalanceReduced(address indexed owner, uint newBalance);\n    event WithdrawPlanned(address indexed withdrawer, uint plannedBalance);\n\n    /*\n     *  Modifiers\n     */\n\n    modifier canTransfer() {\n        require(msg.sender == msc_address || msg.sender == one_to_n_address, \"unknown caller\");\n        _;\n    }\n\n    /*\n     *  Constructor\n     */\n\n    /// @notice Set the default values for the smart contract\n    /// @param _token_address The address of the token to use for rewards\n    constructor(address _token_address, uint256 _whole_balance_limit)\n        public\n    {\n        // check token contract\n        require(_token_address != address(0x0), \"token at address zero\");\n        require(contractExists(_token_address), \"token has no code\");\n        token = Token(_token_address);\n        require(token.totalSupply() > 0, \"token has no total supply\"); // Check if the contract is indeed a token contract\n        // check and set the whole balance limit\n        require(_whole_balance_limit > 0, \"whole balance limit is zero\");\n        whole_balance_limit = _whole_balance_limit;\n    }\n\n    /// @notice Specify trusted contracts. This has to be done outside of the\n    /// constructor to avoid cyclic dependencies.\n    /// @param _msc_address Address of the MonitoringService contract\n    /// @param _one_to_n_address Address of the OneToN contract\n    function init(address _msc_address, address _one_to_n_address)\n        external\n    {\n        // prevent changes of trusted contracts after initialization\n        require(msc_address == address(0x0) && one_to_n_address == address(0x0), \"already initialized\");\n\n        // check monitoring service contract\n        require(_msc_address != address(0x0), \"MS contract at address zero\");\n        require(contractExists(_msc_address), \"MS contract has no code\");\n        msc_address = _msc_address;\n\n        // check one to n contract\n        require(_one_to_n_address != address(0x0), \"OneToN at address zero\");\n        require(contractExists(_one_to_n_address), \"OneToN has no code\");\n        one_to_n_address = _one_to_n_address;\n    }\n\n    /// @notice Deposit tokens. The amount of transferred tokens will be\n    /// `new_total_deposit - total_deposit[beneficiary]`. This makes the\n    /// function behavior predictable and idempotent. Can be called several\n    /// times and on behalf of other accounts.\n    /// @param beneficiary The account benefiting from the deposit\n    /// @param new_total_deposit The total sum of tokens that have been\n    /// deposited by the user by calling this function.\n    function deposit(address beneficiary, uint256 new_total_deposit)\n        external\n    {\n        require(new_total_deposit > total_deposit[beneficiary], \"deposit not increasing\");\n\n        // Calculate the actual amount of tokens that will be transferred\n        uint256 added_deposit = new_total_deposit - total_deposit[beneficiary];\n\n        balances[beneficiary] += added_deposit;\n        total_deposit[beneficiary] += added_deposit;\n\n        // Update whole_balance, but take care against overflows.\n        require(whole_balance + added_deposit >= whole_balance, \"overflowing deposit\");\n        whole_balance += added_deposit;\n\n        // Decline deposit if the whole balance is bigger than the limit.\n        require(whole_balance <= whole_balance_limit, \"too much deposit\");\n\n        // Actual transfer.\n        require(token.transferFrom(msg.sender, address(this), added_deposit), \"tokens didn't transfer\");\n    }\n\n    /// @notice Internally transfer deposits between two addresses.\n    /// Sender and receiver must be different or the transaction will fail.\n    /// @param sender Account from which the amount will be deducted\n    /// @param receiver Account to which the amount will be credited\n    /// @param amount Amount of tokens to be transferred\n    /// @return success true if transfer has been done successfully, otherwise false\n    function transfer(\n        address sender,\n        address receiver,\n        uint256 amount\n    )\n        canTransfer()\n        external\n        returns (bool success)\n    {\n        require(sender != receiver, \"sender == receiver\");\n        if (balances[sender] >= amount && amount > 0) {\n            balances[sender] -= amount;\n            balances[receiver] += amount;\n            emit BalanceReduced(sender, balances[sender]);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice Announce intention to withdraw tokens.\n    /// Sets the planned withdraw amount and resets the withdraw_block.\n    /// There is only one planned withdrawal at a time, the old one gets overwritten.\n    /// @param amount Maximum amount of tokens to be withdrawn\n    function planWithdraw(uint256 amount)\n        external\n    {\n        require(amount > 0, \"withdrawing zero\");\n        require(balances[msg.sender] >= amount, \"withdrawing too much\");\n\n        withdraw_plans[msg.sender] = WithdrawPlan({\n            amount: amount,\n            withdraw_block: block.number + withdraw_delay\n        });\n        emit WithdrawPlanned(msg.sender, balances[msg.sender] - amount);\n    }\n\n    /// @notice Execute a planned withdrawal\n    /// Will only work after the withdraw_delay has expired.\n    /// An amount lower or equal to the planned amount may be withdrawn.\n    /// Removes the withdraw plan even if not the full amount has been\n    /// withdrawn.\n    /// @param amount Amount of tokens to be withdrawn\n    function withdraw(uint256 amount)\n        external\n    {\n        WithdrawPlan storage withdraw_plan = withdraw_plans[msg.sender];\n        require(amount <= withdraw_plan.amount, \"withdrawing more than planned\");\n        require(withdraw_plan.withdraw_block <= block.number, \"withdrawing too early\");\n        uint256 withdrawable = min(amount, balances[msg.sender]);\n        balances[msg.sender] -= withdrawable;\n\n        // Update whole_balance, but take care against underflows.\n        require(whole_balance - withdrawable <= whole_balance, \"underflow in whole_balance\");\n        whole_balance -= withdrawable;\n\n        emit BalanceReduced(msg.sender, balances[msg.sender]);\n        delete withdraw_plans[msg.sender];\n\n        require(token.transfer(msg.sender, withdrawable), \"tokens didn't transfer\");\n    }\n\n    /// @notice The owner's balance with planned withdrawals deducted\n    /// @param owner Address for which the balance should be returned\n    /// @return remaining_balance The remaining balance after planned withdrawals\n    function effectiveBalance(address owner)\n        external\n        view\n        returns (uint256 remaining_balance)\n    {\n        WithdrawPlan storage withdraw_plan = withdraw_plans[owner];\n        if (withdraw_plan.amount > balances[owner]) {\n            return 0;\n        }\n        return balances[owner] - withdraw_plan.amount;\n    }\n\n    function min(uint256 a, uint256 b) pure internal returns (uint256)\n    {\n        return a > b ? b : a;\n    }\n}\n\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"}}}