{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "dnss.sol": {
      "content": "pragma solidity ^0.4.23;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n//manager contract\r\n//manager superAdmin\r\n//manager admin\r\n//manager superAdmin Auth\r\ncontract managerContract{\r\n    /**\r\n      * Token holder :\r\n      *     a.Holding tokens\r\n      *     b.No permission to transfer tokens privately\r\n      *     c.Cannot receive tokens, similar to dead accounts\r\n      *     d.Can delegate second-level administrators, but only one can be delegated\r\n      *     e.Have the permission to unlock and transfer tokens, but it depends on the unlocking rules (9800 DNSS unlocked every day)\r\n      *     f.Has the unlock time setting permission, but can only set one time  the unlock time node once\r\n      */\r\n    address superAdmin;\r\n\r\n    // Secondary ï¼šThe only management is to manage illegal users to obtain DNSS by abnormal means\r\n    mapping(address => address) internal admin;\r\n\r\n    //pool address\r\n    address pool;\r\n\r\n    //Depends on super administrator authority\r\n    modifier onlySuper {\r\n        require(msg.sender == superAdmin,'Depends on super administrator');\r\n        _;\r\n    }\r\n}\r\n\r\n//unLock contract\r\n//manager unLock startTime\r\n//manager circulation ( mining pool out total  )\r\n//manager calculate the number of unlocked DNSS fuction\r\ncontract unLockContract {\r\n\r\n    //use safeMath for Prevent overflow\r\n    using SafeMath for uint256;\r\n\r\n    //start unLock time\r\n    uint256 public startTime;\r\n    //use totalOut for Prevent Locked DNSS overflow\r\n    uint256 public totalToPool = 0;\r\n    //Can't burn DNSS Is 10% of the totalSupply\r\n    uint256 public sayNo = 980 * 1000 * 1000000000000000000 ;\r\n\r\n    //get totalUnLockAmount\r\n    function totalUnLockAmount() internal view returns (uint256 _unLockTotalAmount) {\r\n        //unLock start Time not is zero\r\n        if(startTime==0){ return 0;}\r\n        //Has not started to unlock\r\n        if(now <= startTime){ return 0; }\r\n        //unlock total count\r\n        uint256 dayDiff = (now.sub(startTime)) .div (1 days);\r\n        //Total unlocked quantity in calculation period\r\n        uint256 totalUnLock = dayDiff.mul(9800).mul(1000000000000000000);\r\n        //check totalSupply overflow\r\n        if(totalUnLock >= (980 * 10000 * 1000000000000000000)){\r\n            return 980 * 10000 * 1000000000000000000;\r\n        }\r\n        //return Unlocked DNSS total\r\n        return totalUnLock;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n* DNSS follows the erc-20 protocol\r\n* In order to maintain the maximum rights and interests of DNSS users and achieve\r\n* a completely decentralized consensus mechanism, DNSS will restrict anyone from\r\n* stealing any 9.8 million DNSS from the issuing account, including holders.\r\n* The only way is through the DNSS community committee. The cycle is unlocked for circulation,\r\n* and the DNSS community committee will rigidly restrict the circulation of tokens through this smart contract.\r\n* In order to achieve future deflation of DNSS, the contract will destroy DNSS through the destruction mechanism.\r\n*/\r\ncontract dnss is managerContract,unLockContract{\r\n\r\n    string public constant name     = \"Distributed Number Shared Settlement\";\r\n    string public constant symbol   = \"DNSS\";\r\n    uint8  public constant decimals = 18;\r\n    uint256 public totalSupply = 980 * 10000 * 1000000000000000000 ;\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    \r\n    //use totalBurn for Record the number of burns\r\n    mapping (address => uint256) public balanceBurn;\r\n   \r\n\r\n    //event\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    //init\r\n    constructor() public {\r\n        superAdmin = msg.sender ;\r\n        balanceOf[superAdmin] = totalSupply;\r\n    }\r\n    \r\n    //Get unlocked DNSS total\r\n    function totalUnLock() public view returns(uint256 _unlock){\r\n       return totalUnLockAmount();\r\n    }\r\n\r\n\r\n    //Only the super administrator can set the start unlock time\r\n    function setTime(uint256 _startTime) public onlySuper returns (bool success) {\r\n        require(startTime==0,'already started');\r\n        require(_startTime > now,'The start time cannot be less than or equal to the current time');\r\n        startTime = _startTime;\r\n        require(startTime == _startTime,'The start time was not set successfully');\r\n        return true;\r\n    }\r\n\r\n    //Approve admin\r\n    function superApproveAdmin(address _adminAddress) public onlySuper  returns (bool success) {\r\n        //check admin\r\n        require(_adminAddress != 0x0,'is bad');\r\n        admin[_adminAddress] = _adminAddress;\r\n        //check admin\r\n        if(admin[_adminAddress] == 0x0){\r\n             return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n   //Approve pool address\r\n    function superApprovePool(address _poolAddress) public onlySuper  returns (bool success) {\r\n        require(_poolAddress != 0x0,'is bad');\r\n        pool = _poolAddress; //Approve pool\r\n        require(pool == _poolAddress,'is failed');\r\n        return true;\r\n    }\r\n\r\n\r\n    //burn target address token amout\r\n    //burn total DNSS not more than 90% of the totalSupply\r\n    function superBurnFrom(address _burnTargetAddess, uint256 _value) public onlySuper returns (bool success) {\r\n        require(balanceOf[_burnTargetAddess] >= _value,'Not enough balance');\r\n        require(totalSupply > _value,' SHIT ! YOURE A FUCKING BAD GUY ! Little bitches ');\r\n        //check burn not more than 90% of the totalSupply\r\n        require(totalSupply.sub(_value) >= sayNo,' SHIT ! YOURE A FUCKING BAD GUY ! Little bitches ');\r\n        //burn target address\r\n        balanceOf[_burnTargetAddess] = balanceOf[_burnTargetAddess].sub(_value);\r\n        //totalSupply reduction\r\n        totalSupply=totalSupply.sub(_value);\r\n        emit Burn(_burnTargetAddess, _value);\r\n        //Cumulative DNSS of burns\r\n        balanceBurn[superAdmin] = balanceBurn[superAdmin].add(_value);\r\n        //burn successfully\r\n        return true;\r\n    }\r\n\r\n\r\n    //Unlock to the mining pool account\r\n    function superUnLock( address _poolAddress , uint256 _amount ) public onlySuper {\r\n        require(pool==_poolAddress,'Mine pool address error');\r\n        require( totalToPool.add(_amount)  <= totalSupply ,'totalSupply balance low');\r\n        //get total UnLock Amount\r\n        uint256 _unLockTotalAmount = totalUnLockAmount();\r\n        require( totalToPool.add(_amount)  <= _unLockTotalAmount ,'Not enough dnss has been unlocked');\r\n        //UnLock totalSupply to pool\r\n        balanceOf[_poolAddress]=balanceOf[_poolAddress].add(_amount);\r\n        //UnLock totalSupply to pool\r\n        balanceOf[superAdmin]=balanceOf[superAdmin].sub(_amount);\r\n        //Cumulative DNSS of UnLock\r\n        totalToPool=totalToPool.add(_amount);\r\n    }\r\n\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n       require(_from != superAdmin,'Administrator has no rights transfer');\r\n       require(_to != superAdmin,'Administrator has no rights transfer');\r\n       require(_to != 0x0);\r\n       require(balanceOf[_from] >= _value);\r\n       require(balanceOf[_to] + _value > balanceOf[_to]);\r\n       uint256 previousBalances = balanceOf[_from] + balanceOf[_to];\r\n       balanceOf[_from] -= _value;\r\n       balanceOf[_to] += _value;\r\n       emit Transfer(_from, _to, _value);\r\n       assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n\r\n     //superAdmin not transfer\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n         _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n     //superAdmin not transfer ;\r\n     //allowance transfer\r\n     //everyone can transfer\r\n     //admin can transfer Illegally acquired assets\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //admin Manage illegal assets\r\n        if(admin[msg.sender] != 0x0){\r\n          _transfer(_from, _to, _value);\r\n        } \r\n        return true;\r\n    }\r\n\r\n}"
    }
  }
}