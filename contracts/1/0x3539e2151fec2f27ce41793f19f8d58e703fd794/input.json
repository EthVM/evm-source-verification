{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Ownable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\n\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor(){\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n\n\n\n"
    },
    "SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n"
    },
    "XIVBettingFixed.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\npragma abicoder v2;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./XIVInterface.sol\";\n\ncontract XIVBettingFixed is Ownable{\n    \n    using SafeMath for uint256;\n    uint256 secondsInADay=24 hours;\n    \n    uint256 stakeOffset;\n    address public databaseContractAddress=0x18464e4584759A50CE9FC58eA5997F8B0D1EA1d8;\n    \n    XIVDatabaseLib.IndexCoin[] tempObjectArray;\n    \n     function betFixed(uint256 amountOfXIV, uint16 typeOfBet, address _betContractAddress, uint256 betSlabeIndex) external{\n        // 0-> defi Fixed, 1->defi flexible, 2-> index Fixed and 3-> index flexible 4-> flash fixed 5-> flash flexible\n        require(typeOfBet==0 || typeOfBet==2 || typeOfBet==4,\"Invalid bet Type\");\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        require(!dContract.getExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress),\"you can't place bet using these values.\");\n        Token tokenObj = Token(dContract.getXIVTokenContractAddress());\n        require((dContract.getBetFactorLP()).mul(dContract.getTokenStakedAmount())>=\n                        ((tokenObj.balanceOf(databaseContractAddress)).sub(dContract.getTokenStakedAmount())).add(amountOfXIV),\n                        \"Staking Vaults Have EXCEEDED CAPACITY. Please Check Back in 24hrs?\");\n        require(amountOfXIV>=dContract.getMinStakeXIVAmount() && amountOfXIV<=dContract.getMaxStakeXIVAmount(),\"Please enter amount in the specified range\");\n                   \n        if(typeOfBet==0 || typeOfBet==4){\n            bool isFlashVault=(typeOfBet==4?true:false);\n            require(dContract.isDaysAvailable(dContract.getFixedDefiCoinArray()[betSlabeIndex].daysCount),\"Day does not exists.\");\n            require(dContract.getFixedDefiCoinArray().length>betSlabeIndex,\"Day does not exists.\");\n            require(checkTimeForBet(dContract.getFixedDefiCoinArray()[betSlabeIndex].daysCount),\"Staking time closed for the selected day\");\n            require(dContract.getDefiCoinsFixedMapping(_betContractAddress,isFlashVault).status,\"The currency is currently disabled.\");\n           \n            // defi fixed\n            OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\n            XIVDatabaseLib.BetInfo memory binfo=XIVDatabaseLib.BetInfo({\n                id:dContract.getBetId(),\n                principalAmount:amountOfXIV,\n                amount:amountOfXIV,\n                userAddress:msg.sender,\n                contractAddress:_betContractAddress,\n                betType:typeOfBet,\n                currentPrice:uint256(oWObject.getPrice(dContract.getDefiCoinsFixedMapping(_betContractAddress,isFlashVault).currencySymbol, dContract.getDefiCoinsFixedMapping(_betContractAddress,isFlashVault).oracleType)),\n                betTimePeriod:(dContract.getFixedDefiCoinArray()[betSlabeIndex].daysCount).mul(1 days),\n                checkpointPercent:dContract.getFixedDefiCoinArray()[betSlabeIndex].upDownPercentage,\n                rewardFactor:dContract.getFixedDefiCoinArray()[betSlabeIndex].rewardFactor,\n                riskFactor:dContract.getFixedDefiCoinArray()[betSlabeIndex].riskFactor,\n                timestamp:block.timestamp,\n                adminCommissionFee:0,\n                status:0\n            });\n            dContract.updateBetArray(binfo);\n            dContract.updateFindBetInArrayUsingBetIdMapping(dContract.getBetId(),dContract.getBetArray().length.sub(1));\n            if(dContract.getBetsAccordingToUserAddress(msg.sender).length==0){\n                dContract.addUserAddressUsedForBetting(msg.sender);\n            }\n            dContract.updateBetAddressesArray(msg.sender,dContract.getBetId());\n            dContract.updateBetId(dContract.getBetId().add(1));\n            uint256 betEndTime=((((binfo.timestamp).div(secondsInADay)).mul(secondsInADay)).add(binfo.betTimePeriod).sub(1));\n            dContract.emitBetDetails(binfo.id,binfo.status,betEndTime);\n        }else if(typeOfBet==2){\n            //index Fixed \n            require(dContract.isDaysAvailable(dContract.getFixedDefiIndexArray()[betSlabeIndex].daysCount),\"Day does not exists.\");\n            require(dContract.getFixedDefiIndexArray().length>betSlabeIndex,\"Day does not exists.\");\n            require(checkTimeForBet(dContract.getFixedDefiIndexArray()[betSlabeIndex].daysCount),\"Staking time closed for the selected day\");\n            \n             XIVDatabaseLib.BetInfo memory binfo=XIVDatabaseLib.BetInfo({\n                id:dContract.getBetId(),\n                principalAmount:amountOfXIV,\n                amount:amountOfXIV,\n                userAddress:msg.sender,\n                contractAddress:address(0),\n                betType:typeOfBet,\n                currentPrice:uint256(calculateIndexValueForFixedInternal(dContract.getBetId())),\n                betTimePeriod:(dContract.getFixedDefiIndexArray()[betSlabeIndex].daysCount).mul(1 days),\n                checkpointPercent:dContract.getFixedDefiIndexArray()[betSlabeIndex].upDownPercentage,\n                rewardFactor:dContract.getFixedDefiIndexArray()[betSlabeIndex].rewardFactor,\n                riskFactor:dContract.getFixedDefiIndexArray()[betSlabeIndex].riskFactor,\n                timestamp:block.timestamp,\n                adminCommissionFee:0,\n                status:0\n            });\n            dContract.updateBetArray(binfo);\n            dContract.updateFindBetInArrayUsingBetIdMapping(dContract.getBetId(),dContract.getBetArray().length.sub(1));\n            if(dContract.getBetsAccordingToUserAddress(msg.sender).length==0){\n                dContract.addUserAddressUsedForBetting(msg.sender);\n            }\n            dContract.updateBetAddressesArray(msg.sender,dContract.getBetId());\n            dContract.updateBetId(dContract.getBetId().add(1));\n            uint256 betEndTime=((((binfo.timestamp).div(secondsInADay)).mul(secondsInADay)).add(binfo.betTimePeriod).sub(1));\n            dContract.emitBetDetails(binfo.id,binfo.status,betEndTime);\n        }\n        dContract.transferFromTokens(dContract.getXIVTokenContractAddress(),msg.sender,databaseContractAddress,amountOfXIV);\n        dContract.updateTotalTransactions(dContract.getTotalTransactions().add(amountOfXIV));\n        dContract.updateExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress,true);\n    }\n    function checkTimeForBet(uint256 _days) public view returns(bool){\n        uint256 currentTime=block.timestamp;\n        uint256 utcMidNight=((block.timestamp.div(secondsInADay)).mul(secondsInADay));\n        if(_days==1){\n            if(((utcMidNight).add(2 hours))>currentTime){\n                return true;\n            }else{\n                return false;\n            }\n        }else if(_days==3){\n            if(((utcMidNight).add(12 hours))>currentTime){\n                return true;\n            }else{\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    function calculateIndexValueForFixedInternal(uint256 _betId) internal returns(uint256){\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        uint256 totalMarketcap;\n        for(uint256 i=0;i<dContract.getAllIndexContractAddressArray().length;i++){\n            Token tObj=Token(dContract.getAllIndexContractAddressArray()[i]);\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getAllIndexContractAddressArray()[i]);\n            if(iCObj.status){\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n                dContract.updateBetIndexForFixedArray(_betId,iCObj);\n            }\n        }\n        XIVDatabaseLib.BetPriceHistory memory bPHObj=XIVDatabaseLib.BetPriceHistory({\n            baseIndexValue:dContract.getBetBaseIndexValue()==0?10**11:dContract.getBetBaseIndexValue(),\n            actualIndexValue:totalMarketcap\n        });\n        dContract.updateBetPriceHistoryFixedMapping(_betId,bPHObj);\n        if(dContract.getBetBaseIndexValue()==0){\n            dContract.updateBetBaseIndexValue(10**11);\n        }else{\n            if(totalMarketcap>dContract.getBetActualIndexValue()){\n                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue().add((\n                                                     (totalMarketcap.sub(dContract.getBetActualIndexValue()))\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\n            }else if(totalMarketcap<dContract.getBetActualIndexValue()){\n                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue().sub((\n                                                     (dContract.getBetActualIndexValue().sub(totalMarketcap))\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\n            }\n        }\n        dContract.updateBetActualIndexValue(totalMarketcap);\n        return totalMarketcap;\n    }\n    function updateStatus(uint256[] memory offerIds/**uint256 pageNo, uint256 pageSize**/) external {\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\n        stakeOffset=stakeOffset.add(dContract.getTokenStakedAmount());\n           for(uint256 i=0;i<offerIds.length;i++){ \n            XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[offerIds[i]];\n            if(bObject.status==0){\n                uint256 sevenDaysTime=((((bObject.timestamp).div(secondsInADay)).mul(secondsInADay)).add(bObject.betTimePeriod).sub(1));\n                if(block.timestamp>=sevenDaysTime){\n                     if(bObject.betType==0 || bObject.betType==1 || bObject.betType==4 || bObject.betType==5){\n                        // defi fixed\n                        string memory tempSymbol;\n                        uint256 tempOracle;\n                        if(bObject.betType==0 || bObject.betType==4 || bObject.betType==5){\n                            bool isFlashVault=((bObject.betType==4 || bObject.betType==5)?true:false);\n                            tempSymbol=dContract.getDefiCoinsFixedMapping(bObject.contractAddress,isFlashVault).currencySymbol;\n                            tempOracle=dContract.getDefiCoinsFixedMapping(bObject.contractAddress,isFlashVault).oracleType;\n                        }else if(bObject.betType==1){\n                            tempSymbol=dContract.getDefiCoinsFlexibleMapping(bObject.contractAddress).currencySymbol;\n                            tempOracle=dContract.getDefiCoinsFlexibleMapping(bObject.contractAddress).oracleType;\n                        }\n                        uint256 currentprice=uint256(oWObject.getPrice(tempSymbol, tempOracle));\n                       \n                        if(currentprice<bObject.currentPrice){\n                            uint16 percentageValue=uint16(((bObject.currentPrice.sub(currentprice)).mul(10**4))\n                                                    .div(bObject.currentPrice));\n                            if(percentageValue>=bObject.checkpointPercent){\n                                updateXIVForStakers(offerIds[i], true);\n                            }else{\n                                updateXIVForStakers(offerIds[i], false);\n                            }\n                        }else{\n                            updateXIVForStakers(offerIds[i], false);\n                        }\n                    }else if(bObject.betType==2){\n                        //index Fixed \n                       updateXIVForStakersIndexFixed(offerIds[i]);\n                        \n                    }else if(bObject.betType==3){\n                        //index flexible\n                       updateXIVForStakersIndexFlexible(offerIds[i]);\n                    }\n                }\n            }\n        }\n    }\n    function getUserStakedAddressCount() public view returns(uint256){\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        return dContract.getUserStakedAddress().length;\n    }\n    function incentiveStakers(uint256 pageNo, uint256 pageSize) external{\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        uint256 pageStart=pageNo.mul(pageSize);\n        uint256 pageSizeValue=(pageSize.mul(pageNo.add(1)));\n        if(getUserStakedAddressCount()<pageSizeValue){\n            pageSizeValue=getUserStakedAddressCount();\n        }\n        for(uint256 i=pageStart;i<pageSizeValue;i++){\n            address userAddress=dContract.getUserStakedAddress()[i];\n            uint256 updatedAmount;\n            if(stakeOffset>0){\n                updatedAmount=(((dContract.getTokensStaked(userAddress).mul(10**4).mul(stakeOffset))\n                                    .div(dContract.getTokenStakedAmount().mul(10**4))));\n            }else{\n                updatedAmount=dContract.getTokensStaked(userAddress);\n            }\n            uint256 excutionId=dContract.getSlotExecutionId();\n            if(dContract.getSlotId()>0){\n                if(excutionId<=dContract.getSlotId().sub(1)){\n                    for(uint256 j=0;j<dContract.getStakingInfoMapping(userAddress).length;j++){\n                        excutionId=dContract.getSlotExecutionId();\n                        XIVDatabaseLib.StakingInfo memory stakeInfo=dContract.getStakingInfoMapping(userAddress)[j];\n                        for(uint256 k=0;k<dContract.getIncentiveMapping(excutionId).length;k++){\n                            if(stakeInfo.investmentId<=dContract.getIncentiveMapping(excutionId)[k].tillInvestmentId){\n                                uint256 userIncentive=(((stakeInfo.stakeAmount.mul(10**4).mul(dContract.getIncentiveMapping(excutionId)[k].incentiveAmount))\n                                        .div(dContract.getIncentiveMapping(excutionId)[k].totalAmountStakedAtIncentiveTime.mul(10**4))));\n                                updatedAmount=updatedAmount.add(userIncentive);\n                            }\n                        }\n                        if(dContract.getSlotId().sub(1)>excutionId){\n                            excutionId++;\n                        }\n                    }\n                }\n            }\n            dContract.updateTokensStaked(userAddress,updatedAmount);\n        }\n        if(getUserStakedAddressCount()<pageSizeValue || getUserStakedAddressCount()==pageSizeValue){\n            uint256 updatedAmount;\n            if(dContract.getSlotId()>0){\n                uint256 indexId=dContract.getSlotExecutionId();\n                for(uint256 i=0;i<dContract.getIncentiveMapping(indexId).length;i++){\n                    updatedAmount=updatedAmount.add(dContract.getIncentiveMapping(indexId)[i].incentiveAmount);\n                    if(dContract.getSlotId().sub(1)>indexId){\n                            indexId++;\n                    }\n                }\n            }\n            if(stakeOffset>0){\n                dContract.updateTokenStakedAmount(stakeOffset.add(updatedAmount));\n            }else{\n                dContract.updateTokenStakedAmount(dContract.getTokenStakedAmount().add(updatedAmount));\n            }\n            stakeOffset=0;\n            dContract.updateSlotExecutionId(dContract.getSlotId());\n        }\n    }\n    function updateXIVForStakers(uint256 index, bool isWon) internal{\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n        if(isWon){\n            bObject.status=1;\n            uint256 rewardAmount=(uint256(bObject.rewardFactor).mul(bObject.amount)).div(10**4);\n            dContract.updateRewardGeneratedAmount(dContract.getRewardGeneratedAmount().add(rewardAmount));\n            stakeOffset=stakeOffset.sub(rewardAmount);\n            bObject.amount=bObject.amount.add(rewardAmount);\n            dContract.updateBetArrayIndex(bObject,index);\n        }else{\n            bObject.status=2;\n            uint256 riskAmount=(uint256(bObject.riskFactor).mul(bObject.amount)).div(10**4);\n            stakeOffset=stakeOffset.add(riskAmount);\n            bObject.amount=bObject.amount.sub(riskAmount);\n            dContract.updateBetArrayIndex(bObject,index);\n        }\n        dContract.updateExistingBetCheckMapping(bObject.userAddress,bObject.betType,bObject.contractAddress,false);\n    }\n    \n    function getCalculateIndexValueForFixed(uint256 index) public view returns(uint256){\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        uint256 totalMarketcap;\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n        for(uint256 i=0;i<dContract.getBetIndexForFixedArray(bObject.id).length;i++){\n            Token tObj=Token(dContract.getBetIndexForFixedArray(bObject.id)[i].contractAddress);\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getBetIndexForFixedArray(bObject.id)[i].contractAddress);\n            if(iCObj.status){\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n            }\n        }\n        return totalMarketcap;\n    }\n    \n    function updateXIVForStakersIndexFixed(uint256 index) internal{\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        uint256 totalMarketcap=getCalculateIndexValueForFixed(index);\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n        if(dContract.getBetPriceHistoryFixedMapping(bObject.id).actualIndexValue>totalMarketcap){\n             uint16 percentageValue=uint16(((dContract.getBetPriceHistoryFixedMapping(bObject.id).actualIndexValue\n                                                .sub(totalMarketcap)\n                                                .mul(10**4)).div(dContract.getBetPriceHistoryFixedMapping(bObject.id).actualIndexValue)));\n            if(percentageValue>=bObject.checkpointPercent){\n                updateXIVForStakers(index, true);\n            }else{\n                updateXIVForStakers(index, false);\n            }\n        }else{\n            updateXIVForStakers(index, false);\n        }\n    }\n    function getCalculateIndexValueForFlexible(uint256 index) public view returns(uint256){\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        uint256 totalMarketcap;\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n        for(uint256 i=0;i<dContract.getBetIndexForFlexibleArray(bObject.id).length;i++){\n            Token tObj=Token(dContract.getBetIndexForFlexibleArray(bObject.id)[i].contractAddress);\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getBetIndexForFlexibleArray(bObject.id)[i].contractAddress);\n            if(iCObj.status){\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n            }\n        }\n        return totalMarketcap;\n    }\n    function marketCapValue(XIVDatabaseLib.IndexCoin memory iCObj,Token tObj) internal view returns(uint256){\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\n         if((keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked(\"ETH\"))) || (keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked(\"BTC\")))){\n            return ((((oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\n                                    /*    .mul(iCObj.contributionPercentage)*/)\n                                        .div(10**2)));\n        }else{\n            return (((tObj.totalSupply().mul(oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\n                                /*.mul(iCObj.contributionPercentage)*/)\n                                .div((10**tObj.decimals()).mul(10**2))));\n        }\n    }\n    function updateXIVForStakersIndexFlexible(uint256 index) internal{\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        uint256 totalMarketcap=getCalculateIndexValueForFlexible(index);\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n        if(dContract.getBetPriceHistoryFlexibleMapping(bObject.id).actualIndexValue>totalMarketcap){\n             uint16 percentageValue=uint16(((dContract.getBetPriceHistoryFlexibleMapping(bObject.id).actualIndexValue.sub(totalMarketcap)\n                                                     .mul(10**4)).div(dContract.getBetPriceHistoryFlexibleMapping(bObject.id).actualIndexValue)));\n            if(percentageValue>=bObject.checkpointPercent){\n                updateXIVForStakers(index, true);\n            }else{\n                updateXIVForStakers(index, false);\n            }\n        }else{\n            updateXIVForStakers(index, false);\n        }\n    }\n    \n    function updateDatabaseAddress(address _databaseContractAddress) external onlyOwner{\n        databaseContractAddress=_databaseContractAddress;\n    }\n}\n"
    },
    "XIVDatabaseLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\npragma abicoder v2;\n\nlibrary XIVDatabaseLib{\n    // deficoin struct for deficoinmappings..\n    struct DefiCoin{\n        uint16 oracleType;\n        string currencySymbol;\n        bool status;\n    }\n    struct TimePeriod{\n        uint256 _days;\n        bool status;\n    }\n     struct FlexibleInfo{\n        uint256 id;\n        uint16 upDownPercentage; //10**2\n        uint16 riskFactor;       //10**2\n        uint16 rewardFactor;     //10**2\n        bool status;\n    }\n    struct FixedInfo{\n        uint256 id;\n        uint256 daysCount;// integer value\n        uint16 upDownPercentage; //10**2\n        uint16 riskFactor;       //10**2\n        uint16 rewardFactor;     //10**2\n        bool status;\n    }\n    struct IndexCoin{\n        uint16 oracleType;\n        string currencySymbol;\n        address contractAddress;\n        bool status;\n        uint256 contributionPercentage; //10**2\n    }\n    struct BetPriceHistory{\n        uint256 baseIndexValue;\n        uint256 actualIndexValue;\n    }\n    struct LPLockedInfo{\n        uint256 lockedTimeStamp;\n        uint256 amountLocked;\n    }\n    struct StakingInfo{\n        uint256 investmentId;\n        uint256 stakeAmount;\n    }\n    struct IncentiveInfo{\n        uint256 tillInvestmentId;\n        uint256 incentiveAmount;\n        uint256 totalAmountStakedAtIncentiveTime;\n    }\n    struct BetInfo{\n        uint256 id;\n        uint256 principalAmount;\n        uint256 amount;\n        address userAddress;\n        address contractAddress;\n        uint256 betType; //\n        uint256 currentPrice;\n        uint256 timestamp;\n        uint256 betTimePeriod;\n        uint16 checkpointPercent;\n        uint16 rewardFactor;\n        uint16 riskFactor;\n        uint256 adminCommissionFee;\n        uint16 status; // 0->bet active, 1->bet won, 2->bet lost, 3-> withdraw before result\n    }\n}\n"
    },
    "XIVInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\npragma abicoder v2;\n\nimport \"./XIVDatabaseLib.sol\";\n\ninterface Token{\n    function decimals() external view returns(uint256);\n    function symbol() external view returns(string memory);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n}\n\n\ninterface OracleWrapper{\n    function getPrice(string calldata currencySymbol,uint256 oracleType) external view returns (uint256);\n}\ninterface DatabaseContract{\n    function transferTokens(address contractAddress,address userAddress,uint256 amount) external;\n    function transferFromTokens(address contractAddress,address fromAddress, address toAddress,uint256 amount) external;\n    function getTokensStaked(address userAddress) external view returns(uint256);\n    function updateTokensStaked(address userAddress, uint256 amount) external;\n    function getTokenStakedAmount() external view returns(uint256);\n    function updateTokenStakedAmount(uint256 _tokenStakedAmount) external;\n    function getBetId() external view returns(uint256);\n    function updateBetId(uint256 _userBetId) external;\n    function updateBetArray(XIVDatabaseLib.BetInfo memory bObject) external;\n    function getBetArray() external view returns(XIVDatabaseLib.BetInfo[] memory);\n    function getFindBetInArrayUsingBetIdMapping(uint256 _betid) external view returns(uint256);\n    function updateFindBetInArrayUsingBetIdMapping(uint256 _betid, uint256 value) external;\n    function updateUserStakedAddress(address _address) external;\n    function updateUserStakedAddress(address[] memory _userStakedAddress) external;\n    function getUserStakedAddress() external view returns(address[] memory);\n    function getDefiCoinsFixedMapping(address _betContractAddress,bool isFlashVault) external view returns(XIVDatabaseLib.DefiCoin memory);\n    function getDefiCoinsFlexibleMapping(address _betContractAddress) external view returns(XIVDatabaseLib.DefiCoin memory);\n    function getFlexibleDefiCoinArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\n    function getFlexibleIndexArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\n    function updateBetArrayIndex(XIVDatabaseLib.BetInfo memory bObject, uint256 index) external;\n    function updateBetIndexForFixedArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\n    function updateBetBaseIndexValue(uint256 _betBaseIndexValueFixed) external;\n    function getBetBaseIndexValue() external view returns(uint256);\n    function updateBetPriceHistoryFixedMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\n    function updateBetActualIndexValue(uint256 _betActualIndexValueFixed) external;\n    function getBetActualIndexValue() external view returns(uint256);\n    function getBetIndexForFixedArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\n    function getBetPriceHistoryFixedMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\n    function getXIVTokenContractAddress() external view returns(address);\n    function getAllIndexContractAddressArray() external view returns(address[] memory);\n    function getDefiCoinIndexMapping(address _ContractAddress) external view returns(XIVDatabaseLib.IndexCoin memory);\n    \n    function updateBetIndexForFlexibleArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\n    function getBetIndexForFlexibleArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\n    function updateBetPriceHistoryFlexibleMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\n    function getBetPriceHistoryFlexibleMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\n    \n    function getOracleWrapperContractAddress() external view returns(address);\n    function getPlentyOneDayPercentage() external view returns(uint256);\n    function getPlentyThreeDayPercentage(uint256 _days) external view returns(uint256);\n    function getPlentySevenDayPercentage(uint256 _days) external view returns(uint256);\n    function getBetsAccordingToUserAddress(address userAddress) external view returns(uint256[] memory);\n    function updateBetAddressesArray(address userAddress, uint256 _betId) external;\n    function getRewardGeneratedAmount() external view returns(uint256);\n    function updateRewardGeneratedAmount(uint256 _rewardGeneratedAmount) external;\n    function addUserAddressUsedForBetting(address userAddress) external;\n    function getUserAddressUsedForBetting() external view returns(address[] memory);\n    function getFixedDefiCoinArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\n    function getFixedDefiIndexArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\n    function getMaxStakeXIVAmount() external view returns(uint256);\n    function getMinStakeXIVAmount() external view returns(uint256);\n    function getBetFactorLP() external view returns(uint256);\n    function updateActualAmountStakedByUser(address userAddress, uint256 amount) external;\n    function getActualAmountStakedByUser(address userAddress) external view returns(uint256);\n    function isDaysAvailable(uint256 _days) external view returns(bool);\n    function updateExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress,bool status) external;\n    function getExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress) external view returns(bool);\n    function updateTotalTransactions(uint256 _totalTransactions) external;\n    function getTotalTransactions() external view returns(uint256);\n    function getFlexibleDefiCoinTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\n    function getFlexibleIndexTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\n    function getMinLPvalue() external view returns(uint256);\n    function getLockingPeriodForLPMapping(address userAddress) external view returns(XIVDatabaseLib.LPLockedInfo memory);\n    function updateLockingPeriodForLPMapping(address userAddress, uint256 _amountLocked, uint256 _lockedTimeStamp) external;\n    function getStakingInfoMapping(address userAddress) external view returns(XIVDatabaseLib.StakingInfo[] memory);\n    function updateStakingInfoMapping(address userAddress, XIVDatabaseLib.StakingInfo memory sInfo) external;\n    function getInvestmentId() external view returns(uint256);\n    function updateInvestmentId(uint256 _investmentId) external;\n    function getSlotExecutionId() external view returns(uint256);\n    function updateSlotExecutionId(uint256 _slotExecutionId) external;\n    function getSlotId() external view returns(uint256);\n    function updateSlotId(uint256 _slotId) external;\n    function updateIncentiveMapping(uint256 _slotId, XIVDatabaseLib.IncentiveInfo memory iInfo) external;\n    function getIncentiveMapping(uint256 _slotId) external view returns(XIVDatabaseLib.IncentiveInfo[] memory);\n    function emitBetDetails(uint256  betId, uint256  status, uint256  betEndTime) external;\n    function emitLPEvent(uint256 typeOfLP, address userAddress, uint256 amount, uint256 timestamp) external ;\n    function updateIsStakeMapping(address userAddress,bool isStake) external;\n    function getIsStakeMapping(address userAddress) external view returns(bool);\n    \n}\n"
    }
  }
}