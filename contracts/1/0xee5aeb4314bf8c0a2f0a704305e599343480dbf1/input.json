{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DfInfo.sol":{"content":"// File: contracts/constants/ConstantAddressesMainnet.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\ncontract ConstantAddresses {\r\n    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    address public constant COMPOUND_ORACLE = 0x1D8aEdc9E924730DD3f9641CDb4D1B92B848b4bd;\r\n\r\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n\r\n    address public constant USDC_ADDRESS = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n    address public constant CUSDC_ADDRESS = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\r\n\r\n    address public constant WBTC_ADDRESS = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\r\n    address public constant CWBTC_ADDRESS = 0xC11b1268C1A384e55C48c2391d8d480264A3A7F4;\r\n\r\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    address public constant CDAI_ADDRESS = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\r\n\r\n    address public constant COMP_ADDRESS = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\r\n\r\n    address public constant USDT_ADDRESS = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n}\r\n\r\n// File: contracts/interfaces/IPriceOracle.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\ninterface IPriceOracle {\r\n    function price(string calldata symbol) external view returns (uint);\r\n}\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/IDfTokenizedDeposit.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\ninterface IDfTokenizedDeposit {\r\n    function token() external returns (IERC20);\r\n    function dfWallet() external returns (address);\r\n\r\n    function tokenETH() external returns (IERC20);\r\n    function tokenUSDC() external returns (IERC20);\r\n\r\n    function fundsUnwinded(address) external returns (uint256);\r\n}\r\n\r\n// File: contracts/compound/interfaces/ICToken.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\ninterface ICToken {\r\n    function borrowIndex() view external returns (uint256);\r\n\r\n    function mint(uint256 mintAmount) external returns (uint256);\r\n\r\n    function mint() external payable;\r\n\r\n    function redeem(uint256 redeemTokens) external returns (uint256);\r\n\r\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\r\n\r\n    function borrow(uint256 borrowAmount) external returns (uint256);\r\n\r\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\r\n\r\n    function repayBorrow() external payable;\r\n\r\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\r\n\r\n    function repayBorrowBehalf(address borrower) external payable;\r\n\r\n    function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral)\r\n        external\r\n        returns (uint256);\r\n\r\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\r\n\r\n    function exchangeRateCurrent() external returns (uint256);\r\n\r\n    function supplyRatePerBlock() external returns (uint256);\r\n\r\n    function borrowRatePerBlock() external returns (uint256);\r\n\r\n    function totalReserves() external returns (uint256);\r\n\r\n    function reserveFactorMantissa() external returns (uint256);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint256);\r\n\r\n    function borrowBalanceStored(address account) external view returns (uint256);\r\n\r\n    function totalBorrowsCurrent() external returns (uint256);\r\n\r\n    function getCash() external returns (uint256);\r\n\r\n    function balanceOfUnderlying(address owner) external returns (uint256);\r\n\r\n    function balanceOf(address owner) view external returns (uint256);\r\n\r\n    function underlying() external returns (address);\r\n}\r\n\r\n// File: contracts/deposits/DfInfo.sol\r\n\r\npragma solidity ^0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IComptroller {\r\n    function oracle() external view returns (IPriceOracle);\r\n\r\n    function getAccountLiquidity(address)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n}\r\n\r\ncontract DfInfo is ConstantAddresses {\r\n    function getInfo(IDfTokenizedDeposit dfTokenizedDepositAddress)\r\n        public\r\n        returns (\r\n            uint256 liquidity,\r\n            uint256 shortfall,\r\n            uint256 land,\r\n            uint256 cred,\r\n            uint256 f,\r\n            uint256[3] memory walletBalances,\r\n            uint256[3] memory unwindedBalances,\r\n            uint256[3] memory tokenBalances\r\n        )\r\n    {\r\n        address walletAddress = dfTokenizedDepositAddress.dfWallet();\r\n        uint256 err;\r\n        (err, liquidity, shortfall) = IComptroller(COMPTROLLER)\r\n            .getAccountLiquidity(walletAddress);\r\n\r\n        IPriceOracle compOracle = IComptroller(COMPTROLLER).oracle();\r\n\r\n        walletBalances[0] = ICToken(CDAI_ADDRESS).balanceOfUnderlying(\r\n            walletAddress\r\n        );\r\n        walletBalances[1] = ICToken(CUSDC_ADDRESS).balanceOfUnderlying(\r\n            walletAddress\r\n        );\r\n        walletBalances[2] = ICToken(CETH_ADDRESS).balanceOfUnderlying(\r\n            walletAddress\r\n        );\r\n        land =\r\n            (walletBalances[0] * compOracle.price(\"DAI\")) /\r\n            10**6 +\r\n            (walletBalances[1] * compOracle.price(\"USDC\")) /\r\n            10**6 +\r\n            (walletBalances[2] * compOracle.price(\"ETH\")) /\r\n            10**6;\r\n\r\n        walletBalances[0] -= ICToken(CDAI_ADDRESS).borrowBalanceCurrent(\r\n            walletAddress\r\n        );\r\n        walletBalances[1] -= ICToken(CUSDC_ADDRESS).borrowBalanceCurrent(\r\n            walletAddress\r\n        );\r\n        walletBalances[2] -= ICToken(CETH_ADDRESS).borrowBalanceCurrent(\r\n            walletAddress\r\n        );\r\n        cred +=\r\n            (ICToken(CDAI_ADDRESS).borrowBalanceCurrent(walletAddress) *\r\n                compOracle.price(\"DAI\")) /\r\n            10**6;\r\n        cred +=\r\n            (ICToken(CUSDC_ADDRESS).borrowBalanceCurrent(walletAddress) *\r\n                compOracle.price(\"USDC\")) /\r\n            10**6;\r\n        cred +=\r\n            (ICToken(CETH_ADDRESS).borrowBalanceCurrent(walletAddress) *\r\n                compOracle.price(\"ETH\")) /\r\n            10**6;\r\n\r\n        unwindedBalances[0] = dfTokenizedDepositAddress.fundsUnwinded(\r\n            DAI_ADDRESS\r\n        );\r\n        unwindedBalances[1] = dfTokenizedDepositAddress.fundsUnwinded(\r\n            USDC_ADDRESS\r\n        );\r\n        unwindedBalances[2] = dfTokenizedDepositAddress.fundsUnwinded(\r\n            WETH_ADDRESS\r\n        );\r\n\r\n        tokenBalances[0] = dfTokenizedDepositAddress.token().totalSupply();\r\n        tokenBalances[1] = dfTokenizedDepositAddress.tokenUSDC().totalSupply();\r\n        tokenBalances[2] = dfTokenizedDepositAddress.tokenETH().totalSupply();\r\n\r\n        f = (cred * 100) / land;\r\n    }\r\n}"}}}