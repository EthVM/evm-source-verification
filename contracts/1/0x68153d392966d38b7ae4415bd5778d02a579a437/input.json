{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/ACOAssetHelper.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\nlibrary ACOAssetHelper {\r\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n     * @dev Internal function to get if the address is for Ethereum (0x0).\r\n     * @param _address Address to be checked.\r\n     * @return Whether the address is for Ethereum.\r\n     */ \r\n    function _isEther(address _address) internal pure returns(bool) {\r\n        return _address == address(0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to approve ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param spender Authorized address.\r\n     * @param amount Amount to authorize.\r\n     */\r\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, amount));\r\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOAssetHelper::_callApproveERC20\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to transfer ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param recipient Address of the transfer destination.\r\n     * @param amount Amount to transfer.\r\n     */\r\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount));\r\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOAssetHelper::_callTransferERC20\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to call transferFrom on ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param sender Address of the sender.\r\n     * @param recipient Address of the transfer destination.\r\n     * @param amount Amount to transfer.\r\n     */\r\n     function _callTransferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\r\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOAssetHelper::_callTransferFromERC20\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset symbol.\r\n     * @param asset Address of the asset.\r\n     * @return The asset symbol.\r\n     */\r\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\r\n        if (_isEther(asset)) {\r\n            return \"ETH\";\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\r\n            require(success, \"ACOAssetHelper::_getAssetSymbol\");\r\n            return abi.decode(returndata, (string));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset decimals.\r\n     * @param asset Address of the asset.\r\n     * @return The asset decimals.\r\n     */\r\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\r\n        if (_isEther(asset)) {\r\n            return uint8(18);\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\r\n            require(success, \"ACOAssetHelper::_getAssetDecimals\");\r\n            return abi.decode(returndata, (uint8));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to the asset name.\r\n     * @param asset Address of the asset.\r\n     * @return The asset name.\r\n     */\r\n    function _getAssetName(address asset) internal view returns(string memory) {\r\n        if (_isEther(asset)) {\r\n            return \"Ethereum\";\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x06fdde03));\r\n            require(success, \"ACOAssetHelper::_getAssetName\");\r\n            return abi.decode(returndata, (string));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset balance of an account.\r\n     * @param asset Address of the asset.\r\n     * @param account Address of the account.\r\n     * @return The account balance.\r\n     */\r\n    function _getAssetBalanceOf(address asset, address account) internal view returns(uint256) {\r\n        if (_isEther(asset)) {\r\n            return account.balance;\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, account));\r\n            require(success, \"ACOAssetHelper::_getAssetBalanceOf\");\r\n            return abi.decode(returndata, (uint256));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset allowance between two addresses.\r\n     * @param asset Address of the asset.\r\n     * @param owner Address of the owner of the tokens.\r\n     * @param spender Address of the spender authorized.\r\n     * @return The owner allowance for the spender.\r\n     */\r\n    function _getAssetAllowance(address asset, address owner, address spender) internal view returns(uint256) {\r\n        if (_isEther(asset)) {\r\n            return 0;\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0xdd62ed3e, owner, spender));\r\n            require(success, \"ACOAssetHelper::_getAssetAllowance\");\r\n            return abi.decode(returndata, (uint256));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer an asset. \r\n     * @param asset Address of the asset to be transferred.\r\n     * @param to Address of the destination.\r\n     * @param amount The amount to be transferred.\r\n     */\r\n    function _transferAsset(address asset, address to, uint256 amount) internal {\r\n        if (_isEther(asset)) {\r\n            (bool success,) = to.call{value:amount}(new bytes(0));\r\n            require(success, 'ACOAssetHelper::_transferAsset');\r\n        } else {\r\n            _callTransferERC20(asset, to, amount);\r\n        }\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to receive an asset. \r\n     * @param asset Address of the asset to be received.\r\n     * @param amount The amount to be received.\r\n     */\r\n    function _receiveAsset(address asset, uint256 amount) internal {\r\n        if (_isEther(asset)) {\r\n            require(msg.value == amount, \"ACOAssetHelper:: Invalid ETH amount\");\r\n        } else {\r\n            require(msg.value == 0, \"ACOAssetHelper:: Ether is not expected\");\r\n            _callTransferFromERC20(asset, msg.sender, address(this), amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to check asset allowance and set to Infinity if necessary.\r\n     * @param asset Address of the asset.\r\n     * @param owner Address of the owner of the tokens.\r\n     * @param spender Address of the spender authorized.\r\n     * @param amount Amount to check allowance.\r\n     */\r\n    function _setAssetInfinityApprove(address asset, address owner, address spender, uint256 amount) internal {\r\n        if (_getAssetAllowance(asset, owner, spender) < amount) {\r\n            _callApproveERC20(asset, spender, MAX_UINT);\r\n        }\r\n    }\r\n}"
    },
    "browser/ACOPool2.sol": {
      "content": "pragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './Ownable.sol';\r\nimport './Address.sol';\r\nimport './ACOAssetHelper.sol';\r\nimport './ERC20.sol';\r\nimport './IACOFactory.sol';\r\nimport './IACOAssetConverterHelper.sol';\r\nimport './IACOToken.sol';\r\nimport './IChiToken.sol';\r\nimport './IACOPoolStrategy.sol';\r\nimport './IACOPool2.sol';\r\n\r\n/**\r\n * @title ACOPool2\r\n * @dev A pool contract to trade ACO tokens.\r\n * \r\n * The SC errors are defined as code to shrunk the SC bytes size and work around the EIP170.\r\n * The codes are explained in the table below:\r\n ********************************************************************************************\r\n * CODE | FUNCTION                            | DESCRIPTION\t\t\t\t\t\t            *\r\n *------------------------------------------------------------------------------------------*\r\n * E00  | init                                | SC is already initialized                   *\r\n *------------------------------------------------------------------------------------------*\r\n * E01  | init                                | Invalid ACO Factory address                 *\r\n *------------------------------------------------------------------------------------------*\r\n * E02  | init                                | Invalid Chi Token address                   *\r\n *------------------------------------------------------------------------------------------*\r\n * E03  | init                                | Underlying and strike asset are the same    *\r\n *------------------------------------------------------------------------------------------*\r\n * E04  | init                                | Invalid underlying address                  *\r\n *------------------------------------------------------------------------------------------*\r\n * E05  | init                                | Invalid strike asset address                *\r\n *------------------------------------------------------------------------------------------*\r\n * E10  | _deposit                            | Invalid collateral amount                   *\r\n *------------------------------------------------------------------------------------------*\r\n * E11  | _deposit                            | Invalid destination address                 *\r\n *------------------------------------------------------------------------------------------*\r\n * E12  | _deposit                            | The minimum shares were not satisfied       *\r\n *------------------------------------------------------------------------------------------*\r\n * E20  | _withdrawWithLocked                 | Invalid shares amount                       *\r\n *------------------------------------------------------------------------------------------*\r\n * E30  | _withdrawNoLocked                   | Invalid shares amount                       *\r\n *------------------------------------------------------------------------------------------*\r\n * E31  | _withdrawNoLocked                   | Collateral balance is not sufficient        *\r\n *------------------------------------------------------------------------------------------*\r\n * E32  | _withdrawNoLocked                   | The minimum collateral was not satisfied    *\r\n *------------------------------------------------------------------------------------------*\r\n * E33  | _withdrawNoLocked                   | Collateral balance is not sufficient        *\r\n *------------------------------------------------------------------------------------------*\r\n * E34  | _withdrawNoLocked                   | Collateral balance is not sufficient        *\r\n *------------------------------------------------------------------------------------------*\r\n * E40  | _swap                               | Swap deadline reached                       *\r\n *------------------------------------------------------------------------------------------*\r\n * E41  | _swap                               | Invalid destination address                 *\r\n *------------------------------------------------------------------------------------------*\r\n * E42  | _internalSelling                    | The maximum payment restriction was reached *\r\n *------------------------------------------------------------------------------------------*\r\n * E43  | _internalSelling                    | The maximum number of open ACOs was reached *\r\n *------------------------------------------------------------------------------------------*\r\n * E50  | _quote                              | Invalid token amount                        *\r\n *------------------------------------------------------------------------------------------*\r\n * E51  | _quote                              | Invalid ACO token                           *\r\n *------------------------------------------------------------------------------------------*\r\n * E52  | _quote                              | Invalid ACO token expiration                *\r\n *------------------------------------------------------------------------------------------*\r\n * E53  | _quote                              | Invalid ACO token strike price              *\r\n *------------------------------------------------------------------------------------------*\r\n * E54  | _quote                              | ACO token expired                           *\r\n *------------------------------------------------------------------------------------------*\r\n * E55  | _internalQuote                      | Invalid quoted price                        *\r\n *------------------------------------------------------------------------------------------*\r\n * E56  | _getSizeData                        | The token amount is too small               *\r\n *------------------------------------------------------------------------------------------*\r\n * E57  | _getSizeData                        | Insufficient liquidity                      *\r\n *------------------------------------------------------------------------------------------*\r\n * E60  | restoreCollateral                   | No balance to restore                       *\r\n *------------------------------------------------------------------------------------------*\r\n * E80  | withdrawStuckToken                  | The token is forbidden to withdraw          *\r\n *------------------------------------------------------------------------------------------*\r\n * E81  | _setStrategy                        | Invalid strategy address                    *\r\n *------------------------------------------------------------------------------------------*\r\n * E82  | _setBaseVolatility                  | Invalid base volatility                     *\r\n *------------------------------------------------------------------------------------------*\r\n * E83  | _setAssetConverter                  | Invalid asset converter address             *\r\n *------------------------------------------------------------------------------------------*\r\n * E84  | _setAssetConverter                  | No price on the Oracle                      *\r\n *------------------------------------------------------------------------------------------*\r\n * E85  | _setTolerancePriceAbove             | Invalid above tolerance percentage          *\r\n *------------------------------------------------------------------------------------------*\r\n * E86  | _setTolerancePriceBelow             | Invalid below tolerance percentage          *\r\n *------------------------------------------------------------------------------------------*\r\n * E87  | _setMinExpiration                   | Invalid minimum seconds for expiration      *\r\n *------------------------------------------------------------------------------------------*\r\n * E88  | _setMaxExpiration                   | Invalid maximum seconds for expiration      *\r\n *------------------------------------------------------------------------------------------*\r\n * E89  | _setFeeDestination                  | Invalid fee destination address             *\r\n *------------------------------------------------------------------------------------------*\r\n * E90  | onlyFactory                         | Only the pool factory can call the method   *\r\n *------------------------------------------------------------------------------------------*\r\n * E91  | _setFee                             | Invalid fee value                           *\r\n *------------------------------------------------------------------------------------------*\r\n * E92  | _setWithdrawOpenPositionPenalty     | Invalid penalty percentage                  *\r\n *------------------------------------------------------------------------------------------*\r\n * E93  | _setUnderlyingPriceAdjustPercentage | Invalid underlying price adjust percentage  *\r\n *------------------------------------------------------------------------------------------*\r\n * E94  | _setMaximumOpenAco                  | Invalid maximum number of open ACOs allowed *\r\n ********************************************************************************************\r\n */\r\ncontract ACOPool2 is Ownable, ERC20, IACOPool2 {\r\n    using Address for address;\r\n    \r\n    uint256 internal constant PERCENTAGE_PRECISION = 100000;\r\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n\t/**\r\n     * @dev Emitted when the asset converter address has been changed.\r\n     * @param oldAssetConverter Address of the previous asset converter.\r\n     * @param newAssetConverter Address of the new asset converter.\r\n     */\r\n    event SetAssetConverter(address indexed oldAssetConverter, address indexed newAssetConverter);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the above tolerance price has been changed.\r\n     * @param oldTolerancePriceAbove Value of the previous above tolerance price.\r\n     * @param newTolerancePriceAbove Value of the new above tolerance price.\r\n     */\r\n    event SetTolerancePriceAbove(uint256 indexed oldTolerancePriceAbove, uint256 indexed newTolerancePriceAbove);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the below tolerance price has been changed.\r\n     * @param oldTolerancePriceBelow Value of the previous below tolerance price.\r\n     * @param newTolerancePriceBelow Value of the new below tolerance price.\r\n     */\r\n    event SetTolerancePriceBelow(uint256 indexed oldTolerancePriceBelow, uint256 indexed newTolerancePriceBelow);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the minimum expiration has been changed.\r\n     * @param oldMinExpiration Value of the previous minimum expiration.\r\n     * @param newMinExpiration Value of the new minimum expiration.\r\n     */\r\n    event SetMinExpiration(uint256 indexed oldMinExpiration, uint256 indexed newMinExpiration);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the maximum expiration has been changed.\r\n     * @param oldMaxExpiration Value of the previous maximum expiration.\r\n     * @param newMaxExpiration Value of the new maximum expiration.\r\n     */\r\n    event SetMaxExpiration(uint256 indexed oldMaxExpiration, uint256 indexed newMaxExpiration);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the penalty percentage on withdrawing open positions has been changed.\r\n     * @param oldWithdrawOpenPositionPenalty Value of the previous penalty percentage on withdrawing open positions.\r\n     * @param newWithdrawOpenPositionPenalty Value of the new penalty percentage on withdrawing open positions.\r\n     */\r\n\tevent SetWithdrawOpenPositionPenalty(uint256 indexed oldWithdrawOpenPositionPenalty, uint256 indexed newWithdrawOpenPositionPenalty);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the underlying price percentage adjust has been changed.\r\n     * @param oldUnderlyingPriceAdjustPercentage Value of the previous underlying price percentage adjust.\r\n     * @param newUnderlyingPriceAdjustPercentage Value of the new underlying price percentage adjust.\r\n     */\r\n\tevent SetUnderlyingPriceAdjustPercentage(uint256 indexed oldUnderlyingPriceAdjustPercentage, uint256 indexed newUnderlyingPriceAdjustPercentage);\r\n\t\r\n    /**\r\n     * @dev Emitted when the number of maximum open ACOs allowed has been changed.\r\n     * @param oldMaximumOpenAco Value of the previous maximum number of open ACOs allowed.\r\n     * @param newMaximumOpenAco Value of the new maximum number of open ACOs allowed.\r\n     */\r\n\tevent SetMaximumOpenAco(uint256 indexed oldMaximumOpenAco, uint256 indexed newMaximumOpenAco);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the fee has been changed.\r\n     * @param oldFee Value of the previous fee.\r\n     * @param newFee Value of the new fee.\r\n     */\r\n    event SetFee(uint256 indexed oldFee, uint256 indexed newFee);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the fee destination has been changed.\r\n     * @param oldFeeDestination Address of the previous fee destination.\r\n     * @param newFeeDestination Address of the new fee destination.\r\n     */\r\n    event SetFeeDestination(address indexed oldFeeDestination, address indexed newFeeDestination);\r\n\t\r\n\t/**\r\n     * @dev Emitted when an valid creator permission has been changed.\r\n\t * @param creator Address of the creator.\r\n     * @param previousPermission Value of the previous permission.\r\n     * @param newPermission Value of the new permission.\r\n     */\r\n    event SetValidAcoCreator(address indexed creator, bool indexed previousPermission, bool indexed newPermission);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the strategy address has been changed.\r\n     * @param oldStrategy Address of the previous strategy.\r\n     * @param newStrategy Address of the new strategy.\r\n     */\r\n\tevent SetStrategy(address indexed oldStrategy, address indexed newStrategy);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the base volatility has been changed.\r\n     * @param oldBaseVolatility Value of the previous base volatility.\r\n     * @param newBaseVolatility Value of the new base volatility.\r\n     */\r\n    event SetBaseVolatility(uint256 indexed oldBaseVolatility, uint256 indexed newBaseVolatility);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the collateral has been restored on the pool.\r\n     * @param amountOut Amount of the premium sold.\r\n     * @param collateralRestored Amount of collateral restored.\r\n     */\r\n    event RestoreCollateral(uint256 amountOut, uint256 collateralRestored);\r\n\t\r\n\t/**\r\n     * @dev Emitted when an ACO token has been redeemed.\r\n     * @param acoToken Address of the ACO token.\r\n     * @param valueSold Total amount sold by the pool.\r\n     * @param collateralLocked Total amount of collateral locked.\r\n     * @param collateralRedeemed Total amount of collateral redeemed.\r\n     */\r\n\tevent ACORedeem(address indexed acoToken, uint256 valueSold, uint256 collateralLocked, uint256 collateralRedeemed);\r\n\t\r\n\t/**\r\n     * @dev Emitted when a collateral has been deposited on the pool.\r\n     * @param account Address of the account.\r\n\t * @param shares Amount of the shares minted.\r\n     * @param collateralAmount Collateral amount deposited.\r\n     */\r\n    event Deposit(address indexed account, uint256 shares, uint256 collateralAmount);\r\n\t\r\n\t/**\r\n     * @dev Emitted when an account has been withdrawn from the pool.\r\n     * @param account Address of the account.\r\n\t * @param shares Amount of the shares withdrawn.\r\n\t * @param noLocked TRUE if the withdrawal request is with NO locked collateral, otherwise FALSE.\r\n     * @param underlyingWithdrawn Amount of underlying withdrawn.\r\n\t * @param strikeAssetWithdrawn Amount of strike asset withdrawn.\r\n\t * @param acos Array of ACOs addresses with locked collateral transferred.\r\n\t * @param acosAmount Array of amount of ACOs with locked collateral transferred.\r\n     */\r\n    event Withdraw(\r\n\t\taddress indexed account, \r\n\t\tuint256 shares, \r\n\t\tbool noLocked, \r\n\t\tuint256 underlyingWithdrawn, \r\n\t\tuint256 strikeAssetWithdrawn, \r\n\t\taddress[] acos, \r\n\t\tuint256[] acosAmount\r\n\t);\r\n\t\r\n\t/**\r\n     * @dev Emitted when an ACO token has been sold by the pool.\r\n     * @param account Address of the account that is doing the swap.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens swapped.\r\n     * @param price Value of the premium paid in strike asset.\r\n     * @param protocolFee Value of the protocol fee paid in strike asset.\r\n     * @param underlyingPrice The underlying price in strike asset.\r\n\t * @param volatility The volatility used on the option price calculation.\r\n     */\r\n\tevent Swap(\r\n        address indexed account, \r\n        address indexed acoToken, \r\n        uint256 tokenAmount, \r\n        uint256 price, \r\n        uint256 protocolFee,\r\n        uint256 underlyingPrice,\r\n\t\tuint256 volatility\r\n    );\r\n\r\n\t/**\r\n\t * @dev Address of the ACO factory contract.\r\n\t */\r\n    IACOFactory public acoFactory;\r\n\t\r\n\t/**\r\n\t * @dev Address of the Chi gas token.\r\n\t */\r\n\tIChiToken public chiToken;\r\n\t\r\n\t/**\r\n\t * @dev Address of the underlying asset accepts by the pool.\r\n\t */\r\n    address public underlying;\r\n\t\r\n\t/**\r\n\t * @dev Address of the strike asset accepts by the pool.\r\n\t */\r\n    address public strikeAsset;\r\n\t\r\n\t/**\r\n\t * @dev True whether the pool accepts CALL options, otherwise the pool accepts only PUT options. \r\n\t */\r\n    bool public isCall;\r\n    \r\n\t/**\r\n\t * @dev Address of the asset converter helper.\r\n\t */\r\n    IACOAssetConverterHelper public assetConverter;\r\n\t\r\n\t/**\r\n\t * @dev Address of the strategy. \r\n\t */\r\n\tIACOPoolStrategy public strategy;\r\n\t\r\n\t/**\r\n\t * @dev Address of the protocol fee destination.\r\n\t */\r\n\taddress public feeDestination;\r\n\t\r\n\t/**\r\n\t * @dev Percentage value for the base volatility. (100000 = 100%) \r\n\t */\r\n    uint256 public baseVolatility;\r\n\t\r\n\t/**\r\n\t * @dev Percentage value for the above tolerance on the current price. Zero is ignored. (100000 = 100%) \r\n\t */\r\n    uint256 public tolerancePriceAbove;\r\n\t\r\n\t/**\r\n\t * @dev Percentage value for the below tolerance on the current price. Zero is ignored. (100000 = 100%) \r\n\t */\r\n    uint256 public tolerancePriceBelow;\r\n\t\r\n\t/**\r\n\t * @dev Minimum expiration seconds after current time to the pool accepts an ACO based on its expiry time. \r\n\t */\r\n    uint256 public minExpiration;\r\n\t\r\n\t/**\r\n\t * @dev Maximum expiration seconds after current time to the pool accepts an ACO based on its expiry time. \r\n\t */\r\n    uint256 public maxExpiration;\r\n\t\r\n\t/**\r\n\t * @dev The protocol fee percentage. (100000 = 100%)\r\n\t */\r\n    uint256 public fee;\r\n\t\r\n\t/**\r\n\t * @dev Percentage value for the penalty percentage on withdrawing open positions. (100000 = 100%)\r\n\t */\r\n\tuint256 public withdrawOpenPositionPenalty;\r\n\t\r\n\t/**\r\n\t * @dev Percentage value for the underlying price adjust. (100000 = 100%)\r\n\t */\r\n\tuint256 public underlyingPriceAdjustPercentage;\r\n\r\n    /**\r\n\t * @dev Maximum number of open ACOs allowed.\r\n\t */\r\n\tuint256 public maximumOpenAco;\r\n\t\r\n\t/**\r\n\t * @dev Array of ACO tokens negotiated.  \r\n\t */\r\n    address[] public acoTokens;\r\n\t\r\n\t/**\r\n\t * @dev Array of ACO tokens negotiated and currently active.  \r\n\t */\r\n    address[] public openAcos;\r\n\t\r\n\t/**\r\n\t * @dev Mapping for the valid ACO creators allowed by th pool.  \r\n\t */\r\n    mapping(address => bool) public validAcoCreators;\r\n\t\r\n\t/**\r\n\t * @dev Mapping for ACO tokens data negotiated.  \r\n\t */\r\n    mapping(address => AcoData) public acoData;\r\n\t\r\n\t/**\r\n\t * @dev Underlying asset precision. (18 decimals = 1000000000000000000)\r\n\t */\r\n\tuint256 internal underlyingPrecision;\r\n    \r\n\t/**\r\n     * @dev Modifier to apply the Chi gas token and save gas.\r\n     */\r\n\tmodifier discountCHI {\r\n        uint256 gasStart = gasleft();\r\n        _;\r\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\r\n        chiToken.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\r\n    }\r\n\t\r\n    /**\r\n     * @dev Function to initialize the contract.\r\n     * It should be called by the ACO pool factory when creating the pool.\r\n     * It must be called only once. The first `require` is to guarantee that behavior.\r\n     * @param initData The initialize data.\r\n     */\r\n    function init(InitData calldata initData) external override {\r\n\t\trequire(underlying == address(0) && strikeAsset == address(0), \"E00\");\r\n        \r\n        require(initData.acoFactory.isContract(), \"E01\");\r\n        require(initData.chiToken.isContract(), \"E02\");\r\n        require(initData.underlying != initData.strikeAsset, \"E03\");\r\n        require(ACOAssetHelper._isEther(initData.underlying) || initData.underlying.isContract(), \"E04\");\r\n        require(ACOAssetHelper._isEther(initData.strikeAsset) || initData.strikeAsset.isContract(), \"E05\");\r\n        \r\n        super.init();\r\n\r\n        acoFactory = IACOFactory(initData.acoFactory);\r\n        chiToken = IChiToken(initData.chiToken);\r\n        underlying = initData.underlying;\r\n        strikeAsset = initData.strikeAsset;\r\n        isCall = initData.isCall;\r\n\t\t\r\n        _setAssetConverter(initData.assetConverter);\r\n        _setFee(initData.fee);\r\n        _setFeeDestination(initData.feeDestination);\r\n\t\t_setWithdrawOpenPositionPenalty(initData.withdrawOpenPositionPenalty);\r\n\t\t_setUnderlyingPriceAdjustPercentage(initData.underlyingPriceAdjustPercentage);\r\n        _setMaximumOpenAco(initData.maximumOpenAco);\r\n        _setMaxExpiration(initData.maxExpiration);\r\n        _setMinExpiration(initData.minExpiration);\r\n        _setTolerancePriceAbove(initData.tolerancePriceAbove);\r\n        _setTolerancePriceBelow(initData.tolerancePriceBelow);\r\n        _setStrategy(initData.strategy);\r\n        _setBaseVolatility(initData.baseVolatility);\r\n\t\t\r\n\t\tunderlyingPrecision = 10 ** uint256(ACOAssetHelper._getAssetDecimals(initData.underlying));\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n\r\n    /**\r\n     * @dev Function to get the token name.\r\n     */\r\n    function name() public override view returns(string memory) {\r\n        return _name();\r\n    }\r\n\t\r\n    /**\r\n     * @dev Function to get the token symbol, that it is equal to the name.\r\n     */\r\n\tfunction symbol() public override view returns(string memory) {\r\n        return _name();\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to get the token decimals.\r\n     */\r\n    function decimals() public override view returns(uint8) {\r\n        return ACOAssetHelper._getAssetDecimals(collateral());\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to get the number of ACO tokens negotiated.\r\n     */\r\n    function numberOfAcoTokensNegotiated() external view override returns(uint256) {\r\n        return acoTokens.length;\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to get the number of ACO tokens negotiated and currently active.\r\n     */\r\n    function numberOfOpenAcoTokens() external view override returns(uint256) {\r\n        return openAcos.length;\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Function to get the pool collateral asset.\r\n     */\r\n\tfunction collateral() public view override returns(address) {\r\n        if (isCall) {\r\n            return underlying;\r\n        } else {\r\n            return strikeAsset;\r\n        }\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to get whether the pool can swap an ACO token.\r\n\t * @param acoToken Address of the ACO token.\r\n\t * @return TRUE whether it is possible, otherwise FALSE.\r\n     */\r\n    function canSwap(address acoToken) external view override returns(bool) {\r\n        (address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime) = acoFactory.acoTokenData(acoToken);\r\n\t\tif (_acoBasicDataIsValid(acoToken, _underlying, _strikeAsset, _isCall) && _acoExpirationIsValid(_expiryTime)) {\r\n            uint256 price = assetConverter.getPrice(_underlying, _strikeAsset);\r\n            return _acoStrikePriceIsValid(_strikePrice, price);\r\n        }\r\n        return false;\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Function to quote an ACO token swap.\r\n     * @param acoToken Address of the ACO token.\r\n     * @param tokenAmount Amount of ACO tokens to swap.\r\n     * @return swapPrice The swap price\r\n     * protocolFee the protocol fee charged on the swap\r\n     * underlyingPrice the underlying price in strike asset \r\n     * volatility the volatility used on the option price calculation.\r\n     */\r\n\tfunction quote(address acoToken, uint256 tokenAmount) external view override returns(\r\n        uint256 swapPrice, \r\n        uint256 protocolFee, \r\n        uint256 underlyingPrice, \r\n        uint256 volatility\r\n    ) {\r\n        (swapPrice, protocolFee, underlyingPrice, volatility,) = _quote(acoToken, tokenAmount);\r\n    }\r\n\t\r\n    /**\r\n     * @dev Function to get the shares for a collateral amount on deposit.\r\n     * @param collateralAmount Amount of collateral to be deposited.\r\n     * @return The shares to be received on the deposit.\r\n     */\r\n\tfunction getDepositShares(uint256 collateralAmount) external view override returns(uint256) {\r\n        return _getDepositShares(collateralAmount);\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to get the withdrawal data for a shares amount considering that there is NO locked collateral on the operation.\r\n     * @param shares Amount of shares to be withdrawn.\r\n     * @return underlyingWithdrawn The underlying amount on the withdraw\r\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\r\n     * isPossible TRUE whether it is possible to withdraw from that way (NO locked) or FALSE otherwise.\r\n     */\r\n\tfunction getWithdrawNoLockedData(uint256 shares) external view override returns(\r\n        uint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn,\r\n\t\tbool isPossible\r\n    ) {\r\n        (underlyingWithdrawn, strikeAssetWithdrawn, isPossible) = _getWithdrawNoLockedData(shares);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Function to get the withdrawal data for a shares amount considering that there is locked collateral on the operation.\r\n     * @param shares Amount of shares to be withdrawn.\r\n     * @return underlyingWithdrawn The underlying amount on the withdraw\r\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\r\n     * acos addresses of the ACOs with locked collateral that will be transferred\r\n     * acosAmount the respective ACOs amount to be transferred.\r\n     */\r\n\tfunction getWithdrawWithLocked(uint256 shares) external view override returns(\r\n        uint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn,\r\n\t\taddress[] memory acos,\r\n\t\tuint256[] memory acosAmount\r\n    ) {\r\n        (underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount) = _getWithdrawWithLocked(shares);\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to set the asset converter address.\r\n\t * Only can be called by the pool factory.\r\n     * @param newAssetConverter Address of the new asset converter.\r\n     */\r\n    function setAssetConverter(address newAssetConverter) external override {\r\n        onlyFactory();\r\n        _setAssetConverter(newAssetConverter);\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to set the percentage of the below price tolerance.\r\n\t * Only can be called by the pool factory.\r\n     * @param newTolerancePriceBelow Value of the new below price tolerance.\r\n     */\r\n    function setTolerancePriceBelow(uint256 newTolerancePriceBelow) external override {\r\n        onlyFactory();\r\n        _setTolerancePriceBelow(newTolerancePriceBelow);\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to set the percentage of the above price tolerance.\r\n\t * Only can be called by the pool factory.\r\n     * @param newTolerancePriceAbove Value of the new above price tolerance.\r\n     */\r\n    function setTolerancePriceAbove(uint256 newTolerancePriceAbove) external override {\r\n        onlyFactory();\r\n        _setTolerancePriceAbove(newTolerancePriceAbove);\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to set the minimum expiration seconds after current time to the pool accepts an ACO based on its expiry time.\r\n\t * Only can be called by the pool factory.\r\n     * @param newMinExpiration Value of the new minimum expiration.\r\n     */\r\n    function setMinExpiration(uint256 newMinExpiration) external override {\r\n        onlyFactory();\r\n        _setMinExpiration(newMinExpiration);\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to set the maximum expiration seconds after current time to the pool accepts an ACO based on its expiry time.\r\n\t * Only can be called by the pool factory.\r\n     * @param newMaxExpiration Value of the new maximum expiration.\r\n     */\r\n    function setMaxExpiration(uint256 newMaxExpiration) external override {\r\n        onlyFactory();\r\n        _setMaxExpiration(newMaxExpiration);\r\n    }\r\n    \r\n\t/**\r\n     * @dev Function to set the protocol fee percentage.\r\n\t * Only can be called by the pool factory.\r\n     * @param newFee Value of the new protocol fee.\r\n     */\r\n    function setFee(uint256 newFee) external override {\r\n        onlyFactory();\r\n        _setFee(newFee);\r\n    }\r\n    \r\n\t/**\r\n     * @dev Function to set the fee destination.\r\n\t * Only can be called by the pool factory.\r\n     * @param newFeeDestination Value of the new fee destination.\r\n     */\r\n    function setFeeDestination(address newFeeDestination) external override {\r\n        onlyFactory();\r\n        _setFeeDestination(newFeeDestination);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Function to set the penalty percentage on withdrawing open positions.\r\n\t * Only can be called by the pool factory.\r\n     * @param newWithdrawOpenPositionPenalty Value of the new penalty percentage on withdrawing open positions.\r\n     */\r\n\tfunction setWithdrawOpenPositionPenalty(uint256 newWithdrawOpenPositionPenalty) external override {\r\n        onlyFactory();\r\n\t\t_setWithdrawOpenPositionPenalty(newWithdrawOpenPositionPenalty);\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Function to set the underlying price percentage adjust.\r\n\t * Only can be called by the pool factory.\r\n     * @param newUnderlyingPriceAdjustPercentage Value of the new underlying price percentage adjust.\r\n     */\r\n\tfunction setUnderlyingPriceAdjustPercentage(uint256 newUnderlyingPriceAdjustPercentage) external override {\r\n        onlyFactory();\r\n\t\t_setUnderlyingPriceAdjustPercentage(newUnderlyingPriceAdjustPercentage);\r\n\t}\r\n\t\r\n    /**\r\n     * @dev Function to set the  maximum number of open ACOs allowed.\r\n\t * Only can be called by the pool factory.\r\n     * @param newMaximumOpenAco Value of the new maximum number of open ACOs allowed.\r\n     */\r\n\tfunction setMaximumOpenAco(uint256 newMaximumOpenAco) external override {\r\n        onlyFactory();\r\n\t\t_setMaximumOpenAco(newMaximumOpenAco);\r\n\t}\r\n\r\n\t/**\r\n     * @dev Function to set the strategy address.\r\n\t * Only can be called by the pool factory.\r\n     * @param newStrategy Address of the new strategy address.\r\n     */\r\n\tfunction setStrategy(address newStrategy) external override {\r\n        onlyFactory();\r\n\t\t_setStrategy(newStrategy);\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Function to set the base volatility.\r\n\t * Only can be called by the pool factory.\r\n     * @param newBaseVolatility Value of the new base volatility.\r\n     */\r\n\tfunction setBaseVolatility(uint256 newBaseVolatility) external override {\r\n        onlyFactory();\r\n\t\t_setBaseVolatility(newBaseVolatility);\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Function to set an valid creator permission.\r\n\t * Only can be called by the pool factory.\r\n     * @param newAcoCreator Address of the creator.\r\n\t * @param newPermission Value of the new permission.\r\n     */\r\n\tfunction setValidAcoCreator(address newAcoCreator, bool newPermission) external override {\r\n        onlyFactory();\r\n        _setValidAcoCreator(newAcoCreator, newPermission);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Function to withdraw a stucked token.\r\n\t * Only can be called by the pool factory.\r\n     * @param token Address of the token.\r\n\t * @param destination Address of the token destination.\r\n     */\r\n    function withdrawStuckToken(address token, address destination) external override {\r\n        onlyFactory();\r\n        require(token != underlying && token != strikeAsset && !acoData[token].open, \"E80\");\r\n        uint256 _balance = ACOAssetHelper._getAssetBalanceOf(token, address(this));\r\n        if (_balance > 0) {\r\n            ACOAssetHelper._transferAsset(token, destination, _balance);\r\n        }\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to deposit on the pool.\r\n     * @param collateralAmount Amount of collateral to be deposited.\r\n     * @param minShares The minimum amount of shares acceptable.\r\n     * @param to Address of the destination of the pool token.\r\n     * @return The amount of pool tokens minted.\r\n     */\r\n\tfunction deposit(uint256 collateralAmount, uint256 minShares, address to) external payable override returns(uint256) {\r\n        return _deposit(collateralAmount, minShares, to);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Function to deposit on the pool using Chi gas token to saving gas.\r\n     * @param collateralAmount Amount of collateral to be deposited.\r\n     * @param minShares The minimum amount of shares acceptable.\r\n     * @param to Address of the destination of the pool token.\r\n     * @return The amount of pool tokens minted.\r\n     */\r\n\tfunction depositWithGasToken(uint256 collateralAmount, uint256 minShares, address to) discountCHI external payable override returns(uint256) {\r\n        return _deposit(collateralAmount, minShares, to);\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to withdraw from the pool with NO locked collateral.\r\n     * @param shares Amount of the account shares to be withdrawn.\r\n     * @param minCollateral The minimum collateral amount acceptable on the withdrawal.\r\n     * @param account Address of the account to withdraw.\r\n     * @return underlyingWithdrawn The underlying amount on the withdraw\r\n     * strikeAssetWithdrawn the strike asset amount on the withdraw.\r\n     */\r\n\tfunction withdrawNoLocked(uint256 shares, uint256 minCollateral, address account) external override returns (\r\n\t\tuint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn\r\n\t) {\r\n        (underlyingWithdrawn, strikeAssetWithdrawn) = _withdrawNoLocked(shares, minCollateral, account);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Function to withdraw from the pool with NO locked collateral using Chi gas token to save gas.\r\n     * @param shares Amount of the account shares to be withdrawn.\r\n     * @param minCollateral The minimum collateral amount acceptable on the withdrawal.\r\n     * @param account Address of the account to withdraw.\r\n     * @return underlyingWithdrawn The underlying amount on the withdraw\r\n     * strikeAssetWithdrawn the strike asset amount on the withdraw.\r\n     */\r\n\tfunction withdrawNoLockedWithGasToken(uint256 shares, uint256 minCollateral, address account) discountCHI external override returns (\r\n\t\tuint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn\r\n\t) {\r\n        (underlyingWithdrawn, strikeAssetWithdrawn) = _withdrawNoLocked(shares, minCollateral, account);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Function to withdraw from the pool and transferring the locked collateral and the obligation to redeem it on the expiration.\r\n     * @param shares Amount of the account shares to be withdrawn.\r\n     * @param account Address of the account to withdraw.\r\n     * @return underlyingWithdrawn The underlying amount on the withdraw\r\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\r\n     * acos addresses of the ACOs with locked collateral that will be transferred\r\n     * acosAmount the respective ACOs amount to be transferred.\r\n     */\r\n    function withdrawWithLocked(uint256 shares, address account) external override returns (\r\n\t\tuint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn,\r\n\t\taddress[] memory acos,\r\n\t\tuint256[] memory acosAmount\r\n\t) {\r\n        (underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount) = _withdrawWithLocked(shares, account);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Function to withdraw from the pool and transferring the locked collateral and the obligation to redeem it on the expiration using Chi gas token to save gas.\r\n     * @param shares Amount of the account shares to be withdrawn.\r\n     * @param account Address of the account to withdraw.\r\n     * @return underlyingWithdrawn The underlying amount on the withdraw\r\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\r\n     * acos addresses of the ACOs with locked collateral that will be transferred\r\n     * acosAmount the respective ACOs amount to be transferred.\r\n     */\r\n\tfunction withdrawWithLockedWithGasToken(uint256 shares, address account) discountCHI external override returns (\r\n\t\tuint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn,\r\n\t\taddress[] memory acos,\r\n\t\tuint256[] memory acosAmount\r\n\t) {\r\n        (underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount) = _withdrawWithLocked(shares, account);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Function to swap an ACO token with the pool.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens to swap.\r\n     * @param restriction The maximum value to pay on the ACO purchase.\r\n     * @param to Address of the destination of the ACO tokens.\r\n     * @param deadline UNIX deadline for the swap to be executed.\r\n     */\r\n\tfunction swap(\r\n        address acoToken, \r\n        uint256 tokenAmount, \r\n        uint256 restriction, \r\n        address to, \r\n        uint256 deadline\r\n    ) external override {\r\n        _swap(acoToken, tokenAmount, restriction, to, deadline);\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to swap an ACO token with the pool using Chi gas token to save gas.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens to swap.\r\n     * @param restriction The maximum value to pay on the ACO purchase.\r\n     * @param to Address of the destination of the ACO tokens.\r\n     * @param deadline UNIX deadline for the swap to be executed.\r\n     */\r\n    function swapWithGasToken(\r\n        address acoToken, \r\n        uint256 tokenAmount, \r\n        uint256 restriction, \r\n        address to, \r\n        uint256 deadline\r\n    ) discountCHI external override {\r\n        _swap(acoToken, tokenAmount, restriction, to, deadline);\r\n    }\r\n    \r\n\t/**\r\n     * @dev Function to redeem the collateral from the active ACO tokens negotiated on the pool.\r\n     * It redeems the collateral only if the respective ACO token is expired.\r\n     */\r\n    function redeemACOTokens() public override {\r\n        for (uint256 i = openAcos.length; i > 0; --i) {\r\n            address acoToken = openAcos[i - 1];\r\n            _redeemACOToken(acoToken);\r\n        }\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to redeem the collateral from an ACO token.\r\n     * It redeems the collateral only if the ACO token is expired.\r\n     * @param acoToken Address of the ACO token.\r\n     */\r\n\tfunction redeemACOToken(address acoToken) external override {\r\n\t\t_redeemACOToken(acoToken);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Function to restore the collateral on the pool by selling the other asset balance.\r\n     */\r\n\tfunction restoreCollateral() external override {\r\n        address _strikeAsset = strikeAsset;\r\n        address _underlying = underlying;\r\n        bool _isCall = isCall;\r\n        \r\n        uint256 balanceOut;\r\n        address assetIn;\r\n        address assetOut;\r\n        if (_isCall) {\r\n            balanceOut = _getPoolBalanceOf(_strikeAsset);\r\n            assetIn = _underlying;\r\n            assetOut = _strikeAsset;\r\n        } else {\r\n            balanceOut = _getPoolBalanceOf(_underlying);\r\n            assetIn = _strikeAsset;\r\n            assetOut = _underlying;\r\n        }\r\n        require(balanceOut > 0, \"E60\");\r\n        \r\n\t\tuint256 etherAmount = 0;\r\n        if (ACOAssetHelper._isEther(assetOut)) {\r\n\t\t\tetherAmount = balanceOut;\r\n        }\r\n        uint256 collateralRestored = assetConverter.swapExactAmountOut{value: etherAmount}(assetOut, assetIn, balanceOut);\r\n\r\n        emit RestoreCollateral(balanceOut, collateralRestored);\r\n    }\r\n\r\n\t/**\r\n     * @dev Internal function to deposit on the pool.\r\n     * @param collateralAmount Amount of collateral to be deposited.\r\n     * @param minShares The minimum amount of shares acceptable.\r\n     * @param to Address of the destination of the pool token.\r\n     * @return shares The amount of pool tokens minted.\r\n     */\r\n\tfunction _deposit(uint256 collateralAmount, uint256 minShares, address to) internal returns(uint256 shares) {\r\n        require(collateralAmount > 0, \"E10\");\r\n        require(to != address(0) && to != address(this), \"E11\");\r\n\t\t\r\n\t\t(,,uint256 collateralBalance, uint256 collateralOnOpenPosition,) = _getTotalCollateralBalance(true);\r\n\t\tcollateralBalance = collateralBalance.sub(collateralOnOpenPosition);\r\n\r\n\t\taddress _collateral = collateral();\r\n\t\tif (ACOAssetHelper._isEther(_collateral)) {\r\n            collateralBalance = collateralBalance.sub(msg.value);\r\n\t\t}\r\n        \r\n        if (collateralBalance == 0) {\r\n            shares = collateralAmount;\r\n        } else {\r\n            shares = collateralAmount.mul(totalSupply()).div(collateralBalance);\r\n        }\r\n        require(shares >= minShares, \"E12\");\r\n\r\n        ACOAssetHelper._receiveAsset(_collateral, collateralAmount);\r\n\r\n        super._mintAction(to, shares);\r\n        \r\n        emit Deposit(to, shares, collateralAmount);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to get the withdrawal data for a shares amount considering that there is locked collateral on the operation.\r\n     * @param shares Amount of shares to be withdrawn.\r\n     * @return underlyingWithdrawn The underlying amount on the withdraw\r\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\r\n     * acos addresses of the ACOs with locked collateral that will be transferred\r\n     * acosAmount the respective ACOs amount to be transferred.\r\n     */\r\n\tfunction _getWithdrawWithLocked(uint256 shares) internal view returns (\r\n\t\tuint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn,\r\n\t\taddress[] memory acos,\r\n\t\tuint256[] memory acosAmount\r\n\t) {\r\n        uint256 _totalSupply = totalSupply();\t\r\n        if (shares > 0 && shares <= _totalSupply) {\r\n        \r\n\t\t\tuint256 underlyingBalance = _getPoolBalanceOf(underlying);\r\n\t\t\tuint256 strikeAssetBalance = _getPoolBalanceOf(strikeAsset);\r\n\t\t\r\n            acos = new address[](openAcos.length);\r\n            acosAmount = new uint256[](openAcos.length);\r\n\t\t\tfor (uint256 i = 0; i < openAcos.length; ++i) {\r\n\t\t\t\taddress acoToken = openAcos[i];\r\n\t\t\t\tuint256 tokens = IACOToken(acoToken).currentCollateralizedTokens(address(this));\r\n\t\t\t\t\r\n\t\t\t\tacos[i] = acoToken;\r\n\t\t\t\tacosAmount[i] = tokens.mul(shares).div(_totalSupply);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(_totalSupply);\r\n\t\t\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(_totalSupply);\r\n\t\t}\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to get the shares for a collateral amount on deposit.\r\n     * @param collateralAmount Amount of collateral to be deposited.\r\n     * @return The shares to be received on the deposit.\r\n     */\r\n\tfunction _getDepositShares(uint256 collateralAmount) internal view returns(uint256) {\r\n        (,,uint256 collateralBalance, uint256 collateralOnOpenPosition,) = _getTotalCollateralBalance(true);\r\n\t\tcollateralBalance = collateralBalance.sub(collateralOnOpenPosition);\r\n\r\n        if (collateralBalance == 0) {\r\n            return collateralAmount;\r\n        } else {\r\n            return collateralAmount.mul(totalSupply()).div(collateralBalance);\r\n        }\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to get the withdrawal data for a shares amount considering that there is NO locked collateral on the operation.\r\n     * @param shares Amount of shares to be withdrawn.\r\n     * @return underlyingWithdrawn The underlying amount on the withdraw\r\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\r\n     * isPossible TRUE whether it is possible to withdraw from that way (NO locked) or FALSE otherwise.\r\n     */\r\n\tfunction _getWithdrawNoLockedData(uint256 shares) internal view returns (\r\n\t\tuint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn,\r\n\t\tbool isPossible\r\n\t) {\r\n        uint256 _totalSupply = totalSupply();\r\n\t\tif (shares > 0 && shares <= _totalSupply) {\r\n\t\t\t\r\n\t\t\t(uint256 underlyingBalance, \r\n             uint256 strikeAssetBalance, \r\n             uint256 collateralBalance, \r\n             uint256 collateralOnOpenPosition,\r\n             uint256 collateralLockedRedeemable) = _getTotalCollateralBalance(false);\r\n\r\n\t\t\tif (collateralBalance > collateralOnOpenPosition) {\r\n\t\t\t\t\r\n\t\t\t\tuint256 collateralAmount = shares.mul(collateralBalance.sub(collateralOnOpenPosition)).div(_totalSupply);\r\n\t\t\t\t\r\n\t\t\t\tif (isCall) {\r\n\t\t\t\t\tif (collateralAmount <= underlyingBalance.add(collateralLockedRedeemable)) {\r\n\t\t\t\t\t\tunderlyingWithdrawn = collateralAmount;\r\n\t\t\t\t\t\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(_totalSupply);\r\n\t\t\t\t\t\tisPossible = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (collateralAmount <= strikeAssetBalance.add(collateralLockedRedeemable)) {\r\n\t\t\t\t\tstrikeAssetWithdrawn = collateralAmount;\r\n\t\t\t\t\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(_totalSupply);\r\n\t\t\t\t\tisPossible = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n     * @dev Internal function to withdraw from the pool with NO locked collateral.\r\n     * @param shares Amount of the account shares to be withdrawn.\r\n     * @param minCollateral The minimum collateral amount acceptable on the withdrawal.\r\n     * @param account Address of the account to withdraw.\r\n     * @return underlyingWithdrawn The underlying amount on the withdraw\r\n     * strikeAssetWithdrawn the strike asset amount on the withdraw.\r\n     */\r\n    function _withdrawNoLocked(uint256 shares, uint256 minCollateral, address account) internal returns (\r\n\t\tuint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn\r\n\t) {\r\n        require(shares > 0, \"E30\");\r\n        \r\n\t\tredeemACOTokens();\r\n\t\t\r\n        uint256 _totalSupply = totalSupply();\r\n        _callBurn(account, shares);\r\n        \r\n\t\t(uint256 underlyingBalance, \r\n         uint256 strikeAssetBalance, \r\n         uint256 collateralBalance,\r\n         uint256 collateralOnOpenPosition,) = _getTotalCollateralBalance(false);\r\n\t\trequire(collateralBalance > collateralOnOpenPosition, \"E31\");\r\n\r\n\t\tuint256 collateralAmount = shares.mul(collateralBalance.sub(collateralOnOpenPosition)).div(_totalSupply);\r\n\t\trequire(collateralAmount >= minCollateral, \"E32\");\r\n\r\n        if (isCall) {\r\n\t\t\trequire(collateralAmount <= underlyingBalance, \"E33\");\r\n\t\t\tunderlyingWithdrawn = collateralAmount;\r\n\t\t\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(_totalSupply);\r\n        } else {\r\n\t\t\trequire(collateralAmount <= strikeAssetBalance, \"E34\");\r\n\t\t\tstrikeAssetWithdrawn = collateralAmount;\r\n\t\t\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(_totalSupply);\r\n\t\t}\r\n        \r\n\t\tACOAssetHelper._transferAsset(underlying, msg.sender, underlyingWithdrawn);\r\n\t\tACOAssetHelper._transferAsset(strikeAsset, msg.sender, strikeAssetWithdrawn);\r\n\t\t\r\n        emit Withdraw(account, shares, true, underlyingWithdrawn, strikeAssetWithdrawn, new address[](0), new uint256[](0));\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to withdraw from the pool and transferring the locked collateral and the obligation to redeem it on the expiration.\r\n     * @param shares Amount of the account shares to be withdrawn.\r\n     * @param account Address of the account to withdraw.\r\n     * @return underlyingWithdrawn The underlying amount on the withdraw\r\n     * strikeAssetWithdrawn the strike asset amount on the withdraw\r\n     * acos addresses of the ACOs with locked collateral that will be transferred\r\n     * acosAmount the respective ACOs amount to be transferred.\r\n     */\r\n\tfunction _withdrawWithLocked(uint256 shares, address account) internal returns (\r\n\t\tuint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn,\r\n\t\taddress[] memory acos,\r\n\t\tuint256[] memory acosAmount\r\n\t) {\r\n        require(shares > 0, \"E20\");\r\n        \r\n\t\tredeemACOTokens();\r\n\t\t\r\n        uint256 _totalSupply = totalSupply();\r\n        _callBurn(account, shares);\r\n        \r\n\t\taddress _underlying = underlying;\r\n\t\taddress _strikeAsset = strikeAsset;\r\n\t\tuint256 underlyingBalance = _getPoolBalanceOf(_underlying);\r\n\t\tuint256 strikeAssetBalance = _getPoolBalanceOf(_strikeAsset);\r\n\t\t\r\n\t\t(acos, acosAmount) = _transferOpenPositions(shares, _totalSupply);\r\n\t\t\r\n\t\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(_totalSupply);\r\n\t\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(_totalSupply);\r\n\t\t\r\n\t\tACOAssetHelper._transferAsset(_underlying, msg.sender, underlyingWithdrawn);\r\n\t\tACOAssetHelper._transferAsset(_strikeAsset, msg.sender, strikeAssetWithdrawn);\r\n\t\t\r\n        emit Withdraw(account, shares, false, underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to get the total collateral balance from the pool.\r\n     * @param isDeposit TRUE whether is a deposit operation, FALSE otherwise it is a withdraw.\r\n     * @return underlyingBalance The pool underlying balance\r\n     * strikeAssetBalance the pool strike asset balance \r\n     * collateralBalance the pool collateral balance considering the available, locked collateral and the open position\r\n     * collateralOnOpenPosition the pool collateral on open positions calculated using the options current price\r\n     * collateralLockedRedeemable the pool collateral locked that already can be redeem.\r\n     */\r\n\tfunction _getTotalCollateralBalance(bool isDeposit) internal view returns(\r\n        uint256 underlyingBalance, \r\n        uint256 strikeAssetBalance, \r\n        uint256 collateralBalance,\r\n        uint256 collateralOnOpenPosition,\r\n        uint256 collateralLockedRedeemable\r\n    ) {\r\n\t\tunderlyingBalance = _getPoolBalanceOf(underlying);\r\n\t\tstrikeAssetBalance = _getPoolBalanceOf(strikeAsset);\r\n\t\t\r\n\t\tuint256 underlyingPrice = assetConverter.getPrice(underlying, strikeAsset);\r\n\t\t\r\n\t\tif (isCall) {\r\n\t\t\tcollateralBalance = underlyingBalance;\r\n\t\t\tif (isDeposit && strikeAssetBalance > 0) {\r\n\t\t\t\tuint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, false); \r\n\t\t\t\tcollateralBalance = collateralBalance.add(strikeAssetBalance.mul(underlyingPrecision).div(priceAdjusted));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcollateralBalance = strikeAssetBalance;\r\n\t\t\tif (isDeposit && underlyingBalance > 0) {\r\n\t\t\t\tuint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, true); \r\n\t\t\t\tcollateralBalance = collateralBalance.add(underlyingBalance.mul(priceAdjusted).div(underlyingPrecision));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n        uint256 collateralLocked;\r\n\t\t(collateralLocked, collateralOnOpenPosition, collateralLockedRedeemable) = _poolOpenPositionCollateralBalance(underlyingPrice, isDeposit);\r\n\t\t\r\n        collateralBalance = collateralBalance.add(collateralLocked);\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Internal function to burn pool tokens.\r\n     * @param account Address of the account.\r\n     * @param tokenAmount Amount of pool tokens to be burned.\r\n     */\r\n\tfunction _callBurn(address account, uint256 tokenAmount) internal {\r\n        if (account == msg.sender) {\r\n            super._burnAction(account, tokenAmount);\r\n        } else {\r\n            super._burnFrom(account, tokenAmount);\r\n        }\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to swap an ACO token with the pool.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens to swap.\r\n     * @param restriction The maximum value to pay on the purchase.\r\n     * @param to Address of the ACO tokens destination.\r\n     * @param deadline UNIX deadline for the swap to be executed.\r\n     */\r\n\tfunction _swap(\r\n        address acoToken, \r\n        uint256 tokenAmount, \r\n        uint256 restriction, \r\n        address to, \r\n        uint256 deadline\r\n    ) internal {\r\n        require(block.timestamp <= deadline, \"E40\");\r\n        require(to != address(0) && to != acoToken && to != address(this), \"E41\");\r\n        \r\n        (uint256 swapPrice, uint256 protocolFee, uint256 underlyingPrice, uint256 volatility, uint256 collateralAmount) = _quote(acoToken, tokenAmount);\r\n        \r\n        _internalSelling(to, acoToken, collateralAmount, tokenAmount, restriction, swapPrice, protocolFee);\r\n\r\n        if (protocolFee > 0) {\r\n            ACOAssetHelper._transferAsset(strikeAsset, feeDestination, protocolFee);\r\n        }\r\n        \r\n        emit Swap(msg.sender, acoToken, tokenAmount, swapPrice, protocolFee, underlyingPrice, volatility);\r\n    }\r\n\r\n\t/**\r\n     * @dev Internal function to quote an ACO token price.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens to swap.\r\n     * @return swapPrice The quoted price\r\n     * protocolFee the protocol fee charged\r\n     * underlyingPrice the underlying price\r\n     * volatility the volatility used on the calculation\r\n     * collateralAmount the collateral amount.\r\n     */\r\n\tfunction _quote(address acoToken, uint256 tokenAmount) internal view returns(\r\n        uint256 swapPrice, \r\n        uint256 protocolFee, \r\n        uint256 underlyingPrice, \r\n        uint256 volatility, \r\n        uint256 collateralAmount\r\n    ) {\r\n        require(tokenAmount > 0, \"E50\");\r\n        \r\n        (address _underlying, address _strikeAsset, bool _isCall, uint256 strikePrice, uint256 expiryTime) = acoFactory.acoTokenData(acoToken);\r\n        \r\n\t\trequire(_acoBasicDataIsValid(acoToken, _underlying, _strikeAsset, _isCall), \"E51\");\r\n\t\trequire(_acoExpirationIsValid(expiryTime), \"E52\");\r\n\t\t\r\n\t\tunderlyingPrice = assetConverter.getPrice(_underlying, _strikeAsset);\r\n\t\trequire(_acoStrikePriceIsValid(strikePrice, underlyingPrice), \"E53\");\r\n\r\n        require(expiryTime > block.timestamp, \"E54\");\r\n        (swapPrice, protocolFee, volatility, collateralAmount) = _internalQuote(acoToken, tokenAmount, strikePrice, expiryTime, underlyingPrice);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to quote an ACO token price.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens to swap.\r\n\t * @param strikePrice ACO strike price.\r\n\t * @param expiryTime ACO expiry time on UNIX.\r\n\t * @param underlyingPrice The current underlying price.\r\n     * @return swapPrice The quoted price\r\n     * protocolFee the protocol fee charged\r\n     * volatility the volatility used on the calculation\r\n     * collateralAmount the collateral amount.\r\n     */\r\n\tfunction _internalQuote(\r\n\t\taddress acoToken, \r\n\t\tuint256 tokenAmount, \r\n\t\tuint256 strikePrice, \r\n\t\tuint256 expiryTime, \r\n\t\tuint256 underlyingPrice\r\n\t) internal view returns(\r\n        uint256 swapPrice, \r\n        uint256 protocolFee, \r\n        uint256 volatility, \r\n        uint256 collateralAmount\r\n    ) {\r\n        uint256 collateralAvailable;\r\n        (collateralAmount, collateralAvailable) = _getSizeData(acoToken, tokenAmount);\r\n        (swapPrice, volatility) = _strategyQuote(strikePrice, expiryTime, underlyingPrice, collateralAmount, collateralAvailable);\r\n        \r\n        swapPrice = swapPrice.mul(tokenAmount).div(underlyingPrecision);\r\n        \r\n        if (fee > 0) {\r\n            protocolFee = swapPrice.mul(fee).div(PERCENTAGE_PRECISION);\r\n\t\t\tswapPrice = swapPrice.add(protocolFee);\r\n        }\r\n        require(swapPrice > 0, \"E55\");\r\n    }\r\n\r\n\t/**\r\n     * @dev Internal function to the size data for a quote.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens to swap.\r\n     * @return collateralAmount The collateral amount \r\n     * collateralAvailable the collateral available on the pool.\r\n     */\r\n    function _getSizeData(address acoToken, uint256 tokenAmount) internal view returns(\r\n        uint256 collateralAmount, \r\n        uint256 collateralAvailable\r\n    ) {\r\n        if (isCall) {\r\n            collateralAvailable = _getPoolBalanceOf(underlying);\r\n            collateralAmount = tokenAmount; \r\n        } else {\r\n            collateralAvailable = _getPoolBalanceOf(strikeAsset);\r\n            collateralAmount = IACOToken(acoToken).getCollateralAmount(tokenAmount);\r\n            require(collateralAmount > 0, \"E56\");\r\n        }\r\n        require(collateralAmount <= collateralAvailable, \"E57\");\r\n    }\r\n\r\n\t/**\r\n     * @dev Internal function to quote on the strategy contract.\r\n\t * @param strikePrice ACO token strike price.\r\n     * @param expiryTime ACO token expiry time on UNIX.\r\n\t * @param underlyingPrice The current underlying price.\r\n     * @param collateralAmount Amount of collateral for the order size.\r\n     * @param collateralAvailable Amount of collateral available on the pool.\r\n     * @return swapPrice The quoted price\r\n     * volatility the volatility used on te option price calculation.\r\n     */\r\n    function _strategyQuote(\r\n        uint256 strikePrice,\r\n        uint256 expiryTime,\r\n        uint256 underlyingPrice,\r\n        uint256 collateralAmount,\r\n        uint256 collateralAvailable\r\n    ) internal view returns(uint256 swapPrice, uint256 volatility) {\r\n        (swapPrice, volatility) = strategy.quote(IACOPoolStrategy.OptionQuote(\r\n\t\t\tunderlyingPrice,\r\n            underlying, \r\n            strikeAsset, \r\n            isCall, \r\n            strikePrice, \r\n            expiryTime, \r\n            baseVolatility, \r\n            collateralAmount, \r\n            collateralAvailable\r\n        ));\r\n    }\r\n\r\n\t/**\r\n     * @dev Internal function to sell ACO tokens.\r\n     * @param to Address of the destination of the ACO tokens.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param collateralAmount Order collateral amount.\r\n     * @param tokenAmount Order token amount.\r\n     * @param maxPayment Maximum value to be paid for the ACO tokens.\r\n     * @param swapPrice The swap price quoted.\r\n     * @param protocolFee The protocol fee amount.\r\n     */\r\n    function _internalSelling(\r\n        address to,\r\n        address acoToken, \r\n        uint256 collateralAmount, \r\n        uint256 tokenAmount,\r\n        uint256 maxPayment,\r\n        uint256 swapPrice,\r\n        uint256 protocolFee\r\n    ) internal {\r\n        require(swapPrice <= maxPayment, \"E42\");\r\n        \r\n        ACOAssetHelper._callTransferFromERC20(strikeAsset, msg.sender, address(this), swapPrice);\r\n\r\n\t\taddress _collateral = collateral();\r\n        AcoData storage data = acoData[acoToken];\r\n\t\tif (ACOAssetHelper._isEther(_collateral)) {\r\n\t\t\ttokenAmount = IACOToken(acoToken).mintPayable{value: collateralAmount}();\r\n\t\t} else {\r\n\t\t\tif (!data.open) {\r\n\t\t\t\t_setAuthorizedSpender(_collateral, acoToken);    \r\n\t\t\t}\r\n\t\t\ttokenAmount = IACOToken(acoToken).mint(collateralAmount);\r\n\t\t}\r\n\r\n\t\tif (!data.open) {\r\n            require(openAcos.length < maximumOpenAco, \"E43\");\r\n\t\t\tacoData[acoToken] = AcoData(true, swapPrice.sub(protocolFee), collateralAmount, 0, acoTokens.length, openAcos.length);\r\n            acoTokens.push(acoToken);    \r\n            openAcos.push(acoToken);   \r\n        } else {\r\n\t\t\tdata.collateralLocked = collateralAmount.add(data.collateralLocked);\r\n\t\t\tdata.valueSold = swapPrice.sub(protocolFee).add(data.valueSold);\r\n\t\t}\r\n        \r\n        ACOAssetHelper._callTransferERC20(acoToken, to, tokenAmount);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to get the pool colletaral balance from the active ACOs.\r\n\t * @param underlyingPrice The current underlying price.\r\n\t * @param isDeposit TRUE whether it is a deposit operation, otherwise FALSE for a withdraw.\r\n\t * @return collateralLocked Total amount of collateral locked\r\n     * collateralOnOpenPosition the total collateral on open positions calculated using the options current price\r\n     * collateralLockedRedeemable the pool collateral locked that already can be redeem.\r\n     */\r\n\tfunction _poolOpenPositionCollateralBalance(uint256 underlyingPrice, bool isDeposit) internal view returns(\r\n        uint256 collateralLocked, \r\n        uint256 collateralOnOpenPosition,\r\n        uint256 collateralLockedRedeemable\r\n    ) {\r\n\t\tbool _collateralIsUnderlying = isCall;\r\n        uint256 _underlyingPrecision = underlyingPrecision;\r\n        IACOFactory _acoFactory = acoFactory;\r\n\t\tfor (uint256 i = 0; i < openAcos.length; ++i) {\r\n\t\t\taddress acoToken = openAcos[i];\r\n\r\n            (uint256 locked, uint256 openPosition, uint256 lockedRedeemable) = _getOpenPositionCollateralBalance(\r\n                acoToken,\r\n                underlyingPrice,\r\n                _underlyingPrecision,\r\n                _acoFactory,\r\n                _collateralIsUnderlying\r\n            );\r\n            \r\n            collateralLocked = collateralLocked.add(locked);\r\n            collateralOnOpenPosition = collateralOnOpenPosition.add(openPosition);\r\n            collateralLockedRedeemable = collateralLockedRedeemable.add(lockedRedeemable);\r\n\t\t}\r\n\t\tif (!isDeposit) {\r\n\t\t\tcollateralOnOpenPosition = collateralOnOpenPosition.mul(PERCENTAGE_PRECISION.add(withdrawOpenPositionPenalty)).div(PERCENTAGE_PRECISION);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n     * @dev Internal function to get the colletaral balance from the active ACO.\r\n     * @param acoToken Address of the ACO.\r\n\t * @param underlyingPrice The current underlying price.\r\n\t * @param _underlyingPrecision The underlying precision.\r\n\t * @param _acoFactory The ACO factory.\r\n\t * @param _collateralIsUnderlying TRUE whether the collateral is the underlying, otherwise FALSE for the strike asset as collateral.\r\n\t * @return collateralLocked Amount of collateral locked\r\n     * collateralOnOpenPosition the collateral on open positions calculated using the options current price\r\n     * collateralLockedRedeemable the collateral locked that already can be redeem\r\n     */\r\n    function _getOpenPositionCollateralBalance(\r\n        address acoToken,\r\n        uint256 underlyingPrice,\r\n        uint256 _underlyingPrecision,\r\n        IACOFactory _acoFactory,\r\n        bool _collateralIsUnderlying\r\n    ) internal view returns(\r\n        uint256 collateralLocked, \r\n        uint256 collateralOnOpenPosition,\r\n        uint256 collateralLockedRedeemable\r\n    ) {\r\n        (,,,uint256 _strikePrice, uint256 _expiryTime) = _acoFactory.acoTokenData(acoToken);\r\n\t\t\t\r\n        uint256 tokenAmount = IACOToken(acoToken).currentCollateralizedTokens(address(this));\r\n        \r\n        if (_collateralIsUnderlying) {\r\n            collateralLocked = tokenAmount;\r\n        } else {\r\n            collateralLocked = tokenAmount.mul(_strikePrice).div(_underlyingPrecision);\r\n        }\r\n\t\t\r\n        if (_expiryTime > block.timestamp) {\r\n            (uint256 price,) = _strategyQuote(_strikePrice, _expiryTime, underlyingPrice, 0, 1);\r\n            if (_collateralIsUnderlying) {\r\n                uint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, false); \r\n                collateralOnOpenPosition = price.mul(tokenAmount).div(priceAdjusted);\r\n            } else {\r\n                collateralOnOpenPosition = price.mul(tokenAmount).div(_underlyingPrecision);\r\n            }\r\n        } else {\r\n            collateralLockedRedeemable = collateralLocked;\r\n        }\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to transfer the locked position.\r\n     * @param shares Amount of shares.\r\n\t * @param _totalSupply The pool total shares.\r\n\t * @return acos Addresses of the ACOs with locked collateral transferred\r\n     * acosAmount the respective ACOs amount transferred.\r\n     */\r\n\tfunction _transferOpenPositions(uint256 shares, uint256 _totalSupply) internal returns(\r\n        address[] memory acos, \r\n        uint256[] memory acosAmount\r\n    ) {\r\n        uint256 size = openAcos.length;\r\n        acos = new address[](size);\r\n        acosAmount = new uint256[](size);\r\n\t\tfor (uint256 i = 0; i < size; ++i) {\r\n\t\t\taddress acoToken = openAcos[i];\r\n\t\t\tuint256 tokens = IACOToken(acoToken).currentCollateralizedTokens(address(this));\r\n\t\t\t\r\n\t\t\tacos[i] = acoToken;\r\n\t\t\tacosAmount[i] = tokens.mul(shares).div(_totalSupply);\r\n\t\t\t\r\n            if (acosAmount[i] > 0) {\r\n\t\t\t    IACOToken(acoToken).transferCollateralOwnership(msg.sender, acosAmount[i]);\r\n            }\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Internal function to get the current underlying price adjusted to consider the Oracle delay to update.\r\n     * @param underlyingPrice The current underlying price.\r\n\t * @param isMaximum TRUE whether it is a maximum price, otherwise FALSE for a minimum price.\r\n\t * @return The underlying price adjusted.\r\n     */\r\n\tfunction _getUnderlyingPriceAdjusted(uint256 underlyingPrice, bool isMaximum) internal view returns(uint256) {\r\n\t\tif (isMaximum) {\r\n\t\t\treturn underlyingPrice.mul(PERCENTAGE_PRECISION.add(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\r\n\t\t} else {\r\n\t\t\treturn underlyingPrice.mul(PERCENTAGE_PRECISION.sub(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\r\n\t\t}\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to remove an active ACO token from the array.\r\n     * @param data The ACO data for the token.\r\n     */\r\n    function _removeFromOpenAcos(AcoData storage data) internal {\r\n        uint256 lastIndex = openAcos.length - 1;\r\n\t\tuint256 index = data.openIndex;\r\n\t\tif (lastIndex != index) {\r\n\t\t    address last = openAcos[lastIndex];\r\n\t\t\topenAcos[index] = last;\r\n\t\t\tacoData[last].openIndex = index;\r\n\t\t}\r\n\t\tdata.openIndex = 0;\r\n        openAcos.pop();\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to redeem the collateral from an ACO token.\r\n     * It redeems the collateral only if the ACO token is expired.\r\n     * @param acoToken Address of the ACO token.\r\n     */\r\n\tfunction _redeemACOToken(address acoToken) internal {\r\n\t\tAcoData storage data = acoData[acoToken];\r\n\t\tif (data.open && IACOToken(acoToken).expiryTime() <= block.timestamp) {\r\n\t\t\t\r\n            data.open = false;\r\n\r\n            if (IACOToken(acoToken).currentCollateralizedTokens(address(this)) > 0) {\t\r\n\t\t\t    data.collateralRedeemed = IACOToken(acoToken).redeem();\r\n            }\r\n            \r\n\t\t\t_removeFromOpenAcos(data);\r\n\t\t\t\r\n\t\t\temit ACORedeem(acoToken, data.valueSold, data.collateralLocked, data.collateralRedeemed);\r\n\t\t}\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to check whether the ACO assets and creator is valid for the pool.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param _underlying Address of the underlying.\r\n\t * @param _strikeAsset Address of the strike asset.\r\n\t * @param _isCall TRUE whether the ACO is a CALL option, FALSE for a PUT option.\r\n     * @return TRUE whether it is valid, otherwise FALSE.\r\n     */\r\n\tfunction _acoBasicDataIsValid(address acoToken, address _underlying, address _strikeAsset, bool _isCall) internal view returns(bool) {\r\n\t\treturn _underlying == underlying && _strikeAsset == strikeAsset && _isCall == isCall && validAcoCreators[acoFactory.creators(acoToken)];\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Internal function to check whether the ACO expiration is valid for the pool.\r\n     * @param _expiryTime ACO expiry time.\r\n     * @return TRUE whether it is valid, otherwise FALSE.\r\n     */\r\n\tfunction _acoExpirationIsValid(uint256 _expiryTime) internal view returns(bool) {\r\n\t\treturn _expiryTime >= block.timestamp.add(minExpiration) && _expiryTime <= block.timestamp.add(maxExpiration);\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Internal function to check whether the ACO strike asset is valid for the pool.\r\n     * @param _strikePrice ACO strike price.\r\n     * @param price Current underlying price.\r\n     * @return TRUE whether it is valid, otherwise FALSE.\r\n     */\r\n\tfunction _acoStrikePriceIsValid(uint256 _strikePrice, uint256 price) internal view returns(bool) {\r\n\t\tuint256 _tolerancePriceAbove = tolerancePriceAbove;\r\n\t\tuint256 _tolerancePriceBelow = tolerancePriceBelow;\r\n\t\treturn (_tolerancePriceBelow == 0 && _tolerancePriceAbove == 0) ||\r\n\t\t\t(_tolerancePriceBelow == 0 && _strikePrice > price.mul(PERCENTAGE_PRECISION.add(_tolerancePriceAbove)).div(PERCENTAGE_PRECISION)) ||\r\n\t\t\t(_tolerancePriceAbove == 0 && _strikePrice < price.mul(PERCENTAGE_PRECISION.sub(_tolerancePriceBelow)).div(PERCENTAGE_PRECISION)) ||\r\n\t\t\t(_strikePrice >= price.mul(PERCENTAGE_PRECISION.sub(_tolerancePriceBelow)).div(PERCENTAGE_PRECISION) && \r\n\t\t\t _strikePrice <= price.mul(PERCENTAGE_PRECISION.add(_tolerancePriceAbove)).div(PERCENTAGE_PRECISION));\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Internal function to infinite authorize the pool assets on the asset converter helper.\r\n     * @param _isCall True whether it is a CALL option, otherwise it is PUT.\r\n     * @param _assetConverterHelper Address of the asset converter helper.\r\n     * @param _underlying Address of the underlying asset.\r\n     * @param _strikeAsset Address of the strike asset.\r\n     */\r\n\tfunction _approveAssetsOnConverterHelper(\r\n        bool _isCall, \r\n        address _assetConverterHelper,\r\n        address _underlying,\r\n        address _strikeAsset\r\n    ) internal {\r\n        if (_isCall) {\r\n            if (!ACOAssetHelper._isEther(_strikeAsset)) {\r\n                _setAuthorizedSpender(_strikeAsset, _assetConverterHelper);\r\n            }\r\n        } else if (!ACOAssetHelper._isEther(_underlying)) {\r\n            _setAuthorizedSpender(_underlying, _assetConverterHelper);\r\n        }\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to get the pool balance of an asset.\r\n     * @param asset Address of the asset.\r\n     * @return The pool balance.\r\n     */\r\n\tfunction _getPoolBalanceOf(address asset) internal view returns(uint256) {\r\n        return ACOAssetHelper._getAssetBalanceOf(asset, address(this));\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to infinite authorize a spender on an asset.\r\n     * @param asset Address of the asset.\r\n     * @param spender Address of the spender to be authorized.\r\n     */\r\n\tfunction _setAuthorizedSpender(address asset, address spender) internal {\r\n        ACOAssetHelper._callApproveERC20(asset, spender, MAX_UINT);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to set the strategy address.\r\n     * @param newStrategy Address of the new strategy address.\r\n     */\r\n\tfunction _setStrategy(address newStrategy) internal {\r\n        require(newStrategy.isContract(), \"E81\");\r\n        emit SetStrategy(address(strategy), newStrategy);\r\n        strategy = IACOPoolStrategy(newStrategy);\r\n    }\r\n\r\n\t/**\r\n     * @dev Internal function to set the base volatility.\r\n     * @param newBaseVolatility Value of the new base volatility.\r\n     */\r\n    function _setBaseVolatility(uint256 newBaseVolatility) internal {\r\n        require(newBaseVolatility > 0, \"E82\");\r\n        emit SetBaseVolatility(baseVolatility, newBaseVolatility);\r\n        baseVolatility = newBaseVolatility;\r\n    }\r\n\r\n\t/**\r\n     * @dev Internal function to set the asset converter address.\r\n     * @param newAssetConverter Address of the new asset converter.\r\n     */\r\n    function _setAssetConverter(address newAssetConverter) internal {\r\n        require(newAssetConverter.isContract(), \"E83\");\r\n\t\trequire(IACOAssetConverterHelper(newAssetConverter).getPrice(underlying, strikeAsset) > 0, \"E84\");\r\n\t\t\r\n\t\t_approveAssetsOnConverterHelper(isCall, newAssetConverter, underlying, strikeAsset);\r\n\t\t\r\n        emit SetAssetConverter(address(assetConverter), newAssetConverter);\r\n        assetConverter = IACOAssetConverterHelper(newAssetConverter);\r\n    }\r\n\r\n\t/**\r\n     * @dev Internal function to set the percentage of the above price tolerance.\r\n     * @param newTolerancePriceAbove Value of the new above price tolerance.\r\n     */\r\n    function _setTolerancePriceAbove(uint256 newTolerancePriceAbove) internal {\r\n        require(newTolerancePriceAbove < PERCENTAGE_PRECISION, \"E85\");\r\n        emit SetTolerancePriceAbove(tolerancePriceAbove, newTolerancePriceAbove);\r\n        tolerancePriceAbove = newTolerancePriceAbove;\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to set the percentage of the below price tolerance.\r\n     * @param newTolerancePriceBelow Value of the new below price tolerance.\r\n     */\r\n    function _setTolerancePriceBelow(uint256 newTolerancePriceBelow) internal {\r\n        require(newTolerancePriceBelow < PERCENTAGE_PRECISION, \"E86\");\r\n        emit SetTolerancePriceBelow(tolerancePriceBelow, newTolerancePriceBelow);\r\n        tolerancePriceBelow = newTolerancePriceBelow;\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to set the minimum expiration seconds after current time to the pool accepts an ACO based on its expiry time.\r\n     * @param newMinExpiration Value of the new minimum expiration.\r\n     */\r\n    function _setMinExpiration(uint256 newMinExpiration) internal {\r\n        require(newMinExpiration <= maxExpiration, \"E87\");\r\n        emit SetMinExpiration(minExpiration, newMinExpiration);\r\n        minExpiration = newMinExpiration;\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to set the maximum expiration seconds after current time to the pool accepts an ACO based on its expiry time.\r\n     * @param newMaxExpiration Value of the new maximum expiration.\r\n     */\r\n    function _setMaxExpiration(uint256 newMaxExpiration) internal {\r\n        require(newMaxExpiration >= minExpiration, \"E88\");\r\n        emit SetMaxExpiration(maxExpiration, newMaxExpiration);\r\n        maxExpiration = newMaxExpiration;\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to set the fee destination.\r\n     * @param newFeeDestination Value of the new fee destination.\r\n     */\r\n    function _setFeeDestination(address newFeeDestination) internal {\r\n        require(newFeeDestination != address(0), \"E89\");\r\n        emit SetFeeDestination(feeDestination, newFeeDestination);\r\n        feeDestination = newFeeDestination;\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to set the protocol fee percentage.\r\n     * @param newFee Value of the new protocol fee.\r\n     */\r\n    function _setFee(uint256 newFee) internal {\r\n        require(newFee <= 12500, \"E91\");\r\n        emit SetFee(fee, newFee);\r\n        fee = newFee;\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to set the penalty percentage on withdrawing open positions.\r\n     * @param newWithdrawOpenPositionPenalty Value of the new penalty percentage on withdrawing open positions.\r\n     */\r\n    function _setWithdrawOpenPositionPenalty(uint256 newWithdrawOpenPositionPenalty) internal {\r\n        require(newWithdrawOpenPositionPenalty <= PERCENTAGE_PRECISION, \"E92\");\r\n        emit SetWithdrawOpenPositionPenalty(withdrawOpenPositionPenalty, newWithdrawOpenPositionPenalty);\r\n        withdrawOpenPositionPenalty = newWithdrawOpenPositionPenalty;\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to set the underlying price percentage adjust.\r\n     * @param newUnderlyingPriceAdjustPercentage Value of the new underlying price percentage adjust.\r\n     */\r\n\tfunction _setUnderlyingPriceAdjustPercentage(uint256 newUnderlyingPriceAdjustPercentage) internal {\r\n        require(newUnderlyingPriceAdjustPercentage < PERCENTAGE_PRECISION, \"E93\");\r\n        emit SetUnderlyingPriceAdjustPercentage(underlyingPriceAdjustPercentage, newUnderlyingPriceAdjustPercentage);\r\n        underlyingPriceAdjustPercentage = newUnderlyingPriceAdjustPercentage;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the maximum number of open ACOs allowed.\r\n     * @param newMaximumOpenAco Value of the new maximum number of open ACOs allowed.\r\n     */\r\n\tfunction _setMaximumOpenAco(uint256 newMaximumOpenAco) internal {\r\n        require(newMaximumOpenAco > 0, \"E94\");\r\n        emit SetMaximumOpenAco(maximumOpenAco, newMaximumOpenAco);\r\n        maximumOpenAco = newMaximumOpenAco;\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to set an valid creator permission.\r\n     * @param creator Address of the creator.\r\n\t * @param newPermission Value of the new permission.\r\n     */\r\n    function _setValidAcoCreator(address creator, bool newPermission) internal {\r\n        emit SetValidAcoCreator(creator, validAcoCreators[creator], newPermission);\r\n        validAcoCreators[creator] = newPermission;\r\n    }\r\n\r\n\t/**\r\n     * @dev Internal function to check whether the transaction sender is the pool factory.\r\n     */\r\n    function onlyFactory() internal view {\r\n        require(owner() == msg.sender, \"E90\");\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Internal function to get the token name.\r\n     * The token name is assembled with the token data:\r\n     * ACO POOL WRITE UNDERLYING_SYMBOL-STRIKE_ASSET_SYMBOL-TYPE\r\n     * @return The token name.\r\n     */\r\n\tfunction _name() internal view returns(string memory) {\r\n        return string(abi.encodePacked(\r\n            \"ACO POOL WRITE \",\r\n            ACOAssetHelper._getAssetSymbol(underlying),\r\n            \"-\",\r\n            ACOAssetHelper._getAssetSymbol(strikeAsset),\r\n            \"-\",\r\n            (isCall ? \"CALL\" : \"PUT\")\r\n        ));\r\n    }\r\n}"
    },
    "browser/Address.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n"
    },
    "browser/ERC20.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./IERC20.sol\";\r\n\r\n/**\r\n * @title ERC20\r\n * @dev Base implementation of ERC20 token.\r\n */\r\nabstract contract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n    \r\n    uint256 private _totalSupply;\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    function name() public view virtual returns(string memory);\r\n    function symbol() public view virtual returns(string memory);\r\n    function decimals() public view virtual returns(uint8);\r\n\r\n    function totalSupply() public view override returns(uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns(uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns(uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns(bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns(bool) {\r\n        _approveAction(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        _transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns(bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 amount) public returns(bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(amount));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 amount) public returns(bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(amount));\r\n        return true;\r\n    }\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        _transferAction(sender, recipient, amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        _approveAction(owner, spender, amount);\r\n    }\r\n    \r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _approveAction(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n        _burnAction(account, amount);\r\n    }\r\n\r\n    function _transferAction(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20::_transferAction: Invalid sender\");\r\n        require(recipient != address(0), \"ERC20::_transferAction: Invalid recipient\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        \r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n    \r\n    function _approveAction(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20::_approveAction: Invalid owner\");\r\n        require(spender != address(0), \"ERC20::_approveAction: Invalid spender\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        \r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    \r\n    function _mintAction(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20::_mintAction: Invalid account\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        \r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burnAction(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20::_burnAction: Invalid account\");\r\n\r\n        _balances[account] = _balances[account].sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        \r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n}    \r\n"
    },
    "browser/IACOAssetConverterHelper.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\ninterface IACOAssetConverterHelper {\r\n    function setPairTolerancePercentage(address baseAsset, address quoteAsset, uint256 tolerancePercentage) external;\r\n    function setAggregator(address baseAsset, address quoteAsset, address aggregator) external;\r\n    function setUniswapMiddleRoute(address baseAsset, address quoteAsset, address[] calldata uniswapMiddleRoute) external;\r\n    function withdrawStuckAsset(address asset, address destination) external;\r\n    function hasAggregator(address baseAsset, address quoteAsset) external view returns(bool);\r\n    function getPairData(address baseAsset, address quoteAsset) external view returns(address, uint256, uint256, uint256);\r\n    function getUniswapMiddleRouteByIndex(address baseAsset, address quoteAsset, uint256 index) external view returns(address);\r\n    function getPrice(address baseAsset, address quoteAsset) external view returns(uint256);\r\n    function getPriceWithTolerance(address baseAsset, address quoteAsset, bool isMinimumPrice) external view returns(uint256);\r\n    function getExpectedAmountOutToSwapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external view returns(uint256);\r\n    function getExpectedAmountOutToSwapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external view returns(uint256);\r\n    function swapExactAmountOut(address assetToSold, address assetToBuy, uint256 amountToSold) external payable returns(uint256);\r\n    function swapExactAmountOutWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 tolerancePercentage) external payable returns(uint256);\r\n    function swapExactAmountOutWithMinAmountToReceive(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 minAmountToReceive) external payable returns(uint256);\r\n    function swapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external payable returns(uint256);\r\n    function swapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external payable returns(uint256);\r\n    function swapExactAmountInWithMaxAmountToSold(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 maxAmountToSold) external payable returns(uint256);\r\n}"
    },
    "browser/IACOFactory.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\ninterface IACOFactory {\r\n\tfunction init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) external;\r\n    function acoFee() external view returns(uint256);\r\n    function factoryAdmin() external view returns(address);\r\n    function acoTokenImplementation() external view returns(address);\r\n    function acoFeeDestination() external view returns(address);\r\n    function acoTokenData(address acoToken) external view returns(address, address, bool, uint256, uint256);\r\n    function creators(address acoToken) external view returns(address);\r\n    function createAcoToken(address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime, uint256 maxExercisedAccounts) external returns(address);\r\n    function setFactoryAdmin(address newFactoryAdmin) external;\r\n    function setAcoTokenImplementation(address newAcoTokenImplementation) external;\r\n    function setAcoFee(uint256 newAcoFee) external;\r\n    function setAcoFeeDestination(address newAcoFeeDestination) external;\r\n}"
    },
    "browser/IACOPool2.sol": {
      "content": "pragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './IERC20.sol';\r\n\r\ninterface IACOPool2 is IERC20 {\r\n\r\n    struct InitData {\r\n        address acoFactory;\r\n        address chiToken;\r\n        address underlying;\r\n        address strikeAsset;\r\n        bool isCall; \r\n\t\taddress assetConverter;\r\n        uint256 fee;\r\n        address feeDestination;\r\n        uint256 withdrawOpenPositionPenalty;\r\n        uint256 underlyingPriceAdjustPercentage;\r\n\t\tuint256 maximumOpenAco;\r\n        uint256 tolerancePriceBelow;\r\n        uint256 tolerancePriceAbove; \r\n        uint256 minExpiration;\r\n        uint256 maxExpiration;\r\n        address strategy;\r\n        uint256 baseVolatility;    \r\n    }\r\n\r\n\tstruct AcoData {\r\n        bool open;\r\n        uint256 valueSold;\r\n        uint256 collateralLocked;\r\n        uint256 collateralRedeemed;\r\n        uint256 index;\r\n\t\tuint256 openIndex;\r\n    }\r\n    \r\n\tfunction init(InitData calldata initData) external;\r\n\tfunction numberOfAcoTokensNegotiated() external view returns(uint256);\r\n    function numberOfOpenAcoTokens() external view returns(uint256);\r\n    function collateral() external view returns(address);\r\n\tfunction canSwap(address acoToken) external view returns(bool);\r\n\tfunction quote(address acoToken, uint256 tokenAmount) external view returns(\r\n\t\tuint256 swapPrice, \r\n\t\tuint256 protocolFee, \r\n\t\tuint256 underlyingPrice, \r\n\t\tuint256 volatility\r\n\t);\r\n\tfunction getDepositShares(uint256 collateralAmount) external view returns(uint256 shares);\r\n\tfunction getWithdrawNoLockedData(uint256 shares) external view returns(\r\n\t\tuint256 underlyingWithdrawn, \r\n\t\tuint256 strikeAssetWithdrawn, \r\n\t\tbool isPossible\r\n\t);\r\n\tfunction getWithdrawWithLocked(uint256 shares) external view returns(\r\n\t\tuint256 underlyingWithdrawn, \r\n\t\tuint256 strikeAssetWithdrawn, \r\n\t\taddress[] memory acos, \r\n\t\tuint256[] memory acosAmount\r\n\t);\r\n\tfunction setAssetConverter(address newAssetConverter) external;\r\n    function setTolerancePriceBelow(uint256 newTolerancePriceBelow) external;\r\n    function setTolerancePriceAbove(uint256 newTolerancePriceAbove) external;\r\n    function setMinExpiration(uint256 newMinExpiration) external;\r\n    function setMaxExpiration(uint256 newMaxExpiration) external;\r\n    function setFee(uint256 newFee) external;\r\n    function setFeeDestination(address newFeeDestination) external;\r\n\tfunction setWithdrawOpenPositionPenalty(uint256 newWithdrawOpenPositionPenalty) external;\r\n\tfunction setUnderlyingPriceAdjustPercentage(uint256 newUnderlyingPriceAdjustPercentage) external;\r\n\tfunction setMaximumOpenAco(uint256 newMaximumOpenAco) external;\r\n\tfunction setStrategy(address newStrategy) external;\r\n\tfunction setBaseVolatility(uint256 newBaseVolatility) external;\r\n\tfunction setValidAcoCreator(address newAcoCreator, bool newPermission) external;\r\n    function withdrawStuckToken(address token, address destination) external;\r\n    function deposit(uint256 collateralAmount, uint256 minShares, address to) external payable returns(uint256 acoPoolTokenAmount);\r\n\tfunction depositWithGasToken(uint256 collateralAmount, uint256 minShares, address to) external payable returns(uint256 acoPoolTokenAmount);\r\n\tfunction withdrawNoLocked(uint256 shares, uint256 minCollateral, address account) external returns (\r\n\t\tuint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn\r\n\t);\r\n\tfunction withdrawNoLockedWithGasToken(uint256 shares, uint256 minCollateral, address account) external returns (\r\n\t\tuint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn\r\n\t);\r\n    function withdrawWithLocked(uint256 shares, address account) external returns (\r\n\t\tuint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn,\r\n\t\taddress[] memory acos,\r\n\t\tuint256[] memory acosAmount\r\n\t);\r\n\tfunction withdrawWithLockedWithGasToken(uint256 shares, address account) external returns (\r\n\t\tuint256 underlyingWithdrawn,\r\n\t\tuint256 strikeAssetWithdrawn,\r\n\t\taddress[] memory acos,\r\n\t\tuint256[] memory acosAmount\r\n\t);\r\n    function swap(address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external;\r\n    function swapWithGasToken(address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external;\r\n    function redeemACOTokens() external;\r\n\tfunction redeemACOToken(address acoToken) external;\r\n    function restoreCollateral() external;\r\n}"
    },
    "browser/IACOPoolStrategy.sol": {
      "content": "pragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IACOPoolStrategy {\r\n    \r\n    struct OptionQuote {\r\n        uint256 underlyingPrice;\r\n        address underlying;\r\n        address strikeAsset;\r\n        bool isCallOption;\r\n        uint256 strikePrice; \r\n        uint256 expiryTime;\r\n        uint256 baseVolatility;\r\n        uint256 collateralOrderAmount;\r\n        uint256 collateralAvailable;\r\n    }\r\n\r\n    function quote(OptionQuote calldata quoteData) external view returns(uint256 optionPrice, uint256 volatility);\r\n}"
    },
    "browser/IACOToken.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface IACOToken is IERC20 {\r\n\tfunction init(address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime, uint256 _acoFee, address payable _feeDestination, uint256 _maxExercisedAccounts) external;\r\n    function name() external view returns(string memory);\r\n    function symbol() external view returns(string memory);\r\n    function decimals() external view returns(uint8);\r\n    function underlying() external view returns (address);\r\n    function strikeAsset() external view returns (address);\r\n    function feeDestination() external view returns (address);\r\n    function isCall() external view returns (bool);\r\n    function strikePrice() external view returns (uint256);\r\n    function expiryTime() external view returns (uint256);\r\n    function totalCollateral() external view returns (uint256);\r\n    function acoFee() external view returns (uint256);\r\n\tfunction maxExercisedAccounts() external view returns (uint256);\r\n    function underlyingSymbol() external view returns (string memory);\r\n    function strikeAssetSymbol() external view returns (string memory);\r\n    function underlyingDecimals() external view returns (uint8);\r\n    function strikeAssetDecimals() external view returns (uint8);\r\n    function currentCollateral(address account) external view returns(uint256);\r\n    function unassignableCollateral(address account) external view returns(uint256);\r\n    function assignableCollateral(address account) external view returns(uint256);\r\n    function currentCollateralizedTokens(address account) external view returns(uint256);\r\n    function unassignableTokens(address account) external view returns(uint256);\r\n    function assignableTokens(address account) external view returns(uint256);\r\n    function getCollateralAmount(uint256 tokenAmount) external view returns(uint256);\r\n    function getTokenAmount(uint256 collateralAmount) external view returns(uint256);\r\n    function getBaseExerciseData(uint256 tokenAmount) external view returns(address, uint256);\r\n    function numberOfAccountsWithCollateral() external view returns(uint256);\r\n    function getCollateralOnExercise(uint256 tokenAmount) external view returns(uint256, uint256);\r\n    function collateral() external view returns(address);\r\n    function mintPayable() external payable returns(uint256);\r\n    function mintToPayable(address account) external payable returns(uint256);\r\n    function mint(uint256 collateralAmount) external returns(uint256);\r\n    function mintTo(address account, uint256 collateralAmount) external returns(uint256);\r\n    function burn(uint256 tokenAmount) external returns(uint256);\r\n    function burnFrom(address account, uint256 tokenAmount) external returns(uint256);\r\n    function redeem() external returns(uint256);\r\n    function redeemFrom(address account) external returns(uint256);\r\n    function exercise(uint256 tokenAmount, uint256 salt) external payable returns(uint256);\r\n    function exerciseFrom(address account, uint256 tokenAmount, uint256 salt) external payable returns(uint256);\r\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\r\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\r\n    function transferCollateralOwnership(address recipient, uint256 tokenCollateralizedAmount) external;\r\n}"
    },
    "browser/IChiToken.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\nimport './IERC20.sol';\r\n\r\ninterface IChiToken is IERC20 {\r\n    function mint(uint256 value) external;\r\n    function computeAddress2(uint256 salt) external view returns(address);\r\n    function free(uint256 value) external returns(uint256);\r\n    function freeUpTo(uint256 value) external returns(uint256);\r\n    function freeFrom(address from, uint256 value) external returns(uint256);\r\n    function freeFromUpTo(address from, uint256 value) external returns(uint256);\r\n}"
    },
    "browser/IERC20.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"
    },
    "browser/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Adapted from OpenZeppelin\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function init() internal {\r\n        require(_owner == address(0), \"Ownable: Contract initialized\");\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"
    },
    "browser/SafeMath.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"
    }
  }
}