{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":100},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"StableCollTroveManager.sol":{"content":"// Sources flattened with hardhat v2.1.1 https://hardhat.org\r\n\r\n// File contracts/Interfaces/IPriceFeed.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.11;\r\n\r\ninterface IPriceFeed {\r\n\r\n    // --- Events ---\r\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\r\n   \r\n    // --- Function ---\r\n    function fetchPrice() external returns (uint);\r\n}\r\n\r\n\r\n// File contracts/Interfaces/ILiquityBase.sol\r\n\r\n\r\n\r\n\r\n\r\ninterface ILiquityBase {\r\n    function priceFeed() external view returns (IPriceFeed);\r\n}\r\n\r\n\r\n// File contracts/Interfaces/IStabilityPool.sol\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n * The Stability Pool holds LUSD tokens deposited by Stability Pool depositors.\r\n *\r\n * When a trove is liquidated, then depending on system conditions, some of its LUSD debt gets offset with\r\n * LUSD in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of LUSD tokens in the Stability Pool is burned.\r\n *\r\n * Thus, a liquidation causes each depositor to receive a LUSD loss, in proportion to their deposit as a share of total deposits.\r\n * They also receive an ETH gain, as the ETH collateral of the liquidated trove is distributed among Stability depositors,\r\n * in the same proportion.\r\n *\r\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\r\n * of the total LUSD in the Stability Pool, depletes 40% of each deposit.\r\n *\r\n * A deposit that has experienced a series of liquidations is termed a \"compounded deposit\": each liquidation depletes the deposit,\r\n * multiplying it by some factor in range ]0,1[\r\n *\r\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / ETH gain derivations:\r\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\r\n *\r\n * --- LQTY ISSUANCE TO STABILITY POOL DEPOSITORS ---\r\n *\r\n * An LQTY issuance event occurs at every deposit operation, and every liquidation.\r\n *\r\n * Each deposit is tagged with the address of the front end through which it was made.\r\n *\r\n * All deposits earn a share of the issued LQTY in proportion to the deposit as a share of total deposits. The LQTY earned\r\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\r\n *\r\n * Please see the system Readme for an overview:\r\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\r\n */\r\ninterface IStabilityPool {\r\n\r\n    // --- Events ---\r\n    \r\n    event StabilityPoolETHBalanceUpdated(uint _newBalance);\r\n    event StabilityPoolLUSDBalanceUpdated(uint _newBalance);\r\n\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\r\n    event CollAddressChanged(address _collTokenAddress);\r\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\r\n\r\n    event P_Updated(uint _P);\r\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\r\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\r\n    event EpochUpdated(uint128 _currentEpoch);\r\n    event ScaleUpdated(uint128 _currentScale);\r\n\r\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\r\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\r\n\r\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\r\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\r\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\r\n    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);\r\n\r\n    event ETHGainWithdrawn(address indexed _depositor, uint _ETH, uint _LUSDLoss);\r\n    event LQTYPaidToDepositor(address indexed _depositor, uint _LQTY);\r\n    event LQTYPaidToFrontEnd(address indexed _frontEnd, uint _LQTY);\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Functions ---\r\n\r\n    /*\r\n     * Called only once on init, to set addresses of other Liquity contracts\r\n     * Callable only by owner, renounces ownership at the end\r\n     */\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _troveManagerAddress,\r\n        address _activePoolAddress,\r\n        address _LUSDTokenAddress,\r\n        address _sortedTrovesAddress,\r\n        address _priceFeedAddress,\r\n        address _communityIssuanceAddress,\r\n        address _collTokenAddress,\r\n        uint _collDecimalAdjustment\r\n    ) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Frontend is registered or zero address\r\n     * - Sender is not a registered frontend\r\n     * - _amount is not zero\r\n     * ---\r\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\r\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\r\n     * - Sends depositor's accumulated gains (LQTY, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\r\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     */\r\n    function provideToSP(uint _amount, address _frontEndTag) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - _amount is zero or there are no under collateralized troves left in the system\r\n     * - User has a non zero deposit\r\n     * ---\r\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\r\n     * - Removes the deposit's front end tag if it is a full withdrawal\r\n     * - Sends all depositor's accumulated gains (LQTY, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\r\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     *\r\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\r\n     */\r\n    function withdrawFromSP(uint _amount) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - User has a non zero deposit\r\n     * - User has an open trove\r\n     * - User has some ETH gain\r\n     * ---\r\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\r\n     * - Sends all depositor's LQTY gain to  depositor\r\n     * - Sends all tagged front end's LQTY gain to the tagged front end\r\n     * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\r\n     * - Leaves their compounded deposit in the Stability Pool\r\n     * - Updates snapshots for deposit and tagged front end stake\r\n     */\r\n    function withdrawETHGainToTrove(address _upperHint, address _lowerHint) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Frontend (sender) not already registered\r\n     * - User (sender) has no deposit\r\n     * - _kickbackRate is in the range [0, 100%]\r\n     * ---\r\n     * Front end makes a one-time selection of kickback rate upon registering\r\n     */\r\n    function registerFrontEnd(uint _kickbackRate) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Caller is TroveManager\r\n     * ---\r\n     * Cancels out the specified debt against the LUSD contained in the Stability Pool (as far as possible)\r\n     * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\r\n     * Only called by liquidation functions in the TroveManager.\r\n     */\r\n    function offset(uint _debt, uint _coll) external;\r\n\r\n    /*\r\n     * Returns the total amount of ETH held by the pool, accounted in an internal variable instead of `balance`,\r\n     * to exclude edge cases like ETH received from a self-destruct.\r\n     */\r\n    function getETH() external view returns (uint);\r\n\r\n    /*\r\n     * Returns LUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\r\n     */\r\n    function getTotalLUSDDeposits() external view returns (uint);\r\n\r\n    /*\r\n     * Calculates the ETH gain earned by the deposit since its last snapshots were taken.\r\n     */\r\n    function getDepositorETHGain(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Calculate the LQTY gain earned by a deposit since its last snapshots were taken.\r\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\r\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\r\n     * which they made their deposit.\r\n     */\r\n    function getDepositorLQTYGain(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Return the LQTY gain earned by the front end.\r\n     */\r\n    function getFrontEndLQTYGain(address _frontEnd) external view returns (uint);\r\n\r\n    /*\r\n     * Return the user's compounded deposit.\r\n     */\r\n    function getCompoundedLUSDDeposit(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Return the front end's compounded stake.\r\n     *\r\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\r\n     */\r\n    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);\r\n\r\n    function depositColl(uint _amount) external;\r\n    /*\r\n     * Fallback function\r\n     * Only callable by Active Pool, it just accounts for ETH received\r\n     * receive() external payable;\r\n     */\r\n}\r\n\r\n\r\n// File contracts/Dependencies/IERC20.sol\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Based on the OpenZeppelin IER20 interface:\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\r\n *\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    \r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/Dependencies/IERC2612.sol\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC2612 standard as defined in the EIP.\r\n *\r\n * Adds the {permit} method, which can be used to change one's\r\n * {IERC20-allowance} without having to send a transaction, by signing a\r\n * message. This allows users to spend tokens without having to hold Ether.\r\n *\r\n * See https://eips.ethereum.org/EIPS/eip-2612.\r\n * \r\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\r\n */\r\ninterface IERC2612 {\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\r\n     * given `owner`'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(address owner, address spender, uint256 amount, \r\n                    uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    \r\n    /**\r\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     *\r\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to \r\n     * a value in the near future. The deadline argument can be set to uint(-1) to \r\n     * create Permits that effectively never expire.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n    \r\n    function version() external view returns (string memory);\r\n    function permitTypeHash() external view returns (bytes32);\r\n    function domainSeparator() external view returns (bytes32);\r\n}\r\n\r\n\r\n// File contracts/Interfaces/ILUSDToken.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface ILUSDToken is IERC20, IERC2612 {\r\n    // --- Events ---\r\n\r\n    event LUSDTokenBalanceUpdated(address _user, uint256 _amount);\r\n    event CollateralAdded(\r\n        address _troveManagerAddress,\r\n        address _stabilityPoolAddress,\r\n        address _borrowerOperationsAddress\r\n    );\r\n    event ColllateralRemoved(\r\n        address _troveManagerAddress,\r\n        address _stabilityPoolAddress,\r\n        address _borrowerOperationsAddress\r\n    );\r\n\r\n    // --- Functions ---\r\n    function addAddressesForColl(\r\n        address _troveManagerAddress,\r\n        address _stabilityPoolAddress,\r\n        address _borrowerOperationsAddress\r\n    ) external;\r\n\r\n    function removeAddressesForColl(\r\n        address _troveManagerAddress,\r\n        address _stabilityPoolAddress,\r\n        address _borrowerOperationsAddress\r\n    ) external;\r\n\r\n    function mint(address _account, uint256 _amount) external;\r\n\r\n    function burn(address _account, uint256 _amount) external;\r\n\r\n    function sendToPool(\r\n        address _sender,\r\n        address poolAddress,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    function returnFromPool(\r\n        address poolAddress,\r\n        address user,\r\n        uint256 _amount\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/Interfaces/ILQTYToken.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface ILQTYToken is IERC20, IERC2612 { \r\n   \r\n    // --- Events ---\r\n    \r\n    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);\r\n    event LockupContractFactoryAddressSet(address _lockupContractFactoryAddress);\r\n\r\n    // --- Functions ---\r\n    \r\n    function getDeploymentStartTime() external view returns (uint256);\r\n\r\n    function getLpRewardsEntitlement() external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/Interfaces/IStableCollTroveManager.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Common interface for the Trove Manager.\r\ninterface IStableCollTroveManager is ILiquityBase {\r\n    \r\n    // --- Events ---\r\n\r\n    event StableCollBorrowerOperationsAddressChanged(address _newStableCollBorrowerOperationsAddress);\r\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\r\n    event StableCollActivePoolAddressChanged(address _stableCollActivePoolAddress);\r\n    event LQTYTokenAddressChanged(address _lqtyTokenAddress);\r\n    event BorrowingRatePlusChanged(uint _borrowingRatePlus);\r\n\r\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\r\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);\r\n    event BaseRateUpdated(uint _baseRate);\r\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\r\n    event TotalStakesUpdated(uint _newTotalStakes);\r\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\r\n    event LTermsUpdated(uint _L_ETH, uint _L_LUSDDebt);\r\n    event TroveSnapshotsUpdated(uint _L_ETH, uint _L_LUSDDebt);\r\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\r\n\r\n    // --- Functions ---\r\n\r\n    function setAddresses(\r\n        address _stableCollBorrowerOperationsAddress,\r\n        address _stableCollActivePoolAddress,\r\n        address _lusdTokenAddress,\r\n        address _lqtyTokenAddress,\r\n        address _collTokenAddress,\r\n        uint _collDecimalAdjustment\r\n    ) external;\r\n\r\n    function lusdToken() external view returns (ILUSDToken);\r\n    function lqtyToken() external view returns (ILQTYToken);\r\n\r\n    function getTroveOwnersCount() external view returns (uint);\r\n\r\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\r\n\r\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\r\n\r\n    function getEntireDebtAndColl(address _borrower) external view returns (\r\n        uint debt, \r\n        uint coll\r\n    );\r\n\r\n    function closeTrove(address _borrower) external;\r\n\r\n    function getBorrowingRate() external view returns (uint);\r\n    function getBorrowingFee(uint LUSDDebt) external view returns (uint);\r\n\r\n    function getDebtCeiling() external view returns (uint);\r\n\r\n    function getStableCollAmount(uint _LUSDDebt) external view returns (uint);\r\n    \r\n    function getTroveStatus(address _borrower) external view returns (uint);\r\n    \r\n    function getTroveDebt(address _borrower) external view returns (uint);\r\n\r\n    function getTroveColl(address _borrower) external view returns (uint);\r\n\r\n    function setTroveStatus(address _borrower, uint num) external;\r\n\r\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\r\n\r\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint); \r\n\r\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint); \r\n\r\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint); \r\n\r\n    function getTCR(uint _price) external view returns (uint);\r\n}\r\n\r\n\r\n// File contracts/Dependencies/BaseMath.sol\r\n\r\n\r\n\r\n\r\n\r\ncontract BaseMath {\r\n    uint constant public DECIMAL_PRECISION = 1e18;\r\n}\r\n\r\n\r\n// File contracts/Dependencies/SafeMath.sol\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Based on OpenZeppelin's SafeMath:\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\r\n *\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Dependencies/console.sol\r\n\r\n\r\n\r\n\r\n\r\n// Buidler's helper contract for console logging\r\nlibrary console {\r\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\r\n\r\n\tfunction log() internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log()\"));\r\n\t\tignored;\r\n\t}\tfunction logInt(int p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(int)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logUint(uint p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logString(string memory p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBool(bool p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logAddress(address p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes(bytes memory p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logByte(byte p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(byte)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes1(bytes1 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes1)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes2(bytes2 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes2)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes3(bytes3 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes3)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes4(bytes4 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes4)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes5(bytes5 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes5)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes6(bytes6 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes6)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes7(bytes7 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes7)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes8(bytes8 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes8)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes9(bytes9 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes9)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes10(bytes10 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes10)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes11(bytes11 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes11)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes12(bytes12 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes12)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes13(bytes13 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes13)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes14(bytes14 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes14)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes15(bytes15 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes15)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes16(bytes16 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes16)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes17(bytes17 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes17)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes18(bytes18 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes18)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes19(bytes19 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes19)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes20(bytes20 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes20)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes21(bytes21 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes21)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes22(bytes22 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes22)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes23(bytes23 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes23)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes24(bytes24 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes24)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes25(bytes25 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes25)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes26(bytes26 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes26)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes27(bytes27 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes27)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes28(bytes28 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes28)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes29(bytes29 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes29)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes30(bytes30 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes30)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes31(bytes31 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes31)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction logBytes32(bytes32 p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bytes32)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address)\", p0));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, uint p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, string memory p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, bool p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, address p2) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\r\n\t\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\r\n\t\tignored;\r\n\t}\r\n\r\n}\r\n\r\n\r\n// File contracts/Dependencies/LiquityMath.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary LiquityMath {\r\n    using SafeMath for uint;\r\n\r\n    uint internal constant DECIMAL_PRECISION = 1e18;\r\n\r\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\r\n     *\r\n     * - Making it too high could lead to overflows.\r\n     * - Making it too low could lead to an ICR equal to zero, due to truncation from Solidity floor division. \r\n     *\r\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,\r\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\r\n     *\r\n     */\r\n    uint internal constant NICR_PRECISION = 1e20;\r\n\r\n    function _min(uint _a, uint _b) internal pure returns (uint) {\r\n        return (_a < _b) ? _a : _b;\r\n    }\r\n\r\n    function _max(uint _a, uint _b) internal pure returns (uint) {\r\n        return (_a >= _b) ? _a : _b;\r\n    }\r\n\r\n    /* \r\n    * Multiply two decimal numbers and use normal rounding rules:\r\n    * -round product up if 19'th mantissa digit >= 5\r\n    * -round product down if 19'th mantissa digit < 5\r\n    *\r\n    * Used only inside the exponentiation, _decPow().\r\n    */\r\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\r\n        uint prod_xy = x.mul(y);\r\n\r\n        decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\r\n    }\r\n\r\n    /* \r\n    * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\r\n    * \r\n    * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity. \r\n    * \r\n    * Called by two functions that represent time in units of minutes:\r\n    * 1) TroveManager._calcDecayedBaseRate\r\n    * 2) CommunityIssuance._getCumulativeIssuanceFraction \r\n    * \r\n    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\r\n    * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\r\n    * \r\n    * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\r\n    * negligibly different from just passing the cap, since: \r\n    *\r\n    * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\r\n    * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\r\n    */\r\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\r\n       \r\n        if (_minutes > 525600000) {_minutes = 525600000;}  // cap to avoid overflow\r\n    \r\n        if (_minutes == 0) {return DECIMAL_PRECISION;}\r\n\r\n        uint y = DECIMAL_PRECISION;\r\n        uint x = _base;\r\n        uint n = _minutes;\r\n\r\n        // Exponentiation-by-squaring\r\n        while (n > 1) {\r\n            if (n % 2 == 0) {\r\n                x = decMul(x, x);\r\n                n = n.div(2);\r\n            } else { // if (n % 2 != 0)\r\n                y = decMul(x, y);\r\n                x = decMul(x, x);\r\n                n = (n.sub(1)).div(2);\r\n            }\r\n        }\r\n\r\n        return decMul(x, y);\r\n  }\r\n\r\n    function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {\r\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\r\n    }\r\n\r\n    function _computeNominalCR(uint _coll, uint _debt, uint _collDecimalAdjustment) internal pure returns (uint) {\r\n        if (_debt > 0) {\r\n            return _coll.mul(_collDecimalAdjustment).mul(NICR_PRECISION).div(_debt);\r\n        }\r\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\r\n        else { // if (_debt == 0)\r\n            return 2**256 - 1;\r\n        }\r\n    }\r\n\r\n    function _computeCR(uint _coll, uint _debt, uint _price, uint _collDecimalAdjustment) internal pure returns (uint) {\r\n        if (_debt > 0) {\r\n            uint newCollRatio = _coll.mul(_collDecimalAdjustment).mul(_price).div(_debt);\r\n\r\n            return newCollRatio;\r\n        }\r\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\r\n        else { // if (_debt == 0)\r\n            return 2**256 - 1; \r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Interfaces/IPool.sol\r\n\r\n\r\n\r\n\r\n\r\n// Common interface for the Pools.\r\ninterface IPool {\r\n    \r\n    // --- Events ---\r\n    \r\n    event ETHBalanceUpdated(uint _newBalance);\r\n    event LUSDBalanceUpdated(uint _newBalance);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Functions ---\r\n    \r\n    function getETH() external view returns (uint);\r\n\r\n    function getLUSDDebt() external view returns (uint);\r\n\r\n    function increaseLUSDDebt(uint _amount) external;\r\n\r\n    function depositColl(uint _amount) external;\r\n\r\n    function decreaseLUSDDebt(uint _amount) external;\r\n}\r\n\r\n\r\n// File contracts/Interfaces/IActivePool.sol\r\n\r\n\r\n\r\n\r\n\r\ninterface IActivePool is IPool {\r\n    // --- Events ---\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolLUSDDebtUpdated(uint _LUSDDebt);\r\n    event ActivePoolETHBalanceUpdated(uint _ETH);\r\n    event CollAddressChanged(address _wethTokenAddress);\r\n\r\n    // --- Functions ---\r\n    function sendETH(address _account, uint _amount) external;\r\n    function notifyFee(address _feeForwarderAddress, uint _amount) external; \r\n}\r\n\r\n\r\n// File contracts/Interfaces/IStableCollActivePool.sol\r\n\r\n\r\n\r\n\r\n\r\ninterface IStableCollActivePool is IPool {\r\n    // --- Events ---\r\n    event StableCollBorrowerOperationsAddressChanged(address _newStableCollBorrowerOperationsAddress);\r\n    event StableCollTroveManagerAddressChanged(address _newStableCollTroveManagerAddress);\r\n    event StableCollActivePoolLUSDDebtUpdated(uint _LUSDDebt);\r\n    event StableCollActivePoolETHBalanceUpdated(uint _ETH);\r\n    event CollAddressChanged(address _collTokenAddress);\r\n\r\n    // --- Functions ---\r\n    function sendETH(address _account, uint _amount) external;\r\n}\r\n\r\n\r\n// File contracts/Interfaces/IDefaultPool.sol\r\n\r\n\r\n\r\n\r\n\r\ninterface IDefaultPool is IPool {\r\n    // --- Events ---\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event DefaultPoolLUSDDebtUpdated(uint _LUSDDebt);\r\n    event DefaultPoolETHBalanceUpdated(uint _ETH);\r\n    event CollTokenAddressUpdated(address _collTokenAddress);\r\n\r\n    // --- Functions ---\r\n    function sendETHToActivePool(uint _amount) external;\r\n}\r\n\r\n\r\n// File contracts/Dependencies/LiquityBase.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* \r\n* Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\r\n* common functions. \r\n*/\r\ncontract LiquityBase is BaseMath, ILiquityBase {\r\n    using SafeMath for uint;\r\n\r\n    uint constant public _100pct = 1000000000000000000; // 1e18 == 100%\r\n\r\n    // Minimum collateral ratio for individual troves\r\n    uint constant public MCR = 1100000000000000000; // 110%\r\n\r\n    // Minimum stablecoin collateral ratio for individual troves\r\n    uint constant public MSCR = 1000000000000000000; // 100%\r\n\r\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\r\n    uint constant public CCR = 1500000000000000000; // 150%\r\n\r\n    // Amount of LUSD to be locked in gas pool on opening troves\r\n    uint constant public LUSD_GAS_COMPENSATION = 400e18;\r\n\r\n    // Minimum amount of net LUSD debt a trove must have\r\n    uint constant public MIN_NET_DEBT = 2000e18; \r\n\r\n    uint constant public PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\r\n\r\n    uint constant public STABLE_COLL_BORROWING_RATE = DECIMAL_PRECISION / 100; // 1%\r\n\r\n    uint constant public STABLE_COLL_COLLATERAL_RARIO = 1010000000000000000; // 101%\r\n\r\n    uint constant public STABLE_COLL_COLLATERAL_RARIO_DIVIDEND = 101;\r\n\r\n    uint constant public STABLE_COLL_COLLATERAL_RARIO_DIVISOR = 100; \r\n\r\n    uint constant public STABLE_COLL_DEBT_CEILING = DECIMAL_PRECISION * 1e4; // 10,000\r\n\r\n    uint constant public COLL_DEBT_CEILING = DECIMAL_PRECISION * 1e4; // 10,000\r\n    \r\n    uint constant public BORROWING_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 4; // 0.4%\r\n\r\n    IActivePool public activePool;\r\n    IStableCollActivePool public stableCollActivePool;\r\n\r\n    IDefaultPool public defaultPool;\r\n\r\n    IPriceFeed public override priceFeed;\r\n\r\n    // --- Gas compensation functions ---\r\n\r\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\r\n    function _getCompositeDebt(uint _debt) internal pure returns (uint) {\r\n        return _debt.add(LUSD_GAS_COMPENSATION);\r\n    }\r\n\r\n    function _getNetDebt(uint _debt) internal pure returns (uint) {\r\n        return _debt.sub(LUSD_GAS_COMPENSATION);\r\n    }\r\n\r\n    // Return the amount of ETH to be drawn from a trove's collateral and sent as gas compensation.\r\n    function _getCollGasCompensation(uint _entireColl) internal pure returns (uint) {\r\n        return _entireColl / PERCENT_DIVISOR;\r\n    }\r\n\r\n    function getEntireSystemColl() public view returns (uint) {\r\n        uint activeColl = activePool.getETH();\r\n        uint liquidatedColl = defaultPool.getETH();\r\n\r\n        return activeColl.add(liquidatedColl);\r\n    }\r\n\r\n    function getEntireSystemStableColl() public view returns (uint) {\r\n        return stableCollActivePool.getETH();\r\n    }\r\n\r\n    function getEntireSystemDebt() public view returns (uint) {\r\n        uint activeDebt = activePool.getLUSDDebt();\r\n        uint closedDebt = defaultPool.getLUSDDebt();\r\n\r\n        return activeDebt.add(closedDebt);\r\n    }\r\n\r\n    function getEntireSystemStableDebt() public view returns (uint) {\r\n        return stableCollActivePool.getLUSDDebt();\r\n    }\r\n\r\n    function _getTCR(uint _price, uint _collDecimalAdjustment) internal view returns (uint) {\r\n        uint entireSystemColl = getEntireSystemColl();\r\n        uint entireSystemDebt = getEntireSystemDebt();\r\n\r\n        uint TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, _price, _collDecimalAdjustment);\r\n\r\n        return TCR;\r\n    }\r\n\r\n    function _checkRecoveryMode(uint _price, uint _collDecimalAdjustment) internal view returns (bool) {\r\n        uint TCR = _getTCR(_price, _collDecimalAdjustment);\r\n\r\n        return TCR < CCR;\r\n    }\r\n\r\n    function _requireUserAcceptsFee(uint _fee, uint _amount, uint _maxFeePercentage) internal pure {\r\n        uint feePercentage = _fee.mul(DECIMAL_PRECISION).div(_amount);\r\n        require(feePercentage <= _maxFeePercentage, \"Fee exceeded provided maximum\");\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Dependencies/Ownable.sol\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Based on OpenZeppelin's Ownable contract:\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\r\n *\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     *\r\n     * NOTE: This function is not safe, as it doesnt check owner is calling it.\r\n     * Make sure you check it before calling it.\r\n     */\r\n    function _renounceOwnership() internal {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Dependencies/CheckContract.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CheckContract {\r\n    /**\r\n     * Check that the account is an already deployed non-destroyed contract.\r\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\r\n     */\r\n    function checkContract(address _account) internal view {\r\n        require(_account != address(0), \"Account cannot be zero address\");\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(_account) }\r\n        require(size > 0, \"Account code size cannot be zero\");\r\n    }\r\n}\r\n\r\n\r\n// File contracts/StableColl/StableCollTroveManager.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract StableCollTroveManager is LiquityBase, Ownable, CheckContract, IStableCollTroveManager {\r\n    string constant public NAME = \"StableCollTroveManager\";\r\n\r\n    // --- Connected contract declarations ---\r\n\r\n    address public stableCollBorrowerOperationsAddress;\r\n\r\n    ILUSDToken public override lusdToken;\r\n\r\n    ILQTYToken public override lqtyToken;\r\n\r\n    address public collTokenAddress;\r\n\r\n    // During bootsrap period redemptions are not allowed\r\n    uint constant public BOOTSTRAP_PERIOD = 21 days;\r\n\r\n    bool isAddressesSet = false;\r\n    uint public debtCeilingPlus;\r\n    uint private collDecimalAdjustment;\r\n\r\n    enum Functions { SET_DEBT_CEILING }  \r\n    uint256 private constant _TIMELOCK = 1 days;\r\n    mapping(Functions => uint256) public timelock;\r\n\r\n    // --- Time lock\r\n    modifier notLocked(Functions _fn) {\r\n        require(\r\n        timelock[_fn] != 1 && timelock[_fn] <= block.timestamp,\r\n        \"Function is timelocked\"\r\n        );\r\n        _;\r\n    }\r\n    //unlock timelock\r\n    function unlockFunction(Functions _fn) public onlyOwner {\r\n        timelock[_fn] = block.timestamp + _TIMELOCK;\r\n    }\r\n    //lock timelock\r\n    function lockFunction(Functions _fn) public onlyOwner {\r\n        timelock[_fn] = 1;\r\n    }\r\n\r\n    // --- Data structures ---\r\n    enum Status {\r\n        nonExistent,\r\n        active,\r\n        closedByOwner\r\n    }\r\n\r\n    // Store the necessary data for a trove\r\n    struct Trove {\r\n        uint debt;\r\n        uint coll;\r\n        uint stake; /* To be removed */\r\n        Status status;\r\n        uint128 arrayIndex;\r\n    }\r\n\r\n    mapping (address => Trove) public Troves;\r\n\r\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\r\n    address[] public TroveOwners;\r\n\r\n    struct ContractsCache {\r\n        IStableCollActivePool stableCollActivePool;\r\n        ILUSDToken lusdToken;\r\n    }\r\n\r\n    // --- Events ---\r\n    event StableCollBorrowerOperationsAddressChanged(address _newStableCollBorrowerOperationsAddress);\r\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\r\n    event StableCollActivePoolAddressChanged(address _stableCollActivePoolAddress);\r\n    event LQTYTokenAddressChanged(address _lqtyTokenAddress);\r\n    event DebtCeilingPlusChanged(uint _debtCeilingPlus);\r\n\r\n\r\n    // --- Dependency setter ---\r\n\r\n    function setAddresses(\r\n        address _stableCollBorrowerOperationsAddress,\r\n        address _stableCollActivePoolAddress,\r\n        address _lusdTokenAddress,\r\n        address _lqtyTokenAddress,\r\n        address _collTokenAddress,\r\n        uint _collDecimalAdjustment\r\n    )\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        require(!isAddressesSet, \"StableCollTroveManager: Addresses are already set!\");\r\n        isAddressesSet = true;\r\n\r\n        checkContract(_stableCollBorrowerOperationsAddress);\r\n        checkContract(_stableCollActivePoolAddress);\r\n        checkContract(_lusdTokenAddress);\r\n        checkContract(_lqtyTokenAddress);\r\n\r\n        stableCollBorrowerOperationsAddress = _stableCollBorrowerOperationsAddress;\r\n        stableCollActivePool = IStableCollActivePool(_stableCollActivePoolAddress);\r\n        lusdToken = ILUSDToken(_lusdTokenAddress);\r\n        lqtyToken = ILQTYToken(_lqtyTokenAddress);\r\n        collTokenAddress = _collTokenAddress;\r\n        collDecimalAdjustment = _collDecimalAdjustment;\r\n\r\n        emit StableCollBorrowerOperationsAddressChanged(_stableCollBorrowerOperationsAddress);\r\n        emit StableCollActivePoolAddressChanged(_stableCollActivePoolAddress);\r\n        emit LUSDTokenAddressChanged(_lusdTokenAddress);\r\n        emit LQTYTokenAddressChanged(_lqtyTokenAddress);\r\n    }\r\n\r\n    function setDebtCeilingPlus(uint _debtCeilingPlus) external onlyOwner notLocked(Functions.SET_DEBT_CEILING) {\r\n        debtCeilingPlus = _debtCeilingPlus;\r\n\r\n        emit DebtCeilingPlusChanged(_debtCeilingPlus);\r\n\r\n        timelock[Functions.SET_DEBT_CEILING] = 1;\r\n    }\r\n\r\n    // --- Getters ---\r\n\r\n    function getTroveOwnersCount() external view override returns (uint) {\r\n        return TroveOwners.length;\r\n    }\r\n\r\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\r\n        return TroveOwners[_index];\r\n    }\r\n\r\n\r\n    // Return the Troves entire debt and coll.\r\n    function getEntireDebtAndColl(\r\n        address _borrower\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (uint debt, uint coll)\r\n    {\r\n        debt = Troves[_borrower].debt;\r\n        coll = Troves[_borrower].coll;\r\n    }\r\n\r\n    function closeTrove(address _borrower) external override {\r\n        _requireCallerIsBorrowerOperations();\r\n        return _closeTrove(_borrower, Status.closedByOwner);\r\n    }\r\n\r\n    function _closeTrove(address _borrower, Status closedStatus) internal {\r\n        assert(closedStatus != Status.nonExistent && closedStatus != Status.active);\r\n\r\n        uint TroveOwnersArrayLength = TroveOwners.length;\r\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\r\n\r\n        Troves[_borrower].status = closedStatus;\r\n        Troves[_borrower].coll = 0;\r\n        Troves[_borrower].debt = 0;\r\n\r\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\r\n    }\r\n\r\n    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct\r\n    function addTroveOwnerToArray(address _borrower) external override returns (uint index) {\r\n        _requireCallerIsBorrowerOperations();\r\n        return _addTroveOwnerToArray(_borrower);\r\n    }\r\n\r\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\r\n        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum LUSD\r\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 LUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */\r\n\r\n        // Push the Troveowner to the array\r\n        TroveOwners.push(_borrower);\r\n\r\n        // Record the index of the new Troveowner on their Trove struct\r\n        index = uint128(TroveOwners.length.sub(1));\r\n        Troves[_borrower].arrayIndex = index;\r\n\r\n        return index;\r\n    }\r\n\r\n    /*\r\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:\r\n    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.\r\n    */\r\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\r\n        Status troveStatus = Troves[_borrower].status;\r\n        // Its set in caller function `_closeTrove`\r\n        assert(troveStatus != Status.nonExistent && troveStatus != Status.active);\r\n\r\n        uint128 index = Troves[_borrower].arrayIndex;\r\n        uint length = TroveOwnersArrayLength;\r\n        uint idxLast = length.sub(1);\r\n\r\n        assert(index <= idxLast);\r\n\r\n        address addressToMove = TroveOwners[idxLast];\r\n\r\n        TroveOwners[index] = addressToMove;\r\n        Troves[addressToMove].arrayIndex = index;\r\n        emit TroveIndexUpdated(addressToMove, index);\r\n\r\n        TroveOwners.pop();\r\n    }\r\n\r\n    // --- Recovery Mode and TCR functions ---\r\n\r\n    function getTCR(uint _price) external view override returns (uint) {\r\n        return _getTCR(_price, collDecimalAdjustment);\r\n    }\r\n\r\n    // --- Borrowing fee functions ---\r\n\r\n    function getBorrowingRate() public view override returns (uint) { /* mark */\r\n        return STABLE_COLL_BORROWING_RATE;\r\n    }\r\n\r\n    function getBorrowingFee(uint _LUSDDebt) external view override returns (uint) { /* mark */\r\n        return _calcBorrowingFee(getBorrowingRate(), _LUSDDebt);\r\n    }\r\n\r\n    function _calcBorrowingFee(uint _borrowingRate, uint _LUSDDebt) internal pure returns (uint) { /* mark */\r\n        return _borrowingRate.mul(_LUSDDebt).div(DECIMAL_PRECISION);\r\n    }\r\n\r\n    function getDebtCeiling() public view override returns (uint) { /* mark */\r\n        return STABLE_COLL_DEBT_CEILING.add(debtCeilingPlus);\r\n    }\r\n\r\n    function getStableCollAmount(uint _LUSDDebt) public view override returns (uint) { /* mark */\r\n        return _LUSDDebt.mul(STABLE_COLL_COLLATERAL_RARIO).div(DECIMAL_PRECISION).div(collDecimalAdjustment);\r\n    }\r\n\r\n    // --- 'require' wrapper functions ---\r\n\r\n    function _requireCallerIsBorrowerOperations() internal view {\r\n        require(msg.sender == stableCollBorrowerOperationsAddress, \"StableCollTroveManager: Caller is not the BorrowerOperations contract\");\r\n    }\r\n\r\n    function _requireTroveIsActive(address _borrower) internal view {\r\n        require(Troves[_borrower].status == Status.active, \"StableCollTroveManager: Trove does not exist or is closed\");\r\n    }\r\n\r\n    function _requireLUSDBalanceCoversRedemption(ILUSDToken _lusdToken, address _redeemer, uint _amount) internal view {\r\n        require(_lusdToken.balanceOf(_redeemer) >= _amount, \"StableCollTroveManager: Requested redemption amount must be <= user's LUSD token balance\");\r\n    }\r\n\r\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\r\n        require (TroveOwnersArrayLength > 1, \"StableCollTroveManager: Only one trove in the system\");\r\n    }\r\n\r\n    function _requireAmountGreaterThanZero(uint _amount) internal pure {\r\n        require(_amount > 0, \"StableCollTroveManager: Amount must be greater than zero\");\r\n    }\r\n\r\n    function _requireTCRoverMCR(uint _price) internal view {\r\n        require(_getTCR(_price, collDecimalAdjustment) >= MCR, \"StableCollTroveManager: Cannot redeem when TCR < MCR\");\r\n    }\r\n\r\n    function _requireAfterBootstrapPeriod() internal view {\r\n        uint systemDeploymentTime = lqtyToken.getDeploymentStartTime();\r\n        require(block.timestamp >= systemDeploymentTime.add(BOOTSTRAP_PERIOD), \"StableCollTroveManager: Redemptions are not allowed during bootstrap phase\");\r\n    }\r\n\r\n    // --- Trove property getters ---\r\n\r\n    function getTroveStatus(address _borrower) external view override returns (uint) { /* mark */\r\n        return uint(Troves[_borrower].status);\r\n    }\r\n\r\n    function getTroveDebt(address _borrower) external view override returns (uint) {\r\n        return Troves[_borrower].debt;\r\n    }\r\n\r\n    function getTroveColl(address _borrower) external view override returns (uint) {\r\n        return Troves[_borrower].coll;\r\n    }\r\n\r\n    // --- Trove property setters, called by BorrowerOperations ---\r\n\r\n    function setTroveStatus(address _borrower, uint _num) external override { /* mark */\r\n        _requireCallerIsBorrowerOperations();\r\n        Troves[_borrower].status = Status(_num);\r\n    }\r\n\r\n    function increaseTroveColl(address _borrower, uint _collIncrease) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        uint newColl = Troves[_borrower].coll.add(_collIncrease);\r\n        Troves[_borrower].coll = newColl;\r\n        return newColl;\r\n    }\r\n\r\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        uint newColl = Troves[_borrower].coll.sub(_collDecrease);\r\n        Troves[_borrower].coll = newColl;\r\n        return newColl;\r\n    }\r\n\r\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\r\n        Troves[_borrower].debt = newDebt;\r\n        return newDebt;\r\n    }\r\n\r\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\r\n        _requireCallerIsBorrowerOperations();\r\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\r\n        Troves[_borrower].debt = newDebt;\r\n        return newDebt;\r\n    }\r\n}"}}}