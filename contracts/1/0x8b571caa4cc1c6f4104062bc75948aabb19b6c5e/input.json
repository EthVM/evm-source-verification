{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"FlashArbitrageController.sol":{"content":"// Sources flattened with hardhat v2.0.1 https://hardhat.org\r\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n\r\n// _________  ________ _____________________                                             \r\n// \\_   ___ \\ \\_____  \\\\______   \\_   _____/                                             \r\n// /    \\  \\/  /   |   \\|       _/|    __)_                                              \r\n// \\     \\____/    |    \\    |   \\|        \\                                             \r\n//  \\______  /\\_______  /____|_  /_______  /                                             \r\n//         \\/         \\/       \\/        \\/                                              \r\n// ___________.____       _____    _________ ___ ___                                     \r\n// \\_   _____/|    |     /  _  \\  /   _____//   |   \\                                    \r\n//  |    __)  |    |    /  /_\\  \\ \\_____  \\/    ~    \\                                   \r\n//  |     \\   |    |___/    |    \\/        \\    Y    /                                   \r\n//  \\___  /   |_______ \\____|__  /_______  /\\___|_  /                                    \r\n//      \\/            \\/       \\/        \\/       \\/                                     \r\n//    _____ ____________________.________________________    _____    ___________________\r\n//   /  _  \\\\______   \\______   \\   \\__    ___/\\______   \\  /  _  \\  /  _____/\\_   _____/\r\n//  /  /_\\  \\|       _/|    |  _/   | |    |    |       _/ /  /_\\  \\/   \\  ___ |    __)_ \r\n// /    |    \\    |   \\|    |   \\   | |    |    |    |   \\/    |    \\    \\_\\  \\|        \\\r\n// \\____|__  /____|_  /|______  /___| |____|    |____|_  /\\____|__  /\\______  /_______  /\r\n//         \\/       \\/        \\/                       \\/         \\/        \\/        \\/ \r\n//  Controller\r\n//\r\n// This contract checks for opportunities to gain profit for all of DEXs out there\r\n// But especially the CORE ecosystem because this contract can tell another contrac to turn feeOff for the duration of its trades\r\n// By arbitraging all existing pools, and transfering profits to FeeSplitter\r\n// That will add rewards to specific pools to keep them at X% APY\r\n// And add liquidity and subsequently burn the liquidity tokens after all pools reach this threashold\r\n//\r\n//      .edee...      .....       .eeec.   ..eee..\r\n//    .d*\"  \"\"\"\"*e..d*\"\"\"\"\"**e..e*\"\"  \"*c.d\"\"  \"\"*e.\r\n//   z\"           \"$          $\"\"       *F         **e.\r\n//  z\"             \"c        d\"          *.           \"$.\r\n// .F                        \"            \"            'F\r\n// d                                                   J%\r\n// 3         .                                        e\"\r\n// 4r       e\"              .                        d\"\r\n//  $     .d\"     .        .F             z ..zeeeeed\"\r\n//  \"*beeeP\"      P        d      e.      $**\"\"    \"\r\n//      \"*b.     Jbc.     z*%e.. .$**eeeeP\"\r\n//         \"*beee* \"$$eeed\"  ^$$$\"\"    \"\r\n//                  '$$.     .$$$c\r\n//                   \"$$.   e$$*$$c\r\n//                    \"$$..$$P\" '$$r\r\n//                     \"$$$$\"    \"$$.           .d\r\n//         z.          .$$$\"      \"$$.        .dP\"\r\n//         ^*e        e$$\"         \"$$.     .e$\"\r\n//           *b.    .$$P\"           \"$$.   z$\"\r\n//            \"$c  e$$\"              \"$$.z$*\"\r\n//             ^*e$$P\"                \"$$$\"\r\n//               *$$                   \"$$r\r\n//               '$$F                 .$$P\r\n//                $$$                z$$\"\r\n//                4$$               d$$b.\r\n//                .$$%            .$$*\"*$$e.\r\n//             e$$$*\"            z$$\"    \"*$$e.\r\n//            4$$\"              d$P\"        \"*$$e.\r\n//            $P              .d$$$c           \"*$$e..\r\n//           d$\"             z$$\" *$b.            \"*$L\r\n//          4$\"             e$P\"   \"*$c            ^$$\r\n//          $\"            .d$\"       \"$$.           ^$r\r\n//         dP            z$$\"         ^*$e.          \"b\r\n//        4$            e$P             \"$$           \"\r\n//                     J$F               $$\r\n//                     $$               .$F\r\n//                    4$\"               $P\"\r\n//                    $\"               dP    kjRWG0tKD4A\r\n//\r\n// I'll have you know...\r\n// File @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol@v1.0.1\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n\r\n// File @uniswap/lib/contracts/libraries/AddressStringUtil.sol@v1.1.4\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.5.0;\r\n\r\nlibrary AddressStringUtil {\r\n    // converts an address to the uppercase hex string, extracting only len bytes (up to 20, multiple of 2)\r\n    function toAsciiString(address addr, uint len) pure internal returns (string memory) {\r\n        require(len % 2 == 0 && len > 0 && len <= 40, \"AddressStringUtil: INVALID_LEN\");\r\n\r\n        bytes memory s = new bytes(len);\r\n        uint addrNum = uint(addr);\r\n        for (uint i = 0; i < len / 2; i++) {\r\n            // shift right and truncate all but the least significant byte to extract the byte at position 19-i\r\n            uint8 b = uint8(addrNum >> (8 * (19 - i)));\r\n            // first hex character is the most significant 4 bits\r\n            uint8 hi = b >> 4;\r\n            // second hex character is the least significant 4 bits\r\n            uint8 lo = b - (hi << 4);\r\n            s[2 * i] = char(hi);\r\n            s[2 * i + 1] = char(lo);\r\n        }\r\n        return string(s);\r\n    }\r\n\r\n    // hi and lo are only 4 bits and between 0 and 16\r\n    // this method converts those values to the unicode/ascii code point for the hex representation\r\n    // uses upper case for the characters\r\n    function char(uint8 b) pure private returns (byte c) {\r\n        if (b < 10) {\r\n            return byte(b + 0x30);\r\n        } else {\r\n            return byte(b + 0x37);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @uniswap/lib/contracts/libraries/SafeERC20Namer.sol@v1.1.4\r\n\r\n\r\npragma solidity >=0.5.0;\r\n\r\n// produces token descriptors from inconsistent or absent ERC20 symbol implementations that can return string or bytes32\r\n// this library will always produce a string symbol to represent the token\r\nlibrary SafeERC20Namer {\r\n    function bytes32ToString(bytes32 x) pure private returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint j = 0; j < 32; j++) {\r\n            byte char = x[j];\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n    // assumes the data is in position 2\r\n    function parseStringData(bytes memory b) pure private returns (string memory) {\r\n        uint charCount = 0;\r\n        // first parse the charCount out of the data\r\n        for (uint i = 32; i < 64; i++) {\r\n            charCount <<= 8;\r\n            charCount += uint8(b[i]);\r\n        }\r\n\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint i = 0; i < charCount; i++) {\r\n            bytesStringTrimmed[i] = b[i + 64];\r\n        }\r\n\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n    // uses a heuristic to produce a token name from the address\r\n    // the heuristic returns the full hex of the address string in upper case\r\n    function addressToName(address token) pure private returns (string memory) {\r\n        return AddressStringUtil.toAsciiString(token, 40);\r\n    }\r\n\r\n    // uses a heuristic to produce a token symbol from the address\r\n    // the heuristic returns the first 6 hex of the address string in upper case\r\n    function addressToSymbol(address token) pure private returns (string memory) {\r\n        return AddressStringUtil.toAsciiString(token, 6);\r\n    }\r\n\r\n    // calls an external view token contract method that returns a symbol or name, and parses the output into a string\r\n    function callAndParseStringReturn(address token, bytes4 selector) view private returns (string memory) {\r\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(selector));\r\n        // if not implemented, or returns empty data, return empty string\r\n        if (!success || data.length == 0) {\r\n            return \"\";\r\n        }\r\n        // bytes32 data always has length 32\r\n        if (data.length == 32) {\r\n            bytes32 decoded = abi.decode(data, (bytes32));\r\n            return bytes32ToString(decoded);\r\n        } else if (data.length > 64) {\r\n            return abi.decode(data, (string));\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    // attempts to extract the token symbol. if it does not implement symbol, returns a symbol derived from the address\r\n    function tokenSymbol(address token) internal view returns (string memory) {\r\n        // 0x95d89b41 = bytes4(keccak256(\"symbol()\"))\r\n        string memory symbol = callAndParseStringReturn(token, 0x95d89b41);\r\n        if (bytes(symbol).length == 0) {\r\n            // fallback to 6 uppercase hex of address\r\n            return addressToSymbol(token);\r\n        }\r\n        return symbol;\r\n    }\r\n\r\n    // attempts to extract the token name. if it does not implement name, returns a name derived from the address\r\n    function tokenName(address token) internal view returns (string memory) {\r\n        // 0x06fdde03 = bytes4(keccak256(\"name()\"))\r\n        string memory name = callAndParseStringReturn(token, 0x06fdde03);\r\n        if (bytes(name).length == 0) {\r\n            // fallback to full hex of address\r\n            return addressToName(token);\r\n        }\r\n        return name;\r\n    }\r\n}\r\n\r\n\r\n// File @uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol@v1.0.1\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol@v3.0.0\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol@v3.0.0\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-ethereum-package/contracts/Initializable.sol@v3.0.0\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol@v3.0.0\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract ContextUpgradeSafe is Initializable {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n\r\n    function __Context_init() internal initializer {\r\n        __Context_init_unchained();\r\n    }\r\n\r\n    function __Context_init_unchained() internal initializer {\r\n\r\n\r\n    }\r\n\r\n\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol@v3.0.0\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n\r\n    function __Ownable_init() internal initializer {\r\n        __Context_init_unchained();\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal initializer {\r\n\r\n\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[49] private __gap;\r\n}\r\n\r\n\r\n// File contracts/v612/FlashArbitrageController.sol\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\n\r\n\r\n\r\ninterface IFlashArbitrageExecutor {\r\n    function getStrategyProfitInReturnToken(address[] memory pairs, uint256[] memory feeOnTransfers, bool[] memory token0Out) external view returns (uint256);\r\n    function executeStrategy(uint256) external;\r\n    // Strategy that self calculates best input but costs gas\r\n    function executeStrategy(address[] memory pairs, uint256[] memory feeOnTransfers, bool[] memory token0Out, bool cBTCSupport) external;\r\n    // strategy that does not calculate the best input meant for miners\r\n    function executeStrategy(uint256 borrowAmt, address[] memory pairs, uint256[] memory feeOnTransfers, bool[] memory token0Out, bool cBTCSupport) external;\r\n\r\n    function getOptimalInput(address[] memory pairs, uint256[] memory feeOnTransfers, bool[] memory token0Out) external view returns (uint256);\r\n}\r\n\r\n\r\ncontract FlashArbitrageController is OwnableUpgradeSafe {\r\n    using SafeMath for uint256;\r\n\r\n    event StrategyAdded(string indexed name, uint256 indexed id, address[] pairs, bool feeOff, address indexed originator);\r\n\r\n    struct Strategy {\r\n        string strategyName;\r\n        bool[] token0Out; // An array saying if token 0 should be out in this step\r\n        address[] pairs; // Array of pair addresses\r\n        uint256[] feeOnTransfers; //Array of fee on transfers 1% = 10\r\n        bool cBTCSupport; // Should the algorithm check for cBTC and wrap/unwrap it\r\n                        // Note not checking saves gas\r\n        bool feeOff; // Allows for adding CORE strategies - where there is no fee on the executor\r\n    }\r\n\r\n    uint256 public revenueSplitFeeOffStrategy;\r\n    uint256 public revenueSplitFeeOnStrategy;\r\n\r\n    address public  distributor;\r\n    IFlashArbitrageExecutor public executor;\r\n    address public cBTC;\r\n    address public CORE;\r\n    address public wBTC;\r\n    bool depreciated; // This contract can be upgraded to a new one\r\n                      // But we don't want people to add new strategies if its depreciated\r\n    uint8 MAX_STEPS_LEN; // This variable is responsible to minimsing risk of gas limit strategies being added\r\n                        // Which would always have 0 gas cost because they could never complete\r\n    Strategy[] public strategies;\r\n    mapping(uint256 => bool) strategyBlacklist;\r\n\r\n\r\n    function initialize(address _executor, address _distributor) initializer public  {\r\n        require(tx.origin == address(0x5A16552f59ea34E44ec81E58b3817833E9fD5436));\r\n        OwnableUpgradeSafe.__Ownable_init();\r\n\r\n        cBTC = 0x7b5982dcAB054C377517759d0D2a3a5D02615AB8;\r\n        CORE = 0x62359Ed7505Efc61FF1D56fEF82158CcaffA23D7;\r\n        wBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\r\n        distributor = _distributor; // we dont hard set it because its not live yet\r\n                                    // So can't easily mock it in tests\r\n        executor = IFlashArbitrageExecutor(_executor);\r\n        revenueSplitFeeOffStrategy = 100; // 10%\r\n        revenueSplitFeeOnStrategy = 650; // 65%\r\n        MAX_STEPS_LEN = 20;\r\n    }\r\n\r\n    \r\n    /////////////////\r\n    //// ADMIN SETTERS\r\n    //////////////////\r\n\r\n    //In case executor needs to be updated\r\n    function setExecutor(address _executor) onlyOwner public {\r\n        executor = IFlashArbitrageExecutor(_executor);\r\n    }\r\n\r\n    //In case executor needs to be updated\r\n    function setDistributor(address _distributor) onlyOwner public {\r\n        distributor = _distributor;\r\n    }\r\n\r\n    function setMaxStrategySteps(uint8 _maxSteps) onlyOwner public {\r\n        MAX_STEPS_LEN = _maxSteps;\r\n    }\r\n\r\n    function setDepreciated(bool _depreciated) onlyOwner public {\r\n        depreciated = _depreciated;\r\n    }\r\n\r\n    function setFeeSplit(uint256 _revenueSplitFeeOffStrategy, uint256 _revenueSplitFeeOnStrategy) onlyOwner public {\r\n        // We cap both fee splits to 20% max and 95% max\r\n        // This means people calling feeOff strategies get max 20% revenue\r\n        // And people calling feeOn strategies get max 95%\r\n        require(revenueSplitFeeOffStrategy <= 200, \"FA : 20% max fee for feeOff revenue split\");\r\n        require(revenueSplitFeeOnStrategy <= 950, \"FA : 95% max fee for feeOff revenue split\");\r\n        revenueSplitFeeOffStrategy = _revenueSplitFeeOffStrategy;\r\n        revenueSplitFeeOnStrategy = _revenueSplitFeeOnStrategy;\r\n    }\r\n\r\n\r\n    /////////////////\r\n    //// Views for strategies\r\n    //////////////////\r\n    function getOptimalInput(uint256 strategyPID) public view returns (uint256) {\r\n        Strategy memory currentStrategy = strategies[strategyPID];\r\n        return executor.getOptimalInput(currentStrategy.pairs, currentStrategy.feeOnTransfers, currentStrategy.token0Out);\r\n    }\r\n\r\n    // Returns the current profit of strateg if it was executed\r\n    // In return token - this means if you borrow CORE from CORe/cBTC pair\r\n    // This profit would be denominated in cBTC\r\n    // Since thats what you have to return \r\n    function strategyProfitInReturnToken(uint256 strategyID) public view returns (uint256 profit) {\r\n        Strategy memory currentStrategy = strategies[strategyID];\r\n        if(strategyBlacklist[strategyID]) return 0;\r\n        return executor.getStrategyProfitInReturnToken(currentStrategy.pairs, currentStrategy.feeOnTransfers, currentStrategy.token0Out);\r\n    }\r\n\r\n    function strategyProfitInETH(uint256 strategyID) public view returns (uint256 profit) {\r\n        Strategy memory currentStrategy = strategies[strategyID];\r\n        if(strategyBlacklist[strategyID]) return 0;\r\n        profit = executor.getStrategyProfitInReturnToken(currentStrategy.pairs, currentStrategy.feeOnTransfers, currentStrategy.token0Out);\r\n        if(profit == 0) return profit;\r\n        address pair = currentStrategy.pairs[0];\r\n        address token = currentStrategy.token0Out[0] ? IUniswapV2Pair(pair).token1() : IUniswapV2Pair(pair).token0(); \r\n        address pairForProfitToken = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f).getPair(\r\n            0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, token\r\n        );\r\n        if(pairForProfitToken == address(0)) return 0;\r\n        bool profitTokenIsToken0InPair = IUniswapV2Pair(pairForProfitToken).token0() == token;\r\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pairForProfitToken).getReserves();\r\n\r\n        if(profitTokenIsToken0InPair) {\r\n            profit = getAmountOut(profit, reserve0, reserve1);\r\n        }\r\n        else {\r\n            profit = getAmountOut(profit, reserve1, reserve0);\r\n        }\r\n    }\r\n\r\n    function mostProfitableStrategyInETH() public view  returns (uint256 profit, uint256 strategyID){\r\n          \r\n          for (uint256 i = 0; i < strategies.length; i++) {\r\n              uint256 profitThisStrategy = strategyProfitInETH(i);\r\n\r\n              if(profitThisStrategy > profit) {\r\n                profit = profitThisStrategy;\r\n                strategyID = i;\r\n              }\r\n\r\n          }\r\n    }\r\n\r\n\r\n    // Returns information about the strategy\r\n    function strategyInfo(uint256 strategyPID) public view returns (Strategy memory){\r\n        return strategies[strategyPID];\r\n    }\r\n\r\n    function numberOfStrategies() public view returns (uint256) {\r\n        return strategies.length;\r\n    }\r\n\r\n\r\n\r\n    ///////////////////\r\n    //// Strategy execution\r\n    //// And profit assurances\r\n    //////////////////\r\n\r\n    // Public function that executes a strategy\r\n    // since its all a flash swap\r\n    // the strategies can't lose money only gain\r\n    // so its appropriate that they are public here\r\n    // I don't think its possible that one of the strategies that is less profitable\r\n    // takes away money from the more profitable one\r\n    // Otherwise people would be able to do it anyway with their own contracts\r\n    function executeStrategy(uint256 strategyPID) public {\r\n        // function executeStrategy(address[] memory pairs, uint256[] memory feeOnTransfers, bool[] memory token0Out, bool cBTCSupport) external;\r\n        require(!depreciated, \"This Contract is depreciated\");\r\n        Strategy memory currentStrategy = strategies[strategyPID];\r\n\r\n        \r\n        try executor.executeStrategy(currentStrategy.pairs, currentStrategy.feeOnTransfers, currentStrategy.token0Out, currentStrategy.cBTCSupport)\r\n        { \r\n            splitProfit(currentStrategy);\r\n        }\r\n        catch (bytes memory reason) \r\n        {\r\n            bytes memory k = bytes(\"UniswapV2: K\");\r\n\r\n            // We blacklist malicious \r\n            if(reason.length == 100 && !currentStrategy.feeOff) { // \"UniswapV2: K\" \r\n                strategyBlacklist[strategyPID] = true;\r\n                return;\r\n            } else {\r\n                revert(\"Strategy could not execute, most likely because it was not profitable at the moment of execution.\");\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    // Miner-friendly strategy executor\r\n    function executeStrategy(uint256 inputAmount, uint256 strategyPID) public {\r\n\r\n        require(!depreciated, \"This Contract is depreciated\");\r\n        Strategy memory currentStrategy = strategies[strategyPID];\r\n\r\n        try executor.executeStrategy(inputAmount ,currentStrategy.pairs, currentStrategy.feeOnTransfers, currentStrategy.token0Out, currentStrategy.cBTCSupport)\r\n        { \r\n            splitProfit(currentStrategy);\r\n        }\r\n        catch (bytes memory reason) \r\n        {\r\n            bytes memory k = bytes(\"UniswapV2: K\");\r\n            // We blacklist malicious \r\n            if(reason.length == 100 && !currentStrategy.feeOff) { // \"UniswapV2: K\" // We don't blacklist admin added\r\n                strategyBlacklist[strategyPID] = true;\r\n                return;\r\n            } else {\r\n                revert(\"Strategy could not execute, most likely because it was not profitable at the moment of execution.\");\r\n            }\r\n        }\r\n     \r\n\r\n    }\r\n\r\n    function splitProfit(Strategy memory currentStrategy) internal {\r\n        // Eg. Token 0 was out so profit token is token 1\r\n        address profitToken = currentStrategy.token0Out[0] ? \r\n            IUniswapV2Pair(currentStrategy.pairs[0]).token1() \r\n                : \r\n            IUniswapV2Pair(currentStrategy.pairs[0]).token0();\r\n\r\n        // console.log(\"Profit token\", profitToken);\r\n\r\n        uint256 profit = IERC20(profitToken).balanceOf(address(this));\r\n        // console.log(\"Profit \", profit);\r\n\r\n        // We split the profit based on the strategy\r\n        if(currentStrategy.feeOff) {\r\n            safeTransfer(profitToken, msg.sender, profit.mul(revenueSplitFeeOffStrategy).div(1000));\r\n        }\r\n        else {\r\n            safeTransfer(profitToken, msg.sender, profit.mul(revenueSplitFeeOnStrategy).div(1000));\r\n        }\r\n        // console.log(\"Send revenue split now have \", IERC20(profitToken).balanceOf(address(this)) );\r\n\r\n        safeTransfer(profitToken, distributor, IERC20(profitToken).balanceOf(address(this)));\r\n    }\r\n\r\n\r\n    ///////////////////\r\n    //// Adding strategies\r\n    //////////////////\r\n\r\n\r\n    // Normal add without Fee Ontrasnfer being specified\r\n    function addNewStrategy(bool borrowToken0, address[] memory pairs) public returns (uint256 strategyID) {\r\n\r\n        uint256[] memory feeOnTransfers = new uint256[](pairs.length);\r\n        strategyID = addNewStrategyWithFeeOnTransferTokens(borrowToken0, pairs, feeOnTransfers);\r\n\r\n    }\r\n\r\n    //Adding strategy with fee on transfer support\r\n    function addNewStrategyWithFeeOnTransferTokens(bool borrowToken0, address[] memory pairs, uint256[] memory feeOnTransfers) public returns (uint256 strategyID) {\r\n        require(!depreciated, \"This Contract is depreciated\");\r\n        require(pairs.length <= MAX_STEPS_LEN, \"FA Controller - too many steps\");\r\n        require(pairs.length > 1, \"FA Controller - Specifying one pair is not arbitage\");\r\n        require(pairs.length == feeOnTransfers.length, \"FA Controller: Malformed Input -  pairs and feeontransfers should equal\");\r\n        bool[] memory token0Out = new bool[](pairs.length);\r\n        // First token out is the same as borrowTokenOut\r\n        token0Out[0] = borrowToken0;\r\n\r\n        address token0 = IUniswapV2Pair(pairs[0]).token0();\r\n        address token1 = IUniswapV2Pair(pairs[0]).token1();\r\n        if(msg.sender != owner()) {\r\n            require(token0 != CORE && token1 != CORE, \"FA Controller: CORE strategies can be only added by an admin\");\r\n        }        \r\n        \r\n        bool cBTCSupport;\r\n        // We turn on cbtc support if any of the borrow token pair has cbtc\r\n        if(token0 == cBTC || token1 == cBTC) cBTCSupport = true;\r\n\r\n        // Establish the first token out\r\n        address lastToken = borrowToken0 ? token0 : token1;\r\n        // console.log(\"Borrowing Token\", lastToken);\r\n\r\n       \r\n        string memory strategyName = append(\r\n            SafeERC20Namer.tokenSymbol(lastToken),\r\n            \" price too low. In \", \r\n            SafeERC20Namer.tokenSymbol(token0), \"/\", \r\n            SafeERC20Namer.tokenSymbol(token1), \" pair\");\r\n\r\n        // console.log(strategyName);\r\n\r\n        // Loop over all other pairs\r\n        for (uint256 i = 1; i < token0Out.length; i++) {\r\n            require(pairs[i] != pairs[0], \"Uniswap lock\");\r\n            address token0 = IUniswapV2Pair(pairs[i]).token0();\r\n            address token1 = IUniswapV2Pair(pairs[i]).token1();\r\n\r\n            if(msg.sender != owner()) {\r\n                require(token0 != CORE && token1 != CORE, \"FA Controller: CORE strategies can be only added by an admin\");\r\n            }\r\n\r\n            // console.log(\"Last token is\", lastToken);\r\n            // console.log(\"pair is\",pairs[i]);\r\n  \r\n            \r\n            // We turn on cbtc support if any of the pairs have cbts\r\n            if(lastToken == cBTC || lastToken == wBTC){       \r\n                require(token0 == cBTC || token1 == cBTC || token0 == wBTC || token1 == wBTC,\r\n                    \"FA Controller: Malformed Input - pair does not contain previous token\");\r\n\r\n            } else{\r\n                // We check if the token is in the next pair\r\n                // If its not then its a wrong input\r\n                // console.log(\"Last token\", lastToken);\r\n                require(token0 == lastToken || token1 == lastToken, \"FA Controller: Malformed Input - pair does not contain previous token\");\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n            // If last token is cBTC\r\n            // And the this pair has wBTC in it\r\n            // Then we should have the last token as wBTC\r\n            if(lastToken == cBTC) {\r\n                // console.log(\"Flipping here\");\r\n                cBTCSupport = true;\r\n                // If last token is cBTC and this pair has wBTC and no cBTC\r\n                // Then we are inputting wBTC after unwrapping\r\n                 if(token0 == wBTC || token1 == wBTC && token0 != cBTC && token1 != cBTC){\r\n                     \r\n                     // The token we take out here is opposite of wbtc\r\n                     // Token 0 is out if wBTC is token1\r\n                     // Because we are inputting wBTC\r\n                     token0Out[i] = wBTC == token1;\r\n                     lastToken = wBTC == token1 ? token0 : token1;\r\n                 }\r\n            }\r\n\r\n            // If last token is wBTC\r\n            // And cbtc is in this pair\r\n            // And wbtc isn't in this pair\r\n            // Then we wrapped cBTC\r\n             else if(lastToken == wBTC && token0 == cBTC || token1 == cBTC && token0 != wBTC && token1 != wBTC){\r\n                // explained above with cbtc\r\n                cBTCSupport = true;\r\n                token0Out[i] = cBTC == token1;\r\n                lastToken = cBTC == token1 ? token0 : token1;\r\n                // console.log(\"Token0 out from last wBTC\");\r\n            }\r\n            //Default case with no cBTC support\r\n            else {\r\n                // If token 0 is the token we are inputting, the last one\r\n                // Then we take the opposite here\r\n                token0Out[i] = token1 == lastToken;\r\n\r\n                // We take the opposite\r\n                // So if we input token1\r\n                // Then token0 is out\r\n                lastToken = token0 == lastToken ? token1 : token0;\r\n                // console.log(\"Basic branch last token is \", lastToken);\r\n                // console.log(\"Basic branch last token1 is \", token1);\r\n                // console.log(\"Basic branch last token0 is \", token0);\r\n\r\n                // console.log(\"Token0 out from basic branch\");\r\n\r\n            }\r\n          \r\n\r\n\r\n        //    console.log(\"Last token is\", lastToken);\r\n        \r\n        }\r\n        \r\n        // address[] memory pairs, uint256[] memory feeOnTransfers, bool[] memory token0Out, bool cBTCSupport\r\n        \r\n        // Before adding to return index\r\n        strategyID = strategies.length;\r\n\r\n        strategies.push(\r\n            Strategy({\r\n                strategyName : strategyName,\r\n                token0Out : token0Out,\r\n                pairs : pairs,\r\n                feeOnTransfers : feeOnTransfers,\r\n                cBTCSupport : cBTCSupport,\r\n                feeOff : msg.sender == owner()\r\n            })\r\n        );\r\n\r\n\r\n        emit StrategyAdded(strategyName, strategyID, pairs, msg.sender == owner(), msg.sender);\r\n    }\r\n\r\n  \r\n    ///////////////////\r\n    //// Helper functions\r\n    //////////////////\r\n    function sendETH(address payable to, uint256 amt) internal {\r\n        // console.log(\"I'm transfering ETH\", amt/1e18, to);\r\n        // throw exception on failure\r\n        to.transfer(amt);\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n            // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n            (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n            require(success && (data.length == 0 || abi.decode(data, (bool))), 'FA Controller: TRANSFER_FAILED');\r\n    }\r\n\r\n    function getTokenSafeName(address token) public view returns (string memory) {\r\n        return SafeERC20Namer.tokenSymbol(token);\r\n    }\r\n\r\n\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) internal  pure returns (uint256 amountOut) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // A function that lets owner remove any tokens from this addrss\r\n    // note this address shoudn't hold any tokens\r\n    // And if it does that means someting already went wrong or someone send them to this address\r\n    function rescueTokens(address token, uint256 amt) public onlyOwner {\r\n        IERC20(token).transfer(owner(), amt);\r\n    }\r\n\r\n    function rescueETH(uint256 amt) public {\r\n        sendETH(0xd5b47B80668840e7164C1D1d81aF8a9d9727B421, amt);\r\n    }\r\n\r\n    // appends two strings together\r\n    function append(string memory a, string memory b, string memory c, string memory d, string memory e, string memory f) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(a, b,c,d,e,f));\r\n    }\r\n\r\n\r\n    ///////////////////\r\n    //// Additional functions\r\n    //////////////////\r\n\r\n    // This function is for people who do not want to reveal their strategies\r\n    // Note we can do this function because executor requires this contract to be a caller when doing feeoff stratgies\r\n    function skimToken(address _token) public {\r\n        IERC20 token = IERC20(_token);\r\n        uint256 balToken = token.balanceOf(address(this));\r\n        safeTransfer(_token, msg.sender, balToken.mul(revenueSplitFeeOffStrategy).div(1000));\r\n        safeTransfer(_token, distributor, token.balanceOf(address(this)));\r\n    }\r\n\r\n\r\n}"}}}