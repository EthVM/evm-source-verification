{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"uniwallet.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IFactory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IPresale {\r\n    function userDeposit(uint _amount) external payable;\r\n    function userWithdrawTokens() external;\r\n}\r\n\r\ninterface IRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\r\n        external\r\n        pure\r\n        returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\r\n        external\r\n        pure\r\n        returns (uint amountIn);        \r\n}\r\n\r\nlibrary LPancakeSwap {\r\n    IWETH constant private _weth = IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\r\n\r\n    bytes4 public constant SWAP_SELECTOR = bytes4(keccak256(bytes('swapExactTokensForTokens(uint256,uint256,address[],address,uint256)')));\r\n    bytes4 public constant ADD_LIQ_SELECTOR = bytes4(keccak256(bytes('addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)')));\r\n    bytes4 public constant REMOVE_LIQ_SELECTOR = bytes4(keccak256(bytes('removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)')));\r\n    bytes4 public constant TRANSFER_SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n    \r\n    function thisAddress()\r\n        internal\r\n        view\r\n        returns(address)\r\n    {\r\n        return address(this);\r\n    }\r\n\r\n    function getPair(\r\n        address router_,\r\n        address token0_,\r\n        address token1_\r\n    )\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        address factory = IRouter(router_).factory();\r\n        return IFactory(factory).getPair(token0_, token1_);\r\n    }\r\n\r\n    function transferToken(\r\n        address token_,\r\n        address to_,\r\n        uint amount_\r\n    )\r\n        internal\r\n        returns(bool success)\r\n    {\r\n        (success, ) = token_.call((abi.encodeWithSelector(\r\n            TRANSFER_SELECTOR,\r\n            to_,\r\n            amount_\r\n        )));   \r\n    }\r\n\r\n    function transferBnb(\r\n        address to_,\r\n        uint amount_\r\n    )\r\n        internal\r\n        returns(bool success)\r\n    {\r\n        (success,) = to_.call{value:amount_}(new bytes(0));\r\n    }\r\n\r\n    function _approve(\r\n        address token_,\r\n        address to_\r\n    )\r\n        internal\r\n    {\r\n        if (IERC20(token_).allowance(address(this), to_) == 0) {\r\n            IERC20(token_).approve(to_, ~uint256(0));\r\n        }\r\n    }\r\n\r\n    function swap(\r\n        address router_,\r\n        address fromCurrency_,\r\n        address toCurrency_,\r\n        uint amount_,\r\n        address to_\r\n    )\r\n        internal\r\n        returns(bool success)\r\n    {\r\n        address[] memory path = new address[](2);\r\n        path[0] = fromCurrency_;\r\n        path[1] = toCurrency_;\r\n\r\n        _approve(fromCurrency_, router_);\r\n\r\n        (success, ) = router_.call((abi.encodeWithSelector(\r\n            SWAP_SELECTOR,\r\n            amount_,\r\n            0,\r\n            path,\r\n            to_,\r\n            block.timestamp\r\n        )));\r\n    }\r\n\r\n    function addLiquidity(\r\n        address router_,\r\n        address token0_,\r\n        address token1_,\r\n        address to_\r\n    )\r\n        internal\r\n        returns(bool success)\r\n    {\r\n        _approve(token0_, router_);\r\n        _approve(token1_, router_);\r\n\r\n        (success, ) = router_.call((abi.encodeWithSelector(\r\n            ADD_LIQ_SELECTOR,\r\n            token0_,\r\n            token1_,\r\n            IERC20(token0_).balanceOf(address(this)),\r\n            IERC20(token1_).balanceOf(address(this)),\r\n            0,\r\n            0,\r\n            to_,\r\n            block.timestamp\r\n        )));\r\n    }\r\n\r\n    function removeLiquidity(\r\n        address router_,\r\n        address token0_,\r\n        address token1_,\r\n        address to_\r\n    )\r\n        internal\r\n        returns(bool success)\r\n    {\r\n        address pair = getPair(router_, token0_, token1_);\r\n        uint liqBalance = IERC20(pair).balanceOf(address(this));\r\n\r\n        _approve(pair, router_);\r\n\r\n        (success, ) = router_.call((abi.encodeWithSelector(\r\n            REMOVE_LIQ_SELECTOR,\r\n            token0_,\r\n            token1_,\r\n            liqBalance,\r\n            0,\r\n            0,\r\n            to_,\r\n            block.timestamp\r\n        )));\r\n    }\r\n\r\n    function swapAndAddLiquidity(\r\n        address router_,\r\n        address fromCurrency_,\r\n        address toCurrency_,\r\n        uint amount_,\r\n        address to_\r\n    )\r\n        internal\r\n    {\r\n        uint amount = amount_ > 0 ? amount_ : IERC20(fromCurrency_).balanceOf(address(this));\r\n        swap(router_, fromCurrency_, toCurrency_, amount / 2, address(this));\r\n        addLiquidity(router_, fromCurrency_, toCurrency_, to_);\r\n    }\r\n\r\n    function removeLiquidityAndSwap(\r\n        address router_,\r\n        address fromCurrency_,\r\n        address toCurrency_,\r\n        address to_\r\n    )\r\n        internal\r\n    {\r\n        removeLiquidity(router_, fromCurrency_, toCurrency_, address(this));\r\n        uint fromBalance = IERC20(fromCurrency_).balanceOf(address(this));\r\n        swap(router_, fromCurrency_, toCurrency_, fromBalance, address(this));\r\n        uint toBalance = IERC20(toCurrency_).balanceOf(address(this));\r\n        if (toCurrency_ == address(_weth)) {\r\n            _weth.withdraw(toBalance);\r\n            transferBnb(to_, address(this).balance);\r\n        } else {\r\n            transferToken(toCurrency_, to_, toBalance);\r\n        }\r\n    }\r\n}\r\n\r\ncontract Owner {\r\n    modifier onlyOwner() {\r\n        require(_isOwner[msg.sender], \"9\");\r\n        _;\r\n    }\r\n    \r\n    mapping(address => bool) internal _isOwner;\r\n    \r\n    address payable public _admin;\r\n\r\n    constructor() {\r\n        _admin = payable(msg.sender);\r\n        _isOwner[_admin] = true;\r\n        _isOwner[tx.origin] = true;\r\n    }\r\n    \r\n    function addOwners(address[] memory owners_) public {\r\n        require(msg.sender == _admin, \"1\");\r\n        uint n = owners_.length;\r\n        uint i = 0;\r\n        while (i < n) {\r\n            _isOwner[owners_[i]] = true;\r\n            i++;\r\n        }\r\n    }\r\n\r\n    function addOwner(address owner_) public {\r\n        require(msg.sender == _admin, \"1\");\r\n        require(!_isOwner[owner_], \"2\");\r\n        _isOwner[owner_] = true;\r\n    }\r\n    \r\n    function removeOwner(address owner_) public {\r\n        require(msg.sender == _admin, \"3\");\r\n        require(_isOwner[owner_], \"4\");\r\n        _isOwner[owner_] = false;\r\n    }\r\n    \r\n    function changeAdmin(address admin_) public {\r\n        require(msg.sender == _admin, \"1\");\r\n        _admin = payable(admin_);\r\n        _isOwner[admin_] = true;\r\n    }\r\n    \r\n    function isOwner(address address_) public view returns(bool) {\r\n        return _isOwner[address_];\r\n    }\r\n}\r\n\r\ncontract Wallet is Owner {\r\n\r\n    IWETH immutable private _weth = IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\r\n\r\n    receive() external payable {\r\n        if (msg.sender != address(_weth)) {\r\n            _toWbnb();\r\n        }\r\n    }\r\n\r\n    function _toWbnb()\r\n        internal\r\n    {\r\n        uint amount = address(this).balance;\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n        _weth.deposit{value: amount}();\r\n    }\r\n\r\n    function _toBnb()\r\n        internal\r\n    {\r\n        uint amount = _weth.balanceOf(address(this));\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n        _weth.withdraw(amount);\r\n    }\r\n\r\n    function _transferToken(\r\n        address token_,\r\n        uint amount_,\r\n        address to_\r\n    )\r\n        internal\r\n        onlyOwner\r\n    {\r\n        uint amount = amount_ > 0 ? amount_ : tokenBalance(token_, address(this));\r\n        if (amount > 0) {\r\n            IERC20(token_).transfer(to_, amount);\r\n        }\r\n    }\r\n\r\n    function transferToken(\r\n        address token_,\r\n        uint amount_,\r\n        address to_\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        _transferToken(token_, amount_, to_);\r\n    }\r\n\r\n    function transferBnb(\r\n        uint amount_,\r\n        address payable to_\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        _toBnb();\r\n        uint amount = amount_ > 0 ? amount_ : address(this).balance;\r\n        to_.transfer(amount);\r\n    }\r\n\r\n    function command(\r\n        address dest_,\r\n        uint value_,\r\n        bytes memory data_\r\n    )\r\n        external\r\n        onlyOwner\r\n        returns(bool)\r\n    {\r\n        (bool success, ) = address(dest_).call{value: value_}(data_);\r\n        return success;\r\n    }\r\n\r\n    function tokenBalance(\r\n        address token_,\r\n        address address_\r\n    )\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return IERC20(token_).balanceOf(address_);\r\n    }\r\n}\r\n\r\ncontract Helper {\r\n    function toWei(uint amount_) public pure returns(uint)\r\n    {\r\n        return amount_ * 1e18;\r\n    }\r\n\r\n    function fromWei(uint amount_) public pure returns(uint, uint)\r\n    {\r\n        return (amount_ / 1e18, amount_ % 1e18);\r\n    }\r\n}\r\n\r\ncontract UniWallet is Helper, Wallet {\r\n\r\n    // leave amount = 0 if swap 50% and then add liq.\r\n    function swap(\r\n        address router_,\r\n        address fromCurrency_,\r\n        address toCurrency_,\r\n        uint amount_\r\n    )\r\n        external\r\n    {\r\n        LPancakeSwap.swapAndAddLiquidity(router_, fromCurrency_, toCurrency_, amount_, address(this));\r\n    }\r\n\r\n\r\n    function libAddressThis()\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        return LPancakeSwap.thisAddress();\r\n    }\r\n    /*\r\n        Withdraw\r\n    */\r\n\r\n    function withdrawToken(address token_, uint amount_) public {\r\n        require(msg.sender == _admin, \"7\");\r\n        uint amount = amount_ > 0 ? amount_ : tokenBalance(token_, address(this));\r\n        IERC20(token_).transfer(_admin, amount);\r\n    }\r\n    \r\n    function withdrawBnb(uint amount_) public {\r\n        require(msg.sender == _admin, \"7\");\r\n        _toBnb();\r\n        uint amount = amount_ > 0 ? amount_ : address(this).balance;\r\n        _admin.transfer(amount);\r\n        _toWbnb();\r\n    }\r\n}\r\n\r\n/*\r\n    addresses:\r\n    apeRouter: 0xcF0feBd3f17CEf5b47b0cD257aCf6025c5BFf3b7\r\n    pancakeRouter: 0x10ED43C718714eb63d5aA57B78B54704E256024E\r\n    wbnb: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\r\n    busd: 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\r\n    banana: 0x603c7f932ed1fc6575303d8fb018fdcbb0f39a95\r\n    \r\n    uniswapRouter: 0x7a250d5630b4cf539739df2c5dacb4c659f2488d\r\n    sushiswapRouter: 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F\r\n    erc20 usdt: 0xdac17f958d2ee523a2206206994597c13d831ec7\r\n    weth: 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n*/\r\n\r\n\r\n"}}}