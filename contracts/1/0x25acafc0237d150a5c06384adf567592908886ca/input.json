{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"./contracts/debt/mozart/IMozartCoreV1.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {Decimal} from \"../../lib/Decimal.sol\";\nimport {Amount} from \"../../lib/Amount.sol\";\n\nimport {MozartTypes} from \"./MozartTypes.sol\";\n\ninterface IMozartCoreV1 {\n\n    function getPosition(\n        uint256 id\n    )\n        external\n        view\n        returns (MozartTypes.Position memory);\n\n    function getCurrentPrice()\n        external\n        view\n        returns (Decimal.D256 memory);\n\n    function getSyntheticAsset()\n        external\n        view\n        returns (address);\n\n    function getCollateralAsset()\n        external\n        view\n        returns (address);\n\n    function getCurrentOracle()\n        external\n        view\n        returns (address);\n\n    function getInterestSetter()\n        external\n        view\n        returns (address);\n\n    function getBorrowIndex()\n        external\n        view\n        returns (uint256, uint256);\n\n    function getCollateralRatio()\n        external\n        view\n        returns (Decimal.D256 memory);\n\n    function getTotals()\n        external\n        view\n        returns (uint256, uint256);\n\n    function getLimits()\n        external\n        view\n        returns (uint256, uint256);\n\n    function getInterestRate()\n        external\n        view\n        returns (uint256);\n\n    function getFees()\n        external\n        view\n        returns (\n            Decimal.D256 memory _liquidationUserFee,\n            Decimal.D256 memory _liquidationArcRatio\n        );\n\n    function isPositionOperator(\n        uint256 _positionId,\n        address _operator\n    )\n        external\n        view\n        returns (bool);\n\n    function isGlobalOperator(\n        address _operator\n    )\n        external\n        view\n        returns (bool);\n}\n"},"./contracts/debt/mozart/MozartTypes.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {Amount} from \"../../lib/Amount.sol\";\n\nlibrary MozartTypes {\n\n    /* ========== Structs ========== */\n\n    struct Position {\n        address owner;\n        Amount.Principal collateralAmount;\n        Amount.Principal borrowedAmount;\n    }\n\n}\n"},"./contracts/debt/mozart/savings/MozartSavingsStorage.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {ISyntheticToken} from \"../../../token/ISyntheticToken.sol\";\n\nimport {Amount} from \"../../../lib/Amount.sol\";\nimport {Decimal} from \"../../../lib/Decimal.sol\";\n\ncontract MozartSavingsStorageV1 {\n\n    /**\n     * @dev ERC20 Properties\n     */\n    string  internal _name;\n    string  internal _symbol;\n    uint256 internal _totalSupply;\n\n    /**\n     * @notice Synthetic token to mint\n     */\n    ISyntheticToken public synthetic;\n\n    /**\n     * @notice Enable/disable interactions with this contract\n     */\n    bool public paused;\n\n    /**\n     * @notice The savings index which is used to store the cumulative\n     *         interest rate across all users\n     */\n    uint256 public savingsIndex;\n\n    /**\n     * @notice The savings interest rate at which the index grows by.\n               This is expresed in seconds.\n     */\n    uint256 public savingsRate;\n\n    /**\n     * @notice The last time the index was updated\n     */\n    uint256 public indexLastUpdate;\n\n    /**\n     * @notice The total amount of synthetics supplied to this contract.\n     *         This amount is the actual amount and not the principal amount.\n     */\n    uint256 public totalSupplied;\n\n    /**\n     * @notice How much of the interest earned ARC should take/keep.\n     */\n    Decimal.D256 public arcFee;\n\n    /**\n     * @dev Storage mapping of user's internal balances.\n     */\n    mapping (address => uint256) internal _balances;\n\n    /**\n     * @dev Storage mapping of user's allowances balances.\n     */\n    mapping (address => mapping (address => uint256)) internal _allowances;\n\n}\n\n/* solium-disable-next-line */\ncontract MozartSavingsStorage is MozartSavingsStorageV1 { }\n"},"./contracts/debt/mozart/savings/MozartSavingsV1.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {ISyntheticToken} from \"../../../token/ISyntheticToken.sol\";\nimport {IERC20} from \"../../../token/IERC20.sol\";\n\nimport {Adminable} from \"../../../lib/Adminable.sol\";\nimport {Amount} from \"../../../lib/Amount.sol\";\nimport {Decimal} from \"../../../lib/Decimal.sol\";\nimport {SafeMath} from \"../../../lib/SafeMath.sol\";\nimport {SafeERC20} from \"../../../lib/SafeERC20.sol\";\nimport {Ownable} from \"../../../lib/Ownable.sol\";\n\nimport {IMozartCoreV1} from \"../IMozartCoreV1.sol\";\n\nimport {MozartSavingsStorage} from \"./MozartSavingsStorage.sol\";\n\n/**\n * @title MozartSavingsV1\n * @author Kerman Kohli\n * @notice This contract is relatively simple in where you deposit a specific token and then\n *         users who deposit their tokens earn more of it as more of it gets minted directly to\n *         this contract. Balances are stored as \"principal\" amounts and the actual amount\n *         can be retreived through simply multiplying by the exchangeRate() stored.\n */\ncontract MozartSavingsV1 is Adminable, MozartSavingsStorage, IERC20 {\n\n    /* ========== Libraries ========== */\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Amount for Amount.Principal;\n\n    /* ========== Events ========== */\n\n    event IndexUpdated(uint256 updateTime, uint256 newIndex);\n\n    event SavingsRateUpdated(uint256 newRate);\n\n    event ArcFeeUpdated(uint256 feeUpdated);\n\n    event Paused(bool newStatus);\n\n    /* ========== Constants ========== */\n\n    uint256 constant BASE = 10**18;\n\n    /* ========== Modifier ========== */\n\n    modifier isActive() {\n        require(\n            paused == false,\n            \"D2Savings: contract is paused\"\n        );\n        _;\n    }\n\n    /* ========== Constructor ========== */\n\n    function init(\n        string memory name,\n        string memory symbol,\n        address _syntheticAddress,\n        Decimal.D256 memory _fee\n    )\n        public\n        onlyAdmin\n    {\n        _name = name;\n        _symbol = symbol;\n\n        synthetic = ISyntheticToken(_syntheticAddress);\n\n        paused = true;\n\n        savingsIndex = BASE;\n        indexLastUpdate = currentTimestamp();\n\n        setArcFee(_fee);\n    }\n\n    /* ========== Public View Functions ========== */\n\n    function name()\n        external\n        view\n        returns (string memory)\n    {\n        return _name;\n    }\n\n    function symbol()\n        external\n        view\n        returns (string memory)\n    {\n        return _symbol;\n    }\n\n    function decimals()\n        external\n        pure\n        returns (uint8)\n    {\n        return 18;\n    }\n\n    function currentTimestamp()\n        public\n        view\n        returns (uint256)\n    {\n        return block.timestamp;\n    }\n\n    function balanceOf(\n        address user\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _balances[user];\n    }\n\n    function totalSupply()\n        public\n        view\n        returns (uint256)\n    {\n        return _totalSupply;\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function currentSavingsIndex()\n        public\n        view\n        returns (uint256)\n    {\n        // Check the time since the last update, multiply to get interest generated\n        uint256 totalInterestAccumulated = savingsRate.mul(currentTimestamp().sub(indexLastUpdate));\n\n        // Set the new index based on how much accrued\n        return savingsIndex.add(totalInterestAccumulated);\n    }\n\n    /* ========== Admin Functions ========== */\n\n    function setSavingsRate(\n        uint256 rate\n    )\n        public\n        onlyAdmin\n    {\n        savingsRate = rate;\n\n        emit SavingsRateUpdated(rate);\n    }\n\n    function setArcFee(\n        Decimal.D256 memory _fee\n    )\n        public\n        onlyAdmin\n    {\n        arcFee = _fee;\n\n        emit ArcFeeUpdated(_fee.value);\n    }\n\n    function setPaused(\n        bool status\n    )\n        public\n        onlyAdmin\n    {\n        paused = status;\n\n        emit Paused(status);\n    }\n\n    /* ========== Public Functions ========== */\n\n    /**\n     * @dev Stake your synthetic tokens to earn interest.\n     *\n     * @notice Can only be called if contracts not paused.\n     *\n     * @param amount The actual number of tokens you'd like to stake (not principal amount)\n     */\n    function stake(\n        uint256 amount\n    )\n        public\n        isActive\n        returns (uint256)\n    {\n        // CHECKS:\n        // 1. Update the index to make sure we use the correct\n        //    values for calculations when withdrawing\n        // 2. Calculate the principal amount given a deposit amount\n\n        // EFFECTS:\n        // 1. Set the user's balance to the new calculated amount\n\n        // INTERACTIONS:\n        // 1. Transfer the synthetic tokens to the contract\n        // 2. Increase the total supplied amount\n\n        // Update the index first\n        uint256 latestIndex = updateIndex();\n\n        // Calculate your stake amount given the current index\n        Amount.Principal memory depositPrincipalAmount = Amount.calculatePrincipal(\n            amount,\n            latestIndex,\n            true\n        );\n\n        // Increase the totalSupplied amount\n        totalSupplied = totalSupplied.add(amount);\n\n        // Mints the receipt token\n        _mint(\n            msg.sender,\n            depositPrincipalAmount.value\n        );\n\n        // Transfer the synth\n        IERC20(address(synthetic)).transferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        return latestIndex;\n    }\n\n    /**\n     * @dev Unstake your synthetic tokens and stop earning interest on them.\n     *\n     * @notice Can only be called if contracts not paused.\n     *\n     * @param amount The interested adjusted amount of tokens you'd like to unstake\n     */\n    function unstake(\n        uint256 amount\n    )\n        public\n        isActive\n        returns (uint256)\n    {\n        // CHECKS:\n        // 1. Update the index to make sure we can use the correct\n        //    values for calculations when withdrawing\n        // 2. Calculate the principal amount that needs to be withdrawn\n\n        // EFFECTS:\n        // 1. Update the user's balance\n        // 2. Decrease the total supplied amount\n\n        // INTERACTIONS\n        // 1. Transfer the tokens back to the user\n\n        // Update the index first\n        uint256 latestIndex = updateIndex();\n\n        // Calculate the withdraw amount given the index\n        Amount.Principal memory withdrawPrinicipalAmount = Amount.calculatePrincipal(\n            amount,\n            latestIndex,\n            true\n        );\n\n        // Get the user's existing balance\n        uint256 existingPrincipalBalance = _balances[msg.sender];\n\n        // Ensure that the user's existing balance is greater than the withdraw amount\n        require(\n            existingPrincipalBalance >= withdrawPrinicipalAmount.value,\n            \"unstake(): cannot withdraw more than you are allowed\"\n        );\n\n        // Decrease the totalSupplied amount\n        totalSupplied = totalSupplied.sub(amount);\n\n        // Burns the receipt token\n        _burn(\n            msg.sender,\n            withdrawPrinicipalAmount.value\n        );\n\n        // Transfer the synth\n        IERC20(address(synthetic)).transfer(\n            msg.sender,\n            amount\n        );\n\n        return latestIndex;\n    }\n\n    /**\n     * @dev Unstake all your synthetic tokens and stop earning interest on them.\n     *\n     * @notice Can only be called if contracts not paused.\n     *\n     */\n    function unstakeAll()\n        public\n        isActive\n        returns (uint256)\n    {\n        // Get the user's principal balance\n        uint256 principalBalance = balanceOf(msg.sender);\n\n        // Get the interest adjusted amount by multiplying by the index\n        uint256 userBalance = principalBalance.mul(savingsIndex).div(BASE);\n\n        // Call the unstake function with the final balance\n        return unstake(userBalance);\n    }\n\n    /**\n     * @dev Accumulates interest for all capital. Can be called by anyone.\n     *\n     * @notice Can only be called if contracts not paused.\n     *\n     */\n    function updateIndex()\n        public\n        isActive\n        returns (uint256)\n    {\n        // CHECKS:\n        // 1. If there has been no time since the last update OR no savings rate set, return\n        // 2. Calculate the interest accumulated since the last time the index was updated\n\n        // EFFECTS:\n        // 1. Update the new savings index by adding the amount of interest accumualted\n        // 2. Update the total supplied amount of the contracts to indicate how much money it holds\n        // 3. Update the index last update timestamp\n\n        // INTERACTIONS:\n        // 1. Mint the amount of interest accrued\n\n        // If there have been no updates then return\n        if (currentTimestamp() == indexLastUpdate) {\n            return savingsIndex;\n        }\n\n        if (savingsRate == 0) {\n            indexLastUpdate = currentTimestamp();\n            emit IndexUpdated(indexLastUpdate, savingsIndex);\n            return savingsIndex;\n        }\n\n        // Set the new index based on how much accrued\n        uint256 newSavingsIndex = currentSavingsIndex();\n        savingsIndex = newSavingsIndex;\n\n        uint256 existingSupply = totalSupplied;\n        totalSupplied = totalSupplied.mul(newSavingsIndex).div(BASE);\n\n        // With the difference between the new amount being borrowed and the existing amount\n        // we can figure out how much interest is owed to the system as a whole and therefore\n        // calculate how much of the synth to mint\n        uint256 interestAccrued = totalSupplied.sub(existingSupply);\n\n        // Set the last time the index was updated to now\n        indexLastUpdate = currentTimestamp();\n\n        synthetic.mint(\n            address(this),\n            interestAccrued\n        );\n\n        emit IndexUpdated(\n            indexLastUpdate,\n            newSavingsIndex\n        );\n\n        return newSavingsIndex;\n    }\n\n    /* ========== Token Functions ========== */\n\n    function transfer(\n        address recipient,\n        uint256 amount\n    )\n        public\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(\n        address spender,\n        uint256 amount\n    )\n        public\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        public\n        returns (bool)\n    {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            _allowances[sender][msg.sender].sub(amount)\n        );\n\n        return true;\n    }\n\n    /* ========== Internal Functions ========== */\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        internal\n    {\n        require(\n            sender != address(0),\n            \"ERC20: transfer from the zero address\"\n        );\n\n        require(\n            recipient != address(0),\n            \"ERC20: transfer to the zero address\"\n        );\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    )\n        internal\n    {\n        require(\n            owner != address(0),\n            \"ERC20: approve from the zero address\"\n        );\n\n        require(\n            spender != address(0),\n            \"ERC20: approve to the zero address\"\n        );\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _mint(\n        address account,\n        uint256 amount\n    )\n        internal\n    {\n        require(\n            account != address(0),\n            \"ERC20: mint to the zero address\"\n        );\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(\n        address account,\n        uint256 amount\n    )\n        internal\n    {\n        require(\n            account != address(0),\n            \"ERC20: burn from the zero address\"\n        );\n\n        _balances[account] = _balances[account].sub(amount);\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n}\n"},"./contracts/lib/Adminable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { Storage } from \"./Storage.sol\";\n\n/**\n * @title Adminable\n * @author dYdX\n *\n * @dev EIP-1967 Proxy Admin contract.\n */\ncontract Adminable {\n    /**\n     * @dev Storage slot with the admin of the contract.\n     *  This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    bytes32 internal constant ADMIN_SLOT =\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n    * @dev Modifier to check whether the `msg.sender` is the admin.\n    *  If it is, it will run the function. Otherwise, it will revert.\n    */\n    modifier onlyAdmin() {\n        require(\n            msg.sender == getAdmin(),\n            \"Adminable: caller is not admin\"\n        );\n        _;\n    }\n\n    /**\n     * @return The EIP-1967 proxy admin\n     */\n    function getAdmin()\n        public\n        view\n        returns (address)\n    {\n        return address(uint160(uint256(Storage.load(ADMIN_SLOT))));\n    }\n}"},"./contracts/lib/Amount.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {Math} from \"../lib/Math.sol\";\n\nlibrary Amount {\n\n    using Math for uint256;\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    uint256 constant BASE = 10**18;\n\n    // A Principal Amount is an amount that's been adjusted by an index\n\n    struct Principal {\n        bool sign; // true if positive\n        uint256 value;\n    }\n\n    function zero()\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return Principal({\n            sign: false,\n            value: 0\n        });\n    }\n\n    function sub(\n        Principal memory a,\n        Principal memory b\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return add(a, negative(b));\n    }\n\n    function add(\n        Principal memory a,\n        Principal memory b\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        Principal memory result;\n\n        if (a.sign == b.sign) {\n            result.sign = a.sign;\n            result.value = SafeMath.add(a.value, b.value);\n        } else {\n            if (a.value >= b.value) {\n                result.sign = a.sign;\n                result.value = SafeMath.sub(a.value, b.value);\n            } else {\n                result.sign = b.sign;\n                result.value = SafeMath.sub(b.value, a.value);\n            }\n        }\n        return result;\n    }\n\n    function equals(\n        Principal memory a,\n        Principal memory b\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        if (a.value == b.value) {\n            if (a.value == 0) {\n                return true;\n            }\n            return a.sign == b.sign;\n        }\n        return false;\n    }\n\n    function negative(\n        Principal memory a\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return Principal({\n            sign: !a.sign,\n            value: a.value\n        });\n    }\n\n    function calculateAdjusted(\n        Principal memory a,\n        uint256 index\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(a.value, index, BASE);\n    }\n\n    function calculatePrincipal(\n        uint256 value,\n        uint256 index,\n        bool sign\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return Principal({\n            sign: sign,\n            value: Math.getPartial(value, BASE, index)\n        });\n    }\n\n}\n"},"./contracts/lib/Decimal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {Math} from \"./Math.sol\";\n\n/**\n * @title Decimal\n *\n * Library that defines a fixed-point number with 18 decimal places.\n */\nlibrary Decimal {\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    uint256 constant BASE = 10**18;\n\n    // ============ Structs ============\n\n    struct D256 {\n        uint256 value;\n    }\n\n    // ============ Functions ============\n\n    function one()\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: BASE });\n    }\n\n    function onePlus(\n        D256 memory d\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: d.value.add(BASE) });\n    }\n\n    function mul(\n        uint256 target,\n        D256 memory d\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(target, d.value, BASE);\n    }\n\n    function mul(\n        D256 memory d1,\n        D256 memory d2\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return Decimal.D256({ value: Math.getPartial(d1.value, d2.value, BASE) });\n    }\n\n    function div(\n        uint256 target,\n        D256 memory d\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(target, BASE, d.value);\n    }\n\n    function add(\n        D256 memory d,\n        uint256 amount\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: d.value.add(amount) });\n    }\n\n    function sub(\n        D256 memory d,\n        uint256 amount\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: d.value.sub(amount) });\n    }\n\n}\n"},"./contracts/lib/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"./SafeMath.sol\";\n\n/**\n * @title Math\n *\n * Library for non-standard Math functions\n */\nlibrary Math {\n    using SafeMath for uint256;\n\n    // ============ Library Functions ============\n\n    /*\n     * Return target * (numerator / denominator).\n     */\n    function getPartial(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return target.mul(numerator).div(denominator);\n    }\n\n    function to128(\n        uint256 number\n    )\n        internal\n        pure\n        returns (uint128)\n    {\n        uint128 result = uint128(number);\n        require(\n            result == number,\n            \"Math: Unsafe cast to uint128\"\n        );\n        return result;\n    }\n\n    function min(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function max(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a > b ? a : b;\n    }\n}\n"},"./contracts/lib/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"./contracts/lib/SafeERC20.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.5.16;\n\nimport {IERC20} from \"../token/IERC20.sol\";\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary SafeERC20 {\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        /* solium-disable-next-line */\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: APPROVE_FAILED\"\n        );\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        /* solium-disable-next-line */\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        /* solium-disable-next-line */\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(\n                0x23b872dd,\n                from,\n                to,\n                value\n            )\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: TRANSFER_FROM_FAILED\"\n        );\n    }\n}\n"},"./contracts/lib/SafeMath.sol":{"content":"\npragma solidity ^0.5.16;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"},"./contracts/lib/Storage.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nlibrary Storage {\n\n    /**\n     * @dev Performs an SLOAD and returns the data in the slot.\n     */\n    function load(\n        bytes32 slot\n    )\n        internal\n        view\n        returns (bytes32)\n    {\n        bytes32 result;\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            result := sload(slot)\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs an SSTORE to save the value to the slot.\n     */\n    function store(\n        bytes32 slot,\n        bytes32 value\n    )\n        internal\n    {\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            sstore(slot, value)\n        }\n    }\n}"},"./contracts/token/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    )\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(\n        address spender,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"},"./contracts/token/ISyntheticToken.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {Amount} from \"../lib/Amount.sol\";\n\ninterface ISyntheticToken {\n\n    function symbolKey()\n        external\n        view\n        returns (bytes32);\n\n    function mint(\n        address to,\n        uint256 value\n    )\n        external;\n\n    function burn(\n        address to,\n        uint256 value\n    )\n        external;\n\n    function transferCollateral(\n        address token,\n        address to,\n        uint256 value\n    )\n        external\n        returns (bool);\n\n    function getMinterIssued(\n        address _minter\n    )\n        external\n        view\n        returns (Amount.Principal memory);\n\n    function getMinterLimit(\n        address _minter\n    )\n        external\n        view\n        returns (uint256);\n\n}\n"}}}