{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "BalanceManager.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\ninterface IKeeperRecipient {\r\n    function keep() external;\r\n}\r\n\r\ninterface IArmorMaster {\r\n    function registerModule(bytes32 _key, address _module) external;\r\n    function getModule(bytes32 _key) external view returns(address);\r\n    function keep() external;\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * \r\n * @dev Completely default OpenZeppelin.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function initializeOwnable() internal {\r\n        require(_owner == address(0), \"already initialized\");\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"msg.sender is not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _pendingOwner = newOwner;\r\n    }\r\n\r\n    function receiveOwnership() public {\r\n        require(msg.sender == _pendingOwner, \"only pending owner can call this function\");\r\n        _transferOwnership(_pendingOwner);\r\n        _pendingOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\nlibrary Bytes32 {\r\n    function toString(bytes32 x) internal pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint256 j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint256 j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Each arCore contract is a module to enable simple communication and interoperability. ArmorMaster.sol is master.\r\n**/\r\ncontract ArmorModule {\r\n    IArmorMaster internal _master;\r\n\r\n    using Bytes32 for bytes32;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == Ownable(address(_master)).owner(), \"only owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier doKeep() {\r\n        _master.keep();\r\n        _;\r\n    }\r\n\r\n    modifier onlyModule(bytes32 _module) {\r\n        string memory message = string(abi.encodePacked(\"only module \", _module.toString(),\" can call this function\"));\r\n        require(msg.sender == getModule(_module), message);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Used when multiple can call.\r\n    **/\r\n    modifier onlyModules(bytes32 _moduleOne, bytes32 _moduleTwo) {\r\n        string memory message = string(abi.encodePacked(\"only module \", _moduleOne.toString(),\" or \", _moduleTwo.toString(),\" can call this function\"));\r\n        require(msg.sender == getModule(_moduleOne) || msg.sender == getModule(_moduleTwo), message);\r\n        _;\r\n    }\r\n\r\n    function initializeModule(address _armorMaster) internal {\r\n        require(address(_master) == address(0), \"already initialized\");\r\n        require(_armorMaster != address(0), \"master cannot be zero address\");\r\n        _master = IArmorMaster(_armorMaster);\r\n    }\r\n\r\n    function changeMaster(address _newMaster) external onlyOwner {\r\n        _master = IArmorMaster(_newMaster);\r\n    }\r\n\r\n    function getModule(bytes32 _key) internal view returns(address) {\r\n        return _master.getModule(_key);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n * \r\n * @dev Default OpenZeppelin\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Balance Expire Traker\r\n * @dev Keeps track of expiration of user balances.\r\n**/\r\ncontract BalanceExpireTracker {\r\n    \r\n    using SafeMath for uint64;\r\n    using SafeMath for uint256;\r\n    \r\n    // Don't want to keep typing address(0). Typecasting just for clarity.\r\n    uint160 private constant EMPTY = uint160(address(0));\r\n    \r\n    // 1 day for each step.\r\n    uint64 public constant BUCKET_STEP = 86400;\r\n\r\n    // indicates where to start from \r\n    // points where TokenInfo with (expiredAt / BUCKET_STEP) == index\r\n    mapping(uint64 => Bucket) public checkPoints;\r\n\r\n    struct Bucket {\r\n        uint160 head;\r\n        uint160 tail;\r\n    }\r\n\r\n    // points first active nft\r\n    uint160 public head;\r\n    // points last active nft\r\n    uint160 public tail;\r\n\r\n    // maps expireId to deposit info\r\n    mapping(uint160 => ExpireMetadata) public infos; \r\n    \r\n    // pack data to reduce gas\r\n    struct ExpireMetadata {\r\n        uint160 next; // zero if there is no further information\r\n        uint160 prev;\r\n        uint64 expiresAt;\r\n    }\r\n\r\n    function expired() internal view returns(bool){\r\n        if(infos[head].expiresAt == 0) {\r\n            return false;\r\n        }\r\n\r\n        if(infos[head].expiresAt <= uint64(now)){\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // using typecasted expireId to save gas\r\n    function push(uint160 expireId, uint64 expiresAt) \r\n      internal \r\n    {\r\n        require(expireId != EMPTY, \"info id address(0) cannot be supported\");\r\n        \r\n        // If this is a replacement for a current balance, remove it's current link first.\r\n        if (infos[expireId].expiresAt > 0) pop(expireId);\r\n        \r\n        uint64 bucket = uint64( (expiresAt.div(BUCKET_STEP)).mul(BUCKET_STEP) );\r\n        if (head == EMPTY) {\r\n            // all the nfts are expired. so just add\r\n            head = expireId;\r\n            tail = expireId;\r\n            checkPoints[bucket] = Bucket(expireId, expireId);\r\n            infos[expireId] = ExpireMetadata(EMPTY,EMPTY,expiresAt);\r\n            \r\n            return;\r\n        }\r\n            \r\n        // there is active nft. we need to find where to push\r\n        // first check if this expires faster than head\r\n        if (infos[head].expiresAt >= expiresAt) {\r\n            // pushing nft is going to expire first\r\n            // update head\r\n            infos[head].prev = expireId;\r\n\r\n            infos[expireId] = ExpireMetadata(head, EMPTY, expiresAt);\r\n            head = expireId;\r\n            \r\n            // update head of bucket\r\n            Bucket storage b = checkPoints[bucket];\r\n            b.head = expireId;\r\n                \r\n            if(b.tail == EMPTY) {\r\n                // if tail is zero, this bucket was empty should fill tail with expireId\r\n                b.tail = expireId;\r\n            }\r\n                \r\n            // this case can end now\r\n            return;\r\n        }\r\n          \r\n        // then check if depositing nft will last more than latest\r\n        if (infos[tail].expiresAt <= expiresAt) {\r\n            infos[tail].next = expireId;\r\n\r\n            // push nft at tail\r\n            infos[expireId] = ExpireMetadata(EMPTY,tail,expiresAt);\r\n            tail = expireId;\r\n            \r\n            // update tail of bucket\r\n            Bucket storage b = checkPoints[bucket];\r\n            b.tail = expireId;\r\n            \r\n            if(b.head == EMPTY) {\r\n              // if head is zero, this bucket was empty should fill head with expireId\r\n              b.head = expireId;\r\n            }\r\n            \r\n            // this case is done now\r\n            return;\r\n        }\r\n          \r\n        // so our nft is somewhere in between\r\n        if (checkPoints[bucket].head != EMPTY) {\r\n            //bucket is not empty\r\n            //we just need to find our neighbor in the bucket\r\n            uint160 cursor = checkPoints[bucket].head;\r\n        \r\n            // iterate until we find our nft's next\r\n            while(infos[cursor].expiresAt < expiresAt){\r\n                cursor = infos[cursor].next;\r\n            }\r\n        \r\n            infos[expireId] = ExpireMetadata(cursor, infos[cursor].prev, expiresAt);\r\n            infos[infos[cursor].prev].next = expireId;\r\n            infos[cursor].prev = expireId;\r\n        \r\n            //now update bucket's head/tail data\r\n            Bucket storage b = checkPoints[bucket];\r\n            \r\n            if (infos[b.head].prev == expireId){\r\n                b.head = expireId;\r\n            }\r\n            \r\n            if (infos[b.tail].next == expireId){\r\n                b.tail = expireId;\r\n            }\r\n        } else {\r\n            //bucket is empty\r\n            //should find which bucket has depositing nft's closest neighbor\r\n            // step 1 find prev bucket\r\n            uint64 prevCursor = uint64( bucket.sub(BUCKET_STEP) );\r\n            \r\n            while(checkPoints[prevCursor].tail == EMPTY){\r\n              prevCursor = uint64( prevCursor.sub(BUCKET_STEP) );\r\n            }\r\n    \r\n            uint160 prev = checkPoints[prevCursor].tail;\r\n            uint160 next = infos[prev].next;\r\n    \r\n            // step 2 link prev buckets tail - nft - next buckets head\r\n            infos[expireId] = ExpireMetadata(next,prev,expiresAt);\r\n            infos[prev].next = expireId;\r\n            infos[next].prev = expireId;\r\n    \r\n            checkPoints[bucket].head = expireId;\r\n            checkPoints[bucket].tail = expireId;\r\n        }\r\n    }\r\n\r\n    function pop(uint160 expireId) internal {\r\n        uint64 expiresAt = infos[expireId].expiresAt;\r\n        uint64 bucket = uint64( (expiresAt.div(BUCKET_STEP)).mul(BUCKET_STEP) );\r\n        // check if bucket is empty\r\n        // if bucket is empty, reverts\r\n        require(checkPoints[bucket].head != EMPTY, \"Info does not exist: Bucket empty\");\r\n        // if bucket is not empty, iterate through\r\n        // if expiresAt of current cursor is larger than expiresAt of parameter, reverts\r\n        for(uint160 cursor = checkPoints[bucket].head; infos[cursor].expiresAt <= expiresAt; cursor = infos[cursor].next) {\r\n            ExpireMetadata memory info = infos[cursor];\r\n            // if expiresAt is same of paramter, check if expireId is same\r\n            if(info.expiresAt == expiresAt && cursor == expireId) {\r\n                // if yes, delete it\r\n                // if cursor was head, move head to cursor.next\r\n                if(head == cursor) {\r\n                    head = info.next;\r\n                }\r\n                // if cursor was tail, move tail to cursor.prev\r\n                if(tail == cursor) {\r\n                    tail = info.prev;\r\n                }\r\n                // if cursor was head of bucket\r\n                if(checkPoints[bucket].head == cursor){\r\n                    // and cursor.next is still in same bucket, move head to cursor.next\r\n                    if(infos[info.next].expiresAt.div(BUCKET_STEP) == bucket.div(BUCKET_STEP)){\r\n                        checkPoints[bucket].head == info.next;\r\n                    } else {\r\n                        // delete whole checkpoint if bucket is now empty\r\n                        delete checkPoints[bucket];\r\n                    }\r\n                } else if(checkPoints[bucket].tail == cursor){\r\n                    // since bucket.tail == bucket.haed == cursor case is handled at the above,\r\n                    // we only have to handle bucket.tail == cursor != bucket.head\r\n                    checkPoints[bucket].tail = info.prev;\r\n                }\r\n                // now we handled all tail/head situation, we have to connect prev and next\r\n                infos[info.prev].next = info.next;\r\n                infos[info.next].prev = info.prev;\r\n                // delete info and end\r\n                delete infos[cursor];\r\n                return;\r\n            }\r\n            // if not, continue -> since there can be same expires at with multiple expireId\r\n        }\r\n        revert(\"Info does not exist.\");\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IBalanceManager {\r\n  event Deposit(address indexed user, uint256 amount);\r\n  event Withdraw(address indexed user, uint256 amount);\r\n  event Loss(address indexed user, uint256 amount);\r\n  event PriceChange(address indexed user, uint256 price);\r\n  event AffiliatePaid(address indexed affiliate, address indexed referral, uint256 amount, uint256 timestamp);\r\n  event ReferralAdded(address indexed affiliate, address indexed referral, uint256 timestamp);\r\n  function deposit(address _referrer) external payable;\r\n  function withdraw(uint256 _amount) external;\r\n  function updateBalance(address _user) external;\r\n  function initialize(address _armormaster, address _devWallet) external;\r\n  function balanceOf(address _user) external view returns (uint256);\r\n  function perSecondPrice(address _user) external view returns(uint256);\r\n  function changePrice(address user, uint64 _newPricePerSec) external;\r\n}\r\n\r\ninterface IPlanManager {\r\n  // Event to notify frontend of plan update.\r\n  event PlanUpdate(address indexed user, address[] protocols, uint256[] amounts, uint256 endTime);\r\n  function initialize(address _armorManager) external;\r\n  function changePrice(address _scAddress, uint256 _pricePerAmount) external;\r\n  function updatePlan(address[] calldata _protocols, uint256[] calldata _coverAmounts) external;\r\n  function checkCoverage(address _user, address _protocol, uint256 _hacktime, uint256 _amount) external view returns (uint256, bool);\r\n  function coverageLeft(address _protocol) external view returns(uint256);\r\n  function getCurrentPlan(address _user) external view returns(uint128 start, uint128 end);\r\n  function updateExpireTime(address _user) external;\r\n  function planRedeemed(address _useer, uint256 _planIndex, address _protocol) external;\r\n}\r\n\r\ninterface IRewardDistributionRecipient {\r\n    function notifyRewardAmount(uint256 reward) payable external;\r\n}\r\n\r\ninterface IRewardManager is IRewardDistributionRecipient {\r\n  function initialize(address _rewardToken, address _stakeManager) external;\r\n  function stake(address _user, uint256 _coverPrice, uint256 _nftId) external;\r\n  function withdraw(address _user, uint256 _coverPrice, uint256 _nftId) external;\r\n  function getReward(address payable _user) external;\r\n}\r\n\r\ninterface IUtilizationFarm is IRewardDistributionRecipient {\r\n  function initialize(address _rewardToken, address _stakeManager) external;\r\n  function stake(address _user, uint256 _coverPrice) external;\r\n  function withdraw(address _user, uint256 _coverPrice) external;\r\n  function getReward(address payable _user) external;\r\n}\r\n\r\n// SPDX-License-Identifier: (c) Armor.Fi DAO, 2021\r\n\r\n/**\r\n * @dev BorrowManager is where borrowers do all their interaction and it holds funds\r\n *      until they're sent to the StakeManager.\r\n **/\r\ncontract BalanceManager is ArmorModule, IBalanceManager, BalanceExpireTracker {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint128;\r\n\r\n    // Wallet of the developers for if a developer fee is being paid.\r\n    address public devWallet;\r\n\r\n    // With lastTime and secondPrice we can determine balance by second.\r\n    struct Balance {\r\n        uint64 lastTime;\r\n        uint64 perSecondPrice;\r\n        uint128 lastBalance;\r\n    }\r\n    \r\n    // keep track of monthly payments and start/end of those\r\n    mapping (address => Balance) public balances;\r\n\r\n    // user => referrer\r\n    mapping (address => address) public referrers;\r\n\r\n    // Percent of funds that go to development--start with 0 and can change.\r\n    uint128 public devPercent;\r\n\r\n    // Percent of funds referrers receive. 20 = 2%.\r\n    uint128 public refPercent;\r\n\r\n    // Percent of funds given to governance stakers.\r\n    uint128 public govPercent;\r\n\r\n    // Denominator used to when distributing tokens 1000 == 100%\r\n    uint128 public constant DENOMINATOR = 1000;\r\n\r\n    // True if utilization farming is still ongoing\r\n    bool public ufOn;\r\n\r\n    // Mapping of shields so we don't reward them for U.F.\r\n    mapping (address => bool) public arShields;\r\n    \r\n    // Block withdrawals within 1 hour of depositing.\r\n    modifier onceAnHour {\r\n        require(block.timestamp >= balances[msg.sender].lastTime.add(1 hours), \"You must wait an hour after your last update to withdraw.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Call updateBalance before any action is taken by a user.\r\n     * @param _user The user whose balance we need to update.\r\n     **/\r\n    modifier update(address _user)\r\n    {\r\n        updateBalance(_user);\r\n        \r\n        _;\r\n        \r\n        Balance memory balance = balances[_user];\r\n        \r\n        if (balance.perSecondPrice > 0) {\r\n            uint64 expiry = uint64( balance.lastBalance.div(uint128(balance.perSecondPrice)).add(uint128(balance.lastTime)) );\r\n            BalanceExpireTracker.push(uint160(_user), expiry);\r\n        }\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev Keep function can be called by anyone to balances that have been expired. This pays out addresses and removes used cover.\r\n     *      This is external because the doKeep modifier calls back to ArmorMaster, which then calls back to here (and elsewhere).\r\n    **/\r\n    function keep() external {\r\n        // Restrict each keep to 3 removes max.\r\n        for (uint256 i = 0; i < 3; i++) {\r\n        \r\n            if (infos[head].expiresAt != 0 && infos[head].expiresAt <= now) {\r\n                address oldHead = address(head);\r\n                uint256 oldPrice = balances[oldHead].perSecondPrice;\r\n                BalanceExpireTracker.pop(head);\r\n                updateBalance(oldHead);\r\n        \r\n                // Remove borrowed amount from PlanManager.        \r\n                _notifyBalanceChange(msg.sender);\r\n            } else return;\r\n            \r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param _armorMaster Address of the ArmorMaster contract.\r\n     **/\r\n    function initialize(address _armorMaster, address _devWallet)\r\n      external\r\n      override\r\n    {\r\n        initializeModule(_armorMaster);\r\n        devWallet = _devWallet;\r\n        devPercent = 0;     // 0 %\r\n        refPercent = 25;    // 2.5%\r\n        govPercent = 0;     // 0%\r\n        ufOn = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Borrower deposits an amount of ETH to pay for coverage.\r\n     * @param _referrer User who referred the depositor.\r\n     **/\r\n    function deposit(address _referrer) \r\n      external\r\n      payable\r\n      override\r\n      doKeep\r\n      update(msg.sender)\r\n    {\r\n        if ( referrers[msg.sender] == address(0) ) {\r\n            referrers[msg.sender] = _referrer != address(0) ? _referrer : devWallet;\r\n            emit ReferralAdded(_referrer, msg.sender, block.timestamp);\r\n        }\r\n        \r\n        require(msg.value > 0, \"No Ether was deposited.\");\r\n\r\n        balances[msg.sender].lastBalance = uint128(balances[msg.sender].lastBalance.add(msg.value));\r\n        // it is handled in update() function\r\n        //balances[msg.sender].lastTime = uint64(block.timestamp);\r\n        _notifyBalanceChange(msg.sender);\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Borrower withdraws Dai from the contract.\r\n     * @param _amount The amount of Dai to withdraw.\r\n     **/\r\n    function withdraw(uint256 _amount)\r\n      external\r\n      override\r\n      onceAnHour\r\n      doKeep\r\n      update(msg.sender)\r\n    {\r\n        Balance memory balance = balances[msg.sender];\r\n\r\n        // Since cost increases per second, it's difficult to estimate the correct amount. Withdraw it all in that case.\r\n        if (balance.lastBalance > _amount) {\r\n            balance.lastBalance = uint128( balance.lastBalance.sub(_amount) );\r\n        } else {\r\n            _amount = balance.lastBalance;\r\n            balance.lastBalance = 0;\r\n        }\r\n        \r\n        balances[msg.sender] = balance;\r\n        _notifyBalanceChange(msg.sender);\r\n        msg.sender.transfer(_amount);\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Find the current balance of a user to the second.\r\n     * @param _user The user whose balance to find.\r\n     **/\r\n    function balanceOf(address _user)\r\n      public\r\n      view\r\n      override\r\n    returns (uint256)\r\n    {\r\n        Balance memory balance = balances[_user];\r\n\r\n        // We adjust balance on chain based on how many blocks have passed.\r\n        uint256 lastBalance = balance.lastBalance;\r\n\r\n        uint256 timeElapsed = block.timestamp.sub(balance.lastTime);\r\n        uint256 cost = timeElapsed.mul(balance.perSecondPrice);\r\n\r\n        // If the elapsed time has brought balance to 0, make it 0.\r\n        uint256 newBalance;\r\n        if (lastBalance > cost) newBalance = lastBalance.sub(cost);\r\n        else newBalance = 0;\r\n\r\n        return newBalance;\r\n    }\r\n\r\n    /**\r\n     * @dev Update a borrower's balance to it's adjusted amount.\r\n     * @param _user The address to be updated.\r\n     **/\r\n    function updateBalance(address _user)\r\n      public\r\n      override\r\n    {\r\n        Balance memory balance = balances[_user];\r\n\r\n        // The new balance that a user will have.\r\n        uint256 newBalance = balanceOf(_user);\r\n\r\n        // newBalance should never be greater than last balance.\r\n        uint256 loss = balance.lastBalance.sub(newBalance);\r\n    \r\n        _payPercents(_user, uint128(loss));\r\n\r\n        // Update storage balance.\r\n        balance.lastBalance = uint128(newBalance);\r\n        balance.lastTime = uint64(block.timestamp);\r\n        emit Loss(_user, loss);\r\n        \r\n        if (newBalance == 0) {\r\n            _priceChange(_user, 0);\r\n        }\r\n        \r\n        balances[_user] = balance;\r\n    }\r\n\r\n    /**\r\n     * @dev handle the user's balance change. this will interact with UFB\r\n     * @param _user user's address\r\n     * @param _newPrice user's new per sec price\r\n     **/\r\n\r\n    function _priceChange(address _user, uint64 _newPrice) internal {\r\n        Balance storage balance = balances[_user];\r\n        uint64 originalPrice = balance.perSecondPrice;\r\n        if(originalPrice == _newPrice) {\r\n            // no need to process\r\n            return;\r\n        }\r\n        if(ufOn && !arShields[_user]) {\r\n            if(originalPrice > _newPrice) {\r\n                // price is decreasing\r\n                IUtilizationFarm(getModule(\"UFB\")).withdraw(_user, originalPrice.sub(_newPrice));\r\n            } else {\r\n                // price is increasing\r\n                IUtilizationFarm(getModule(\"UFB\")).stake(_user, _newPrice.sub(originalPrice));\r\n            } \r\n        }\r\n        \r\n        balance.perSecondPrice = _newPrice;\r\n        emit PriceChange(_user, _newPrice);\r\n    }\r\n\r\n    /**\r\n     * @dev Armor controller has the ability to change the price that a user is paying for their insurance.\r\n     * @param _user The user whose price we are changing.\r\n     * @param _newPrice the new price per second that the user will be paying.\r\n     **/\r\n    function changePrice(address _user, uint64 _newPrice)\r\n      external\r\n      override\r\n      onlyModule(\"PLAN\")\r\n      update(_user)\r\n    {\r\n        _priceChange(_user, _newPrice);\r\n    }\r\n\r\n    /**\r\n     * @dev Send funds to governanceStaker and rewardManager (don't want to have to send them with every transaction).\r\n    **/\r\n    function releaseFunds()\r\n      public\r\n    {\r\n       uint256 govBalance = balances[getModule(\"GOVSTAKE\")].lastBalance;\r\n       // If staking contracts are sent too low of a reward, it can mess up distribution.\r\n       if (govBalance >= 1 ether / 10) {\r\n           IRewardManager(getModule(\"GOVSTAKE\")).notifyRewardAmount{value: govBalance}(govBalance);\r\n           balances[getModule(\"GOVSTAKE\")].lastBalance = 0;\r\n       }\r\n       \r\n       uint256 rewardBalance = balances[getModule(\"REWARD\")].lastBalance;\r\n       // If staking contracts are sent too low of a reward, it can mess up distribution.\r\n       if (rewardBalance >= 1 ether / 10) {\r\n           IRewardManager(getModule(\"REWARD\")).notifyRewardAmount{value: rewardBalance}(rewardBalance);\r\n           balances[getModule(\"REWARD\")].lastBalance = 0;\r\n       }\r\n    }\r\n\r\n    function perSecondPrice(address _user)\r\n      external\r\n      override\r\n      view\r\n    returns(uint256)\r\n    {\r\n        Balance memory balance = balances[_user];\r\n        return balance.perSecondPrice;\r\n    }\r\n    \r\n    /**\r\n     * @dev Give rewards to different places.\r\n     * @param _user User that's being charged.\r\n     * @param _charged Amount of funds charged to the user.\r\n    **/\r\n    function _payPercents(address _user, uint128 _charged)\r\n      internal\r\n    {\r\n        // percents: 20 = 2%.\r\n        uint128 refAmount = referrers[_user] != address(0) ? _charged * refPercent / DENOMINATOR : 0;\r\n        uint128 devAmount = _charged * devPercent / DENOMINATOR;\r\n        uint128 govAmount = _charged * govPercent / DENOMINATOR;\r\n        uint128 nftAmount = uint128( _charged.sub(refAmount).sub(devAmount).sub(govAmount) );\r\n        \r\n        if (refAmount > 0) {\r\n            balances[ referrers[_user] ].lastBalance = uint128( balances[ referrers[_user] ].lastBalance.add(refAmount) );\r\n            emit AffiliatePaid(referrers[_user], _user, refAmount, block.timestamp);\r\n        }\r\n        if (devAmount > 0) balances[devWallet].lastBalance = uint128( balances[devWallet].lastBalance.add(devAmount) );\r\n        if (govAmount > 0) balances[getModule(\"GOVSTAKE\")].lastBalance = uint128( balances[getModule(\"GOVSTAKE\")].lastBalance.add(govAmount) );\r\n        if (nftAmount > 0) balances[address(IRewardManager(getModule(\"REWARD\")))].lastBalance = uint128( balances[address(IRewardManager(getModule(\"REWARD\")))].lastBalance.add(nftAmount) );\r\n    }\r\n\r\n    /**\r\n     * @dev Balance has changed so PlanManager's expire time must be either increased or reduced.\r\n    **/\r\n    function _notifyBalanceChange(address _user) \r\n      internal\r\n    {\r\n        IPlanManager(getModule(\"PLAN\")).updateExpireTime(_user); \r\n    }\r\n    \r\n    /**\r\n     * @dev Controller can change how much referrers are paid.\r\n     * @param _newPercent New percent referrals receive from revenue. 100 == 10%.\r\n    **/\r\n    function changeRefPercent(uint128 _newPercent)\r\n      external\r\n      onlyOwner\r\n    {\r\n        require(_newPercent <= DENOMINATOR, \"new percent cannot be bigger than DENOMINATOR\");\r\n        refPercent = _newPercent;\r\n    }\r\n    \r\n    /**\r\n     * @dev Controller can change how much governance is paid.\r\n     * @param _newPercent New percent that governance will receive from revenue. 100 == 10%.\r\n    **/\r\n    function changeGovPercent(uint128 _newPercent)\r\n      external\r\n      onlyOwner\r\n    {\r\n        require(_newPercent <= DENOMINATOR, \"new percent cannot be bigger than DENOMINATOR\");\r\n        govPercent = _newPercent;\r\n    }\r\n    \r\n    /**\r\n     * @dev Controller can change how much developers are paid.\r\n     * @param _newPercent New percent that devs will receive from revenue. 100 == 10%.\r\n    **/\r\n    function changeDevPercent(uint128 _newPercent)\r\n      external\r\n      onlyOwner\r\n    {\r\n        require(_newPercent <= DENOMINATOR, \"new percent cannot be bigger than DENOMINATOR\");\r\n        devPercent = _newPercent;\r\n    }\r\n    \r\n    /**\r\n     * @dev Toggle whether utilization farming should be on or off.\r\n    **/\r\n    function toggleUF()\r\n      external\r\n      onlyOwner\r\n    {\r\n        ufOn = !ufOn;\r\n    }\r\n    \r\n    /**\r\n     * @dev Toggle whether address is a shield.\r\n    **/\r\n    function toggleShield(address _shield)\r\n      external\r\n      onlyOwner\r\n    {\r\n        arShields[_shield] = !arShields[_shield];\r\n    }\r\n}"
    }
  }
}