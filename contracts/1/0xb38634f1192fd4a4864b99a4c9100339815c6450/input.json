{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/bridge/Inbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./interfaces/IInbox.sol\";\nimport \"./interfaces/IBridge.sol\";\n\nimport \"./Messages.sol\";\nimport \"../libraries/Cloneable.sol\";\nimport \"../libraries/Whitelist.sol\";\n\ncontract Inbox is IInbox, WhitelistConsumer, Cloneable {\n    uint8 internal constant ETH_TRANSFER = 0;\n    uint8 internal constant L2_MSG = 3;\n    uint8 internal constant L1MessageType_L2FundedByL1 = 7;\n    uint8 internal constant L1MessageType_submitRetryableTx = 9;\n\n    uint8 internal constant L2MessageType_unsignedEOATx = 0;\n    uint8 internal constant L2MessageType_unsignedContractTx = 1;\n\n    IBridge public override bridge;\n\n    function initialize(IBridge _bridge, address _whitelist) external {\n        require(address(bridge) == address(0), \"ALREADY_INIT\");\n        bridge = _bridge;\n        WhitelistConsumer.whitelist = _whitelist;\n    }\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\n     * @param messageData Data of the message being sent\n     */\n    function sendL2MessageFromOrigin(bytes calldata messageData)\n        external\n        onlyWhitelisted\n        returns (uint256)\n    {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender == tx.origin, \"origin only\");\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\n        emit InboxMessageDeliveredFromOrigin(msgNum);\n        return msgNum;\n    }\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\n     * @param messageData Data of the message being sent\n     */\n    function sendL2Message(bytes calldata messageData)\n        external\n        override\n        onlyWhitelisted\n        returns (uint256)\n    {\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\n        emit InboxMessageDelivered(msgNum, messageData);\n        return msgNum;\n    }\n\n    function sendL1FundedUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        bytes calldata data\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\n        return\n            _deliverMessage(\n                L1MessageType_L2FundedByL1,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    maxGas,\n                    gasPriceBid,\n                    nonce,\n                    uint256(uint160(bytes20(destAddr))),\n                    msg.value,\n                    data\n                )\n            );\n    }\n\n    function sendL1FundedContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        bytes calldata data\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\n        return\n            _deliverMessage(\n                L1MessageType_L2FundedByL1,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedContractTx,\n                    maxGas,\n                    gasPriceBid,\n                    uint256(uint160(bytes20(destAddr))),\n                    msg.value,\n                    data\n                )\n            );\n    }\n\n    function sendUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external virtual override onlyWhitelisted returns (uint256) {\n        return\n            _deliverMessage(\n                L2_MSG,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    maxGas,\n                    gasPriceBid,\n                    nonce,\n                    uint256(uint160(bytes20(destAddr))),\n                    amount,\n                    data\n                )\n            );\n    }\n\n    function sendContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external virtual override onlyWhitelisted returns (uint256) {\n        return\n            _deliverMessage(\n                L2_MSG,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedContractTx,\n                    maxGas,\n                    gasPriceBid,\n                    uint256(uint160(bytes20(destAddr))),\n                    amount,\n                    data\n                )\n            );\n    }\n\n    function depositEth(uint256 maxSubmissionCost)\n        external\n        payable\n        virtual\n        override\n        onlyWhitelisted\n        returns (uint256)\n    {\n        return\n            _deliverMessage(\n                L1MessageType_submitRetryableTx,\n                msg.sender,\n                abi.encodePacked(\n                    uint256(uint160(bytes20(msg.sender))),\n                    uint256(0),\n                    msg.value,\n                    maxSubmissionCost,\n                    uint256(uint160(bytes20(msg.sender))),\n                    uint256(uint160(bytes20(msg.sender))),\n                    uint256(0),\n                    uint256(0),\n                    uint256(0),\n                    \"\"\n                )\n            );\n    }\n\n    /**\n     * @notice Put an message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\n     * @param destAddr destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param  maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param maxGas Max gas deducted from user's L2 balance to cover L2 execution\n     * @param gasPriceBid price bid for L2 execution\n     * @param data ABI encoded data of L2 message\n     * @return unique id for retryable transaction (keccak256(requestID, uint(0) )\n     */\n    function createRetryableTicket(\n        address destAddr,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\n        return\n            _deliverMessage(\n                L1MessageType_submitRetryableTx,\n                msg.sender,\n                abi.encodePacked(\n                    uint256(uint160(bytes20(destAddr))),\n                    l2CallValue,\n                    msg.value,\n                    maxSubmissionCost,\n                    uint256(uint160(bytes20(excessFeeRefundAddress))),\n                    uint256(uint160(bytes20(callValueRefundAddress))),\n                    maxGas,\n                    gasPriceBid,\n                    data.length,\n                    data\n                )\n            );\n    }\n\n    function _deliverMessage(\n        uint8 _kind,\n        address _sender,\n        bytes memory _messageData\n    ) internal returns (uint256) {\n        uint256 msgNum = deliverToBridge(_kind, _sender, keccak256(_messageData));\n        emit InboxMessageDelivered(msgNum, _messageData);\n        return msgNum;\n    }\n\n    function deliverToBridge(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) internal returns (uint256) {\n        return bridge.deliverMessageToInbox{ value: msg.value }(kind, sender, messageDataHash);\n    }\n}\n"
    },
    "contracts/bridge/Messages.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nlibrary Messages {\n    function messageHash(\n        uint8 kind,\n        address sender,\n        uint256 blockNumber,\n        uint256 timestamp,\n        uint256 inboxSeqNum,\n        uint256 gasPriceL1,\n        bytes32 messageDataHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    kind,\n                    sender,\n                    blockNumber,\n                    timestamp,\n                    inboxSeqNum,\n                    gasPriceL1,\n                    messageDataHash\n                )\n            );\n    }\n\n    function addMessageToInbox(bytes32 inbox, bytes32 message) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(inbox, message));\n    }\n}\n"
    },
    "contracts/bridge/interfaces/IBridge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    );\n\n    function deliverMessageToInbox(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    // These are only callable by the admin\n    function setInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // View functions\n\n    function activeOutbox() external view returns (address);\n\n    function allowedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function messageCount() external view returns (uint256);\n}\n"
    },
    "contracts/bridge/interfaces/IInbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./IBridge.sol\";\nimport \"./IMessageProvider.sol\";\n\ninterface IInbox is IMessageProvider {\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n    function sendUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendL1FundedUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function sendL1FundedContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function createRetryableTicket(\n        address destAddr,\n        uint256 arbTxCallValue,\n        uint256 maxSubmissionCost,\n        address submissionRefundAddress,\n        address valueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\n\n    function bridge() external view returns (IBridge);\n}\n"
    },
    "contracts/bridge/interfaces/IMessageProvider.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IMessageProvider {\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"
    },
    "contracts/libraries/Cloneable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./ICloneable.sol\";\n\ncontract Cloneable is ICloneable {\n    string private constant NOT_CLONE = \"NOT_CLONE\";\n\n    bool private isMasterCopy;\n\n    constructor() public {\n        isMasterCopy = true;\n    }\n\n    function isMaster() external view override returns (bool) {\n        return isMasterCopy;\n    }\n\n    function safeSelfDestruct(address payable dest) internal {\n        require(!isMasterCopy, NOT_CLONE);\n        selfdestruct(dest);\n    }\n}\n"
    },
    "contracts/libraries/ICloneable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface ICloneable {\n    function isMaster() external view returns (bool);\n}\n"
    },
    "contracts/libraries/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nabstract contract WhitelistConsumer {\n    address public whitelist;\n\n    event WhitelistSourceUpdated(address newSource);\n\n    modifier onlyWhitelisted {\n        if (whitelist != address(0)) {\n            require(Whitelist(whitelist).isAllowed(msg.sender), \"NOT_WHITELISTED\");\n        }\n        _;\n    }\n\n    function updateWhitelistSource(address newSource) external {\n        require(msg.sender == whitelist, \"NOT_FROM_LIST\");\n        whitelist = newSource;\n        emit WhitelistSourceUpdated(newSource);\n    }\n}\n\ncontract Whitelist {\n    address public owner;\n    mapping(address => bool) public isAllowed;\n\n    event OwnerUpdated(address newOwner);\n    event WhitelistUpgraded(address newWhitelist, address[] targets);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    function setOwner(address newOwner) external onlyOwner {\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    function setWhitelist(address[] memory user, bool[] memory val) external onlyOwner {\n        require(user.length == val.length, \"INVALID_INPUT\");\n\n        for (uint256 i = 0; i < user.length; i++) {\n            isAllowed[user[i]] = val[i];\n        }\n    }\n\n    // set new whitelist to address(0) to disable whitelist\n    function triggerConsumers(address newWhitelist, address[] memory targets) external onlyOwner {\n        for (uint256 i = 0; i < targets.length; i++) {\n            WhitelistConsumer(targets[i]).updateWhitelistSource(newWhitelist);\n        }\n        emit WhitelistUpgraded(newWhitelist, targets);\n    }\n}\n"
    }
  }
}