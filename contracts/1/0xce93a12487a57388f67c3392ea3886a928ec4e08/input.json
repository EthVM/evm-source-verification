{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Ownable.sol":{"content":"// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\n\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor(){\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n\n\n\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n"},"XIVBettingFlexible.sol":{"content":"// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\npragma abicoder v2;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./XIVInterface.sol\";\n\ncontract XIVBettingFlexible is Ownable{\n    \n    using SafeMath for uint256;\n    address public databaseContractAddress=0x18464e4584759A50CE9FC58eA5997F8B0D1EA1d8;\n    uint256 secondsInADay=24 hours;\n    \n    XIVDatabaseLib.IndexCoin[] tempObjectArray;\n    \n    function betFlexible(uint256 amountOfXIV, uint16 typeOfBet, address _betContractAddress, uint256 betSlabeIndex, uint256 _days) external{\n        // 0-> defi Fixed, 1->defi flexible, 2-> index Fixed and 3-> index flexible 4-> flash fixed 5-> flash flexible\n        require(typeOfBet==1 || typeOfBet==3  || typeOfBet==5, \"Invalid bet Type\");\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        require(!dContract.getExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress),\"you can't place bet using these values.\");\n        require(dContract.isDaysAvailable(_days),\"Day does not exists.\");\n        Token tokenObj = Token(dContract.getXIVTokenContractAddress());\n        require((dContract.getBetFactorLP()).mul(dContract.getTokenStakedAmount())>=\n                        ((tokenObj.balanceOf(databaseContractAddress)).sub(dContract.getTokenStakedAmount())).add(amountOfXIV),\n                        \"Staking Vaults Have EXCEEDED CAPACITY. Please Check Back in 24hrs?\");\n       \n        require(amountOfXIV>=dContract.getMinStakeXIVAmount() && amountOfXIV<=dContract.getMaxStakeXIVAmount(),\"Please enter amount in the specified range\");\n       \n        if(typeOfBet==1 || typeOfBet==5){\n            //defi flexible\n            require((typeOfBet==1?dContract.getDefiCoinsFlexibleMapping(_betContractAddress):\n                                    dContract.getDefiCoinsFixedMapping(_betContractAddress,true)).status,\"The currency is currently disabled.\");\n            require(isFlexibleDaysAvailable(_days,false),\"Day does not exists.\");\n            require(checkTimeForBet(_days),\"Staking time closed for the selected day\");\n            require(dContract.getFlexibleDefiCoinArray().length>betSlabeIndex,\"Day does not exists.\");\n            OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\n            XIVDatabaseLib.BetInfo memory binfo=XIVDatabaseLib.BetInfo({\n                id:dContract.getBetId(),\n                principalAmount:amountOfXIV,\n                amount:amountOfXIV,\n                userAddress:msg.sender,\n                contractAddress:_betContractAddress,\n                betType:typeOfBet,\n                currentPrice:uint256(oWObject.getPrice((typeOfBet==1?dContract.getDefiCoinsFlexibleMapping(_betContractAddress):\n                                    dContract.getDefiCoinsFixedMapping(_betContractAddress,true)).currencySymbol, (typeOfBet==1?dContract.getDefiCoinsFlexibleMapping(_betContractAddress):\n                                    dContract.getDefiCoinsFixedMapping(_betContractAddress,true)).oracleType)),\n                betTimePeriod:_days.mul(1 days),\n                checkpointPercent:dContract.getFlexibleDefiCoinArray()[betSlabeIndex].upDownPercentage,\n                rewardFactor:dContract.getFlexibleDefiCoinArray()[betSlabeIndex].rewardFactor,\n                riskFactor:dContract.getFlexibleDefiCoinArray()[betSlabeIndex].riskFactor,\n                timestamp:block.timestamp,\n                adminCommissionFee:0,\n                status:0\n            });\n            dContract.updateBetArray(binfo);\n            dContract.updateFindBetInArrayUsingBetIdMapping(dContract.getBetId(),dContract.getBetArray().length.sub(1));\n            if(dContract.getBetsAccordingToUserAddress(msg.sender).length==0){\n                dContract.addUserAddressUsedForBetting(msg.sender);\n            }\n            dContract.updateBetAddressesArray(msg.sender,dContract.getBetId());\n            dContract.updateBetId(dContract.getBetId().add(1));\n            uint256 betEndTime=((((binfo.timestamp).div(secondsInADay)).mul(secondsInADay)).add(binfo.betTimePeriod).sub(1));\n            dContract.emitBetDetails(binfo.id,binfo.status,betEndTime);\n        }else if(typeOfBet==3){\n            //index flexible\n            require(isFlexibleDaysAvailable(_days, true),\"Day does not exists.\");\n            require(checkTimeForBet(_days),\"Staking time closed for the selected day\");\n            require(dContract.getFlexibleIndexArray().length>betSlabeIndex,\"Day does not exists.\");\n            XIVDatabaseLib.BetInfo memory binfo=XIVDatabaseLib.BetInfo({\n                id:dContract.getBetId(),\n                principalAmount:amountOfXIV,\n                amount:amountOfXIV,\n                userAddress:msg.sender,\n                contractAddress:address(0),\n                betType:typeOfBet,\n                currentPrice:uint256(calculateIndexValueForFlexibleInternal(dContract.getBetId())),\n                betTimePeriod:_days.mul(1 days),\n                checkpointPercent:dContract.getFlexibleIndexArray()[betSlabeIndex].upDownPercentage,\n                rewardFactor:dContract.getFlexibleIndexArray()[betSlabeIndex].rewardFactor,\n                riskFactor:dContract.getFlexibleIndexArray()[betSlabeIndex].riskFactor,\n                timestamp:block.timestamp,\n                adminCommissionFee:0,\n                status:0\n            });\n            dContract.updateBetArray(binfo);\n            dContract.updateFindBetInArrayUsingBetIdMapping(dContract.getBetId(),dContract.getBetArray().length.sub(1));\n            if(dContract.getBetsAccordingToUserAddress(msg.sender).length==0){\n                dContract.addUserAddressUsedForBetting(msg.sender);\n            }\n            dContract.updateBetAddressesArray(msg.sender,dContract.getBetId());\n            dContract.updateBetId(dContract.getBetId().add(1));\n            uint256 betEndTime=((((binfo.timestamp).div(secondsInADay)).mul(secondsInADay)).add(binfo.betTimePeriod).sub(1));\n            dContract.emitBetDetails(binfo.id,binfo.status,betEndTime);\n        }\n        dContract.transferFromTokens(dContract.getXIVTokenContractAddress(),msg.sender,databaseContractAddress,amountOfXIV);\n        dContract.updateTotalTransactions(dContract.getTotalTransactions().add(amountOfXIV));\n        dContract.updateExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress,true);\n    }\n    function checkTimeForBet(uint256 _days) internal view returns(bool){\n        uint256 currentTime=block.timestamp;\n        uint256 utcMidNight=((block.timestamp.div(secondsInADay)).mul(secondsInADay));\n        if(_days==1){\n            if(((utcMidNight).add(2 hours))>currentTime){\n                return true;\n            }else{\n                return false;\n            }\n        }else if(_days==3){\n            if(((utcMidNight).add(12 hours))>currentTime){\n                return true;\n            }else{\n                return false;\n            }\n        }\n        return true;\n    }\n    function isFlexibleDaysAvailable(uint256 _days, bool isIndex) internal view returns(bool){\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        if(isIndex){\n            for(uint256 i=0;i<dContract.getFlexibleIndexTimePeriodArray().length;i++){\n                if(dContract.getFlexibleIndexTimePeriodArray()[i]._days==_days && dContract.getFlexibleIndexTimePeriodArray()[i].status==true){\n                    return true;\n                }\n            }\n        }else{\n            for(uint256 i=0;i<dContract.getFlexibleDefiCoinTimePeriodArray().length;i++){\n                if(dContract.getFlexibleDefiCoinTimePeriodArray()[i]._days==_days && dContract.getFlexibleDefiCoinTimePeriodArray()[i].status==true){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n   function calculateIndexValueForBetActual() external view returns(uint256){\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        uint256 totalMarketcap;\n        for(uint256 i=0;i<dContract.getAllIndexContractAddressArray().length;i++){\n            Token tObj=Token(dContract.getAllIndexContractAddressArray()[i]);\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getAllIndexContractAddressArray()[i]);\n            if(iCObj.status){\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n            }\n        }\n        return totalMarketcap;\n    }\n    function calculateIndexValueForBetBase() external view returns(uint256){\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        uint256 totalMarketcap;\n        for(uint256 i=0;i<dContract.getAllIndexContractAddressArray().length;i++){\n            Token tObj=Token(dContract.getAllIndexContractAddressArray()[i]);\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getAllIndexContractAddressArray()[i]);\n            if(iCObj.status){\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n            }\n        }\n         if(dContract.getBetBaseIndexValue()==0){\n            return (10**11);\n        }else{\n            if(totalMarketcap>dContract.getBetActualIndexValue()){\n                return (dContract.getBetBaseIndexValue().add((\n                                                     (totalMarketcap.sub(dContract.getBetActualIndexValue()))\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\n            }else if(totalMarketcap<dContract.getBetActualIndexValue()){\n                return (dContract.getBetBaseIndexValue().sub((\n                                                     (dContract.getBetActualIndexValue().sub(totalMarketcap))\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\n            }\n        }\n        return (10**11);\n    }\n    \n    function calculateIndexValueForFlexibleInternal(uint256 _betId) internal returns(uint256){\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        uint256 totalMarketcap;\n        for(uint256 i=0;i<dContract.getAllIndexContractAddressArray().length;i++){\n            Token tObj=Token(dContract.getAllIndexContractAddressArray()[i]);\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getAllIndexContractAddressArray()[i]);\n            if(iCObj.status){\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n                dContract.updateBetIndexForFlexibleArray(_betId,iCObj);\n            }\n        }\n        XIVDatabaseLib.BetPriceHistory memory bPHObj=XIVDatabaseLib.BetPriceHistory({\n            baseIndexValue:dContract.getBetBaseIndexValue()==0?10**11:dContract.getBetBaseIndexValue(),\n            actualIndexValue:totalMarketcap\n        });\n        dContract.updateBetPriceHistoryFlexibleMapping(_betId,bPHObj);\n        if(dContract.getBetBaseIndexValue()==0){\n            dContract.updateBetBaseIndexValue(10**11);\n        }else{\n            if(totalMarketcap>dContract.getBetActualIndexValue()){\n                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue().add((\n                                                     (totalMarketcap.sub(dContract.getBetActualIndexValue()))\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\n            }else if(totalMarketcap<dContract.getBetActualIndexValue()){\n                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue().sub((\n                                                     (dContract.getBetActualIndexValue().sub(totalMarketcap))\n                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\n            }\n        }\n        dContract.updateBetActualIndexValue(totalMarketcap);\n        return totalMarketcap;\n    }\n    \n    function claimBet(uint256 userBetId) external{\n        // 0-> defi Fixed, 1->defi flexible, 2-> index Fixed and 3-> index flexible\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        uint256 index=dContract.getFindBetInArrayUsingBetIdMapping(userBetId);\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n        require((bObject.status==0) \n                || (bObject.status==1)\n                || (bObject.status==2),\"bet is closed.\");\n        if(bObject.status==0){\n           if(block.timestamp.sub(bObject.timestamp) > 6 days){\n                plentyFinal(index,7);\n                return;\n            }else if(block.timestamp.sub(bObject.timestamp) > 5 days){\n                plentyFinal(index,6);\n                return;\n            }else if(block.timestamp.sub(bObject.timestamp) > 4 days){\n                plentyFinal(index,5);\n                return;\n            }else if(block.timestamp.sub(bObject.timestamp) > 3 days){\n                plentyFinal(index,4);\n                return;\n            }else if(block.timestamp.sub(bObject.timestamp) > 2 days){\n                plentyFinal(index,3);\n                return;\n            }else if(block.timestamp.sub(bObject.timestamp) > 1 days){\n                plentyFinal(index,2);\n                return;\n            }else{\n                plentyFinal(index,1);\n                return;\n            }\n        }else{\n            claimBetFinal(index);\n        }\n    }\n    \n    function claimBetFinal(uint256 index) internal{\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n        require(bObject.userAddress==msg.sender,\"Authentication failure\");\n        require(bObject.amount!=0,\"Your bet amount is 0\");\n        dContract.transferTokens(dContract.getXIVTokenContractAddress(),msg.sender,(bObject.amount)); \n        bObject.amount=0; // return 3 times\n        dContract.updateBetArrayIndex(bObject,index);\n    }\n    function plentyFinal(uint256 index, uint256 _days) internal{\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n        uint256 plentyPercentage;\n        if(bObject.betTimePeriod==1 days){\n            plentyPercentage=dContract.getPlentyOneDayPercentage();\n        }else if(bObject.betTimePeriod==3 days){\n            plentyPercentage=dContract.getPlentyThreeDayPercentage(_days);\n        }else if(bObject.betTimePeriod==7 days){\n            plentyPercentage=dContract.getPlentySevenDayPercentage(_days);\n        }\n        if(plentyPercentage!=0){\n            uint256 plentyAmount=((plentyPercentage.mul(bObject.amount)).div(10**4));\n            uint256 userAmount=(bObject.amount).sub(plentyAmount);\n            if(userAmount!=0){\n                dContract.transferTokens(dContract.getXIVTokenContractAddress(),msg.sender,userAmount); \n            }\n            bObject.status=3;\n            bObject.amount=0;\n            \n            XIVDatabaseLib.IncentiveInfo memory iInfo= XIVDatabaseLib.IncentiveInfo({\n                tillInvestmentId:dContract.getInvestmentId().sub(1),\n                incentiveAmount:plentyAmount,\n                totalAmountStakedAtIncentiveTime:dContract.getTokenStakedAmount()\n            }); \n            dContract.updateIncentiveMapping(dContract.getSlotId(),iInfo);\n            dContract.updateSlotId(dContract.getSlotId().add(1));\n            dContract.updateBetArrayIndex(bObject,index);\n            dContract.updateExistingBetCheckMapping(bObject.userAddress,bObject.betType,bObject.contractAddress,false);\n        }\n    }\n    \n    function marketCapValue(XIVDatabaseLib.IndexCoin memory iCObj,Token tObj) internal view returns(uint256){\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\n         if((keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked(\"ETH\"))) || (keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked(\"BTC\")))){\n            return ((((oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\n                                        /* .mul(iCObj.contributionPercentage)*/)\n                                        .div(10**2)));\n        }else{\n            return (((tObj.totalSupply().mul(oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\n                                /*.mul(iCObj.contributionPercentage)*/)\n                                .div((10**tObj.decimals()).mul(10**2))));\n        }\n    }\n    function getPieChartValue() external view returns(XIVDatabaseLib.IndexCoin[] memory){\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        uint256 totalMarketcap;\n        XIVDatabaseLib.IndexCoin[] memory tempIndexArray=new XIVDatabaseLib.IndexCoin[](dContract.getAllIndexContractAddressArray().length);\n        for(uint256 i=0;i<dContract.getAllIndexContractAddressArray().length;i++){\n            Token tObj=Token(dContract.getAllIndexContractAddressArray()[i]);\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getAllIndexContractAddressArray()[i]);\n            if(iCObj.status){\n                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n            }\n        }\n        for(uint256 i=0;i<dContract.getAllIndexContractAddressArray().length;i++){\n            Token tObj=Token(dContract.getAllIndexContractAddressArray()[i]);\n            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getAllIndexContractAddressArray()[i]);\n            if(iCObj.status){\n                iCObj.contributionPercentage=(marketCapValue(iCObj,tObj).mul(10**4))/totalMarketcap;\n                tempIndexArray[i]=iCObj;\n            }\n        }\n        return tempIndexArray;\n    }\n    \n    function updateDatabaseAddress(address _databaseContractAddress) external onlyOwner{\n        databaseContractAddress=_databaseContractAddress;\n    }\n}\n"},"XIVDatabaseLib.sol":{"content":"// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\npragma abicoder v2;\n\nlibrary XIVDatabaseLib{\n    // deficoin struct for deficoinmappings..\n    struct DefiCoin{\n        uint16 oracleType;\n        string currencySymbol;\n        bool status;\n    }\n    struct TimePeriod{\n        uint256 _days;\n        bool status;\n    }\n     struct FlexibleInfo{\n        uint256 id;\n        uint16 upDownPercentage; //10**2\n        uint16 riskFactor;       //10**2\n        uint16 rewardFactor;     //10**2\n        bool status;\n    }\n    struct FixedInfo{\n        uint256 id;\n        uint256 daysCount;// integer value\n        uint16 upDownPercentage; //10**2\n        uint16 riskFactor;       //10**2\n        uint16 rewardFactor;     //10**2\n        bool status;\n    }\n    struct IndexCoin{\n        uint16 oracleType;\n        string currencySymbol;\n        address contractAddress;\n        bool status;\n        uint256 contributionPercentage; //10**2\n    }\n    struct BetPriceHistory{\n        uint256 baseIndexValue;\n        uint256 actualIndexValue;\n    }\n    struct LPLockedInfo{\n        uint256 lockedTimeStamp;\n        uint256 amountLocked;\n    }\n    struct StakingInfo{\n        uint256 investmentId;\n        uint256 stakeAmount;\n    }\n    struct IncentiveInfo{\n        uint256 tillInvestmentId;\n        uint256 incentiveAmount;\n        uint256 totalAmountStakedAtIncentiveTime;\n    }\n    struct BetInfo{\n        uint256 id;\n        uint256 principalAmount;\n        uint256 amount;\n        address userAddress;\n        address contractAddress;\n        uint256 betType; //\n        uint256 currentPrice;\n        uint256 timestamp;\n        uint256 betTimePeriod;\n        uint16 checkpointPercent;\n        uint16 rewardFactor;\n        uint16 riskFactor;\n        uint256 adminCommissionFee;\n        uint16 status; // 0->bet active, 1->bet won, 2->bet lost, 3-> withdraw before result\n    }\n}\n"},"XIVInterface.sol":{"content":"// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\npragma abicoder v2;\n\nimport \"./XIVDatabaseLib.sol\";\n\ninterface Token{\n    function decimals() external view returns(uint256);\n    function symbol() external view returns(string memory);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n}\n\n\ninterface OracleWrapper{\n    function getPrice(string calldata currencySymbol,uint256 oracleType) external view returns (uint256);\n}\ninterface DatabaseContract{\n    function transferTokens(address contractAddress,address userAddress,uint256 amount) external;\n    function transferFromTokens(address contractAddress,address fromAddress, address toAddress,uint256 amount) external;\n    function getTokensStaked(address userAddress) external view returns(uint256);\n    function updateTokensStaked(address userAddress, uint256 amount) external;\n    function getTokenStakedAmount() external view returns(uint256);\n    function updateTokenStakedAmount(uint256 _tokenStakedAmount) external;\n    function getBetId() external view returns(uint256);\n    function updateBetId(uint256 _userBetId) external;\n    function updateBetArray(XIVDatabaseLib.BetInfo memory bObject) external;\n    function getBetArray() external view returns(XIVDatabaseLib.BetInfo[] memory);\n    function getFindBetInArrayUsingBetIdMapping(uint256 _betid) external view returns(uint256);\n    function updateFindBetInArrayUsingBetIdMapping(uint256 _betid, uint256 value) external;\n    function updateUserStakedAddress(address _address) external;\n    function updateUserStakedAddress(address[] memory _userStakedAddress) external;\n    function getUserStakedAddress() external view returns(address[] memory);\n    function getDefiCoinsFixedMapping(address _betContractAddress,bool isFlashVault) external view returns(XIVDatabaseLib.DefiCoin memory);\n    function getDefiCoinsFlexibleMapping(address _betContractAddress) external view returns(XIVDatabaseLib.DefiCoin memory);\n    function getFlexibleDefiCoinArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\n    function getFlexibleIndexArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\n    function updateBetArrayIndex(XIVDatabaseLib.BetInfo memory bObject, uint256 index) external;\n    function updateBetIndexForFixedArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\n    function updateBetBaseIndexValue(uint256 _betBaseIndexValueFixed) external;\n    function getBetBaseIndexValue() external view returns(uint256);\n    function updateBetPriceHistoryFixedMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\n    function updateBetActualIndexValue(uint256 _betActualIndexValueFixed) external;\n    function getBetActualIndexValue() external view returns(uint256);\n    function getBetIndexForFixedArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\n    function getBetPriceHistoryFixedMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\n    function getXIVTokenContractAddress() external view returns(address);\n    function getAllIndexContractAddressArray() external view returns(address[] memory);\n    function getDefiCoinIndexMapping(address _ContractAddress) external view returns(XIVDatabaseLib.IndexCoin memory);\n    \n    function updateBetIndexForFlexibleArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\n    function getBetIndexForFlexibleArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\n    function updateBetPriceHistoryFlexibleMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\n    function getBetPriceHistoryFlexibleMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\n    \n    function getOracleWrapperContractAddress() external view returns(address);\n    function getPlentyOneDayPercentage() external view returns(uint256);\n    function getPlentyThreeDayPercentage(uint256 _days) external view returns(uint256);\n    function getPlentySevenDayPercentage(uint256 _days) external view returns(uint256);\n    function getBetsAccordingToUserAddress(address userAddress) external view returns(uint256[] memory);\n    function updateBetAddressesArray(address userAddress, uint256 _betId) external;\n    function getRewardGeneratedAmount() external view returns(uint256);\n    function updateRewardGeneratedAmount(uint256 _rewardGeneratedAmount) external;\n    function addUserAddressUsedForBetting(address userAddress) external;\n    function getUserAddressUsedForBetting() external view returns(address[] memory);\n    function getFixedDefiCoinArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\n    function getFixedDefiIndexArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\n    function getMaxStakeXIVAmount() external view returns(uint256);\n    function getMinStakeXIVAmount() external view returns(uint256);\n    function getBetFactorLP() external view returns(uint256);\n    function updateActualAmountStakedByUser(address userAddress, uint256 amount) external;\n    function getActualAmountStakedByUser(address userAddress) external view returns(uint256);\n    function isDaysAvailable(uint256 _days) external view returns(bool);\n    function updateExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress,bool status) external;\n    function getExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress) external view returns(bool);\n    function updateTotalTransactions(uint256 _totalTransactions) external;\n    function getTotalTransactions() external view returns(uint256);\n    function getFlexibleDefiCoinTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\n    function getFlexibleIndexTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\n    function getMinLPvalue() external view returns(uint256);\n    function getLockingPeriodForLPMapping(address userAddress) external view returns(XIVDatabaseLib.LPLockedInfo memory);\n    function updateLockingPeriodForLPMapping(address userAddress, uint256 _amountLocked, uint256 _lockedTimeStamp) external;\n    function getStakingInfoMapping(address userAddress) external view returns(XIVDatabaseLib.StakingInfo[] memory);\n    function updateStakingInfoMapping(address userAddress, XIVDatabaseLib.StakingInfo memory sInfo) external;\n    function getInvestmentId() external view returns(uint256);\n    function updateInvestmentId(uint256 _investmentId) external;\n    function getSlotExecutionId() external view returns(uint256);\n    function updateSlotExecutionId(uint256 _slotExecutionId) external;\n    function getSlotId() external view returns(uint256);\n    function updateSlotId(uint256 _slotId) external;\n    function updateIncentiveMapping(uint256 _slotId, XIVDatabaseLib.IncentiveInfo memory iInfo) external;\n    function getIncentiveMapping(uint256 _slotId) external view returns(XIVDatabaseLib.IncentiveInfo[] memory);\n    function emitBetDetails(uint256  betId, uint256  status, uint256  betEndTime) external;\n    function emitLPEvent(uint256 typeOfLP, address userAddress, uint256 amount, uint256 timestamp) external ;\n    function updateIsStakeMapping(address userAddress,bool isStake) external;\n    function getIsStakeMapping(address userAddress) external view returns(bool);\n    \n}\n"}}}