{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ReflexerView.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\npragma experimental ABIEncoderV2;\n\n\n\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"\");\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n\n\n\n\nabstract contract IGetSafes {\n    function getSafesAsc(address manager, address guy) external virtual view returns (uint[] memory ids, address[] memory safes, bytes32[] memory collateralTypes);\n    function getSafesDesc(address manager, address guy) external virtual view returns (uint[] memory ids, address[] memory safes, bytes32[] memory collateralTypes);\n\n}\n\n\n\n\n\nabstract contract ISAFEEngine {\n\n    struct SAFE {\n        uint256 lockedCollateral;\n        uint256 generatedDebt;\n    }\n\n    struct CollateralType {\n        // Total debt issued for this specific collateral type\n        uint256 debtAmount;        // [wad]\n        // Accumulator for interest accrued on this collateral type\n        uint256 accumulatedRate;   // [ray]\n        // Floor price at which a SAFE is allowed to generate debt\n        uint256 safetyPrice;       // [ray]\n        // Maximum amount of debt that can be generated with this collateral type\n        uint256 debtCeiling;       // [rad]\n        // Minimum amount of debt that must be generated by a SAFE using this collateral\n        uint256 debtFloor;         // [rad]\n        // Price at which a SAFE gets liquidated\n        uint256 liquidationPrice;  // [ray]\n    }\n\n    mapping (bytes32 => mapping (address => SAFE )) public safes;\n    mapping (bytes32 => CollateralType) public collateralTypes;\n    mapping (bytes32 => mapping (address => uint)) public tokenCollateral;\n\n    function safeRights(address, address) virtual public view returns (uint);\n    function coinBalance(address) virtual public view returns (uint);\n    function modifySAFECollateralization(bytes32, address, address, address, int, int) virtual public;\n    function approveSAFEModification(address) virtual public;\n    function transferInternalCoins(address, address, uint) virtual public;\n    function transferSAFECollateralAndDebt(bytes32, address, address, int, int) virtual public;\n}\n\n\n\n\n\nabstract contract ISAFEManager {\n\n    function lastSAFEID(address) virtual public view returns (uint);\n    function safeCan(address, uint, address) virtual public view returns (uint);\n    function collateralTypes(uint) virtual public view returns (bytes32);\n    function ownsSAFE(uint) virtual public view returns (address);\n    function safes(uint) virtual public view returns (address);\n    function safeEngine() virtual public view returns (address);\n    function openSAFE(bytes32, address) virtual public returns (uint);\n    function transferSAFEOwnership(uint, address) virtual public;\n    function allowSAFE(uint, address, uint) virtual public;\n    function handlerAllowed(address, uint) virtual public;\n    function modifySAFECollateralization(uint, int, int) virtual public;\n    function transferCollateral(uint, address, uint) virtual public;\n    function transferInternalCoins(uint, address, uint) virtual public;\n    function quitSystem(uint, address) virtual public;\n    function enterSystem(address, uint) virtual public;\n    function moveSAFE(uint, uint) virtual public;\n    function safeCount(address) virtual public view returns (uint);\n    function safei() virtual public view returns (uint);\n    function protectSAFE(uint, address, address) virtual public;\n}\n\n\n\n\n\nabstract contract IOracleRelayer {\n    struct CollateralType {\n        address orcl;\n        uint256 safetyCRatio;\n    }\n\n    mapping (bytes32 => CollateralType) public collateralTypes;\n\n    function redemptionPrice() public virtual returns (uint256);\n    uint256 public redemptionRate;\n}\n\n\n\n\n\nabstract contract IMedianOracle {\n    function read() external virtual view returns (uint256);\n}\n\n\n\n\n\nabstract contract ITaxCollector {\n    struct CollateralType {\n        uint256 stabilityFee;\n        uint256 updateTime;\n    }\n\n    mapping (bytes32 => CollateralType) public collateralTypes;\n\n    function taxSingle(bytes32) public virtual returns (uint);\n}\n\n\n\n\n\n\n\n\n\n\ncontract ReflexerView is DSMath {\n    // mainnet\n    address public constant GET_SAFES_ADDR = 0xdf4BC9aA98cC8eCd90Ba2BEe73aD4a1a9C8d202B;\n    address public constant MANAGER_ADDR = 0xEfe0B4cA532769a3AE758fD82E1426a03A94F185;\n    address public constant SAFE_ENGINE_ADDRESS = 0xCC88a9d330da1133Df3A7bD823B95e52511A6962;\n    address public constant ORACLE_RELAYER_ADDRESS = 0x4ed9C0dCa0479bC64d8f4EB3007126D5791f7851;\n    address public constant MEDIAN_ORACLE_ADDRESS = 0x92dC9b16be52De059279916c1eF810877f85F960;\n    address public constant TAX_COLLECTOR_ADDRESS = 0xcDB05aEda142a1B0D6044C09C64e4226c1a281EB;\n\n    // kovan\n    // address public constant GET_SAFES_ADDR = 0x702dcf4a8C3bBBd243477D5704fc45F2762D3826;\n    // address public constant MANAGER_ADDR = 0x807C8eCb73d9c8203d2b1369E678098B9370F2EA;\n    // address public constant SAFE_ENGINE_ADDRESS = 0x7f63fE955fFF8EA474d990f1Fc8979f2C650edbE;\n    // address public constant ORACLE_RELAYER_ADDRESS = 0xE5Ae4E49bEA485B5E5172EE6b1F99243cB15225c;\n    // address public constant MEDIAN_ORACLE_ADDRESS = 0x82bEAd00751EFA3286c9Dd17e4Ea2570916B3944;\n    // address public constant TAX_COLLECTOR_ADDRESS = 0xc1a94C5ad9FCD79b03F79B34d8C0B0C8192fdc16;\n\n    struct SafeInfo {\n        uint256 safeId;\n        uint256 coll;\n        uint256 debt;\n        address safeAddr;\n        bytes32 collType;\n    }\n\n    struct CollInfo {\n        uint256 debtCeiling;\n        uint256 currDebtAmount;\n        uint256 currRate;\n        uint256 dust;\n        uint256 safetyPrice;\n        uint256 liqPrice;\n        uint256 assetPrice;\n        uint256 liqRatio;\n        uint256 stabilityFee;\n    }\n\n    struct RaiInfo {\n        uint256 redemptionPrice;\n        uint256 currRaiPrice;\n        uint256 redemptionRate;\n    }\n\n    function getCollateralTypeInfo(bytes32 _collType)\n        public\n        returns (CollInfo memory collInfo)\n    {\n        (\n            uint256 debtAmount,\n            uint256 accumulatedRates,\n            uint256 safetyPrice,\n            uint256 debtCeiling,\n            uint256 debtFloor,\n            uint256 liquidationPrice\n        ) = ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\n\n        (, uint liqRatio) = IOracleRelayer(ORACLE_RELAYER_ADDRESS).collateralTypes(_collType);\n\n        (uint stabilityFee,) = ITaxCollector(TAX_COLLECTOR_ADDRESS).collateralTypes(_collType);\n\n\n        collInfo = CollInfo({\n            debtCeiling: debtCeiling,\n            currDebtAmount: debtAmount,\n            currRate: accumulatedRates,\n            dust: debtFloor,\n            safetyPrice: safetyPrice,\n            liqPrice: liquidationPrice,\n            assetPrice: getPrice(_collType),\n            liqRatio: liqRatio,\n            stabilityFee: stabilityFee\n        });\n    }\n\n    function getCollAndRaiInfo(bytes32 _collType)\n        public\n        returns (CollInfo memory collInfo, RaiInfo memory raiInfo) {\n            collInfo = getCollateralTypeInfo(_collType);\n            raiInfo = getRaiInfo();\n        }\n\n    function getPrice(bytes32 _collType) public returns (uint256) {\n        (, uint256 safetyCRatio) =\n            IOracleRelayer(ORACLE_RELAYER_ADDRESS).collateralTypes(_collType);\n        (, , uint256 safetyPrice, , , ) =\n            ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\n\n        uint256 redemptionPrice = IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionPrice();\n\n        return rmul(rmul(safetyPrice, redemptionPrice), safetyCRatio);\n    }\n\n    function getRaiInfo() public returns (RaiInfo memory raiInfo) {\n        uint medianPrice = 0;\n        \n        try IMedianOracle(MEDIAN_ORACLE_ADDRESS).read() returns (uint p) {\n            medianPrice = p;\n        } catch(bytes memory) {}\n        \n        raiInfo = RaiInfo({\n            redemptionPrice: IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionPrice(),\n            currRaiPrice: IMedianOracle(MEDIAN_ORACLE_ADDRESS).read(),\n            redemptionRate: IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionRate()\n        });\n    }\n\n    function getSafeInfo(uint256 _safeId) public view returns (SafeInfo memory safeInfo) {\n        address safeAddr = ISAFEManager(MANAGER_ADDR).safes(_safeId);\n        bytes32 collType = ISAFEManager(MANAGER_ADDR).collateralTypes(_safeId);\n\n        (uint256 coll, uint256 debt) = ISAFEEngine(SAFE_ENGINE_ADDRESS).safes(collType, safeAddr);\n\n        safeInfo = SafeInfo({\n            safeId: _safeId,\n            coll: coll,\n            debt: debt,\n            safeAddr: safeAddr,\n            collType: collType\n        });\n    }\n\n    function getUserSafes(address _user)\n        public\n        view\n        returns (\n            uint256[] memory ids,\n            address[] memory safes,\n            bytes32[] memory collateralTypes\n        )\n    {\n        return IGetSafes(GET_SAFES_ADDR).getSafesAsc(MANAGER_ADDR, _user);\n    }\n\n    function getUserSafesFullInfo(address _user) public view returns (SafeInfo[] memory safeInfos) {\n        (uint256[] memory ids, , ) = getUserSafes(_user);\n\n        safeInfos = new SafeInfo[](ids.length);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            safeInfos[i] = getSafeInfo(ids[i]);\n        }\n    }\n\n    function getFullInfo(address _user, bytes32 _collType)\n        public\n        returns (\n            CollInfo memory collInfo,\n            RaiInfo memory raiInfo,\n            SafeInfo[] memory safeInfos\n        )\n    {\n        collInfo = getCollateralTypeInfo(_collType);\n        raiInfo = getRaiInfo();\n        safeInfos = getUserSafesFullInfo(_user);\n    }\n}\n"}}}