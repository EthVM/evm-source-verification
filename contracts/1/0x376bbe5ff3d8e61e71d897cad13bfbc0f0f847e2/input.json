{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"mytest/staking.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\ninterface I {\n\tfunction balanceOf(address a) external view returns (uint);\n\tfunction transfer(address recipient, uint amount) external returns (bool);\n\tfunction transferFrom(address sender,address recipient, uint amount) external returns (bool);\n\tfunction totalSupply() external view returns (uint);\n//\tfunction getLastVoted(address account) external view returns (uint lastVoted); function changeAddress(address acc,address acc1) external;\n\tfunction getRewards(address a,uint rewToClaim) external returns(bool);\n\tfunction contributions(address a) external view returns(uint);\n//\tfunction providerMigr(address a,uint lpShare,uint lastClaim,uint lastEpoch,uint tknAmount,bool status) external;function lockerMigr(address a,uint amount,uint lockUpTo) external;\n}\n\n// did change it a small bit: founders are unable to stake generic liquidity on top of their share, or it will be too expensive to sload\n// for that they will have to use another address\n\ncontract StakingContract {\n\tuint128 private _foundingETHDeposited;\n\tuint128 private _foundingLPtokensMinted;\n\taddress private _tokenETHLP;\n\tbool private _init;\n\tuint88 private _genLPtokens;\n\n\tstruct LPProvider {uint32 lastClaim; uint16 lastEpoch; bool founder; uint128 tknAmount; uint128 lpShare;uint128 lockedAmount;uint128 lockUpTo;}\n\tstruct TokenLocker {uint128 amount;uint128 lockUpTo;}\n\n\tbytes32[] private _epochs;\n\tbytes32[] private _founderEpochs;\n\n\tmapping(address => LPProvider) private _ps;\n\tmapping(address => TokenLocker) private _ls;\n//\tmapping(address => address) public newAddresses;\n//\tmapping(address => bool) private _takenNew;\n\n\tfunction init(uint foundingETH, address tkn) public {\n\t\trequire(msg.sender == 0x901628CF11454AFF335770e8a9407CccAb3675BE && _init == false);\n\t\t_foundingETHDeposited = uint128(foundingETH);\n\t\t_foundingLPtokensMinted = uint128(I(tkn).balanceOf(address(this)));\n\t\t_tokenETHLP = tkn;\n\t\t_init = true;\n\t\t_createEpoch(0,false);\n\t\t_createEpoch(1e24,true);\n\t}\n\n\tfunction claimFounderStatus() public {\n\t\tuint ethContributed = I(0x901628CF11454AFF335770e8a9407CccAb3675BE).contributions(msg.sender);\n\t\trequire(ethContributed > 0);\n\t\trequire(_init == true && _ps[msg.sender].founder == false);\n\t\t_ps[msg.sender].founder = true;\n\t\tuint foundingETH = _foundingETHDeposited;\n\t\tuint lpShare = _foundingLPtokensMinted*ethContributed/foundingETH;\n\t\tuint tknAmount = ethContributed*1e24/foundingETH;\n\t\t_ps[msg.sender].lpShare = uint128(lpShare);\n\t\t_ps[msg.sender].tknAmount = uint128(tknAmount);\n\t\t_ps[msg.sender].lastClaim = 1264e4;\n\t}\n\n\tfunction unstakeLp(bool ok,uint amount) public {\n\t\t(uint lastClaim,bool status,uint tknAmount,uint lpShare,uint lockedAmount) = getProvider(msg.sender);\n\t\trequire(lpShare-lockedAmount >= amount && ok == true);\n\t\tif (lastClaim != block.number) {_getRewards(msg.sender);}\n\t\t_ps[msg.sender].lpShare = uint128(lpShare - amount);\n\t\tuint toSubtract = tknAmount*amount/lpShare; // not an array of deposits. if a provider stakes and then stakes again, and then unstakes - he loses share as if he staked only once at lowest price he had\n\t\t_ps[msg.sender].tknAmount = uint128(tknAmount-toSubtract);\n\t\tbytes32 epoch; uint length;\n\t\tif (status == true) {length = _founderEpochs.length; epoch = _founderEpochs[length-1];}\n\t\telse{length = _epochs.length; epoch = _epochs[length-1];_genLPtokens -= uint88(amount/1e10);}\n\t\t(uint80 eBlock,uint96 eAmount,) = _extractEpoch(epoch);\n\t\teAmount -= uint96(toSubtract);\n\t\t_storeEpoch(eBlock,eAmount,status,length);\n\t\tI(_tokenETHLP).transfer(address(msg.sender), amount);\n\t}\n\n\tfunction getRewards() public {_getRewards(msg.sender);}\n\n\tfunction _getRewards(address a) internal {\n\t\tuint lastClaim = _ps[a].lastClaim;\n\t\tuint epochToClaim = _ps[a].lastEpoch;\n\t\tbool status = _ps[a].founder;\n\t\tuint tknAmount = _ps[a].tknAmount;\n\t\trequire(block.number>lastClaim);\n\t\t_ps[a].lastClaim = uint32(block.number);\n\t\tuint rate = _getRate();\n\t\tuint eBlock; uint eAmount; uint eEnd; bytes32 epoch; uint length; uint toClaim;\n\t\tif (status) {length = _founderEpochs.length;} else {length = _epochs.length;}\n\t\tif (length>0 && epochToClaim < length-1) {\n\t\t\tfor (uint i = epochToClaim; i<length;i++) {\n\t\t\t\tif (status) {epoch = _founderEpochs[i];} else {epoch = _epochs[i];}\n\t\t\t\t(eBlock,eAmount,eEnd) = _extractEpoch(epoch);\n\t\t\t\tif(i == length-1) {eBlock = lastClaim;}\n\t\t\t\ttoClaim += _computeRewards(eBlock,eAmount,eEnd,tknAmount,rate);\n\t\t\t}\n\t\t\t_ps[a].lastEpoch = uint16(length-1);\n\t\t} else {\n\t\t\tif(status){epoch = _founderEpochs[length-1];} else {epoch = _epochs[length-1];}\n\t\t\teAmount = uint96(bytes12(epoch << 80)); toClaim = _computeRewards(lastClaim,eAmount,block.number,tknAmount,rate);\n\t\t}\n\t\tbool success = I(0x3E6AE87673424B1a1111E7F8180294B57be36476).getRewards(a, toClaim); require(success == true);\n\t}\n\n\tfunction _getRate() internal view returns(uint){uint rate = 84e15; uint halver = block.number/1e7;if (halver>1) {for (uint i=1;i<halver;i++) {rate=rate*3/4;}}return rate;}\n\n\tfunction _computeRewards(uint eBlock, uint eAmount, uint eEnd, uint tknAmount, uint rate) internal view returns(uint){\n\t\tif(eEnd==0){eEnd = block.number;} uint blocks = eEnd - eBlock; return (blocks*tknAmount*rate/eAmount);\n\t}\n\n// this function has to be expensive as an alert of something fishy just in case\n// metamask has to somehow provide more info about a transaction\n/*\tfunction newAddress(address a) public {\n\t\trequire(_takenNew[a] == false && _ps[a].lpShare == 0 && _ls[a].amount == 0);\n\t\tif(_ps[msg.sender].lockedAmount>0||_ls[msg.sender].amount>0){require(_isContract(msg.sender) == false);}\n\t\t_takenNew[a] = true;\n\t\tnewAddresses[msg.sender] = a;\n\t}\n// nobody should trust dapp interface. maybe a function like this should not be provided through dapp at all\n\tfunction changeAddress(address ad) public { // while user can confirm newAddress by public method, still has to enter the same address second time\n\t\taddress S = msg.sender;\taddress a = newAddresses[S];\n\t\trequire(a != address(0) && a == ad && a != msg.sender && block.number - 172800 > I(0xaE9564269B75f67510Bf20a512632869e3d42217).getLastVoted(S));\n\t\tif (_ps[S].lpShare > 0) {\n\t\t\t_ps[a].lastClaim = _ps[S].lastClaim;_ps[a].lastEpoch = _ps[S].lastEpoch;_ps[a].founder = _ps[S].founder;_ps[a].tknAmount = _ps[S].tknAmount;\n\t\t\t_ps[a].lpShare = _ps[S].lpShare;_ps[a].lockUpTo = _ps[S].lockUpTo;_ps[a].lockedAmount = _ps[S].lockedAmount;delete _ps[S];\n\t\t}\n\t\tif (_ls[S].amount > 0) {_ls[a].amount=_ls[S].amount;_ls[a].lockUpTo=_ls[S].lockUpTo;delete _ls[S];}\n\t}*/\n\n\tfunction lockFor6Months(bool ok, address tkn, uint amount) public {\n\t\trequire(ok==true && amount>0);\n\t\tif(tkn ==_tokenETHLP) {\n\t\t\trequire(_ps[msg.sender].lpShare-_ps[msg.sender].lockedAmount>=amount); _ps[msg.sender].lockUpTo=uint128(block.number+1e6);_ps[msg.sender].lockedAmount+=uint128(amount);\t\n\t\t}\n\t\tif(tkn == 0x1565616E3994353482Eb032f7583469F5e0bcBEC) {\n\t\t\trequire(I(tkn).balanceOf(msg.sender)>=amount);\n\t\t\t_ls[msg.sender].lockUpTo=uint128(block.number+1e6);\n\t\t\t_ls[msg.sender].amount+=uint128(amount);\n\t\t\tI(tkn).transferFrom(msg.sender,address(this),amount);\n\t\t}\n\t}\n\n\tfunction unlock() public {\n\t\tif (_ps[msg.sender].lockedAmount > 0 && block.number>=_ps[msg.sender].lockUpTo) {_ps[msg.sender].lockedAmount = 0;}\n\t\tuint amount = _ls[msg.sender].amount;\n\t\tif (amount > 0 && block.number>=_ls[msg.sender].lockUpTo) {I(0x1565616E3994353482Eb032f7583469F5e0bcBEC).transfer(msg.sender,amount);_ls[msg.sender].amount = 0;}\n\t}\n\n\tfunction stake(uint amount) public {\n\t\taddress tkn = _tokenETHLP;\n\t\tuint length = _epochs.length;\n\t\tuint lastClaim = _ps[msg.sender].lastClaim;\n\t\trequire(_ps[msg.sender].founder==false && I(tkn).balanceOf(msg.sender)>=amount);\n\t\tI(tkn).transferFrom(msg.sender,address(this),amount);\n\t\tif(lastClaim==0){_ps[msg.sender].lastClaim = uint32(block.number);}\n\t\telse if (lastClaim != block.number) {_getRewards(msg.sender);}\n\t\tbytes32 epoch = _epochs[length-1];\n\t\t(uint80 eBlock,uint96 eAmount,) = _extractEpoch(epoch);\n\t\teAmount += uint96(amount);\n\t\t_storeEpoch(eBlock,eAmount,false,length);\n\t\t_ps[msg.sender].lastEpoch = uint16(_epochs.length);\n\t\tuint genLPtokens = _genLPtokens*1e10;\n\t\tgenLPtokens += amount;\n\t\t_genLPtokens = uint88(genLPtokens/1e10);\n\t\tuint share = amount*I(0x1565616E3994353482Eb032f7583469F5e0bcBEC).balanceOf(tkn)/genLPtokens;\n\t\t_ps[msg.sender].tknAmount += uint128(share);\n\t\t_ps[msg.sender].lpShare += uint128(amount);\n\t}\n\n\tfunction _extractEpoch(bytes32 epoch) internal pure returns (uint80,uint96,uint80){\n\t\tuint80 eBlock = uint80(bytes10(epoch));\n\t\tuint96 eAmount = uint96(bytes12(epoch << 80));\n\t\tuint80 eEnd = uint80(bytes10(epoch << 176));\n\t\treturn (eBlock,eAmount,eEnd);\n\t}\n \n\tfunction _storeEpoch(uint80 eBlock, uint96 eAmount, bool founder, uint length) internal {\n\t\tuint eEnd;\n\t\tif(block.number-80640>eBlock){eEnd = block.number-1;}// so an epoch can be bigger than 2 weeks, it's normal behavior and even desirable\n\t\tbytes memory by = abi.encodePacked(eBlock,eAmount,uint80(eEnd));\n\t\tbytes32 epoch; assembly {epoch := mload(add(by, 32))}\n\t\tif (founder) {_founderEpochs[length-1] = epoch;} else {_epochs[length-1] = epoch;}\n\t\tif (eEnd>0) {_createEpoch(eAmount,founder);}\n\t}\n\n\tfunction _createEpoch(uint amount, bool founder) internal {\n\t\tbytes memory by = abi.encodePacked(uint80(block.number),uint96(amount),uint80(0));\n\t\tbytes32 epoch; assembly {epoch := mload(add(by, 32))}\n\t\tif (founder == true){_founderEpochs.push(epoch);} else {_epochs.push(epoch);}\n\t}\n\n/*\tfunction migrate(address contr,address tkn,uint amount) public lock {//can support any amount of bridges\n\t\tif (tkn == _tokenETHLP) {\n\t\t\t(uint lastClaim,bool status,uint tknAmount,uint lpShare,uint lockedAmount) = getProvider(msg.sender);\n\t\t\tif (lastClaim != block.number) {_getRewards(msg.sender);}\n\t\t\trequire(lpShare-lockedAmount >= amount);\n\t\t\t_ps[msg.sender].lpShare = uint128(lpShare - amount);\n\t\t\tuint toSubtract = amount*tknAmount/lpShare;\n\t\t\t_ps[msg.sender].tknAmount = uint128(tknAmount-toSubtract);\n\t\t\tuint length; bytes32 epoch;\n\t\t\tif (status == true){length = _founderEpochs.length; epoch = _founderEpochs[length-1];}\n\t\t\telse{length = _epochs.length; epoch = _epochs[length-1]; _genLPtokens -= uint88(amount/1e10);}\n\t\t\t(uint80 eBlock, uint96 eAmount,) = _extractEpoch(epoch);\n\t\t\teAmount -= uint96(toSubtract);\n\t\t\t_storeEpoch(eBlock,eAmount,status,length);\n\t\t\tI(tkn).transfer(contr, amount);\n\t\t\tI(contr).provider(msg.sender,amount,_ps[msg.sender].lastClaim,_ps[msg.sender].lastEpoch,toSubtract,status);\n\t\t}\n\t\tif (tkn == 0x1565616E3994353482Eb032f7583469F5e0bcBEC) {\n\t\t\tuint lockedAmount = _ls[msg.sender].amount;\n\t\t\trequire(lockedAmount >= amount);\n\t\t\tI(tkn).transfer(contr, amount);\n\t\t\t_ls[msg.sender].amount = uint128(lockedAmount-amount);\n\t\t\tI(contr).locker(msg.sender,amount,_ls[msg.sender].lockUpTo);\n\t\t}\n\t}*/\n// VIEW FUNCTIONS ==================================================\n\tfunction getVoter(address a) external view returns (uint128,uint128,uint128,uint128,uint128,uint128) {\n\t\treturn (_ps[a].tknAmount,_ps[a].lpShare,_ps[a].lockedAmount,_ps[a].lockUpTo,_ls[a].amount,_ls[a].lockUpTo);\n\t}\n\n\tfunction getProvider(address a)public view returns(uint,bool,uint,uint,uint){return(_ps[a].lastClaim,_ps[a].founder,_ps[a].tknAmount,_ps[a].lpShare,_ps[a].lockedAmount);}\n}"}}}