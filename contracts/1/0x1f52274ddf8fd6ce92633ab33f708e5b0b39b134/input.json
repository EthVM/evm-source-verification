{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Untitled.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-12-16\n*/\n\npragma solidity ^0.7.0;\n\n\n// SPDX-License-Identifier: MIT\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n        uint256 c = add(a,m);\n        uint256 d = sub(c,1);\n        return mul(div(d,m),m);\n    }\n}\n\ncontract SecretSanta {\n\t\n\tusing SafeMath for uint;\n\t\n\taddress payable public owner;\n\tuint public amountMinimumToPlay;\n\tuint public fee;\n\tuint public basepercent = 100;\n\n\t// Thursday 24 December 2020 04:20:00\n\tuint public christmaseve = 1608783600;\n\t\n\t// Friday 25 December 2020 04:20:00\n\tuint public christmasday = 1608870000;\n\n\tstruct Santa {\n\t\taddress payable wallet;\n\t\tuint amount;\n\t}\n\t\n\tSanta[] santas;\n\tSanta[] assignedSantas;\n\t\n\tmapping(address => uint) allSantas;\n\n\tevent NewSanta(\n\t\tuint indexed _now,\n\t\taddress indexed _wallet,\n\t\tuint _amount\n\t);\n\tevent AssignSantas(\n\t\tuint indexed _now,\n\t\tuint _overallSantas,\n\t\tuint _overallFunds\n\t);\n\tevent PlayFinish(\n\t\tuint indexed _now,\n\t\tbool _finish\n\t);\n\t\n\tconstructor(\n\t\tuint amountMinimumToPlayArg\n\t) {\n\t\tamountMinimumToPlay = amountMinimumToPlayArg;\n\t\towner = msg.sender; \n\t}\n\t\n\t/* Deposit a gift for someone and become a sekret vitalik ! */ \n\tfunction enter() payable external {\n\t\trequire(msg.value >= amountMinimumToPlay, 'gift the min amount to become a secret santa');\n        require(allSantas[msg.sender] == uint(0x0), 'you can only enter once');\n        require(block.timestamp <= christmaseve, 'you are to late to the christmas party!');\n        \n\t\tuint fee_amount = calcFee(msg.value);\n\t\tuint value = msg.value.sub(fee_amount);\n\n\t\tSanta memory santa = Santa({\n\t\t\twallet: msg.sender, \n\t\t\tamount: value\n\t\t});\n\t\t\n\t\tsantas.push(santa);\n\t\tallSantas[msg.sender] = value;\n\n\t\temit NewSanta(block.timestamp, msg.sender, msg.value);\n\t}\n\t\n\n\t/* When the right time has come anyone can call this function\n\t\t- This function will pay out all assigned santas !\n\t\t- Will selfdestruct the contract and transfer the fees to sekretvitalik.eth \n\t*/ \n\tfunction finishPlay() public payable {\n\t\trequire(block.timestamp >= christmasday, 'you can not finish before christmasday');\n\t\trequire(assignedSantas.length > 2, 'there must be min 2 Santas assigned before you can finish');\n\n\t\tfor(uint i = 0; i < assignedSantas.length; i++) {\n\t\t\tSanta  memory recipient =  assignedSantas[i];\n\t\t\trecipient.wallet.transfer(recipient.amount);\n\t\t}\n\t\t\n\t\temit PlayFinish(\n\t\t\tblock.timestamp,\n\t\t\ttrue\n\t\t);\n\t\t\n\t\tdestruct();\n\t}\n\t\n\t\n\t/* Public view functions */\n\n\tfunction getOverallSantas() view public returns (uint) {\n\t\treturn santas.length;\n\t}\n\t\n\tfunction getOverallFunds() public view returns (uint overallFunds) {\n\t\toverallFunds = 0;\n\t\t\n\t\tfor(uint i = 0; i < santas.length; i++) {\n\t\t\toverallFunds += santas[i].amount;\n\t\t}\n\t\t\n\t\treturn overallFunds;\n\t}\n\t\n\tfunction checkPlayer(address payable playerAddress) public view returns (bool checkResult, uint checkAmount) {\n\t\tcheckResult = false;\n\t\tcheckAmount = 0;\n\t\t\n\t\tfor(uint i = 0; i < santas.length; i++) {\n\t\t\tif(santas[i].wallet == playerAddress) {\n\t\t\t\tcheckResult = true;\n\t\t\t\tif (msg.sender == owner || msg.sender == santas[i].wallet) {\n\t\t\t\t\tcheckAmount = santas[i].amount;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (checkResult, checkAmount);\n\t\t\n\t}\n\t\n\tfunction checkSender() public view returns (bool checkResult, uint checkAmount) {\n\t\treturn checkPlayer(msg.sender);\n\t}\n\t\n\t/* Owner only functions */\n\t\n\tfunction setOwner (address payable newOwner) external onlyOwner {\n\t\towner = newOwner;\n\t}\n\t\n\t// Just in case there is a problem and we need to change dates */\n\tfunction setchristmasday (uint newDay) external onlyOwner {\n\t    christmasday = newDay; \n\t}\n\n\t// Just in case there is a problem and we need to change dates\n    function setchristmaseve (uint newDay) external onlyOwner {\n\t    christmaseve = newDay; \n\t}\n    \n    function assignSantas() external onlyOwner  {\n\t\trequire(santas.length > 2);\n\t\t\n\t\tSanta[] memory shuffledSantas = shuffleSantas();\n\t\t\n\t\tfor(uint i = 0; i < shuffledSantas.length; i++) {\n\t\t\tSanta memory santa = shuffledSantas[i];\n\t\t\tSanta memory recipient;\n\t\t\t\n\t\t\tif(i != shuffledSantas.length - 1) {\n\t\t\t\trecipient = shuffledSantas[i + 1];\n\t\t\t} else {\n\t\t\t\trecipient = shuffledSantas[0];\n\t\t\t}\n\t\t\t\n\t\t\tassignedSantas.push( Santa(recipient.wallet, santa.amount) );\n\t\t}\n\t\t\n\t}\n\n\t/* Internal functions */\n\t\n\tfunction shuffleSantas() internal view returns(Santa[] memory shuffledSantas) {\n\t\tshuffledSantas = santas;\n\t\tuint n = shuffledSantas.length;\n\t\t\n\t\trequire(n > 2);\n\t\t\n\t\tuint i;\n\t\tSanta memory tmpSanta;\n\t\t\n\t\twhile(n > 0) {\n\t\t\ti = random(block.timestamp, n--);\n\t\t\ttmpSanta = shuffledSantas[n];\n\t\t\tshuffledSantas[n] = shuffledSantas[i];\n\t\t\tshuffledSantas[i] = tmpSanta;\n\t\t}\n\t\t\n\t\treturn shuffledSantas;\n\t}\n\n    function random(uint seed, uint n) internal view returns (uint256) {\n       uint256(\n            keccak256(\n                abi.encode(\n                    block.difficulty, \n                    block.timestamp, \n                    tx.origin,\n\t\t\t\t\tblockhash(block.number),\n\t\t\t\t\tseed,\n\t\t\t\t\tn\n                    )\n                )\n            );\n    }\n\n\tfunction calcFee(uint _value) internal view returns(uint) {\n\t\tuint roundValue = SafeMath.ceil(_value, basepercent);\n        uint onePercent = SafeMath.div(SafeMath.mul(roundValue, basepercent), 10000);\n        return onePercent;\n\t}\n\n\tfunction destruct() onlyOwner internal {\n\t\tselfdestruct(owner);\n\t}\n\n\tmodifier onlyOwner {\n        require(msg.sender == owner, \n        'only manager can call this function');\n        _;\n    }\n\n}"
    }
  }
}