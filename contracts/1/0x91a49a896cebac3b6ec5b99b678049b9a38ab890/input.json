{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"KyberRateQueryHelper.sol":{"content":"pragma solidity 0.6.6;\r\n\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function decimals() external view returns (uint8 digits);\r\n\r\n    function totalSupply() external view returns (uint256 supply);\r\n}\r\n\r\n\r\ninterface IConversionRates {\r\n    \r\n    function getRate(\r\n        IERC20 token,\r\n        uint256 currentBlockNumber,\r\n        bool buy,\r\n        uint256 qty\r\n    ) external view returns(uint256);\r\n}\r\n\r\n\r\ninterface IKyberReserve {\r\n    function getConversionRate(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcQty,\r\n        uint256 blockNumber\r\n    ) external view returns (uint256);\r\n    \r\n    function conversionRatesContract() external view returns (IConversionRates);\r\n    function sanityRatesContract() external view returns (IKyberSanity);\r\n}\r\n\r\n\r\ninterface IKyberSanity {\r\n    function getSanityRate(IERC20 src, IERC20 dest) external view returns (uint256);\r\n}\r\n\r\ncontract Utils5 {\r\n    IERC20 internal constant ETH_TOKEN_ADDRESS = IERC20(\r\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n    );\r\n    uint256 internal constant PRECISION = (10**18);\r\n    uint256 internal constant MAX_QTY = (10**28); // 10B tokens\r\n    uint256 internal constant MAX_RATE = (PRECISION * 10**7); // up to 10M tokens per eth\r\n    uint256 internal constant MAX_DECIMALS = 18;\r\n    uint256 internal constant ETH_DECIMALS = 18;\r\n    uint256 constant BPS = 10000; // Basic Price Steps. 1 step = 0.01%\r\n    uint256 internal constant MAX_ALLOWANCE = uint256(-1); // token.approve inifinite\r\n\r\n    mapping(IERC20 => uint256) internal decimals;\r\n\r\n    function getUpdateDecimals(IERC20 token) internal returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint256 tokenDecimals = decimals[token];\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if (tokenDecimals == 0) {\r\n            tokenDecimals = token.decimals();\r\n            decimals[token] = tokenDecimals;\r\n        }\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function setDecimals(IERC20 token) internal {\r\n        if (decimals[token] != 0) return; //already set\r\n\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            decimals[token] = ETH_DECIMALS;\r\n        } else {\r\n            decimals[token] = token.decimals();\r\n        }\r\n    }\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(IERC20 token, address user) internal view returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            return user.balance;\r\n        } else {\r\n            return token.balanceOf(user);\r\n        }\r\n    }\r\n\r\n    function getDecimals(IERC20 token) internal view returns (uint256) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint256 tokenDecimals = decimals[token];\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if (tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDestAmount(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 srcAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(\r\n        IERC20 src,\r\n        IERC20 dest,\r\n        uint256 destAmount,\r\n        uint256 rate\r\n    ) internal view returns (uint256) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcDstQty(\r\n        uint256 srcQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(srcQty <= MAX_QTY, \"srcQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(\r\n        uint256 dstQty,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        require(dstQty <= MAX_QTY, \"dstQty > MAX_QTY\");\r\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint256 numerator;\r\n        uint256 denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n\r\n    function calcRateFromQty(\r\n        uint256 srcAmount,\r\n        uint256 destAmount,\r\n        uint256 srcDecimals,\r\n        uint256 dstDecimals\r\n    ) internal pure returns (uint256) {\r\n        require(srcAmount <= MAX_QTY, \"srcAmount > MAX_QTY\");\r\n        require(destAmount <= MAX_QTY, \"destAmount > MAX_QTY\");\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION) / ((10**(dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\r\n            return ((destAmount * PRECISION * (10**(srcDecimals - dstDecimals))) / srcAmount);\r\n        }\r\n    }\r\n\r\n    function minOf (uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n}\r\n\r\ncontract KyberRateQueryHelper is Utils5 {\r\n    \r\n    function getRateWithEth(IKyberReserve reserve, IERC20 token, uint256 weiAmount) public view \r\n        returns(uint256 reserveSellRate, uint256 reserveBuyRate, uint256 pricingSellRate, uint256 pricingBuyRate, uint256 tweiAmount) \r\n    {\r\n        IConversionRates conversionRate = reserve.conversionRatesContract();\r\n        \r\n        reserveBuyRate = IKyberReserve(reserve).getConversionRate(\r\n                    ETH_TOKEN_ADDRESS,\r\n                    token,\r\n                    weiAmount,\r\n                    block.number\r\n                );\r\n\r\n        pricingBuyRate = conversionRate.getRate(token, block.number, true, weiAmount);\r\n        \r\n        tweiAmount = calcDestAmount(\r\n            ETH_TOKEN_ADDRESS, \r\n            token, \r\n            weiAmount, \r\n            reserveBuyRate == 0 ? pricingBuyRate : reserveBuyRate);\r\n        \r\n        reserveSellRate = reserve.getConversionRate(\r\n                    token,\r\n                    ETH_TOKEN_ADDRESS,\r\n                    tweiAmount,\r\n                    block.number\r\n                );\r\n                \r\n        pricingSellRate = conversionRate.getRate(token, block.number, false, tweiAmount);\r\n    }\r\n\r\n    function getRatesWithEth(IKyberReserve reserve, IERC20[] calldata tokens, uint256 weiAmount) external view \r\n        returns(uint256[] memory sellRates, uint256[] memory buyRates)\r\n    {\r\n        uint256 numTokens = tokens.length;\r\n     \r\n        buyRates = new uint256[](numTokens);\r\n        sellRates = new uint256[](numTokens);\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            (buyRates[i], sellRates[i], , , ) = getRateWithEth(reserve, tokens[i], weiAmount);\r\n        }   \r\n    }\r\n    \r\n    function getRateWithToken(IKyberReserve reserve, IERC20 token, uint256 tweiAmount) public view \r\n        returns(uint256 reserveBuyRate, uint256 reserveSellRate, uint256 pricingBuyRate, uint256 pricingSellRate, uint256 weiAmount) \r\n    {\r\n        IConversionRates conversionRate = reserve.conversionRatesContract();\r\n        \r\n        reserveSellRate = IKyberReserve(reserve).getConversionRate(\r\n                token,\r\n                ETH_TOKEN_ADDRESS,\r\n                tweiAmount,\r\n                block.number\r\n            );\r\n        \r\n        pricingSellRate = conversionRate.getRate(token, block.number, false, tweiAmount);\r\n\r\n        weiAmount = calcDestAmount(\r\n            token, \r\n            ETH_TOKEN_ADDRESS, \r\n            tweiAmount,\r\n            reserveSellRate == 0 ? pricingSellRate : reserveSellRate);\r\n        \r\n        reserveBuyRate = IKyberReserve(reserve).getConversionRate(\r\n                ETH_TOKEN_ADDRESS,\r\n                token,\r\n                weiAmount,\r\n                block.number\r\n            );\r\n        \r\n        pricingBuyRate = conversionRate.getRate(token, block.number, true, weiAmount);\r\n    }\r\n\r\n    function getRatesWithToken(IKyberReserve reserve, IERC20[] calldata tokens, uint256 tweiAmount) external view \r\n        returns(uint256[] memory sellRates, uint256[] memory buyRates)\r\n    {\r\n        uint256 numTokens = tokens.length;\r\n     \r\n        buyRates = new uint256[](numTokens);\r\n        sellRates = new uint256[](numTokens);\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            (buyRates[i], sellRates[i], ,  , ) = getRateWithEth(reserve, tokens[i], tweiAmount);\r\n        }   \r\n    }\r\n    \r\n    function getReserveRates(IKyberReserve reserve, IERC20[] calldata srcs, IERC20[] calldata dests)\r\n        external view returns(uint256[] memory pricingRates, uint256[] memory sanityRates)\r\n    {\r\n        require(srcs.length == dests.length, \"srcs length != dests\");\r\n\r\n        pricingRates = new uint256[](srcs.length);\r\n        sanityRates = new uint256[](srcs.length);\r\n\r\n        for (uint256 i = 0 ; i < srcs.length ; i++) {\r\n            \r\n            if (reserve.sanityRatesContract() != IKyberSanity(0x0)) {\r\n                sanityRates[i] = reserve.sanityRatesContract().getSanityRate(srcs[i], dests[i]);\r\n            }\r\n            \r\n            pricingRates[i] = reserve.conversionRatesContract().getRate(\r\n                srcs[i] == ETH_TOKEN_ADDRESS ? dests[i] : srcs[i],\r\n                block.number,\r\n                srcs[i] == ETH_TOKEN_ADDRESS ? true : false,\r\n                0);\r\n        }\r\n\r\n        return (pricingRates,sanityRates);\r\n    }\r\n}"}}}