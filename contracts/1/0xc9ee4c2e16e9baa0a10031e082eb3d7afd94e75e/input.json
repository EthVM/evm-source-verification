{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ChainLinkOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity 0.7.4;\r\n\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\ninterface ITrollbox {\r\n    function withdrawWinnings(uint voterId) external;\r\n    function updateAccount(uint voterId, uint tournamentId, uint roundId) external;\r\n    function isSynced(uint voterId, uint tournamentId, uint roundId) external view returns (bool);\r\n    function roundAlreadyResolved(uint tournamentId, uint roundId) external view returns (bool);\r\n    function resolveRound(uint tournamentId, uint roundId, uint winningOption) external;\r\n    function getCurrentRoundId(uint tournamentId) external returns (uint);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ChainLinkOracle {\r\n\r\n    struct Proposal {\r\n        uint id;\r\n        uint time;\r\n        bool confirmed;\r\n        uint roundId;\r\n        uint winnerIndex;\r\n        uint challengeWinnerIndex;\r\n        address challenger;\r\n    }\r\n\r\n    mapping (bytes32 => address) public feedMap; // ticker symbol => price aggregator address\r\n    mapping (bytes32 => int) public prices; // symbol => price\r\n    mapping (uint => Proposal) public proposals;\r\n\r\n    address public management;\r\n    ITrollbox public trollbox;\r\n    IERC20 public token;\r\n\r\n    int constant public PRECISION = 1000000;\r\n    uint public numProposals = 0;\r\n    uint public challengeDeposit = 0;\r\n    uint public challengePeriodSeconds = 60 * 60 * 24;\r\n    uint public tournamentId = 1;\r\n\r\n    bytes32[] public tickerSymbols;\r\n\r\n    // mgmt events\r\n    event FeedUpdated(bytes32 indexed key, address indexed feedAddr);\r\n    event ManagementUpdated(address oldManagement, address newManagement);\r\n    event DepositUpdated(uint oldDeposit, uint newDeposit);\r\n    event ChallengePeriodUpdated(uint oldPeriod, uint newPeriod);\r\n    event TickerSymbolsUpdated(bytes32[] oldKeys, bytes32[] newKeys);\r\n\r\n    // winner events\r\n    event WinnerProposed(uint indexed roundId, uint indexed proposalId, uint winnerIndex);\r\n    event WinnerConfirmed(uint indexed roundId, uint indexed proposalId, int[] prices);\r\n\r\n    // challenger events\r\n    event ChallengeMade(uint indexed proposalId, address indexed challenger, uint indexed claimedWinner);\r\n    event ChallengerSlashed(uint indexed proposalId, address indexed challenger, uint indexed slashAmount);\r\n    event ChallengerVindicated(uint indexed proposalId, address indexed challenger);\r\n\r\n    modifier managementOnly() {\r\n        require (msg.sender == management, 'Only management may call this');\r\n        _;\r\n    }\r\n\r\n    modifier latestProposalConfirmed() {\r\n        require (proposals[numProposals].confirmed == true || numProposals == 0, 'Unconfirmed proposal present');\r\n        _;\r\n    }\r\n\r\n    constructor(address mgmt, address trollboxAddr, address tokenAddr, uint tournament, bytes32[] memory initialSymbols, int[] memory initialPrices) {\r\n        management = mgmt;\r\n        trollbox = ITrollbox(trollboxAddr);\r\n        token = IERC20(tokenAddr);\r\n        tournamentId = tournament;\r\n        tickerSymbols = initialSymbols;\r\n        setPricesInternal(initialPrices);\r\n    }\r\n\r\n    function setManagement(address newMgmt) public managementOnly {\r\n        address oldMgmt = management;\r\n        management =  newMgmt;\r\n        emit ManagementUpdated(oldMgmt, newMgmt);\r\n    }\r\n\r\n    function setChallengeDeposit(uint newDeposit) public managementOnly latestProposalConfirmed {\r\n        uint oldDeposit = challengeDeposit;\r\n        challengeDeposit = newDeposit;\r\n        emit DepositUpdated(oldDeposit, newDeposit);\r\n    }\r\n\r\n    function setChallengePeriod(uint newPeriod) public managementOnly latestProposalConfirmed {\r\n        uint oldPeriod = challengePeriodSeconds;\r\n        challengePeriodSeconds = newPeriod;\r\n        emit ChallengePeriodUpdated(oldPeriod, newPeriod);\r\n    }\r\n\r\n    function setPricesInternal(int[] memory newPrices) internal {\r\n        for (uint i = 0; i < tickerSymbols.length; i++) {\r\n            prices[tickerSymbols[i]] = newPrices[i];\r\n        }\r\n    }\r\n\r\n    function getTickerSymbols() public view returns (bytes32[] memory) {\r\n        return tickerSymbols;\r\n    }\r\n\r\n    function setTickerSymbols(bytes32[] memory newKeys) public managementOnly latestProposalConfirmed {\r\n        bytes32[] memory oldKeys = tickerSymbols;\r\n        tickerSymbols = newKeys;\r\n        emit TickerSymbolsUpdated(oldKeys, newKeys);\r\n    }\r\n\r\n    function addFeed(bytes32 key, address feedAddr) public managementOnly {\r\n        feedMap[key] = feedAddr;\r\n        emit FeedUpdated(key, feedAddr);\r\n    }\r\n\r\n    function getWinner() public view returns (int[] memory, uint) {\r\n        int256 maxPriceDiff = -100 * PRECISION;\r\n        uint winnerIndex = 0;\r\n        int[] memory pricesLocal = new int[](tickerSymbols.length);\r\n        for (uint i = 0; i < tickerSymbols.length; i++) {\r\n            bytes32 key = tickerSymbols[i];\r\n            int priceBefore = prices[key];\r\n            AggregatorV3Interface chainlink = AggregatorV3Interface(feedMap[key]);\r\n            (,int256 priceNow,,,) = chainlink.latestRoundData();\r\n            pricesLocal[i] = priceNow;\r\n            int256 priceDiff = ((priceNow - priceBefore) * PRECISION) / priceBefore;\r\n            if (priceDiff > maxPriceDiff) {\r\n                maxPriceDiff = priceDiff;\r\n                // add one to index to account for 1 based indexing on Trollbox contract\r\n                winnerIndex = i + 1;\r\n            }\r\n        }\r\n        return (pricesLocal, winnerIndex);\r\n    }\r\n\r\n    function proposeWinner(uint roundId) public latestProposalConfirmed {\r\n        require(trollbox.roundAlreadyResolved(tournamentId, roundId) == false, 'Round already resolve');\r\n        require(trollbox.getCurrentRoundId(tournamentId) > roundId + 1, 'Round not ready to resolve');\r\n        Proposal storage proposal = proposals[++numProposals];\r\n        proposal.id = numProposals;\r\n        proposal.time = block.timestamp;\r\n        proposal.roundId = roundId;\r\n        (int[] memory newPrices, uint winnerIndex) = getWinner();\r\n        setPricesInternal(newPrices);\r\n        proposal.winnerIndex = winnerIndex;\r\n        emit WinnerProposed(roundId, numProposals, proposal.winnerIndex);\r\n    }\r\n\r\n    function challengeWinner(uint proposalId, uint claimedWinner) public {\r\n        token.transferFrom(msg.sender, address(this), challengeDeposit);\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.challenger == address(0), 'Proposal already challenged');\r\n        require(claimedWinner != proposal.winnerIndex, 'Must claim different winner than proposed winner');\r\n        require(block.timestamp - proposal.time < challengePeriodSeconds, 'Challenge period has passed');\r\n        proposal.challenger = msg.sender;\r\n        proposal.challengeWinnerIndex = claimedWinner;\r\n        emit ChallengeMade(proposalId, msg.sender, claimedWinner);\r\n    }\r\n\r\n    function confirmWinnerUnchallenged(uint proposalId) public {\r\n        Proposal memory proposal = proposals[proposalId];\r\n        require(proposal.challenger == address(0), 'Proposal has been challenged');\r\n        require(block.timestamp - proposal.time > challengePeriodSeconds, 'Challenge period has not passed');\r\n        confirmWinnerInternal(proposalId);\r\n    }\r\n\r\n    function confirmWinnerChallenged(uint proposalId, uint chosenWinnerIndex, int[] memory localPrices) public managementOnly {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.challenger != address(0), 'Proposal has not been challenged');\r\n        require(chosenWinnerIndex <= tickerSymbols.length, 'Winner index out of range');\r\n        require(chosenWinnerIndex > 0, 'Winner index must be positive');\r\n        require(localPrices.length == tickerSymbols.length, 'Must specify prices for all ticker symbols');\r\n\r\n        // set official winner\r\n        proposal.winnerIndex = chosenWinnerIndex;\r\n\r\n        // record prices\r\n        for (uint i = 0; i < tickerSymbols.length; i++) {\r\n            prices[tickerSymbols[i]] = localPrices[i];\r\n        }\r\n\r\n        confirmWinnerInternal(proposalId);\r\n\r\n        // if challenger failed, slash their deposit\r\n        if (chosenWinnerIndex != proposal.challengeWinnerIndex) {\r\n            token.transfer(address(0), challengeDeposit);\r\n            emit ChallengerSlashed(proposalId, proposal.challenger, challengeDeposit);\r\n        // else send it back to them\r\n        } else {\r\n            token.transfer(proposal.challenger, challengeDeposit);\r\n            emit ChallengerVindicated(proposalId, proposal.challenger);\r\n        }\r\n    }\r\n\r\n    function confirmWinnerInternal(uint proposalId) internal {\r\n        Proposal storage proposal = proposals[proposalId];\r\n        require(proposal.id == proposalId, 'Invalid proposalId');\r\n        require(proposal.confirmed == false, 'Already confirmed proposal');\r\n        proposal.confirmed = true;\r\n        int[] memory pricesLocal = new int[](tickerSymbols.length);\r\n        for (uint i = 0; i < tickerSymbols.length; i++) {\r\n            pricesLocal[i] = prices[tickerSymbols[i]];\r\n        }\r\n        emit WinnerConfirmed(proposal.roundId, proposalId, pricesLocal);\r\n        trollbox.resolveRound(tournamentId, proposal.roundId, proposal.winnerIndex);\r\n    }\r\n\r\n}"
    }
  }
}