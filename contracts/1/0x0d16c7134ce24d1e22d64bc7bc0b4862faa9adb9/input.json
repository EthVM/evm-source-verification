{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ConnectRefinance.sol":{"content":"pragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface TokenInterface {\r\n    function approve(address, uint256) external;\r\n    function transfer(address, uint) external;\r\n    function transferFrom(address, address, uint) external;\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n    function balanceOf(address) external view returns (uint);\r\n    function decimals() external view returns (uint);\r\n}\r\n\r\n// Compound Helpers\r\ninterface CTokenInterface {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n}\r\n\r\ninterface CETHInterface {\r\n    function mint() external payable;\r\n    function repayBorrow() external payable;\r\n}\r\n\r\ninterface InstaMapping {\r\n    function cTokenMapping(address) external view returns (address);\r\n    function gemJoinMapping(bytes32) external view returns (address);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n}\r\n// End Compound Helpers\r\n\r\n// Aave v1 Helpers\r\ninterface AaveV1Interface {\r\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external payable;\r\n    function redeemUnderlying(\r\n        address _reserve,\r\n        address payable _user,\r\n        uint256 _amount,\r\n        uint256 _aTokenBalanceAfterRedeem\r\n    ) external;\r\n    \r\n    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external;\r\n    function getUserReserveData(address _reserve, address _user) external view returns (\r\n        uint256 currentATokenBalance,\r\n        uint256 currentBorrowBalance,\r\n        uint256 principalBorrowBalance,\r\n        uint256 borrowRateMode,\r\n        uint256 borrowRate,\r\n        uint256 liquidityRate,\r\n        uint256 originationFee,\r\n        uint256 variableBorrowIndex,\r\n        uint256 lastUpdateTimestamp,\r\n        bool usageAsCollateralEnabled\r\n    );\r\n    function borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode) external;\r\n    function repay(address _reserve, uint256 _amount, address payable _onBehalfOf) external payable;\r\n}\r\n\r\ninterface AaveV1ProviderInterface {\r\n    function getLendingPool() external view returns (address);\r\n    function getLendingPoolCore() external view returns (address);\r\n}\r\n\r\ninterface AaveV1CoreInterface {\r\n    function getReserveATokenAddress(address _reserve) external view returns (address);\r\n}\r\n\r\ninterface ATokenV1Interface {\r\n    function redeem(uint256 _amount) external;\r\n    function balanceOf(address _user) external view returns(uint256);\r\n    function principalBalanceOf(address _user) external view returns(uint256);\r\n\r\n    function allowance(address, address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n// End Aave v1 Helpers\r\n\r\n// Aave v2 Helpers\r\ninterface AaveV2Interface {\r\n    function deposit(address _asset, uint256 _amount, address _onBehalfOf, uint16 _referralCode) external;\r\n    function withdraw(address _asset, uint256 _amount, address _to) external;\r\n    function borrow(\r\n        address _asset,\r\n        uint256 _amount,\r\n        uint256 _interestRateMode,\r\n        uint16 _referralCode,\r\n        address _onBehalfOf\r\n    ) external;\r\n    function repay(address _asset, uint256 _amount, uint256 _rateMode, address _onBehalfOf) external;\r\n    function setUserUseReserveAsCollateral(address _asset, bool _useAsCollateral) external;\r\n}\r\n\r\ninterface AaveV2LendingPoolProviderInterface {\r\n    function getLendingPool() external view returns (address);\r\n}\r\n\r\n// Aave Protocol Data Provider\r\ninterface AaveV2DataProviderInterface {\r\n    function getUserReserveData(address _asset, address _user) external view returns (\r\n        uint256 currentATokenBalance,\r\n        uint256 currentStableDebt,\r\n        uint256 currentVariableDebt,\r\n        uint256 principalStableDebt,\r\n        uint256 scaledVariableDebt,\r\n        uint256 stableBorrowRate,\r\n        uint256 liquidityRate,\r\n        uint40 stableRateLastUpdated,\r\n        bool usageAsCollateralEnabled\r\n    );\r\n}\r\n// End Aave v2 Helpers\r\n\r\ncontract DSMath {\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"sub-overflow\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n}\r\n\r\ncontract Helpers is DSMath {\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    enum Protocol {\r\n        Aave,\r\n        AaveV2,\r\n        Compound\r\n    }\r\n\r\n    address payable constant feeCollector = 0xb1DC62EC38E6E3857a887210C38418E4A17Da5B2;\r\n\r\n    /**\r\n     * @dev Return ethereum address\r\n     */\r\n    function getEthAddr() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return Weth address\r\n    */\r\n    function getWethAddr() internal pure returns (address) {\r\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // Mainnet WETH Address\r\n        // return 0xd0A1E359811322d97991E03f863a0C30C2cF029C; // Kovan WETH Address\r\n    }\r\n\r\n    /**\r\n     * @dev Connector Details.\r\n    */\r\n    function connectorID() public pure returns(uint _type, uint _id) {\r\n        (_type, _id) = (1, 73);\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaDApp Mapping Address\r\n     */\r\n    function getMappingAddr() internal pure returns (address) {\r\n        return 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88; // InstaMapping Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return Compound Comptroller Address\r\n     */\r\n    function getComptrollerAddress() internal pure returns (address) {\r\n        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n    /**\r\n     * @dev get Aave Provider\r\n    */\r\n    function getAaveProvider() internal pure returns (AaveV1ProviderInterface) {\r\n        return AaveV1ProviderInterface(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8); //mainnet\r\n        // return AaveV1ProviderInterface(0x506B0B2CF20FAA8f38a4E2B524EE43e1f4458Cc5); //kovan\r\n    }\r\n\r\n    /**\r\n     * @dev get Aave Lending Pool Provider\r\n    */\r\n    function getAaveV2Provider() internal pure returns (AaveV2LendingPoolProviderInterface) {\r\n        return AaveV2LendingPoolProviderInterface(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5); //mainnet\r\n        // return AaveV2LendingPoolProviderInterface(0x652B2937Efd0B5beA1c8d54293FC1289672AFC6b); //kovan\r\n    }\r\n\r\n    /**\r\n     * @dev get Aave Protocol Data Provider\r\n    */\r\n    function getAaveV2DataProvider() internal pure returns (AaveV2DataProviderInterface) {\r\n        return AaveV2DataProviderInterface(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d); //mainnet\r\n        // return AaveV2DataProviderInterface(0x744C1aaA95232EeF8A9994C4E0b3a89659D9AB79); //kovan\r\n    }\r\n\r\n    /**\r\n     * @dev get Referral Code\r\n    */\r\n    function getReferralCode() internal pure returns (uint16) {\r\n        return 3228;\r\n    }\r\n\r\n    function getWithdrawBalance(AaveV1Interface aave, address token) internal view returns (uint bal) {\r\n        (bal, , , , , , , , , ) = aave.getUserReserveData(token, address(this));\r\n    }\r\n\r\n    function getPaybackBalance(AaveV1Interface aave, address token) internal view returns (uint bal, uint fee) {\r\n        (, bal, , , , , fee, , , ) = aave.getUserReserveData(token, address(this));\r\n    }\r\n\r\n    function getTotalBorrowBalance(AaveV1Interface aave, address token) internal view returns (uint amt) {\r\n        (, uint bal, , , , , uint fee, , , ) = aave.getUserReserveData(token, address(this));\r\n        amt = add(bal, fee);\r\n    }\r\n\r\n    function getWithdrawBalanceV2(AaveV2DataProviderInterface aaveData, address token) internal view returns (uint bal) {\r\n        (bal, , , , , , , , ) = aaveData.getUserReserveData(token, address(this));\r\n    }\r\n\r\n    function getPaybackBalanceV2(AaveV2DataProviderInterface aaveData, address token, uint rateMode) internal view returns (uint bal) {\r\n        if (rateMode == 1) {\r\n            (, bal, , , , , , , ) = aaveData.getUserReserveData(token, address(this));\r\n        } else {\r\n            (, , bal, , , , , , ) = aaveData.getUserReserveData(token, address(this));\r\n        }\r\n    }\r\n\r\n    function getIsColl(AaveV1Interface aave, address token) internal view returns (bool isCol) {\r\n        (, , , , , , , , , isCol) = aave.getUserReserveData(token, address(this));\r\n    }\r\n\r\n    function getIsCollV2(AaveV2DataProviderInterface aaveData, address token) internal view returns (bool isCol) {\r\n        (, , , , , , , , isCol) = aaveData.getUserReserveData(token, address(this));\r\n    }\r\n\r\n    function convertEthToWeth(bool isEth, TokenInterface token, uint amount) internal {\r\n        if(isEth) token.deposit.value(amount)();\r\n    }\r\n\r\n    function convertWethToEth(bool isEth, TokenInterface token, uint amount) internal {\r\n       if(isEth) {\r\n            token.approve(address(token), amount);\r\n            token.withdraw(amount);\r\n        }\r\n    }\r\n\r\n    function getMaxBorrow(Protocol target, address token, CTokenInterface ctoken, uint rateMode) internal returns (uint amt) {\r\n        AaveV1Interface aaveV1 = AaveV1Interface(getAaveProvider().getLendingPool());\r\n        AaveV2DataProviderInterface aaveData = getAaveV2DataProvider();\r\n\r\n        if (target == Protocol.Aave) {\r\n            (uint _amt, uint _fee) = getPaybackBalance(aaveV1, token);\r\n            amt = _amt + _fee;\r\n        } else if (target == Protocol.AaveV2) {\r\n            amt = getPaybackBalanceV2(aaveData, token, rateMode);\r\n        } else if (target == Protocol.Compound) {\r\n            amt = ctoken.borrowBalanceCurrent(address(this));\r\n        }\r\n    }\r\n\r\n    function transferFees(address token, uint feeAmt) internal {\r\n        if (feeAmt > 0) {\r\n            if (token == getEthAddr()) {\r\n                feeCollector.transfer(feeAmt);\r\n            } else {\r\n                IERC20(token).safeTransfer(feeCollector, feeAmt);\r\n            }\r\n        }\r\n    }\r\n\r\n    function calculateFee(uint256 amount, uint256 fee, bool toAdd) internal pure returns(uint feeAmount, uint _amount){\r\n        feeAmount = wmul(amount, fee);\r\n        _amount = toAdd ? add(amount, feeAmount) : sub(amount, feeAmount);\r\n    }\r\n\r\n    function getTokenInterfaces(uint length, address[] memory tokens) internal pure returns (TokenInterface[] memory) {\r\n        TokenInterface[] memory _tokens = new TokenInterface[](length);\r\n        for (uint i = 0; i < length; i++) {\r\n            if (tokens[i] ==  getEthAddr()) {\r\n                _tokens[i] = TokenInterface(getWethAddr());\r\n            } else {\r\n                _tokens[i] = TokenInterface(tokens[i]);\r\n            }\r\n        }\r\n        return _tokens;\r\n    }\r\n\r\n    function getCtokenInterfaces(uint length, address[] memory tokens) internal view returns (CTokenInterface[] memory) {\r\n        CTokenInterface[] memory _ctokens = new CTokenInterface[](length);\r\n        for (uint i = 0; i < length; i++) {\r\n            address _cToken = InstaMapping(getMappingAddr()).cTokenMapping(tokens[i]);\r\n            _ctokens[i] = CTokenInterface(_cToken);\r\n        }\r\n        return _ctokens;\r\n    }\r\n}\r\n\r\ncontract CompoundHelpers is Helpers {\r\n\r\n    struct CompoundBorrowData {\r\n        uint length;\r\n        uint fee;\r\n        Protocol target;\r\n        CTokenInterface[] ctokens;\r\n        TokenInterface[] tokens;\r\n        uint[] amts;\r\n        uint[] rateModes;\r\n    }\r\n\r\n    function _compEnterMarkets(uint length, CTokenInterface[] memory ctokens) internal {\r\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\r\n        address[] memory _cTokens = new address[](length);\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            _cTokens[i] = address(ctokens[i]);\r\n        }\r\n        troller.enterMarkets(_cTokens);\r\n    }\r\n\r\n    function _compBorrowOne(\r\n        uint fee,\r\n        CTokenInterface ctoken,\r\n        TokenInterface token,\r\n        uint amt,\r\n        Protocol target,\r\n        uint rateMode\r\n    ) internal returns (uint) {\r\n        if (amt > 0) {\r\n            address _token = address(token) == getWethAddr() ? getEthAddr() : address(token);\r\n\r\n            if (amt == uint(-1)) {\r\n                amt = getMaxBorrow(target, address(token), ctoken, rateMode);\r\n            }\r\n\r\n            (uint feeAmt, uint _amt) = calculateFee(amt, fee, true);\r\n\r\n            require(ctoken.borrow(_amt) == 0, \"borrow-failed-collateral?\");\r\n            transferFees(_token, feeAmt);\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _compBorrow(\r\n        CompoundBorrowData memory data\r\n    ) internal returns (uint[] memory) {\r\n        uint[] memory finalAmts = new uint[](data.length);\r\n        for (uint i = 0; i < data.length; i++) {\r\n            finalAmts[i] = _compBorrowOne(\r\n                data.fee, \r\n                data.ctokens[i], \r\n                data.tokens[i], \r\n                data.amts[i], \r\n                data.target, \r\n                data.rateModes[i]\r\n            );\r\n        }\r\n        return finalAmts;\r\n    }\r\n\r\n    function _compDepositOne(uint fee, CTokenInterface ctoken, TokenInterface token, uint amt) internal {\r\n        if (amt > 0) {\r\n            address _token = address(token) == getWethAddr() ? getEthAddr() : address(token);\r\n\r\n            (uint feeAmt, uint _amt) = calculateFee(amt, fee, false);\r\n\r\n            if (_token != getEthAddr()) {\r\n                token.approve(address(ctoken), _amt);\r\n                require(ctoken.mint(_amt) == 0, \"deposit-failed\");\r\n            } else {\r\n                CETHInterface(address(ctoken)).mint.value(_amt)();\r\n            }\r\n            transferFees(_token, feeAmt);\r\n        }\r\n    }\r\n\r\n    function _compDeposit(\r\n        uint length,\r\n        uint fee,\r\n        CTokenInterface[] memory ctokens,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts\r\n    ) internal {\r\n        for (uint i = 0; i < length; i++) {\r\n            _compDepositOne(fee, ctokens[i], tokens[i], amts[i]);\r\n        }\r\n    }\r\n\r\n    function _compWithdrawOne(CTokenInterface ctoken, TokenInterface token, uint amt) internal returns (uint) {\r\n        if (amt > 0) {\r\n            if (amt == uint(-1)) {\r\n                bool isEth = address(token) == getWethAddr();\r\n                uint initalBal = isEth ? address(this).balance : token.balanceOf(address(this));\r\n                require(ctoken.redeem(ctoken.balanceOf(address(this))) == 0, \"withdraw-failed\");\r\n                uint finalBal = isEth ? address(this).balance : token.balanceOf(address(this));\r\n                amt = sub(finalBal, initalBal);\r\n            } else {\r\n                require(ctoken.redeemUnderlying(amt) == 0, \"withdraw-failed\");\r\n            }\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _compWithdraw(\r\n        uint length,\r\n        CTokenInterface[] memory ctokens,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts\r\n    ) internal returns(uint[] memory) {\r\n        uint[] memory finalAmts = new uint[](length);\r\n        for (uint i = 0; i < length; i++) {\r\n            finalAmts[i] = _compWithdrawOne(ctokens[i], tokens[i], amts[i]);\r\n        }\r\n        return finalAmts;\r\n    }\r\n\r\n    function _compPaybackOne(CTokenInterface ctoken, TokenInterface token, uint amt) internal returns (uint) {\r\n        if (amt > 0) {\r\n            if (amt == uint(-1)) {\r\n                amt = ctoken.borrowBalanceCurrent(address(this));\r\n            }\r\n            if (address(token) != getWethAddr()) {\r\n                token.approve(address(ctoken), amt);\r\n                require(ctoken.repayBorrow(amt) == 0, \"repay-failed.\");\r\n            } else {\r\n                CETHInterface(address(ctoken)).repayBorrow.value(amt)();\r\n            }\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _compPayback(\r\n        uint length,\r\n        CTokenInterface[] memory ctokens,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts\r\n    ) internal {\r\n        for (uint i = 0; i < length; i++) {\r\n            _compPaybackOne(ctokens[i], tokens[i], amts[i]);\r\n        }\r\n    }\r\n}\r\n\r\ncontract AaveV1Helpers is CompoundHelpers {\r\n\r\n    struct AaveV1BorrowData {\r\n        AaveV1Interface aave;\r\n        uint length;\r\n        uint fee;\r\n        Protocol target;\r\n        TokenInterface[] tokens;\r\n        CTokenInterface[] ctokens;\r\n        uint[] amts;\r\n        uint[] borrowRateModes;\r\n        uint[] paybackRateModes;\r\n    }\r\n\r\n    struct AaveV1DepositData {\r\n        AaveV1Interface aave;\r\n        AaveV1CoreInterface aaveCore;\r\n        uint length;\r\n        uint fee;\r\n        TokenInterface[] tokens;\r\n        uint[] amts;\r\n    }\r\n\r\n    function _aaveV1BorrowOne(\r\n        AaveV1Interface aave,\r\n        uint fee,\r\n        Protocol target,\r\n        TokenInterface token,\r\n        CTokenInterface ctoken,\r\n        uint amt,\r\n        uint borrowRateMode,\r\n        uint paybackRateMode\r\n    ) internal returns (uint) {\r\n        if (amt > 0) {\r\n\r\n            address _token = address(token) == getWethAddr() ? getEthAddr() : address(token);\r\n\r\n            if (amt == uint(-1)) {\r\n                amt = getMaxBorrow(target, address(token), ctoken, paybackRateMode);\r\n            }\r\n\r\n            (uint feeAmt, uint _amt) = calculateFee(amt, fee, true);\r\n\r\n            aave.borrow(_token, _amt, borrowRateMode, getReferralCode());\r\n            transferFees(_token, feeAmt);\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _aaveV1Borrow(\r\n        AaveV1BorrowData memory data\r\n    ) internal returns (uint[] memory) {\r\n        uint[] memory finalAmts = new uint[](data.length);\r\n        for (uint i = 0; i < data.length; i++) {\r\n            finalAmts[i] = _aaveV1BorrowOne(\r\n                data.aave,\r\n                data.fee,\r\n                data.target,\r\n                data.tokens[i],\r\n                data.ctokens[i],\r\n                data.amts[i],\r\n                data.borrowRateModes[i],\r\n                data.paybackRateModes[i]\r\n            );\r\n        }\r\n        return finalAmts;\r\n    }\r\n\r\n    function _aaveV1DepositOne(\r\n        AaveV1Interface aave,\r\n        AaveV1CoreInterface aaveCore,\r\n        uint fee,\r\n        TokenInterface token,\r\n        uint amt\r\n    ) internal {\r\n        if (amt > 0) {\r\n            uint ethAmt;\r\n            (uint feeAmt, uint _amt) = calculateFee(amt, fee, false);\r\n\r\n            bool isEth = address(token) == getWethAddr();\r\n\r\n            address _token = isEth ? getEthAddr() : address(token);\r\n\r\n            if (isEth) {\r\n                ethAmt = _amt;\r\n            } else {\r\n                token.approve(address(aaveCore), _amt);\r\n            }\r\n\r\n            transferFees(_token, feeAmt);\r\n\r\n            aave.deposit.value(ethAmt)(_token, _amt, getReferralCode());\r\n\r\n            if (!getIsColl(aave, _token))\r\n                aave.setUserUseReserveAsCollateral(_token, true);\r\n        }\r\n    }\r\n\r\n    function _aaveV1Deposit(\r\n        AaveV1DepositData memory data\r\n    ) internal {\r\n        for (uint i = 0; i < data.length; i++) {\r\n            _aaveV1DepositOne(\r\n                data.aave,\r\n                data.aaveCore,\r\n                data.fee,\r\n                data.tokens[i],\r\n                data.amts[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function _aaveV1WithdrawOne(\r\n        AaveV1Interface aave,\r\n        AaveV1CoreInterface aaveCore,\r\n        TokenInterface token,\r\n        uint amt\r\n    ) internal returns (uint) {\r\n        if (amt > 0) {\r\n            address _token = address(token) == getWethAddr() ? getEthAddr() : address(token);\r\n            ATokenV1Interface atoken = ATokenV1Interface(aaveCore.getReserveATokenAddress(_token));\r\n            if (amt == uint(-1)) {\r\n                amt = getWithdrawBalance(aave, _token);\r\n            }\r\n            atoken.redeem(amt);\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _aaveV1Withdraw(\r\n        AaveV1Interface aave,\r\n        AaveV1CoreInterface aaveCore,\r\n        uint length,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts\r\n    ) internal returns (uint[] memory) {\r\n        uint[] memory finalAmts = new uint[](length);\r\n        for (uint i = 0; i < length; i++) {\r\n            finalAmts[i] = _aaveV1WithdrawOne(aave, aaveCore, tokens[i], amts[i]);\r\n        }\r\n        return finalAmts;\r\n    }\r\n\r\n    function _aaveV1PaybackOne(\r\n        AaveV1Interface aave,\r\n        AaveV1CoreInterface aaveCore,\r\n        TokenInterface token,\r\n        uint amt\r\n    ) internal returns (uint) {\r\n        if (amt > 0) {\r\n            uint ethAmt;\r\n\r\n            bool isEth = address(token) == getWethAddr();\r\n\r\n            address _token = isEth ? getEthAddr() : address(token);\r\n\r\n            if (amt == uint(-1)) {\r\n                (uint _amt, uint _fee) = getPaybackBalance(aave, _token);\r\n                amt = _amt + _fee;\r\n            }\r\n\r\n            if (isEth) {\r\n                ethAmt = amt;\r\n            } else {\r\n                token.approve(address(aaveCore), amt);\r\n            }\r\n\r\n            aave.repay.value(ethAmt)(_token, amt, payable(address(this)));\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _aaveV1Payback(\r\n        AaveV1Interface aave,\r\n        AaveV1CoreInterface aaveCore,\r\n        uint length,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts\r\n    ) internal {\r\n        for (uint i = 0; i < length; i++) {\r\n            _aaveV1PaybackOne(aave, aaveCore, tokens[i], amts[i]);\r\n        }\r\n    }\r\n}\r\n\r\ncontract AaveV2Helpers is AaveV1Helpers {\r\n\r\n    struct AaveV2BorrowData {\r\n        AaveV2Interface aave;\r\n        uint length;\r\n        uint fee;\r\n        Protocol target;\r\n        TokenInterface[] tokens;\r\n        CTokenInterface[] ctokens;\r\n        uint[] amts;\r\n        uint[] rateModes;\r\n    }\r\n\r\n    struct AaveV2PaybackData {\r\n        AaveV2Interface aave;\r\n        AaveV2DataProviderInterface aaveData;\r\n        uint length;\r\n        TokenInterface[] tokens;\r\n        uint[] amts;\r\n        uint[] rateModes;\r\n    }\r\n\r\n    struct AaveV2WithdrawData {\r\n        AaveV2Interface aave;\r\n        AaveV2DataProviderInterface aaveData;\r\n        uint length;\r\n        TokenInterface[] tokens;\r\n        uint[] amts;\r\n    }\r\n\r\n    function _aaveV2BorrowOne(\r\n        AaveV2Interface aave,\r\n        uint fee,\r\n        Protocol target,\r\n        TokenInterface token,\r\n        CTokenInterface ctoken,\r\n        uint amt,\r\n        uint rateMode\r\n    ) internal returns (uint) {\r\n        if (amt > 0) {\r\n            bool isEth = address(token) == getWethAddr();\r\n            \r\n            address _token = isEth ? getEthAddr() : address(token);\r\n\r\n            if (amt == uint(-1)) {\r\n                amt = getMaxBorrow(target, _token, ctoken, rateMode);\r\n            }\r\n\r\n            (uint feeAmt, uint _amt) = calculateFee(amt, fee, true);\r\n\r\n            aave.borrow(address(token), _amt, rateMode, getReferralCode(), address(this));\r\n            convertWethToEth(isEth, token, amt);\r\n\r\n            transferFees(_token, feeAmt);\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _aaveV2Borrow(\r\n        AaveV2BorrowData memory data\r\n    ) internal returns (uint[] memory) {\r\n        uint[] memory finalAmts = new uint[](data.length);\r\n        for (uint i = 0; i < data.length; i++) {\r\n            finalAmts[i] = _aaveV2BorrowOne(\r\n                data.aave,\r\n                data.fee,\r\n                data.target,\r\n                data.tokens[i],\r\n                data.ctokens[i],\r\n                data.amts[i],\r\n                data.rateModes[i]\r\n            );\r\n        }\r\n        return finalAmts;\r\n    }\r\n\r\n    function _aaveV2DepositOne(\r\n        AaveV2Interface aave,\r\n        AaveV2DataProviderInterface aaveData,\r\n        uint fee,\r\n        TokenInterface token,\r\n        uint amt\r\n    ) internal {\r\n        if (amt > 0) {\r\n            (uint feeAmt, uint _amt) = calculateFee(amt, fee, false);\r\n\r\n            bool isEth = address(token) == getWethAddr();\r\n            address _token = isEth ? getEthAddr() : address(token);\r\n\r\n            transferFees(_token, feeAmt);\r\n\r\n            convertEthToWeth(isEth, token, _amt);\r\n\r\n            token.approve(address(aave), _amt);\r\n\r\n            aave.deposit(address(token), _amt, address(this), getReferralCode());\r\n\r\n            if (!getIsCollV2(aaveData, address(token))) {\r\n                aave.setUserUseReserveAsCollateral(address(token), true);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _aaveV2Deposit(\r\n        AaveV2Interface aave,\r\n        AaveV2DataProviderInterface aaveData,\r\n        uint length,\r\n        uint fee,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts\r\n    ) internal {\r\n        for (uint i = 0; i < length; i++) {\r\n            _aaveV2DepositOne(aave, aaveData, fee, tokens[i], amts[i]);\r\n        }\r\n    }\r\n\r\n    function _aaveV2WithdrawOne(\r\n        AaveV2Interface aave,\r\n        AaveV2DataProviderInterface aaveData,\r\n        TokenInterface token,\r\n        uint amt\r\n    ) internal returns (uint _amt) {\r\n        if (amt > 0) {\r\n            bool isEth = address(token) == getWethAddr();\r\n\r\n            aave.withdraw(address(token), amt, address(this));\r\n\r\n            _amt = amt == uint(-1) ? getWithdrawBalanceV2(aaveData, address(token)) : amt;\r\n\r\n            convertWethToEth(isEth, token, _amt);\r\n        }\r\n    }\r\n\r\n    function _aaveV2Withdraw(\r\n        AaveV2WithdrawData memory data\r\n    ) internal returns (uint[] memory) {\r\n        uint[] memory finalAmts = new uint[](data.length);\r\n        for (uint i = 0; i < data.length; i++) {\r\n            finalAmts[i] = _aaveV2WithdrawOne(\r\n                data.aave,\r\n                data.aaveData,\r\n                data.tokens[i],\r\n                data.amts[i]\r\n            );\r\n        }\r\n        return finalAmts;\r\n    }\r\n\r\n    function _aaveV2PaybackOne(\r\n        AaveV2Interface aave,\r\n        AaveV2DataProviderInterface aaveData,\r\n        TokenInterface token,\r\n        uint amt,\r\n        uint rateMode\r\n    ) internal returns (uint _amt) {\r\n        if (amt > 0) {\r\n            bool isEth = address(token) == getWethAddr();\r\n\r\n            _amt = amt == uint(-1) ? getPaybackBalanceV2(aaveData, address(token), rateMode) : amt;\r\n\r\n            convertEthToWeth(isEth, token, _amt);\r\n\r\n            token.approve(address(aave), _amt);\r\n\r\n            aave.repay(address(token), _amt, rateMode, address(this));\r\n        }\r\n    }\r\n\r\n    function _aaveV2Payback(\r\n        AaveV2PaybackData memory data\r\n    ) internal {\r\n        for (uint i = 0; i < data.length; i++) {\r\n            _aaveV2PaybackOne(\r\n                data.aave,\r\n                data.aaveData,\r\n                data.tokens[i],\r\n                data.amts[i],\r\n                data.rateModes[i]\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\ncontract RefinanceResolver is AaveV2Helpers {\r\n\r\n    struct RefinanceData {\r\n        Protocol source;\r\n        Protocol target;\r\n        uint collateralFee;\r\n        uint debtFee;\r\n        address[] tokens;\r\n        uint[] borrowAmts;\r\n        uint[] withdrawAmts;\r\n        uint[] borrowRateModes;\r\n        uint[] paybackRateModes;\r\n    }\r\n\r\n    function refinance(RefinanceData calldata data) external payable {\r\n\r\n        require(data.source != data.target, \"source-and-target-unequal\");\r\n\r\n        uint length = data.tokens.length;\r\n\r\n        require(data.borrowAmts.length == length, \"length-mismatch\");\r\n        require(data.withdrawAmts.length == length, \"length-mismatch\");\r\n        require(data.borrowRateModes.length == length, \"length-mismatch\");\r\n        require(data.paybackRateModes.length == length, \"length-mismatch\");\r\n\r\n        AaveV2Interface aaveV2 = AaveV2Interface(getAaveV2Provider().getLendingPool());\r\n        AaveV1Interface aaveV1 = AaveV1Interface(getAaveProvider().getLendingPool());\r\n        AaveV1CoreInterface aaveCore = AaveV1CoreInterface(getAaveProvider().getLendingPoolCore());\r\n        AaveV2DataProviderInterface aaveData = getAaveV2DataProvider();\r\n\r\n        uint[] memory depositAmts;\r\n        uint[] memory paybackAmts;\r\n\r\n        TokenInterface[] memory tokens = getTokenInterfaces(length, data.tokens);\r\n        CTokenInterface[] memory _ctokens = getCtokenInterfaces(length, data.tokens);\r\n\r\n        if (data.source == Protocol.Aave && data.target == Protocol.AaveV2) {\r\n            AaveV2BorrowData memory _aaveV2BorrowData;\r\n\r\n            _aaveV2BorrowData.aave = aaveV2;\r\n            _aaveV2BorrowData.length = length;\r\n            _aaveV2BorrowData.fee = data.debtFee;\r\n            _aaveV2BorrowData.target = data.source;\r\n            _aaveV2BorrowData.tokens = tokens;\r\n            _aaveV2BorrowData.ctokens = _ctokens;\r\n            _aaveV2BorrowData.amts = data.borrowAmts;\r\n            _aaveV2BorrowData.rateModes = data.borrowRateModes;\r\n\r\n            paybackAmts = _aaveV2Borrow(_aaveV2BorrowData);\r\n            _aaveV1Payback(aaveV1, aaveCore, length, tokens, paybackAmts);\r\n            depositAmts = _aaveV1Withdraw(aaveV1, aaveCore, length, tokens, data.withdrawAmts);\r\n            _aaveV2Deposit(aaveV2, aaveData, length, data.collateralFee, tokens, depositAmts);\r\n        } else if (data.source == Protocol.Aave && data.target == Protocol.Compound) {\r\n            _compEnterMarkets(length, _ctokens);\r\n\r\n            CompoundBorrowData memory _compoundBorrowData;\r\n\r\n            _compoundBorrowData.length = length;\r\n            _compoundBorrowData.fee = data.debtFee;\r\n            _compoundBorrowData.target = data.source;\r\n            _compoundBorrowData.ctokens = _ctokens;\r\n            _compoundBorrowData.tokens = tokens;\r\n            _compoundBorrowData.amts = data.borrowAmts;\r\n            _compoundBorrowData.rateModes = data.borrowRateModes;\r\n\r\n            paybackAmts = _compBorrow(_compoundBorrowData);\r\n            \r\n            _aaveV1Payback(aaveV1, aaveCore, length, tokens, paybackAmts);\r\n            depositAmts = _aaveV1Withdraw(aaveV1, aaveCore, length, tokens, data.withdrawAmts);\r\n            _compDeposit(length, data.collateralFee, _ctokens, tokens, depositAmts);\r\n        } else if (data.source == Protocol.AaveV2 && data.target == Protocol.Aave) {\r\n\r\n            AaveV1BorrowData memory _aaveV1BorrowData;\r\n            AaveV2PaybackData memory _aaveV2PaybackData;\r\n            AaveV2WithdrawData memory _aaveV2WithdrawData;\r\n\r\n            {\r\n                _aaveV1BorrowData.aave = aaveV1;\r\n                _aaveV1BorrowData.length = length;\r\n                _aaveV1BorrowData.fee = data.debtFee;\r\n                _aaveV1BorrowData.target = data.source;\r\n                _aaveV1BorrowData.tokens = tokens;\r\n                _aaveV1BorrowData.ctokens = _ctokens;\r\n                _aaveV1BorrowData.amts = data.borrowAmts;\r\n                _aaveV1BorrowData.borrowRateModes = data.borrowRateModes;\r\n                _aaveV1BorrowData.paybackRateModes = data.paybackRateModes;\r\n\r\n                paybackAmts = _aaveV1Borrow(_aaveV1BorrowData);\r\n            }\r\n            \r\n            {\r\n                _aaveV2PaybackData.aave = aaveV2;\r\n                _aaveV2PaybackData.aaveData = aaveData;\r\n                _aaveV2PaybackData.length = length;\r\n                _aaveV2PaybackData.tokens = tokens;\r\n                _aaveV2PaybackData.amts = paybackAmts;\r\n                _aaveV2PaybackData.rateModes = data.paybackRateModes;\r\n                _aaveV2Payback(_aaveV2PaybackData);\r\n            }\r\n\r\n            {\r\n                _aaveV2WithdrawData.aave = aaveV2;\r\n                _aaveV2WithdrawData.aaveData = aaveData;\r\n                _aaveV2WithdrawData.length = length;\r\n                _aaveV2WithdrawData.tokens = tokens;\r\n                _aaveV2WithdrawData.amts = data.withdrawAmts;\r\n                depositAmts = _aaveV2Withdraw(_aaveV2WithdrawData);\r\n            }\r\n            {\r\n                AaveV1DepositData memory _aaveV1DepositData;\r\n                \r\n                _aaveV1DepositData.aave = aaveV1;\r\n                _aaveV1DepositData.aaveCore = aaveCore;\r\n                _aaveV1DepositData.length = length;\r\n                _aaveV1DepositData.fee = data.collateralFee;\r\n                _aaveV1DepositData.tokens = tokens;\r\n                _aaveV1DepositData.amts = depositAmts;\r\n\r\n                _aaveV1Deposit(_aaveV1DepositData);\r\n            }\r\n        } else if (data.source == Protocol.AaveV2 && data.target == Protocol.Compound) {\r\n            _compEnterMarkets(length, _ctokens);\r\n\r\n            {\r\n                CompoundBorrowData memory _compoundBorrowData;\r\n\r\n                _compoundBorrowData.length = length;\r\n                _compoundBorrowData.fee = data.debtFee;\r\n                _compoundBorrowData.target = data.source;\r\n                _compoundBorrowData.ctokens = _ctokens;\r\n                _compoundBorrowData.tokens = tokens;\r\n                _compoundBorrowData.amts = data.borrowAmts;\r\n                _compoundBorrowData.rateModes = data.borrowRateModes;\r\n\r\n                paybackAmts = _compBorrow(_compoundBorrowData);\r\n            }\r\n\r\n            AaveV2PaybackData memory _aaveV2PaybackData;\r\n\r\n            _aaveV2PaybackData.aave = aaveV2;\r\n            _aaveV2PaybackData.aaveData = aaveData;\r\n            _aaveV2PaybackData.length = length;\r\n            _aaveV2PaybackData.tokens = tokens;\r\n            _aaveV2PaybackData.amts = paybackAmts;\r\n            _aaveV2PaybackData.rateModes = data.paybackRateModes;\r\n            \r\n            _aaveV2Payback(_aaveV2PaybackData);\r\n\r\n            {\r\n                AaveV2WithdrawData memory _aaveV2WithdrawData;\r\n\r\n                _aaveV2WithdrawData.aave = aaveV2;\r\n                _aaveV2WithdrawData.aaveData = aaveData;\r\n                _aaveV2WithdrawData.length = length;\r\n                _aaveV2WithdrawData.tokens = tokens;\r\n                _aaveV2WithdrawData.amts = data.withdrawAmts;\r\n                depositAmts = _aaveV2Withdraw(_aaveV2WithdrawData);\r\n            }\r\n            _compDeposit(length, data.collateralFee, _ctokens, tokens, depositAmts);\r\n        } else if (data.source == Protocol.Compound && data.target == Protocol.Aave) {\r\n\r\n            AaveV1BorrowData memory _aaveV1BorrowData;\r\n\r\n            _aaveV1BorrowData.aave = aaveV1;\r\n            _aaveV1BorrowData.length = length;\r\n            _aaveV1BorrowData.fee = data.debtFee;\r\n            _aaveV1BorrowData.target = data.source;\r\n            _aaveV1BorrowData.tokens = tokens;\r\n            _aaveV1BorrowData.ctokens = _ctokens;\r\n            _aaveV1BorrowData.amts = data.borrowAmts;\r\n            _aaveV1BorrowData.borrowRateModes = data.borrowRateModes;\r\n            _aaveV1BorrowData.paybackRateModes = data.paybackRateModes;\r\n            \r\n            paybackAmts = _aaveV1Borrow(_aaveV1BorrowData);\r\n            {\r\n            _compPayback(length, _ctokens, tokens, paybackAmts);\r\n            depositAmts = _compWithdraw(length, _ctokens, tokens, data.withdrawAmts);\r\n            }\r\n\r\n            {\r\n                AaveV1DepositData memory _aaveV1DepositData;\r\n                \r\n                _aaveV1DepositData.aave = aaveV1;\r\n                _aaveV1DepositData.aaveCore = aaveCore;\r\n                _aaveV1DepositData.length = length;\r\n                _aaveV1DepositData.fee = data.collateralFee;\r\n                _aaveV1DepositData.tokens = tokens;\r\n                _aaveV1DepositData.amts = depositAmts;\r\n\r\n                _aaveV1Deposit(_aaveV1DepositData);\r\n            }\r\n        } else if (data.source == Protocol.Compound && data.target == Protocol.AaveV2) {\r\n            AaveV2BorrowData memory _aaveV2BorrowData;\r\n\r\n            _aaveV2BorrowData.aave = aaveV2;\r\n            _aaveV2BorrowData.length = length;\r\n            _aaveV2BorrowData.fee = data.debtFee;\r\n            _aaveV2BorrowData.target = data.source;\r\n            _aaveV2BorrowData.tokens = tokens;\r\n            _aaveV2BorrowData.ctokens = _ctokens;\r\n            _aaveV2BorrowData.amts = data.borrowAmts;\r\n            _aaveV2BorrowData.rateModes = data.borrowRateModes;\r\n            \r\n            paybackAmts = _aaveV2Borrow(_aaveV2BorrowData);\r\n            _compPayback(length, _ctokens, tokens, paybackAmts);\r\n            depositAmts = _compWithdraw(length, _ctokens, tokens, data.withdrawAmts);\r\n            _aaveV2Deposit(aaveV2, aaveData, length, data.collateralFee, tokens, depositAmts);\r\n        } else {\r\n            revert(\"invalid-options\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract ConnectRefinance is RefinanceResolver {\r\n    string public name = \"Refinance-v1.1\";\r\n}"}}}