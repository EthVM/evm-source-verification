{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"VersionManager.sol":{"content":"pragma experimental ABIEncoderV2;\r\n// File: contracts/modules/common/Utils.sol\r\n// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n// SPDX-License-Identifier: GPL-3.0-only\r\n/**\r\n * @title Utils\r\n * @notice Common utility methods used by modules.\r\n */\r\nlibrary Utils {\r\n    /**\r\n    * @notice Helper method to recover the signer at a given position from a list of concatenated signatures.\r\n    * @param _signedHash The signed hash\r\n    * @param _signatures The concatenated signatures.\r\n    * @param _index The index of the signature to recover.\r\n    */\r\n    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint _index) internal pure returns (address) {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        // we jump 32 (0x20) as the first slot of bytes contains the length\r\n        // we jump 65 (0x41) per signature\r\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\r\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\r\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\r\n        }\r\n        require(v == 27 || v == 28);\r\n        address recoveredAddress = ecrecover(_signedHash, v, r, s);\r\n        require(recoveredAddress != address(0), \"Utils: ecrecover returned 0\");\r\n        return recoveredAddress;\r\n    }\r\n    /**\r\n    * @notice Helper method to parse data and extract the method signature.\r\n    */\r\n    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\r\n        require(_data.length >= 4, \"RM: Invalid functionPrefix\");\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            prefix := mload(add(_data, 0x20))\r\n        }\r\n    }\r\n    /**\r\n    * @notice Returns ceil(a / b).\r\n    */\r\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        if (a % b == 0) {\r\n            return c;\r\n        } else {\r\n            return c + 1;\r\n        }\r\n    }\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a < b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n}\r\n// File: contracts/infrastructure/base/Owned.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n  \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title Owned\r\n * @notice Basic contract to define an owner.\r\n * @author Julien Niset - <julien@argent.xyz>\r\n */\r\ncontract Owned {\r\n    // The owner\r\n    address public owner;\r\n    event OwnerChanged(address indexed _newOwner);\r\n    /**\r\n     * @notice Throws if the sender is not the owner.\r\n     */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Must be owner\");\r\n        _;\r\n    }\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    /**\r\n     * @notice Lets the owner transfer ownership of the contract to a new owner.\r\n     * @param _newOwner The new owner.\r\n     */\r\n    function changeOwner(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"Address must not be null\");\r\n        owner = _newOwner;\r\n        emit OwnerChanged(_newOwner);\r\n    }\r\n}\r\n// File: contracts/infrastructure/storage/ITransferStorage.sol\r\n// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n  \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title ITransferStorage\r\n * @notice TransferStorage interface\r\n */\r\ninterface ITransferStorage {\r\n    function setWhitelist(address _wallet, address _target, uint256 _value) external;\r\n    function getWhitelist(address _wallet, address _target) external view returns (uint256);\r\n}\r\n// File: contracts/infrastructure/storage/IGuardianStorage.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n  \r\npragma solidity >=0.5.4 <0.7.0;\r\ninterface IGuardianStorage {\r\n    /**\r\n     * @notice Lets an authorised module add a guardian to a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The guardian to add.\r\n     */\r\n    function addGuardian(address _wallet, address _guardian) external;\r\n    /**\r\n     * @notice Lets an authorised module revoke a guardian from a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The guardian to revoke.\r\n     */\r\n    function revokeGuardian(address _wallet, address _guardian) external;\r\n    /**\r\n     * @notice Checks if an account is a guardian for a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The account.\r\n     * @return true if the account is a guardian for a wallet.\r\n     */\r\n    function isGuardian(address _wallet, address _guardian) external view returns (bool);\r\n    function isLocked(address _wallet) external view returns (bool);\r\n    function getLock(address _wallet) external view returns (uint256);\r\n    function getLocker(address _wallet) external view returns (address);\r\n    function setLock(address _wallet, uint256 _releaseAfter) external;\r\n    function getGuardians(address _wallet) external view returns (address[] memory);\r\n    function guardianCount(address _wallet) external view returns (uint256);\r\n}\r\n// File: contracts/modules/common/IModule.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n  \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title IModule\r\n * @notice Interface for a module.\r\n * A module MUST implement the addModule() method to ensure that a wallet with at least one module\r\n * can never end up in a \"frozen\" state.\r\n * @author Julien Niset - <julien@argent.xyz>\r\n */\r\ninterface IModule {\r\n    /**\r\n     * @notice Inits a module for a wallet by e.g. setting some wallet specific parameters in storage.\r\n     * @param _wallet The wallet.\r\n     */\r\n    function init(address _wallet) external;\r\n    /**\t\r\n     * @notice Adds a module to a wallet. Cannot execute when wallet is locked (or under recovery)\t\r\n     * @param _wallet The target wallet.\t\r\n     * @param _module The modules to authorise.\t\r\n     */\t\r\n    function addModule(address _wallet, address _module) external;\r\n}\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n// File: contracts/wallet/IWallet.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n  \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title IWallet\r\n * @notice Interface for the BaseWallet\r\n */\r\ninterface IWallet {\r\n    /**\r\n     * @notice Returns the wallet owner.\r\n     * @return The wallet owner address.\r\n     */\r\n    function owner() external view returns (address);\r\n    /**\r\n     * @notice Returns the number of authorised modules.\r\n     * @return The number of authorised modules.\r\n     */\r\n    function modules() external view returns (uint);\r\n    /**\r\n     * @notice Sets a new owner for the wallet.\r\n     * @param _newOwner The new owner.\r\n     */\r\n    function setOwner(address _newOwner) external;\r\n    /**\r\n     * @notice Checks if a module is authorised on the wallet.\r\n     * @param _module The module address to check.\r\n     * @return `true` if the module is authorised, otherwise `false`.\r\n     */\r\n    function authorised(address _module) external view returns (bool);\r\n    /**\r\n     * @notice Returns the module responsible for a static call redirection.\r\n     * @param _sig The signature of the static call.\r\n     * @return the module doing the redirection\r\n     */\r\n    function enabled(bytes4 _sig) external view returns (address);\r\n    /**\r\n     * @notice Enables/Disables a module.\r\n     * @param _module The target module.\r\n     * @param _value Set to `true` to authorise the module.\r\n     */\r\n    function authoriseModule(address _module, bool _value) external;\r\n    /**\r\n    * @notice Enables a static method by specifying the target module to which the call must be delegated.\r\n    * @param _module The target module.\r\n    * @param _method The static method signature.\r\n    */\r\n    function enableStaticCall(address _module, bytes4 _method) external;\r\n}\r\n// File: contracts/infrastructure/IModuleRegistry.sol\r\n// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n  \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title IModuleRegistry\r\n * @notice Interface for the registry of authorised modules.\r\n */\r\ninterface IModuleRegistry {\r\n    function registerModule(address _module, bytes32 _name) external;\r\n    function deregisterModule(address _module) external;\r\n    function registerUpgrader(address _upgrader, bytes32 _name) external;\r\n    function deregisterUpgrader(address _upgrader) external;\r\n    function recoverToken(address _token) external;\r\n    function moduleInfo(address _module) external view returns (bytes32);\r\n    function upgraderInfo(address _upgrader) external view returns (bytes32);\r\n    function isRegisteredModule(address _module) external view returns (bool);\r\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool);\r\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool);\r\n}\r\n// File: contracts/infrastructure/storage/ILockStorage.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n  \r\npragma solidity >=0.5.4 <0.7.0;\r\ninterface ILockStorage {\r\n    function isLocked(address _wallet) external view returns (bool);\r\n    function getLock(address _wallet) external view returns (uint256);\r\n    function getLocker(address _wallet) external view returns (address);\r\n    function setLock(address _wallet, address _locker, uint256 _releaseAfter) external;\r\n}\r\n// File: contracts/modules/common/IFeature.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n  \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title IFeature\r\n * @notice Interface for a Feature.\r\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\r\n */\r\ninterface IFeature {\r\n    enum OwnerSignature {\r\n        Anyone,             // Anyone\r\n        Required,           // Owner required\r\n        Optional,           // Owner and/or guardians\r\n        Disallowed          // guardians only\r\n    }\r\n    /**\r\n    * @notice Utility method to recover any ERC20 token that was sent to the Feature by mistake.\r\n    * @param _token The token to recover.\r\n    */\r\n    function recoverToken(address _token) external;\r\n    /**\r\n     * @notice Inits a Feature for a wallet by e.g. setting some wallet specific parameters in storage.\r\n     * @param _wallet The wallet.\r\n     */\r\n    function init(address _wallet) external;\r\n    /**\r\n     * @notice Helper method to check if an address is an authorised feature of a target wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _feature The address.\r\n     */\r\n    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) external view returns (bool);\r\n    /**\r\n    * @notice Gets the number of valid signatures that must be provided to execute a\r\n    * specific relayed transaction.\r\n    * @param _wallet The target wallet.\r\n    * @param _data The data of the relayed transaction.\r\n    * @return The number of required signatures and the wallet owner signature requirement.\r\n    */\r\n    function getRequiredSignatures(address _wallet, bytes calldata _data) external view returns (uint256, OwnerSignature);\r\n    /**\r\n    * @notice Gets the list of static call signatures that this feature responds to on behalf of wallets\r\n    */\r\n    function getStaticCallSignatures() external view returns (bytes4[] memory);\r\n}\r\n// File: lib/other/ERC20.sol\r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * ERC20 contract interface.\r\n */\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function decimals() external view returns (uint);\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n}\r\n// File: contracts/infrastructure/storage/ILimitStorage.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n  \r\n/**\r\n * @title ILimitStorage\r\n * @notice LimitStorage interface\r\n */\r\ninterface ILimitStorage {\r\n    struct Limit {\r\n        // the current limit\r\n        uint128 current;\r\n        // the pending limit if any\r\n        uint128 pending;\r\n        // when the pending limit becomes the current limit\r\n        uint64 changeAfter;\r\n    }\r\n    struct DailySpent {\r\n        // The amount already spent during the current period\r\n        uint128 alreadySpent;\r\n        // The end of the current period\r\n        uint64 periodEnd;\r\n    }\r\n    function setLimit(address _wallet, Limit memory _limit) external;\r\n    function getLimit(address _wallet) external view returns (Limit memory _limit);\r\n    function setDailySpent(address _wallet, DailySpent memory _dailySpent) external;\r\n    function getDailySpent(address _wallet) external view returns (DailySpent memory _dailySpent);\r\n    function setLimitAndDailySpent(address _wallet, Limit memory _limit, DailySpent memory _dailySpent) external;\r\n    function getLimitAndDailySpent(address _wallet) external view returns (Limit memory _limit, DailySpent memory _dailySpent);\r\n}\r\n// File: contracts/modules/common/IVersionManager.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n  \r\npragma solidity >=0.5.4 <0.7.0;\r\n/**\r\n * @title IVersionManager\r\n * @notice Interface for the VersionManager module.\r\n * @author Olivier VDB - <olivier@argent.xyz>\r\n */\r\ninterface IVersionManager {\r\n    /**\r\n     * @notice Returns true if the feature is authorised for the wallet\r\n     * @param _wallet The target wallet.\r\n     * @param _feature The feature.\r\n     */\r\n    function isFeatureAuthorised(address _wallet, address _feature) external view returns (bool);\r\n    /**\r\n     * @notice Lets a feature (caller) invoke a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _to The target address for the transaction.\r\n     * @param _value The value of the transaction.\r\n     * @param _data The data of the transaction.\r\n     */\r\n    function checkAuthorisedFeatureAndInvokeWallet(\r\n        address _wallet,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) external returns (bytes memory _res);\r\n    /* ******* Backward Compatibility with old Storages and BaseWallet *************** */\r\n    /**\r\n     * @notice Sets a new owner for the wallet.\r\n     * @param _newOwner The new owner.\r\n     */\r\n    function setOwner(address _wallet, address _newOwner) external;\r\n    /**\r\n     * @notice Lets a feature write data to a storage contract.\r\n     * @param _wallet The target wallet.\r\n     * @param _storage The storage contract.\r\n     * @param _data The data of the call\r\n     */\r\n    function invokeStorage(address _wallet, address _storage, bytes calldata _data) external;\r\n    /**\r\n     * @notice Upgrade a wallet to a new version.\r\n     * @param _wallet the wallet to upgrade\r\n     * @param _toVersion the new version\r\n     */\r\n    function upgradeWallet(address _wallet, uint256 _toVersion) external;\r\n}\r\n// File: contracts/modules/common/BaseFeature.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.s\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n  \r\n/**\r\n * @title BaseFeature\r\n * @notice Base Feature contract that contains methods common to all Feature contracts.\r\n * @author Julien Niset - <julien@argent.xyz>, Olivier VDB - <olivier@argent.xyz>\r\n */\r\ncontract BaseFeature is IFeature {\r\n    // Empty calldata\r\n    bytes constant internal EMPTY_BYTES = \"\";\r\n    // Mock token address for ETH\r\n    address constant internal ETH_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    // The address of the Lock storage\r\n    ILockStorage internal lockStorage;\r\n    // The address of the Version Manager\r\n    IVersionManager internal versionManager;\r\n    event FeatureCreated(bytes32 name);\r\n    /**\r\n     * @notice Throws if the wallet is locked.\r\n     */\r\n    modifier onlyWhenUnlocked(address _wallet) {\r\n        require(!lockStorage.isLocked(_wallet), \"BF: wallet locked\");\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Throws if the sender is not the VersionManager.\r\n     */\r\n    modifier onlyVersionManager() {\r\n        require(msg.sender == address(versionManager), \"BF: caller must be VersionManager\");\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Throws if the sender is not the owner of the target wallet.\r\n     */\r\n    modifier onlyWalletOwner(address _wallet) {\r\n        require(isOwner(_wallet, msg.sender), \"BF: must be wallet owner\");\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Throws if the sender is not an authorised feature of the target wallet.\r\n     */\r\n    modifier onlyWalletFeature(address _wallet) {\r\n        require(versionManager.isFeatureAuthorised(_wallet, msg.sender), \"BF: must be a wallet feature\");\r\n        _;\r\n    }\r\n    /**\r\n     * @notice Throws if the sender is not the owner of the target wallet or the feature itself.\r\n     */\r\n    modifier onlyWalletOwnerOrFeature(address _wallet) {\r\n        // Wrapping in an internal method reduces deployment cost by avoiding duplication of inlined code\r\n        verifyOwnerOrAuthorisedFeature(_wallet, msg.sender);\r\n        _;\r\n    }\r\n    constructor(\r\n        ILockStorage _lockStorage,\r\n        IVersionManager _versionManager,\r\n        bytes32 _name\r\n    ) public {\r\n        lockStorage = _lockStorage;\r\n        versionManager = _versionManager;\r\n        emit FeatureCreated(_name);\r\n    }\r\n    /**\r\n    * @inheritdoc IFeature\r\n    */\r\n    function recoverToken(address _token) external virtual override {\r\n        uint total = ERC20(_token).balanceOf(address(this));\r\n        _token.call(abi.encodeWithSelector(ERC20(_token).transfer.selector, address(versionManager), total));\r\n    }\r\n    /**\r\n     * @notice Inits the feature for a wallet by doing nothing.\r\n     * @dev !! Overriding methods need make sure `init()` can only be called by the VersionManager !!\r\n     * @param _wallet The wallet.\r\n     */\r\n    function init(address _wallet) external virtual override  {}\r\n    /**\r\n     * @inheritdoc IFeature\r\n     */\r\n    function getRequiredSignatures(address, bytes calldata) external virtual view override returns (uint256, OwnerSignature) {\r\n        revert(\"BF: disabled method\");\r\n    }\r\n    /**\r\n     * @inheritdoc IFeature\r\n     */\r\n    function getStaticCallSignatures() external virtual override view returns (bytes4[] memory _sigs) {}\r\n    /**\r\n     * @inheritdoc IFeature\r\n     */\r\n    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) public override view returns (bool) {\r\n        return versionManager.isFeatureAuthorised(_wallet, _feature);\r\n    }\r\n    /**\r\n    * @notice Checks that the wallet address provided as the first parameter of _data matches _wallet\r\n    * @return false if the addresses are different.\r\n    */\r\n    function verifyData(address _wallet, bytes calldata _data) internal pure returns (bool) {\r\n        require(_data.length >= 36, \"RM: Invalid dataWallet\");\r\n        address dataWallet = abi.decode(_data[4:], (address));\r\n        return dataWallet == _wallet;\r\n    }\r\n     /**\r\n     * @notice Helper method to check if an address is the owner of a target wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _addr The address.\r\n     */\r\n    function isOwner(address _wallet, address _addr) internal view returns (bool) {\r\n        return IWallet(_wallet).owner() == _addr;\r\n    }\r\n    /**\r\n     * @notice Verify that the caller is an authorised feature or the wallet owner.\r\n     * @param _wallet The target wallet.\r\n     * @param _sender The caller.\r\n     */\r\n    function verifyOwnerOrAuthorisedFeature(address _wallet, address _sender) internal view {\r\n        require(isFeatureAuthorisedInVersionManager(_wallet, _sender) || isOwner(_wallet, _sender), \"BF: must be owner or feature\");\r\n    }\r\n    /**\r\n     * @notice Helper method to invoke a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _to The target address for the transaction.\r\n     * @param _value The value of the transaction.\r\n     * @param _data The data of the transaction.\r\n     */\r\n    function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data)\r\n        internal\r\n        returns (bytes memory _res) \r\n    {\r\n        _res = versionManager.checkAuthorisedFeatureAndInvokeWallet(_wallet, _to, _value, _data);\r\n    }\r\n}\r\n// File: modules/VersionManager.sol\r\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n  \r\n/**\r\n * @title VersionManager\r\n * @notice Intermediate contract between features and wallets. VersionManager checks that a calling feature is\r\n * authorised for the wallet and if so, forwards the call to it. Note that VersionManager is meant to be the only\r\n * module authorised on a wallet and because some of its methods need to be called by the RelayerManager feature,\r\n * the VersionManager is both a module AND a feature.\r\n * @author Olivier VDB <olivier@argent.xyz>\r\n */\r\ncontract VersionManager is IVersionManager, IModule, BaseFeature, Owned {\r\n    bytes32 constant NAME = \"VersionManager\";\r\n    bytes4 constant internal ADD_MODULE_PREFIX = bytes4(keccak256(\"addModule(address,address)\"));\r\n    bytes4 constant internal UPGRADE_WALLET_PREFIX = bytes4(keccak256(\"upgradeWallet(address,uint256)\"));\r\n    // Last bundle version\r\n    uint256 public lastVersion;\r\n    // Minimum allowed version\r\n    uint256 public minVersion = 1;\r\n    // Current bundle version for a wallet\r\n    mapping(address => uint256) public walletVersions; // [wallet] => [version]\r\n    // Features per version\r\n    mapping(address => mapping(uint256 => bool)) public isFeatureInVersion; // [feature][version] => bool\r\n    // Features requiring initialization for a wallet\r\n    mapping(uint256 => address[]) public featuresToInit; // [version] => [features]\r\n    // Supported static call signatures\r\n    mapping(uint256 => bytes4[]) public staticCallSignatures; // [version] => [sigs]\r\n    // Features executing static calls\r\n    mapping(uint256 => mapping(bytes4 => address)) public staticCallExecutors; // [version][sig] => [feature]\r\n    // Authorised Storages\r\n    mapping(address => bool) public isStorage; // [storage] => bool\r\n    event VersionAdded(uint256 _version, address[] _features);\r\n    event WalletUpgraded(address indexed _wallet, uint256 _version);\r\n    // The Module Registry\r\n    IModuleRegistry private registry;\r\n    /* ***************** Constructor ************************* */\r\n    constructor(\r\n        IModuleRegistry _registry,\r\n        ILockStorage _lockStorage,\r\n        IGuardianStorage _guardianStorage,\r\n        ITransferStorage _transferStorage,\r\n        ILimitStorage _limitStorage\r\n    )\r\n        BaseFeature(_lockStorage, IVersionManager(address(this)), NAME)\r\n        public\r\n    {\r\n        registry = _registry;\r\n        // Add initial storages\r\n        if(address(_lockStorage) != address(0)) { \r\n            addStorage(address(_lockStorage));\r\n        }\r\n        if(address(_guardianStorage) != address(0)) { \r\n            addStorage(address(_guardianStorage));\r\n        }\r\n        if(address(_transferStorage) != address(0)) {\r\n            addStorage(address(_transferStorage));\r\n        }\r\n        if(address(_limitStorage) != address(0)) {\r\n            addStorage(address(_limitStorage));\r\n        }\r\n    }\r\n    /* ***************** onlyOwner ************************* */\r\n    /**\r\n     * @inheritdoc IFeature\r\n     */\r\n    function recoverToken(address _token) external override onlyOwner {\r\n        uint total = ERC20(_token).balanceOf(address(this));\r\n        _token.call(abi.encodeWithSelector(ERC20(_token).transfer.selector, msg.sender, total));\r\n    }\r\n    /**\r\n     * @notice Lets the owner change the minimum allowed version\r\n     * @param _minVersion the minimum allowed version\r\n     */\r\n    function setMinVersion(uint256 _minVersion) external onlyOwner {\r\n        require(_minVersion > 0 && _minVersion <= lastVersion, \"VM: invalid _minVersion\");\r\n        minVersion = _minVersion;\r\n    }\r\n    /**\r\n     * @notice Lets the owner add a new version, i.e. a new bundle of features.\r\n     * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n     * WARNING: if a feature was added to a version and later on removed from a subsequent version,\r\n     * the feature may no longer be used in any future version without first being redeployed.\r\n     * Otherwise, the feature could be initialized more than once.\r\n     * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n     * @param _features the list of features included in the new version\r\n     * @param _featuresToInit the subset of features that need to be initialized for a wallet\r\n     */\r\n    function addVersion(address[] calldata _features, address[] calldata _featuresToInit) external onlyOwner {\r\n        uint256 newVersion = ++lastVersion;\r\n        for(uint256 i = 0; i < _features.length; i++) {\r\n            isFeatureInVersion[_features[i]][newVersion] = true;\r\n            // Store static call information to optimise its use by wallets\r\n            bytes4[] memory sigs = IFeature(_features[i]).getStaticCallSignatures();\r\n            for(uint256 j = 0; j < sigs.length; j++) {\r\n                staticCallSignatures[newVersion].push(sigs[j]);\r\n                staticCallExecutors[newVersion][sigs[j]] = _features[i];\r\n            }\r\n        }\r\n        // Sanity check\r\n        for(uint256 i = 0; i < _featuresToInit.length; i++) {\r\n            require(isFeatureInVersion[_featuresToInit[i]][newVersion], \"VM: invalid _featuresToInit\");\r\n        }\r\n        featuresToInit[newVersion] = _featuresToInit;\r\n        emit VersionAdded(newVersion, _features);\r\n    }\r\n    /**\r\n     * @notice Lets the owner add a storage contract\r\n     * @param _storage the storage contract to add\r\n     */\r\n    function addStorage(address _storage) public onlyOwner {\r\n        require(!isStorage[_storage], \"VM: storage already added\");\r\n        isStorage[_storage] = true;\r\n    }\r\n    /* ***************** View Methods ************************* */\r\n    /**\r\n     * @inheritdoc IVersionManager\r\n     */\r\n    function isFeatureAuthorised(address _wallet, address _feature) external view override returns (bool) {\r\n        // Note that the VersionManager is the only feature that isn't stored in isFeatureInVersion\r\n        return _isFeatureAuthorisedForWallet(_wallet, _feature) || _feature == address(this);\r\n    }\r\n    /**\r\n     * @inheritdoc IFeature\r\n     */\r\n    function getRequiredSignatures(address /* _wallet */, bytes calldata _data) external view override returns (uint256, OwnerSignature) {\r\n        bytes4 methodId = Utils.functionPrefix(_data);\r\n        // This require ensures that the RelayerManager cannot be used to call a featureOnly VersionManager method\r\n        // that calls a Storage or the BaseWallet for backward-compatibility reason\r\n        require(methodId == UPGRADE_WALLET_PREFIX || methodId == ADD_MODULE_PREFIX, \"VM: unknown method\");     \r\n        return (1, OwnerSignature.Required);\r\n    }\r\n    /* ***************** Static Call Delegation ************************* */\r\n    /**\r\n     * @notice This method is used by the VersionManager's fallback (via an internal call) to determine whether\r\n     * the current transaction is a staticcall or not. The method succeeds if the current transaction is a static call, \r\n     * and reverts otherwise. \r\n     * @dev The use of an if/else allows to encapsulate the whole logic in a single function.\r\n     */\r\n    function verifyStaticCall() public {\r\n        if(msg.sender != address(this)) { // first entry in the method (via an internal call)\r\n            (bool success,) = address(this).call{gas: 3000}(abi.encodeWithSelector(VersionManager(0).verifyStaticCall.selector));\r\n            require(!success, \"VM: not in a staticcall\");\r\n        } else { // second entry in the method (via an external call)\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly { log0(0, 0) }\r\n        }\r\n    }\r\n    /**\r\n     * @notice This method delegates the static call to a target feature\r\n     */\r\n    fallback() external {\r\n        uint256 version = walletVersions[msg.sender];\r\n        address feature = staticCallExecutors[version][msg.sig];\r\n        require(feature != address(0), \"VM: static call not supported for wallet version\");\r\n        verifyStaticCall();\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(gas(), feature, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n            case 0 {revert(0, returndatasize())}\r\n            default {return (0, returndatasize())}\r\n        }\r\n    }\r\n    /* ***************** Wallet Upgrade ************************* */\r\n    /**\r\n     * @inheritdoc IFeature\r\n     */\r\n    function init(address _wallet) public override(IModule, BaseFeature) {}\r\n    /**\r\n     * @inheritdoc IVersionManager\r\n     */\r\n    function upgradeWallet(address _wallet, uint256 _toVersion) external override onlyWhenUnlocked(_wallet) {\r\n        require(\r\n            // Upgrade triggered by the RelayerManager (from version v>=1 to version v'>v)\r\n            _isFeatureAuthorisedForWallet(_wallet, msg.sender) ||\r\n            // Upgrade triggered by WalletFactory or UpgraderToVersionManager (from version v=0 to version v'>0)\r\n            IWallet(_wallet).authorised(msg.sender) ||\r\n            // Upgrade triggered directly by the owner (from version v>=1 to version v'>v)\r\n            isOwner(_wallet, msg.sender), \r\n            \"VM: sender may not upgrade wallet\"\r\n        );\r\n        uint256 fromVersion = walletVersions[_wallet];\r\n        uint256 minVersion_ = minVersion;\r\n        uint256 toVersion;\r\n        if(_toVersion < minVersion_ && fromVersion == 0 && IWallet(_wallet).modules() == 2) {\r\n            // When the caller is the WalletFactory, we automatically change toVersion to minVersion if needed.\r\n            // Note that when fromVersion == 0, the caller could be the WalletFactory or the UpgraderToVersionManager. \r\n            // The WalletFactory will be the only possible caller when the wallet has only 2 authorised modules \r\n            // (that number would be >= 3 for a call from the UpgraderToVersionManager)\r\n            toVersion = minVersion_;\r\n        } else {\r\n            toVersion = _toVersion;\r\n        }\r\n        require(toVersion >= minVersion_ && toVersion <= lastVersion, \"VM: invalid _toVersion\");\r\n        require(fromVersion < toVersion, \"VM: already on new version\");\r\n        walletVersions[_wallet] = toVersion;\r\n        // Setup static call redirection\r\n        bytes4[] storage sigs = staticCallSignatures[toVersion];\r\n        for(uint256 i = 0; i < sigs.length; i++) {\r\n            bytes4 sig = sigs[i];\r\n            if(IWallet(_wallet).enabled(sig) != address(this)) {\r\n                IWallet(_wallet).enableStaticCall(address(this), sig);\r\n            }\r\n        }\r\n        // Init features\r\n        address[] storage featuresToInitInToVersion = featuresToInit[toVersion];\r\n        for(uint256 i = 0; i < featuresToInitInToVersion.length; i++) {\r\n            address feature = featuresToInitInToVersion[i];\r\n            // We only initialize a feature that was not already initialized in the previous version\r\n            if(fromVersion == 0 || !isFeatureInVersion[feature][fromVersion]) {\r\n                IFeature(feature).init(_wallet);\r\n            }\r\n        }\r\n        emit WalletUpgraded(_wallet, toVersion);\r\n    }\r\n    /**\r\n     * @inheritdoc IModule\r\n     */\r\n    function addModule(address _wallet, address _module) external override onlyWalletOwnerOrFeature(_wallet) onlyWhenUnlocked(_wallet) {\r\n        require(registry.isRegisteredModule(_module), \"VM: module is not registered\");\r\n        IWallet(_wallet).authoriseModule(_module, true);\r\n    }\r\n    /* ******* Backward Compatibility with old Storages and BaseWallet *************** */\r\n    /**\r\n     * @inheritdoc IVersionManager\r\n     */\r\n    function checkAuthorisedFeatureAndInvokeWallet(\r\n        address _wallet, \r\n        address _to, \r\n        uint256 _value, \r\n        bytes memory _data\r\n    ) \r\n        external \r\n        override\r\n        returns (bytes memory _res) \r\n    {\r\n        require(_isFeatureAuthorisedForWallet(_wallet, msg.sender), \"VM: sender may not invoke wallet\");\r\n        bool success;\r\n        (success, _res) = _wallet.call(abi.encodeWithSignature(\"invoke(address,uint256,bytes)\", _to, _value, _data));\r\n        if (success && _res.length > 0) { //_res is empty if _wallet is an \"old\" BaseWallet that can't return output values\r\n            (_res) = abi.decode(_res, (bytes));\r\n        } else if (_res.length > 0) {\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                returndatacopy(0, 0, returndatasize())\r\n                revert(0, returndatasize())\r\n            }\r\n        } else if (!success) {\r\n            revert(\"VM: wallet invoke reverted\");\r\n        }\r\n    }\r\n    /**\r\n     * @inheritdoc IVersionManager\r\n     */\r\n    function invokeStorage(address _wallet, address _storage, bytes calldata _data) external override {\r\n        require(_isFeatureAuthorisedForWallet(_wallet, msg.sender), \"VM: sender may not invoke storage\");\r\n        require(verifyData(_wallet, _data), \"VM: target of _data != _wallet\");\r\n        require(isStorage[_storage], \"VM: invalid storage invoked\");\r\n        (bool success,) = _storage.call(_data);\r\n        require(success, \"VM: _storage failed\");\r\n    }\r\n    /**\r\n     * @inheritdoc IVersionManager\r\n     */\r\n    function setOwner(address _wallet, address _newOwner) external override {\r\n        require(_isFeatureAuthorisedForWallet(_wallet, msg.sender), \"VM: sender should be authorized feature\");\r\n        IWallet(_wallet).setOwner(_newOwner);\r\n    }\r\n    /* ***************** Internal Methods ************************* */\r\n    function _isFeatureAuthorisedForWallet(address _wallet, address _feature) private view returns (bool) {\r\n        return isFeatureInVersion[_feature][walletVersions[_wallet]];\r\n    }\r\n}"}}}