{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@eth-optimism/contracts/libraries/bridge/CrossDomainEnabled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"./ICrossDomainMessenger.sol\";\n\n/**\n * @title CrossDomainEnabled\n * @dev Helper contract for contracts performing cross-domain communications\n *\n * Compiler used: defined by inheriting contract\n */\ncontract CrossDomainEnabled {\n    /*************\n     * Variables *\n     *************/\n\n    // Messenger contract used to send and recieve messages from the other domain.\n    address public messenger;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\n     */\n    constructor(address _messenger) {\n        messenger = _messenger;\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Enforces that the modified function is only callable by a specific cross-domain account.\n     * @param _sourceDomainAccount The only account on the originating domain which is\n     *  authenticated to call this function.\n     */\n    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {\n        require(\n            msg.sender == address(getCrossDomainMessenger()),\n            \"OVM_XCHAIN: messenger contract unauthenticated\"\n        );\n\n        require(\n            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,\n            \"OVM_XCHAIN: wrong sender of cross-domain message\"\n        );\n\n        _;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\n     * needs to override.\n     * @return The address of the cross-domain messenger contract which should be used.\n     */\n    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {\n        return ICrossDomainMessenger(messenger);\n    }\n\n    /**q\n     * Sends a message to an account on another domain\n     * @param _crossDomainTarget The intended recipient on the destination domain\n     * @param _message The data to send to the target (usually calldata to a function with\n     *  `onlyFromCrossDomainAccount()`)\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\n     */\n    function sendCrossDomainMessage(\n        address _crossDomainTarget,\n        uint32 _gasLimit,\n        bytes memory _message\n    ) internal {\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/common/implementation/Lockable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\n */\ncontract Lockable {\n    bool private _notEntered;\n\n    constructor() {\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\n        // refund coming into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\n     * function that does the actual state modification.\n     */\n    modifier nonReentrant() {\n        _preEntranceCheck();\n        _preEntranceSet();\n        _;\n        _postEntranceReset();\n    }\n\n    /**\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\n     */\n    modifier nonReentrantView() {\n        _preEntranceCheck();\n        _;\n    }\n\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\n    // then call `_postEntranceReset()`.\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\n    function _preEntranceCheck() internal view {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n    }\n\n    function _preEntranceSet() internal {\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n    }\n\n    function _postEntranceReset() internal {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/Optimism_ParentMessenger.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// This should be replaced with a \"real\" import when Optimism release their new contract versions.\nimport \"@eth-optimism/contracts/libraries/bridge/CrossDomainEnabled.sol\";\nimport \"../interfaces/ParentMessengerInterface.sol\";\nimport \"../interfaces/ParentMessengerConsumerInterface.sol\";\nimport \"./ParentMessengerBase.sol\";\nimport \"../../common/implementation/Lockable.sol\";\n\n/**\n * @notice Sends cross chain messages from Ethereum L1 to Optimism L2 network.\n * @dev This contract is ownable and should be owned by the DVM governor.\n */\ncontract Optimism_ParentMessenger is CrossDomainEnabled, ParentMessengerInterface, ParentMessengerBase, Lockable {\n    event SetDefaultGasLimit(uint32 newDefaultGasLimit);\n    event MessageSentToChild(bytes data, address indexed targetSpoke, uint32 gasLimit, address indexed childMessenger);\n    event MessageReceivedFromChild(bytes data, address indexed childMessenger, address indexed targetHub);\n\n    uint32 public defaultGasLimit = 5_000_000;\n\n    /**\n     * @notice Construct the Optimism_ParentMessenger contract.\n     * @param _crossDomainMessenger The address of the Optimism cross domain messenger contract.\n     * @param _childChainId The chain id of the Optimism L2 network this messenger should connect to.\n     **/\n    constructor(address _crossDomainMessenger, uint256 _childChainId)\n        CrossDomainEnabled(_crossDomainMessenger)\n        ParentMessengerBase(_childChainId)\n    {}\n\n    /**\n     * @notice Changes the default gas limit that is sent along with transactions to Optimism.\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\n     * @param newDefaultGasLimit the new L2 gas limit to be set.\n     */\n    function setDefaultGasLimit(uint32 newDefaultGasLimit) public onlyOwner nonReentrant() {\n        defaultGasLimit = newDefaultGasLimit;\n        emit SetDefaultGasLimit(newDefaultGasLimit);\n    }\n\n    /**\n     * @notice Changes the address of the oracle spoke on L2 via the child messenger.\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\n     * @param newOracleSpoke the new oracle spoke address set on L2.\n     */\n    function setChildOracleSpoke(address newOracleSpoke) public onlyOwner nonReentrant() {\n        bytes memory dataSentToChild = abi.encodeWithSignature(\"setOracleSpoke(address)\", newOracleSpoke);\n        sendCrossDomainMessage(childMessenger, defaultGasLimit, dataSentToChild);\n        emit MessageSentToChild(dataSentToChild, address(0), defaultGasLimit, childMessenger);\n    }\n\n    /**\n     * @notice Changes the address of the parent messenger on L2 via the child messenger.\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\n     * @param newParentMessenger the new parent messenger contract to be set on L2.\n     */\n    function setChildParentMessenger(address newParentMessenger) public onlyOwner nonReentrant() {\n        bytes memory dataSentToChild = abi.encodeWithSignature(\"setParentMessenger(address)\", newParentMessenger);\n        sendCrossDomainMessage(childMessenger, defaultGasLimit, dataSentToChild);\n        emit MessageSentToChild(dataSentToChild, address(0), defaultGasLimit, childMessenger);\n    }\n\n    /**\n     * @notice Changes the Optimism_ChildMessenger default gas limit on L2 via the child messenger.\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\n     * @param newDefaultGasLimit the new default gas limit set on L2.\n     */\n    function setChildDefaultGasLimit(uint32 newDefaultGasLimit) public onlyOwner nonReentrant() {\n        bytes memory dataSentToChild = abi.encodeWithSignature(\"setDefaultGasLimit(uint32)\", newDefaultGasLimit);\n        sendCrossDomainMessage(childMessenger, defaultGasLimit, dataSentToChild);\n        emit MessageSentToChild(dataSentToChild, address(0), defaultGasLimit, childMessenger);\n    }\n\n    /**\n     * @notice Sends a message to the child messenger via the canonical message bridge.\n     * @dev The caller must be the either the OracleHub or the GovernorHub. This is to send either a\n     * price or initiate a governance action to the OracleSpoke or GovernorSpoke on the child network.\n     * @dev The recipient of this message is the child messenger. The messenger must implement processMessageFromParent\n     * which then forwards the data to the target either the OracleSpoke or the governorSpoke depending on the caller.\n     * @param data data message sent to the child messenger. Should be an encoded function call or packed data.\n     */\n    function sendMessageToChild(bytes memory data) public override onlyHubContract() nonReentrant() {\n        address target = msg.sender == oracleHub ? oracleSpoke : governorSpoke;\n        bytes memory dataSentToChild =\n            abi.encodeWithSignature(\"processMessageFromCrossChainParent(bytes,address)\", data, target);\n        sendCrossDomainMessage(childMessenger, defaultGasLimit, dataSentToChild);\n        emit MessageSentToChild(dataSentToChild, target, defaultGasLimit, childMessenger);\n    }\n\n    /**\n     * @notice Process a received message from the child messenger via the canonical message bridge.\n     * @dev The caller must be the the child messenger, sent over the canonical message bridge.\n     * @dev Note that only the OracleHub can receive messages from the child messenger. Therefore we can always forward\n     * these messages to this contract. The OracleHub must implement processMessageFromChild to handle this message.\n     * @param data data message sent from the child messenger. Should be an encoded function call or packed data.\n     */\n    function processMessageFromCrossChainChild(bytes memory data)\n        public\n        onlyFromCrossDomainAccount(childMessenger)\n        nonReentrant()\n    {\n        ParentMessengerConsumerInterface(oracleHub).processMessageFromChild(childChainId, data);\n        emit MessageReceivedFromChild(data, childMessenger, oracleHub);\n    }\n}\n"
    },
    "contracts/cross-chain-oracle/chain-adapters/ParentMessengerBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ParentMessengerInterface.sol\";\n\nabstract contract ParentMessengerBase is Ownable, ParentMessengerInterface {\n    uint256 public childChainId;\n\n    address public childMessenger;\n\n    address public oracleHub;\n    address public governorHub;\n\n    address public oracleSpoke;\n    address public governorSpoke;\n\n    event SetChildMessenger(address indexed childMessenger);\n    event SetOracleHub(address indexed oracleHub);\n    event SetGovernorHub(address indexed governorHub);\n    event SetOracleSpoke(address indexed oracleSpoke);\n    event SetGovernorSpoke(address indexed governorSpoke);\n\n    modifier onlyHubContract() {\n        require(msg.sender == oracleHub || msg.sender == governorHub, \"Only privileged caller\");\n        _;\n    }\n\n    /**\n     * @notice Construct the ParentMessengerBase contract.\n     * @param _childChainId The chain id of the L2 network this messenger should connect to.\n     **/\n    constructor(uint256 _childChainId) {\n        childChainId = _childChainId;\n    }\n\n    /*******************\n     *  OWNER METHODS  *\n     *******************/\n\n    /**\n     * @notice Changes the stored address of the child messenger, deployed on L2.\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\n     * @param newChildMessenger address of the new child messenger, deployed on L2.\n     */\n    function setChildMessenger(address newChildMessenger) public onlyOwner {\n        childMessenger = newChildMessenger;\n        emit SetChildMessenger(childMessenger);\n    }\n\n    /**\n     * @notice Changes the stored address of the Oracle hub, deployed on L1.\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\n     * @param newOracleHub address of the new oracle hub, deployed on L1 Ethereum.\n     */\n    function setOracleHub(address newOracleHub) public onlyOwner {\n        oracleHub = newOracleHub;\n        emit SetOracleHub(oracleHub);\n    }\n\n    /**\n     * @notice Changes the stored address of the Governor hub, deployed on L1.\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\n     * @param newGovernorHub address of the new governor hub, deployed on L1 Ethereum.\n     */\n    function setGovernorHub(address newGovernorHub) public onlyOwner {\n        governorHub = newGovernorHub;\n        emit SetGovernorHub(governorHub);\n    }\n\n    /**\n     * @notice Changes the stored address of the oracle spoke, deployed on L2.\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\n     * @param newOracleSpoke address of the new oracle spoke, deployed on L2.\n     */\n    function setOracleSpoke(address newOracleSpoke) public onlyOwner {\n        oracleSpoke = newOracleSpoke;\n        emit SetOracleSpoke(oracleSpoke);\n    }\n\n    /**\n     * @notice Changes the stored address of the governor spoke, deployed on L2.\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\n     * @param newGovernorSpoke address of the new governor spoke, deployed on L2.\n     */\n    function setGovernorSpoke(address newGovernorSpoke) public onlyOwner {\n        governorSpoke = newGovernorSpoke;\n        emit SetGovernorSpoke(governorSpoke);\n    }\n\n    /**\n     * @notice Returns the amount of ETH required for a caller to pass as msg.value when calling `sendMessageToChild`.\n     * @return The amount of ETH required for a caller to pass as msg.value when calling `sendMessageToChild`.\n     */\n    function getL1CallValue() external view virtual override returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/cross-chain-oracle/interfaces/ParentMessengerConsumerInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface ParentMessengerConsumerInterface {\n    // Function called on Oracle hub to pass in data send from L2, with chain ID.\n    function processMessageFromChild(uint256 chainId, bytes memory data) external;\n}\n"
    },
    "contracts/cross-chain-oracle/interfaces/ParentMessengerInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface ParentMessengerInterface {\n    // Should send cross-chain message to Child messenger contract or revert.\n    function sendMessageToChild(bytes memory data) external;\n\n    // Informs Hub how much msg.value they need to include to call `sendMessageToChild`.\n    function getL1CallValue() external view returns (uint256);\n}\n"
    }
  }
}