{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Governor.sol":{"content":"/*\n * Origin Protocol\n * https://originprotocol.com\n *\n * Released under the MIT license\n * https://github.com/OriginProtocol/origin-dollar\n *\n * Copyright 2020 Origin Protocol, Inc\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts/timelock/Timelock.sol\n\npragma solidity 0.5.11;\n\n/**\n * @title OUSD Timelock Contract\n * @author Origin Protocol Inc\n */\n\ninterface CapitalPausable {\n    function pauseCapital() external;\n\n    function unpauseCapital() external;\n}\n\ncontract Timelock {\n    using SafeMath for uint256;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    uint256 public constant GRACE_PERIOD = 3 days;\n    uint256 public constant MINIMUM_DELAY = 1 minutes;\n    uint256 public constant MAXIMUM_DELAY = 2 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    constructor(address admin_, uint256 delay_) public {\n        require(\n            delay_ >= MINIMUM_DELAY,\n            \"Timelock::constructor: Delay must exceed minimum delay.\"\n        );\n        require(\n            delay_ <= MAXIMUM_DELAY,\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n        );\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    function setDelay(uint256 delay_) public {\n        require(\n            msg.sender == address(this),\n            \"Timelock::setDelay: Call must come from Timelock.\"\n        );\n        require(\n            delay_ >= MINIMUM_DELAY,\n            \"Timelock::setDelay: Delay must exceed minimum delay.\"\n        );\n        require(\n            delay_ <= MAXIMUM_DELAY,\n            \"Timelock::setDelay: Delay must not exceed maximum delay.\"\n        );\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(\n            msg.sender == pendingAdmin,\n            \"Timelock::acceptAdmin: Call must come from pendingAdmin.\"\n        );\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(\n            msg.sender == address(this),\n            \"Timelock::setPendingAdmin: Call must come from Timelock.\"\n        );\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal returns (bytes32) {\n        require(\n            msg.sender == admin,\n            \"Timelock::queueTransaction: Call must come from admin.\"\n        );\n        require(\n            eta >= getBlockTimestamp().add(delay),\n            \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n        );\n\n        bytes32 txHash = keccak256(\n            abi.encode(target, signature, keccak256(data), eta)\n        );\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            msg.sender == admin,\n            \"Timelock::cancelTransaction: Call must come from admin.\"\n        );\n\n        bytes32 txHash = keccak256(\n            abi.encode(target, signature, keccak256(data), eta)\n        );\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal returns (bytes memory) {\n        require(\n            msg.sender == admin,\n            \"Timelock::executeTransaction: Call must come from admin.\"\n        );\n\n        bytes32 txHash = keccak256(\n            abi.encode(target, signature, keccak256(data), eta)\n        );\n        require(\n            queuedTransactions[txHash],\n            \"Timelock::executeTransaction: Transaction hasn't been queued.\"\n        );\n        require(\n            getBlockTimestamp() >= eta,\n            \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\n        );\n        require(\n            getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n            \"Timelock::executeTransaction: Transaction is stale.\"\n        );\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(\n                bytes4(keccak256(bytes(signature))),\n                data\n            );\n        }\n\n        (bool success, bytes memory returnData) = target.call(callData);\n        require(\n            success,\n            \"Timelock::executeTransaction: Transaction execution reverted.\"\n        );\n\n        emit ExecuteTransaction(txHash, target, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n\n    function pauseCapital(address target) external {\n        require(\n            msg.sender == admin,\n            \"Timelock::pauseCapital: Call must come from admin.\"\n        );\n        CapitalPausable(target).pauseCapital();\n    }\n\n    function unpauseCapital(address target) external {\n        require(\n            msg.sender == admin,\n            \"Timelock::unpauseCapital: Call must come from admin.\"\n        );\n        CapitalPausable(target).unpauseCapital();\n    }\n}\n\n// File: contracts/governance/Governor.sol\n\npragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\n// Modeled off of Compound's Governor Alpha\n//    https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\ncontract Governor is Timelock {\n    // @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // @notice Unique id for looking up a proposal\n        uint256 id;\n        // @notice Creator of the proposal\n        address proposer;\n        // @notice The timestamp that the proposal will be available for\n        // execution, set once the vote succeeds\n        uint256 eta;\n        // @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        // @notice The ordered list of function signatures to be called\n        string[] signatures;\n        // @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        // @notice Flag marking whether the proposal has been executed\n        bool executed;\n    }\n\n    // @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    // @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        string[] signatures,\n        bytes[] calldatas,\n        string description\n    );\n\n    // @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    // @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    // @notice An event emitted when a proposal has been cancelled\n    event ProposalCancelled(uint256 id);\n\n    uint256 public constant MAX_OPERATIONS = 16;\n\n    // @notice Possible states that a proposal may be in\n    enum ProposalState { Pending, Queued, Expired, Executed }\n\n    /**\n     * @dev Throws if called by any account other than the Admin.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Caller is not the admin\");\n        _;\n    }\n\n    bytes32 public constant setPendingAdminSign = keccak256(\n        bytes(\"setPendingAdmin(address)\")\n    );\n\n    constructor(address admin_, uint256 delay_)\n        public\n        Timelock(admin_, delay_)\n    {}\n\n    /**\n     * @notice Propose Governance call(s)\n     * @param targets Ordered list of targeted addresses\n     * @param signatures Orderd list of function signatures to be called\n     * @param calldatas Orderded list of calldata to be passed with each call\n     * @param description Description of the governance\n     * @return uint256 id of the proposal\n     */\n    function propose(\n        address[] memory targets,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        // Allow anyone to propose for now, since only admin can queue the\n        // transaction it should be harmless, you just need to pay the gas\n        require(\n            targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            \"Governor::propose: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"Governor::propose: must provide actions\");\n        require(\n            targets.length <= MAX_OPERATIONS,\n            \"Governor::propose: too many actions\"\n        );\n\n        for (uint256 i = 0; i < signatures.length; i++) {\n            require(\n                keccak256(bytes(signatures[i])) != setPendingAdminSign,\n                \"Governor::propose: setPendingAdmin transaction cannot be proposed or queued\"\n            );\n        }\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n            id: proposalCount,\n            proposer: msg.sender,\n            eta: 0,\n            targets: targets,\n            signatures: signatures,\n            calldatas: calldatas,\n            executed: false\n        });\n\n        proposals[newProposal.id] = newProposal;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            signatures,\n            calldatas,\n            description\n        );\n        return newProposal.id;\n    }\n\n    /**\n     * @notice Queue a proposal for execution\n     * @param proposalId id of the proposal to queue\n     */\n    function queue(uint256 proposalId) public onlyAdmin {\n        require(\n            state(proposalId) == ProposalState.Pending,\n            \"Governor::queue: proposal can only be queued if it is pending\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.eta = block.timestamp.add(delay);\n\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(\n                proposal.targets[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalQueued(proposal.id, proposal.eta);\n    }\n\n    /**\n     * @notice Get the state of a proposal\n     * @param proposalId id of the proposal\n     * @return ProposalState\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > 0,\n            \"Governor::state: invalid proposal id\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Pending;\n        } else if (block.timestamp >= proposal.eta.add(GRACE_PERIOD)) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    function _queueOrRevert(\n        address target,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !queuedTransactions[keccak256(\n                abi.encode(target, signature, keccak256(data), eta)\n            )],\n            \"Governor::_queueOrRevert: proposal action already queued at eta\"\n        );\n        require(\n            queuedTransactions[queueTransaction(target, signature, data, eta)],\n            \"Governor::_queueOrRevert: failed to queue transaction\"\n        );\n    }\n\n    /**\n     * @notice Execute a proposal.\n     * @param proposalId id of the proposal\n     */\n    function execute(uint256 proposalId) public {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            \"Governor::execute: proposal can only be executed if it is queued\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            executeTransaction(\n                proposal.targets[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Cancel a proposal.\n     * @param proposalId id of the proposal\n     */\n    function cancel(uint256 proposalId) public onlyAdmin {\n        ProposalState proposalState = state(proposalId);\n\n        require(\n            proposalState == ProposalState.Queued ||\n                proposalState == ProposalState.Pending,\n            \"Governor::execute: proposal can only be cancelled if it is queued or pending\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.eta = 1; // To mark the proposal as `Expired`\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            cancelTransaction(\n                proposal.targets[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalCancelled(proposalId);\n    }\n\n    /**\n     * @notice Get the actions that a proposal will take.\n     * @param proposalId id of the proposal\n     */\n    function getActions(uint256 proposalId)\n        public\n        view\n        returns (\n            address[] memory targets,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.signatures, p.calldatas);\n    }\n}\n"}}}