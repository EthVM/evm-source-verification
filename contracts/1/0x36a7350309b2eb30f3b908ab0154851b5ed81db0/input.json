{
  "language": "Solidity",
  "sources": {
    "MapleLoanFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity =0.8.7;\n\ninterface IMapleGlobalsLike {\n\n    function governor() external view returns (address governor_);\n\n}\n\ninterface IMapleProxiedLike {\n\n    function implementation() external view returns (address implementation_);\n\n}\n\ninterface IProxiedLike {\n\n    function implementation() external view returns (address implementation_);\n\n    function setImplementation(address newImplementation_) external;\n\n    function migrate(address migrator_, bytes calldata arguments_) external;\n\n}\n\n/// @title An beacon that provides a default implementation for proxies, must implement IDefaultImplementationBeacon.\ninterface IDefaultImplementationBeacon {\n\n    /// @dev The address of an implementation for proxies.\n    function defaultImplementation() external view returns (address defaultImplementation_);\n\n}\n\n/// @title A Maple factory for Proxy contracts that proxy MapleProxied implementations.\ninterface IMapleProxyFactory is IDefaultImplementationBeacon {\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    /**\n     *  @dev   A default version was set.\n     *  @param version_ The default version.\n     */\n    event DefaultVersionSet(uint256 indexed version_);\n\n    /**\n     *  @dev   A version of an implementation, at some address, was registered, with an optional initializer.\n     *  @param version_               The version registered.\n     *  @param implementationAddress_ The address of the implementation.\n     *  @param initializer_           The address of the initializer, if any.\n     */\n    event ImplementationRegistered(uint256 indexed version_, address indexed implementationAddress_, address indexed initializer_);\n\n    /**\n     *  @dev   A proxy contract was deployed with some initialization arguments.\n     *  @param version_                 The version of the implementation being proxied by the deployed proxy contract.\n     *  @param instance_                The address of the proxy contract deployed.\n     *  @param initializationArguments_ The arguments used to initialize the proxy contract, if any.\n     */\n    event InstanceDeployed(uint256 indexed version_, address indexed instance_, bytes initializationArguments_);\n\n    /**\n     *  @dev   A instance has upgraded by proxying to a new implementation, with some migration arguments.\n     *  @param instance_           The address of the proxy contract.\n     *  @param fromVersion_        The initial implementation version being proxied.\n     *  @param toVersion_          The new implementation version being proxied.\n     *  @param migrationArguments_ The arguments used to migrate, if any.\n     */\n    event InstanceUpgraded(address indexed instance_, uint256 indexed fromVersion_, uint256 indexed toVersion_, bytes migrationArguments_);\n\n    /**\n     *  @dev   The MapleGlobals was set.\n     *  @param mapleGlobals_ The address of a Maple Globals contract.\n     */\n    event MapleGlobalsSet(address indexed mapleGlobals_);\n\n    /**\n     *  @dev   An upgrade path was disabled, with an optional migrator contract.\n     *  @param fromVersion_ The starting version of the upgrade path.\n     *  @param toVersion_   The destination version of the upgrade path.\n     */\n    event UpgradePathDisabled(uint256 indexed fromVersion_, uint256 indexed toVersion_);\n\n    /**\n     *  @dev   An upgrade path was enabled, with an optional migrator contract.\n     *  @param fromVersion_ The starting version of the upgrade path.\n     *  @param toVersion_   The destination version of the upgrade path.\n     *  @param migrator_    The address of the migrator, if any.\n     */\n    event UpgradePathEnabled(uint256 indexed fromVersion_, uint256 indexed toVersion_, address indexed migrator_);\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    /**\n     *  @dev The default version.\n     */\n    function defaultVersion() external view returns (uint256 defaultVersion_);\n\n    /**\n     *  @dev The address of the MapleGlobals contract.\n     */\n    function mapleGlobals() external view returns (address mapleGlobals_);\n\n    /**\n     *  @dev    Whether the upgrade is enabled for a path from a version to another version.\n     *  @param  toVersion_   The initial version.\n     *  @param  fromVersion_ The destination version.\n     *  @return allowed_     Whether the upgrade is enabled.\n     */\n    function upgradeEnabledForPath(uint256 toVersion_, uint256 fromVersion_) external view returns (bool allowed_);\n\n    /********************************/\n    /*** State Changing Functions ***/\n    /********************************/\n\n    /**\n     *  @dev    Deploys a new instance proxying the default implementation version, with some initialization arguments.\n     *          Uses a nonce and `msg.sender` as a salt for the CREATE2 opcode during instantiation to produce deterministic addresses.\n     *  @param  arguments_ The initialization arguments to use for the instance deployment, if any.\n     *  @param  salt_      The salt to use in the contract creation process.\n     *  @return instance_  The address of the deployed proxy contract.\n     */\n    function createInstance(bytes calldata arguments_, bytes32 salt_) external returns (address instance_);\n\n    /**\n     *  @dev   Enables upgrading from a version to a version of an implementation, with an optional migrator.\n     *         Only the Governor can call this function.\n     *  @param fromVersion_ The starting version of the upgrade path.\n     *  @param toVersion_   The destination version of the upgrade path.\n     *  @param migrator_    The address of the migrator, if any.\n     */\n    function enableUpgradePath(uint256 fromVersion_, uint256 toVersion_, address migrator_) external;\n\n    /**\n     *  @dev   Disables upgrading from a version to a version of a implementation.\n     *         Only the Governor can call this function.\n     *  @param fromVersion_ The starting version of the upgrade path.\n     *  @param toVersion_   The destination version of the upgrade path.\n     */\n    function disableUpgradePath(uint256 fromVersion_, uint256 toVersion_) external;\n\n    /**\n     *  @dev   Registers the address of an implementation contract as a version, with an optional initializer.\n     *         Only the Governor can call this function.\n     *  @param version_               The version to register.\n     *  @param implementationAddress_ The address of the implementation.\n     *  @param initializer_           The address of the initializer, if any.\n     */\n    function registerImplementation(uint256 version_, address implementationAddress_, address initializer_) external;\n\n    /**\n     *  @dev   Sets the default version.\n     *         Only the Governor can call this function.\n     *  @param version_ The implementation version to set as the default.\n     */\n    function setDefaultVersion(uint256 version_) external;\n\n    /**\n     *  @dev   Sets the Maple Globals contract.\n     *         Only the Governor can call this function.\n     *  @param mapleGlobals_ The address of a Maple Globals contract.\n     */\n    function setGlobals(address mapleGlobals_) external;\n\n    /**\n     *  @dev   Upgrades the calling proxy contract's implementation, with some migration arguments.\n     *  @param toVersion_ The implementation version to upgrade the proxy contract to.\n     *  @param arguments_ The migration arguments, if any.\n     */\n    function upgradeInstance(uint256 toVersion_, bytes calldata arguments_) external;\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /**\n     *  @dev    Returns the deterministic address of a potential proxy, given some arguments and salt.\n     *  @param  arguments_       The initialization arguments to be used when deploying the proxy.\n     *  @param  salt_            The salt to be used when deploying the proxy.\n     *  @return instanceAddress_ The deterministic address of a potential proxy.\n     */\n    function getInstanceAddress(bytes calldata arguments_, bytes32 salt_) external view returns (address instanceAddress_);\n\n    /**\n     *  @dev    Returns the address of an implementation version.\n     *  @param  version_        The implementation version.\n     *  @return implementation_ The address of the implementation.\n     */\n    function implementationOf(uint256 version_) external view returns (address implementation_);\n\n    /**\n     *  @dev    Returns the address of a migrator contract for a migration path (from version, to version).\n     *          If oldVersion_ == newVersion_, the migrator is an initializer.\n     *  @param  oldVersion_ The old version.\n     *  @param  newVersion_ The new version.\n     *  @return migrator_   The address of a migrator contract.\n     */\n    function migratorForPath(uint256 oldVersion_, uint256 newVersion_) external view returns (address migrator_);\n\n    /**\n     *  @dev    Returns the version of an implementation contract.\n     *  @param  implementation_ The address of an implementation contract.\n     *  @return version_        The version of the implementation contract.\n     */\n    function versionOf(address implementation_) external view returns (uint256 version_);\n\n}\n\n/// @title MapleLoanFactory deploys Loan instances.\ninterface IMapleLoanFactory is IMapleProxyFactory {\n\n    /**\n     *  @dev    Whether the proxy is a MapleLoan deployed by this factory.\n     *  @param  proxy_  The address of the proxy contract.\n     *  @return isLoan_ Whether the proxy is a MapleLoan deployed by this factory.\n     */\n    function isLoan(address proxy_) external view returns (bool isLoan_);\n\n}\n\nabstract contract SlotManipulatable {\n\n    function _getReferenceTypeSlot(bytes32 slot_, bytes32 key_) internal pure returns (bytes32 value_) {\n        return keccak256(abi.encodePacked(key_, slot_));\n    }\n\n    function _getSlotValue(bytes32 slot_) internal view returns (bytes32 value_) {\n        assembly {\n            value_ := sload(slot_)\n        }\n    }\n\n    function _setSlotValue(bytes32 slot_, bytes32 value_) internal {\n        assembly {\n            sstore(slot_, value_)\n        }\n    }\n\n}\n\n/// @title A completely transparent, and thus interface-less, proxy contract.\ncontract Proxy is SlotManipulatable {\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.factory') - 1`.\n    bytes32 private constant FACTORY_SLOT = bytes32(0x7a45a402e4cb6e08ebc196f20f66d5d30e67285a2a8aa80503fa409e727a4af1);\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 private constant IMPLEMENTATION_SLOT = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    /**\n     *  @dev   The constructor requires at least one of `factory_` or `implementation_`.\n     *         If an implementation is not provided, the factory is treated as an IDefaultImplementationBeacon to fetch the default implementation.\n     *  @param factory_        The address of a proxy factory, if any.\n     *  @param implementation_ The address of the implementation contract being proxied, if any.\n     */\n    constructor(address factory_, address implementation_) {\n        _setSlotValue(FACTORY_SLOT, bytes32(uint256(uint160(factory_))));\n\n        // If the implementation is empty, fetch it from the factory, which can act as a beacon.\n        address implementation = implementation_ == address(0) ? IDefaultImplementationBeacon(factory_).defaultImplementation() : implementation_;\n\n        require(implementation != address(0));\n\n        _setSlotValue(IMPLEMENTATION_SLOT, bytes32(uint256(uint160(implementation))));\n    }\n\n    fallback() payable external virtual {\n        bytes32 implementation = _getSlotValue(IMPLEMENTATION_SLOT);\n\n        require(address(uint160(uint256(implementation))).code.length != uint256(0));\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n}\n\n/// @title A factory for Proxy contracts that proxy Proxied implementations.\nabstract contract ProxyFactory {\n\n    mapping(uint256 => address) internal _implementationOf;\n\n    mapping(address => uint256) internal _versionOf;\n\n    mapping(uint256 => mapping(uint256 => address)) internal _migratorForPath;\n\n    /// @dev Returns the implementation of `proxy_`.\n    function _getImplementationOfProxy(address proxy_) private view returns (bool success_, address implementation_) {\n        bytes memory returnData;\n        // Since `_getImplementationOfProxy` is a private function, no need to check `proxy_` is a contract.\n        ( success_, returnData ) = proxy_.staticcall(abi.encodeWithSelector(IProxiedLike.implementation.selector));\n        implementation_ = abi.decode(returnData, (address));\n    }\n\n    /// @dev Initializes `proxy_` using the initializer for `version_`, given some initialization arguments.\n    function _initializeInstance(address proxy_, uint256 version_, bytes memory arguments_) private returns (bool success_) {\n        // The migrator, where fromVersion == toVersion, is an initializer.\n        address initializer = _migratorForPath[version_][version_];\n\n        // If there is no initializer, then no initialization is necessary, so long as no initialization arguments were provided.\n        if (initializer == address(0)) return arguments_.length == uint256(0);\n\n        // Call the migrate function on the proxy, passing any initialization arguments.\n        // Since `_initializeInstance` is a private function, no need to check `proxy_` is a contract.\n        ( success_, ) = proxy_.call(abi.encodeWithSelector(IProxiedLike.migrate.selector, initializer, arguments_));\n    }\n\n    /// @dev Deploys a new proxy for some version, with some initialization arguments, using `create` (i.e. factory's nonce determines the address).\n    function _newInstance(uint256 version_, bytes memory arguments_) internal virtual returns (bool success_, address proxy_) {\n        address implementation = _implementationOf[version_];\n\n        if (implementation == address(0)) return (false, address(0));\n\n        proxy_   = address(new Proxy(address(this), implementation));\n        success_ = _initializeInstance(proxy_, version_, arguments_);\n    }\n\n    /// @dev Deploys a new proxy, with some initialization arguments, using `create2` (i.e. salt determines the address).\n    ///      This factory needs to be IDefaultImplementationBeacon, since the proxy will pull its implementation from it.\n    function _newInstance(bytes memory arguments_, bytes32 salt_) internal virtual returns (bool success_, address proxy_) {\n        proxy_ = address(new Proxy{ salt: salt_ }(address(this), address(0)));\n\n        // Fetch the implementation from the proxy. Don't care about success, since the version of the implementation will be checked in the next step.\n        ( , address implementation ) = _getImplementationOfProxy(proxy_);\n\n        // Get the version of the implementation.\n        uint256 version = _versionOf[implementation];\n\n        // Successful if version is nonzero (i.e. implementation fetched successfully from proxy) and initializing the instance succeeds.\n        success_ = (version != uint256(0)) && _initializeInstance(proxy_, version, arguments_);\n    }\n\n    /// @dev Registers an implementation for some version.\n    function _registerImplementation(uint256 version_, address implementation_) internal virtual returns (bool success_) {\n        // Version 0 is not allowed since its the default value of all _versionOf[implementation_].\n        // Implementation cannot already be registered and cannot be empty account (and thus also not address(0)).\n        if (\n            version_ == uint256(0) ||\n            _implementationOf[version_] != address(0) ||\n            _versionOf[implementation_] != uint256(0) ||\n            !_isContract(implementation_)\n        ) return false;\n\n        // Store in two-way mappings.\n        _implementationOf[version_] = implementation_;\n        _versionOf[implementation_] = version_;\n\n        return true;\n    }\n\n    /// @dev Registers a migrator for between two versions. If `fromVersion_ == toVersion_`, migrator is an initializer.\n    function _registerMigrator(uint256 fromVersion_, uint256 toVersion_, address migrator_) internal virtual returns (bool success_) {\n        // Version 0 is invalid.\n        if (fromVersion_ == uint256(0) || toVersion_ == uint256(0)) return false;\n\n        // Migrator must either be zero (clearing) or a contract (setting).\n        if (migrator_ != address(0) && !_isContract(migrator_)) return false;\n\n        _migratorForPath[fromVersion_][toVersion_] = migrator_;\n\n        return true;\n    }\n\n    /// @dev Upgrades a proxy to a new version of an implementation, with some migration arguments.\n    ///      Inheritor should revert on `success_ = false`, since proxy can be set to new implementation, but failed to migrate.\n    function _upgradeInstance(address proxy_, uint256 toVersion_, bytes memory arguments_) internal virtual returns (bool success_) {\n        // Check that the proxy is currently a contract, just once, ahead of the 3 times it will be low-level-called.\n        if (!_isContract(proxy_)) return false;\n\n        address toImplementation = _implementationOf[toVersion_];\n\n        // The implementation being migrated must have been registered (which also implies that `toVersion_` was not 0).\n        if (toImplementation == address(0)) return false;\n\n        // Fetch the implementation from the proxy.\n        address fromImplementation;\n        ( success_, fromImplementation ) = _getImplementationOfProxy(proxy_);\n\n        if (!success_) return false;\n\n        // Set the proxy's implementation.\n        ( success_, ) = proxy_.call(abi.encodeWithSelector(IProxiedLike.setImplementation.selector, toImplementation));\n\n        if (!success_) return false;\n\n        // Get the version of the `fromImplementation`, then get the `migrator` of the upgrade path to `toVersion_`.\n        address migrator = _migratorForPath[_versionOf[fromImplementation]][toVersion_];\n\n        // If there is no migrator, then no migration is necessary, so long as no migration arguments were provided.\n        if (migrator == address(0)) return arguments_.length == uint256(0);\n\n        // Call the migrate function on the proxy, passing any migration arguments.\n        ( success_, ) = proxy_.call(abi.encodeWithSelector(IProxiedLike.migrate.selector, migrator, arguments_));\n    }\n\n    /// @dev Returns the deterministic address of a proxy given some salt.\n    function _getDeterministicProxyAddress(bytes32 salt_) internal virtual view returns (address deterministicProxyAddress_) {\n        // See https://docs.soliditylang.org/en/v0.8.7/control-structures.html#salted-contract-creations-create2\n        return address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xff),\n                            address(this),\n                            salt_,\n                            keccak256(abi.encodePacked(type(Proxy).creationCode, abi.encode(address(this), address(0))))\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /// @dev Returns whether the account is currently a contract.\n    function _isContract(address account_) internal view returns (bool isContract_) {\n        return account_.code.length != uint256(0);\n    }\n\n}\n\n/// @title A Maple factory for Proxy contracts that proxy MapleProxied implementations.\ncontract MapleProxyFactory is IMapleProxyFactory, ProxyFactory {\n\n    address public override mapleGlobals;\n\n    uint256 public override defaultVersion;\n\n    mapping(uint256 => mapping(uint256 => bool)) public override upgradeEnabledForPath;\n\n    /// @param mapleGlobals_ The address of a Maple Globals contract.\n    constructor(address mapleGlobals_) {\n        require(IMapleGlobalsLike(mapleGlobals = mapleGlobals_).governor() != address(0), \"MPF:C:INVALID_GLOBALS\");\n    }\n\n    modifier onlyGovernor() {\n        require(msg.sender == IMapleGlobalsLike(mapleGlobals).governor(), \"MPF:NOT_GOVERNOR\");\n        _;\n    }\n\n    /********************************/\n    /*** Administrative Functions ***/\n    /********************************/\n\n    function disableUpgradePath(uint256 fromVersion_, uint256 toVersion_) public override virtual onlyGovernor {\n        require(fromVersion_ != toVersion_,                              \"MPF:DUP:OVERWRITING_INITIALIZER\");\n        require(_registerMigrator(fromVersion_, toVersion_, address(0)), \"MPF:DUP:FAILED\");\n\n        emit UpgradePathDisabled(fromVersion_, toVersion_);\n\n        upgradeEnabledForPath[fromVersion_][toVersion_] = false;\n    }\n\n    function enableUpgradePath(uint256 fromVersion_, uint256 toVersion_, address migrator_) public override virtual onlyGovernor {\n        require(fromVersion_ != toVersion_,                             \"MPF:EUP:OVERWRITING_INITIALIZER\");\n        require(_registerMigrator(fromVersion_, toVersion_, migrator_), \"MPF:EUP:FAILED\");\n\n        emit UpgradePathEnabled(fromVersion_, toVersion_, migrator_);\n\n        upgradeEnabledForPath[fromVersion_][toVersion_] = true;\n    }\n\n    function registerImplementation(uint256 version_, address implementationAddress_, address initializer_) public override virtual onlyGovernor {\n        // Version 0 reserved as \"no version\" since default `defaultVersion` is 0.\n        require(version_ != uint256(0), \"MPF:RI:INVALID_VERSION\");\n\n        emit ImplementationRegistered(version_, implementationAddress_, initializer_);\n\n        require(_registerImplementation(version_, implementationAddress_), \"MPF:RI:FAIL_FOR_IMPLEMENTATION\");\n\n        // Set migrator for initialization, which understood as fromVersion == toVersion.\n        require(_registerMigrator(version_, version_, initializer_), \"MPF:RI:FAIL_FOR_MIGRATOR\");\n    }\n\n    function setDefaultVersion(uint256 version_) public override virtual onlyGovernor {\n        // Version must be 0 (to disable creating new instances) or be registered.\n        require(version_ == 0 || _implementationOf[version_] != address(0), \"MPF:SDV:INVALID_VERSION\");\n\n        emit DefaultVersionSet(defaultVersion = version_);\n    }\n\n    function setGlobals(address mapleGlobals_) public override virtual onlyGovernor {\n        require(IMapleGlobalsLike(mapleGlobals_).governor() != address(0), \"MPF:SG:INVALID_GLOBALS\");\n\n        emit MapleGlobalsSet(mapleGlobals = mapleGlobals_);\n    }\n\n    /**************************/\n    /*** Instance Functions ***/\n    /**************************/\n\n    function createInstance(bytes calldata arguments_, bytes32 salt_) public override virtual returns (address instance_) {\n        bool success;\n        ( success, instance_ ) = _newInstance(arguments_, keccak256(abi.encodePacked(arguments_, salt_)));\n        require(success, \"MPF:CI:FAILED\");\n\n        emit InstanceDeployed(defaultVersion, instance_, arguments_);\n    }\n\n    // NOTE: The implementation proxied by the instance defines the access control logic for its own upgrade.\n    function upgradeInstance(uint256 toVersion_, bytes calldata arguments_) public override virtual {\n        uint256 fromVersion = _versionOf[IMapleProxiedLike(msg.sender).implementation()];\n\n        require(upgradeEnabledForPath[fromVersion][toVersion_], \"MPF:UI:NOT_ALLOWED\");\n\n        emit InstanceUpgraded(msg.sender, fromVersion, toVersion_, arguments_);\n\n        require(_upgradeInstance(msg.sender, toVersion_, arguments_), \"MPF:UI:FAILED\");\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    function getInstanceAddress(bytes calldata arguments_, bytes32 salt_) public view override virtual returns (address instanceAddress_) {\n        return _getDeterministicProxyAddress(keccak256(abi.encodePacked(arguments_, salt_)));\n    }\n\n    function implementationOf(uint256 version_) public view override virtual returns (address implementation_) {\n        return _implementationOf[version_];\n    }\n\n    function defaultImplementation() external view override returns (address defaultImplementation_) {\n        return _implementationOf[defaultVersion];\n    }\n\n    function migratorForPath(uint256 oldVersion_, uint256 newVersion_) public view override virtual returns (address migrator_) {\n        return _migratorForPath[oldVersion_][newVersion_];\n    }\n\n    function versionOf(address implementation_) public view override virtual returns (uint256 version_) {\n        return _versionOf[implementation_];\n    }\n\n}\n\n/// @title MapleLoanFactory deploys Loan instances.\ncontract MapleLoanFactory is IMapleLoanFactory, MapleProxyFactory {\n\n    mapping(address => bool) public override isLoan;\n\n    /// @param mapleGlobals_ The address of a Maple Globals contract.\n    constructor(address mapleGlobals_) MapleProxyFactory(mapleGlobals_) {}\n\n    function createInstance(bytes calldata arguments_, bytes32 salt_)\n        override(IMapleProxyFactory, MapleProxyFactory) public returns (\n            address instance_\n        )\n    {\n        isLoan[instance_ = super.createInstance(arguments_, salt_)] = true;\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "metadata": {
      "bytecodeHash": "none"
    }
  }
}