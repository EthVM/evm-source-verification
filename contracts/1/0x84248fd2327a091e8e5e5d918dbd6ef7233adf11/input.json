{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"QUAI_Staking.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity ^0.7.5;\r\n\r\n//MATH OPERATIONS -- designed to avoid possibility of errors with built-in math functions\r\nlibrary SafeMath {\r\n    //@dev Multiplies two numbers, throws on overflow.\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    //@dev Integer division of two numbers, truncating the quotient (i.e. rounds down).\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    //@dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    //@dev Adds two numbers, throws on overflow.\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n//end library\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract QUAI_Staking is Ownable {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public constant quaiToken = 0x40821CD074dfeCb1524286923bC69315075b5c89; //token to stake\r\n\r\n\t//STAKING PARAMETERS\r\n\tuint256 public constant stakingPeriod = 30 days; //period over which tokens are locked after staking\r\n\tuint256 public stakingEnd; //point after which staking rewards cease to accumulate\r\n\tuint256 public rewardRate = 14; //14% linear return per staking period\r\n\tuint256 public totalStaked; //sum of all user stakes\r\n\tuint256 public maxTotalStaked = 58e23; //5.8 million tokens\r\n\tuint256 public minStaked = 1e21; //1000 tokens. min staked per user\r\n\r\n\t//STAKING MAPPINGS\r\n\tmapping (address => uint256) public stakedTokens; //amount of tokens that address has staked\r\n\tmapping (address => uint256) public lastStaked; //last time at which address staked, deposited, or \"rolled over\" their position by calling updateStake directly\r\n\tmapping (address => uint256) public totalEarnedTokens; //total tokens earned through staking by each user\r\n\t\r\n\tconstructor(){\r\n\t\tstakingEnd = (block.timestamp + 180 days);\r\n\t}\r\n\r\n\t//STAKING FUNCTIONS\r\n\tfunction deposit(uint256 amountTokens) external {\r\n\t\trequire( (stakedTokens[msg.sender] >= minStaked || amountTokens >= minStaked), \"deposit: must exceed minimum stake\" );\r\n\t\trequire(totalStaked + amountTokens <= maxTotalStaked, \"deposit: amount would exceed max stake. call updateStake to claim dividends\");\r\n\t\tupdateStake();\r\n\t\tIERC20(quaiToken).transferFrom(msg.sender, address(this), amountTokens);\r\n\t\tstakedTokens[msg.sender] += amountTokens;\r\n\t\ttotalStaked += amountTokens;\r\n\t}\r\n\r\n\tfunction updateStake() public {\r\n\t\tuint256 stakedUntil = min(block.timestamp, stakingEnd);\r\n\t\tuint256 periodStaked = stakedUntil.sub(lastStaked[msg.sender]);\r\n\t\tuint256 dividends;\r\n\t\t//linear rewards up to stakingPeriod\r\n\t\tif(periodStaked < stakingPeriod) {\r\n\t\t\tdividends = periodStaked.mul(stakedTokens[msg.sender]).mul(rewardRate).div(stakingPeriod).div(100);\r\n\t\t} else {\r\n\t\t\tdividends = stakedTokens[msg.sender].mul(rewardRate).div(100);\r\n\t\t}\r\n\t\t//update lastStaked time for msg.sender -- user cannot unstake until end of another stakingPeriod\r\n\t\tlastStaked[msg.sender] = stakedUntil;\r\n\t\t//withdraw dividends for user if rolling over dividends would exceed staking cap, else stake the dividends automatically\r\n\t\tif(totalStaked + dividends > maxTotalStaked) {\r\n\t\t\tIERC20(quaiToken).transfer(msg.sender, dividends);\r\n\t\t\ttotalEarnedTokens[msg.sender] += dividends;\r\n\t\t} else {\r\n\t\t\tstakedTokens[msg.sender] += dividends;\r\n\t\t\ttotalStaked += dividends;\r\n\t\t\ttotalEarnedTokens[msg.sender] += dividends;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction withdrawDividends() external {\r\n\t\tuint256 stakedUntil = min(block.timestamp, stakingEnd);\r\n\t\tuint256 periodStaked = stakedUntil.sub(lastStaked[msg.sender]);\r\n\t\tuint256 dividends;\r\n\t\t//linear rewards up to stakingPeriod\r\n\t\tif(periodStaked < stakingPeriod) {\r\n\t\t\tdividends = periodStaked.mul(stakedTokens[msg.sender]).mul(rewardRate).div(stakingPeriod).div(100);\r\n\t\t} else {\r\n\t\t\tdividends = stakedTokens[msg.sender].mul(rewardRate).div(100);\r\n\t\t}\r\n\t\t//update lastStaked time for msg.sender -- user cannot unstake until end of another stakingPeriod\r\n\t\tlastStaked[msg.sender] = stakedUntil;\r\n\t\t//withdraw dividends for user\r\n\t\tIERC20(quaiToken).transfer(msg.sender, dividends);\r\n\t\ttotalEarnedTokens[msg.sender] += dividends;\r\n\t}\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n\tfunction unstake() external {\r\n\t\tuint256 timeSinceStake = (block.timestamp).sub(lastStaked[msg.sender]);\r\n\t\trequire(timeSinceStake >= stakingPeriod || block.timestamp > stakingEnd, \"unstake: staking period for user still ongoing\");\r\n\t\tupdateStake();\r\n\t\tuint256 toTransfer = stakedTokens[msg.sender];\r\n\t\tstakedTokens[msg.sender] = 0;\r\n\t\tIERC20(quaiToken).transfer(msg.sender, toTransfer);\r\n\t\ttotalStaked = totalStaked.sub(toTransfer);\r\n\t}\r\n\r\n\tfunction getPendingDivs(address user) external view returns(uint256) {\r\n\t\tuint256 stakedUntil = min(block.timestamp, stakingEnd);\r\n\t\tuint256 periodStaked = stakedUntil.sub(lastStaked[user]);\r\n\t\tuint256 dividends;\r\n\t\t//linear rewards up to stakingPeriod\r\n\t\tif(periodStaked < stakingPeriod) {\r\n\t\t\tdividends = periodStaked.mul(stakedTokens[user]).mul(rewardRate).div(stakingPeriod).div(100);\r\n\t\t} else {\r\n\t\t\tdividends = stakedTokens[user].mul(rewardRate).div(100);\r\n\t\t}\r\n\t\treturn(dividends);\r\n\t}\r\n\r\n\t//OWNER ONLY FUNCTIONS\r\n\tfunction updateMinStake(uint256 newMinStake) external onlyOwner() {\r\n\t\tminStaked = newMinStake;\r\n\t}\r\n\r\n\tfunction updateStakingEnd(uint256 newStakingEnd) external onlyOwner() {\r\n\t\trequire(newStakingEnd >= block.timestamp, \"updateStakingEnd: newStakingEnd must be in future\");\r\n\t\tstakingEnd = newStakingEnd;\r\n\t}\r\n\r\n\tfunction updateRewardRate(uint256 newRewardRate) external onlyOwner() {\r\n\t\trequire(newRewardRate <= 100, \"what are you, crazy?\");\r\n\t\trewardRate = newRewardRate;\r\n\t}\r\n\r\n\tfunction updateMaxTotalStaked(uint256 newMaxTotalStaked) external onlyOwner() {\r\n\t\tmaxTotalStaked = newMaxTotalStaked;\r\n\t}\r\n\r\n\t//allows owner to recover ERC20 tokens for users when they are mistakenly sent to contract\r\n\tfunction recoverTokens(address tokenAddress, address dest, uint256 amountTokens) external onlyOwner() {\r\n\t\trequire(tokenAddress != quaiToken, \"recoverTokens: cannot move staked token\");\r\n\t\tIERC20(tokenAddress).transfer(dest, amountTokens);\r\n\t}\r\n\r\n\t//allows owner to reclaim any tokens not distributed during staking\r\n\tfunction recoverQUAI() external onlyOwner() {\r\n\t\trequire(block.timestamp >= (stakingEnd + 30 days), \"recoverQUAI: too early\");\r\n\t\tuint256 amountToSend = IERC20(quaiToken).balanceOf(address(this));\r\n\t\tIERC20(quaiToken).transfer(msg.sender, amountToSend);\r\n\t}\r\n}"}}}