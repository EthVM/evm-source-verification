{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "dog.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n/// dog.sol -- Dai liquidation module 2.0\r\n\r\n// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.6.12;\r\n\r\ninterface ClipperLike {\r\n    function ilk() external view returns (bytes32);\r\n    function kick(\r\n        uint256 tab,\r\n        uint256 lot,\r\n        address usr,\r\n        address kpr\r\n    ) external returns (uint256);\r\n}\r\n\r\ninterface VatLike {\r\n    function ilks(bytes32) external view returns (\r\n        uint256 Art,  // [wad]\r\n        uint256 rate, // [ray]\r\n        uint256 spot, // [ray]\r\n        uint256 line, // [rad]\r\n        uint256 dust  // [rad]\r\n    );\r\n    function urns(bytes32,address) external view returns (\r\n        uint256 ink,  // [wad]\r\n        uint256 art   // [wad]\r\n    );\r\n    function grab(bytes32,address,address,address,int256,int256) external;\r\n    function hope(address) external;\r\n    function nope(address) external;\r\n}\r\n\r\ninterface VowLike {\r\n    function fess(uint256) external;\r\n}\r\n\r\ncontract Dog {\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;\r\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\r\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Dog/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        address clip;  // Liquidator\r\n        uint256 chop;  // Liquidation Penalty                                          [wad]\r\n        uint256 hole;  // Max DAI needed to cover debt+fees of active auctions per ilk [rad]\r\n        uint256 dirt;  // Amt DAI needed to cover debt+fees of active auctions per ilk [rad]\r\n    }\r\n\r\n    VatLike immutable public vat;  // CDP Engine\r\n\r\n    mapping (bytes32 => Ilk) public ilks;\r\n\r\n    VowLike public vow;   // Debt Engine\r\n    uint256 public live;  // Active Flag\r\n    uint256 public Hole;  // Max DAI needed to cover debt+fees of active auctions [rad]\r\n    uint256 public Dirt;  // Amt DAI needed to cover debt+fees of active auctions [rad]\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n\r\n    event File(bytes32 indexed what, uint256 data);\r\n    event File(bytes32 indexed what, address data);\r\n    event File(bytes32 indexed ilk, bytes32 indexed what, uint256 data);\r\n    event File(bytes32 indexed ilk, bytes32 indexed what, address clip);\r\n\r\n    event Bark(\r\n      bytes32 indexed ilk,\r\n      address indexed urn,\r\n      uint256 ink,\r\n      uint256 art,\r\n      uint256 due,\r\n      address clip,\r\n      uint256 indexed id\r\n    );\r\n    event Digs(bytes32 indexed ilk, uint256 rad);\r\n    event Cage();\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        vat = VatLike(vat_);\r\n        live = 1;\r\n        wards[msg.sender] = 1;\r\n        emit Rely(msg.sender);\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant WAD = 10 ** 18;\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x <= y ? x : y;\r\n    }\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, address data) external auth {\r\n        if (what == \"vow\") vow = VowLike(data);\r\n        else revert(\"Dog/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n    function file(bytes32 what, uint256 data) external auth {\r\n        if (what == \"Hole\") Hole = data;\r\n        else revert(\"Dog/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint256 data) external auth {\r\n        if (what == \"chop\") {\r\n            require(data >= WAD, \"Dog/file-chop-lt-WAD\");\r\n            ilks[ilk].chop = data;\r\n        } else if (what == \"hole\") ilks[ilk].hole = data;\r\n        else revert(\"Dog/file-unrecognized-param\");\r\n        emit File(ilk, what, data);\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, address clip) external auth {\r\n        if (what == \"clip\") {\r\n            require(ilk == ClipperLike(clip).ilk(), \"Dog/file-ilk-neq-clip.ilk\");\r\n            ilks[ilk].clip = clip;\r\n        } else revert(\"Dog/file-unrecognized-param\");\r\n        emit File(ilk, what, clip);\r\n    }\r\n\r\n    function chop(bytes32 ilk) external view returns (uint256) {\r\n        return ilks[ilk].chop;\r\n    }\r\n\r\n    // --- CDP Liquidation: all bark and no bite ---\r\n    //\r\n    // Liquidate a Vault and start a Dutch auction to sell its collateral for DAI.\r\n    //\r\n    // The third argument is the address that will receive the liquidation reward, if any.\r\n    //\r\n    // The entire Vault will be liquidated except when the target amount of DAI to be raised in\r\n    // the resulting auction (debt of Vault + liquidation penalty) causes either Dirt to exceed\r\n    // Hole or ilk.dirt to exceed ilk.hole by an economically significant amount. In that\r\n    // case, a partial liquidation is performed to respect the global and per-ilk limits on\r\n    // outstanding DAI target. The one exception is if the resulting auction would likely\r\n    // have too little collateral to be interesting to Keepers (debt taken from Vault < ilk.dust),\r\n    // in which case the function reverts. Please refer to the code and comments within if\r\n    // more detail is desired.\r\n    function bark(bytes32 ilk, address urn, address kpr) external returns (uint256 id) {\r\n        require(live == 1, \"Dog/not-live\");\r\n\r\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\r\n        Ilk memory milk = ilks[ilk];\r\n        uint256 dart;\r\n        uint256 rate;\r\n        uint256 dust;\r\n        {\r\n            uint256 spot;\r\n            (,rate, spot,, dust) = vat.ilks(ilk);\r\n            require(spot > 0 && mul(ink, spot) < mul(art, rate), \"Dog/not-unsafe\");\r\n\r\n            // Get the minimum value between:\r\n            // 1) Remaining space in the general Hole\r\n            // 2) Remaining space in the collateral hole\r\n            require(Hole > Dirt && milk.hole > milk.dirt, \"Dog/liquidation-limit-hit\");\r\n            uint256 room = min(Hole - Dirt, milk.hole - milk.dirt);\r\n\r\n            // uint256.max()/(RAD*WAD) = 115,792,089,237,316\r\n            dart = min(art, mul(room, WAD) / rate / milk.chop);\r\n\r\n            // Partial liquidation edge case logic\r\n            if (art > dart) {\r\n                if (mul(art - dart, rate) < dust) {\r\n\r\n                    // If the leftover Vault would be dusty, just liquidate it entirely.\r\n                    // This will result in at least one of dirt_i > hole_i or Dirt > Hole becoming true.\r\n                    // The amount of excess will be bounded above by ceiling(dust_i * chop_i / WAD).\r\n                    // This deviation is assumed to be small compared to both hole_i and Hole, so that\r\n                    // the extra amount of target DAI over the limits intended is not of economic concern.\r\n                    dart = art;\r\n                } else {\r\n\r\n                    // In a partial liquidation, the resulting auction should also be non-dusty.\r\n                    require(mul(dart, rate) >= dust, \"Dog/dusty-auction-from-partial-liquidation\");\r\n                }\r\n            }\r\n        }\r\n\r\n        uint256 dink = mul(ink, dart) / art;\r\n\r\n        require(dink > 0, \"Dog/null-auction\");\r\n        require(dart <= 2**255 && dink <= 2**255, \"Dog/overflow\");\r\n\r\n        vat.grab(\r\n            ilk, urn, milk.clip, address(vow), -int256(dink), -int256(dart)\r\n        );\r\n\r\n        uint256 due = mul(dart, rate);\r\n        vow.fess(due);\r\n\r\n        {   // Avoid stack too deep\r\n            // This calcuation will overflow if dart*rate exceeds ~10^14\r\n            uint256 tab = mul(due, milk.chop) / WAD;\r\n            Dirt = add(Dirt, tab);\r\n            ilks[ilk].dirt = add(milk.dirt, tab);\r\n\r\n            id = ClipperLike(milk.clip).kick({\r\n                tab: tab,\r\n                lot: dink,\r\n                usr: urn,\r\n                kpr: kpr\r\n            });\r\n        }\r\n\r\n        emit Bark(ilk, urn, dink, dart, due, milk.clip, id);\r\n    }\r\n\r\n    function digs(bytes32 ilk, uint256 rad) external auth {\r\n        Dirt = sub(Dirt, rad);\r\n        ilks[ilk].dirt = sub(ilks[ilk].dirt, rad);\r\n        emit Digs(ilk, rad);\r\n    }\r\n\r\n    function cage() external auth {\r\n        live = 0;\r\n        emit Cage();\r\n    }\r\n}"
    }
  }
}