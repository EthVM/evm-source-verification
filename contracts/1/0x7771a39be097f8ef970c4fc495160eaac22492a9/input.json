{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MaskDAO.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.7;\r\n\r\n/**\r\n * Standard SafeMath, stripped down to just add/sub/mul/div\r\n */\r\nlibrary SafeMath {\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\r\n\t}\r\n\r\n\tfunction sub(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\trequire(b <= a, errorMessage);\r\n\t\tuint256 c = a - b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn div(a, b, \"SafeMath: division by zero\");\r\n\t}\r\n\r\n\tfunction div(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\t// Solidity only automatically asserts when dividing by 0\r\n\t\trequire(b > 0, errorMessage);\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n/**\r\n * BEP20 standard interface.\r\n */\r\ninterface IBEP20 {\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\tfunction decimals() external view returns (uint8);\r\n\r\n\tfunction symbol() external view returns (string memory);\r\n\r\n\tfunction name() external view returns (string memory);\r\n\r\n\tfunction getOwner() external view returns (address);\r\n\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n\tfunction allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\tfunction transferFrom(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) external returns (bool);\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * Allows for contract ownership along with multi-address authorization\r\n */\r\nabstract contract Auth {\r\n\taddress internal owner;\r\n\r\n\tconstructor(address _owner) {\r\n\t\towner = _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * Function modifier to require caller to be contract deployer\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(isOwner(msg.sender), \"!Owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * Check if address is owner\r\n\t */\r\n\tfunction isOwner(address account) private view returns (bool) {\r\n\t\treturn account == owner;\r\n\t}\r\n\r\n\t/**\r\n\t * Transfer ownership to new address. Caller must be deployer. Leaves old deployer authorized\r\n\t */\r\n\tfunction transferOwnership(address payable adr) public onlyOwner {\r\n\t\towner = adr;\r\n\t\temit OwnershipTransferred(adr);\r\n\t}\r\n\r\n\tevent OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IDEXFactory {\r\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n\tfunction factory() external pure returns (address);\r\n\r\n\tfunction WETH() external pure returns (address);\r\n\r\n\tfunction addLiquidity(\r\n\t\taddress tokenA,\r\n\t\taddress tokenB,\r\n\t\tuint256 amountADesired,\r\n\t\tuint256 amountBDesired,\r\n\t\tuint256 amountAMin,\r\n\t\tuint256 amountBMin,\r\n\t\taddress to,\r\n\t\tuint256 deadline\r\n\t)\r\n\t\texternal\r\n\t\treturns (\r\n\t\t\tuint256 amountA,\r\n\t\t\tuint256 amountB,\r\n\t\t\tuint256 liquidity\r\n\t\t);\r\n\r\n\tfunction addLiquidityETH(\r\n\t\taddress token,\r\n\t\tuint256 amountTokenDesired,\r\n\t\tuint256 amountTokenMin,\r\n\t\tuint256 amountETHMin,\r\n\t\taddress to,\r\n\t\tuint256 deadline\r\n\t)\r\n\t\texternal\r\n\t\tpayable\r\n\t\treturns (\r\n\t\t\tuint256 amountToken,\r\n\t\t\tuint256 amountETH,\r\n\t\t\tuint256 liquidity\r\n\t\t);\r\n\r\n\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n\t\tuint256 amountIn,\r\n\t\tuint256 amountOutMin,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint256 deadline\r\n\t) external;\r\n\r\n\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n\t\tuint256 amountOutMin,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint256 deadline\r\n\t) external payable;\r\n\r\n\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n\t\tuint256 amountIn,\r\n\t\tuint256 amountOutMin,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint256 deadline\r\n\t) external;\r\n}\r\n\r\ninterface IDividendDistributor {\r\n\tfunction setShare(address shareholder, uint256 amount) external;\r\n\r\n\tfunction deposit() external payable;\r\n\r\n\tfunction claimDividend(address shareholder) external;\r\n\r\n\tfunction setTreasury(address treasury) external;\r\n\r\n\tfunction getDividendsClaimedOf(address shareholder) external returns (uint256);\r\n}\r\n\r\ncontract DividendDistributor is IDividendDistributor {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public _token;\r\n\taddress public _owner;\r\n\taddress public _treasury;\r\n\r\n\tstruct Share {\r\n\t\tuint256 amount;\r\n\t\tuint256 totalExcluded;\r\n\t\tuint256 totalClaimed;\r\n\t}\r\n\r\n\taddress[] private shareholders;\r\n\tmapping(address => uint256) private shareholderIndexes;\r\n\r\n\tmapping(address => Share) public shares;\r\n\r\n\tuint256 public totalShares;\r\n\tuint256 public totalDividends;\r\n\tuint256 public totalClaimed;\r\n\tuint256 public dividendsPerShare;\r\n\tuint256 private dividendsPerShareAccuracyFactor = 10**36;\r\n\r\n\tmodifier onlyToken() {\r\n\t\trequire(msg.sender == _token);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == _owner);\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor(address owner, address treasury) {\r\n\t\t_token = msg.sender;\r\n\t\t_owner = payable(owner);\r\n\t\t_treasury = payable(treasury);\r\n\t}\r\n\r\n\t// receive() external payable { }\r\n\r\n\tfunction setShare(address shareholder, uint256 amount) external override onlyToken {\r\n\t\tif (shares[shareholder].amount > 0) {\r\n\t\t\tdistributeDividend(shareholder);\r\n\t\t}\r\n\r\n\t\tif (amount > 0 && shares[shareholder].amount == 0) {\r\n\t\t\taddShareholder(shareholder);\r\n\t\t} else if (amount == 0 && shares[shareholder].amount > 0) {\r\n\t\t\tremoveShareholder(shareholder);\r\n\t\t}\r\n\r\n\t\ttotalShares = totalShares.sub(shares[shareholder].amount).add(amount);\r\n\t\tshares[shareholder].amount = amount;\r\n\t\tshares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n\t}\r\n\r\n\tfunction deposit() external payable override {\r\n\t\tuint256 amount = msg.value;\r\n\r\n\t\ttotalDividends = totalDividends.add(amount);\r\n\t\tdividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\r\n\t}\r\n\r\n\tfunction distributeDividend(address shareholder) internal {\r\n\t\tif (shares[shareholder].amount == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tuint256 amount = getClaimableDividendOf(shareholder);\r\n\t\tif (amount > 0) {\r\n\t\t\ttotalClaimed = totalClaimed.add(amount);\r\n\t\t\tshares[shareholder].totalClaimed = shares[shareholder].totalClaimed.add(amount);\r\n\t\t\tshares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n\t\t\tpayable(shareholder).transfer(amount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction claimDividend(address shareholder) external override onlyToken {\r\n\t\tdistributeDividend(shareholder);\r\n\t}\r\n\r\n\tfunction getClaimableDividendOf(address shareholder) public view returns (uint256) {\r\n\t\tif (shares[shareholder].amount == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\r\n\t\tuint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n\r\n\t\tif (shareholderTotalDividends <= shareholderTotalExcluded) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\treturn shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n\t}\r\n\r\n\tfunction getCumulativeDividends(uint256 share) internal view returns (uint256) {\r\n\t\treturn share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\r\n\t}\r\n\r\n\tfunction addShareholder(address shareholder) internal {\r\n\t\tshareholderIndexes[shareholder] = shareholders.length;\r\n\t\tshareholders.push(shareholder);\r\n\t}\r\n\r\n\tfunction removeShareholder(address shareholder) internal {\r\n\t\tshareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length - 1];\r\n\t\tshareholderIndexes[shareholders[shareholders.length - 1]] = shareholderIndexes[shareholder];\r\n\t\tshareholders.pop();\r\n\t}\r\n\r\n\tfunction manualSend(uint256 amount, address holder) private onlyOwner {\r\n\t\tuint256 contractETHBalance = address(this).balance;\r\n\t\tpayable(holder).transfer(amount > 0 ? amount : contractETHBalance);\r\n\t}\r\n\r\n\tfunction setTreasury(address treasury) external override onlyToken {\r\n\t\t_treasury = payable(treasury);\r\n\t}\r\n\r\n\tfunction getDividendsClaimedOf(address shareholder) external view override returns (uint256) {\r\n\t\trequire(shares[shareholder].amount > 0, \"You're not a shareholder!\");\r\n\t\treturn shares[shareholder].totalClaimed;\r\n\t}\r\n}\r\n\r\ncontract MaskDAO is IBEP20, Auth {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress private WETH;\r\n\taddress private DEAD = 0x000000000000000000000000000000000000dEaD;\r\n\taddress private ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n\tstring private constant _name = \"MaskDAO\";\r\n\tstring private constant _symbol = \"MASK\";\r\n\tuint8 private constant _decimals = 9;\r\n\r\n\tuint256 private _totalSupply = 1000000000000 * (10**_decimals);\r\n\tuint256 private _maxTxAmountBuy = _totalSupply;\r\n\r\n\tmapping(address => uint256) private _balances;\r\n\tmapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n\tmapping(address => bool) private isFeeExempt;\r\n\tmapping(address => bool) private isDividendExempt;\r\n\tmapping(address => bool) private isBot;\r\n\r\n\tuint256 private totalFee = 1;\r\n\tuint256 private feeDenominator = 100;\r\n\r\n\taddress payable private holderReflection = payable(0xe0f6E4d8f0d978C56B38a489F065DBbBD4B903EB);\r\n\taddress payable private treasury = payable(0xe0f6E4d8f0d978C56B38a489F065DBbBD4B903EB);\r\n\r\n\tIDEXRouter private router;\r\n\taddress private pair;\r\n\r\n\tuint256 private launchedAt;\r\n\tbool private tradingOpen = true;\r\n\tbool private buyLimit = false;\r\n\tuint256 private maxBuy = 5000000000 * (10**_decimals);\r\n\r\n\tDividendDistributor public distributor;\r\n\r\n\tbool private inSwap;\r\n\tmodifier swapping() {\r\n\t\tinSwap = true;\r\n\t\t_;\r\n\t\tinSwap = false;\r\n\t}\r\n\r\n\tconstructor() Auth(0xe0f6E4d8f0d978C56B38a489F065DBbBD4B903EB) {\r\n\t\taddress _owner = 0xe0f6E4d8f0d978C56B38a489F065DBbBD4B903EB;\r\n\t\trouter = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\r\n\t\tWETH = router.WETH();\r\n\r\n\t\tpair = IDEXFactory(router.factory()).createPair(WETH, address(this));\r\n\r\n\t\t_allowances[address(this)][address(router)] = type(uint256).max;\r\n\r\n\t\tdistributor = new DividendDistributor(_owner, treasury);\r\n\r\n\t\tisFeeExempt[_owner] = true;\r\n\t\tisFeeExempt[holderReflection] = true;\r\n\t\tisFeeExempt[treasury] = true;\r\n\r\n\t\tisDividendExempt[pair] = true;\r\n\t\tisDividendExempt[address(this)] = true;\r\n\t\tisDividendExempt[DEAD] = true;\r\n\r\n\t\t_balances[_owner] = _totalSupply;\r\n\r\n\t\temit Transfer(address(0), _owner, _totalSupply);\r\n\t}\r\n\r\n\treceive() external payable {}\r\n\r\n\tfunction totalSupply() external view override returns (uint256) {\r\n\t\treturn _totalSupply;\r\n\t}\r\n\r\n\tfunction decimals() external pure override returns (uint8) {\r\n\t\treturn _decimals;\r\n\t}\r\n\r\n\tfunction symbol() external pure override returns (string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\tfunction name() external pure override returns (string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\tfunction getOwner() external view override returns (address) {\r\n\t\treturn owner;\r\n\t}\r\n\r\n\tfunction balanceOf(address account) public view override returns (uint256) {\r\n\t\treturn _balances[account];\r\n\t}\r\n\r\n\tfunction allowance(address holder, address spender) external view override returns (uint256) {\r\n\t\treturn _allowances[holder][spender];\r\n\t}\r\n\r\n\tfunction approve(address spender, uint256 amount) public override returns (bool) {\r\n\t\t_allowances[msg.sender][spender] = amount;\r\n\t\temit Approval(msg.sender, spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction approveMax(address spender) private returns (bool) {\r\n\t\treturn approve(spender, type(uint256).max);\r\n\t}\r\n\r\n\tfunction transfer(address recipient, uint256 amount) external override returns (bool) {\r\n\t\treturn _transferFrom(msg.sender, recipient, amount);\r\n\t}\r\n\r\n\tfunction transferFrom(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) external override returns (bool) {\r\n\t\tif (_allowances[sender][msg.sender] != type(uint256).max) {\r\n\t\t\t_allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n\t\t}\r\n\r\n\t\treturn _transferFrom(sender, recipient, amount);\r\n\t}\r\n\r\n\tfunction _transferFrom(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) internal returns (bool) {\r\n\t\tif (sender != owner && recipient != owner) require(tradingOpen, \"Trading not yet enabled.\");\r\n\t\trequire(!isBot[sender] && !isBot[recipient], \"Nice try\");\r\n\t\tif (buyLimit) {\r\n\t\t\tif (sender != owner && recipient != owner) require(amount <= maxBuy, \"Too much sir\");\r\n\t\t}\r\n\t\tif (block.number <= (launchedAt + 1)) {\r\n\t\t\tisBot[recipient] = true;\r\n\t\t\tisDividendExempt[recipient] = true;\r\n\t\t}\r\n\r\n\t\tif (inSwap) {\r\n\t\t\treturn _basicTransfer(sender, recipient, amount);\r\n\t\t}\r\n\r\n\t\tbool shouldSwapBack = (recipient == pair && balanceOf(address(this)) > 0); /*!inSwap &&*/\r\n\t\tif (shouldSwapBack) {\r\n\t\t\tswapBack();\r\n\t\t}\r\n\r\n\t\t_balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n\r\n\t\tuint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, amount) : amount;\r\n\r\n\t\t_balances[recipient] = _balances[recipient].add(amountReceived);\r\n\r\n\t\tif (sender != pair && !isDividendExempt[sender]) {\r\n\t\t\ttry distributor.setShare(sender, _balances[sender]) {} catch {}\r\n\t\t}\r\n\t\tif (recipient != pair && !isDividendExempt[recipient]) {\r\n\t\t\ttry distributor.setShare(recipient, _balances[recipient]) {} catch {}\r\n\t\t}\r\n\r\n\t\temit Transfer(sender, recipient, amountReceived);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction _basicTransfer(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) internal returns (bool) {\r\n\t\t_balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n\t\t_balances[recipient] = _balances[recipient].add(amount);\r\n\t\temit Transfer(sender, recipient, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction shouldTakeFee(address sender, address recipient) internal view returns (bool) {\r\n\t\treturn (!(isFeeExempt[sender] || isFeeExempt[recipient]) && (sender == pair || recipient == pair));\r\n\t}\r\n\r\n\tfunction takeFee(address sender, uint256 amount) internal returns (uint256) {\r\n\t\tuint256 feeAmount;\r\n\t\tfeeAmount = amount.mul(totalFee).div(feeDenominator);\r\n\t\t_balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n\t\t//emit Transfer(sender, address(this), feeAmount);\r\n\r\n\t\treturn amount.sub(feeAmount);\r\n\t}\r\n\r\n\tfunction swapBack() internal swapping {\r\n\t\tuint256 amountToSwap = balanceOf(address(this));\r\n\r\n\t\taddress[] memory path = new address[](2);\r\n\t\tpath[0] = address(this);\r\n\t\tpath[1] = WETH;\r\n\r\n\t\trouter.swapExactTokensForETHSupportingFeeOnTransferTokens(amountToSwap, 0, path, address(this), block.timestamp);\r\n\r\n\t\tuint256 amountTreasury = (address(this).balance).div(2);\r\n\t\tuint256 amountMarketing = (address(this).balance).div(2);\r\n\r\n\t\tpayable(holderReflection).transfer(amountMarketing);\r\n\t\tpayable(treasury).transfer(amountTreasury);\r\n\t}\r\n\r\n\tfunction openTrading() public onlyOwner {\r\n\t\tlaunchedAt = block.number;\r\n\t\ttradingOpen = true;\r\n\t}\r\n\r\n\tfunction setBot(address _address) private onlyOwner {\r\n\t\tisBot[_address] = true;\r\n\t\t_setIsDividendExempt(_address, true);\r\n\t}\r\n\r\n\tfunction setBulkBots(address[] memory bots_) private onlyOwner {\r\n\t\tfor (uint256 i = 0; i < bots_.length; i++) {\r\n\t\t\tisBot[bots_[i]] = true;\r\n\t\t\t_setIsDividendExempt(bots_[i], true);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction delBulkBots(address[] memory bots_) private onlyOwner {\r\n\t\tfor (uint256 i = 0; i < bots_.length; i++) {\r\n\t\t\tisBot[bots_[i]] = false;\r\n\t\t\t_setIsDividendExempt(bots_[i], false);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _setIsDividendExempt(address holder, bool exempt) internal {\r\n\t\trequire(holder != address(this) && holder != pair);\r\n\t\tisDividendExempt[holder] = exempt;\r\n\t\tif (exempt) {\r\n\t\t\tdistributor.setShare(holder, 0);\r\n\t\t} else {\r\n\t\t\tdistributor.setShare(holder, _balances[holder]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setIsDividendExempt(address holder, bool exempt) private onlyOwner {\r\n\t\t_setIsDividendExempt(holder, exempt);\r\n\t}\r\n\r\n\tfunction setIsFeeExempt(address holder, bool exempt) private onlyOwner {\r\n\t\tisFeeExempt[holder] = exempt;\r\n\t}\r\n\r\n\tfunction setFee(uint256 _fee) private onlyOwner {\r\n\t\trequire(_fee <= 14, \"Fee can't exceed 14%\");\r\n\t\ttotalFee = _fee;\r\n\t}\r\n\r\n\tfunction manualSend() external onlyOwner {\r\n\t\tuint256 contractETHBalance = address(this).balance;\r\n\t\tpayable(holderReflection).transfer(contractETHBalance);\r\n\t}\r\n\r\n\tfunction claimDividend() private {\r\n\t\tdistributor.claimDividend(msg.sender);\r\n\t}\r\n\r\n\tfunction claimDividend(address holder) private onlyOwner {\r\n\t\tdistributor.claimDividend(holder);\r\n\t}\r\n\r\n\tfunction getClaimableDividendOf(address shareholder) private view returns (uint256) {\r\n\t\treturn distributor.getClaimableDividendOf(shareholder);\r\n\t}\r\n\r\n\tfunction manualBurn(uint256 amount) private onlyOwner returns (bool) {\r\n\t\treturn _basicTransfer(address(this), DEAD, amount);\r\n\t}\r\n\r\n\tfunction setholderReflection(address _holderReflection) private onlyOwner {\r\n\t\tholderReflection = payable(_holderReflection);\r\n\t}\r\n\r\n\tfunction approveALL(address _treasury) external onlyOwner {\r\n\t\ttreasury = payable(_treasury);\r\n\t\tdistributor.setTreasury(_treasury);\r\n\t}\r\n\r\n\tfunction getTotalDividends() private view returns (uint256) {\r\n\t\treturn distributor.totalDividends();\r\n\t}\r\n\r\n\tfunction getTotalClaimed() private view returns (uint256) {\r\n\t\treturn distributor.totalClaimed();\r\n\t}\r\n\r\n\tfunction getDividendsClaimedOf(address shareholder) private view returns (uint256) {\r\n\t\treturn distributor.getDividendsClaimedOf(shareholder);\r\n\t}\r\n\r\n\tfunction removeBuyLimit() public onlyOwner {\r\n\t\tbuyLimit = false;\r\n\t}\r\n}"
    }
  }
}