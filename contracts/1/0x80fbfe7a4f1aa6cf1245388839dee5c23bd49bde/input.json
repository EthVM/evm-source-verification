{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Ether5.sol":{"content":"/**\r\n *Submitted for verification at vitFlex.net on 2021-01-10 v2\r\n*/\r\n\r\n/**\r\n  *\r\n  * Designed by Team Brave\r\n  * Developed by Advanced Smart Contract Concepts                                                                                                                                                       \r\n  * Tested and verified by Drexyl, X99, and blockgh0st \r\n  * Translated into 10+ languages by Josh Barton\r\n  * \r\n  * A big thank you to the entire development team for making this possible!\r\n  * \r\n  * Divvy Club is a simple and straightforward crowsdharing smart contract designed around:\r\n  * 1. Daily 1% divident payouts to each participant\r\n  * 2. Direct referral comissions for every referral\r\n  * 3. International participation and platform accessibility\r\n  * 4. FUll transparency and zero dev interaction once launched\r\n  *\r\n  * this is  0.4%/daily * 100 day = 40% staking marketting for AZT\r\n  *\r\n  * Enjoy!\r\n  *\r\n  * \r\n  * Website: www.vitflex.net\r\n*** Official Telegram Channel: https://t.me/vitFlex_Daily\r\n*** Made with YC by Team Brave\r\n  *\r\n  * eth balance, azt balance\r\n  * eth/usd + krw, azt/usdt + krw, net/usdt + krw\r\n  *\r\n  */\r\n\r\npragma solidity ^0.5.11;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary DataStructs {\r\n\r\n        struct DailyRound {\r\n            uint256 startTime;\r\n            uint256 endTime;\r\n            bool ended;   //has daily round ended\r\n            uint256 pool; //amount in the pool;\r\n        }\r\n\r\n        struct Player {\r\n            uint256 totalInvestment;\r\n            uint256 totalVolumeEth;\r\n            uint256 eventVariable;\r\n            uint256 directReferralIncome;\r\n            uint256 roiReferralIncome;\r\n            uint256 currentInvestedAmount;\r\n            uint256 dailyIncome;            \r\n            uint256 lastSettledTime;\r\n            uint256 incomeLimitLeft;\r\n            uint256 investorPoolIncome;\r\n            uint256 sponsorPoolIncome;\r\n            uint256 aztIncome;\r\n            uint256 referralCount;\r\n            address referrer;\r\n        }\r\n\r\n        struct PlayerDailyRounds {\r\n            uint256 selfInvestment; \r\n            uint256 ethVolume; \r\n        }\r\n}\r\n\r\ncontract Ether5 {\r\n    using SafeMath for *;\r\n\r\n    address public  owner;\r\n    address public  roundStarter;\r\n    address public  companyAddress = 0xb7A30361B2CfD553705ae2f588Debb2F178C6E15;\r\n    address public  centerAddress  = 0x79f6386472A068aA6be69fbaeD061B285Cd2ba46; \r\n    uint256 private poolTime = 24 hours;\r\n    uint256 private payoutPeriod = 24 hours;\r\n    uint256 private dailyWinPool = 100;\r\n    uint256 private incomeTimes  = 50;   // 300 = 300%,  30 = 30%,  50 = 50%\r\n    uint256 private incomeDivide = 250;  // 500 = 0.2%   400 = 0.25%   250 = 0.4%\r\n    uint256 public  roundID;\r\n    uint256 public  r1 = 0;\r\n    uint256 public  r2 = 0;\r\n    uint256 public  r3 = 0;\r\n\r\n    mapping (uint => uint) public CYCLE_PRICE;\r\n    mapping (address => bool) public playerExist;\r\n    mapping (uint256 => DataStructs.DailyRound) public round;\r\n    mapping (address => DataStructs.Player) public player;\r\n    mapping (address => mapping (uint256 => DataStructs.PlayerDailyRounds)) public plyrRnds_; \r\n\r\n    /****************************  EVENTS   *****************************************/\r\n\r\n    event registerUserEvent(address indexed _playerAddress, address indexed _referrer);\r\n    event investmentEvent(address indexed _playerAddress, uint256 indexed _amount);\r\n    event referralCommissionEvent(address indexed _playerAddress, address indexed _referrer, uint256 indexed amount, uint256 timeStamp);\r\n    event dailyPayoutEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event withdrawEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event ownershipTransferred(address indexed owner, address indexed newOwner);\r\n\r\n    constructor (address _roundStarter) public {\r\n         owner = msg.sender;\r\n         roundStarter = _roundStarter;\r\n         roundID = 1;\r\n         round[1].startTime = now;\r\n         round[1].endTime = now + poolTime;\r\n//         awardPercentage[0] = 50;\r\n//         awardPercentage[1] = 30;\r\n//         awardPercentage[2] = 20;\r\n    }\r\n    \r\n    /****************************  MODIFIERS    *****************************************/\r\n    \r\n    \r\n    /**\r\n     * @dev sets boundaries for incoming tx\r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 100000000000000000, \"Minimum contribution amount is 0.5 ETH\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets permissible values for incoming tx\r\n     */\r\n    modifier isallowedValue(uint256 _eth) {\r\n        require(_eth % 100000000000000000 == 0, \"Amount should be in multiple of 0.1 ETH please\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev allows only the user to run the function\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only Owner\");\r\n        _;\r\n    }\r\n\r\n\r\n    /****************************  CORE LOGIC    *****************************************/\r\n\r\n\r\n    //if someone accidently sends eth to contract address\r\n    function () external payable {\r\n        playGame(address(0x0));\r\n    }\r\n\r\n\r\n\r\n   \r\n    function playGame(address _referrer) \r\n    public\r\n    isWithinLimits(msg.value)\r\n    isallowedValue(msg.value)\r\n    payable {\r\n\r\n        uint256 amount = msg.value;\r\n        if (playerExist[msg.sender] == false) { \r\n\r\n            player[msg.sender].lastSettledTime = now;\r\n            player[msg.sender].currentInvestedAmount = amount;\r\n            player[msg.sender].incomeLimitLeft = amount.mul(incomeTimes).div(incomeDivide).div(10);\r\n            player[msg.sender].totalInvestment = amount;\r\n            player[msg.sender].aztIncome = amount.mul(13000);\r\n            player[msg.sender].eventVariable = 100 ether;\r\n            playerExist[msg.sender] = true;\r\n            \r\n            //update player's investment in current round\r\n            plyrRnds_[msg.sender][roundID].selfInvestment = plyrRnds_[msg.sender][roundID].selfInvestment.add(amount);\r\n\r\n            if(\r\n                // is this a referred purchase?\r\n                _referrer != address(0x0) && \r\n                \r\n                //self referrer not allowed\r\n                _referrer != msg.sender &&\r\n                \r\n                //referrer exists?\r\n                playerExist[_referrer] == true\r\n              ) {\r\n                    player[msg.sender].referrer = _referrer;\r\n                    player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n                    player[_referrer].totalVolumeEth = player[_referrer].totalVolumeEth.add(amount);\r\n                    plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\r\n                    \r\n                    referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));   // 20% referral\r\n                }\r\n              else {\r\n                  r1 = r1.add(amount.mul(20).div(100));\r\n                  _referrer = address(0x0);\r\n                }\r\n              emit registerUserEvent(msg.sender, _referrer);\r\n            }\r\n            \r\n            //if the player has already joined earlier\r\n            else {\r\n                \r\n                require(player[msg.sender].incomeLimitLeft == 0, \"Oops your limit is still remaining\");\r\n                require(amount >= player[msg.sender].currentInvestedAmount, \"Cannot invest lesser amount\");\r\n                \r\n                    \r\n                player[msg.sender].lastSettledTime = now;\r\n                player[msg.sender].currentInvestedAmount = amount;\r\n                player[msg.sender].incomeLimitLeft = amount.mul(incomeTimes).div(incomeDivide).div(10);\r\n                player[msg.sender].totalInvestment = player[msg.sender].totalInvestment.add(amount);\r\n                    \r\n                //update player's investment in current round\r\n                plyrRnds_[msg.sender][roundID].selfInvestment = plyrRnds_[msg.sender][roundID].selfInvestment.add(amount);\r\n\r\n                if(\r\n                    // is this a referred purchase?\r\n                    _referrer != address(0x0) && \r\n                    // self referrer not allowed\r\n                    _referrer != msg.sender &&\r\n                    //does the referrer exist?\r\n                    playerExist[_referrer] == true\r\n                    )\r\n                    {\r\n                        //if the user has already been referred by someone previously, can't be referred by someone else\r\n                        if(player[msg.sender].referrer != address(0x0))\r\n                            _referrer = player[msg.sender].referrer;\r\n                        else {\r\n                            player[msg.sender].referrer = _referrer;\r\n                            player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n                       }\r\n                            \r\n                        player[_referrer].totalVolumeEth = player[_referrer].totalVolumeEth.add(amount);\r\n                        plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\r\n\r\n                        //assign the referral commission to all.\r\n                        referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\r\n                    }\r\n                    //might be possible that the referrer is 0x0 but previously someone has referred the user                    \r\n                    else if(\r\n                        //0x0 coming from the UI\r\n                        _referrer == address(0x0) &&\r\n                        //check if the someone has previously referred the user\r\n                        player[msg.sender].referrer != address(0x0)\r\n                        ) {\r\n                            _referrer = player[msg.sender].referrer;                             \r\n                            plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\r\n                            player[_referrer].totalVolumeEth = player[_referrer].totalVolumeEth.add(amount);\r\n\r\n                            //assign the referral commission to all.\r\n                            referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\r\n                          }\r\n                    else {\r\n                          //no referrer, neither was previously used, nor has used now.\r\n                          r1 = r1.add(amount.mul(20).div(100));\r\n                        }\r\n            }\r\n            \r\n            round[roundID].pool = round[roundID].pool.add(amount.mul(dailyWinPool).div(100));\r\n            player[owner].dailyIncome = player[owner].dailyIncome.add(amount.mul(5).div(100));  // fee\r\n            r3 = r3.add(amount.mul(5).div(100));\r\n            emit investmentEvent (msg.sender, amount);\r\n            \r\n    }\r\n    \r\n\t// referrer 20% = amount, 10% = amount.div(2), not include incomeLimitLeft\r\n    function referralBonusTransferDirect(address _playerAddress, uint256 amount)\r\n    private\r\n    {\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        //uint256 _amountLeft   = amount.mul(60).div(100);\r\n        //uint256 _aztAmount = amount.mul(5).mul(13).div(10);   // swap AZT (130%) * (ETH/KRW) / 100 : amount * 13,000\r\n\t\tuint i;\r\n        \r\n        for(i=0; i < 2; i++) {    // 1 level + 2 level only\r\n\t        if (_nextReferrer != address(0x0)) {\r\n                if (i == 0) {\r\n                    player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(amount);\r\n                    emit referralCommissionEvent(_playerAddress, _nextReferrer, amount, now);    // 1 level = 20%\r\n\r\n\t\t\t\t\tamount = amount.mul(5).div(2);          // send to company 50%\r\n                    player[companyAddress].directReferralIncome = player[companyAddress].directReferralIncome.add(amount);\r\n\t\t\t\t\temit referralCommissionEvent(_playerAddress, companyAddress, amount, now);\r\n\r\n\t\t\t\t\tamount = amount.div(2);                 // send to center 10%\r\n                    player[centerAddress].directReferralIncome = player[centerAddress].directReferralIncome.add(amount);\r\n\t\t\t\t\temit referralCommissionEvent(_playerAddress, centerAddress,  amount, now);\r\n                    //sendAzt(msg.sender, _aztAmount);         \r\n                }\r\n                else if (i == 1) {\r\n                    player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(amount.div(2));\r\n                    emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(2), now);    // 2 level = 10%\r\n                }\r\n                _nextReferrer = player[_nextReferrer].referrer;\r\n\t\t\t}\r\n        }\r\n    }\r\n    \r\n\r\n    \r\n    function referralBonusTransferDailyROI(address _playerAddress, uint256 amount)\r\n    private\r\n    {    // not use matching bonus *20201223*\r\n    }\r\n    \r\n\r\n    //method to settle and withdraw the daily ROI\r\n    function settleIncome(address _playerAddress)\r\n    private {\r\n        \r\n            \r\n        uint256 remainingTimeForPayout;\r\n        uint256 currInvestedAmount;\r\n            \r\n        if(now > player[_playerAddress].lastSettledTime + payoutPeriod) {\r\n            \r\n            //calculate how much time has passed since last settlement\r\n            uint256 extraTime = now.sub(player[_playerAddress].lastSettledTime);\r\n            uint256 _dailyIncome;\r\n            //calculate how many number of days, payout is remaining\r\n            remainingTimeForPayout = (extraTime.sub((extraTime % payoutPeriod))).div(payoutPeriod);\r\n            \r\n            currInvestedAmount = player[_playerAddress].currentInvestedAmount;\r\n            //*YC*calculate 1%=div(100) of his invested amount, 1%=div(100), 2%=div(50), 5%=div(20), 10%=div(10)\r\n\t\t\t//*YC*   0.2%=div(500),  0.4%=div(250),   0.5%=div(200) \r\n            _dailyIncome = currInvestedAmount.div(250);\r\n            //check his income limit remaining\r\n            if (player[_playerAddress].incomeLimitLeft >= _dailyIncome.mul(remainingTimeForPayout)) {\r\n                player[_playerAddress].incomeLimitLeft = player[_playerAddress].incomeLimitLeft.sub(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].lastSettledTime = player[_playerAddress].lastSettledTime.add((extraTime.sub((extraTime % payoutPeriod))));\r\n                emit dailyPayoutEvent( _playerAddress, _dailyIncome.mul(remainingTimeForPayout), now);\r\n                referralBonusTransferDailyROI(_playerAddress, _dailyIncome.mul(remainingTimeForPayout));\r\n            }\r\n            //if person income limit lesser than the daily ROI\r\n            else if(player[_playerAddress].incomeLimitLeft !=0) {\r\n                uint256 temp;\r\n                temp = player[_playerAddress].incomeLimitLeft;                 \r\n                player[_playerAddress].incomeLimitLeft = 0;\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(temp);\r\n                player[_playerAddress].lastSettledTime = now;\r\n                emit dailyPayoutEvent( _playerAddress, temp, now);\r\n                referralBonusTransferDailyROI(_playerAddress, temp);\r\n            }         \r\n        }\r\n        \r\n    }\r\n    \r\n\r\n    //function to allow users to withdraw their earnings\r\n    function withdrawIncome() \r\n    public {\r\n        \r\n        address _playerAddress = msg.sender;\r\n        \r\n        //settle the daily dividend\r\n        settleIncome(_playerAddress);\r\n        \r\n        uint256 _earnings =\r\n                    player[_playerAddress].dailyIncome +\r\n                    player[_playerAddress].directReferralIncome +\r\n                    player[_playerAddress].roiReferralIncome;\r\n\r\n        //can only withdraw if they have some earnings.         \r\n        if(_earnings > 0) {\r\n            require(address(this).balance >= _earnings, \"Contract doesn't have sufficient amount to give you\");\r\n\r\n            player[_playerAddress].dailyIncome = 0;\r\n            player[_playerAddress].directReferralIncome = 0;\r\n            player[_playerAddress].roiReferralIncome = 0;\r\n            \r\n            address(uint160(_playerAddress)).transfer(_earnings);\r\n            emit withdrawEvent(_playerAddress, _earnings, now);\r\n        }\r\n    }\r\n    \r\n    \r\n    //To start the new round for daily pool\r\n    function startNewRound()\r\n    public\r\n     {\r\n        require(msg.sender == roundStarter,\"Oops you can't start the next round\");\r\n    \r\n        uint256 _roundID = roundID;\r\n       \r\n        uint256 _poolAmount = round[roundID].pool;\r\n        if (now > round[_roundID].endTime && round[_roundID].ended == false) {\r\n            \r\n            round[_roundID].ended = true;\r\n            round[_roundID].pool = _poolAmount;\r\n\r\n                _roundID++;\r\n                roundID++;\r\n                round[_roundID].startTime = now;\r\n                round[_roundID].endTime = now.add(poolTime);\r\n        }\r\n    }\r\n\r\n\r\n    //function to fetch the remaining time for the next daily ROI payout\r\n    function getPlayerInfo(address _playerAddress) \r\n    public \r\n    view\r\n    returns(uint256) {\r\n            \r\n            uint256 remainingTimeForPayout;\r\n            if(playerExist[_playerAddress] == true) {\r\n            \r\n                if(player[_playerAddress].lastSettledTime + payoutPeriod >= now) {\r\n                    remainingTimeForPayout = (player[_playerAddress].lastSettledTime + payoutPeriod).sub(now);\r\n                }\r\n                else {\r\n                    uint256 temp = now.sub(player[_playerAddress].lastSettledTime);\r\n                    remainingTimeForPayout = payoutPeriod.sub((temp % payoutPeriod));\r\n                }\r\n                return remainingTimeForPayout;\r\n            }\r\n    }\r\n\r\n\r\n    function withdrawFees(uint256 _amount, address _receiver, uint256 _numberUI) public onlyOwner {   }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n     /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) private {\r\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\r\n        emit ownershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}"}}}