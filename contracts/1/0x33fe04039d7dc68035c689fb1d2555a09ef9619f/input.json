{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "WishingWell.sol": {
      "content": "//\r\n// CLV Wishing Well\r\n// Trust the plan.\r\n//\r\n\r\npragma solidity ^0.5.16;\r\n\r\ninterface CloverContract {\r\n\tfunction allowance(address, address) external view returns (uint256);\r\n  function approve(address spender, uint amount) external returns (bool);\r\n\tfunction balanceOf(address) external view returns (uint256);\r\n\tfunction transfer(address, uint256) external returns (bool);\r\n\tfunction transferFrom(address, address, uint256) external returns (bool);\r\n}\r\ninterface CLV2DContract {\r\n\tfunction balanceOf(address) external view returns (uint256);\r\n\tfunction buy(uint256) external returns (uint256);\r\n\tfunction sell(uint256) external returns (uint256);\r\n\tfunction reinvest() external returns (uint256);\r\n\tfunction calculateResult(uint256, bool, bool) external view returns (uint256);\r\n\tfunction dividendsOf(address) external view returns (uint256);\r\n}\r\n\r\ncontract WishingWell {\r\n  uint256 constant private startingPotSize = 1000000; //pot must always start with 1\r\n  uint256 constant private skimPercent = 20; //skim 5% of winnins to put into C2D (100/20 == 5)\r\n  uint constant public bigPotFrequency = 50; // how often the big pot occurs\r\n  uint constant private minute = 60; //60 seconds in a minute\r\n\r\n\tevent Bet(address better, uint256 amount, uint256 potBalance);\r\n  event Withdraw(address user, uint256 amount);\r\n  event StartNextRound(uint256 roundNumber, uint256 startingPot);\r\n\t\r\n  struct User {\r\n\t\tuint256 winnings;\r\n\t}\r\n\r\n\tstruct Info {\r\n    CloverContract clv;\r\n    CLV2DContract c2d;\r\n\r\n\t\tmapping(address => User) users;\r\n    address lastPlayer;\r\n    address lastWinner;\r\n    uint256 minBet;\r\n    uint256 roundEndTime;\r\n    uint256 roundNumber;\r\n    uint256 playsThisRound;\r\n    uint256 heldWinnings;\r\n\t}\r\n\r\n  modifier gameIsOver {require(now >= info.roundEndTime); _; }\r\n  modifier gameIsNotOver {require(now < info.roundEndTime); _; }\r\n  \r\n  Info private info;\r\n\r\n\tconstructor(address _CLVaddress, address _C2Daddress) public {\r\n    info.clv = CloverContract(_CLVaddress);\r\n    info.c2d = CLV2DContract(_C2Daddress);\r\n    \r\n    info.lastWinner = address(0x0);\r\n    info.lastPlayer = address(0x0);\r\n    info.roundEndTime = 0;\r\n    info.heldWinnings = 0;\r\n\t}\r\n\r\n  function calcMinBet() internal view returns (uint256){\r\n    uint256 newMin = getPotBalance()/100; //min bet is 1% of current Pot\r\n    if(newMin<=info.minBet){//in case where the minimumBet hasn't grown\r\n      newMin = info.minBet+1;\r\n    }\r\n    return newMin;\r\n  }\r\n\r\n  //get current balance (winnings of a user)\r\n  function currentWinnings(address _user) public view returns (uint256){\r\n    return info.users[_user].winnings;\r\n  }\r\n\r\n  function  getPotBalance() internal view returns (uint256){\r\n    return (info.clv.balanceOf(address(this)) - info.heldWinnings);\r\n  }\r\n\r\n  function withdrawWinnings() external returns (uint256){\r\n    uint256 currBal = currentWinnings(msg.sender);\r\n    //check that that we have something\r\n    require(currBal > 0, \"Need more than 0CLV in winnings to withdraw\");\r\n\t\tinfo.clv.transfer(msg.sender, currBal);\r\n\t\tinfo.users[msg.sender].winnings -= currBal;\r\n    info.heldWinnings -= currBal;\r\n\r\n    emit Withdraw(msg.sender, currBal);\r\n\t\treturn currBal;\r\n  }\r\n  //current status of the well\r\n  function wellInfo(address _user) public view returns \r\n  (uint256 potBalance, \r\n  uint256 roundNumber, \r\n  uint256 playsThisRound,\r\n  uint256 roundEndTime,\r\n  uint256 minBet,\r\n  address lastPlayer,\r\n  address lastWinner,\r\n  uint256 wellBalance,\r\n  uint256 userAllowance,\r\n  uint256 userWinnings,\r\n  uint256 wellC2Dbalance,\r\n  uint256 bigPotFreq,\r\n  uint256 wellCLVLiquidBalance){\r\n    potBalance = getPotBalance();\r\n    roundNumber = info.roundNumber;\r\n    playsThisRound = info.playsThisRound;\r\n    roundEndTime = info.roundEndTime;\r\n    minBet = info.minBet;\r\n    lastPlayer = info.lastPlayer;\r\n    lastWinner = info.lastWinner;\r\n    wellBalance = info.clv.balanceOf(address(this));\r\n    userAllowance = info.clv.allowance(_user, address(this));\r\n    userWinnings = currentWinnings(_user);\r\n    wellC2Dbalance = info.c2d.balanceOf(address(this));\r\n    wellCLVLiquidBalance = info.c2d.calculateResult(wellC2Dbalance, false, false);\r\n    bigPotFreq = bigPotFrequency;\r\n  }\r\n\r\n  function bet(uint256 _amount) public gameIsNotOver returns (uint256){\r\n    //_tokens come it with 6 decimals. ie 1 CLV comes in as 1000000\r\n    require(_amount >= info.minBet);\r\n    require(info.clv.transferFrom(msg.sender, address(this), _amount));\r\n    info.playsThisRound += 1;\r\n    if(msg.sender == info.lastPlayer){\r\n      info.roundEndTime += 1*minute;//add 1 min if they just played\r\n    } else{\r\n      info.roundEndTime += 5*minute;//add 5 mins if they did not just play\r\n    }\r\n    info.minBet = calcMinBet();\r\n    info.lastPlayer = msg.sender;\r\n\t\temit Bet(msg.sender, _amount, getPotBalance());\r\n    return _amount;\r\n  } \r\n\r\n  function startNextRound(uint256 _bet) external gameIsOver returns(uint256){\r\n    //first need to clean up last round\r\n    if(info.playsThisRound>0){//if any bets were played\r\n      if(getPotBalance()>startingPotSize){\r\n        uint256 available = getPotBalance() - startingPotSize;\r\n        uint256 forC2D = available/20; //take 5%\r\n        uint256 playerWinnings = available-forC2D;\r\n        info.users[info.lastPlayer].winnings += playerWinnings;\r\n        info.heldWinnings += playerWinnings;\r\n        \r\n        //transfer to c2d\r\n        if(forC2D>0 && ((info.roundNumber+1) % bigPotFrequency != 0)){\r\n          info.clv.approve(address(info.c2d), forC2D);\r\n          info.c2d.buy(forC2D);\r\n        }\r\n      }\r\n    }//else dont modify pot or users winnings.\r\n    info.lastWinner = info.lastPlayer;\r\n\r\n    //start next round\r\n    info.roundNumber++;\r\n    //fill pot with c2d\r\n    if(info.roundNumber%bigPotFrequency == 0){\r\n      //sell all c2d\r\n      uint256 c2dBal = info.c2d.balanceOf(address(this));\r\n      info.c2d.sell(c2dBal);\r\n      //reinvest c2d dividends (if we have any)\r\n      if(info.c2d.dividendsOf(address(this))>0){\r\n        info.c2d.reinvest();\r\n      }\r\n    }\r\n\r\n    info.playsThisRound = 0;\r\n    info.lastPlayer = address(0x0);\r\n    info.roundEndTime = now+5*minute;//add 5 mins + the bettings addition (also 5)\r\n    info.minBet = 222222; //always start with a minbet of 0.222222\r\n    emit StartNextRound(info.roundNumber, getPotBalance());\r\n\r\n    //now place inital bet\r\n    return(bet(_bet));\r\n  }\r\n\r\n}"
    }
  }
}