{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "HectorBondStakeDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity 0.7.5;\r\n\r\ninterface IOwnable {\r\n  function policy() external view returns (address);\r\n\r\n  function renounceManagement() external;\r\n  \r\n  function pushManagement( address newOwner_ ) external;\r\n  \r\n  function pullManagement() external;\r\n}\r\n\r\ncontract Ownable is IOwnable {\r\n\r\n    address internal _owner;\r\n    address internal _newOwner;\r\n\r\n    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\r\n    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        _owner = msg.sender;\r\n        emit OwnershipPushed( address(0), _owner );\r\n    }\r\n\r\n    function policy() public view override returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyPolicy() {\r\n        require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\r\n        _;\r\n    }\r\n\r\n    function renounceManagement() public virtual override onlyPolicy() {\r\n        emit OwnershipPushed( _owner, address(0) );\r\n        _owner = address(0);\r\n    }\r\n\r\n    function pushManagement( address newOwner_ ) public virtual override onlyPolicy() {\r\n        require( newOwner_ != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipPushed( _owner, newOwner_ );\r\n        _newOwner = newOwner_;\r\n    }\r\n    \r\n    function pullManagement() public virtual override {\r\n        require( msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\r\n        emit OwnershipPulled( _owner, _newOwner );\r\n        _owner = _newOwner;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function sqrrt(uint256 a) internal pure returns (uint c) {\r\n        if (a > 3) {\r\n            c = a;\r\n            uint b = add( div( a, 2), 1 );\r\n            while (b < c) {\r\n                c = b;\r\n                b = div( add( div( a, b ), b), 2 );\r\n            }\r\n        } else if (a != 0) {\r\n            c = 1;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addressToString(address _address) internal pure returns(string memory) {\r\n        bytes32 _bytes = bytes32(uint256(_address));\r\n        bytes memory HEX = \"0123456789abcdef\";\r\n        bytes memory _addr = new bytes(42);\r\n\r\n        _addr[0] = '0';\r\n        _addr[1] = 'x';\r\n\r\n        for(uint256 i = 0; i < 20; i++) {\r\n            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\r\n            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\r\n        }\r\n\r\n        return string(_addr);\r\n\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract ERC20 is IERC20 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // TODO comment actual hash value.\r\n    bytes32 constant private ERC20TOKEN_ERC1820_INTERFACE_ID = keccak256( \"ERC20Token\" );\r\n    \r\n    mapping (address => uint256) internal _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) internal _allowances;\r\n\r\n    uint256 internal _totalSupply;\r\n\r\n    string internal _name;\r\n    \r\n    string internal _symbol;\r\n    \r\n    uint8 internal _decimals;\r\n\r\n    constructor (string memory name_, string memory symbol_, uint8 decimals_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account_, uint256 ammount_) internal virtual {\r\n        require(account_ != address(0), \"ERC20: mint to the zero address\");\r\n        _beforeTokenTransfer(address( this ), account_, ammount_);\r\n        _totalSupply = _totalSupply.add(ammount_);\r\n        _balances[account_] = _balances[account_].add(ammount_);\r\n        emit Transfer(address( this ), account_, ammount_);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n  function _beforeTokenTransfer( address from_, address to_, uint256 amount_ ) internal virtual { }\r\n}\r\n\r\ninterface IERC2612Permit {\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n}\r\n\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\nabstract contract ERC20Permit is ERC20, IERC2612Permit {\r\n    using Counters for Counters.Counter;\r\n\r\n    mapping(address => Counters.Counter) private _nonces;\r\n\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n\r\n    constructor() {\r\n        uint256 chainID;\r\n        assembly {\r\n            chainID := chainid()\r\n        }\r\n\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                keccak256(bytes(name())),\r\n                keccak256(bytes(\"1\")), // Version\r\n                chainID,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual override {\r\n        require(block.timestamp <= deadline, \"Permit: expired deadline\");\r\n\r\n        bytes32 hashStruct =\r\n            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner].current(), deadline));\r\n\r\n        bytes32 _hash = keccak256(abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct));\r\n\r\n        address signer = ecrecover(_hash, v, r, s);\r\n        require(signer != address(0) && signer == owner, \"ZeroSwapPermit: Invalid signature\");\r\n\r\n        _nonces[owner].increment();\r\n        _approve(owner, spender, amount);\r\n    }\r\n\r\n    function nonces(address owner) public view override returns (uint256) {\r\n        return _nonces[owner].current();\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary FullMath {\r\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\r\n        uint256 mm = mulmod(x, y, uint256(-1));\r\n        l = x * y;\r\n        h = mm - l;\r\n        if (mm < l) h -= 1;\r\n    }\r\n\r\n    function fullDiv(\r\n        uint256 l,\r\n        uint256 h,\r\n        uint256 d\r\n    ) private pure returns (uint256) {\r\n        uint256 pow2 = d & -d;\r\n        d /= pow2;\r\n        l /= pow2;\r\n        l += h * ((-pow2) / pow2 + 1);\r\n        uint256 r = 1;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        return l * r;\r\n    }\r\n\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 d\r\n    ) internal pure returns (uint256) {\r\n        (uint256 l, uint256 h) = fullMul(x, y);\r\n        uint256 mm = mulmod(x, y, d);\r\n        if (mm > l) h -= 1;\r\n        l -= mm;\r\n        require(h < d, 'FullMath::mulDiv: overflow');\r\n        return fullDiv(l, h, d);\r\n    }\r\n}\r\n\r\nlibrary FixedPoint {\r\n\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    struct uq144x112 {\r\n        uint256 _x;\r\n    }\r\n\r\n    uint8 private constant RESOLUTION = 112;\r\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\r\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\r\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\r\n\r\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\r\n        return uint112(self._x >> RESOLUTION);\r\n    }\r\n\r\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\r\n\r\n        return uint(self._x) / 5192296858534827;\r\n    }\r\n\r\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\r\n        if (numerator == 0) return FixedPoint.uq112x112(0);\r\n\r\n        if (numerator <= uint144(-1)) {\r\n            uint256 result = (numerator << RESOLUTION) / denominator;\r\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\r\n            return uq112x112(uint224(result));\r\n        } else {\r\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\r\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\r\n            return uq112x112(uint224(result));\r\n        }\r\n    }\r\n}\r\n\r\ninterface ITreasury {\r\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( uint send_ );\r\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\r\n}\r\n\r\ninterface IBondCalculator {\r\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\r\n    function markdown( address _LP ) external view returns ( uint );\r\n}\r\n\r\ninterface IStaking {\r\n    function stake( uint _amount, address _recipient ) external returns ( bool );\r\n    function claim( address _recipient ) external;\r\n}\r\n\r\ninterface ISHEC {\r\n    function gonsForBalance( uint amount ) external view returns ( uint );\r\n    function balanceForGons( uint gons ) external view returns ( uint );\r\n}\r\n\r\ncontract HectorBondStakeDepository is Ownable {\r\n\r\n    using FixedPoint for *;\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint;\r\n\r\n\r\n\r\n\r\n    /* ======== EVENTS ======== */\r\n\r\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\r\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\r\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\r\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\r\n\r\n\r\n\r\n\r\n    /* ======== STATE VARIABLES ======== */\r\n\r\n    address public immutable HEC; // intermediate reward token from treasury\r\n    address public immutable sHEC; // token given as payment for bond\r\n    address public immutable principle; // token used to create bond\r\n    address public immutable treasury; // mints HEC when receives principle\r\n    address public immutable DAO; // receives profit share from bond\r\n\r\n    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\r\n    address public immutable bondCalculator; // calculates value of LP tokens\r\n\r\n    address public staking; // to stake and claim if no staking warmup\r\n\r\n    Terms public terms; // stores terms for new bonds\r\n    Adjust public adjustment; // stores adjustment to BCV data\r\n\r\n    mapping( address => Bond ) public _bondInfo; // stores bond information for depositors\r\n\r\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\r\n    uint public lastDecay; // reference block for debt decay\r\n    \r\n    uint public totalPrinciple; // total principle bonded through this depository\r\n\r\n    string internal name_; //name of this bond\r\n\r\n\r\n    /* ======== STRUCTS ======== */\r\n\r\n    // Info for creating new bonds\r\n    struct Terms {\r\n        uint controlVariable; // scaling variable for price\r\n        uint vestingTerm; // in blocks\r\n        uint minimumPrice; // vs principle value\r\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\r\n        uint fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\r\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\r\n    }\r\n\r\n    // Info for bond holder with gons\r\n    struct Bond {\r\n        uint gonsPayout; // sHEC gons remaining to be paid\r\n        uint hecPayout; //hec amount at the moment of bond\r\n        uint vesting; // Blocks left to vest\r\n        uint lastBlock; // Last interaction\r\n        uint pricePaid; // In DAI, for front end viewing\r\n    }\r\n\r\n    // Info for incremental adjustments to control variable \r\n    struct Adjust {\r\n        bool add; // addition or subtraction\r\n        uint rate; // increment\r\n        uint target; // BCV when adjustment finished\r\n        uint buffer; // minimum length (in blocks) between adjustments\r\n        uint lastBlock; // block when last adjustment made\r\n    }\r\n\r\n\r\n\r\n\r\n    /* ======== INITIALIZATION ======== */\r\n\r\n    constructor ( \r\n        string memory _name,\r\n        address _HEC,\r\n        address _sHEC,\r\n        address _principle,\r\n        address _treasury, \r\n        address _DAO, \r\n        address _bondCalculator\r\n    ) {\r\n        require( _HEC != address(0) );\r\n        HEC = _HEC;\r\n        require( _sHEC != address(0) );\r\n        sHEC = _sHEC;\r\n        require( _principle != address(0) );\r\n        principle = _principle;\r\n        require( _treasury != address(0) );\r\n        treasury = _treasury;\r\n        require( _DAO != address(0) );\r\n        DAO = _DAO;\r\n        // bondCalculator should be address(0) if not LP bond\r\n        bondCalculator = _bondCalculator;\r\n        isLiquidityBond = ( _bondCalculator != address(0) );\r\n        name_ = _name;\r\n    }\r\n\r\n    /**\r\n     *  @notice initializes bond parameters\r\n     *  @param _controlVariable uint\r\n     *  @param _vestingTerm uint\r\n     *  @param _minimumPrice uint\r\n     *  @param _maxPayout uint\r\n     *  @param _fee uint\r\n     *  @param _maxDebt uint\r\n     *  @param _initialDebt uint\r\n     */\r\n    function initializeBondTerms( \r\n        uint _controlVariable, \r\n        uint _vestingTerm,\r\n        uint _minimumPrice,\r\n        uint _maxPayout,\r\n        uint _fee,\r\n        uint _maxDebt,\r\n        uint _initialDebt\r\n    ) external onlyPolicy() {\r\n        terms = Terms ({\r\n            controlVariable: _controlVariable,\r\n            vestingTerm: _vestingTerm,\r\n            minimumPrice: _minimumPrice,\r\n            maxPayout: _maxPayout,\r\n            fee: _fee,\r\n            maxDebt: _maxDebt\r\n        });\r\n        totalDebt = _initialDebt;\r\n        lastDecay = block.number;\r\n    }\r\n\r\n\r\n\r\n    \r\n    /* ======== POLICY FUNCTIONS ======== */\r\n\r\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT, MINPRICE }\r\n    /**\r\n     *  @notice set parameters for new bonds\r\n     *  @param _parameter PARAMETER\r\n     *  @param _input uint\r\n     */\r\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\r\n        if ( _parameter == PARAMETER.VESTING ) { // 0\r\n            require( _input >= 10000, \"Vesting must be longer than 3 hours\" );\r\n            terms.vestingTerm = _input;\r\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\r\n            require( _input <= 1000, \"Payout cannot be above 1 percent\" );\r\n            terms.maxPayout = _input;\r\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\r\n            require( _input <= 10000, \"DAO fee cannot exceed payout\" );\r\n            terms.fee = _input;\r\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\r\n            terms.maxDebt = _input;\r\n        } else if ( _parameter == PARAMETER.MINPRICE ) { // 4\r\n            terms.minimumPrice = _input;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @notice set control variable adjustment\r\n     *  @param _addition bool\r\n     *  @param _increment uint\r\n     *  @param _target uint\r\n     *  @param _buffer uint\r\n     */\r\n    function setAdjustment (\r\n        bool _addition,\r\n        uint _increment, \r\n        uint _target,\r\n        uint _buffer \r\n    ) external onlyPolicy() {\r\n        adjustment = Adjust({\r\n            add: _addition,\r\n            rate: _increment,\r\n            target: _target,\r\n            buffer: _buffer,\r\n            lastBlock: block.number\r\n        });\r\n    }\r\n\r\n    /**\r\n     *  @notice set contract for auto stake\r\n     *  @param _staking address\r\n     */\r\n    function setStaking( address _staking) external onlyPolicy() {\r\n        require( _staking != address(0) );\r\n        staking = _staking;\r\n    }\r\n\r\n\r\n    \r\n\r\n    /* ======== USER FUNCTIONS ======== */\r\n\r\n    /**\r\n     *  @notice deposit bond\r\n     *  @param _amount uint\r\n     *  @param _maxPrice uint\r\n     *  @param _depositor address\r\n     *  @return uint\r\n     */\r\n    function deposit( \r\n        uint _amount, \r\n        uint _maxPrice,\r\n        address _depositor\r\n    ) external returns ( uint ) {\r\n        require( _depositor != address(0), \"Invalid address\" );\r\n\r\n        decayDebt();\r\n        require( totalDebt <= terms.maxDebt, \"Max capacity reached\" );\r\n        \r\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\r\n        //uint nativePrice = _bondPrice();\r\n\r\n        require( _maxPrice >= _bondPrice(), \"Slippage limit: more than max price\" ); // slippage protection\r\n\r\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\r\n        uint payout = payoutFor( value ); // payout to bonder is computed\r\n\r\n        require( payout >= 10000000, \"Bond too small\" ); // must be > 0.01 HEC ( underflow protection )\r\n        require( payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\r\n\r\n        // profits are calculated\r\n        uint fee = payout.mul( terms.fee ).div( 10000 );\r\n        uint profit = value.sub( payout ).sub( fee );\r\n\r\n        /**\r\n            principle is transferred in\r\n            approved and\r\n            deposited into the treasury, returning (_amount - profit) HEC\r\n         */\r\n        IERC20( principle ).safeTransferFrom( msg.sender, address(this), _amount );\r\n        IERC20( principle ).approve( address( treasury ), _amount );\r\n        ITreasury( treasury ).deposit( _amount, principle, profit );\r\n        \r\n        totalPrinciple=totalPrinciple.add(_amount);\r\n        \r\n        if ( fee != 0 ) { // fee is transferred to dao \r\n            IERC20( HEC ).safeTransfer( DAO, fee ); \r\n        }\r\n        \r\n        // total debt is increased\r\n        totalDebt = totalDebt.add( value ); \r\n        //TODO\r\n        //uint stakeAmount = totalBond.sub(fee);\r\n        IERC20( HEC ).approve( staking, payout );\r\n        IStaking( staking ).stake( payout, address(this) );\r\n        IStaking( staking ).claim( address(this) );\r\n        uint stakeGons=ISHEC(sHEC).gonsForBalance(payout);\r\n\r\n        // depositor info is stored\r\n        _bondInfo[ _depositor ] = Bond({ \r\n            gonsPayout: _bondInfo[ _depositor ].gonsPayout.add( stakeGons ),\r\n            hecPayout: _bondInfo[ _depositor ].hecPayout.add( payout ),\r\n            vesting: terms.vestingTerm,\r\n            lastBlock: block.number,\r\n            pricePaid: priceInUSD\r\n        });\r\n\r\n        // indexed events are emitted\r\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\r\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\r\n\r\n        adjust(); // control variable is adjusted\r\n        return payout; \r\n    }\r\n\r\n    /** \r\n     *  @notice redeem bond for user, keep the parameter bool _stake for compatibility of redeem helper\r\n     *  @param _recipient address\r\n     *  @param _stake bool\r\n     *  @return uint\r\n     */ \r\n    function redeem( address _recipient, bool _stake) external returns ( uint ) {        \r\n        Bond memory info = _bondInfo[ _recipient ];\r\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\r\n\r\n        require ( percentVested >= 10000 ,\"not yet fully vested\") ; // if fully vested\r\n        delete _bondInfo[ _recipient ]; // delete user info\r\n        uint _amount = ISHEC(sHEC).balanceForGons(info.gonsPayout);\r\n        emit BondRedeemed( _recipient, _amount, 0 ); // emit bond data\r\n        IERC20( sHEC ).transfer( _recipient, _amount ); // pay user everything due\r\n        return _amount;\r\n    }\r\n\r\n\r\n\r\n    \r\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\r\n\r\n    /**\r\n     *  @notice makes incremental adjustment to control variable\r\n     */\r\n    function adjust() internal {\r\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\r\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\r\n            uint initial = terms.controlVariable;\r\n            if ( adjustment.add ) {\r\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\r\n                if ( terms.controlVariable >= adjustment.target ) {\r\n                    adjustment.rate = 0;\r\n                }\r\n            } else {\r\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\r\n                if ( terms.controlVariable <= adjustment.target ) {\r\n                    adjustment.rate = 0;\r\n                }\r\n            }\r\n            adjustment.lastBlock = block.number;\r\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @notice reduce total debt\r\n     */\r\n    function decayDebt() internal {\r\n        totalDebt = totalDebt.sub( debtDecay() );\r\n        lastDecay = block.number;\r\n    }\r\n\r\n\r\n\r\n\r\n    /* ======== VIEW FUNCTIONS ======== */\r\n\r\n    /**\r\n     *  @notice determine maximum bond size\r\n     *  @return uint\r\n     */\r\n    function maxPayout() public view returns ( uint ) {\r\n        return IERC20( HEC ).totalSupply().mul( terms.maxPayout ).div( 100000 );\r\n    }\r\n\r\n    /**\r\n     *  @notice calculate interest due for new bond\r\n     *  @param _value uint\r\n     *  @return uint\r\n     */\r\n    function payoutFor( uint _value ) public view returns ( uint ) {\r\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e16 );\r\n    }\r\n\r\n\r\n    /**\r\n     *  @notice calculate current bond premium\r\n     *  @return price_ uint\r\n     */\r\n    function bondPrice() public view returns ( uint price_ ) {        \r\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\r\n        if ( price_ < terms.minimumPrice ) {\r\n            price_ = terms.minimumPrice;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @notice calculate current bond price and remove floor if above\r\n     *  @return price_ uint\r\n     */\r\n    function _bondPrice() internal returns ( uint price_ ) {\r\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\r\n        if ( price_ < terms.minimumPrice ) {\r\n            price_ = terms.minimumPrice;        \r\n        } else if ( terms.minimumPrice != 0 ) {\r\n            terms.minimumPrice = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @notice converts bond price to DAI value\r\n     *  @return price_ uint\r\n     */\r\n    function bondPriceInUSD() public view returns ( uint price_ ) {\r\n        if( isLiquidityBond ) {\r\n            price_ = bondPrice().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 100 );\r\n        } else {\r\n            price_ = bondPrice().mul( 10 ** IERC20( principle ).decimals() ).div( 100 );\r\n        }\r\n    }\r\n    \r\n    /**\r\n     *  @notice return bond info with latest sHEC balance calculated from gons\r\n     *  @param _depositor address\r\n     *  @return payout uint\r\n     *  @return vesting uint\r\n     *  @return lastBlock uint\r\n     *  @return pricePaid uint\r\n     */\r\n    function bondInfo(address _depositor) public view returns ( uint payout,uint vesting,uint lastBlock,uint pricePaid ) {\r\n        Bond memory info = _bondInfo[ _depositor ];\r\n        payout=ISHEC(sHEC).balanceForGons(info.gonsPayout);\r\n        vesting=info.vesting;\r\n        lastBlock=info.lastBlock;\r\n        pricePaid=info.pricePaid;\r\n    }\r\n\r\n\r\n    /**\r\n     *  @notice calculate current ratio of debt to HEC supply\r\n     *  @return debtRatio_ uint\r\n     */\r\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \r\n        uint supply = IERC20( HEC ).totalSupply();\r\n        debtRatio_ = FixedPoint.fraction( \r\n            currentDebt().mul( 1e9 ), \r\n            supply\r\n        ).decode112with18().div( 1e18 );\r\n    }\r\n\r\n    /**\r\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\r\n     *  @return uint\r\n     */\r\n    function standardizedDebtRatio() external view returns ( uint ) {\r\n        if ( isLiquidityBond ) {\r\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\r\n        } else {\r\n            return debtRatio();\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @notice calculate debt factoring in decay\r\n     *  @return uint\r\n     */\r\n    function currentDebt() public view returns ( uint ) {\r\n        return totalDebt.sub( debtDecay() );\r\n    }\r\n\r\n    /**\r\n     *  @notice amount to decay total debt by\r\n     *  @return decay_ uint\r\n     */\r\n    function debtDecay() public view returns ( uint decay_ ) {\r\n        uint blocksSinceLast = block.number.sub( lastDecay );\r\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\r\n        if ( decay_ > totalDebt ) {\r\n            decay_ = totalDebt;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     *  @notice calculate how far into vesting a depositor is\r\n     *  @param _depositor address\r\n     *  @return percentVested_ uint\r\n     */\r\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\r\n        Bond memory bond = _bondInfo[ _depositor ];\r\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\r\n        uint vesting = bond.vesting;\r\n\r\n        if ( vesting > 0 ) {\r\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\r\n        } else {\r\n            percentVested_ = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @notice calculate amount of HEC available for claim by depositor\r\n     *  @param _depositor address\r\n     *  @return pendingPayout_ uint\r\n     */\r\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\r\n        uint percentVested = percentVestedFor( _depositor );\r\n        uint payout = ISHEC(sHEC).balanceForGons(_bondInfo[ _depositor ].gonsPayout);\r\n\r\n        if ( percentVested >= 10000 ) {\r\n            pendingPayout_ = payout;\r\n        } else {\r\n            pendingPayout_ = 0;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     *  @notice show the name of current bond\r\n     *  @return _name string\r\n     */\r\n    function name() public view returns (string memory _name) {\r\n        return name_;\r\n    }\r\n\r\n\r\n\r\n\r\n    /* ======= AUXILLIARY ======= */\r\n\r\n    /**\r\n     *  @notice allow anyone to send lost tokens (excluding principle or HEC) to the DAO\r\n     *  @return bool\r\n     */\r\n    function recoverLostToken( address _token ) external returns ( bool ) {\r\n        require( _token != HEC );\r\n        require( _token != sHEC );\r\n        require( _token != principle );\r\n        IERC20( _token ).safeTransfer( DAO, IERC20( _token ).balanceOf( address(this) ) );\r\n        return true;\r\n    }\r\n}"
    }
  }
}