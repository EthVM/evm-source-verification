{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "XConfig.sol": {
      "content": "// File: contracts/XConst.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract XConst {\r\n    uint256 public constant BONE = 10**18;\r\n\r\n    uint256 public constant MIN_BOUND_TOKENS = 2;\r\n    uint256 public constant MAX_BOUND_TOKENS = 8;\r\n\r\n    uint256 public constant EXIT_ZERO_FEE = 0;\r\n\r\n    uint256 public constant MIN_WEIGHT = BONE;\r\n    uint256 public constant MAX_WEIGHT = BONE * 50;\r\n    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\r\n\r\n    // min effective value: 0.000001 TOKEN\r\n    uint256 public constant MIN_BALANCE = 10**6;\r\n\r\n    // BONE/(10**10) XPT\r\n    uint256 public constant MIN_POOL_AMOUNT = 10**8;\r\n\r\n    uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\r\n\r\n    uint256 public constant MAX_IN_RATIO = BONE / 2;\r\n    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\r\n}\r\n\r\n// File: contracts/interface/IXPool.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IXPool {\r\n    // XPToken\r\n    event Approval(address indexed src, address indexed dst, uint256 amt);\r\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address whom) external view returns (uint256);\r\n\r\n    function allowance(address src, address dst)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address dst, uint256 amt) external returns (bool);\r\n\r\n    function transfer(address dst, uint256 amt) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 amt\r\n    ) external returns (bool);\r\n\r\n    // Swap\r\n    function swapExactAmountIn(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice\r\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\r\n\r\n    function swapExactAmountOut(\r\n        address tokenIn,\r\n        uint256 maxAmountIn,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPrice\r\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\r\n\r\n    // Referral\r\n    function swapExactAmountInRefer(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice,\r\n        address referrer\r\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\r\n\r\n    function swapExactAmountOutRefer(\r\n        address tokenIn,\r\n        uint256 maxAmountIn,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPrice,\r\n        address referrer\r\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\r\n\r\n    // Pool Data\r\n    function isBound(address token) external view returns (bool);\r\n\r\n    function getFinalTokens() external view returns (address[] memory tokens);\r\n\r\n    function getBalance(address token) external view returns (uint256);\r\n\r\n    function swapFee() external view returns (uint256);\r\n\r\n    function exitFee() external view returns (uint256);\r\n\r\n    function finalized() external view returns (uint256);\r\n\r\n    function controller() external view returns (uint256);\r\n\r\n    function xconfig() external view returns (uint256);\r\n\r\n    function getDenormalizedWeight(address) external view returns (uint256);\r\n\r\n    function getTotalDenormalizedWeight() external view returns (uint256);\r\n\r\n    function getVersion() external view returns (bytes32);\r\n\r\n    function calcInGivenOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 _swapFee\r\n    ) external pure returns (uint256 tokenAmountIn);\r\n\r\n    function calcOutGivenIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 _swapFee\r\n    ) external pure returns (uint256 tokenAmountOut);\r\n\r\n    // Pool Managment\r\n    function setController(address _controller) external;\r\n\r\n    function setExitFee(uint256 newFee) external;\r\n\r\n    function finalize(uint256 _swapFee) external;\r\n\r\n    function bind(address token, uint256 denorm) external;\r\n\r\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\r\n        external;\r\n\r\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\r\n        external;\r\n\r\n    function joinswapExternAmountIn(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        uint256 minPoolAmountOut\r\n    ) external returns (uint256 poolAmountOut);\r\n\r\n    function exitswapPoolAmountIn(\r\n        address tokenOut,\r\n        uint256 poolAmountIn,\r\n        uint256 minAmountOut\r\n    ) external returns (uint256 tokenAmountOut);\r\n\r\n    // Pool Governance\r\n    function updateSafu(address safu, uint256 fee) external;\r\n\r\n    function updateFarm(bool isFarm) external;\r\n}\r\n\r\n// File: contracts/interface/IERC20.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256 remaining);\r\n}\r\n\r\n// File: contracts/lib/Address.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n//https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/utils/Address.sol\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash =\r\n            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account)\r\n        internal\r\n        pure\r\n        returns (address payable)\r\n    {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount).gas(9100)(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/lib/SafeERC20.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n//https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/XNum.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\nlibrary XNum {\r\n    uint256 public constant BONE = 10**18;\r\n    uint256 public constant MIN_BPOW_BASE = 1 wei;\r\n    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\r\n    uint256 public constant BPOW_PRECISION = BONE / 10**10;\r\n\r\n    function btoi(uint256 a) internal pure returns (uint256) {\r\n        return a / BONE;\r\n    }\r\n\r\n    function bfloor(uint256 a) internal pure returns (uint256) {\r\n        return btoi(a) * BONE;\r\n    }\r\n\r\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        (uint256 c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c1 = c0 + (BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c2 = c1 / BONE;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint256 c0 = a * BONE;\r\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint256 c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint256 c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    // DSMath.wpow\r\n    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\r\n        uint256 z = n % 2 != 0 ? a : BONE;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\r\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\r\n    // of approximation of b^0.w\r\n    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\r\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\r\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\r\n\r\n        uint256 whole = bfloor(exp);\r\n        uint256 remain = bsub(exp, whole);\r\n\r\n        uint256 wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(\r\n        uint256 base,\r\n        uint256 exp,\r\n        uint256 precision\r\n    ) internal pure returns (uint256) {\r\n        // term 0:\r\n        uint256 a = exp;\r\n        (uint256 x, bool xneg) = bsubSign(base, BONE);\r\n        uint256 term = BONE;\r\n        uint256 sum = term;\r\n        bool negative = false;\r\n\r\n        // term(k) = numer / denom\r\n        //         = (product(a - i + 1, i=1-->k) * x^k) / (k!)\r\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\r\n        // continue until term is less than precision\r\n        for (uint256 i = 1; term >= precision; i++) {\r\n            uint256 bigK = i * BONE;\r\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n\r\n// File: contracts/XConfig.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n1. SAFU is a multi-sig account\r\n2. SAFU is the core of XConfig contract instance\r\n3. DEV firstly deploys XConfig contract, then setups the xconfig.core and xconfig.safu to SAFU with setSAFU() and setCore() \r\n*/\r\ncontract XConfig is XConst {\r\n    using XNum for uint256;\r\n    using Address for address;\r\n    using SafeERC20 for IERC20;\r\n\r\n    address private core;\r\n\r\n    // Secure Asset Fund for Users(SAFU) address\r\n    address private safu;\r\n    uint256 public SAFU_FEE = (5 * BONE) / 10000; // 0.05%\r\n\r\n    // Swap Proxy Address\r\n    address private swapProxy;\r\n\r\n    // Check Farm Pool\r\n    mapping(address => bool) internal farmPools;\r\n\r\n    // sorted pool sigs for pool deduplication\r\n    // key: keccak256(tokens[i], norms[i]), value: pool_exists\r\n    mapping(bytes32 => bool) internal poolSigs;\r\n    uint256 public poolSigCount;\r\n\r\n    uint256 public maxExitFee = BONE / 1000; // 0.1%\r\n\r\n    event INIT_SAFU(address indexed addr);\r\n    event SET_CORE(address indexed core, address indexed coreNew);\r\n\r\n    event SET_SAFU(address indexed safu, address indexed safuNew);\r\n    event SET_SAFU_FEE(uint256 indexed fee, uint256 indexed feeNew);\r\n\r\n    event SET_PROXY(address indexed proxy, address indexed proxyNew);\r\n\r\n    event ADD_POOL_SIG(address indexed caller, bytes32 sig);\r\n    event RM_POOL_SIG(address indexed caller, bytes32 sig);\r\n\r\n    event ADD_FARM_POOL(address indexed pool);\r\n    event RM_FARM_POOL(address indexed pool);\r\n\r\n    event COLLECT(address indexed token, uint256 amount);\r\n\r\n    modifier onlyCore() {\r\n        require(msg.sender == core, \"ERR_CORE_AUTH\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        core = msg.sender;\r\n        safu = address(this);\r\n        emit INIT_SAFU(address(this));\r\n    }\r\n\r\n    function getCore() external view returns (address) {\r\n        return core;\r\n    }\r\n\r\n    function getSAFU() external view returns (address) {\r\n        return safu;\r\n    }\r\n\r\n    function getMaxExitFee() external view returns (uint256) {\r\n        return maxExitFee;\r\n    }\r\n\r\n    function getSafuFee() external view returns (uint256) {\r\n        return SAFU_FEE;\r\n    }\r\n\r\n    function getSwapProxy() external view returns (address) {\r\n        return swapProxy;\r\n    }\r\n\r\n    /**\r\n     * @dev returns the address used within the protocol to identify ETH\r\n     * @return the address assigned to ETH\r\n     */\r\n    function ethAddress() external pure returns (address) {\r\n        return address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n    }\r\n\r\n    // check pool existence which has the same tokens(sorted by address) and weights\r\n    // the decimals of denorms will allways between [10**18, 50 * 10**18]\r\n    function hasPool(address[] calldata tokens, uint256[] calldata denorms)\r\n        external\r\n        view\r\n        returns (bool exist, bytes32 sig)\r\n    {\r\n        require(tokens.length == denorms.length, \"ERR_LENGTH_MISMATCH\");\r\n        require(tokens.length >= MIN_BOUND_TOKENS, \"ERR_MIN_TOKENS\");\r\n        require(tokens.length <= MAX_BOUND_TOKENS, \"ERR_MAX_TOKENS\");\r\n\r\n        uint256 totalWeight = 0;\r\n        for (uint8 i = 0; i < tokens.length; i++) {\r\n            totalWeight = totalWeight.badd(denorms[i]);\r\n        }\r\n\r\n        bytes memory poolInfo;\r\n        for (uint8 i = 0; i < tokens.length; i++) {\r\n            if (i > 0) {\r\n                require(tokens[i] > tokens[i - 1], \"ERR_TOKENS_NOT_SORTED\");\r\n            }\r\n            //normalized weight (multiplied by 100)\r\n            uint256 nWeight = denorms[i].bmul(100).bdiv(totalWeight);\r\n            poolInfo = abi.encodePacked(poolInfo, tokens[i], nWeight);\r\n        }\r\n        sig = keccak256(poolInfo);\r\n\r\n        exist = poolSigs[sig];\r\n    }\r\n\r\n    function setCore(address _core) external onlyCore {\r\n        require(_core != address(0), \"ERR_ZERO_ADDR\");\r\n        emit SET_CORE(core, _core);\r\n        core = _core;\r\n    }\r\n\r\n    function setSAFU(address _safu) external onlyCore {\r\n        emit SET_SAFU(safu, _safu);\r\n        safu = _safu;\r\n    }\r\n\r\n    function setMaxExitFee(uint256 _fee) external onlyCore {\r\n        require(_fee <= (BONE / 10), \"INVALID_EXIT_FEE\");\r\n        maxExitFee = _fee;\r\n    }\r\n\r\n    function setSafuFee(uint256 _fee) external onlyCore {\r\n        require(_fee <= (BONE / 10), \"INVALID_SAFU_FEE\");\r\n        emit SET_SAFU_FEE(SAFU_FEE, _fee);\r\n        SAFU_FEE = _fee;\r\n    }\r\n\r\n    function setSwapProxy(address _proxy) external onlyCore {\r\n        require(_proxy != address(0), \"ERR_ZERO_ADDR\");\r\n        emit SET_PROXY(swapProxy, _proxy);\r\n        swapProxy = _proxy;\r\n    }\r\n\r\n    // add pool's sig\r\n    // only allow called by swapProxy\r\n    function addPoolSig(bytes32 sig) external {\r\n        require(msg.sender == swapProxy, \"ERR_NOT_SWAPPROXY\");\r\n        require(sig != 0, \"ERR_NOT_SIG\");\r\n        poolSigs[sig] = true;\r\n        poolSigCount = poolSigCount.badd(1);\r\n\r\n        emit ADD_POOL_SIG(msg.sender, sig);\r\n    }\r\n\r\n    // remove pool's sig\r\n    // only allow called by swapProxy\r\n    function removePoolSig(bytes32 sig) external {\r\n        require(msg.sender == swapProxy, \"ERR_NOT_SWAPPROXY\");\r\n        require(sig != 0, \"ERR_NOT_SIG\");\r\n        poolSigs[sig] = false;\r\n        poolSigCount = poolSigCount.bsub(1);\r\n\r\n        emit RM_POOL_SIG(msg.sender, sig);\r\n    }\r\n\r\n    function isFarmPool(address pool) external view returns (bool) {\r\n        return farmPools[pool];\r\n    }\r\n\r\n    //list farm pool\r\n    function addFarmPool(address pool) external onlyCore {\r\n        require(pool != address(0), \"ERR_ZERO_ADDR\");\r\n        require(!farmPools[pool], \"ERR_IS_FARMPOOL\");\r\n        farmPools[pool] = true;\r\n\r\n        emit ADD_FARM_POOL(pool);\r\n    }\r\n\r\n    //delist farm pool\r\n    function removeFarmPool(address pool) external onlyCore {\r\n        require(pool != address(0), \"ERR_ZERO_ADDR\");\r\n        require(farmPools[pool], \"ERR_NOT_FARMPOOL\");\r\n        farmPools[pool] = false;\r\n\r\n        emit RM_FARM_POOL(pool);\r\n    }\r\n\r\n    // update SAFU address and SAFE_FEE to pools\r\n    function updateSafu(address[] calldata pools) external onlyCore {\r\n        require(pools.length > 0 && pools.length <= 30, \"ERR_BATCH_COUNT\");\r\n\r\n        for (uint256 i = 0; i < pools.length; i++) {\r\n            require(Address.isContract(pools[i]), \"ERR_NOT_CONTRACT\");\r\n\r\n            IXPool pool = IXPool(pools[i]);\r\n            pool.updateSafu(safu, SAFU_FEE);\r\n        }\r\n    }\r\n\r\n    // update isFarmPool status to pools\r\n    function updateFarm(address[] calldata pools, bool isFarm)\r\n        external\r\n        onlyCore\r\n    {\r\n        require(pools.length > 0 && pools.length <= 30, \"ERR_BATCH_COUNT\");\r\n\r\n        for (uint256 i = 0; i < pools.length; i++) {\r\n            require(Address.isContract(pools[i]), \"ERR_NOT_CONTRACT\");\r\n\r\n            IXPool pool = IXPool(pools[i]);\r\n            pool.updateFarm(isFarm);\r\n        }\r\n    }\r\n\r\n    // collect any tokens in this contract to safu\r\n    function collect(address token) external onlyCore {\r\n        IERC20 TI = IERC20(token);\r\n\r\n        uint256 collected = TI.balanceOf(address(this));\r\n        TI.safeTransfer(safu, collected);\r\n\r\n        emit COLLECT(token, collected);\r\n    }\r\n}"
    }
  }
}