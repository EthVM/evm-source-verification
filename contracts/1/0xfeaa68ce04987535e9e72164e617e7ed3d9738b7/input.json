{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/doco.sol":{"content":"// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\n\nlibrary SafeMath { // Only relevant functions\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n      assert(b <= a);\n      return a - b;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256)   {\n      uint256 c = a + b;\n      assert(c >= a);\n      return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n          return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n      }\n     function div(uint256 a, uint256 b) internal pure returns (uint256) {\n         if (a == 0) {\n          return 0;\n        }\n        uint256 c = a / b;\n        return c;\n      }\n}\n\ncontract doco\n{\n    using SafeMath for uint256;\n    string  public name ;\n    string public symbol;\n    uint public decimals;\n    uint256 public initialSupply;\n    uint256 public totalSupply;\n    uint256 public burnStopSupply;\n    string public burnPercentage;\n    uint256 public burnedTillDate;\n    address payable creator;\n    mapping(address => uint256) balances;\n    mapping(address => mapping (address => uint256)) allowed;\n   \n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n    event Transfer(address indexed from, address indexed to,uint256 tokens);\n    event Received(address, uint256);\n\n    constructor( ) payable{\n        creator = payable(msg.sender);\n        name = \"DOCO TOKEN\";   \n        symbol = \"DOCO\"; \n        initialSupply = 100000000 *10**18;   // Value is 100000000\n        totalSupply = 100000000 *10**18;   // Value is 100000000\n        burnStopSupply = 90000000 *10**18;   // Value is 20000000\n        burnPercentage = \"0.001%\";  \n        decimals = 18;\n        burnedTillDate=0;\n        balances[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n    \n    function balanceOf(address tokenOwner) public view returns (uint256) {\n        return balances[tokenOwner];\n    }\n    \n    function findBurnTokens(uint256 numTokens) public view returns (uint256)  {\n        uint256 burntokens_ =0;\n        if (totalSupply > burnStopSupply)\n        {\n            burntokens_= numTokens.mul(1000000000).div(1000000000000);\n        }\n        return burntokens_;\n  }\n    \n    function transfer(address receiver,uint256 numTokens) public returns (bool) {\n        require(numTokens <= balances[msg.sender]);\n        uint256 burntokens_ = findBurnTokens(numTokens);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        balances[receiver] = balances[receiver].add(numTokens);\n        balances[creator] = balances[creator].sub(burntokens_);\n        totalSupply = totalSupply.sub(burntokens_);\n        burnedTillDate = burnedTillDate.add(burntokens_);\n        emit Transfer(msg.sender, receiver, numTokens);\n        return true;\n    }\n    \n    function approve(address delegate,uint256 numTokens) public returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n        emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n    \n    function allowance(address owner,address delegate) public view returns (uint) {\n        return allowed[owner][delegate];\n    }\n    \n    function transferFrom(address owner, address buyer, uint256 numTokens) public returns (bool) {\n      \n        require(numTokens <= allowed[owner][msg.sender]);\n        \n        uint256 burntokens_ = findBurnTokens(numTokens);\n        totalSupply = totalSupply.sub(burntokens_);\n        burnedTillDate = burnedTillDate.add(burntokens_);\n        balances[creator] = balances[creator].sub(burntokens_);\n        \n        balances[owner] = balances[owner].sub(numTokens);\n       allowed[owner][msg.sender]= allowed[owner][msg.sender].sub(numTokens);\n        balances[buyer] = balances[buyer].add(numTokens);\n        emit Transfer(owner, buyer, numTokens);\n        \n        return true;\n    }\n    \n    receive() external payable \n    {\n         creator.transfer(msg.value);\n    }\n    \n    fallback() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n}\n"}}}