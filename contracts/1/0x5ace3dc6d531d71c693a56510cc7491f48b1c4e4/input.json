{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Unlock.sol": {
      "content": "/**\r\n *Submitted for verification at Etherscan.io on 2020-07-11\r\n*/\r\n\r\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.7.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context is Initializable {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Initializable, Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function initialize(address sender) public initializer {\r\n        _owner = sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n// File: hardlydifficult-ethereum-contracts/contracts/proxies/Clone2Factory.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n// From https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\r\n// Updated to support Solidity 5, switch to `create2` and revert on fail\r\nlibrary Clone2Factory\r\n{\r\n  /**\r\n   * @notice Uses create2 to deploy a clone to a pre-determined address.\r\n   * @param target the address of the template contract, containing the logic for this contract.\r\n   * @param salt a salt used to determine the contract address before the transaction is mined,\r\n   * may be random or sequential.\r\n   * The salt to use with the create2 call can be `msg.sender+salt` in order to\r\n   * prevent an attacker from front-running another user's deployment.\r\n   * @return proxyAddress the address of the newly deployed contract.\r\n   * @dev Using `bytes12` for the salt saves 6 gas over using `uint96` (requires another shift).\r\n   * Will revert on fail.\r\n   */\r\n  function createClone2(\r\n    address target,\r\n    bytes32 salt\r\n  ) internal\r\n    returns (address proxyAddress)\r\n  {\r\n    // solium-disable-next-line\r\n    assembly\r\n    {\r\n      let pointer := mload(0x40)\r\n\r\n      // Create the bytecode for deployment based on the Minimal Proxy Standard (EIP-1167)\r\n      // bytecode: 0x0\r\n      mstore(pointer, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n      mstore(add(pointer, 0x14), shl(96, target))\r\n      mstore(add(pointer, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n\r\n      // `create2` consumes all available gas if called with a salt that's already been consumed\r\n      // we check if the address is available first so that doesn't happen\r\n      // Costs ~958 gas\r\n\r\n      // Calculate the hash\r\n      let contractCodeHash := keccak256(pointer, 0x37)\r\n\r\n      // salt: 0x100\r\n      mstore(add(pointer, 0x100), salt)\r\n\r\n      // addressSeed: 0x40\r\n      // 0xff\r\n      mstore(add(pointer, 0x40), 0xff00000000000000000000000000000000000000000000000000000000000000)\r\n      // this\r\n      mstore(add(pointer, 0x41), shl(96, address))\r\n      // salt\r\n      mstore(add(pointer, 0x55), mload(add(pointer, 0x100)))\r\n      // hash\r\n      mstore(add(pointer, 0x75), contractCodeHash)\r\n\r\n      proxyAddress := keccak256(add(pointer, 0x40), 0x55)\r\n\r\n      switch extcodesize(proxyAddress)\r\n      case 0 {\r\n        // Deploy the contract, returning the address or 0 on fail\r\n        proxyAddress := create2(0, pointer, 0x37, mload(add(pointer, 0x100)))\r\n      }\r\n      default {\r\n        proxyAddress := 0\r\n      }\r\n    }\r\n\r\n    // Revert if the deployment fails (possible if salt was already used)\r\n    require(proxyAddress != address(0), 'PROXY_DEPLOY_FAILED');\r\n  }\r\n}\r\n\r\n// File: contracts/interfaces/IPublicLock.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n* @title The PublicLock Interface\r\n* @author Nick Furfaro (unlock-protocol.com)\r\n */\r\n\r\n\r\ncontract IPublicLock\r\n{\r\n\r\n// See indentationissue description here:\r\n// https://github.com/duaraghav8/Ethlint/issues/268\r\n// solium-disable indentation\r\n\r\n  /// Functions\r\n\r\n  function initialize(\r\n    address _lockCreator,\r\n    uint _expirationDuration,\r\n    address _tokenAddress,\r\n    uint _keyPrice,\r\n    uint _maxNumberOfKeys,\r\n    string calldata _lockName\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\r\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\r\n   */\r\n  function() external payable;\r\n\r\n  /**\r\n   * @dev Never used directly\r\n   */\r\n  function initialize() external;\r\n\r\n  /**\r\n  * @notice The version number of the current implementation on this network.\r\n  * @return The current version number.\r\n  */\r\n  function publicLockVersion() public pure returns (uint);\r\n\r\n  /**\r\n  * @notice Gets the current balance of the account provided.\r\n  * @param _tokenAddress The token type to retrieve the balance of.\r\n  * @param _account The account to get the balance of.\r\n  * @return The number of tokens of the given type for the given address, possibly 0.\r\n  */\r\n  function getBalance(\r\n    address _tokenAddress,\r\n    address _account\r\n  ) external view\r\n    returns (uint);\r\n\r\n  /**\r\n  * @notice Used to disable lock before migrating keys and/or destroying contract.\r\n  * @dev Throws if called by other than a lock manager.\r\n  * @dev Throws if lock contract has already been disabled.\r\n  */\r\n  function disableLock() external;\r\n\r\n  /**\r\n   * @dev Called by a lock manager or beneficiary to withdraw all funds from the lock and send them to the `beneficiary`.\r\n   * @dev Throws if called by other than a lock manager or beneficiary\r\n   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually\r\n   * the same as `tokenAddress` in MixinFunds.\r\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\r\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\r\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\r\n   * use cases.\r\n   */\r\n  function withdraw(\r\n    address _tokenAddress,\r\n    uint _amount\r\n  ) external;\r\n\r\n  /**\r\n   * @notice An ERC-20 style approval, allowing the spender to transfer funds directly from this lock.\r\n   */\r\n  function approveBeneficiary(\r\n    address _spender,\r\n    uint _amount\r\n  ) external\r\n    returns (bool);\r\n\r\n  /**\r\n   * A function which lets a Lock manager of the lock to change the price for future purchases.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @dev Throws if lock has been disabled\r\n   * @dev Throws if _tokenAddress is not a valid token\r\n   * @param _keyPrice The new price to set for keys\r\n   * @param _tokenAddress The address of the erc20 token to use for pricing the keys,\r\n   * or 0 to use ETH\r\n   */\r\n  function updateKeyPricing( uint _keyPrice, address _tokenAddress ) external;\r\n\r\n  /**\r\n   * A function which lets a Lock manager update the beneficiary account,\r\n   * which receives funds on withdrawal.\r\n   * @dev Throws if called by other than a Lock manager or beneficiary\r\n   * @dev Throws if _beneficiary is address(0)\r\n   * @param _beneficiary The new address to set as the beneficiary\r\n   */\r\n  function updateBeneficiary( address _beneficiary ) external;\r\n\r\n    /**\r\n   * Checks if the user has a non-expired key.\r\n   * @param _user The address of the key owner\r\n   */\r\n  function getHasValidKey(\r\n    address _user\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Find the tokenId for a given user\r\n   * @return The tokenId of the NFT, else returns 0\r\n   * @param _account The address of the key owner\r\n  */\r\n  function getTokenIdFor(\r\n    address _account\r\n  ) external view returns (uint);\r\n\r\n  /**\r\n  * A function which returns a subset of the keys for this Lock as an array\r\n  * @param _page the page of key owners requested when faceted by page size\r\n  * @param _pageSize the number of Key Owners requested per page\r\n  * @dev Throws if there are no key owners yet\r\n  */\r\n  function getOwnersByPage(\r\n    uint _page,\r\n    uint _pageSize\r\n  ) external view returns (address[] memory);\r\n\r\n  /**\r\n   * Checks if the given address owns the given tokenId.\r\n   * @param _tokenId The tokenId of the key to check\r\n   * @param _keyOwner The potential key owners address\r\n   */\r\n  function isKeyOwner(\r\n    uint _tokenId,\r\n    address _keyOwner\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\r\n  * @param _keyOwner address of the user for whom we search the key\r\n  * @dev Returns 0 if the owner has never owned a key for this lock\r\n  */\r\n  function keyExpirationTimestampFor(\r\n    address _keyOwner\r\n  ) external view returns (uint timestamp);\r\n\r\n  /**\r\n   * Public function which returns the total number of unique owners (both expired\r\n   * and valid).  This may be larger than totalSupply.\r\n   */\r\n  function numberOfOwners() external view returns (uint);\r\n\r\n  /**\r\n   * Allows a Lock manager to assign a descriptive name for this Lock.\r\n   * @param _lockName The new name for the lock\r\n   * @dev Throws if called by other than a Lock manager\r\n   */\r\n  function updateLockName(\r\n    string calldata _lockName\r\n  ) external;\r\n\r\n  /**\r\n   * Allows a Lock manager to assign a Symbol for this Lock.\r\n   * @param _lockSymbol The new Symbol for the lock\r\n   * @dev Throws if called by other than a Lock manager\r\n   */\r\n  function updateLockSymbol(\r\n    string calldata _lockSymbol\r\n  ) external;\r\n\r\n  /**\r\n    * @dev Gets the token symbol\r\n    * @return string representing the token symbol\r\n    */\r\n  function symbol()\r\n    external view\r\n    returns(string memory);\r\n\r\n    /**\r\n   * Allows a Lock manager to update the baseTokenURI for this Lock.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @param _baseTokenURI String representing the base of the URI for this lock.\r\n   */\r\n  function setBaseTokenURI(\r\n    string calldata _baseTokenURI\r\n  ) external;\r\n\r\n  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n   *  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n   *  Metadata JSON Schema\".\r\n   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n   * @param _tokenId The tokenID we're inquiring about\r\n   * @return String representing the URI for the requested token\r\n   */\r\n  function tokenURI(\r\n    uint256 _tokenId\r\n  ) external view returns(string memory);\r\n\r\n  /**\r\n   * @notice Allows a Lock manager to add or remove an event hook\r\n   */\r\n  function setEventHooks(\r\n    address _onKeyPurchaseHook,\r\n    address _onKeyCancelHook\r\n  ) external;\r\n\r\n  /**\r\n   * Allows a Lock manager to give a collection of users a key with no charge.\r\n   * Each key may be assigned a different expiration date.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @param _recipients An array of receiving addresses\r\n   * @param _expirationTimestamps An array of expiration Timestamps for the keys being granted\r\n   */\r\n  function grantKeys(\r\n    address[] calldata _recipients,\r\n    uint[] calldata _expirationTimestamps,\r\n    address[] calldata _keyManagers\r\n  ) external;\r\n\r\n  /**\r\n  * @dev Purchase function\r\n  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount\r\n  * (_value is ignored when using ETH)\r\n  * @param _recipient address of the recipient of the purchased key\r\n  * @param _referrer address of the user making the referral\r\n  * @param _data arbitrary data populated by the front-end which initiated the sale\r\n  * @dev Throws if lock is disabled. Throws if lock is sold-out. Throws if _recipient == address(0).\r\n  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if a Lock manager increases the\r\n  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more\r\n  * than keyPrice is approved for spending).\r\n  */\r\n  function purchase(\r\n    uint256 _value,\r\n    address _recipient,\r\n    address _referrer,\r\n    bytes calldata _data\r\n  ) external payable;\r\n\r\n  /**\r\n   * @notice returns the minimum price paid for a purchase with these params.\r\n   * @dev this considers any discount from Unlock or the OnKeyPurchase hook.\r\n   */\r\n  function purchasePriceFor(\r\n    address _recipient,\r\n    address _referrer,\r\n    bytes calldata _data\r\n  ) external view\r\n    returns (uint);\r\n\r\n  /**\r\n   * Allow a Lock manager to change the transfer fee.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @param _transferFeeBasisPoints The new transfer fee in basis-points(bps).\r\n   * Ex: 200 bps = 2%\r\n   */\r\n  function updateTransferFee(\r\n    uint _transferFeeBasisPoints\r\n  ) external;\r\n\r\n  /**\r\n   * Determines how much of a fee a key owner would need to pay in order to\r\n   * transfer the key to another account.  This is pro-rated so the fee goes down\r\n   * overtime.\r\n   * @dev Throws if _keyOwner does not have a valid key\r\n   * @param _keyOwner The owner of the key check the transfer fee for.\r\n   * @param _time The amount of time to calculate the fee for.\r\n   * @return The transfer fee in seconds.\r\n   */\r\n  function getTransferFee(\r\n    address _keyOwner,\r\n    uint _time\r\n  ) external view returns (uint);\r\n\r\n  /**\r\n   * @dev Invoked by a Lock manager to expire the user's key and perform a refund and cancellation of the key\r\n   * @param _keyOwner The key owner to whom we wish to send a refund to\r\n   * @param amount The amount to refund the key-owner\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @dev Throws if _keyOwner does not have a valid key\r\n   */\r\n  function expireAndRefundFor(\r\n    address _keyOwner,\r\n    uint amount\r\n  ) external;\r\n\r\n   /**\r\n   * @dev allows the key manager to expire a given tokenId\r\n   * and send a refund to the keyOwner based on the amount of time remaining.\r\n   * @param _tokenId The id of the key to cancel.\r\n   */\r\n  function cancelAndRefund(uint _tokenId) external;\r\n\r\n  /**\r\n   * @dev Cancels a key managed by a different user and sends the funds to the keyOwner.\r\n   * @param _keyManager the key managed by this user will be canceled\r\n   * @param _v _r _s getCancelAndRefundApprovalHash signed by the _keyManager\r\n   * @param _tokenId The key to cancel\r\n   */\r\n  function cancelAndRefundFor(\r\n    address _keyManager,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s,\r\n    uint _tokenId\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Sets the minimum nonce for a valid off-chain approval message from the\r\n   * senders account.\r\n   * @dev This can be used to invalidate a previously signed message.\r\n   */\r\n  function invalidateOffchainApproval(\r\n    uint _nextAvailableNonce\r\n  ) external;\r\n\r\n  /**\r\n   * Allow a Lock manager to change the refund penalty.\r\n   * @dev Throws if called by other than a Lock manager\r\n   * @param _freeTrialLength The new duration of free trials for this lock\r\n   * @param _refundPenaltyBasisPoints The new refund penaly in basis-points(bps)\r\n   */\r\n  function updateRefundPenalty(\r\n    uint _freeTrialLength,\r\n    uint _refundPenaltyBasisPoints\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Determines how much of a refund a key owner would receive if they issued\r\n   * @param _keyOwner The key owner to get the refund value for.\r\n   * a cancelAndRefund block.timestamp.\r\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\r\n   * than what the user reads from this call.\r\n   */\r\n  function getCancelAndRefundValueFor(\r\n    address _keyOwner\r\n  ) external view returns (uint refund);\r\n\r\n  function keyManagerToNonce(address ) external view returns (uint256 );\r\n\r\n  /**\r\n   * @notice returns the hash to sign in order to allow another user to cancel on your behalf.\r\n   * @dev this can be computed in JS instead of read from the contract.\r\n   * @param _keyManager The key manager's address (also the message signer)\r\n   * @param _txSender The address cancelling cancel on behalf of the keyOwner\r\n   * @return approvalHash The hash to sign\r\n   */\r\n  function getCancelAndRefundApprovalHash(\r\n    address _keyManager,\r\n    address _txSender\r\n  ) external view returns (bytes32 approvalHash);\r\n\r\n  function addKeyGranter(address account) external;\r\n\r\n  function addLockManager(address account) external;\r\n\r\n  function isKeyGranter(address account) external view returns (bool);\r\n\r\n  function isLockManager(address account) external view returns (bool);\r\n\r\n  function onKeyPurchaseHook() external view returns(address);\r\n\r\n  function onKeyCancelHook() external view returns(address);\r\n\r\n  function revokeKeyGranter(address _granter) external;\r\n\r\n  function renounceLockManager() external;\r\n\r\n  ///===================================================================\r\n  /// Auto-generated getter functions from public state variables\r\n\r\n  function beneficiary() external view returns (address );\r\n\r\n  function expirationDuration() external view returns (uint256 );\r\n\r\n  function freeTrialLength() external view returns (uint256 );\r\n\r\n  function isAlive() external view returns (bool );\r\n\r\n  function keyPrice() external view returns (uint256 );\r\n\r\n  function maxNumberOfKeys() external view returns (uint256 );\r\n\r\n  function owners(uint256 ) external view returns (address );\r\n\r\n  function refundPenaltyBasisPoints() external view returns (uint256 );\r\n\r\n  function tokenAddress() external view returns (address );\r\n\r\n  function transferFeeBasisPoints() external view returns (uint256 );\r\n\r\n  function unlockProtocol() external view returns (address );\r\n\r\n  function keyManagerOf(uint) external view returns (address );\r\n\r\n  ///===================================================================\r\n\r\n  /**\r\n  * @notice Allows the key owner to safely share their key (parent key) by\r\n  * transferring a portion of the remaining time to a new key (child key).\r\n  * @dev Throws if key is not valid.\r\n  * @dev Throws if `_to` is the zero address\r\n  * @param _to The recipient of the shared key\r\n  * @param _tokenId the key to share\r\n  * @param _timeShared The amount of time shared\r\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n  * `onERC721Received` on `_to` and throws if the return value is not\r\n  * `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\r\n  * @dev Emit Transfer event\r\n  */\r\n  function shareKey(\r\n    address _to,\r\n    uint _tokenId,\r\n    uint _timeShared\r\n  ) external;\r\n\r\n  /**\r\n  * @notice Update transfer and cancel rights for a given key\r\n  * @param _tokenId The id of the key to assign rights for\r\n  * @param _keyManager The address to assign the rights to for the given key\r\n  */\r\n  function setKeyManagerOf(\r\n    uint _tokenId,\r\n    address _keyManager\r\n  ) external;\r\n\r\n  /// @notice A descriptive name for a collection of NFTs in this contract\r\n  function name() external view returns (string memory _name);\r\n  ///===================================================================\r\n\r\n  /// From ERC165.sol\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool );\r\n  ///===================================================================\r\n\r\n  /// From ERC-721\r\n  /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address _owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     *\r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either {approve} or {setApprovalForAll}.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either {approve} or {setApprovalForAll}.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n\r\n    /**\r\n    * @notice Get the approved address for a single NFT\r\n    * @dev Throws if `_tokenId` is not a valid NFT.\r\n    * @param _tokenId The NFT to find the approved address for\r\n    * @return The approved address for this NFT, or the zero address if there is none\r\n    */\r\n    function getApproved(uint256 _tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address _owner, address operator) public view returns (bool);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 index) public view returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256);\r\n\r\n\r\n\r\n    /**\r\n     * @notice An ERC-20 style transfer.\r\n     * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).\r\n     * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user\r\n     * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.\r\n     */\r\n    function transfer(\r\n      address _to,\r\n      uint _value\r\n    ) external\r\n      returns (bool success);\r\n}\r\n\r\n// File: contracts/interfaces/IUnlock.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n/**\r\n * @title The Unlock Interface\r\n * @author Nick Furfaro (unlock-protocol.com)\r\n**/\r\n\r\ninterface IUnlock\r\n{\r\n  // Use initialize instead of a constructor to support proxies(for upgradeability via zos).\r\n  function initialize(address _unlockOwner) external;\r\n\r\n  /**\r\n  * @dev Create lock\r\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\r\n  * @param _tokenAddress set to the ERC20 token address, or 0 for ETH.\r\n  * @param _salt an identifier for the Lock, which is unique for the user.\r\n  * This may be implemented as a sequence ID or with RNG. It's used with `create2`\r\n  * to know the lock's address before the transaction is mined.\r\n  */\r\n  function createLock(\r\n    uint _expirationDuration,\r\n    address _tokenAddress,\r\n    uint _keyPrice,\r\n    uint _maxNumberOfKeys,\r\n    string calldata _lockName,\r\n    bytes12 _salt\r\n  ) external;\r\n\r\n    /**\r\n   * This function keeps track of the added GDP, as well as grants of discount tokens\r\n   * to the referrer, if applicable.\r\n   * The number of discount tokens granted is based on the value of the referal,\r\n   * the current growth rate and the lock's discount token distribution rate\r\n   * This function is invoked by a previously deployed lock only.\r\n   */\r\n  function recordKeyPurchase(\r\n    uint _value,\r\n    address _referrer // solhint-disable-line no-unused-vars\r\n  )\r\n    external;\r\n\r\n    /**\r\n   * This function will keep track of consumed discounts by a given user.\r\n   * It will also grant discount tokens to the creator who is granting the discount based on the\r\n   * amount of discount and compensation rate.\r\n   * This function is invoked by a previously deployed lock only.\r\n   */\r\n  function recordConsumedDiscount(\r\n    uint _discount,\r\n    uint _tokens // solhint-disable-line no-unused-vars\r\n  )\r\n    external;\r\n\r\n    /**\r\n   * This function returns the discount available for a user, when purchasing a\r\n   * a key from a lock.\r\n   * This does not modify the state. It returns both the discount and the number of tokens\r\n   * consumed to grant that discount.\r\n   */\r\n  function computeAvailableDiscountFor(\r\n    address _purchaser, // solhint-disable-line no-unused-vars\r\n    uint _keyPrice // solhint-disable-line no-unused-vars\r\n  )\r\n    external\r\n    view\r\n    returns(uint discount, uint tokens);\r\n\r\n  // Function to read the globalTokenURI field.\r\n  function globalBaseTokenURI()\r\n    external\r\n    view\r\n    returns(string memory);\r\n\r\n  /**\r\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\r\n   */\r\n  function getGlobalBaseTokenURI()\r\n    external\r\n    view\r\n    returns (string memory);\r\n\r\n  // Function to read the globalTokenSymbol field.\r\n  function globalTokenSymbol()\r\n    external\r\n    view\r\n    returns(string memory);\r\n\r\n  /**\r\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\r\n   */\r\n  function getGlobalTokenSymbol()\r\n    external\r\n    view\r\n    returns (string memory);\r\n\r\n  /**\r\n   * @notice Allows the owner to update configuration variables\r\n   */\r\n  function configUnlock(\r\n    address _udt,\r\n    address _weth,\r\n    uint _estimatedGasForPurchase,\r\n    string calldata _symbol,\r\n    string calldata _URI\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\r\n   * @dev This will initialize the template and revokeOwnership.\r\n   */\r\n  function setLockTemplate(\r\n    address payable _publicLockAddress\r\n  ) external;\r\n\r\n  // Allows the owner to change the value tracking variables as needed.\r\n  function resetTrackedValue(\r\n    uint _grossNetworkProduct,\r\n    uint _totalDiscountGranted\r\n  ) external;\r\n\r\n  function grossNetworkProduct() external view returns(uint);\r\n\r\n  function totalDiscountGranted() external view returns(uint);\r\n\r\n  function locks(address) external view returns(bool deployed, uint totalSales, uint yieldedDiscountTokens);\r\n\r\n  // The address of the public lock template, used when `createLock` is called\r\n  function publicLockAddress() external view returns(address);\r\n\r\n  // Map token address to exchange contract address if the token is supported\r\n  // Used for GDP calculations\r\n  function uniswapOracles(address) external view returns(address);\r\n\r\n  // The WETH token address, used for value calculations\r\n  function weth() external view returns(address);\r\n\r\n  // The UDT token address, used to mint tokens on referral\r\n  function udt() external view returns(address);\r\n\r\n  // The approx amount of gas required to purchase a key\r\n  function estimatedGasForPurchase() external view returns(uint);\r\n\r\n  // The version number of the current Unlock implementation on this network\r\n  function unlockVersion() external pure returns(uint16);\r\n\r\n  /**\r\n   * @notice allows the owner to set the oracle address to use for value conversions\r\n   * setting the _oracleAddress to address(0) removes support for the token\r\n   * @dev This will also call update to ensure at least one datapoint has been recorded.\r\n   */\r\n  function setOracle(\r\n    address _tokenAddress,\r\n    address _oracleAddress\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Returns true if the caller is the current owner.\r\n   */\r\n  function isOwner() external view returns(bool);\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() external view returns(address);\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() external;\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapOracle\r\n{\r\n    function PERIOD() external returns (uint);\r\n    function factory() external returns (address);\r\n    function update(\r\n      address _tokenIn,\r\n      address _tokenOut\r\n    ) external;\r\n    function consult(\r\n      address _tokenIn,\r\n      uint _amountIn,\r\n      address _tokenOut\r\n    ) external view\r\n      returns (uint _amountOut);\r\n    function updateAndConsult(\r\n      address _tokenIn,\r\n      uint _amountIn,\r\n      address _tokenOut\r\n    ) external\r\n      returns (uint _amountOut);\r\n}\r\n\r\n// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IMintableERC20.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ninterface IMintableERC20\r\n{\r\n  function mint(address account, uint256 amount) external returns (bool);\r\n  function totalSupply() external returns (uint);\r\n}\r\n\r\n// File: contracts/Unlock.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @title The Unlock contract\r\n * @author Julien Genestoux (unlock-protocol.com)\r\n * This smart contract has 3 main roles:\r\n *  1. Distribute discounts to discount token holders\r\n *  2. Grant dicount tokens to users making referrals and/or publishers granting discounts.\r\n *  3. Create & deploy Public Lock contracts.\r\n * In order to achieve these 3 elements, it keeps track of several things such as\r\n *  a. Deployed locks addresses and balances of discount tokens granted by each lock.\r\n *  b. The total network product (sum of all key sales, net of discounts)\r\n *  c. Total of discounts granted\r\n *  d. Balances of discount tokens, including 'frozen' tokens (which have been used to claim\r\n * discounts and cannot be used/transferred for a given period)\r\n *  e. Growth rate of Network Product\r\n *  f. Growth rate of Discount tokens supply\r\n * The smart contract has an owner who only can perform the following\r\n *  - Upgrades\r\n *  - Change in golden rules (20% of GDP available in discounts, and supply growth rate is at most\r\n * 50% of GNP growth rate)\r\n * NOTE: This smart contract is partially implemented for now until enough Locks are deployed and\r\n * in the wild.\r\n * The partial implementation includes the following features:\r\n *  a. Keeping track of deployed locks\r\n *  b. Keeping track of GNP\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @dev Must list the direct base contracts in the order from “most base-like” to “most derived”.\r\n/// https://solidity.readthedocs.io/en/latest/contracts.html#multiple-inheritance-and-linearization\r\ncontract Unlock is\r\n  IUnlock,\r\n  Initializable,\r\n  Ownable\r\n{\r\n  using Address for address;\r\n  using Clone2Factory for address;\r\n  using SafeMath for uint;\r\n\r\n  /**\r\n   * The struct for a lock\r\n   * We use deployed to keep track of deployments.\r\n   * This is required because both totalSales and yieldedDiscountTokens are 0 when initialized,\r\n   * which would be the same values when the lock is not set.\r\n   */\r\n  struct LockBalances\r\n  {\r\n    bool deployed;\r\n    uint totalSales; // This is in wei\r\n    uint yieldedDiscountTokens;\r\n  }\r\n\r\n  modifier onlyFromDeployedLock() {\r\n    require(locks[msg.sender].deployed, 'ONLY_LOCKS');\r\n    _;\r\n  }\r\n\r\n  uint public grossNetworkProduct;\r\n\r\n  uint public totalDiscountGranted;\r\n\r\n  // We keep track of deployed locks to ensure that callers are all deployed locks.\r\n  mapping (address => LockBalances) public locks;\r\n\r\n  // global base token URI\r\n  // Used by locks where the owner has not set a custom base URI.\r\n  string public globalBaseTokenURI;\r\n\r\n  // global base token symbol\r\n  // Used by locks where the owner has not set a custom symbol\r\n  string public globalTokenSymbol;\r\n\r\n  // The address of the public lock template, used when `createLock` is called\r\n  address public publicLockAddress;\r\n\r\n  // Map token address to oracle contract address if the token is supported\r\n  // Used for GDP calculations\r\n  mapping (address => IUniswapOracle) public uniswapOracles;\r\n\r\n  // The WETH token address, used for value calculations\r\n  address public weth;\r\n\r\n  // The UDT token address, used to mint tokens on referral\r\n  address public udt;\r\n\r\n  // The approx amount of gas required to purchase a key\r\n  uint public estimatedGasForPurchase;\r\n\r\n  // Events\r\n  event NewLock(\r\n    address indexed lockOwner,\r\n    address indexed newLockAddress\r\n  );\r\n\r\n  event ConfigUnlock(\r\n    address udt,\r\n    address weth,\r\n    uint estimatedGasForPurchase,\r\n    string globalTokenSymbol,\r\n    string globalTokenURI\r\n  );\r\n\r\n  event SetLockTemplate(\r\n    address publicLockAddress\r\n  );\r\n\r\n  event ResetTrackedValue(\r\n    uint grossNetworkProduct,\r\n    uint totalDiscountGranted\r\n  );\r\n\r\n  // Use initialize instead of a constructor to support proxies (for upgradeability via zos).\r\n  function initialize(\r\n    address _unlockOwner\r\n  )\r\n    public\r\n    initializer()\r\n  {\r\n    // We must manually initialize Ownable.sol\r\n    Ownable.initialize(_unlockOwner);\r\n  }\r\n\r\n  /**\r\n  * @dev Create lock\r\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\r\n  * @param _tokenAddress set to the ERC20 token address, or 0 for ETH.\r\n  * @param _salt an identifier for the Lock, which is unique for the user.\r\n  * This may be implemented as a sequence ID or with RNG. It's used with `create2`\r\n  * to know the lock's address before the transaction is mined.\r\n  */\r\n  function createLock(\r\n    uint _expirationDuration,\r\n    address _tokenAddress,\r\n    uint _keyPrice,\r\n    uint _maxNumberOfKeys,\r\n    string memory _lockName,\r\n    bytes12 _salt\r\n  ) public\r\n  {\r\n    require(publicLockAddress != address(0), 'MISSING_LOCK_TEMPLATE');\r\n\r\n    // create lock\r\n    bytes32 salt;\r\n    // solium-disable-next-line\r\n    assembly\r\n    {\r\n      let pointer := mload(0x40)\r\n      // The salt is the msg.sender\r\n      mstore(pointer, shl(96, caller))\r\n      // followed by the _salt provided\r\n      mstore(add(pointer, 0x14), _salt)\r\n      salt := mload(pointer)\r\n    }\r\n    address payable newLock = address(uint160(publicLockAddress.createClone2(salt)));\r\n    IPublicLock(newLock).initialize(\r\n      msg.sender,\r\n      _expirationDuration,\r\n      _tokenAddress,\r\n      _keyPrice,\r\n      _maxNumberOfKeys,\r\n      _lockName\r\n    );\r\n\r\n    // Assign the new Lock\r\n    locks[newLock] = LockBalances({\r\n      deployed: true, totalSales: 0, yieldedDiscountTokens: 0\r\n    });\r\n\r\n    // trigger event\r\n    emit NewLock(msg.sender, newLock);\r\n  }\r\n\r\n  /**\r\n   * This function returns the discount available for a user, when purchasing a\r\n   * a key from a lock.\r\n   * This does not modify the state. It returns both the discount and the number of tokens\r\n   * consumed to grant that discount.\r\n   * TODO: actually implement this.\r\n   */\r\n  function computeAvailableDiscountFor(\r\n    address /* _purchaser */,\r\n    uint /* _keyPrice */\r\n  )\r\n    public\r\n    view\r\n    returns (uint discount, uint tokens)\r\n  {\r\n    // TODO: implement me\r\n    return (0, 0);\r\n  }\r\n\r\n  /**\r\n   * This function keeps track of the added GDP, as well as grants of discount tokens\r\n   * to the referrer, if applicable.\r\n   * The number of discount tokens granted is based on the value of the referal,\r\n   * the current growth rate and the lock's discount token distribution rate\r\n   * This function is invoked by a previously deployed lock only.\r\n   * TODO: actually implement\r\n   */\r\n  function recordKeyPurchase(\r\n    uint _value,\r\n    address _referrer\r\n  )\r\n    public\r\n    onlyFromDeployedLock()\r\n  {\r\n    if(_value > 0) {\r\n      uint valueInETH;\r\n      address tokenAddress = IPublicLock(msg.sender).tokenAddress();\r\n      if(tokenAddress != address(0) && tokenAddress != weth) {\r\n        // If priced in an ERC-20 token, find the supported uniswap oracle\r\n        IUniswapOracle oracle = uniswapOracles[tokenAddress];\r\n        if(address(oracle) != address(0)) {\r\n          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);\r\n        }\r\n      }\r\n      else {\r\n        // If priced in ETH (or value is 0), no conversion is required\r\n        valueInETH = _value;\r\n      }\r\n\r\n      grossNetworkProduct = grossNetworkProduct.add(valueInETH);\r\n      // If GNP does not overflow, the lock totalSales should be safe\r\n      locks[msg.sender].totalSales += valueInETH;\r\n\r\n      // Mint UDT\r\n      if(_referrer != address(0))\r\n      {\r\n        IUniswapOracle udtOracle = uniswapOracles[udt];\r\n        if(address(udtOracle) != address(0))\r\n        {\r\n          // Get the value of 1 UDT (w/ 18 decimals) in ETH\r\n          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);\r\n\r\n          // tokensToMint is either == to the gas cost times 1.25 to cover the 20% dev cut\r\n          uint tokensToMint = (estimatedGasForPurchase * tx.gasprice).mul(125 * 10 ** 18) / 100 / udtPrice;\r\n          // or tokensToMint is capped by percent growth\r\n          uint maxTokens = IMintableERC20(udt).totalSupply().mul(valueInETH) / 2 / grossNetworkProduct;\r\n          if(tokensToMint > maxTokens)\r\n          {\r\n            tokensToMint = maxTokens;\r\n          }\r\n\r\n          if(tokensToMint > 0)\r\n          {\r\n            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer\r\n            uint devReward = tokensToMint.mul(20) / 100;\r\n            IMintableERC20(udt).mint(_referrer, tokensToMint - devReward);\r\n            if(devReward > 0)\r\n            {\r\n              IMintableERC20(udt).mint(owner(), devReward);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This function will keep track of consumed discounts by a given user.\r\n   * It will also grant discount tokens to the creator who is granting the discount based on the\r\n   * amount of discount and compensation rate.\r\n   * This function is invoked by a previously deployed lock only.\r\n   */\r\n  function recordConsumedDiscount(\r\n    uint _discount,\r\n    uint /* _tokens */\r\n  )\r\n    public\r\n    onlyFromDeployedLock()\r\n  {\r\n    // TODO: implement me\r\n    totalDiscountGranted += _discount;\r\n    return;\r\n  }\r\n\r\n  // The version number of the current Unlock implementation on this network\r\n  function unlockVersion(\r\n  ) external pure\r\n    returns (uint16)\r\n  {\r\n    return 8;\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the owner to update configuration variables\r\n   */\r\n  function configUnlock(\r\n    address _udt,\r\n    address _weth,\r\n    uint _estimatedGasForPurchase,\r\n    string calldata _symbol,\r\n    string calldata _URI\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    udt = _udt;\r\n    weth = _weth;\r\n    estimatedGasForPurchase = _estimatedGasForPurchase;\r\n\r\n    globalTokenSymbol = _symbol;\r\n    globalBaseTokenURI = _URI;\r\n\r\n    emit ConfigUnlock(_udt, _weth, _estimatedGasForPurchase, _symbol, _URI);\r\n  }\r\n\r\n  /**\r\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\r\n   * @dev This will initialize the template and revokeOwnership.\r\n   */\r\n  function setLockTemplate(\r\n    address payable _publicLockAddress\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    // First claim the template so that no-one else could\r\n    // this will revert if the template was already initialized.\r\n    IPublicLock(_publicLockAddress).initialize(\r\n      address(this), 0, address(0), 0, 0, ''\r\n    );\r\n    IPublicLock(_publicLockAddress).renounceLockManager();\r\n\r\n    publicLockAddress = _publicLockAddress;\r\n\r\n    emit SetLockTemplate(_publicLockAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice allows the owner to set the oracle address to use for value conversions\r\n   * setting the _oracleAddress to address(0) removes support for the token\r\n   * @dev This will also call update to ensure at least one datapoint has been recorded.\r\n   */\r\n  function setOracle(\r\n    address _tokenAddress,\r\n    address _oracleAddress\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    uniswapOracles[_tokenAddress] = IUniswapOracle(_oracleAddress);\r\n    if(_oracleAddress != address(0)) {\r\n      IUniswapOracle(_oracleAddress).update(_tokenAddress, weth);\r\n    }\r\n  }\r\n\r\n  // Allows the owner to change the value tracking variables as needed.\r\n  function resetTrackedValue(\r\n    uint _grossNetworkProduct,\r\n    uint _totalDiscountGranted\r\n  ) external\r\n    onlyOwner\r\n  {\r\n    grossNetworkProduct = _grossNetworkProduct;\r\n    totalDiscountGranted = _totalDiscountGranted;\r\n\r\n    emit ResetTrackedValue(_grossNetworkProduct, _totalDiscountGranted);\r\n  }\r\n\r\n  /**\r\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\r\n   */\r\n  function getGlobalBaseTokenURI()\r\n    external\r\n    view\r\n    returns (string memory)\r\n  {\r\n    return globalBaseTokenURI;\r\n  }\r\n\r\n  /**\r\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\r\n   */\r\n  function getGlobalTokenSymbol()\r\n    external\r\n    view\r\n    returns (string memory)\r\n  {\r\n    return globalTokenSymbol;\r\n  }\r\n}"
    }
  }
}