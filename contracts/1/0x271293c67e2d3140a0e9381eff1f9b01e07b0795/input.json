{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "DSProxyCache.sol": {
      "content": "// proxy.sol - execute actions atomically through the proxy's identity\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.4.23;\r\n\r\n// DSProxyCache\r\n// This global cache stores addresses of contracts previously deployed\r\n// by a proxy. This saves gas from repeat deployment of the same\r\n// contracts and eliminates blockchain bloat.\r\n\r\n// By default, all proxies deployed from the same factory store\r\n// contracts in the same cache. The cache a proxy instance uses can be\r\n// changed.  The cache uses the sha3 hash of a contract's bytecode to\r\n// lookup the address\r\ncontract DSProxyCache {\r\n    mapping(bytes32 => address) cache;\r\n\r\n    function read(bytes _code) public view returns (address) {\r\n        bytes32 hash = keccak256(_code);\r\n        return cache[hash];\r\n    }\r\n\r\n    function write(bytes _code) public returns (address target) {\r\n        assembly {\r\n            target := create(0, add(_code, 0x20), mload(_code))\r\n            switch iszero(extcodesize(target))\r\n            case 1 {\r\n                // throw if contract failed to deploy\r\n                revert(0, 0)\r\n            }\r\n        }\r\n        bytes32 hash = keccak256(_code);\r\n        cache[hash] = target;\r\n    }\r\n}"
    }
  }
}