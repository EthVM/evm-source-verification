{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"LockLock.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    \r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n    \r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    \r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    \r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract TokenVestingPools {\r\n    using SafeMath for uint256;\r\n\r\n    struct UserInfo{\r\n        uint256 lockedAmount;\r\n        uint256 withdrawn;\r\n    }\r\n\r\n    struct PoolInfo{\r\n        uint256 startReleasingTime;\r\n        uint256 batchPeriod;\r\n        uint256 batchCount;\r\n        uint256 totalLocked;\r\n        uint8 index;\r\n        string name;\r\n    }\r\n    \r\n    IERC20 public lockedToken;\r\n    \r\n    PoolInfo[] public lockPools;\r\n    \r\n    mapping (uint8 => mapping (address => UserInfo)) internal userInfo;\r\n\r\n    event Claim(uint8 pid, address indexed beneficiary, uint value);\r\n\r\n\r\n    constructor(address _token) internal{\r\n        lockedToken = IERC20(_token);\r\n    }\r\n\r\n    function _addVestingPool(string memory _name, uint256 _startReleasingTime, uint256 _batchCount,  uint256 _batchPeriod) internal returns(uint8){\r\n        \r\n        lockPools.push(PoolInfo({\r\n            name: _name,\r\n            startReleasingTime: _startReleasingTime,\r\n            batchPeriod: _batchPeriod,\r\n            batchCount: _batchCount,\r\n            totalLocked:0,\r\n            index:(uint8)(lockPools.length)\r\n        }));\r\n\r\n        return (uint8)(lockPools.length) -1;\r\n    }\r\n\r\n    function _addBeneficiary(uint8 _pid, address _beneficiary, uint256 _lockedTokensCount) internal{\r\n\r\n        require(_pid < lockPools.length, \"non existing pool\");\r\n        require(userInfo[_pid][_beneficiary].lockedAmount == 0, \"existing beneficiary\"); //can add Beneficiary only once to a pool\r\n\r\n        userInfo[_pid][_beneficiary].lockedAmount = _lockedTokensCount * 1e18;\r\n        lockPools[_pid].totalLocked = lockPools[_pid].totalLocked.add(userInfo[_pid][_beneficiary].lockedAmount);\r\n    }\r\n\r\n     function claim(uint8 _pid) public returns(uint256 amount){\r\n\r\n        // require(_pid < LockPoolsCount, \"Can not claim from non existing pool\"); // no need since getReleasableAmount will return 0\r\n\r\n        amount = getReleasableAmount(_pid, msg.sender);\r\n        require (amount > 0, \"can not claimed 0 amount\");\r\n\r\n        userInfo[_pid][msg.sender].withdrawn = userInfo[_pid][msg.sender].withdrawn.add(amount);\r\n\r\n        lockedToken.transfer(msg.sender,amount);\r\n        \r\n        emit Claim(_pid, msg.sender, amount);\r\n    }\r\n    \r\n    function claim2(uint8 _pid) public returns(uint256 amount){\r\n\r\n        // require(_pid < LockPoolsCount, \"Can not claim from non existing pool\"); // no need since getReleasableAmount will return 0\r\n\r\n        amount = getReleasableAmount(_pid, msg.sender);\r\n        require (amount > 0, \"can not claimed 0 amount\");\r\n\r\n        userInfo[_pid][msg.sender].withdrawn = userInfo[_pid][msg.sender].withdrawn.add(amount);\r\n\r\n        lockedToken.transfer(msg.sender,amount);\r\n        \r\n       \r\n    }\r\n    \r\n    function claim3(uint8 _pid) public returns(uint256 amount){\r\n\r\n        // require(_pid < LockPoolsCount, \"Can not claim from non existing pool\"); // no need since getReleasableAmount will return 0\r\n\r\n        amount = getReleasableAmount(_pid, msg.sender);\r\n        if(amount >0){\r\n\r\n        userInfo[_pid][msg.sender].withdrawn = userInfo[_pid][msg.sender].withdrawn.add(amount);\r\n\r\n        lockedToken.transfer(msg.sender,amount);\r\n        emit Claim(_pid, msg.sender, amount);\r\n        }\r\n       \r\n    }\r\n    function claim4(uint8 _pid) public returns(uint256 amount){\r\n\r\n        // require(_pid < LockPoolsCount, \"Can not claim from non existing pool\"); // no need since getReleasableAmount will return 0\r\n\r\n        amount = getReleasableAmount(_pid, msg.sender);\r\n        if(amount >0){\r\n\r\n        userInfo[_pid][msg.sender].withdrawn = userInfo[_pid][msg.sender].withdrawn.add(amount);\r\n\r\n        lockedToken.transfer(msg.sender,amount);\r\n        \r\n        }\r\n       \r\n    }\r\n    \r\n    function claim5(uint8 _pid) public returns(uint256 amount){\r\n\r\n        // require(_pid < LockPoolsCount, \"Can not claim from non existing pool\"); // no need since getReleasableAmount will return 0\r\n\r\n        amount = getReleasableAmount(_pid, msg.sender);\r\n        //require (amount > 0, \"can not claimed 0 amount\");\r\n\r\n        userInfo[_pid][msg.sender].withdrawn = userInfo[_pid][msg.sender].withdrawn.add(amount);\r\n\r\n        lockedToken.transfer(msg.sender,amount);\r\n        \r\n        emit Claim(_pid, msg.sender, amount);\r\n    }\r\n    \r\n    function claim6(uint8 _pid) public returns(uint256 amount){\r\n\r\n        // require(_pid < LockPoolsCount, \"Can not claim from non existing pool\"); // no need since getReleasableAmount will return 0\r\n\r\n        amount = getReleasableAmount(_pid, msg.sender);\r\n        //require (amount > 0, \"can not claimed 0 amount\");\r\n\r\n        userInfo[_pid][msg.sender].withdrawn = userInfo[_pid][msg.sender].withdrawn.add(amount);\r\n\r\n        lockedToken.transfer(msg.sender,amount);\r\n        \r\n       \r\n    }\r\n\r\n    function getReleasableAmount(uint8 _pid, address _beneficiary) public  view returns(uint256){\r\n        return getVestedAmount(_pid, _beneficiary, getCurrentTime()).sub(userInfo[_pid][_beneficiary].withdrawn);\r\n    }\r\n\r\n\r\n    function getVestedAmount(uint8 _pid, address _beneficiary, uint256 _time) public  view returns(uint256){\r\n\r\n        if (_pid >= lockPools.length){\r\n            return 0;\r\n        }\r\n\r\n        // if time < StartReleasingTime: then return 0\r\n        if(_time < lockPools[_pid].startReleasingTime){\r\n            return 0;\r\n        }\r\n\r\n        uint256 lockedAmount = userInfo[_pid][_beneficiary].lockedAmount;\r\n\r\n        // if locked amount 0 return 0\r\n        if (lockedAmount == 0){\r\n            return 0;\r\n        }\r\n\r\n        // elapsedBatchCount = ((time - startReleasingTime) / batchPeriod) + 1\r\n        uint256 elapsedBatchCount =\r\n                    _time.sub(lockPools[_pid].startReleasingTime)\r\n                    .div(lockPools[_pid].batchPeriod)\r\n                    .add(1);\r\n\r\n        // vestedAmount = lockedAmount  * elapsedBatchCount / batchCount\r\n        uint256  vestedAmount =\r\n                    lockedAmount\r\n                    .mul(elapsedBatchCount)\r\n                    .div(lockPools[_pid].batchCount);\r\n\r\n        if(vestedAmount > lockedAmount){\r\n            vestedAmount = lockedAmount;\r\n        }\r\n\r\n        return vestedAmount;\r\n    }\r\n\r\n    function getBeneficiaryInfo(uint8 _pid, address _beneficiary) public view \r\n        returns(address beneficiary, \r\n                uint256 totalLocked, \r\n                uint256 withdrawn, \r\n                uint256 releasableAmount, \r\n                uint256 nextBatchTime, \r\n                uint256 currentTime){\r\n\r\n        beneficiary = _beneficiary;\r\n        currentTime = getCurrentTime();\r\n        if(_pid < lockPools.length){\r\n            totalLocked = userInfo[_pid][_beneficiary].lockedAmount;\r\n            withdrawn = userInfo[_pid][_beneficiary].withdrawn;\r\n            releasableAmount = getReleasableAmount(_pid, _beneficiary);\r\n            nextBatchTime = getNextBatchTime(_pid, _beneficiary, currentTime);\r\n        }\r\n    }\r\n\r\n    function getSenderInfo(uint8 _pid) external view returns(address beneficiary, uint256 totalLocked, uint256 withdrawaned, uint256 releasableAmount, uint256 nextBatchTime, uint256 currentTime){\r\n        return getBeneficiaryInfo(_pid, msg.sender);\r\n    }\r\n\r\n    function getNextBatchTime(uint8 _pid, address _beneficiary, uint256 _time) public view returns(uint256){\r\n\r\n        // if total vested equal to total locked then return 0\r\n        if(getVestedAmount(_pid, _beneficiary, _time) == userInfo[_pid][_beneficiary].lockedAmount){\r\n            return 0;\r\n        }\r\n\r\n        // if time less than startReleasingTime: then return sartReleasingTime\r\n        if(_time <= lockPools[_pid].startReleasingTime){\r\n            return lockPools[_pid].startReleasingTime;\r\n        }\r\n\r\n        // find the next batch time\r\n         uint256 elapsedBatchCount =\r\n                    _time.sub(lockPools[_pid].startReleasingTime)\r\n                    .div(lockPools[_pid].batchPeriod)\r\n                    .add(1);\r\n\r\n        uint256 nextBatchTime =\r\n                    elapsedBatchCount\r\n                    .mul(lockPools[_pid].batchPeriod)\r\n                    .add(lockPools[_pid].startReleasingTime);\r\n\r\n        return nextBatchTime;\r\n\r\n    }\r\n\r\n    function getPoolsCount() external view returns(uint256 poolsCount){\r\n        return lockPools.length;\r\n    }\r\n\r\n    function getPoolInfo(uint8 _pid) external view returns(\r\n                string memory name,\r\n                uint256 totalLocked,\r\n                uint256  startReleasingTime,\r\n                uint256  batchCount,\r\n                uint256  batchPeriodInDays){\r\n                    \r\n        if(_pid < lockPools.length){\r\n            name = lockPools[_pid].name;\r\n            totalLocked = lockPools[_pid].totalLocked;\r\n            startReleasingTime = lockPools[_pid].startReleasingTime;\r\n            batchCount = lockPools[_pid].batchCount;\r\n            batchPeriodInDays = lockPools[_pid].batchPeriod.div(1 days);\r\n        }\r\n    }\r\n\r\n    function getTotalLocked() external view returns(uint256 totalLocked){\r\n        totalLocked =0;\r\n\r\n        for(uint8 i=0; i<lockPools.length; i++){\r\n            totalLocked = totalLocked.add(lockPools[i].totalLocked);\r\n        }\r\n    }\r\n\r\n    function getCurrentTime() public view returns(uint256){\r\n        return block.timestamp;\r\n    }\r\n}\r\n\r\n\r\ncontract LockLock is TokenVestingPools{\r\n\r\n    constructor () public TokenVestingPools(0xE76CF1f9401079B8ddA4F98D914e0521846C2756){\r\n\r\n\t   // check https://www.epochconverter.com/ for timestamp\r\n\r\n\t   \r\n\t   uint8 pool_0 = _addVestingPool(\"pool0\" , 1640995200, 4, 90 days); \r\n\r\n\t  \r\n\t   _addBeneficiary(pool_0, 0xc06A06CeCB585Bb5247e1CC2a96263f59fC34613,1333333); // 1,333,333 Tokens\r\n\t   \r\n\t    uint8 pool_1 = _addVestingPool(\"pool1\" , 1612457122 , 4, 90 days); \r\n\r\n\t  \r\n\t   _addBeneficiary(pool_1, 0xc06A06CeCB585Bb5247e1CC2a96263f59fC34613,1333333); // 1,333,333 Tokens\r\n    }\r\n\t\r\n}"}}}