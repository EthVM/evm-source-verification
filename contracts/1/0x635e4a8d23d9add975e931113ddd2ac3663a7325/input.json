{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":700},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"FaaSPoolLite.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\nlibrary BConst {\r\n    uint public constant BONE                     = 10**18;\r\n\r\n    uint public constant MIN_BOUND_TOKENS         = 2;\r\n    uint public constant MAX_BOUND_TOKENS         = 8;\r\n\r\n    uint public constant DEFAULT_FEE              = BONE * 3 / 1000; // 0.3%\r\n    uint public constant MIN_FEE                  = BONE / 1000; // 0.1%\r\n    uint public constant MAX_FEE                  = BONE / 10; // 10%\r\n\r\n    uint public constant DEFAULT_COLLECTED_FEE    = BONE * 33 / 10000; // 0.33%\r\n    uint public constant MAX_COLLECTED_FEE        = BONE * 334 / 10000; // 3.34%\r\n\r\n    uint public constant DEFAULT_EXIT_FEE         = 0;\r\n    uint public constant MAX_EXIT_FEE             = BONE / 1000; // 0.1%\r\n\r\n    uint public constant MIN_WEIGHT               = BONE;\r\n    uint public constant MAX_WEIGHT               = BONE * 50;\r\n    uint public constant MAX_TOTAL_WEIGHT         = BONE * 50;\r\n    uint public constant MIN_BALANCE              = BONE / 10**12;\r\n\r\n    uint public constant DEFAULT_INIT_POOL_SUPPLY = BONE * 100;\r\n    uint public constant MIN_INIT_POOL_SUPPLY     = BONE / 1000;\r\n    uint public constant MAX_INIT_POOL_SUPPLY     = BONE * 10**18;\r\n\r\n    uint public constant MIN_BPOW_BASE            = 1 wei;\r\n    uint public constant MAX_BPOW_BASE            = (2 * BONE) - 1 wei;\r\n    uint public constant BPOW_PRECISION           = BONE / 10**10;\r\n\r\n    uint public constant MAX_IN_RATIO             = BONE / 2;\r\n    uint public constant MAX_OUT_RATIO            = (BONE / 3) + 1 wei;\r\n}\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\ncontract BNum {\r\n\r\n    function btoi(uint a)\r\n        internal pure \r\n        returns (uint)\r\n    {\r\n        return a / BConst.BONE;\r\n    }\r\n\r\n    function bfloor(uint a)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        return btoi(a) * BConst.BONE;\r\n    }\r\n\r\n    function badd(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c = a + b;\r\n        require(c >= a, \"add overflow\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        (uint c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"sub underflow\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint a, uint b)\r\n        internal pure\r\n        returns (uint, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"mul overflow\");\r\n        uint c1 = c0 + (BConst.BONE / 2);\r\n        require(c1 >= c0, \"mul overflow\");\r\n        uint c2 = c1 / BConst.BONE;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(b != 0, \"div by 0\");\r\n        uint c0 = a * BConst.BONE;\r\n        require(a == 0 || c0 / a == BConst.BONE, \"div internal\"); // bmul overflow\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"div internal\"); //  badd require\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    // DSMath.wpow\r\n    function bpowi(uint a, uint n)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint z = n % 2 != 0 ? a : BConst.BONE;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\r\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\r\n    // of approximation of b^0.w\r\n    function bpow(uint base, uint exp)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(base >= BConst.MIN_BPOW_BASE, \"base too low\");\r\n        require(base <= BConst.MAX_BPOW_BASE, \"base too high\");\r\n\r\n        uint whole  = bfloor(exp);   \r\n        uint remain = bsub(exp, whole);\r\n\r\n        uint wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint partialResult = bpowApprox(base, remain, BConst.BPOW_PRECISION);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(uint base, uint exp, uint precision)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        // term 0:\r\n        uint a     = exp;\r\n        (uint x, bool xneg)  = bsubSign(base, BConst.BONE);\r\n        uint term = BConst.BONE;\r\n        uint sum   = term;\r\n        bool negative = false;\r\n\r\n\r\n        // term(k) = numer / denom \r\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\r\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\r\n        // continue until term is less than precision\r\n        for (uint i = 1; term >= precision; i++) {\r\n            uint bigK = i * BConst.BONE;\r\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BConst.BONE));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n\r\n}\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n// Highly opinionated token implementation\r\ninterface IERC20 {\r\n    event Approval(address indexed src, address indexed dst, uint amt);\r\n    event Transfer(address indexed src, address indexed dst, uint amt);\r\n\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address whom) external view returns (uint);\r\n    function allowance(address src, address dst) external view returns (uint);\r\n\r\n    function approve(address dst, uint amt) external returns (bool);\r\n    function transfer(address dst, uint amt) external returns (bool);\r\n    function transferFrom(\r\n        address src, address dst, uint amt\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract BTokenBase is BNum {\r\n\r\n    mapping(address => uint)                   internal _balance;\r\n    mapping(address => mapping(address=>uint)) internal _allowance;\r\n    uint internal _totalSupply;\r\n\r\n    event Approval(address indexed src, address indexed dst, uint amt);\r\n    event Transfer(address indexed src, address indexed dst, uint amt);\r\n\r\n    function _mint(uint amt) internal {\r\n        _balance[address(this)] = badd(_balance[address(this)], amt);\r\n        _totalSupply = badd(_totalSupply, amt);\r\n        emit Transfer(address(0), address(this), amt);\r\n    }\r\n\r\n    function _burn(uint amt) internal {\r\n        require(_balance[address(this)] >= amt, \"!bal\");\r\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\r\n        _totalSupply = bsub(_totalSupply, amt);\r\n        emit Transfer(address(this), address(0), amt);\r\n    }\r\n\r\n    function _move(address src, address dst, uint amt) internal {\r\n        require(_balance[src] >= amt, \"!bal\");\r\n        _balance[src] = bsub(_balance[src], amt);\r\n        _balance[dst] = badd(_balance[dst], amt);\r\n        emit Transfer(src, dst, amt);\r\n    }\r\n\r\n    function _push(address to, uint amt) internal {\r\n        _move(address(this), to, amt);\r\n    }\r\n\r\n    function _pull(address from, uint amt) internal {\r\n        _move(from, address(this), amt);\r\n    }\r\n}\r\n\r\ncontract BToken is BTokenBase, IERC20 {\r\n    string  private _name     = \"Value Liquidity Provider\";\r\n    string  private _symbol   = \"VLP\";\r\n    uint8   private _decimals = 18;\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns(uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function allowance(address src, address dst) external override view returns (uint) {\r\n        return _allowance[src][dst];\r\n    }\r\n\r\n    function balanceOf(address whom) public override view returns (uint) {\r\n        return _balance[whom];\r\n    }\r\n\r\n    function totalSupply() public override view returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function approve(address dst, uint amt) external override returns (bool) {\r\n        _allowance[msg.sender][dst] = amt;\r\n        emit Approval(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address dst, uint amt) external returns (bool) {\r\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\r\n        uint oldValue = _allowance[msg.sender][dst];\r\n        if (amt > oldValue) {\r\n            _allowance[msg.sender][dst] = 0;\r\n        } else {\r\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\r\n        }\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint amt) external override returns (bool) {\r\n        _move(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint amt) external override returns (bool) {\r\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \"!spender\");\r\n        _move(src, dst, amt);\r\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\r\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\r\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\ncontract BMathLite is BNum {\r\n    /**********************************************************************************************\r\n    // calcSpotPrice                                                                             //\r\n    // sP = spotPrice                                                                            //\r\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\r\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\r\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee (+ collectedFee)                                                             //\r\n    **********************************************************************************************/\r\n    function calcSpotPrice(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint spotPrice)\r\n    {\r\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\r\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\r\n        uint ratio = bdiv(numer, denom);\r\n        uint scale = bdiv(BConst.BONE, bsub(BConst.BONE, swapFee));\r\n        return  (spotPrice = bmul(ratio, scale));\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcOutGivenIn                                                                            //\r\n    // aO = tokenAmountOut                                                                       //\r\n    // bO = tokenBalanceOut                                                                      //\r\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\r\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\r\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee (+ collectedFee)                                                             //\r\n    **********************************************************************************************/\r\n    function calcOutGivenIn(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint tokenAmountIn,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint tokenAmountOut)\r\n    {\r\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\r\n        uint adjustedIn = bsub(BConst.BONE, swapFee);\r\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\r\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\r\n        uint foo = bpow(y, weightRatio);\r\n        uint bar = bsub(BConst.BONE, foo);\r\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcInGivenOut                                                                            //\r\n    // aI = tokenAmountIn                                                                        //\r\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\r\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\r\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\r\n    // wI = tokenWeightIn           --------------------------------------------                 //\r\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\r\n    // sF = swapFee (+ collectedFee)                                                             //\r\n    **********************************************************************************************/\r\n    function calcInGivenOut(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint tokenAmountOut,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint tokenAmountIn)\r\n    {\r\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\r\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\r\n        uint y = bdiv(tokenBalanceOut, diff);\r\n        uint foo = bpow(y, weightRatio);\r\n        foo = bsub(foo, BConst.BONE);\r\n        tokenAmountIn = bsub(BConst.BONE, swapFee);\r\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcPoolOutGivenSingleIn                                                                  //\r\n    // pAo = poolAmountOut         /                                              \\              //\r\n    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\r\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\r\n    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\r\n    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\r\n    // pS = poolSupply            \\\\                    tBi               /        /             //\r\n    // sF = swapFee (+ collectedFee)\\                                              /              //\r\n    **********************************************************************************************/\r\n    function calcPoolOutGivenSingleIn(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountIn,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint poolAmountOut)\r\n    {\r\n        // @dev Charge the trading fee for the proportion of tokenAi\r\n        // which is implicitly traded to the other pool tokens.\r\n        // That proportion is (1- weightTokenIn)\r\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\r\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\r\n        uint zaz = bmul(bsub(BConst.BONE, normalizedWeight), swapFee);\r\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BConst.BONE, zaz));\r\n\r\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\r\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\r\n\r\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\r\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\r\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\r\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\r\n        return poolAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcSingleOutGivenPoolIn                                                                  //\r\n    // tAo = tokenAmountOut            /      /                                             \\\\   //\r\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\r\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\r\n    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\r\n    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\r\n    // tW = totalWeight                    /     /      wO \\       \\                             //\r\n    // sF = swapFee (+ collectedFee)   *  | 1 - |  1 - ---- | * sF  |                            //\r\n    // eF = exitFee                        \\     \\      tW /       /                             //\r\n    **********************************************************************************************/\r\n    function calcSingleOutGivenPoolIn(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint poolAmountIn,\r\n        uint swapFee,\r\n        uint exitFee\r\n    )\r\n        public pure\r\n        returns (uint tokenAmountOut)\r\n    {\r\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\r\n        // charge exit fee on the pool token side\r\n        // pAiAfterExitFee = pAi*(1-exitFee)\r\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BConst.BONE, exitFee));\r\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\r\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\r\n     \r\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\r\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BConst.BONE, normalizedWeight));\r\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\r\n\r\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\r\n\r\n        // charge swap fee on the output token side \r\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\r\n        uint zaz = bmul(bsub(BConst.BONE, normalizedWeight), swapFee);\r\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BConst.BONE, zaz));\r\n        return tokenAmountOut;\r\n    }\r\n\r\n\r\n}\r\n\r\ninterface IBFactory {\r\n    function collectedToken() external view returns (address);\r\n}\r\n\r\ncontract BPoolLite is BToken, BMathLite {\r\n    struct Record {\r\n        bool bound;   // is token bound to pool\r\n        uint index;   // private\r\n        uint denorm;  // denormalized weight\r\n        uint balance;\r\n    }\r\n\r\n    event LOG_SWAP(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        address indexed tokenOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 tokenAmountOut\r\n    );\r\n\r\n    event LOG_JOIN(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        uint256 tokenAmountIn\r\n    );\r\n\r\n    event LOG_EXIT(\r\n        address indexed caller,\r\n        address indexed tokenOut,\r\n        uint256 tokenAmountOut\r\n    );\r\n\r\n    event LOG_COLLECTED_FUND(\r\n        address indexed collectedToken,\r\n        uint256 collectedAmount\r\n    );\r\n\r\n    event LOG_FINALIZE(\r\n        uint swapFee,\r\n        uint initPoolSupply,\r\n        uint version,\r\n        address[] bindTokens,\r\n        uint[] bindDenorms,\r\n        uint[] balances\r\n    );\r\n\r\n    modifier _lock_() {\r\n        require(!_mutex, \"reentry\");\r\n        _mutex = true;\r\n        _;\r\n        _mutex = false;\r\n    }\r\n\r\n    modifier _viewlock_() {\r\n        require(!_mutex, \"reentry\");\r\n        _;\r\n    }\r\n\r\n    bool private _mutex;\r\n\r\n    uint public version = 2001;\r\n    address public factory;    // BFactory address to push token exitFee to\r\n    address public controller; // has CONTROL role\r\n\r\n    // `setSwapFee` and `finalize` require CONTROL\r\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\r\n    uint public swapFee;\r\n    uint public collectedFee; // 0.05% | https://yfv.finance/vip-vote/vip_5\r\n    uint public exitFee;\r\n    bool public finalized;\r\n\r\n    address[] internal _tokens;\r\n    mapping(address => Record) internal _records;\r\n    uint private _totalWeight;\r\n\r\n    constructor(address _factory) public {\r\n        controller = _factory;\r\n        factory = _factory;\r\n        swapFee = BConst.DEFAULT_FEE;\r\n        collectedFee = BConst.DEFAULT_COLLECTED_FEE;\r\n        exitFee = BConst.DEFAULT_EXIT_FEE;\r\n        finalized = false;\r\n    }\r\n\r\n    function setCollectedFee(uint _collectedFee) public {\r\n        require(msg.sender == factory, \"!fctr\");\r\n        require(_collectedFee <= BConst.MAX_COLLECTED_FEE, \">maxCoFee\");\r\n        require(bmul(_collectedFee, 2) <= swapFee, \">sFee/2\");\r\n        collectedFee = _collectedFee;\r\n    }\r\n\r\n    function setExitFee(uint _exitFee) public {\r\n        require(!finalized, \"fnl\");\r\n        require(msg.sender == factory, \"!fctr\");\r\n        require(_exitFee <= BConst.MAX_EXIT_FEE, \">maxExitFee\");\r\n        exitFee = _exitFee;\r\n    }\r\n\r\n    function isBound(address t)\r\n    external view\r\n    returns (bool)\r\n    {\r\n        return _records[t].bound;\r\n    }\r\n\r\n    function getNumTokens()\r\n    external view\r\n    returns (uint)\r\n    {\r\n        return _tokens.length;\r\n    }\r\n\r\n    function getCurrentTokens()\r\n    external view _viewlock_\r\n    returns (address[] memory tokens)\r\n    {\r\n        return _tokens;\r\n    }\r\n\r\n    function getFinalTokens()\r\n    external view\r\n    _viewlock_\r\n    returns (address[] memory tokens)\r\n    {\r\n        require(finalized, \"!fnl\");\r\n        return _tokens;\r\n    }\r\n\r\n    function getDenormalizedWeight(address token)\r\n    external view\r\n    _viewlock_\r\n    returns (uint)\r\n    {\r\n\r\n        require(_records[token].bound, \"!bound\");\r\n        return _records[token].denorm;\r\n    }\r\n\r\n    function getTotalDenormalizedWeight()\r\n    external view\r\n    _viewlock_\r\n    returns (uint)\r\n    {\r\n        return _totalWeight;\r\n    }\r\n\r\n    function getNormalizedWeight(address token)\r\n    external view\r\n    _viewlock_\r\n    returns (uint)\r\n    {\r\n\r\n        require(_records[token].bound, \"!bound\");\r\n        uint denorm = _records[token].denorm;\r\n        return bdiv(denorm, _totalWeight);\r\n    }\r\n\r\n    function getBalance(address token)\r\n    external view\r\n    _viewlock_\r\n    returns (uint)\r\n    {\r\n\r\n        require(_records[token].bound, \"!bound\");\r\n        return _records[token].balance;\r\n    }\r\n\r\n    function setController(address _controller)\r\n    external\r\n    _lock_\r\n    {\r\n        require(msg.sender == controller, \"!cntler\");\r\n        controller = _controller;\r\n    }\r\n\r\n    function finalize(\r\n        uint _swapFee,\r\n        uint _initPoolSupply,\r\n        address[] calldata _bindTokens,\r\n        uint[] calldata _bindDenorms\r\n    ) external _lock_ {\r\n        require(msg.sender == controller, \"!cntler\");\r\n        require(!finalized, \"fnl\");\r\n\r\n        require(_swapFee >= BConst.MIN_FEE, \"<minFee\");\r\n        require(_swapFee <= BConst.MAX_FEE, \">maxFee\");\r\n        swapFee = _swapFee;\r\n        collectedFee = _swapFee / 3;\r\n\r\n        require(_initPoolSupply >= BConst.MIN_INIT_POOL_SUPPLY, \"<minInitPSup\");\r\n        require(_initPoolSupply <= BConst.MAX_INIT_POOL_SUPPLY, \">maxInitPSup\");\r\n\r\n        require(_bindTokens.length >= BConst.MIN_BOUND_TOKENS, \"<minTokens\");\r\n        require(_bindTokens.length < BConst.MAX_BOUND_TOKENS, \">maxTokens\");\r\n        require(_bindTokens.length == _bindDenorms.length, \"erLengMism\");\r\n\r\n        uint totalWeight = 0;\r\n        uint256[] memory balances = new uint[](_bindTokens.length);\r\n        for (uint i = 0; i < _bindTokens.length; i++) {\r\n            address token = _bindTokens[i];\r\n            uint denorm = _bindDenorms[i];\r\n            uint balance = BToken(token).balanceOf(address(this));\r\n            balances[i] = balance;\r\n            require(!_records[token].bound, \"bound\");\r\n            require(denorm >= BConst.MIN_WEIGHT, \"<minWeight\");\r\n            require(denorm <= BConst.MAX_WEIGHT, \">maxWeight\");\r\n            require(balance >= BConst.MIN_BALANCE, \"<minBal\");\r\n            _records[token] = Record({\r\n                bound : true,\r\n                index : i,\r\n                denorm : denorm,\r\n                balance : balance\r\n                });\r\n            totalWeight = badd(totalWeight, denorm);\r\n        }\r\n        require(totalWeight <= BConst.MAX_TOTAL_WEIGHT, \">maxTWeight\");\r\n        _totalWeight = totalWeight;\r\n        _tokens = _bindTokens;\r\n        finalized = true;\r\n        _mintPoolShare(_initPoolSupply);\r\n        _pushPoolShare(msg.sender, _initPoolSupply);\r\n        emit LOG_FINALIZE(swapFee, _initPoolSupply, version, _bindTokens, _bindDenorms, balances);\r\n    }\r\n\r\n    // Absorb any tokens that have been sent to this contract into the pool\r\n    function gulp(address token)\r\n    external\r\n    _lock_\r\n    {\r\n        require(_records[token].bound, \"!bound\");\r\n        _records[token].balance = IERC20(token).balanceOf(address(this));\r\n    }\r\n\r\n    function getSpotPrice(address tokenIn, address tokenOut)\r\n    external view\r\n    _viewlock_\r\n    returns (uint spotPrice)\r\n    {\r\n        require(_records[tokenIn].bound, \"!bound\");\r\n        require(_records[tokenOut].bound, \"!bound\");\r\n        Record storage inRecord = _records[tokenIn];\r\n        Record storage outRecord = _records[tokenOut];\r\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, swapFee);\r\n    }\r\n\r\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\r\n    external view\r\n    _viewlock_\r\n    returns (uint spotPrice)\r\n    {\r\n        require(_records[tokenIn].bound, \"!bound\");\r\n        require(_records[tokenOut].bound, \"!bound\");\r\n        Record storage inRecord = _records[tokenIn];\r\n        Record storage outRecord = _records[tokenOut];\r\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\r\n    }\r\n\r\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\r\n    external virtual\r\n    _lock_\r\n    {\r\n        require(finalized, \"!fnl\");\r\n\r\n        uint poolTotal = totalSupply();\r\n        uint ratio = bdiv(poolAmountOut, poolTotal);\r\n        require(ratio != 0, \"erMApr\");\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint bal = _records[t].balance;\r\n            uint tokenAmountIn = bmul(ratio, bal);\r\n            require(tokenAmountIn != 0, \"erMApr\");\r\n            require(tokenAmountIn <= maxAmountsIn[i], \"<limIn\");\r\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\r\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\r\n        }\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n    }\r\n\r\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\r\n    external virtual\r\n    _lock_\r\n    {\r\n        require(finalized, \"!fnl\");\r\n\r\n        uint poolTotal = totalSupply();\r\n        uint _exitFee = bmul(poolAmountIn, exitFee);\r\n        uint pAiAfterExitFee = bsub(poolAmountIn, _exitFee);\r\n        uint ratio = bdiv(pAiAfterExitFee, poolTotal);\r\n        require(ratio != 0, \"erMApr\");\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        if (_exitFee > 0) {\r\n            _pushPoolShare(factory, _exitFee);\r\n        }\r\n        _burnPoolShare(pAiAfterExitFee);\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint bal = _records[t].balance;\r\n            uint tokenAmountOut = bmul(ratio, bal);\r\n            require(tokenAmountOut != 0, \"erMApr\");\r\n            require(tokenAmountOut >= minAmountsOut[i], \"<limO\");\r\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\r\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\r\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\r\n        }\r\n    }\r\n\r\n    function swapExactAmountIn(\r\n        address tokenIn,\r\n        uint tokenAmountIn,\r\n        address tokenOut,\r\n        uint minAmountOut,\r\n        uint maxPrice\r\n    )\r\n    external\r\n    _lock_\r\n    returns (uint tokenAmountOut, uint spotPriceAfter)\r\n    {\r\n\r\n        require(_records[tokenIn].bound, \"!bound\");\r\n        require(_records[tokenOut].bound, \"!bound\");\r\n\r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(tokenAmountIn <= bmul(inRecord.balance, BConst.MAX_IN_RATIO), \">maxIRat\");\r\n\r\n        uint spotPriceBefore = calcSpotPrice(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            swapFee\r\n        );\r\n        require(spotPriceBefore <= maxPrice, \"badLimPrice\");\r\n\r\n        tokenAmountOut = calcOutGivenIn(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            tokenAmountIn,\r\n            swapFee\r\n        );\r\n        require(tokenAmountOut >= minAmountOut, \"<limO\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        spotPriceAfter = calcSpotPrice(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            swapFee\r\n        );\r\n        require(spotPriceAfter >= spotPriceBefore, \"erMApr\");\r\n        require(spotPriceAfter <= maxPrice, \">limPrice\");\r\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"erMApr\");\r\n\r\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n        uint _subTokenAmountIn;\r\n        (_subTokenAmountIn, tokenAmountOut) = _pushCollectedFundGivenOut(tokenIn, tokenAmountIn, tokenOut, tokenAmountOut);\r\n        if (_subTokenAmountIn > 0) inRecord.balance = bsub(inRecord.balance, _subTokenAmountIn);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return (tokenAmountOut, spotPriceAfter);\r\n    }\r\n\r\n    function swapExactAmountOut(\r\n        address tokenIn,\r\n        uint maxAmountIn,\r\n        address tokenOut,\r\n        uint tokenAmountOut,\r\n        uint maxPrice\r\n    )\r\n    external\r\n    _lock_\r\n    returns (uint tokenAmountIn, uint spotPriceAfter)\r\n    {\r\n        require(_records[tokenIn].bound, \"!bound\");\r\n        require(_records[tokenOut].bound, \"!bound\");\r\n\r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n\r\n        require(tokenAmountOut <= bmul(outRecord.balance, BConst.MAX_OUT_RATIO), \">maxORat\");\r\n\r\n        uint spotPriceBefore = calcSpotPrice(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            swapFee\r\n        );\r\n        require(spotPriceBefore <= maxPrice, \"badLimPrice\");\r\n\r\n        tokenAmountIn = calcInGivenOut(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            tokenAmountOut,\r\n            swapFee\r\n        );\r\n        require(tokenAmountIn <= maxAmountIn, \"<limIn\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        spotPriceAfter = calcSpotPrice(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            swapFee\r\n        );\r\n        require(spotPriceAfter >= spotPriceBefore, \"erMApr\");\r\n        require(spotPriceAfter <= maxPrice, \">limPrice\");\r\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"erMApr\");\r\n\r\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n        uint _collectedFeeAmount = _pushCollectedFundGivenIn(tokenIn, tokenAmountIn);\r\n        if (_collectedFeeAmount > 0) inRecord.balance = bsub(inRecord.balance, _collectedFeeAmount);\r\n\r\n        return (tokenAmountIn, spotPriceAfter);\r\n    }\r\n\r\n    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\r\n    external\r\n    _lock_\r\n    returns (uint poolAmountOut)\r\n\r\n    {\r\n        require(finalized, \"!fnl\");\r\n        require(_records[tokenIn].bound, \"!bound\");\r\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, BConst.MAX_IN_RATIO), \">maxIRat\");\r\n\r\n        Record storage inRecord = _records[tokenIn];\r\n\r\n        poolAmountOut = calcPoolOutGivenSingleIn(\r\n            inRecord.balance,\r\n            inRecord.denorm,\r\n            _totalSupply,\r\n            _totalWeight,\r\n            tokenAmountIn,\r\n            swapFee\r\n        );\r\n\r\n        require(poolAmountOut >= minPoolAmountOut, \"<limO\");\r\n\r\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\r\n\r\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n        uint _subTokenAmountIn;\r\n        (_subTokenAmountIn, poolAmountOut) = _pushCollectedFundGivenOut(tokenIn, tokenAmountIn, address(this), poolAmountOut);\r\n        if (_subTokenAmountIn > 0) inRecord.balance = bsub(inRecord.balance, _subTokenAmountIn);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n\r\n        return poolAmountOut;\r\n    }\r\n\r\n    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\r\n    external\r\n    _lock_\r\n    returns (uint tokenAmountOut)\r\n    {\r\n        require(finalized, \"!fnl\");\r\n        require(_records[tokenOut].bound, \"!bound\");\r\n\r\n        Record storage outRecord = _records[tokenOut];\r\n\r\n        tokenAmountOut = calcSingleOutGivenPoolIn(\r\n            outRecord.balance,\r\n            outRecord.denorm,\r\n            _totalSupply,\r\n            _totalWeight,\r\n            poolAmountIn,\r\n            swapFee,\r\n            exitFee\r\n        );\r\n\r\n        require(tokenAmountOut >= minAmountOut, \"<limO\");\r\n\r\n        require(tokenAmountOut <= bmul(_records[tokenOut].balance, BConst.MAX_OUT_RATIO), \">maxORat\");\r\n\r\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\r\n\r\n        uint _exitFee = bmul(poolAmountIn, exitFee);\r\n\r\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(bsub(poolAmountIn, _exitFee));\r\n        if (_exitFee > 0) {\r\n            _pushPoolShare(factory, _exitFee);\r\n        }\r\n        (, tokenAmountOut) = _pushCollectedFundGivenOut(address(this), poolAmountIn, tokenOut, tokenAmountOut);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    // ==\r\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\r\n    // You must `_lock_` or otherwise ensure reentry-safety\r\n    //\r\n    // Fixed ERC-20 transfer revert for some special token such as USDT\r\n    function _pullUnderlying(address erc20, address from, uint amount) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = erc20.call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), '!_pullU');\r\n    }\r\n\r\n    function _pushUnderlying(address erc20, address to, uint amount) internal\r\n    {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = erc20.call(abi.encodeWithSelector(0xa9059cbb, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), '!_pushU');\r\n    }\r\n\r\n    function _pullPoolShare(address from, uint amount)\r\n    internal\r\n    {\r\n        _pull(from, amount);\r\n    }\r\n\r\n    function _pushPoolShare(address to, uint amount)\r\n    internal\r\n    {\r\n        _push(to, amount);\r\n    }\r\n\r\n    function _mintPoolShare(uint amount)\r\n    internal\r\n    {\r\n        _mint(amount);\r\n    }\r\n\r\n    function _burnPoolShare(uint amount)\r\n    internal\r\n    {\r\n        _burn(amount);\r\n    }\r\n\r\n    function _pushCollectedFundGivenOut(address _tokenIn, uint _tokenAmountIn, address _tokenOut, uint _tokenAmountOut) internal returns (uint subTokenAmountIn, uint tokenAmountOut) {\r\n        subTokenAmountIn = 0;\r\n        tokenAmountOut = _tokenAmountOut;\r\n        if (collectedFee > 0) {\r\n            address _collectedToken = IBFactory(factory).collectedToken();\r\n            if (_collectedToken == _tokenIn) {\r\n                subTokenAmountIn = bdiv(bmul(_tokenAmountIn, collectedFee), BConst.BONE);\r\n                _pushUnderlying(_tokenIn, factory, subTokenAmountIn);\r\n                emit LOG_COLLECTED_FUND(_tokenIn, subTokenAmountIn);\r\n            } else {\r\n                uint _collectedFeeAmount = bdiv(bmul(_tokenAmountOut, collectedFee), BConst.BONE);\r\n                _pushUnderlying(_tokenOut, factory, _collectedFeeAmount);\r\n                tokenAmountOut = bsub(_tokenAmountOut, _collectedFeeAmount);\r\n                emit LOG_COLLECTED_FUND(_tokenOut, _collectedFeeAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    // always push out _tokenIn (already have)\r\n    function _pushCollectedFundGivenIn(address _tokenIn, uint _tokenAmountIn) internal returns (uint collectedFeeAmount) {\r\n        collectedFeeAmount = 0;\r\n        if (collectedFee > 0) {\r\n            address _collectedToken = IBFactory(factory).collectedToken();\r\n            if (_collectedToken != address(0)) {\r\n                collectedFeeAmount = bdiv(bmul(_tokenAmountIn, collectedFee), BConst.BONE);\r\n                _pushUnderlying(_tokenIn, factory, collectedFeeAmount);\r\n                emit LOG_COLLECTED_FUND(_tokenIn, collectedFeeAmount);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IFaaSPool {\r\n    function stake(uint) external;\r\n    function withdraw(uint) external;\r\n    function getReward(uint8 _pid, address _account) external;\r\n    function getAllRewards(address _account) external;\r\n    function pendingReward(uint8 _pid, address _account) external view returns (uint);\r\n    function emergencyWithdraw() external;\r\n}\r\n\r\ninterface IFaaSRewardFund {\r\n    function balance(IERC20 _token) external view returns (uint);\r\n    function safeTransfer(IERC20 _token, address _to, uint _value) external;\r\n}\r\n\r\n// This implements BPool contract, and allows for generalized staking, yield farming, and token distribution.\r\ncontract FaaSPoolLite is BPoolLite, IFaaSPool {\r\n    using SafeMath for uint;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint amount;\r\n        mapping(uint8 => uint) rewardDebt;\r\n        mapping(uint8 => uint) accumulatedEarned; // will accumulate every time user harvest\r\n        mapping(uint8 => uint) lockReward;\r\n        mapping(uint8 => uint) lockRewardReleased;\r\n        uint lastStakeTime;\r\n    }\r\n\r\n    // Info of each rewardPool funding.\r\n    struct RewardPoolInfo {\r\n        IERC20 rewardToken;     // Address of rewardPool token contract.\r\n        uint lastRewardBlock;   // Last block number that rewardPool distribution occurs.\r\n        uint endRewardBlock;    // Block number which rewardPool distribution ends.\r\n        uint rewardPerBlock;    // Reward token amount to distribute per block.\r\n        uint accRewardPerShare; // Accumulated rewardPool per share, times 1e18.\r\n\r\n        uint lockRewardPercent; // Lock reward percent - 0 to disable lock & vesting\r\n        uint startVestingBlock; // Block number which vesting starts.\r\n        uint endVestingBlock;   // Block number which vesting ends.\r\n        uint numOfVestingBlocks;\r\n\r\n        uint totalPaidRewards;\r\n    }\r\n\r\n    mapping(address => UserInfo) private userInfo;\r\n    RewardPoolInfo[] public rewardPoolInfo;\r\n\r\n    IFaaSRewardFund public rewardFund;\r\n    address public exchangeProxy;\r\n    uint public unstakingFrozenTime = 0 days;\r\n\r\n    event Deposit(address indexed account, uint256 amount);\r\n    event Withdraw(address indexed account, uint256 amount);\r\n    event RewardPaid(uint8 pid, address indexed account, uint256 amount);\r\n\r\n    constructor(address _factory) public BPoolLite(_factory) {\r\n    }\r\n\r\n    modifier onlyController() {\r\n        require(msg.sender == controller, \"!cntler\");\r\n        _;\r\n    }\r\n\r\n    function finalizeRewardFundInfo(IFaaSRewardFund _rewardFund, uint _unstakingFrozenTime) external onlyController {\r\n        require(address(rewardFund) == address(0), \"rewardFund!=null\");\r\n        assert(unstakingFrozenTime <= 30 days);\r\n        // do not lock fund for too long, please!\r\n        unstakingFrozenTime = _unstakingFrozenTime;\r\n        rewardFund = _rewardFund;\r\n    }\r\n\r\n    function setExchangeProxy(address _exchangeProxy) public onlyController {\r\n        exchangeProxy = _exchangeProxy;\r\n    }\r\n\r\n    function addRewardPool(IERC20 _rewardToken, uint256 _startBlock, uint256 _endRewardBlock, uint256 _rewardPerBlock,\r\n        uint256 _lockRewardPercent, uint256 _startVestingBlock, uint256 _endVestingBlock) external onlyController {\r\n        require(rewardPoolInfo.length < 8, \"exceed rwdPoolLim\");\r\n        require(_startVestingBlock <= _endVestingBlock, \"sVB>eVB\");\r\n        _startBlock = (block.number > _startBlock) ? block.number : _startBlock;\r\n        require(_startBlock < _endRewardBlock, \"sB>=eB\");\r\n        updateReward();\r\n        rewardPoolInfo.push(RewardPoolInfo({\r\n            rewardToken : _rewardToken,\r\n            lastRewardBlock : _startBlock,\r\n            endRewardBlock : _endRewardBlock,\r\n            rewardPerBlock : _rewardPerBlock,\r\n            accRewardPerShare : 0,\r\n            lockRewardPercent : _lockRewardPercent,\r\n            startVestingBlock : _startVestingBlock,\r\n            endVestingBlock : _endVestingBlock,\r\n            numOfVestingBlocks: _endVestingBlock - _startVestingBlock,\r\n            totalPaidRewards: 0\r\n            }));\r\n    }\r\n\r\n    function updateRewardPool(uint8 _pid, uint256 _endRewardBlock, uint256 _rewardPerBlock) public onlyController {\r\n        updateReward(_pid);\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\r\n        require(block.number <= rewardPool.endRewardBlock, \"late\");\r\n        rewardPool.endRewardBlock = _endRewardBlock;\r\n        rewardPool.rewardPerBlock = _rewardPerBlock;\r\n    }\r\n\r\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external override {\r\n        joinPoolFor(msg.sender, poolAmountOut, maxAmountsIn);\r\n    }\r\n\r\n    function joinPoolFor(address account, uint poolAmountOut, uint[] calldata maxAmountsIn) public _lock_ {\r\n        require(msg.sender == account || msg.sender == exchangeProxy, \"!(prx||own)\");\r\n        _joinPool(account, poolAmountOut, maxAmountsIn);\r\n        _stakePoolShare(account, poolAmountOut);\r\n    }\r\n\r\n    function joinPoolNotStake(uint poolAmountOut, uint[] calldata maxAmountsIn) external _lock_ {\r\n        _joinPool(msg.sender, poolAmountOut, maxAmountsIn);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n    }\r\n\r\n    function _joinPool(address account, uint poolAmountOut, uint[] calldata maxAmountsIn) internal {\r\n        require(finalized, \"!fnl\");\r\n\r\n        uint rewardTotal = totalSupply();\r\n        uint ratio = bdiv(poolAmountOut, rewardTotal);\r\n        require(ratio != 0, \"erMApr\");\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint bal = _records[t].balance;\r\n            uint tokenAmountIn = bmul(ratio, bal);\r\n            require(tokenAmountIn != 0 && tokenAmountIn <= maxAmountsIn[i], \"erMApr||<limIn\");\r\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\r\n            emit LOG_JOIN(account, t, tokenAmountIn);\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\r\n        }\r\n        _mintPoolShare(poolAmountOut);\r\n    }\r\n\r\n    function stake(uint _shares) external override {\r\n        uint _before = balanceOf(address(this));\r\n        _pullPoolShare(msg.sender, _shares);\r\n        uint _after = balanceOf(address(this));\r\n        _shares = bsub(_after, _before); // Additional check for deflationary tokens\r\n        _stakePoolShare(msg.sender, _shares);\r\n    }\r\n\r\n    function _stakePoolShare(address _account, uint _shares) internal {\r\n        UserInfo storage user = userInfo[_account];\r\n        getAllRewards(_account);\r\n        user.amount = user.amount.add(_shares);\r\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\r\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\r\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\r\n        }\r\n        user.lastStakeTime = block.timestamp;\r\n        emit Deposit(_account, _shares);\r\n    }\r\n\r\n    function unfrozenStakeTime(address _account) public view returns (uint) {\r\n        return userInfo[_account].lastStakeTime + unstakingFrozenTime;\r\n    }\r\n\r\n    function withdraw(uint _amount) public override {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.amount >= _amount, \"am>us.am\");\r\n        require(block.timestamp >= user.lastStakeTime.add(unstakingFrozenTime), \"frozen\");\r\n        getAllRewards(msg.sender);\r\n        user.amount = bsub(user.amount, _amount);\r\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\r\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\r\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\r\n        }\r\n        _pushPoolShare(msg.sender, _amount);\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    // using PUSH pattern for using by Proxy if needed\r\n    function getAllRewards(address _account) public override {\r\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\r\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\r\n            getReward(_pid, _account);\r\n        }\r\n    }\r\n\r\n    function getReward(uint8 _pid, address _account) public override {\r\n        updateReward(_pid);\r\n        UserInfo storage user = userInfo[_account];\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\r\n        uint _pendingReward = user.amount.mul(rewardPool.accRewardPerShare).div(1e18).sub(user.rewardDebt[_pid]);\r\n        uint _lockRewardPercent = rewardPool.lockRewardPercent;\r\n        if (_lockRewardPercent > 0) {\r\n            if (block.number > rewardPool.endVestingBlock) {\r\n                uint _unlockReward = user.lockReward[_pid].sub(user.lockRewardReleased[_pid]);\r\n                if (_unlockReward > 0) {\r\n                    _pendingReward = _pendingReward.add(_unlockReward);\r\n                    user.lockRewardReleased[_pid] = user.lockRewardReleased[_pid].add(_unlockReward);\r\n                }\r\n            } else {\r\n                if (_pendingReward > 0) {\r\n                    uint _toLocked = _pendingReward.mul(_lockRewardPercent).div(100);\r\n                    _pendingReward = _pendingReward.sub(_toLocked);\r\n                    user.lockReward[_pid] = user.lockReward[_pid].add(_toLocked);\r\n                }\r\n                if (block.number > rewardPool.startVestingBlock) {\r\n                    uint _toReleased = user.lockReward[_pid].mul(block.number.sub(rewardPool.startVestingBlock)).div(rewardPool.numOfVestingBlocks);\r\n                    uint _lockRewardReleased = user.lockRewardReleased[_pid];\r\n                    if (_toReleased > _lockRewardReleased) {\r\n                        uint _unlockReward = _toReleased.sub(_lockRewardReleased);\r\n                        user.lockRewardReleased[_pid] = _lockRewardReleased.add(_unlockReward);\r\n                        _pendingReward = _pendingReward.add(_unlockReward);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (_pendingReward > 0) {\r\n            user.accumulatedEarned[_pid] = user.accumulatedEarned[_pid].add(_pendingReward);\r\n            rewardPool.totalPaidRewards = rewardPool.totalPaidRewards.add(_pendingReward);\r\n            rewardFund.safeTransfer(rewardPool.rewardToken, _account, _pendingReward);\r\n            emit RewardPaid(_pid, _account, _pendingReward);\r\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\r\n        }\r\n    }\r\n\r\n    function pendingReward(uint8 _pid, address _account) public override view returns (uint _pending) {\r\n        UserInfo storage user = userInfo[_account];\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\r\n        uint _accRewardPerShare = rewardPool.accRewardPerShare;\r\n        uint lpSupply = balanceOf(address(this));\r\n        uint _endRewardBlockApplicable = block.number > rewardPool.endRewardBlock ? rewardPool.endRewardBlock : block.number;\r\n        if (_endRewardBlockApplicable > rewardPool.lastRewardBlock && lpSupply != 0) {\r\n            uint _numBlocks = _endRewardBlockApplicable.sub(rewardPool.lastRewardBlock);\r\n            uint _incRewardPerShare = _numBlocks.mul(rewardPool.rewardPerBlock).mul(1e18).div(lpSupply);\r\n            _accRewardPerShare = _accRewardPerShare.add(_incRewardPerShare);\r\n        }\r\n        _pending = user.amount.mul(_accRewardPerShare).div(1e18).sub(user.rewardDebt[_pid]);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw() external override {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint _amount = user.amount;\r\n        _pushPoolShare(msg.sender, _amount);\r\n        user.amount = 0;\r\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\r\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\r\n            user.rewardDebt[_pid] = 0;\r\n        }\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    function getUserInfo(uint8 _pid, address _account) public view returns (uint amount, uint rewardDebt, uint accumulatedEarned, uint lockReward, uint lockRewardReleased) {\r\n        UserInfo storage user = userInfo[_account];\r\n        amount = user.amount;\r\n        rewardDebt = user.rewardDebt[_pid];\r\n        accumulatedEarned = user.accumulatedEarned[_pid];\r\n        lockReward = user.lockReward[_pid];\r\n        lockRewardReleased = user.lockRewardReleased[_pid];\r\n    }\r\n\r\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external override _lock_ {\r\n        require(finalized, \"!fnl\");\r\n\r\n        uint rewardTotal = totalSupply();\r\n        uint _exitFee = bmul(poolAmountIn, exitFee);\r\n        uint pAiAfterExitFee = bsub(poolAmountIn, _exitFee);\r\n        uint ratio = bdiv(pAiAfterExitFee, rewardTotal);\r\n        require(ratio != 0, \"erMApr\");\r\n\r\n        uint _externalShares = balanceOf(msg.sender);\r\n        if (_externalShares < poolAmountIn) {\r\n            uint _withdrawShares = bsub(poolAmountIn, _externalShares);\r\n            uint _stakedShares = userInfo[msg.sender].amount;\r\n            require(_stakedShares >= _withdrawShares, \"stk<wdr\");\r\n            withdraw(_withdrawShares);\r\n        }\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        if (_exitFee > 0) {\r\n            _pushPoolShare(factory, _exitFee);\r\n        }\r\n        _burnPoolShare(pAiAfterExitFee);\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint bal = _records[t].balance;\r\n            uint tokenAmountOut = bmul(ratio, bal);\r\n            require(tokenAmountOut != 0, \"erMApr\");\r\n            require(tokenAmountOut >= minAmountsOut[i], \"<limO\");\r\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\r\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\r\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\r\n        }\r\n    }\r\n\r\n    function updateReward() public {\r\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\r\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\r\n            updateReward(_pid);\r\n        }\r\n    }\r\n\r\n    function updateReward(uint8 _pid) public {\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\r\n        uint _endRewardBlockApplicable = block.number > rewardPool.endRewardBlock ? rewardPool.endRewardBlock : block.number;\r\n        if (_endRewardBlockApplicable > rewardPool.lastRewardBlock) {\r\n            uint lpSupply = balanceOf(address(this));\r\n            if (lpSupply > 0) {\r\n                uint _numBlocks = _endRewardBlockApplicable.sub(rewardPool.lastRewardBlock);\r\n                uint _incRewardPerShare = _numBlocks.mul(rewardPool.rewardPerBlock).mul(1e18).div(lpSupply);\r\n                rewardPool.accRewardPerShare = rewardPool.accRewardPerShare.add(_incRewardPerShare);\r\n            }\r\n            rewardPool.lastRewardBlock = _endRewardBlockApplicable;\r\n        }\r\n    }\r\n}"}}}