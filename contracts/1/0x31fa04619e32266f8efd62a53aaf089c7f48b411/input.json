{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Chapel.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n// @title The Underground Sistine Chapel by Pascal Boyart\r\n// @author jolan.eth\r\npragma solidity ^0.8;\r\n\r\nimport \"./IChapel.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\ncontract Chapel is Ownable {\r\n    string public CID;\r\n    string public ContractCID;\r\n    string public symbol = \"CHAPEL\";\r\n    string public name = \"The Underground Sistine Chapel\";\r\n    address public ADDRESS_SIGN = 0x1Af70e564847bE46e4bA286c0b0066Da8372F902;\r\n\r\n    uint256 public maxSupply = 404;\r\n    uint256 public totalSupply = 1;\r\n\r\n    mapping (uint256 => address) owners;\r\n    mapping(address => uint256) balances;\r\n    \r\n    mapping(uint256 => address) approvals;\r\n    mapping(address => mapping(address => bool)) operatorApprovals;\r\n\r\n    mapping(uint256 => address) public snapshot;\r\n\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    constructor() {}\r\n\r\n    function setSnapshot(address[] memory batch)\r\n    public onlyOwner {\r\n        uint256 i = 0;\r\n        uint256 len = batch.length;\r\n        while (i < len)\r\n            snapshot[i] = batch[i++];\r\n    }\r\n\r\n    function batchMintChapel()\r\n    public onlyOwner {\r\n        while (totalSupply <= maxSupply)\r\n            _mint(snapshot[totalSupply], totalSupply++);\r\n    }\r\n\r\n    function setCID(string memory _CID) \r\n    public onlyOwner {\r\n        CID = _CID;\r\n    }\r\n\r\n    function setContractCID(string memory _CID) \r\n    public onlyOwner {\r\n        ContractCID = _CID;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n    public pure returns (bool) {\r\n        return\r\n            interfaceId == 0x80ac58cd ||\r\n            interfaceId == 0x5b5e139f;\r\n    }\r\n\r\n    function balanceOf(address owner)\r\n    public view returns (uint256) {\r\n        require(address(0) != owner, \"error address(0)\");\r\n        return balances[owner];\r\n    }\r\n\r\n    function ownerOf(uint256 id)\r\n    public view returns (address) {\r\n        require(owners[id] != address(0), \"error !exist\");\r\n        return owners[id];\r\n    }\r\n\r\n    function tokenURI(uint256 id)\r\n    public view returns (string memory) {\r\n        require(owners[id] != address(0), \"error !exist\");\r\n        return string(\r\n            abi.encodePacked(\r\n                \"ipfs://\", CID, '/', _toString(id)\r\n            )\r\n        );\r\n    }\r\n\r\n    function contractURI()\r\n    public view returns (string memory) {\r\n        return string(\r\n            abi.encodePacked(\r\n                \"ipfs://\", ContractCID\r\n            )\r\n        );\r\n    }\r\n\r\n    function approve(address to, uint256 id)\r\n    public {\r\n        address owner = owners[id];\r\n        require(to != owner, \"error to\");\r\n        require(\r\n            owner == msg.sender ||\r\n            operatorApprovals[owner][msg.sender],\r\n            \"error owner\"\r\n        );\r\n        approvals[id] = to;\r\n        emit Approval(owner, to, id);\r\n    }\r\n\r\n    function getApproved(uint256 id)\r\n    public view returns (address) {\r\n        require(owners[id] != address(0), \"error !exist\");\r\n        return approvals[id];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved)\r\n    public {\r\n        require(operator != msg.sender, \"error operator\");\r\n        operatorApprovals[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n    public view returns (bool) {\r\n        return operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 id)\r\n    public {\r\n        require(owners[id] != address(0), \"error !exist\");\r\n        address owner = owners[id];\r\n        require(\r\n            msg.sender == owner ||\r\n            msg.sender == approvals[id] ||\r\n            operatorApprovals[owner][msg.sender], \r\n            \"error msg.sender\"\r\n        );\r\n\r\n        _transfer(owner, from, to, id);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data)\r\n    public {\r\n        address owner = owners[id];\r\n        require(\r\n            msg.sender == owner ||\r\n            msg.sender == approvals[id] ||\r\n            operatorApprovals[owner][msg.sender], \r\n            \"error msg.sender\"\r\n        );\r\n        _transfer(owner, from, to, id);\r\n        require(_checkOnERC721Received(from, to, id, data), \"error ERC721Receiver\");\r\n    }\r\n\r\n    function _mint(address to, uint256 id)\r\n    private {\r\n        require(to != address(0), \"error to\");\r\n        require(owners[id] == address(0), \"error owners[id]\");\r\n        emit Transfer(address(0), ADDRESS_SIGN, id);\r\n\r\n        balances[to]++;\r\n        owners[id] = to;\r\n        \r\n        emit Transfer(ADDRESS_SIGN, to, id);\r\n        require(_checkOnERC721Received(address(0), to, id, \"\"), \"error ERC721Receiver\");\r\n    }\r\n\r\n    function _transfer(address owner, address from, address to, uint256 id)\r\n    private {\r\n        require(owner == from, \"errors owners[id]\");\r\n        require(address(0) != to, \"errors address(0)\");\r\n\r\n        approve(address(0), id);\r\n        balances[from]--;\r\n        balances[to]++;\r\n        owners[id] = to;\r\n        \r\n        emit Transfer(from, to, id);\r\n    }\r\n\r\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory _data)\r\n    internal returns (bool) {\r\n        uint256 size;\r\n\r\n        assembly {\r\n            size := extcodesize(to)\r\n        }\r\n\r\n        if (size > 0)\r\n            try IChapel(to).onERC721Received(msg.sender, from, id, _data) returns (bytes4 retval) {\r\n                return retval == IChapel(to).onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) revert(\"error ERC721Receiver\");\r\n                else assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n            }\r\n        else return true;\r\n    }\r\n\r\n    function _toString(uint256 value) private pure returns (string memory) {\r\n        if (value == 0) return \"0\";\r\n\r\n        uint256 digits;\r\n        uint256 tmp = value;\r\n\r\n        while (tmp != 0) {\r\n            digits++;\r\n            tmp /= 10;\r\n        }\r\n\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n\r\n        return string(buffer);\r\n    }\r\n}\r\n"
    },
    "IChapel.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IChapel {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n"
    },
    "Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"error owner()\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"error newOwner\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n"
    }
  }
}