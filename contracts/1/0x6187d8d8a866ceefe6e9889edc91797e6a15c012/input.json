{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/DSA_READ/index.sol":{"content":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface AccountInterface {\n    function isAuth(address user) external view returns (bool);\n    function sheild() external view returns (bool);\n    function version() external view returns (uint);\n}\n\ninterface ListInterface {\n    struct UserLink {\n        uint64 first;\n        uint64 last;\n        uint64 count;\n    }\n\n    struct UserList {\n        uint64 prev;\n        uint64 next;\n    }\n\n    struct AccountLink {\n        address first;\n        address last;\n        uint64 count;\n    }\n\n    struct AccountList {\n        address prev;\n        address next;\n    }\n\n    function accounts() external view returns (uint);\n    function accountID(address) external view returns (uint64);\n    function accountAddr(uint64) external view returns (address);\n    function userLink(address) external view returns (UserLink memory);\n    function userList(address, uint64) external view returns (UserList memory);\n    function accountLink(uint64) external view returns (AccountLink memory);\n    function accountList(uint64, address) external view returns (AccountList memory);\n\n}\n\ninterface IndexInterface {\n    function master() external view returns (address);\n    function list() external view returns (address);\n    function connectors(uint) external view returns (address);\n    function account(uint) external view returns (address);\n    function check(uint) external view returns (address);\n    function versionCount() external view returns (uint);\n}\n\ninterface ConnectorsInterface {\n    struct List {\n        address prev;\n        address next;\n    }\n    function chief(address) external view returns (bool);\n    function connectors(address) external view returns (bool);\n    function staticConnectors(address) external view returns (bool);\n\n    function connectorArray(uint) external view returns (address);\n    function connectorLength() external view returns (uint);\n    function staticConnectorArray(uint) external view returns (address);\n    function staticConnectorLength() external view returns (uint);\n    function connectorCount() external view returns (uint);\n\n    function isConnector(address[] calldata _connectors) external view returns (bool isOk);\n    function isStaticConnector(address[] calldata _connectors) external view returns (bool isOk);\n\n}\n\ninterface ConnectorInterface {\n    function name() external view returns (string memory);\n}\n\ninterface GnosisFactoryInterface {\n    function proxyRuntimeCode() external pure returns (bytes memory);\n}\n\n\ncontract Helpers {\n    address public index;\n    address public list;\n    address public connectors;\n    IndexInterface indexContract;\n    ListInterface listContract;\n    ConnectorsInterface connectorsContract;\n\n    GnosisFactoryInterface gnosisFactoryContract;\n\n    function getContractCode(address _addr) public view returns (bytes memory o_code) {\n        assembly {\n            // retrieve the size of the code, this needs assembly\n            let size := extcodesize(_addr)\n            // allocate output byte array - this could also be done without assembly\n            // by using o_code = new bytes(size)\n            o_code := mload(0x40)\n            // new \"memory end\" including padding\n            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            // store length in memory\n            mstore(o_code, size)\n            // actually retrieve the code, this needs assembly\n            extcodecopy(_addr, add(o_code, 0x20), 0, size)\n        }\n    }\n}\n\ncontract AccountResolver is Helpers {\n\n    function getID(address account) public view returns(uint id){\n        return listContract.accountID(account);\n    }\n\n    function getAccount(uint64 id) public view returns(address account){\n        return listContract.accountAddr(uint64(id));\n    }\n\n    function getAuthorityIDs(address authority) public view returns(uint64[] memory){\n        ListInterface.UserLink memory userLink = listContract.userLink(authority);\n        uint64[] memory IDs = new uint64[](userLink.count);\n        uint64 id = userLink.first;\n        for (uint i = 0; i < userLink.count; i++) {\n            IDs[i] = id;\n            ListInterface.UserList memory userList = listContract.userList(authority, id);\n            id = userList.next;\n        }\n        return IDs;\n    }\n\n    function getAuthorityAccounts(address authority) public view returns(address[] memory){\n        uint64[] memory IDs = getAuthorityIDs(authority);\n        address[] memory accounts = new address[](IDs.length);\n        for (uint i = 0; i < IDs.length; i++) {\n            accounts[i] = getAccount(IDs[i]);\n        }\n        return accounts;\n    }\n\n    function getIDAuthorities(uint id) public view returns(address[] memory){\n        ListInterface.AccountLink memory accountLink = listContract.accountLink(uint64(id));\n        address[] memory authorities = new address[](accountLink.count);\n        address authority = accountLink.first;\n        for (uint i = 0; i < accountLink.count; i++) {\n            authorities[i] = authority;\n            ListInterface.AccountList memory accountList = listContract.accountList(uint64(id), authority);\n            authority = accountList.next;\n        }\n        return authorities;\n    }\n\n    function getAccountAuthorities(address account) public view returns(address[] memory){\n        return getIDAuthorities(getID(account));\n    }\n\n    function getAccountVersions(address[] memory accounts) public view returns(uint[] memory) {\n        uint[] memory versions = new uint[](accounts.length);\n        for (uint i = 0; i < accounts.length; i++) {\n            versions[i] = AccountInterface(accounts[i]).version();\n        }\n        return versions;\n    }\n\n    struct AuthorityData {\n        uint64[] IDs;\n        address[] accounts;\n        uint[] versions;\n    }\n\n    struct AccountData {\n        uint ID;\n        address account;\n        uint version;\n        address[] authorities;\n    }\n\n    function getAuthorityDetails(address authority) public view returns(AuthorityData memory){\n        address[] memory accounts = getAuthorityAccounts(authority);\n        return AuthorityData(\n            getAuthorityIDs(authority),\n            accounts,\n            getAccountVersions(accounts)\n        );\n    }\n\n    function getAccountIdDetails(uint id) public view returns(AccountData memory){\n        address account = getAccount(uint64(id));\n        return AccountData(\n            id,\n            account,\n            AccountInterface(account).version(),\n            getIDAuthorities(id)\n        );\n    }\n\n    function getAccountDetails(address account) public view returns(AccountData memory){\n        uint id = getID(account);\n        return AccountData(\n            id,\n            account,\n            AccountInterface(account).version(),\n            getIDAuthorities(id)\n        );\n    }\n\n    function isShield(address account) public view returns(bool shield) {\n        shield = AccountInterface(account).sheild();\n    }\n\n    struct AuthType {\n        address owner;\n        uint authType;\n    }\n\n    function getAuthorityTypes(address[] memory authorities) public view returns(AuthType[] memory) {\n        bytes memory multiSigCode = gnosisFactoryContract.proxyRuntimeCode();\n        AuthType[] memory types = new AuthType[](authorities.length);\n        for (uint i = 0; i < authorities.length; i++) {\n            bytes memory _contractCode = getContractCode(authorities[i]);\n            if(keccak256(abi.encode(multiSigCode)) == keccak256(abi.encode(_contractCode))) {\n                types[i] = AuthType({\n                    owner: authorities[i],\n                    authType: 1\n                });\n            } else {\n                types[i] = AuthType({\n                    owner: authorities[i],\n                    authType: 0\n                });\n            }\n        }\n        return types;\n    }\n\n    function getAccountAuthoritiesTypes(address account) public view returns(AuthType[] memory) {\n        return getAuthorityTypes(getAccountAuthorities(account));\n    }\n}\n\n\ncontract ConnectorsResolver is AccountResolver {\n    struct ConnectorsData {\n        address connector;\n        uint connectorID;\n        string name;\n    }\n\n    function getEnabledConnectors() public view returns(address[] memory){\n        uint enabledCount = connectorsContract.connectorCount();\n        address[] memory addresses = new address[](enabledCount);\n        uint connectorArrayLength = connectorsContract.connectorLength();\n        uint count;\n        for (uint i = 0; i < connectorArrayLength ; i++) {\n            address connector = connectorsContract.connectorArray(i);\n            if (connectorsContract.connectors(connector)) {\n                addresses[count] = connector;\n                count++;\n            }\n        }\n        return addresses;\n    }\n\n    function getEnabledConnectorsData() public view returns(ConnectorsData[] memory){\n        uint enabledCount = connectorsContract.connectorCount();\n        ConnectorsData[] memory connectorsData = new ConnectorsData[](enabledCount);\n        uint connectorArrayLength = connectorsContract.connectorLength();\n        uint count;\n        for (uint i = 0; i < connectorArrayLength ; i++) {\n            address connector = connectorsContract.connectorArray(i);\n            if (connectorsContract.connectors(connector)) {\n                connectorsData[count] = ConnectorsData(\n                    connector,\n                    i+1,\n                    ConnectorInterface(connector).name()\n                );\n                count++;\n            }\n        }\n        return connectorsData;\n    }\n\n    function getStaticConnectors() public view returns(address[] memory){\n        uint staticLength = connectorsContract.staticConnectorLength();\n        address[] memory staticConnectorArray = new address[](staticLength);\n        for (uint i = 0; i < staticLength ; i++) {\n            staticConnectorArray[i] = connectorsContract.staticConnectorArray(i);\n        }\n        return staticConnectorArray;\n    }\n\n    function getStaticConnectorsData() public view returns(ConnectorsData[] memory){\n        uint staticLength = connectorsContract.staticConnectorLength();\n        ConnectorsData[] memory staticConnectorsData = new ConnectorsData[](staticLength);\n        for (uint i = 0; i < staticLength ; i++) {\n            address staticConnector = connectorsContract.staticConnectorArray(i);\n            staticConnectorsData[i] = ConnectorsData(\n                staticConnector,\n                i+1,\n                ConnectorInterface(staticConnector).name()\n            );\n        }\n        return staticConnectorsData;\n    }\n}\n\n\ncontract InstaDSAResolver is ConnectorsResolver {\n    string public constant name = \"DSA-Resolver-v1.1\";\n    uint public constant version = 1;\n\n    constructor(address _index, address gnosisFactory) public{\n        index = _index;\n        indexContract = IndexInterface(index);\n        list = indexContract.list();\n        listContract = ListInterface(list);\n        connectors = indexContract.connectors(version);\n        connectorsContract = ConnectorsInterface(connectors);\n        gnosisFactoryContract = GnosisFactoryInterface(gnosisFactory);\n    }\n}"}}}