{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{"AmplElasticCRP.sol":{"BalancerSafeMath":"0x5147fd16f4f7bfbc33f9fdcc5b82f945e37fe4d8","RightsManager":"0x2992a06af9b5e156cd6574049d37ad8da52b9e28","SmartPoolManager":"0xa854ecc4d8bf77cad542a04087fc6e0082d43b86"}},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"AmplElasticCRP.sol":{"content":"// @AmpelforthOrg + @BalancerLabs => Elastic smart pool  \r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: configurable-rights-pool/contracts/IBFactory.sol\r\n\r\ninterface IBPool {\r\n    function rebind(address token, uint balance, uint denorm) external;\r\n    function setSwapFee(uint swapFee) external;\r\n    function setPublicSwap(bool publicSwap) external;\r\n    function bind(address token, uint balance, uint denorm) external;\r\n    function unbind(address token) external;\r\n    function gulp(address token) external;\r\n    function isBound(address token) external view returns(bool);\r\n    function getBalance(address token) external view returns (uint);\r\n    function totalSupply() external view returns (uint);\r\n    function getSwapFee() external view returns (uint);\r\n    function isPublicSwap() external view returns (bool);\r\n    function getDenormalizedWeight(address token) external view returns (uint);\r\n    function getTotalDenormalizedWeight() external view returns (uint);\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function EXIT_FEE() external view returns (uint);\r\n\r\n    function calcPoolOutGivenSingleIn(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountIn,\r\n        uint swapFee\r\n    )\r\n        external pure\r\n        returns (uint poolAmountOut);\r\n\r\n    function calcSingleInGivenPoolOut(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint poolAmountOut,\r\n        uint swapFee\r\n    )\r\n        external pure\r\n        returns (uint tokenAmountIn);\r\n\r\n    function calcSingleOutGivenPoolIn(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint poolAmountIn,\r\n        uint swapFee\r\n    )\r\n        external pure\r\n        returns (uint tokenAmountOut);\r\n\r\n    function calcPoolInGivenSingleOut(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountOut,\r\n        uint swapFee\r\n    )\r\n        external pure\r\n        returns (uint poolAmountIn);\r\n\r\n    function getCurrentTokens()\r\n        external view\r\n        returns (address[] memory tokens);\r\n}\r\n\r\ninterface IBFactory {\r\n    function newBPool() external returns (IBPool);\r\n    function setBLabs(address b) external;\r\n    function collect(IBPool pool) external;\r\n    function isBPool(address b) external view returns (bool);\r\n    function getBLabs() external view returns (address);\r\n}\r\n\r\n// File: configurable-rights-pool/libraries/BalancerConstants.sol\r\n\r\n\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Put all the constants in one place\r\n */\r\n\r\nlibrary BalancerConstants {\r\n    // State variables (must be constant in a library)\r\n\r\n    // B \"ONE\" - all math is in the \"realm\" of 10 ** 18;\r\n    // where numeric 1 = 10 ** 18\r\n    uint public constant BONE = 10**18;\r\n    uint public constant MIN_WEIGHT = BONE;\r\n    uint public constant MAX_WEIGHT = BONE * 50;\r\n    uint public constant MAX_TOTAL_WEIGHT = BONE * 50;\r\n    uint public constant MIN_BALANCE = BONE / 10**6;\r\n    uint public constant MAX_BALANCE = BONE * 10**12;\r\n    uint public constant MIN_POOL_SUPPLY = BONE * 100;\r\n    uint public constant MAX_POOL_SUPPLY = BONE * 10**9;\r\n    uint public constant MIN_FEE = BONE / 10**6;\r\n    uint public constant MAX_FEE = BONE / 10;\r\n    // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\r\n    uint public constant EXIT_FEE = 0;\r\n    uint public constant MAX_IN_RATIO = BONE / 2;\r\n    uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\r\n    // Must match BConst.MIN_BOUND_TOKENS and BConst.MAX_BOUND_TOKENS\r\n    uint public constant MIN_ASSET_LIMIT = 2;\r\n    uint public constant MAX_ASSET_LIMIT = 8;\r\n    uint public constant MAX_UINT = uint(-1);\r\n}\r\n\r\n// File: configurable-rights-pool/libraries/BalancerSafeMath.sol\r\n\r\n\r\n\r\n\r\n// Imports\r\n\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title SafeMath - wrap Solidity operators to prevent underflow/overflow\r\n * @dev badd and bsub are basically identical to OpenZeppelin SafeMath; mul/div have extra checks\r\n */\r\nlibrary BalancerSafeMath {\r\n    /**\r\n     * @notice Safe addition\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @dev if we are adding b to a, the resulting sum must be greater than a\r\n     * @return - sum of operands; throws if overflow\r\n     */\r\n    function badd(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned subtraction\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @dev Do a signed subtraction, and check that it produces a positive value\r\n     *      (i.e., a - b is valid if b <= a)\r\n     * @return - a - b; throws if underflow\r\n     */\r\n    function bsub(uint a, uint b) internal pure returns (uint) {\r\n        (uint c, bool negativeResult) = bsubSign(a, b);\r\n        require(!negativeResult, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe signed subtraction\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @dev Do a signed subtraction\r\n     * @return - difference between a and b, and a flag indicating a negative result\r\n     *           (i.e., a - b if a is greater than or equal to b; otherwise b - a)\r\n     */\r\n    function bsubSign(uint a, uint b) internal pure returns (uint, bool) {\r\n        if (b <= a) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Safe multiplication\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @dev Multiply safely (and efficiently), rounding down\r\n     * @return - product of operands; throws if overflow or rounding error\r\n     */\r\n    function bmul(uint a, uint b) internal pure returns (uint) {\r\n        // Gas optimization (see github.com/OpenZeppelin/openzeppelin-contracts/pull/522)\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Standard overflow check: a/a*b=b\r\n        uint c0 = a * b;\r\n        require(c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n\r\n        // Round to 0 if x*y < BONE/2?\r\n        uint c1 = c0 + (BalancerConstants.BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint c2 = c1 / BalancerConstants.BONE;\r\n        return c2;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe division\r\n     * @param dividend - first operand\r\n     * @param divisor - second operand\r\n     * @dev Divide safely (and efficiently), rounding down\r\n     * @return - quotient; throws if overflow or rounding error\r\n     */\r\n    function bdiv(uint dividend, uint divisor) internal pure returns (uint) {\r\n        require(divisor != 0, \"ERR_DIV_ZERO\");\r\n\r\n        // Gas optimization\r\n        if (dividend == 0){\r\n            return 0;\r\n        }\r\n\r\n        uint c0 = dividend * BalancerConstants.BONE;\r\n        require(c0 / dividend == BalancerConstants.BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n\r\n        uint c1 = c0 + (divisor / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n\r\n        uint c2 = c1 / divisor;\r\n        return c2;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned integer modulo\r\n     * @dev Returns the remainder of dividing two unsigned integers.\r\n     *      Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * @param dividend - first operand\r\n     * @param divisor - second operand -- cannot be zero\r\n     * @return - quotient; throws if overflow or rounding error\r\n     */\r\n    function bmod(uint dividend, uint divisor) internal pure returns (uint) {\r\n        require(divisor != 0, \"ERR_MODULO_BY_ZERO\");\r\n\r\n        return dividend % divisor;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned integer max\r\n     * @dev Returns the greater of the two input values\r\n     *\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @return - the maximum of a and b\r\n     */\r\n    function bmax(uint a, uint b) internal pure returns (uint) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned integer min\r\n     * @dev returns b, if b < a; otherwise returns a\r\n     *\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @return - the lesser of the two input values\r\n     */\r\n    function bmin(uint a, uint b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned integer average\r\n     * @dev Guard against (a+b) overflow by dividing each operand separately\r\n     *\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @return - the average of the two values\r\n     */\r\n    function baverage(uint a, uint b) internal pure returns (uint) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n\r\n    /**\r\n     * @notice Babylonian square root implementation\r\n     * @dev (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n     * @param y - operand\r\n     * @return z - the square root result\r\n     */\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        }\r\n        else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\n// File: configurable-rights-pool/interfaces/IERC20.sol\r\n\r\n\r\n\r\n// Interface declarations\r\n\r\n/* solhint-disable func-order */\r\n\r\ninterface IERC20 {\r\n    // Emitted when the allowance of a spender for an owner is set by a call to approve.\r\n    // Value is the new allowance\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    // Emitted when value tokens are moved from one account (from) to another (to).\r\n    // Note that value may be zero\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    // Returns the amount of tokens in existence\r\n    function totalSupply() external view returns (uint);\r\n\r\n    // Returns the amount of tokens owned by account\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    // Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner\r\n    // through transferFrom. This is zero by default\r\n    // This value changes when approve or transferFrom are called\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    // Sets amount as the allowance of spender over the caller’s tokens\r\n    // Returns a boolean value indicating whether the operation succeeded\r\n    // Emits an Approval event.\r\n    function approve(address spender, uint amount) external returns (bool);\r\n\r\n    // Moves amount tokens from the caller’s account to recipient\r\n    // Returns a boolean value indicating whether the operation succeeded\r\n    // Emits a Transfer event.\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n\r\n    // Moves amount tokens from sender to recipient using the allowance mechanism\r\n    // Amount is then deducted from the caller’s allowance\r\n    // Returns a boolean value indicating whether the operation succeeded\r\n    // Emits a Transfer event\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n}\r\n\r\n// File: configurable-rights-pool/contracts/PCToken.sol\r\n\r\n\r\n\r\n// Imports\r\n\r\n\r\n\r\n// Contracts\r\n\r\n/* solhint-disable func-order */\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Highly opinionated token implementation\r\n*/\r\ncontract PCToken is IERC20 {\r\n    using BalancerSafeMath for uint;\r\n\r\n    // State variables\r\n    string public constant NAME = \"Balancer Smart Pool\";\r\n    uint8 public constant DECIMALS = 18;\r\n\r\n    // No leading underscore per naming convention (non-private)\r\n    // Cannot call totalSupply (name conflict)\r\n    // solhint-disable-next-line private-vars-leading-underscore\r\n    uint internal varTotalSupply;\r\n\r\n    mapping(address => uint) private _balance;\r\n    mapping(address => mapping(address => uint)) private _allowance;\r\n\r\n    string private _symbol;\r\n    string private _name;\r\n\r\n    // Event declarations\r\n\r\n    // See definitions above; must be redeclared to be emitted from this contract\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    // Function declarations\r\n\r\n    /**\r\n     * @notice Base token constructor\r\n     * @param tokenSymbol - the token symbol\r\n     */\r\n    constructor (string memory tokenSymbol, string memory tokenName) public {\r\n        _symbol = tokenSymbol;\r\n        _name = tokenName;\r\n    }\r\n\r\n    // External functions\r\n\r\n    /**\r\n     * @notice Getter for allowance: amount spender will be allowed to spend on behalf of owner\r\n     * @param owner - owner of the tokens\r\n     * @param spender - entity allowed to spend the tokens\r\n     * @return uint - remaining amount spender is allowed to transfer\r\n     */\r\n    function allowance(address owner, address spender) external view override returns (uint) {\r\n        return _allowance[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for current account balance\r\n     * @param account - address we're checking the balance of\r\n     * @return uint - token balance in the account\r\n     */\r\n    function balanceOf(address account) external view override returns (uint) {\r\n        return _balance[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Approve owner (sender) to spend a certain amount\r\n     * @dev emits an Approval event\r\n     * @param spender - entity the owner (sender) is approving to spend his tokens\r\n     * @param amount - number of tokens being approved\r\n     * @return bool - result of the approval (will always be true if it doesn't revert)\r\n     */\r\n    function approve(address spender, uint amount) external override returns (bool) {\r\n        /* In addition to the increase/decreaseApproval functions, could\r\n           avoid the \"approval race condition\" by only allowing calls to approve\r\n           when the current approval amount is 0\r\n\r\n           require(_allowance[msg.sender][spender] == 0, \"ERR_RACE_CONDITION\");\r\n\r\n           Some token contracts (e.g., KNC), already revert if you call approve\r\n           on a non-zero allocation. To deal with these, we use the SafeApprove library\r\n           and safeApprove function when adding tokens to the pool.\r\n        */\r\n\r\n        _allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Increase the amount the spender is allowed to spend on behalf of the owner (sender)\r\n     * @dev emits an Approval event\r\n     * @param spender - entity the owner (sender) is approving to spend his tokens\r\n     * @param amount - number of tokens being approved\r\n     * @return bool - result of the approval (will always be true if it doesn't revert)\r\n     */\r\n    function increaseApproval(address spender, uint amount) external returns (bool) {\r\n        _allowance[msg.sender][spender] = BalancerSafeMath.badd(_allowance[msg.sender][spender], amount);\r\n\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Decrease the amount the spender is allowed to spend on behalf of the owner (sender)\r\n     * @dev emits an Approval event\r\n     * @dev If you try to decrease it below the current limit, it's just set to zero (not an error)\r\n     * @param spender - entity the owner (sender) is approving to spend his tokens\r\n     * @param amount - number of tokens being approved\r\n     * @return bool - result of the approval (will always be true if it doesn't revert)\r\n     */\r\n    function decreaseApproval(address spender, uint amount) external returns (bool) {\r\n        uint oldValue = _allowance[msg.sender][spender];\r\n        // Gas optimization - if amount == oldValue (or is larger), set to zero immediately\r\n        if (amount >= oldValue) {\r\n            _allowance[msg.sender][spender] = 0;\r\n        } else {\r\n            _allowance[msg.sender][spender] = BalancerSafeMath.bsub(oldValue, amount);\r\n        }\r\n\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer the given amount from sender (caller) to recipient\r\n     * @dev _move emits a Transfer event if successful\r\n     * @param recipient - entity receiving the tokens\r\n     * @param amount - number of tokens being transferred\r\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\r\n     */\r\n    function transfer(address recipient, uint amount) external override returns (bool) {\r\n        require(recipient != address(0), \"ERR_ZERO_ADDRESS\");\r\n\r\n        _move(msg.sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer the given amount from sender to recipient\r\n     * @dev _move emits a Transfer event if successful; may also emit an Approval event\r\n     * @param sender - entity sending the tokens (must be caller or allowed to spend on behalf of caller)\r\n     * @param recipient - recipient of the tokens\r\n     * @param amount - number of tokens being transferred\r\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\r\n     */\r\n    function transferFrom(address sender, address recipient, uint amount) external override returns (bool) {\r\n        require(recipient != address(0), \"ERR_ZERO_ADDRESS\");\r\n        require(msg.sender == sender || amount <= _allowance[sender][msg.sender], \"ERR_PCTOKEN_BAD_CALLER\");\r\n\r\n        _move(sender, recipient, amount);\r\n\r\n        // memoize for gas optimization\r\n        uint oldAllowance = _allowance[sender][msg.sender];\r\n\r\n        // If the sender is not the caller, adjust the allowance by the amount transferred\r\n        if (msg.sender != sender && oldAllowance != uint(-1)) {\r\n            _allowance[sender][msg.sender] = BalancerSafeMath.bsub(oldAllowance, amount);\r\n\r\n            emit Approval(msg.sender, recipient, _allowance[sender][msg.sender]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // public functions\r\n\r\n    /**\r\n     * @notice Getter for the total supply\r\n     * @dev declared external for gas optimization\r\n     * @return uint - total number of tokens in existence\r\n     */\r\n    function totalSupply() external view override returns (uint) {\r\n        return varTotalSupply;\r\n    }\r\n\r\n    // Public functions\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     *      We allow the user to set this name (as well as the symbol).\r\n     *      Alternatives are 1) A fixed string (original design)\r\n     *                       2) A fixed string plus the user-defined symbol\r\n     *                          return string(abi.encodePacked(NAME, \"-\", _symbol));\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() external pure returns (uint8) {\r\n        return DECIMALS;\r\n    }\r\n\r\n    // internal functions\r\n\r\n    // Mint an amount of new tokens, and add them to the balance (and total supply)\r\n    // Emit a transfer amount from the null address to this contract\r\n    function _mint(uint amount) internal virtual {\r\n        _balance[address(this)] = BalancerSafeMath.badd(_balance[address(this)], amount);\r\n        varTotalSupply = BalancerSafeMath.badd(varTotalSupply, amount);\r\n\r\n        emit Transfer(address(0), address(this), amount);\r\n    }\r\n\r\n    // Burn an amount of new tokens, and subtract them from the balance (and total supply)\r\n    // Emit a transfer amount from this contract to the null address\r\n    function _burn(uint amount) internal virtual {\r\n        // Can't burn more than we have\r\n        // Remove require for gas optimization - bsub will revert on underflow\r\n        // require(_balance[address(this)] >= amount, \"ERR_INSUFFICIENT_BAL\");\r\n\r\n        _balance[address(this)] = BalancerSafeMath.bsub(_balance[address(this)], amount);\r\n        varTotalSupply = BalancerSafeMath.bsub(varTotalSupply, amount);\r\n\r\n        emit Transfer(address(this), address(0), amount);\r\n    }\r\n\r\n    // Transfer tokens from sender to recipient\r\n    // Adjust balances, and emit a Transfer event\r\n    function _move(address sender, address recipient, uint amount) internal virtual {\r\n        // Can't send more than sender has\r\n        // Remove require for gas optimization - bsub will revert on underflow\r\n        // require(_balance[sender] >= amount, \"ERR_INSUFFICIENT_BAL\");\r\n\r\n        _balance[sender] = BalancerSafeMath.bsub(_balance[sender], amount);\r\n        _balance[recipient] = BalancerSafeMath.badd(_balance[recipient], amount);\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    // Transfer from this contract to recipient\r\n    // Emits a transfer event if successful\r\n    function _push(address recipient, uint amount) internal {\r\n        _move(address(this), recipient, amount);\r\n    }\r\n\r\n    // Transfer from recipient to this contract\r\n    // Emits a transfer event if successful\r\n    function _pull(address sender, uint amount) internal {\r\n        _move(sender, address(this), amount);\r\n    }\r\n}\r\n\r\n// File: configurable-rights-pool/contracts/utils/BalancerReentrancyGuard.sol\r\n\r\n\r\n\r\n/**\r\n * @author Balancer Labs (and OpenZeppelin)\r\n * @title Protect against reentrant calls (and also selectively protect view functions)\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {_lock_} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `_lock_` guard, functions marked as\r\n * `_lock_` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `_lock_` entry\r\n * points to them.\r\n *\r\n * Also adds a _lockview_ modifier, which doesn't create a lock, but fails\r\n *   if another _lock_ call is in progress\r\n */\r\ncontract BalancerReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint private constant _NOT_ENTERED = 1;\r\n    uint private constant _ENTERED = 2;\r\n\r\n    uint private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `_lock_` function from another `_lock_`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `_lock_` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier lock() {\r\n        // On the first call to _lock_, _notEntered will be true\r\n        require(_status != _ENTERED, \"ERR_REENTRY\");\r\n\r\n        // Any calls to _lock_ after this point will fail\r\n        _status = _ENTERED;\r\n        _;\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Also add a modifier that doesn't create a lock, but protects functions that\r\n     *      should not be called while a _lock_ function is running\r\n     */\r\n     modifier viewlock() {\r\n        require(_status != _ENTERED, \"ERR_REENTRY_VIEW\");\r\n        _;\r\n     }\r\n}\r\n\r\n// File: configurable-rights-pool/contracts/utils/BalancerOwnable.sol\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract BalancerOwnable {\r\n    // State variables\r\n\r\n    address private _owner;\r\n\r\n    // Event declarations\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // Modifiers\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"ERR_NOT_CONTROLLER\");\r\n        _;\r\n    }\r\n\r\n    // Function declarations\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\r\n     *         Can only be called by the current owner\r\n     * @dev external for gas optimization\r\n     * @param newOwner - address of new owner\r\n     */\r\n    function setController(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"ERR_ZERO_ADDRESS\");\r\n\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of the current owner\r\n     * @dev external for gas optimization\r\n     * @return address - of the owner (AKA controller)\r\n     */\r\n    function getController() external view returns (address) {\r\n        return _owner;\r\n    }\r\n}\r\n\r\n// File: configurable-rights-pool/libraries/RightsManager.sol\r\n\r\n\r\n\r\n// Needed to handle structures externally\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Manage Configurable Rights for the smart pool\r\n *      canPauseSwapping - can setPublicSwap back to false after turning it on\r\n *                         by default, it is off on initialization and can only be turned on\r\n *      canChangeSwapFee - can setSwapFee after initialization (by default, it is fixed at create time)\r\n *      canChangeWeights - can bind new token weights (allowed by default in base pool)\r\n *      canAddRemoveTokens - can bind/unbind tokens (allowed by default in base pool)\r\n *      canWhitelistLPs - can limit liquidity providers to a given set of addresses\r\n *      canChangeCap - can change the BSP cap (max # of pool tokens)\r\n */\r\nlibrary RightsManager {\r\n\r\n    // Type declarations\r\n\r\n    enum Permissions { PAUSE_SWAPPING,\r\n                       CHANGE_SWAP_FEE,\r\n                       CHANGE_WEIGHTS,\r\n                       ADD_REMOVE_TOKENS,\r\n                       WHITELIST_LPS,\r\n                       CHANGE_CAP }\r\n\r\n    struct Rights {\r\n        bool canPauseSwapping;\r\n        bool canChangeSwapFee;\r\n        bool canChangeWeights;\r\n        bool canAddRemoveTokens;\r\n        bool canWhitelistLPs;\r\n        bool canChangeCap;\r\n    }\r\n\r\n    // State variables (can only be constants in a library)\r\n    bool public constant DEFAULT_CAN_PAUSE_SWAPPING = false;\r\n    bool public constant DEFAULT_CAN_CHANGE_SWAP_FEE = true;\r\n    bool public constant DEFAULT_CAN_CHANGE_WEIGHTS = true;\r\n    bool public constant DEFAULT_CAN_ADD_REMOVE_TOKENS = false;\r\n    bool public constant DEFAULT_CAN_WHITELIST_LPS = false;\r\n    bool public constant DEFAULT_CAN_CHANGE_CAP = false;\r\n\r\n    // Functions\r\n\r\n    /**\r\n     * @notice create a struct from an array (or return defaults)\r\n     * @dev If you pass an empty array, it will construct it using the defaults\r\n     * @param a - array input\r\n     * @return Rights struct\r\n     */\r\n    function constructRights(bool[] calldata a) external pure returns (Rights memory) {\r\n        if (a.length == 0) {\r\n            return Rights(DEFAULT_CAN_PAUSE_SWAPPING,\r\n                          DEFAULT_CAN_CHANGE_SWAP_FEE,\r\n                          DEFAULT_CAN_CHANGE_WEIGHTS,\r\n                          DEFAULT_CAN_ADD_REMOVE_TOKENS,\r\n                          DEFAULT_CAN_WHITELIST_LPS,\r\n                          DEFAULT_CAN_CHANGE_CAP);\r\n        }\r\n        else {\r\n            return Rights(a[0], a[1], a[2], a[3], a[4], a[5]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Convert rights struct to an array (e.g., for events, GUI)\r\n     * @dev avoids multiple calls to hasPermission\r\n     * @param rights - the rights struct to convert\r\n     * @return boolean array containing the rights settings\r\n     */\r\n    function convertRights(Rights calldata rights) external pure returns (bool[] memory) {\r\n        bool[] memory result = new bool[](6);\r\n\r\n        result[0] = rights.canPauseSwapping;\r\n        result[1] = rights.canChangeSwapFee;\r\n        result[2] = rights.canChangeWeights;\r\n        result[3] = rights.canAddRemoveTokens;\r\n        result[4] = rights.canWhitelistLPs;\r\n        result[5] = rights.canChangeCap;\r\n\r\n        return result;\r\n    }\r\n\r\n    // Though it is actually simple, the number of branches triggers code-complexity\r\n    /* solhint-disable code-complexity */\r\n\r\n    /**\r\n     * @notice Externally check permissions using the Enum\r\n     * @param self - Rights struct containing the permissions\r\n     * @param permission - The permission to check\r\n     * @return Boolean true if it has the permission\r\n     */\r\n    function hasPermission(Rights calldata self, Permissions permission) external pure returns (bool) {\r\n        if (Permissions.PAUSE_SWAPPING == permission) {\r\n            return self.canPauseSwapping;\r\n        }\r\n        else if (Permissions.CHANGE_SWAP_FEE == permission) {\r\n            return self.canChangeSwapFee;\r\n        }\r\n        else if (Permissions.CHANGE_WEIGHTS == permission) {\r\n            return self.canChangeWeights;\r\n        }\r\n        else if (Permissions.ADD_REMOVE_TOKENS == permission) {\r\n            return self.canAddRemoveTokens;\r\n        }\r\n        else if (Permissions.WHITELIST_LPS == permission) {\r\n            return self.canWhitelistLPs;\r\n        }\r\n        else if (Permissions.CHANGE_CAP == permission) {\r\n            return self.canChangeCap;\r\n        }\r\n    }\r\n\r\n    /* solhint-enable code-complexity */\r\n}\r\n\r\n// File: configurable-rights-pool/interfaces/IConfigurableRightsPool.sol\r\n\r\n\r\n\r\n// Interface declarations\r\n\r\n// Introduce to avoid circularity (otherwise, the CRP and SmartPoolManager include each other)\r\n// Removing circularity allows flattener tools to work, which enables Etherscan verification\r\ninterface IConfigurableRightsPool {\r\n    function mintPoolShareFromLib(uint amount) external;\r\n    function pushPoolShareFromLib(address to, uint amount) external;\r\n    function pullPoolShareFromLib(address from, uint amount) external;\r\n    function burnPoolShareFromLib(uint amount) external;\r\n    function totalSupply() external view returns (uint);\r\n    function getController() external view returns (address);\r\n}\r\n\r\n// File: configurable-rights-pool/libraries/SafeApprove.sol\r\n\r\n\r\n\r\n// Imports\r\n\r\n\r\n// Libraries\r\n\r\n/**\r\n * @author PieDAO (ported to Balancer Labs)\r\n * @title SafeApprove - set approval for tokens that require 0 prior approval\r\n * @dev Perhaps to address the known ERC20 race condition issue\r\n *      See https://github.com/crytic/not-so-smart-contracts/tree/master/race_condition\r\n *      Some tokens - notably KNC - only allow approvals to be increased from 0\r\n */\r\nlibrary SafeApprove {\r\n    /**\r\n     * @notice handle approvals of tokens that require approving from a base of 0\r\n     * @param token - the token we're approving\r\n     * @param spender - entity the owner (sender) is approving to spend his tokens\r\n     * @param amount - number of tokens being approved\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint amount) internal returns (bool) {\r\n        uint currentAllowance = token.allowance(address(this), spender);\r\n\r\n        // Do nothing if allowance is already set to this value\r\n        if(currentAllowance == amount) {\r\n            return true;\r\n        }\r\n\r\n        // If approval is not zero reset it to zero first\r\n        if(currentAllowance != 0) {\r\n            return token.approve(spender, 0);\r\n        }\r\n\r\n        // do the actual approval\r\n        return token.approve(spender, amount);\r\n    }\r\n}\r\n\r\n// File: configurable-rights-pool/libraries/SmartPoolManager.sol\r\n\r\n\r\n\r\n// Needed to pass in structs\r\n\r\n// Imports\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Factor out the weight updates\r\n */\r\nlibrary SmartPoolManager {\r\n    // Type declarations\r\n\r\n    struct NewTokenParams {\r\n        address addr;\r\n        bool isCommitted;\r\n        uint commitBlock;\r\n        uint denorm;\r\n        uint balance;\r\n    }\r\n\r\n    // For blockwise, automated weight updates\r\n    // Move weights linearly from startWeights to endWeights,\r\n    // between startBlock and endBlock\r\n    struct GradualUpdateParams {\r\n        uint startBlock;\r\n        uint endBlock;\r\n        uint[] startWeights;\r\n        uint[] endWeights;\r\n    }\r\n\r\n    // updateWeight and pokeWeights are unavoidably long\r\n    /* solhint-disable function-max-lines */\r\n\r\n    /**\r\n     * @notice Update the weight of an existing token\r\n     * @dev Refactored to library to make CRPFactory deployable\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param token - token to be reweighted\r\n     * @param newWeight - new weight of the token\r\n    */\r\n    function updateWeight(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address token,\r\n        uint newWeight\r\n    )\r\n        external\r\n    {\r\n        require(newWeight >= BalancerConstants.MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\r\n        require(newWeight <= BalancerConstants.MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\r\n\r\n        uint currentWeight = bPool.getDenormalizedWeight(token);\r\n        // Save gas; return immediately on NOOP\r\n        if (currentWeight == newWeight) {\r\n             return;\r\n        }\r\n\r\n        uint currentBalance = bPool.getBalance(token);\r\n        uint totalSupply = self.totalSupply();\r\n        uint totalWeight = bPool.getTotalDenormalizedWeight();\r\n        uint poolShares;\r\n        uint deltaBalance;\r\n        uint deltaWeight;\r\n        uint newBalance;\r\n\r\n        if (newWeight < currentWeight) {\r\n            // This means the controller will withdraw tokens to keep price\r\n            // So they need to redeem PCTokens\r\n            deltaWeight = BalancerSafeMath.bsub(currentWeight, newWeight);\r\n\r\n            // poolShares = totalSupply * (deltaWeight / totalWeight)\r\n            poolShares = BalancerSafeMath.bmul(totalSupply,\r\n                                               BalancerSafeMath.bdiv(deltaWeight, totalWeight));\r\n\r\n            // deltaBalance = currentBalance * (deltaWeight / currentWeight)\r\n            deltaBalance = BalancerSafeMath.bmul(currentBalance,\r\n                                                 BalancerSafeMath.bdiv(deltaWeight, currentWeight));\r\n\r\n            // New balance cannot be lower than MIN_BALANCE\r\n            newBalance = BalancerSafeMath.bsub(currentBalance, deltaBalance);\r\n\r\n            require(newBalance >= BalancerConstants.MIN_BALANCE, \"ERR_MIN_BALANCE\");\r\n\r\n            // First get the tokens from this contract (Pool Controller) to msg.sender\r\n            bPool.rebind(token, newBalance, newWeight);\r\n\r\n            // Now with the tokens this contract can send them to msg.sender\r\n            bool xfer = IERC20(token).transfer(msg.sender, deltaBalance);\r\n            require(xfer, \"ERR_ERC20_FALSE\");\r\n\r\n            self.pullPoolShareFromLib(msg.sender, poolShares);\r\n            self.burnPoolShareFromLib(poolShares);\r\n        }\r\n        else {\r\n            // This means the controller will deposit tokens to keep the price.\r\n            // They will be minted and given PCTokens\r\n            deltaWeight = BalancerSafeMath.bsub(newWeight, currentWeight);\r\n\r\n            require(BalancerSafeMath.badd(totalWeight, deltaWeight) <= BalancerConstants.MAX_TOTAL_WEIGHT,\r\n                    \"ERR_MAX_TOTAL_WEIGHT\");\r\n\r\n            // poolShares = totalSupply * (deltaWeight / totalWeight)\r\n            poolShares = BalancerSafeMath.bmul(totalSupply,\r\n                                               BalancerSafeMath.bdiv(deltaWeight, totalWeight));\r\n            // deltaBalance = currentBalance * (deltaWeight / currentWeight)\r\n            deltaBalance = BalancerSafeMath.bmul(currentBalance,\r\n                                                 BalancerSafeMath.bdiv(deltaWeight, currentWeight));\r\n\r\n            // First gets the tokens from msg.sender to this contract (Pool Controller)\r\n            bool xfer = IERC20(token).transferFrom(msg.sender, address(this), deltaBalance);\r\n            require(xfer, \"ERR_ERC20_FALSE\");\r\n\r\n            // Now with the tokens this contract can bind them to the pool it controls\r\n            bPool.rebind(token, BalancerSafeMath.badd(currentBalance, deltaBalance), newWeight);\r\n\r\n            self.mintPoolShareFromLib(poolShares);\r\n            self.pushPoolShareFromLib(msg.sender, poolShares);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice External function called to make the contract update weights according to plan\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param gradualUpdate - gradual update parameters from the CRP\r\n    */\r\n    function pokeWeights(\r\n        IBPool bPool,\r\n        GradualUpdateParams storage gradualUpdate\r\n    )\r\n        external\r\n    {\r\n        // Do nothing if we call this when there is no update plan\r\n        if (gradualUpdate.startBlock == 0) {\r\n            return;\r\n        }\r\n\r\n        // Error to call it before the start of the plan\r\n        require(block.number >= gradualUpdate.startBlock, \"ERR_CANT_POKE_YET\");\r\n        // Proposed error message improvement\r\n        // require(block.number >= startBlock, \"ERR_NO_HOKEY_POKEY\");\r\n\r\n        // This allows for pokes after endBlock that get weights to endWeights\r\n        // Get the current block (or the endBlock, if we're already past the end)\r\n        uint currentBlock;\r\n        if (block.number > gradualUpdate.endBlock) {\r\n            currentBlock = gradualUpdate.endBlock;\r\n        }\r\n        else {\r\n            currentBlock = block.number;\r\n        }\r\n\r\n        uint blockPeriod = BalancerSafeMath.bsub(gradualUpdate.endBlock, gradualUpdate.startBlock);\r\n        uint blocksElapsed = BalancerSafeMath.bsub(currentBlock, gradualUpdate.startBlock);\r\n        uint weightDelta;\r\n        uint deltaPerBlock;\r\n        uint newWeight;\r\n\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        // This loop contains external calls\r\n        // External calls are to math libraries or the underlying pool, so low risk\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            // Make sure it does nothing if the new and old weights are the same (saves gas)\r\n            // It's a degenerate case if they're *all* the same, but you certainly could have\r\n            // a plan where you only change some of the weights in the set\r\n            if (gradualUpdate.startWeights[i] != gradualUpdate.endWeights[i]) {\r\n                if (gradualUpdate.endWeights[i] < gradualUpdate.startWeights[i]) {\r\n                    // We are decreasing the weight\r\n\r\n                    // First get the total weight delta\r\n                    weightDelta = BalancerSafeMath.bsub(gradualUpdate.startWeights[i],\r\n                                                        gradualUpdate.endWeights[i]);\r\n                    // And the amount it should change per block = total change/number of blocks in the period\r\n                    deltaPerBlock = BalancerSafeMath.bdiv(weightDelta, blockPeriod);\r\n                    //deltaPerBlock = bdivx(weightDelta, blockPeriod);\r\n\r\n                     // newWeight = startWeight - (blocksElapsed * deltaPerBlock)\r\n                    newWeight = BalancerSafeMath.bsub(gradualUpdate.startWeights[i],\r\n                                                      BalancerSafeMath.bmul(blocksElapsed, deltaPerBlock));\r\n                }\r\n                else {\r\n                    // We are increasing the weight\r\n\r\n                    // First get the total weight delta\r\n                    weightDelta = BalancerSafeMath.bsub(gradualUpdate.endWeights[i],\r\n                                                        gradualUpdate.startWeights[i]);\r\n                    // And the amount it should change per block = total change/number of blocks in the period\r\n                    deltaPerBlock = BalancerSafeMath.bdiv(weightDelta, blockPeriod);\r\n                    //deltaPerBlock = bdivx(weightDelta, blockPeriod);\r\n\r\n                     // newWeight = startWeight + (blocksElapsed * deltaPerBlock)\r\n                    newWeight = BalancerSafeMath.badd(gradualUpdate.startWeights[i],\r\n                                                      BalancerSafeMath.bmul(blocksElapsed, deltaPerBlock));\r\n                }\r\n\r\n                uint bal = bPool.getBalance(tokens[i]);\r\n\r\n                bPool.rebind(tokens[i], bal, newWeight);\r\n            }\r\n        }\r\n\r\n        // Reset to allow add/remove tokens, or manual weight updates\r\n        if (block.number >= gradualUpdate.endBlock) {\r\n            gradualUpdate.startBlock = 0;\r\n        }\r\n    }\r\n\r\n    /* solhint-enable function-max-lines */\r\n\r\n    /**\r\n     * @notice Schedule (commit) a token to be added; must call applyAddToken after a fixed\r\n     *         number of blocks to actually add the token\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param token - the token to be added\r\n     * @param balance - how much to be added\r\n     * @param denormalizedWeight - the desired token weight\r\n     * @param newToken - NewTokenParams struct used to hold the token data (in CRP storage)\r\n     */\r\n    function commitAddToken(\r\n        IBPool bPool,\r\n        address token,\r\n        uint balance,\r\n        uint denormalizedWeight,\r\n        NewTokenParams storage newToken\r\n    )\r\n        external\r\n    {\r\n        require(!bPool.isBound(token), \"ERR_IS_BOUND\");\r\n\r\n        require(denormalizedWeight <= BalancerConstants.MAX_WEIGHT, \"ERR_WEIGHT_ABOVE_MAX\");\r\n        require(denormalizedWeight >= BalancerConstants.MIN_WEIGHT, \"ERR_WEIGHT_BELOW_MIN\");\r\n        require(BalancerSafeMath.badd(bPool.getTotalDenormalizedWeight(),\r\n                                      denormalizedWeight) <= BalancerConstants.MAX_TOTAL_WEIGHT,\r\n                \"ERR_MAX_TOTAL_WEIGHT\");\r\n        require(balance >= BalancerConstants.MIN_BALANCE, \"ERR_BALANCE_BELOW_MIN\");\r\n\r\n        newToken.addr = token;\r\n        newToken.balance = balance;\r\n        newToken.denorm = denormalizedWeight;\r\n        newToken.commitBlock = block.number;\r\n        newToken.isCommitted = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the token previously committed (in commitAddToken) to the pool\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param addTokenTimeLockInBlocks -  Wait time between committing and applying a new token\r\n     * @param newToken - NewTokenParams struct used to hold the token data (in CRP storage)\r\n     */\r\n    function applyAddToken(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        uint addTokenTimeLockInBlocks,\r\n        NewTokenParams storage newToken\r\n    )\r\n        external\r\n    {\r\n        require(newToken.isCommitted, \"ERR_NO_TOKEN_COMMIT\");\r\n        require(BalancerSafeMath.bsub(block.number, newToken.commitBlock) >= addTokenTimeLockInBlocks,\r\n                                      \"ERR_TIMELOCK_STILL_COUNTING\");\r\n\r\n        uint totalSupply = self.totalSupply();\r\n\r\n        // poolShares = totalSupply * newTokenWeight / totalWeight\r\n        uint poolShares = BalancerSafeMath.bdiv(BalancerSafeMath.bmul(totalSupply, newToken.denorm),\r\n                                                bPool.getTotalDenormalizedWeight());\r\n\r\n        // Clear this to allow adding more tokens\r\n        newToken.isCommitted = false;\r\n\r\n        // First gets the tokens from msg.sender to this contract (Pool Controller)\r\n        bool returnValue = IERC20(newToken.addr).transferFrom(self.getController(), address(self), newToken.balance);\r\n        require(returnValue, \"ERR_ERC20_FALSE\");\r\n\r\n        // Now with the tokens this contract can bind them to the pool it controls\r\n        // Approves bPool to pull from this controller\r\n        // Approve unlimited, same as when creating the pool, so they can join pools later\r\n        returnValue = SafeApprove.safeApprove(IERC20(newToken.addr), address(bPool), BalancerConstants.MAX_UINT);\r\n        require(returnValue, \"ERR_ERC20_FALSE\");\r\n\r\n        bPool.bind(newToken.addr, newToken.balance, newToken.denorm);\r\n\r\n        self.mintPoolShareFromLib(poolShares);\r\n        self.pushPoolShareFromLib(msg.sender, poolShares);\r\n    }\r\n\r\n     /**\r\n     * @notice Remove a token from the pool\r\n     * @dev Logic in the CRP controls when ths can be called. There are two related permissions:\r\n     *      AddRemoveTokens - which allows removing down to the underlying BPool limit of two\r\n     *      RemoveAllTokens - which allows completely draining the pool by removing all tokens\r\n     *                        This can result in a non-viable pool with 0 or 1 tokens (by design),\r\n     *                        meaning all swapping or binding operations would fail in this state\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param token - token to remove\r\n     */\r\n    function removeToken(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address token\r\n    )\r\n        external\r\n    {\r\n        uint totalSupply = self.totalSupply();\r\n\r\n        // poolShares = totalSupply * tokenWeight / totalWeight\r\n        uint poolShares = BalancerSafeMath.bdiv(BalancerSafeMath.bmul(totalSupply,\r\n                                                                      bPool.getDenormalizedWeight(token)),\r\n                                                bPool.getTotalDenormalizedWeight());\r\n\r\n        // this is what will be unbound from the pool\r\n        // Have to get it before unbinding\r\n        uint balance = bPool.getBalance(token);\r\n\r\n        // Unbind and get the tokens out of balancer pool\r\n        bPool.unbind(token);\r\n\r\n        // Now with the tokens this contract can send them to msg.sender\r\n        bool xfer = IERC20(token).transfer(self.getController(), balance);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n\r\n        self.pullPoolShareFromLib(self.getController(), poolShares);\r\n        self.burnPoolShareFromLib(poolShares);\r\n    }\r\n\r\n    /**\r\n     * @notice Non ERC20-conforming tokens are problematic; don't allow them in pools\r\n     * @dev Will revert if invalid\r\n     * @param token - The prospective token to verify\r\n     */\r\n    function verifyTokenCompliance(address token) external {\r\n        verifyTokenComplianceInternal(token);\r\n    }\r\n\r\n    /**\r\n     * @notice Non ERC20-conforming tokens are problematic; don't allow them in pools\r\n     * @dev Will revert if invalid - overloaded to save space in the main contract\r\n     * @param tokens - The prospective tokens to verify\r\n     */\r\n    function verifyTokenCompliance(address[] calldata tokens) external {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            verifyTokenComplianceInternal(tokens[i]);\r\n         }\r\n    }\r\n\r\n    /**\r\n     * @notice Update weights in a predetermined way, between startBlock and endBlock,\r\n     *         through external cals to pokeWeights\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param newWeights - final weights we want to get to\r\n     * @param startBlock - when weights should start to change\r\n     * @param endBlock - when weights will be at their final values\r\n     * @param minimumWeightChangeBlockPeriod - needed to validate the block period\r\n    */\r\n    function updateWeightsGradually(\r\n        IBPool bPool,\r\n        GradualUpdateParams storage gradualUpdate,\r\n        uint[] calldata newWeights,\r\n        uint startBlock,\r\n        uint endBlock,\r\n        uint minimumWeightChangeBlockPeriod\r\n    )\r\n        external\r\n    {\r\n        // Enforce a minimum time over which to make the changes\r\n        // The also prevents endBlock <= startBlock\r\n        require(BalancerSafeMath.bsub(endBlock, startBlock) >= minimumWeightChangeBlockPeriod,\r\n                \"ERR_WEIGHT_CHANGE_TIME_BELOW_MIN\");\r\n        require(block.number < endBlock, \"ERR_GRADUAL_UPDATE_TIME_TRAVEL\");\r\n\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        // Must specify weights for all tokens\r\n        require(newWeights.length == tokens.length, \"ERR_START_WEIGHTS_MISMATCH\");\r\n\r\n        uint weightsSum = 0;\r\n        gradualUpdate.startWeights = new uint[](tokens.length);\r\n\r\n        // Check that endWeights are valid now to avoid reverting in a future pokeWeights call\r\n        //\r\n        // This loop contains external calls\r\n        // External calls are to math libraries or the underlying pool, so low risk\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            require(newWeights[i] <= BalancerConstants.MAX_WEIGHT, \"ERR_WEIGHT_ABOVE_MAX\");\r\n            require(newWeights[i] >= BalancerConstants.MIN_WEIGHT, \"ERR_WEIGHT_BELOW_MIN\");\r\n\r\n            weightsSum = BalancerSafeMath.badd(weightsSum, newWeights[i]);\r\n            gradualUpdate.startWeights[i] = bPool.getDenormalizedWeight(tokens[i]);\r\n        }\r\n        require(weightsSum <= BalancerConstants.MAX_TOTAL_WEIGHT, \"ERR_MAX_TOTAL_WEIGHT\");\r\n\r\n        if (block.number > startBlock && block.number < endBlock) {\r\n            // This means the weight update should start ASAP\r\n            // Moving the start block up prevents a big jump/discontinuity in the weights\r\n            //\r\n            // Only valid within the startBlock - endBlock period!\r\n            // Should not happen, but defensively check that we aren't\r\n            // setting the start point past the end point\r\n            gradualUpdate.startBlock = block.number;\r\n        }\r\n        else{\r\n            gradualUpdate.startBlock = startBlock;\r\n        }\r\n\r\n        gradualUpdate.endBlock = endBlock;\r\n        gradualUpdate.endWeights = newWeights;\r\n    }\r\n\r\n    /**\r\n     * @notice Join a pool\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param poolAmountOut - number of pool tokens to receive\r\n     * @param maxAmountsIn - Max amount of asset tokens to spend\r\n     * @return actualAmountsIn - calculated values of the tokens to pull in\r\n     */\r\n    function joinPool(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        uint poolAmountOut,\r\n        uint[] calldata maxAmountsIn\r\n    )\r\n         external\r\n         view\r\n         returns (uint[] memory actualAmountsIn)\r\n    {\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        require(maxAmountsIn.length == tokens.length, \"ERR_AMOUNTS_MISMATCH\");\r\n\r\n        uint poolTotal = self.totalSupply();\r\n        // Subtract  1 to ensure any rounding errors favor the pool\r\n        uint ratio = BalancerSafeMath.bdiv(poolAmountOut,\r\n                                           BalancerSafeMath.bsub(poolTotal, 1));\r\n\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        // We know the length of the array; initialize it, and fill it below\r\n        // Cannot do \"push\" in memory\r\n        actualAmountsIn = new uint[](tokens.length);\r\n\r\n        // This loop contains external calls\r\n        // External calls are to math libraries or the underlying pool, so low risk\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address t = tokens[i];\r\n            uint bal = bPool.getBalance(t);\r\n            // Add 1 to ensure any rounding errors favor the pool\r\n            uint tokenAmountIn = BalancerSafeMath.bmul(ratio,\r\n                                                       BalancerSafeMath.badd(bal, 1));\r\n\r\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\r\n\r\n            actualAmountsIn[i] = tokenAmountIn;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem pool tokens for underlying assets\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param poolAmountIn - amount of pool tokens to redeem\r\n     * @param minAmountsOut - minimum amount of asset tokens to receive\r\n     * @return exitFee - calculated exit fee\r\n     * @return pAiAfterExitFee - final amount in (after accounting for exit fee)\r\n     * @return actualAmountsOut - calculated amounts of each token to pull\r\n     */\r\n    function exitPool(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        uint poolAmountIn,\r\n        uint[] calldata minAmountsOut\r\n    )\r\n        external\r\n        view\r\n        returns (uint exitFee, uint pAiAfterExitFee, uint[] memory actualAmountsOut)\r\n    {\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        require(minAmountsOut.length == tokens.length, \"ERR_AMOUNTS_MISMATCH\");\r\n\r\n        uint poolTotal = self.totalSupply();\r\n\r\n        // Calculate exit fee and the final amount in\r\n        exitFee = BalancerSafeMath.bmul(poolAmountIn, BalancerConstants.EXIT_FEE);\r\n        pAiAfterExitFee = BalancerSafeMath.bsub(poolAmountIn, exitFee);\r\n\r\n        uint ratio = BalancerSafeMath.bdiv(pAiAfterExitFee,\r\n                                           BalancerSafeMath.badd(poolTotal, 1));\r\n\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        actualAmountsOut = new uint[](tokens.length);\r\n\r\n        // This loop contains external calls\r\n        // External calls are to math libraries or the underlying pool, so low risk\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address t = tokens[i];\r\n            uint bal = bPool.getBalance(t);\r\n            // Subtract 1 to ensure any rounding errors favor the pool\r\n            uint tokenAmountOut = BalancerSafeMath.bmul(ratio,\r\n                                                        BalancerSafeMath.bsub(bal, 1));\r\n\r\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\r\n\r\n            actualAmountsOut[i] = tokenAmountOut;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Join by swapping a fixed amount of an external token in (must be present in the pool)\r\n     *         System calculates the pool token amount\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param tokenIn - which token we're transferring in\r\n     * @param tokenAmountIn - amount of deposit\r\n     * @param minPoolAmountOut - minimum of pool tokens to receive\r\n     * @return poolAmountOut - amount of pool tokens minted and transferred\r\n     */\r\n    function joinswapExternAmountIn(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address tokenIn,\r\n        uint tokenAmountIn,\r\n        uint minPoolAmountOut\r\n    )\r\n        external\r\n        view\r\n        returns (uint poolAmountOut)\r\n    {\r\n        require(bPool.isBound(tokenIn), \"ERR_NOT_BOUND\");\r\n        require(tokenAmountIn <= BalancerSafeMath.bmul(bPool.getBalance(tokenIn),\r\n                                                       BalancerConstants.MAX_IN_RATIO),\r\n                                                       \"ERR_MAX_IN_RATIO\");\r\n\r\n        poolAmountOut = bPool.calcPoolOutGivenSingleIn(\r\n                            bPool.getBalance(tokenIn),\r\n                            bPool.getDenormalizedWeight(tokenIn),\r\n                            self.totalSupply(),\r\n                            bPool.getTotalDenormalizedWeight(),\r\n                            tokenAmountIn,\r\n                            bPool.getSwapFee()\r\n                        );\r\n\r\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\r\n    }\r\n\r\n    /**\r\n     * @notice Join by swapping an external token in (must be present in the pool)\r\n     *         To receive an exact amount of pool tokens out. System calculates the deposit amount\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param tokenIn - which token we're transferring in (system calculates amount required)\r\n     * @param poolAmountOut - amount of pool tokens to be received\r\n     * @param maxAmountIn - Maximum asset tokens that can be pulled to pay for the pool tokens\r\n     * @return tokenAmountIn - amount of asset tokens transferred in to purchase the pool tokens\r\n     */\r\n    function joinswapPoolAmountOut(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address tokenIn,\r\n        uint poolAmountOut,\r\n        uint maxAmountIn\r\n    )\r\n        external\r\n        view\r\n        returns (uint tokenAmountIn)\r\n    {\r\n        require(bPool.isBound(tokenIn), \"ERR_NOT_BOUND\");\r\n\r\n        tokenAmountIn = bPool.calcSingleInGivenPoolOut(\r\n                            bPool.getBalance(tokenIn),\r\n                            bPool.getDenormalizedWeight(tokenIn),\r\n                            self.totalSupply(),\r\n                            bPool.getTotalDenormalizedWeight(),\r\n                            poolAmountOut,\r\n                            bPool.getSwapFee()\r\n                        );\r\n\r\n        require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        require(tokenAmountIn <= BalancerSafeMath.bmul(bPool.getBalance(tokenIn),\r\n                                                       BalancerConstants.MAX_IN_RATIO),\r\n                                                       \"ERR_MAX_IN_RATIO\");\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem a specific number of pool tokens for an underlying asset\r\n     *         Asset must be present in the pool, and will incur an EXIT_FEE (if set to non-zero)\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param tokenOut - which token the caller wants to receive\r\n     * @param poolAmountIn - amount of pool tokens to redeem\r\n     * @param minAmountOut - minimum asset tokens to receive\r\n     * @return exitFee - calculated exit fee\r\n     * @return tokenAmountOut - amount of asset tokens returned\r\n     */\r\n    function exitswapPoolAmountIn(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address tokenOut,\r\n        uint poolAmountIn,\r\n        uint minAmountOut\r\n    )\r\n        external\r\n        view\r\n        returns (uint exitFee, uint tokenAmountOut)\r\n    {\r\n        require(bPool.isBound(tokenOut), \"ERR_NOT_BOUND\");\r\n\r\n        tokenAmountOut = bPool.calcSingleOutGivenPoolIn(\r\n                            bPool.getBalance(tokenOut),\r\n                            bPool.getDenormalizedWeight(tokenOut),\r\n                            self.totalSupply(),\r\n                            bPool.getTotalDenormalizedWeight(),\r\n                            poolAmountIn,\r\n                            bPool.getSwapFee()\r\n                        );\r\n\r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n        require(tokenAmountOut <= BalancerSafeMath.bmul(bPool.getBalance(tokenOut),\r\n                                                        BalancerConstants.MAX_OUT_RATIO),\r\n                                                        \"ERR_MAX_OUT_RATIO\");\r\n\r\n        exitFee = BalancerSafeMath.bmul(poolAmountIn, BalancerConstants.EXIT_FEE);\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem pool tokens for a specific amount of underlying assets\r\n     *         Asset must be present in the pool\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param tokenOut - which token the caller wants to receive\r\n     * @param tokenAmountOut - amount of underlying asset tokens to receive\r\n     * @param maxPoolAmountIn - maximum pool tokens to be redeemed\r\n     * @return exitFee - calculated exit fee\r\n     * @return poolAmountIn - amount of pool tokens redeemed\r\n     */\r\n    function exitswapExternAmountOut(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address tokenOut,\r\n        uint tokenAmountOut,\r\n        uint maxPoolAmountIn\r\n    )\r\n        external\r\n        view\r\n        returns (uint exitFee, uint poolAmountIn)\r\n    {\r\n        require(bPool.isBound(tokenOut), \"ERR_NOT_BOUND\");\r\n        require(tokenAmountOut <= BalancerSafeMath.bmul(bPool.getBalance(tokenOut),\r\n                                                        BalancerConstants.MAX_OUT_RATIO),\r\n                                                        \"ERR_MAX_OUT_RATIO\");\r\n        poolAmountIn = bPool.calcPoolInGivenSingleOut(\r\n                            bPool.getBalance(tokenOut),\r\n                            bPool.getDenormalizedWeight(tokenOut),\r\n                            self.totalSupply(),\r\n                            bPool.getTotalDenormalizedWeight(),\r\n                            tokenAmountOut,\r\n                            bPool.getSwapFee()\r\n                        );\r\n\r\n        require(poolAmountIn != 0, \"ERR_MATH_APPROX\");\r\n        require(poolAmountIn <= maxPoolAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        exitFee = BalancerSafeMath.bmul(poolAmountIn, BalancerConstants.EXIT_FEE);\r\n    }\r\n\r\n    // Internal functions\r\n\r\n    // Check for zero transfer, and make sure it returns true to returnValue\r\n    function verifyTokenComplianceInternal(address token) internal {\r\n        bool returnValue = IERC20(token).transfer(msg.sender, 0);\r\n        require(returnValue, \"ERR_NONCONFORMING_TOKEN\");\r\n    }\r\n}\r\n\r\n// File: configurable-rights-pool/contracts/ConfigurableRightsPool.sol\r\n\r\n\r\n\r\n// Needed to handle structures externally\r\n\r\n// Imports\r\n\r\n\r\n\r\n\r\n\r\n// Interfaces\r\n\r\n// Libraries\r\n\r\n\r\n\r\n\r\n// Contracts\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Smart Pool with customizable features\r\n * @notice PCToken is the \"Balancer Smart Pool\" token (transferred upon finalization)\r\n * @dev Rights are defined as follows (index values into the array)\r\n *      0: canPauseSwapping - can setPublicSwap back to false after turning it on\r\n *                            by default, it is off on initialization and can only be turned on\r\n *      1: canChangeSwapFee - can setSwapFee after initialization (by default, it is fixed at create time)\r\n *      2: canChangeWeights - can bind new token weights (allowed by default in base pool)\r\n *      3: canAddRemoveTokens - can bind/unbind tokens (allowed by default in base pool)\r\n *      4: canWhitelistLPs - can restrict LPs to a whitelist\r\n *      5: canChangeCap - can change the BSP cap (max # of pool tokens)\r\n *\r\n * Note that functions called on bPool and bFactory may look like internal calls,\r\n *   but since they are contracts accessed through an interface, they are really external.\r\n * To make this explicit, we could write \"IBPool(address(bPool)).function()\" everywhere,\r\n *   instead of \"bPool.function()\".\r\n */\r\ncontract ConfigurableRightsPool is PCToken, BalancerOwnable, BalancerReentrancyGuard {\r\n    using BalancerSafeMath for uint;\r\n    using SafeApprove for IERC20;\r\n\r\n    // Type declarations\r\n\r\n    struct PoolParams {\r\n        // Balancer Pool Token (representing shares of the pool)\r\n        string poolTokenSymbol;\r\n        string poolTokenName;\r\n        // Tokens inside the Pool\r\n        address[] constituentTokens;\r\n        uint[] tokenBalances;\r\n        uint[] tokenWeights;\r\n        uint swapFee;\r\n    }\r\n\r\n    // State variables\r\n\r\n    IBFactory public bFactory;\r\n    IBPool public bPool;\r\n\r\n    // Struct holding the rights configuration\r\n    RightsManager.Rights public rights;\r\n\r\n    // Hold the parameters used in updateWeightsGradually\r\n    SmartPoolManager.GradualUpdateParams public gradualUpdate;\r\n\r\n    // This is for adding a new (currently unbound) token to the pool\r\n    // It's a two-step process: commitAddToken(), then applyAddToken()\r\n    SmartPoolManager.NewTokenParams public newToken;\r\n\r\n    // Fee is initialized on creation, and can be changed if permission is set\r\n    // Only needed for temporary storage between construction and createPool\r\n    // Thereafter, the swap fee should always be read from the underlying pool\r\n    uint private _initialSwapFee;\r\n\r\n    // Store the list of tokens in the pool, and balances\r\n    // NOTE that the token list is *only* used to store the pool tokens between\r\n    //   construction and createPool - thereafter, use the underlying BPool's list\r\n    //   (avoids synchronization issues)\r\n    address[] private _initialTokens;\r\n    uint[] private _initialBalances;\r\n\r\n    // Enforce a minimum time between the start and end blocks\r\n    uint public minimumWeightChangeBlockPeriod;\r\n    // Enforce a mandatory wait time between updates\r\n    // This is also the wait time between committing and applying a new token\r\n    uint public addTokenTimeLockInBlocks;\r\n\r\n    // Whitelist of LPs (if configured)\r\n    mapping(address => bool) private _liquidityProviderWhitelist;\r\n\r\n    // Cap on the pool size (i.e., # of tokens minted when joining)\r\n    // Limits the risk of experimental pools; failsafe/backup for fixed-size pools\r\n    uint public bspCap;\r\n\r\n    // Event declarations\r\n\r\n    // Anonymous logger event - can only be filtered by contract address\r\n\r\n    event LogCall(\r\n        bytes4  indexed sig,\r\n        address indexed caller,\r\n        bytes data\r\n    ) anonymous;\r\n\r\n    event LogJoin(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        uint tokenAmountIn\r\n    );\r\n\r\n    event LogExit(\r\n        address indexed caller,\r\n        address indexed tokenOut,\r\n        uint tokenAmountOut\r\n    );\r\n\r\n    event CapChanged(\r\n        address indexed caller,\r\n        uint oldCap,\r\n        uint newCap\r\n    );\r\n\r\n    event NewTokenCommitted(\r\n        address indexed token,\r\n        address indexed pool,\r\n        address indexed caller\r\n    );\r\n\r\n    // Modifiers\r\n\r\n    modifier logs() {\r\n        emit LogCall(msg.sig, msg.sender, msg.data);\r\n        _;\r\n    }\r\n\r\n    // Mark functions that require delegation to the underlying Pool\r\n    modifier needsBPool() {\r\n        require(address(bPool) != address(0), \"ERR_NOT_CREATED\");\r\n        _;\r\n    }\r\n\r\n    modifier lockUnderlyingPool() {\r\n        // Turn off swapping on the underlying pool during joins\r\n        // Otherwise tokens with callbacks would enable attacks involving simultaneous swaps and joins\r\n        bool origSwapState = bPool.isPublicSwap();\r\n        bPool.setPublicSwap(false);\r\n        _;\r\n        bPool.setPublicSwap(origSwapState);\r\n    }\r\n\r\n    // Default values for these variables (used only in updateWeightsGradually), set in the constructor\r\n    // Pools without permission to update weights cannot use them anyway, and should call\r\n    //   the default createPool() function.\r\n    // To override these defaults, pass them into the overloaded createPool()\r\n    // Period is in blocks; 500 blocks ~ 2 hours; 90,000 blocks ~ 2 weeks\r\n    uint public constant DEFAULT_MIN_WEIGHT_CHANGE_BLOCK_PERIOD = 90000;\r\n    uint public constant DEFAULT_ADD_TOKEN_TIME_LOCK_IN_BLOCKS = 500;\r\n\r\n    // Function declarations\r\n\r\n    /**\r\n     * @notice Construct a new Configurable Rights Pool (wrapper around BPool)\r\n     * @dev _initialTokens and _swapFee are only used for temporary storage between construction\r\n     *      and create pool, and should not be used thereafter! _initialTokens is destroyed in\r\n     *      createPool to prevent this, and _swapFee is kept in sync (defensively), but\r\n     *      should never be used except in this constructor and createPool()\r\n     * @param factoryAddress - the BPoolFactory used to create the underlying pool\r\n     * @param poolParams - struct containing pool parameters\r\n     * @param rightsStruct - Set of permissions we are assigning to this smart pool\r\n     */\r\n    constructor(\r\n        address factoryAddress,\r\n        PoolParams memory poolParams,\r\n        RightsManager.Rights memory rightsStruct\r\n    )\r\n        public\r\n        PCToken(poolParams.poolTokenSymbol, poolParams.poolTokenName)\r\n    {\r\n        // We don't have a pool yet; check now or it will fail later (in order of likelihood to fail)\r\n        // (and be unrecoverable if they don't have permission set to change it)\r\n        // Most likely to fail, so check first\r\n        require(poolParams.swapFee >= BalancerConstants.MIN_FEE, \"ERR_INVALID_SWAP_FEE\");\r\n        require(poolParams.swapFee <= BalancerConstants.MAX_FEE, \"ERR_INVALID_SWAP_FEE\");\r\n\r\n        // Arrays must be parallel\r\n        require(poolParams.tokenBalances.length == poolParams.constituentTokens.length, \"ERR_START_BALANCES_MISMATCH\");\r\n        require(poolParams.tokenWeights.length == poolParams.constituentTokens.length, \"ERR_START_WEIGHTS_MISMATCH\");\r\n        // Cannot have too many or too few - technically redundant, since BPool.bind() would fail later\r\n        // But if we don't check now, we could have a useless contract with no way to create a pool\r\n\r\n        require(poolParams.constituentTokens.length >= BalancerConstants.MIN_ASSET_LIMIT, \"ERR_TOO_FEW_TOKENS\");\r\n        require(poolParams.constituentTokens.length <= BalancerConstants.MAX_ASSET_LIMIT, \"ERR_TOO_MANY_TOKENS\");\r\n        // There are further possible checks (e.g., if they use the same token twice), but\r\n        // we can let bind() catch things like that (i.e., not things that might reasonably work)\r\n\r\n        SmartPoolManager.verifyTokenCompliance(poolParams.constituentTokens);\r\n\r\n        bFactory = IBFactory(factoryAddress);\r\n        rights = rightsStruct;\r\n        _initialTokens = poolParams.constituentTokens;\r\n        _initialBalances = poolParams.tokenBalances;\r\n        _initialSwapFee = poolParams.swapFee;\r\n\r\n        // These default block time parameters can be overridden in createPool\r\n        minimumWeightChangeBlockPeriod = DEFAULT_MIN_WEIGHT_CHANGE_BLOCK_PERIOD;\r\n        addTokenTimeLockInBlocks = DEFAULT_ADD_TOKEN_TIME_LOCK_IN_BLOCKS;\r\n\r\n        gradualUpdate.startWeights = poolParams.tokenWeights;\r\n        // Initializing (unnecessarily) for documentation - 0 means no gradual weight change has been initiated\r\n        gradualUpdate.startBlock = 0;\r\n        // By default, there is no cap (unlimited pool token minting)\r\n        bspCap = BalancerConstants.MAX_UINT;\r\n    }\r\n\r\n    // External functions\r\n\r\n    /**\r\n     * @notice Set the swap fee on the underlying pool\r\n     * @dev Keep the local version and core in sync (see below)\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @param swapFee in Wei\r\n     */\r\n    function setSwapFee(uint swapFee)\r\n        external\r\n        logs\r\n        lock\r\n        onlyOwner\r\n        needsBPool\r\n        virtual\r\n    {\r\n        require(rights.canChangeSwapFee, \"ERR_NOT_CONFIGURABLE_SWAP_FEE\");\r\n\r\n        // Underlying pool will check against min/max fee\r\n        bPool.setSwapFee(swapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the publicSwap field on the underlying pool\r\n     * @dev viewLock, because setPublicSwap is lock\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @return Current value of isPublicSwap\r\n     */\r\n    function isPublicSwap()\r\n        external\r\n        view\r\n        viewlock\r\n        needsBPool\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        return bPool.isPublicSwap();\r\n    }\r\n\r\n    /**\r\n     * @notice Set the cap (max # of pool tokens)\r\n     * @dev _bspCap defaults in the constructor to unlimited\r\n     *      Can set to 0 (or anywhere below the current supply), to halt new investment\r\n     *      Prevent setting it before creating a pool, since createPool sets to intialSupply\r\n     *      (it does this to avoid an unlimited cap window between construction and createPool)\r\n     *      Therefore setting it before then has no effect, so should not be allowed\r\n     * @param newCap - new value of the cap\r\n     */\r\n    function setCap(uint newCap)\r\n        external\r\n        logs\r\n        lock\r\n        needsBPool\r\n        onlyOwner\r\n    {\r\n        require(rights.canChangeCap, \"ERR_CANNOT_CHANGE_CAP\");\r\n\r\n        emit CapChanged(msg.sender, bspCap, newCap);\r\n\r\n        bspCap = newCap;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the public swap flag on the underlying pool\r\n     * @dev If this smart pool has canPauseSwapping enabled, we can turn publicSwap off if it's already on\r\n     *      Note that if they turn swapping off - but then finalize the pool - finalizing will turn the\r\n     *      swapping back on. They're not supposed to finalize the underlying pool... would defeat the\r\n     *      smart pool functions. (Only the owner can finalize the pool - which is this contract -\r\n     *      so there is no risk from outside.)\r\n     *\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @param publicSwap new value of the swap\r\n     */\r\n    function setPublicSwap(bool publicSwap)\r\n        external\r\n        logs\r\n        lock\r\n        onlyOwner\r\n        needsBPool\r\n        virtual\r\n    {\r\n        require(rights.canPauseSwapping, \"ERR_NOT_PAUSABLE_SWAP\");\r\n\r\n        bPool.setPublicSwap(publicSwap);\r\n    }\r\n\r\n    /**\r\n     * @notice Create a new Smart Pool - and set the block period time parameters\r\n     * @dev Initialize the swap fee to the value provided in the CRP constructor\r\n     *      Can be changed if the canChangeSwapFee permission is enabled\r\n     *      Time parameters will be fixed at these values\r\n     *\r\n     *      If this contract doesn't have canChangeWeights permission - or you want to use the default\r\n     *      values, the block time arguments are not needed, and you can just call the single-argument\r\n     *      createPool()\r\n     * @param initialSupply - Starting token balance\r\n     * @param minimumWeightChangeBlockPeriodParam - Enforce a minimum time between the start and end blocks\r\n     * @param addTokenTimeLockInBlocksParam - Enforce a mandatory wait time between updates\r\n     *                                   This is also the wait time between committing and applying a new token\r\n     */\r\n    function createPool(\r\n        uint initialSupply,\r\n        uint minimumWeightChangeBlockPeriodParam,\r\n        uint addTokenTimeLockInBlocksParam\r\n    )\r\n        external\r\n        onlyOwner\r\n        logs\r\n        lock\r\n        virtual\r\n    {\r\n        require (minimumWeightChangeBlockPeriodParam >= addTokenTimeLockInBlocksParam,\r\n                \"ERR_INCONSISTENT_TOKEN_TIME_LOCK\");\r\n\r\n        minimumWeightChangeBlockPeriod = minimumWeightChangeBlockPeriodParam;\r\n        addTokenTimeLockInBlocks = addTokenTimeLockInBlocksParam;\r\n\r\n        createPoolInternal(initialSupply);\r\n    }\r\n\r\n    /**\r\n     * @notice Create a new Smart Pool\r\n     * @dev Delegates to internal function\r\n     * @param initialSupply starting token balance\r\n     */\r\n    function createPool(uint initialSupply)\r\n        external\r\n        onlyOwner\r\n        logs\r\n        lock\r\n        virtual\r\n    {\r\n        createPoolInternal(initialSupply);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the weight of an existing token\r\n     * @dev Notice Balance is not an input (like with rebind on BPool) since we will require prices not to change\r\n     *      This is achieved by forcing balances to change proportionally to weights, so that prices don't change\r\n     *      If prices could be changed, this would allow the controller to drain the pool by arbing price changes\r\n     * @param token - token to be reweighted\r\n     * @param newWeight - new weight of the token\r\n    */\r\n    function updateWeight(address token, uint newWeight)\r\n        external\r\n        logs\r\n        lock\r\n        onlyOwner\r\n        needsBPool\r\n        virtual\r\n    {\r\n        require(rights.canChangeWeights, \"ERR_NOT_CONFIGURABLE_WEIGHTS\");\r\n\r\n        // We don't want people to set weights manually if there's a block-based update in progress\r\n        require(gradualUpdate.startBlock == 0, \"ERR_NO_UPDATE_DURING_GRADUAL\");\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.updateWeight(IConfigurableRightsPool(address(this)), bPool, token, newWeight);\r\n    }\r\n\r\n    /**\r\n     * @notice Update weights in a predetermined way, between startBlock and endBlock,\r\n     *         through external calls to pokeWeights\r\n     * @dev Must call pokeWeights at least once past the end for it to do the final update\r\n     *      and enable calling this again.\r\n     *      It is possible to call updateWeightsGradually during an update in some use cases\r\n     *      For instance, setting newWeights to currentWeights to stop the update where it is\r\n     * @param newWeights - final weights we want to get to. Note that the ORDER (and number) of\r\n     *                     tokens can change if you have added or removed tokens from the pool\r\n     *                     It ensures the counts are correct, but can't help you with the order!\r\n     *                     You can get the underlying BPool (it's public), and call\r\n     *                     getCurrentTokens() to see the current ordering, if you're not sure\r\n     * @param startBlock - when weights should start to change\r\n     * @param endBlock - when weights will be at their final values\r\n    */\r\n    function updateWeightsGradually(\r\n        uint[] calldata newWeights,\r\n        uint startBlock,\r\n        uint endBlock\r\n    )\r\n        external\r\n        logs\r\n        lock\r\n        onlyOwner\r\n        needsBPool\r\n        virtual\r\n    {\r\n        require(rights.canChangeWeights, \"ERR_NOT_CONFIGURABLE_WEIGHTS\");\r\n         // Don't start this when we're in the middle of adding a new token\r\n        require(!newToken.isCommitted, \"ERR_PENDING_TOKEN_ADD\");\r\n\r\n        // Library computes the startBlock, computes startWeights as the current\r\n        // denormalized weights of the core pool tokens.\r\n        SmartPoolManager.updateWeightsGradually(\r\n            bPool,\r\n            gradualUpdate,\r\n            newWeights,\r\n            startBlock,\r\n            endBlock,\r\n            minimumWeightChangeBlockPeriod\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice External function called to make the contract update weights according to plan\r\n     * @dev Still works if we poke after the end of the period; also works if the weights don't change\r\n     *      Resets if we are poking beyond the end, so that we can do it again\r\n    */\r\n    function pokeWeights()\r\n        external\r\n        logs\r\n        lock\r\n        needsBPool\r\n        virtual\r\n    {\r\n        require(rights.canChangeWeights, \"ERR_NOT_CONFIGURABLE_WEIGHTS\");\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.pokeWeights(bPool, gradualUpdate);\r\n    }\r\n\r\n    /**\r\n     * @notice Schedule (commit) a token to be added; must call applyAddToken after a fixed\r\n     *         number of blocks to actually add the token\r\n     *\r\n     * @dev The purpose of this two-stage commit is to give warning of a potentially dangerous\r\n     *      operation. A malicious pool operator could add a large amount of a low-value token,\r\n     *      then drain the pool through price manipulation. Of course, there are many\r\n     *      legitimate purposes, such as adding additional collateral tokens.\r\n     *\r\n     * @param token - the token to be added\r\n     * @param balance - how much to be added\r\n     * @param denormalizedWeight - the desired token weight\r\n     */\r\n    function commitAddToken(\r\n        address token,\r\n        uint balance,\r\n        uint denormalizedWeight\r\n    )\r\n        external\r\n        logs\r\n        lock\r\n        onlyOwner\r\n        needsBPool\r\n        virtual\r\n    {\r\n        require(rights.canAddRemoveTokens, \"ERR_CANNOT_ADD_REMOVE_TOKENS\");\r\n\r\n        // Can't do this while a progressive update is happening\r\n        require(gradualUpdate.startBlock == 0, \"ERR_NO_UPDATE_DURING_GRADUAL\");\r\n\r\n        SmartPoolManager.verifyTokenCompliance(token);\r\n\r\n        emit NewTokenCommitted(token, address(this), msg.sender);\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.commitAddToken(\r\n            bPool,\r\n            token,\r\n            balance,\r\n            denormalizedWeight,\r\n            newToken\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Add the token previously committed (in commitAddToken) to the pool\r\n     */\r\n    function applyAddToken()\r\n        external\r\n        logs\r\n        lock\r\n        onlyOwner\r\n        needsBPool\r\n        virtual\r\n    {\r\n        require(rights.canAddRemoveTokens, \"ERR_CANNOT_ADD_REMOVE_TOKENS\");\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.applyAddToken(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            addTokenTimeLockInBlocks,\r\n            newToken\r\n        );\r\n    }\r\n\r\n     /**\r\n     * @notice Remove a token from the pool\r\n     * @dev bPool is a contract interface; function calls on it are external\r\n     * @param token - token to remove\r\n     */\r\n    function removeToken(address token)\r\n        external\r\n        logs\r\n        lock\r\n        onlyOwner\r\n        needsBPool\r\n    {\r\n        // It's possible to have remove rights without having add rights\r\n        require(rights.canAddRemoveTokens,\"ERR_CANNOT_ADD_REMOVE_TOKENS\");\r\n        // After createPool, token list is maintained in the underlying BPool\r\n        require(!newToken.isCommitted, \"ERR_REMOVE_WITH_ADD_PENDING\");\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.removeToken(IConfigurableRightsPool(address(this)), bPool, token);\r\n    }\r\n\r\n    /**\r\n     * @notice Join a pool\r\n     * @dev Emits a LogJoin event (for each token)\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @param poolAmountOut - number of pool tokens to receive\r\n     * @param maxAmountsIn - Max amount of asset tokens to spend\r\n     */\r\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\r\n        external\r\n        logs\r\n        lock\r\n        needsBPool\r\n        lockUnderlyingPool\r\n    {\r\n        require(!rights.canWhitelistLPs || _liquidityProviderWhitelist[msg.sender],\r\n                \"ERR_NOT_ON_WHITELIST\");\r\n\r\n        // Delegate to library to save space\r\n\r\n        // Library computes actualAmountsIn, and does many validations\r\n        // Cannot call the push/pull/min from an external library for\r\n        // any of these pool functions. Since msg.sender can be anybody,\r\n        // they must be internal\r\n        uint[] memory actualAmountsIn = SmartPoolManager.joinPool(\r\n                                            IConfigurableRightsPool(address(this)),\r\n                                            bPool,\r\n                                            poolAmountOut,\r\n                                            maxAmountsIn\r\n                                        );\r\n\r\n        // After createPool, token list is maintained in the underlying BPool\r\n        address[] memory poolTokens = bPool.getCurrentTokens();\r\n\r\n        for (uint i = 0; i < poolTokens.length; i++) {\r\n            address t = poolTokens[i];\r\n            uint tokenAmountIn = actualAmountsIn[i];\r\n\r\n            emit LogJoin(msg.sender, t, tokenAmountIn);\r\n\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\r\n        }\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem pool tokens for underlying assets\r\n     * @dev Emits a LogExit event for each token\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @param poolAmountIn - amount of pool tokens to redeem\r\n     * @param minAmountsOut - minimum amount of asset tokens to receive\r\n     */\r\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\r\n        external\r\n        logs\r\n        lock\r\n        needsBPool\r\n        lockUnderlyingPool\r\n    {\r\n        // Delegate to library to save space\r\n\r\n        // Library computes actualAmountsOut, and does many validations\r\n        // Also computes the exitFee and pAiAfterExitFee\r\n        (uint exitFee,\r\n         uint pAiAfterExitFee,\r\n         uint[] memory actualAmountsOut) = SmartPoolManager.exitPool(\r\n                                               IConfigurableRightsPool(address(this)),\r\n                                               bPool,\r\n                                               poolAmountIn,\r\n                                               minAmountsOut\r\n                                           );\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _pushPoolShare(address(bFactory), exitFee);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n\r\n        // After createPool, token list is maintained in the underlying BPool\r\n        address[] memory poolTokens = bPool.getCurrentTokens();\r\n\r\n        for (uint i = 0; i < poolTokens.length; i++) {\r\n            address t = poolTokens[i];\r\n            uint tokenAmountOut = actualAmountsOut[i];\r\n\r\n            emit LogExit(msg.sender, t, tokenAmountOut);\r\n\r\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Join by swapping a fixed amount of an external token in (must be present in the pool)\r\n     *         System calculates the pool token amount\r\n     * @dev emits a LogJoin event\r\n     * @param tokenIn - which token we're transferring in\r\n     * @param tokenAmountIn - amount of deposit\r\n     * @param minPoolAmountOut - minimum of pool tokens to receive\r\n     * @return poolAmountOut - amount of pool tokens minted and transferred\r\n     */\r\n    function joinswapExternAmountIn(\r\n        address tokenIn,\r\n        uint tokenAmountIn,\r\n        uint minPoolAmountOut\r\n    )\r\n        external\r\n        logs\r\n        lock\r\n        needsBPool\r\n        returns (uint poolAmountOut)\r\n    {\r\n        require(!rights.canWhitelistLPs || _liquidityProviderWhitelist[msg.sender],\r\n                \"ERR_NOT_ON_WHITELIST\");\r\n\r\n        // Delegate to library to save space\r\n        poolAmountOut = SmartPoolManager.joinswapExternAmountIn(\r\n                            IConfigurableRightsPool(address(this)),\r\n                            bPool,\r\n                            tokenIn,\r\n                            tokenAmountIn,\r\n                            minPoolAmountOut\r\n                        );\r\n\r\n        emit LogJoin(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        return poolAmountOut;\r\n    }\r\n\r\n    /**\r\n     * @notice Join by swapping an external token in (must be present in the pool)\r\n     *         To receive an exact amount of pool tokens out. System calculates the deposit amount\r\n     * @dev emits a LogJoin event\r\n     * @param tokenIn - which token we're transferring in (system calculates amount required)\r\n     * @param poolAmountOut - amount of pool tokens to be received\r\n     * @param maxAmountIn - Maximum asset tokens that can be pulled to pay for the pool tokens\r\n     * @return tokenAmountIn - amount of asset tokens transferred in to purchase the pool tokens\r\n     */\r\n    function joinswapPoolAmountOut(\r\n        address tokenIn,\r\n        uint poolAmountOut,\r\n        uint maxAmountIn\r\n    )\r\n        external\r\n        logs\r\n        lock\r\n        needsBPool\r\n        returns (uint tokenAmountIn)\r\n    {\r\n        require(!rights.canWhitelistLPs || _liquidityProviderWhitelist[msg.sender],\r\n                \"ERR_NOT_ON_WHITELIST\");\r\n\r\n        // Delegate to library to save space\r\n        tokenAmountIn = SmartPoolManager.joinswapPoolAmountOut(\r\n                            IConfigurableRightsPool(address(this)),\r\n                            bPool,\r\n                            tokenIn,\r\n                            poolAmountOut,\r\n                            maxAmountIn\r\n                        );\r\n\r\n        emit LogJoin(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem a specific number of pool tokens for an underlying asset\r\n     *         Asset must be present in the pool, and will incur an EXIT_FEE (if set to non-zero)\r\n     * @dev Emits a LogExit event for the token\r\n     * @param tokenOut - which token the caller wants to receive\r\n     * @param poolAmountIn - amount of pool tokens to redeem\r\n     * @param minAmountOut - minimum asset tokens to receive\r\n     * @return tokenAmountOut - amount of asset tokens returned\r\n     */\r\n    function exitswapPoolAmountIn(\r\n        address tokenOut,\r\n        uint poolAmountIn,\r\n        uint minAmountOut\r\n    )\r\n        external\r\n        logs\r\n        lock\r\n        needsBPool\r\n        returns (uint tokenAmountOut)\r\n    {\r\n        // Delegate to library to save space\r\n\r\n        // Calculates final amountOut, and the fee and final amount in\r\n        (uint exitFee,\r\n         uint amountOut) = SmartPoolManager.exitswapPoolAmountIn(\r\n                               IConfigurableRightsPool(address(this)),\r\n                               bPool,\r\n                               tokenOut,\r\n                               poolAmountIn,\r\n                               minAmountOut\r\n                           );\r\n\r\n        tokenAmountOut = amountOut;\r\n        uint pAiAfterExitFee = BalancerSafeMath.bsub(poolAmountIn, exitFee);\r\n\r\n        emit LogExit(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n        _pushPoolShare(address(bFactory), exitFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem pool tokens for a specific amount of underlying assets\r\n     *         Asset must be present in the pool\r\n     * @dev Emits a LogExit event for the token\r\n     * @param tokenOut - which token the caller wants to receive\r\n     * @param tokenAmountOut - amount of underlying asset tokens to receive\r\n     * @param maxPoolAmountIn - maximum pool tokens to be redeemed\r\n     * @return poolAmountIn - amount of pool tokens redeemed\r\n     */\r\n    function exitswapExternAmountOut(\r\n        address tokenOut,\r\n        uint tokenAmountOut,\r\n        uint maxPoolAmountIn\r\n    )\r\n        external\r\n        logs\r\n        lock\r\n        needsBPool\r\n        returns (uint poolAmountIn)\r\n    {\r\n        // Delegate to library to save space\r\n\r\n        // Calculates final amounts in, accounting for the exit fee\r\n        (uint exitFee,\r\n         uint amountIn) = SmartPoolManager.exitswapExternAmountOut(\r\n                              IConfigurableRightsPool(address(this)),\r\n                              bPool,\r\n                              tokenOut,\r\n                              tokenAmountOut,\r\n                              maxPoolAmountIn\r\n                          );\r\n\r\n        poolAmountIn = amountIn;\r\n        uint pAiAfterExitFee = BalancerSafeMath.bsub(poolAmountIn, exitFee);\r\n\r\n        emit LogExit(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n        _pushPoolShare(address(bFactory), exitFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return poolAmountIn;\r\n    }\r\n\r\n    /**\r\n     * @notice Add to the whitelist of liquidity providers (if enabled)\r\n     * @param provider - address of the liquidity provider\r\n     */\r\n    function whitelistLiquidityProvider(address provider)\r\n        external\r\n        onlyOwner\r\n        lock\r\n        logs\r\n    {\r\n        require(rights.canWhitelistLPs, \"ERR_CANNOT_WHITELIST_LPS\");\r\n        require(provider != address(0), \"ERR_INVALID_ADDRESS\");\r\n\r\n        _liquidityProviderWhitelist[provider] = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove from the whitelist of liquidity providers (if enabled)\r\n     * @param provider - address of the liquidity provider\r\n     */\r\n    function removeWhitelistedLiquidityProvider(address provider)\r\n        external\r\n        onlyOwner\r\n        lock\r\n        logs\r\n    {\r\n        require(rights.canWhitelistLPs, \"ERR_CANNOT_WHITELIST_LPS\");\r\n        require(_liquidityProviderWhitelist[provider], \"ERR_LP_NOT_WHITELISTED\");\r\n        require(provider != address(0), \"ERR_INVALID_ADDRESS\");\r\n\r\n        _liquidityProviderWhitelist[provider] = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if an address is a liquidity provider\r\n     * @dev If the whitelist feature is not enabled, anyone can provide liquidity (assuming finalized)\r\n     * @return boolean value indicating whether the address can join a pool\r\n     */\r\n    function canProvideLiquidity(address provider)\r\n        external\r\n        view\r\n        returns(bool)\r\n    {\r\n        if (rights.canWhitelistLPs) {\r\n            return _liquidityProviderWhitelist[provider];\r\n        }\r\n        else {\r\n            // Probably don't strictly need this (could just return true)\r\n            // But the null address can't provide funds\r\n            return provider != address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for specific permissions\r\n     * @dev value of the enum is just the 0-based index in the enumeration\r\n     *      For instance canPauseSwapping is 0; canChangeWeights is 2\r\n     * @return token boolean true if we have the given permission\r\n    */\r\n    function hasPermission(RightsManager.Permissions permission)\r\n        external\r\n        view\r\n        virtual\r\n        returns(bool)\r\n    {\r\n        return RightsManager.hasPermission(rights, permission);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the denormalized weight of a token\r\n     * @dev viewlock to prevent calling if it's being updated\r\n     * @return token weight\r\n     */\r\n    function getDenormalizedWeight(address token)\r\n        external\r\n        view\r\n        viewlock\r\n        needsBPool\r\n        returns (uint)\r\n    {\r\n        return bPool.getDenormalizedWeight(token);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the RightsManager contract\r\n     * @dev Convenience function to get the address of the RightsManager library (so clients can check version)\r\n     * @return address of the RightsManager library\r\n    */\r\n    function getRightsManagerVersion() external pure returns (address) {\r\n        return address(RightsManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the BalancerSafeMath contract\r\n     * @dev Convenience function to get the address of the BalancerSafeMath library (so clients can check version)\r\n     * @return address of the BalancerSafeMath library\r\n    */\r\n    function getBalancerSafeMathVersion() external pure returns (address) {\r\n        return address(BalancerSafeMath);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the SmartPoolManager contract\r\n     * @dev Convenience function to get the address of the SmartPoolManager library (so clients can check version)\r\n     * @return address of the SmartPoolManager library\r\n    */\r\n    function getSmartPoolManagerVersion() external pure returns (address) {\r\n        return address(SmartPoolManager);\r\n    }\r\n\r\n    // Public functions\r\n\r\n    // \"Public\" versions that can safely be called from SmartPoolManager\r\n    // Allows only the contract itself to call them (not the controller or any external account)\r\n\r\n    function mintPoolShareFromLib(uint amount) public {\r\n        require (msg.sender == address(this), \"ERR_NOT_CONTROLLER\");\r\n\r\n        _mint(amount);\r\n    }\r\n\r\n    function pushPoolShareFromLib(address to, uint amount) public {\r\n        require (msg.sender == address(this), \"ERR_NOT_CONTROLLER\");\r\n\r\n        _push(to, amount);\r\n    }\r\n\r\n    function pullPoolShareFromLib(address from, uint amount) public  {\r\n        require (msg.sender == address(this), \"ERR_NOT_CONTROLLER\");\r\n\r\n        _pull(from, amount);\r\n    }\r\n\r\n    function burnPoolShareFromLib(uint amount) public  {\r\n        require (msg.sender == address(this), \"ERR_NOT_CONTROLLER\");\r\n\r\n        _burn(amount);\r\n    }\r\n\r\n    // Internal functions\r\n\r\n    // Lint wants the function to have a leading underscore too\r\n    /* solhint-disable private-vars-leading-underscore */\r\n\r\n    /**\r\n     * @notice Create a new Smart Pool\r\n     * @dev Initialize the swap fee to the value provided in the CRP constructor\r\n     *      Can be changed if the canChangeSwapFee permission is enabled\r\n     * @param initialSupply starting token balance\r\n     */\r\n    function createPoolInternal(uint initialSupply) internal {\r\n        require(address(bPool) == address(0), \"ERR_IS_CREATED\");\r\n        require(initialSupply >= BalancerConstants.MIN_POOL_SUPPLY, \"ERR_INIT_SUPPLY_MIN\");\r\n        require(initialSupply <= BalancerConstants.MAX_POOL_SUPPLY, \"ERR_INIT_SUPPLY_MAX\");\r\n\r\n        // If the controller can change the cap, initialize it to the initial supply\r\n        // Defensive programming, so that there is no gap between creating the pool\r\n        // (initialized to unlimited in the constructor), and setting the cap,\r\n        // which they will presumably do if they have this right.\r\n        if (rights.canChangeCap) {\r\n            bspCap = initialSupply;\r\n        }\r\n\r\n        // There is technically reentrancy here, since we're making external calls and\r\n        // then transferring tokens. However, the external calls are all to the underlying BPool\r\n\r\n        // To the extent possible, modify state variables before calling functions\r\n        _mintPoolShare(initialSupply);\r\n        _pushPoolShare(msg.sender, initialSupply);\r\n\r\n        // Deploy new BPool (bFactory and bPool are interfaces; all calls are external)\r\n        bPool = bFactory.newBPool();\r\n\r\n        // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\r\n        require(bPool.EXIT_FEE() == 0, \"ERR_NONZERO_EXIT_FEE\");\r\n        require(BalancerConstants.EXIT_FEE == 0, \"ERR_NONZERO_EXIT_FEE\");\r\n\r\n        for (uint i = 0; i < _initialTokens.length; i++) {\r\n            address t = _initialTokens[i];\r\n            uint bal = _initialBalances[i];\r\n            uint denorm = gradualUpdate.startWeights[i];\r\n\r\n            bool returnValue = IERC20(t).transferFrom(msg.sender, address(this), bal);\r\n            require(returnValue, \"ERR_ERC20_FALSE\");\r\n\r\n            returnValue = IERC20(t).safeApprove(address(bPool), BalancerConstants.MAX_UINT);\r\n            require(returnValue, \"ERR_ERC20_FALSE\");\r\n\r\n            bPool.bind(t, bal, denorm);\r\n        }\r\n\r\n        while (_initialTokens.length > 0) {\r\n            // Modifying state variable after external calls here,\r\n            // but not essential, so not dangerous\r\n            _initialTokens.pop();\r\n        }\r\n\r\n        // Set fee to the initial value set in the constructor\r\n        // Hereafter, read the swapFee from the underlying pool, not the local state variable\r\n        bPool.setSwapFee(_initialSwapFee);\r\n        bPool.setPublicSwap(true);\r\n\r\n        // \"destroy\" the temporary swap fee (like _initialTokens above) in case a subclass tries to use it\r\n        _initialSwapFee = 0;\r\n    }\r\n\r\n    /* solhint-enable private-vars-leading-underscore */\r\n\r\n    // Rebind BPool and pull tokens from address\r\n    // bPool is a contract interface; function calls on it are external\r\n    function _pullUnderlying(address erc20, address from, uint amount) internal needsBPool {\r\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\r\n        uint tokenBalance = bPool.getBalance(erc20);\r\n        uint tokenWeight = bPool.getDenormalizedWeight(erc20);\r\n\r\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n        bPool.rebind(erc20, BalancerSafeMath.badd(tokenBalance, amount), tokenWeight);\r\n    }\r\n\r\n    // Rebind BPool and push tokens to address\r\n    // bPool is a contract interface; function calls on it are external\r\n    function _pushUnderlying(address erc20, address to, uint amount) internal needsBPool {\r\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\r\n        uint tokenBalance = bPool.getBalance(erc20);\r\n        uint tokenWeight = bPool.getDenormalizedWeight(erc20);\r\n        bPool.rebind(erc20, BalancerSafeMath.bsub(tokenBalance, amount), tokenWeight);\r\n\r\n        bool xfer = IERC20(erc20).transfer(to, amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n    }\r\n\r\n    // Wrappers around corresponding core functions\r\n\r\n    //\r\n    function _mint(uint amount) internal override {\r\n        super._mint(amount);\r\n        require(varTotalSupply <= bspCap, \"ERR_CAP_LIMIT_REACHED\");\r\n    }\r\n\r\n    function _mintPoolShare(uint amount) internal {\r\n        _mint(amount);\r\n    }\r\n\r\n    function _pushPoolShare(address to, uint amount) internal {\r\n        _push(to, amount);\r\n    }\r\n\r\n    function _pullPoolShare(address from, uint amount) internal  {\r\n        _pull(from, amount);\r\n    }\r\n\r\n    function _burnPoolShare(uint amount) internal  {\r\n        _burn(amount);\r\n    }\r\n}\r\n\r\n// File: contracts/AmplElasticCRP.sol\r\n\r\n\r\n\r\n\r\n// Needed to handle structures externally\r\n\r\n// Imports\r\n\r\n\r\n/**\r\n * @author Ampleforth engineering team & Balancer Labs\r\n *\r\n * Reference:\r\n * https://github.com/balancer-labs/configurable-rights-pool/blob/master/contracts/templates/ElasticSupplyPool.sol\r\n *\r\n * @title Ampl Elastic Configurable Rights Pool.\r\n *\r\n * @dev   Extension of Balancer labs' configurable rights pool (smart-pool).\r\n *        Amples are a dynamic supply tokens, supply and individual balances change daily by a Rebase operation.\r\n *        In constant-function markets, Ampleforth's supply adjustments result in Impermanent Loss (IL)\r\n *        to liquidity providers. The AmplElasticCRP is an extension of Balancer Lab's\r\n *        ConfigurableRightsPool which mitigates IL induced by supply adjustments.\r\n *\r\n *        It accomplishes this by doing the following mechanism:\r\n *        The `resyncWeight` method will be invoked atomically after rebase through Ampleforth's orchestrator.\r\n *\r\n *        When rebase changes supply, ampl weight is updated to the geometric mean of\r\n *        the current ampl weight and the target. Every other token's weight is updated\r\n *        proportionally such that relative ratios are same.\r\n *\r\n *        Weights: {w_ampl, w_t1 ... w_tn}\r\n *\r\n *        Rebase_change: x% (Ample's supply changes by x%, can be positive or negative)\r\n *\r\n *        Ample target weight: w_ampl_target = (100+x)/100 * w_ampl\r\n *\r\n *        w_ampl_new = sqrt(w_ampl * w_ampl_target)  // geometric mean\r\n *        for i in tn:\r\n *           w_ti_new = (w_ampl_new * w_ti) / w_ampl_target\r\n *\r\n */\r\ncontract AmplElasticCRP is ConfigurableRightsPool {\r\n    constructor(\r\n        address factoryAddress,\r\n        PoolParams memory poolParams,\r\n        RightsManager.Rights memory rightsStruct\r\n    )\r\n    public\r\n    ConfigurableRightsPool(factoryAddress, poolParams, rightsStruct) {\r\n\r\n        require(rights.canChangeWeights, \"ERR_NOT_CONFIGURABLE_WEIGHTS\");\r\n\r\n    }\r\n\r\n    function updateWeight(address token, uint newWeight)\r\n        external\r\n        logs\r\n        onlyOwner\r\n        needsBPool\r\n        override\r\n    {\r\n        revert(\"ERR_UNSUPPORTED_OPERATION\");\r\n    }\r\n\r\n    function updateWeightsGradually(\r\n        uint[] calldata newWeights,\r\n        uint startBlock,\r\n        uint endBlock\r\n    )\r\n        external\r\n        logs\r\n        onlyOwner\r\n        needsBPool\r\n        override\r\n    {\r\n        revert(\"ERR_UNSUPPORTED_OPERATION\");\r\n    }\r\n\r\n    function pokeWeights()\r\n        external\r\n        logs\r\n        needsBPool\r\n        override\r\n    {\r\n       revert(\"ERR_UNSUPPORTED_OPERATION\");\r\n    }\r\n\r\n    /*\r\n     * @param token The address of the token in the underlying BPool to be weight adjusted.\r\n     * @dev Checks if the token's current pool balance has deviated from cached balance,\r\n     *      if so it adjusts the token's weights proportional to the deviation.\r\n     *      The underlying BPool enforces bounds on MIN_WEIGHTS=1e18, MAX_WEIGHT=50e18 and TOTAL_WEIGHT=50e18.\r\n     *      NOTE: The BPool.rebind function CAN REVERT if the updated weights go beyond the enforced bounds.\r\n     */\r\n    function resyncWeight(address token)\r\n        external\r\n        logs\r\n        lock\r\n        needsBPool\r\n    {\r\n\r\n        // NOTE: Skipping gradual update check\r\n        // Pool will never go into gradual update state as `updateWeightsGradually` is disabled\r\n        // require(\r\n        //     ConfigurableRightsPool.gradualUpdate.startBlock == 0,\r\n        //     \"ERR_NO_UPDATE_DURING_GRADUAL\");\r\n\r\n        require(\r\n            IBPool(address(bPool)).isBound(token),\r\n            \"ERR_NOT_BOUND\");\r\n\r\n        // get cached balance\r\n        uint tokenBalanceBefore = IBPool(address(bPool)).getBalance(token);\r\n\r\n        // sync balance\r\n        IBPool(address(bPool)).gulp(token);\r\n\r\n        // get new balance\r\n        uint tokenBalanceAfter = IBPool(address(bPool)).getBalance(token);\r\n\r\n        // No-Op\r\n        if(tokenBalanceBefore == tokenBalanceAfter) {\r\n            return;\r\n        }\r\n\r\n        // current token weight\r\n        uint tokenWeightBefore = IBPool(address(bPool)).getDenormalizedWeight(token);\r\n\r\n        // target token weight = RebaseRatio * previous token weight\r\n        uint tokenWeightTarget = BalancerSafeMath.bdiv(\r\n            BalancerSafeMath.bmul(tokenWeightBefore, tokenBalanceAfter),\r\n            tokenBalanceBefore\r\n        );\r\n\r\n        // new token weight = sqrt(current token weight * target token weight)\r\n        uint tokenWeightAfter = BalancerSafeMath.sqrt(\r\n            BalancerSafeMath.bdiv(\r\n                BalancerSafeMath.bmul(tokenWeightBefore, tokenWeightTarget),\r\n                1\r\n            )\r\n        );\r\n\r\n\r\n        address[] memory tokens = IBPool(address(bPool)).getCurrentTokens();\r\n        for(uint i=0; i<tokens.length; i++){\r\n            if(tokens[i] == token) {\r\n\r\n                // adjust weight\r\n                IBPool(address(bPool)).rebind(token, tokenBalanceAfter, tokenWeightAfter);\r\n\r\n            } else {\r\n\r\n                uint otherWeightBefore = IBPool(address(bPool)).getDenormalizedWeight(tokens[i]);\r\n                uint otherBalance = bPool.getBalance(tokens[i]);\r\n\r\n                // other token weight = (new token weight * other token weight before) / target token weight\r\n                uint otherWeightAfter = BalancerSafeMath.bdiv(\r\n                    BalancerSafeMath.bmul(tokenWeightAfter, otherWeightBefore),\r\n                    tokenWeightTarget\r\n                );\r\n\r\n                // adjust weight\r\n                IBPool(address(bPool)).rebind(tokens[i], otherBalance, otherWeightAfter);\r\n            }\r\n        }\r\n    }\r\n}"}}}