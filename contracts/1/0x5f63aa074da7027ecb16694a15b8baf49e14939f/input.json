{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "forbitspaceX.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\n\ninterface IPayment {\n\tfunction collectETH() external returns (uint amount);\n\n\tfunction collectTokens(address token) external returns (uint amount);\n\n\tfunction setAdmin(address newAdmin) external ;\n}\n\ninterface IforbitspaceX is IPayment {\n\tstruct SwapParam {\n\t\taddress addressToApprove;\n\t\taddress exchangeTarget;\n\t\taddress tokenIn; // tokenFrom\n\t\taddress tokenOut; // tokenTo\n\t\tbytes swapData;\n\t}\n\n\tfunction aggregate(\n\t\taddress tokenIn,\n\t\taddress tokenOut,\n\t\tuint amountInTotal,\n\t\taddress recipient,\n\t\tSwapParam[] calldata params\n\t) external payable returns (uint amountInAcutual, uint amountOutAcutual);\n}\n\n// \n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n\t/**\n\t * @dev Returns the amount of tokens in existence.\n\t */\n\tfunction totalSupply() external view returns (uint);\n\n\t/**\n\t * @dev Returns the amount of tokens owned by `account`.\n\t */\n\tfunction balanceOf(address account) external view returns (uint);\n\n\t/**\n\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transfer(address recipient, uint amount) external returns (bool);\n\n\t/**\n\t * @dev Returns the remaining number of tokens that `spender` will be\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\t * zero by default.\n\t *\n\t * This value changes when {approve} or {transferFrom} are called.\n\t */\n\tfunction allowance(address owner, address spender) external view returns (uint);\n\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\t * that someone may use both the old and the new allowance by unfortunate\n\t * transaction ordering. One possible solution to mitigate this race\n\t * condition is to first reduce the spender's allowance to 0 and set the\n\t * desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t *\n\t * Emits an {Approval} event.\n\t */\n\tfunction approve(address spender, uint amount) external returns (bool);\n\n\t/**\n\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\t * allowance mechanism. `amount` is then deducted from the caller's\n\t * allowance.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint amount\n\t) external returns (bool);\n\n\t/**\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\t * another (`to`).\n\t *\n\t * Note that `value` may be zero.\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\n\t/**\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\t * a call to {approve}. `value` is the new allowance.\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint value);\n}\n\n// \n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n\t/**\n\t * @dev Returns true if `account` is a contract.\n\t *\n\t * [IMPORTANT]\n\t * ====\n\t * It is unsafe to assume that an address for which this function returns\n\t * false is an externally-owned account (EOA) and not a contract.\n\t *\n\t * Among others, `isContract` will return false for the following\n\t * types of addresses:\n\t *\n\t *  - an externally-owned account\n\t *  - a contract in construction\n\t *  - an address where a contract will be created\n\t *  - an address where a contract lived, but was destroyed\n\t * ====\n\t */\n\tfunction isContract(address account) internal view returns (bool) {\n\t\t// This method relies on extcodesize, which returns 0 for contracts in\n\t\t// construction, since the code is only stored at the end of the\n\t\t// constructor execution.\n\n\t\tuint size;\n\t\tassembly {\n\t\t\tsize := extcodesize(account)\n\t\t}\n\t\treturn size > 0;\n\t}\n\n\t/**\n\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n\t * `recipient`, forwarding all available gas and reverting on errors.\n\t *\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\n\t * imposed by `transfer`, making them unable to receive funds via\n\t * `transfer`. {sendValue} removes this limitation.\n\t *\n\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n\t *\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\n\t * taken to not create reentrancy vulnerabilities. Consider using\n\t * {ReentrancyGuard} or the\n\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n\t */\n\tfunction sendValue(address payable recipient, uint amount) internal {\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\n\n\t\t(bool success, ) = recipient.call{ value: amount }(\"\");\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\n\t}\n\n\t/**\n\t * @dev Performs a Solidity function call using a low level `call`. A\n\t * plain `call` is an unsafe replacement for a function call: use this\n\t * function instead.\n\t *\n\t * If `target` reverts with a revert reason, it is bubbled up by this\n\t * function (like regular Solidity function calls).\n\t *\n\t * Returns the raw returned data. To convert to the expected return value,\n\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n\t *\n\t * Requirements:\n\t *\n\t * - `target` must be a contract.\n\t * - calling `target` with `data` must not revert.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n\t * `errorMessage` as a fallback revert reason when `target` reverts.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCall(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tstring memory errorMessage\n\t) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t * but also transferring `value` wei to `target`.\n\t *\n\t * Requirements:\n\t *\n\t * - the calling contract must have an ETH balance of at least `value`.\n\t * - the called Solidity function must be `payable`.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCallWithValue(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tuint value\n\t) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n\t * with `errorMessage` as a fallback revert reason when `target` reverts.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCallWithValue(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tuint value,\n\t\tstring memory errorMessage\n\t) internal returns (bytes memory) {\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\n\t\trequire(isContract(target), \"Address: call to non-contract\");\n\n\t\t(bool success, bytes memory returndata) = target.call{ value: value }(data);\n\t\treturn verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t * but performing a static call.\n\t *\n\t * _Available since v3.3._\n\t */\n\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n\t\treturn functionStaticCall(target, data, \"Address: low-level static call failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n\t * but performing a static call.\n\t *\n\t * _Available since v3.3._\n\t */\n\tfunction functionStaticCall(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tstring memory errorMessage\n\t) internal view returns (bytes memory) {\n\t\trequire(isContract(target), \"Address: static call to non-contract\");\n\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\n\t\treturn verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t * but performing a delegate call.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n\t * but performing a delegate call.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction functionDelegateCall(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tstring memory errorMessage\n\t) internal returns (bytes memory) {\n\t\trequire(isContract(target), \"Address: delegate call to non-contract\");\n\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\n\t\treturn verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\t/**\n\t * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n\t * revert reason using the provided one.\n\t *\n\t * _Available since v4.3._\n\t */\n\tfunction verifyCallResult(\n\t\tbool success,\n\t\tbytes memory returndata,\n\t\tstring memory errorMessage\n\t) internal pure returns (bytes memory) {\n\t\tif (success) {\n\t\t\treturn returndata;\n\t\t} else {\n\t\t\t// Look for revert reason and bubble it up if present\n\t\t\tif (returndata.length > 0) {\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\n\n\t\t\t\tassembly {\n\t\t\t\t\tlet returndata_size := mload(returndata)\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trevert(errorMessage);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlibrary SafeERC20 {\n\tusing Address for address;\n\n\tfunction safeTransfer(\n\t\tIERC20 token,\n\t\taddress to,\n\t\tuint value\n\t) internal {\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n\t}\n\n\tfunction safeTransferFrom(\n\t\tIERC20 token,\n\t\taddress from,\n\t\taddress to,\n\t\tuint value\n\t) internal {\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n\t}\n\n\t/**\n\t * @dev Deprecated. This function has issues similar to the ones found in\n\t * {IERC20-approve}, and its usage is discouraged.\n\t *\n\t * Whenever possible, use {safeIncreaseAllowance} and\n\t * {safeDecreaseAllowance} instead.\n\t */\n\tfunction safeApprove(\n\t\tIERC20 token,\n\t\taddress spender,\n\t\tuint value\n\t) internal {\n\t\t// safeApprove should only be called when setting an initial allowance,\n\t\t// or when resetting it to zero. To increase and decrease it, use\n\t\t// 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n\t\trequire(\n\t\t\t(value == 0) || (token.allowance(address(this), spender) == 0),\n\t\t\t\"SafeERC20: approve from non-zero to non-zero allowance\"\n\t\t);\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n\t}\n\n\tfunction safeIncreaseAllowance(\n\t\tIERC20 token,\n\t\taddress spender,\n\t\tuint value\n\t) internal {\n\t\tuint newAllowance = token.allowance(address(this), spender) + value;\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n\t}\n\n\tfunction safeDecreaseAllowance(\n\t\tIERC20 token,\n\t\taddress spender,\n\t\tuint value\n\t) internal {\n\t\tunchecked {\n\t\t\tuint oldAllowance = token.allowance(address(this), spender);\n\t\t\trequire(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n\t\t\tuint newAllowance = oldAllowance - value;\n\t\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n\t\t}\n\t}\n\n\t/**\n\t * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n\t * on the return value: the return value is optional (but if data is returned, it must not be false).\n\t * @param token The token targeted by the call.\n\t * @param data The call data (encoded using abi.encode or one of its variants).\n\t */\n\tfunction _callOptionalReturn(IERC20 token, bytes memory data) private {\n\t\t// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n\t\t// we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n\t\t// the target address contains contract code and also asserts for success in the low-level call.\n\n\t\tbytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n\t\tif (returndata.length > 0) {\n\t\t\t// Return data is optional\n\t\t\trequire(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n\t\t}\n\t}\n}\n\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryAdd(uint a, uint b) internal pure returns (bool, uint) {\n\t\tunchecked {\n\t\t\tuint c = a + b;\n\t\t\tif (c < a) return (false, 0);\n\t\t\treturn (true, c);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction trySub(uint a, uint b) internal pure returns (bool, uint) {\n\t\tunchecked {\n\t\t\tif (b > a) return (false, 0);\n\t\t\treturn (true, a - b);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryMul(uint a, uint b) internal pure returns (bool, uint) {\n\t\tunchecked {\n\t\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t\t// benefit is lost if 'b' is also tested.\n\t\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\t\tif (a == 0) return (true, 0);\n\t\t\tuint c = a * b;\n\t\t\tif (c / a != b) return (false, 0);\n\t\t\treturn (true, c);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryDiv(uint a, uint b) internal pure returns (bool, uint) {\n\t\tunchecked {\n\t\t\tif (b == 0) return (false, 0);\n\t\t\treturn (true, a / b);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n\t *\n\t * _Available since v3.4._\n\t */\n\tfunction tryMod(uint a, uint b) internal pure returns (bool, uint) {\n\t\tunchecked {\n\t\t\tif (b == 0) return (false, 0);\n\t\t\treturn (true, a % b);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint a, uint b) internal pure returns (uint) {\n\t\treturn a + b;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint a, uint b) internal pure returns (uint) {\n\t\treturn a - b;\n\t}\n\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint a, uint b) internal pure returns (uint) {\n\t\treturn a * b;\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers, reverting on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint a, uint b) internal pure returns (uint) {\n\t\treturn a / b;\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * reverting when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint a, uint b) internal pure returns (uint) {\n\t\treturn a % b;\n\t}\n\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\n\t * message unnecessarily. For custom revert reasons use {trySub}.\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(\n\t\tuint a,\n\t\tuint b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint) {\n\t\tunchecked {\n\t\t\trequire(b <= a, errorMessage);\n\t\t\treturn a - b;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(\n\t\tuint a,\n\t\tuint b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint) {\n\t\tunchecked {\n\t\t\trequire(b > 0, errorMessage);\n\t\t\treturn a / b;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * reverting with custom message when dividing by zero.\n\t *\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\n\t * message unnecessarily. For custom revert reasons use {tryMod}.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(\n\t\tuint a,\n\t\tuint b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint) {\n\t\tunchecked {\n\t\t\trequire(b > 0, errorMessage);\n\t\t\treturn a % b;\n\t\t}\n\t}\n}\n\n// \n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n\tfunction _msgSender() internal view virtual returns (address) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\n\t\treturn msg.data;\n\t}\n}\n\nabstract contract Ownable is Context {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor() {\n\t\t_setOwner(_msgSender());\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view virtual returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Leaves the contract without owner. It will not be possible to call\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\n\t *\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\n\t * thereby removing any functionality that is only available to the owner.\n\t */\n\tfunction renounceOwnership() public virtual onlyOwner {\n\t\t_setOwner(address(0));\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\t_setOwner(newOwner);\n\t}\n\n\tfunction _setOwner(address newOwner) private {\n\t\taddress oldOwner = _owner;\n\t\t_owner = newOwner;\n\t\temit OwnershipTransferred(oldOwner, newOwner);\n\t}\n}\n\ninterface IWETH is IERC20 {\n\t/// @notice Deposit ether to get wrapped ether\n\tfunction deposit() external payable;\n\n\t/// @notice Withdraw wrapped ether to get ether\n\tfunction withdraw(uint) external;\n}\n\nabstract contract Payment is IPayment, Ownable {\n\tusing SafeMath for uint;\n\tusing SafeERC20 for IERC20;\n\n\taddress public constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n\taddress public immutable WETH_ADDRESS;\n\taddress public admin;\n\treceive() external payable {}\n\n\tconstructor(address _WETH, address _admin) {\n\t\tWETH_ADDRESS = _WETH;\n\t\tadmin = _admin;\n\t}\n\n\tfunction approve(\n\t\taddress addressToApprove,\n\t\taddress token,\n\t\tuint amount\n\t) internal {\n\t\tif (IERC20(token).allowance(address(this), addressToApprove) < amount) {\n\t\t\tIERC20(token).safeApprove(addressToApprove, 0);\n\t\t\tIERC20(token).safeIncreaseAllowance(addressToApprove, amount);\n\t\t}\n\t}\n\n\tfunction balanceOf(address token) internal view returns (uint bal) {\n\t\tif (token == ETH_ADDRESS) {\n\t\t\ttoken = WETH_ADDRESS;\n\t\t}\n\n\t\tbal = IERC20(token).balanceOf(address(this));\n\t}\n\n\tfunction pay(\n\t\taddress recipient,\n\t\taddress token,\n\t\tuint amount\n\t) internal {\n\t\tif (amount > 0) {\n\t\t\tif (recipient == address(this)) {\n\t\t\t\tif (token == ETH_ADDRESS) {\n\t\t\t\t\tIWETH(WETH_ADDRESS).deposit{ value: amount }();\n\t\t\t\t} else {\n\t\t\t\t\tIERC20(token).safeTransferFrom(_msgSender(), address(this), amount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (token == ETH_ADDRESS) {\n\t\t\t\t\tif (balanceOf(WETH_ADDRESS) > 0) IWETH(WETH_ADDRESS).withdraw(balanceOf(WETH_ADDRESS));\n\t\t\t\t\tAddress.sendValue(payable(recipient), amount);\n\t\t\t\t} else {\n\t\t\t\t\tIERC20(token).safeTransfer(recipient, amount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction collectETH() public override returns (uint amount) {\n\t\tif (balanceOf(WETH_ADDRESS) > 0) {\n\t\t\tIWETH(WETH_ADDRESS).withdraw(balanceOf(WETH_ADDRESS));\n\t\t}\n\t\tif ((amount = address(this).balance) > 0) {\n\t\t\tAddress.sendValue(payable(admin), amount);\n\t\t}\n\t}\n\n\tfunction collectTokens(address token) public override returns (uint amount) {\n\t\tif (token == ETH_ADDRESS) {\n\t\t\tamount = collectETH();\n\t\t} else if ((amount = balanceOf(token)) > 0) {\n\t\t\tIERC20(token).safeTransfer(admin, amount);\n\t\t}\n\t}\n\n\tfunction setAdmin(address newAdmin) public override onlyOwner {\n\t\trequire(newAdmin != admin, \"A_I_E\"); // Admin is exist\n\t\tadmin = newAdmin;\n\t}\n}\n\n// \n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n// \ncontract forbitspaceX is IforbitspaceX, Payment, ReentrancyGuard {\n\tusing SafeMath for uint;\n\tusing Address for address;\n\n\tconstructor(address _WETH, address _admin) Payment(_WETH, _admin) {}\n\n\tfunction aggregate(\n\t\taddress tokenIn,\n\t\taddress tokenOut,\n\t\tuint amountInTotal,\n\t\taddress recipient,\n\t\tSwapParam[] calldata params\n\t) public payable override nonReentrant returns (uint amountInActual, uint amountOutActual) {\n\t\t// check invalid tokens address\n\t\trequire(!(tokenIn == tokenOut), \"I_T_A\");\n\t\trequire(!(tokenIn == ETH_ADDRESS && tokenOut == WETH_ADDRESS), \"I_T_A\");\n\t\trequire(!(tokenIn == WETH_ADDRESS && tokenOut == ETH_ADDRESS), \"I_T_A\");\n\n\t\t// check invalid value\n\t\tif (tokenIn == ETH_ADDRESS) {\n\t\t\tamountInTotal = msg.value;\n\t\t} else {\n\t\t\trequire(msg.value == 0, \"I_V\");\n\t\t}\n\t\trequire(amountInTotal > 0, \"I_V\");\n\n\t\t// receive tokens\n\t\tpay(address(this), tokenIn, amountInTotal);\n\n\t\t// amountAcutual before\n\t\tuint amountInBefore = balanceOf(tokenIn);\n\t\tamountOutActual = balanceOf(tokenOut);\n\n\t\t// call swap on multi dexs\n\t\t_swap(params);\n\n\t\t// amountAcutual after\n\t\tamountInActual = amountInBefore.sub(balanceOf(tokenIn));\n\t\tamountOutActual = balanceOf(tokenOut).sub(amountOutActual);\n\n\t\trequire((amountInActual > 0) && (amountOutActual > 0), \"I_A_T_A\"); // incorrect actual total amounts\n\n\t\t// refund tokens\n\t\tpay(_msgSender(), tokenIn, amountInBefore.sub(amountInActual, \"N_E_T\")); // not enough tokens\n\t\tpay(recipient, tokenOut, amountOutActual.mul(9995).div(10000)); // 0.05% fee\n\n\t\t// sweep tokens for owner\n\t\tcollectTokens(tokenIn);\n\t\tcollectTokens(tokenOut);\n\t}\n\n\tfunction _swap(SwapParam[] calldata params) private {\n\t\tfor (uint i = 0; i < params.length; i++) {\n\t\t\tSwapParam calldata p = params[i];\n\t\t\t(\n\t\t\t\taddress exchangeTarget,\n\t\t\t\taddress addressToApprove,\n\t\t\t\taddress tokenIn,\n\t\t\t\taddress tokenOut,\n\t\t\t\tbytes calldata swapData\n\t\t\t) = (p.exchangeTarget, p.addressToApprove, p.tokenIn, p.tokenOut, p.swapData);\n\n\t\t\t// approve(addressToApprove, tokenIn, type(uint).max);\n\t\t\tapprove(addressToApprove, tokenIn, balanceOf(tokenIn));\n\n\t\t\tuint amountInActual = balanceOf(tokenIn);\n\t\t\tuint amountOutActual = balanceOf(tokenOut);\n\n\t\t\texchangeTarget.functionCall(swapData, \"L_C_F\"); // low-level call failed\n\n\t\t\t// amountInActual = amountInActual.sub(balanceOf(tokenIn));\n\t\t\t// amountOutActual = balanceOf(tokenOut).sub(amountOutActual);\n\n\t\t\tbool success = ((balanceOf(tokenIn) < amountInActual) && (balanceOf(tokenOut) > amountOutActual));\n\n\t\t\trequire(success, \"I_A_A\"); // incorrect actual amounts\n\t\t}\n\t}\n}"
    }
  }
}