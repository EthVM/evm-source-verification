{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ESM.sol": {
      "content": "pragma solidity ^0.5.12;\r\n\r\ncontract VatFab {\r\n    function newVat() public returns (Vat vat) {\r\n        vat = new Vat();\r\n        vat.rely(msg.sender);\r\n        vat.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract JugFab {\r\n    function newJug(address vat) public returns (Jug jug) {\r\n        jug = new Jug(vat);\r\n        jug.rely(msg.sender);\r\n        jug.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract VowFab {\r\n    function newVow(address vat, address flap, address flop) public returns (Vow vow) {\r\n        vow = new Vow(vat, flap, flop);\r\n        vow.rely(msg.sender);\r\n        vow.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract CatFab {\r\n    function newCat(address vat) public returns (Cat cat) {\r\n        cat = new Cat(vat);\r\n        cat.rely(msg.sender);\r\n        cat.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract DaiFab {\r\n    function newDai(uint chainId) public returns (Dai dai) {\r\n        dai = new Dai(chainId);\r\n        dai.rely(msg.sender);\r\n        dai.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract DaiJoinFab {\r\n    function newDaiJoin(address vat, address dai) public returns (DaiJoin daiJoin) {\r\n        daiJoin = new DaiJoin(vat, dai);\r\n    }\r\n}\r\n\r\ncontract FlapFab {\r\n    function newFlap(address vat, address gov) public returns (Flapper flap) {\r\n        flap = new Flapper(vat, gov);\r\n        flap.rely(msg.sender);\r\n        flap.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract FlopFab {\r\n    function newFlop(address vat, address gov) public returns (Flopper flop) {\r\n        flop = new Flopper(vat, gov);\r\n        flop.rely(msg.sender);\r\n        flop.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract FlipFab {\r\n    function newFlip(address vat, bytes32 ilk) public returns (Flipper flip) {\r\n        flip = new Flipper(vat, ilk);\r\n        flip.rely(msg.sender);\r\n        flip.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract SpotFab {\r\n    function newSpotter(address vat) public returns (Spotter spotter) {\r\n        spotter = new Spotter(vat);\r\n        spotter.rely(msg.sender);\r\n        spotter.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract PotFab {\r\n    function newPot(address vat) public returns (Pot pot) {\r\n        pot = new Pot(vat);\r\n        pot.rely(msg.sender);\r\n        pot.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract EndFab {\r\n    function newEnd() public returns (End end) {\r\n        end = new End();\r\n        end.rely(msg.sender);\r\n        end.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract ESMFab {\r\n    function newESM(address gov, address end, address pit, uint min) public returns (ESM esm) {\r\n        esm = new ESM(gov, end, pit, min);\r\n    }\r\n}\r\n\r\ncontract PauseFab {\r\n    function newPause(uint delay, address owner, DSAuthority authority) public returns(DSPause pause) {\r\n        pause = new DSPause(delay, owner, authority);\r\n    }\r\n}\r\n\r\ncontract GemLikeESM {\r\n    function balanceOf(address) public view returns (uint256);\r\n    function transfer(address, uint256) public returns (bool);\r\n    function transferFrom(address, address, uint256) public returns (bool);\r\n}\r\n\r\ncontract EndLike {\r\n    function cage() public;\r\n}\r\n\r\ncontract ESM {\r\n    GemLikeESM public gem; // collateral\r\n    EndLike public end; // cage module\r\n    address public pit; // burner\r\n    uint256 public min; // threshold\r\n    uint256 public fired;\r\n\r\n    mapping(address => uint256) public sum; // per-address balance\r\n    uint256 public Sum; // total balance\r\n\r\n    // --- Logs ---\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  usr,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an 'anonymous' event with a constant 6 words of calldata\r\n            // and four indexed topics: selector, caller, arg1 and arg2\r\n            let mark := msize                         // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 caller,                              // msg.sender\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36)                     // arg2\r\n                )\r\n        }\r\n    }\r\n\r\n    constructor(address gem_, address end_, address pit_, uint256 min_) public {\r\n        gem = GemLikeESM(gem_);\r\n        end = EndLike(end_);\r\n        pit = pit_;\r\n        min = min_;\r\n    }\r\n\r\n    // -- math --\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x + y;\r\n        require(z >= x);\r\n    }\r\n\r\n    function fire() external note {\r\n        require(fired == 0,  \"esm/already-fired\");\r\n        require(Sum >= min,  \"esm/min-not-reached\");\r\n\r\n        end.cage();\r\n\r\n        fired = 1;\r\n    }\r\n\r\n    function join(uint256 wad) external note {\r\n        require(fired == 0, \"esm/already-fired\");\r\n\r\n        sum[msg.sender] = add(sum[msg.sender], wad);\r\n        Sum = add(Sum, wad);\r\n\r\n        require(gem.transferFrom(msg.sender, pit, wad), \"esm/transfer-failed\");\r\n    }\r\n}\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DssDeploy is DSAuth {\r\n    VatFab     public vatFab;\r\n    JugFab     public jugFab;\r\n    VowFab     public vowFab;\r\n    CatFab     public catFab;\r\n    DaiFab     public daiFab;\r\n    DaiJoinFab public daiJoinFab;\r\n    FlapFab    public flapFab;\r\n    FlopFab    public flopFab;\r\n    FlipFab    public flipFab;\r\n    SpotFab    public spotFab;\r\n    PotFab     public potFab;\r\n    EndFab     public endFab;\r\n    ESMFab     public esmFab;\r\n    PauseFab   public pauseFab;\r\n\r\n    Vat     public vat;\r\n    Jug     public jug;\r\n    Vow     public vow;\r\n    Cat     public cat;\r\n    Dai     public dai;\r\n    DaiJoin public daiJoin;\r\n    Flapper public flap;\r\n    Flopper public flop;\r\n    Spotter public spotter;\r\n    Pot     public pot;\r\n    End     public end;\r\n    ESM     public esm;\r\n    DSPause public pause;\r\n\r\n    mapping(bytes32 => Ilk) public ilks;\r\n\r\n    uint8 public step = 0;\r\n\r\n    uint256 constant ONE = 10 ** 27;\r\n\r\n    struct Ilk {\r\n        Flipper flip;\r\n        address join;\r\n    }\r\n\r\n    constructor(\r\n        VatFab vatFab_,\r\n        JugFab jugFab_,\r\n        VowFab vowFab_,\r\n        CatFab catFab_,\r\n        DaiFab daiFab_,\r\n        DaiJoinFab daiJoinFab_,\r\n        FlapFab flapFab_,\r\n        FlopFab flopFab_,\r\n        FlipFab flipFab_,\r\n        SpotFab spotFab_,\r\n        PotFab potFab_,\r\n        EndFab endFab_,\r\n        ESMFab esmFab_,\r\n        PauseFab pauseFab_\r\n    ) public {\r\n        vatFab = vatFab_;\r\n        jugFab = jugFab_;\r\n        vowFab = vowFab_;\r\n        catFab = catFab_;\r\n        daiFab = daiFab_;\r\n        daiJoinFab = daiJoinFab_;\r\n        flapFab = flapFab_;\r\n        flopFab = flopFab_;\r\n        flipFab = flipFab_;\r\n        spotFab = spotFab_;\r\n        potFab = potFab_;\r\n        endFab = endFab_;\r\n        esmFab = esmFab_;\r\n        pauseFab = pauseFab_;\r\n    }\r\n\r\n    function rad(uint wad) internal pure returns (uint) {\r\n        return wad * 10 ** 27;\r\n    }\r\n\r\n    function deployVat() public auth {\r\n        require(address(vat) == address(0), \"VAT already deployed\");\r\n        vat = vatFab.newVat();\r\n        spotter = spotFab.newSpotter(address(vat));\r\n\r\n        // Internal auth\r\n        vat.rely(address(spotter));\r\n    }\r\n\r\n    function deployDai(uint256 chainId) public auth {\r\n        require(address(vat) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy\r\n        dai = daiFab.newDai(chainId);\r\n        daiJoin = daiJoinFab.newDaiJoin(address(vat), address(dai));\r\n        dai.rely(address(daiJoin));\r\n    }\r\n\r\n    function deployTaxation() public auth {\r\n        require(address(vat) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy\r\n        jug = jugFab.newJug(address(vat));\r\n        pot = potFab.newPot(address(vat));\r\n\r\n        // Internal auth\r\n        vat.rely(address(jug));\r\n        vat.rely(address(pot));\r\n    }\r\n\r\n    function deployAuctions(address gov) public auth {\r\n        require(gov != address(0), \"Missing GOV address\");\r\n        require(address(jug) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy\r\n        flap = flapFab.newFlap(address(vat), gov);\r\n        flop = flopFab.newFlop(address(vat), gov);\r\n        vow = vowFab.newVow(address(vat), address(flap), address(flop));\r\n\r\n        // Internal references set up\r\n        jug.file(\"vow\", address(vow));\r\n        pot.file(\"vow\", address(vow));\r\n\r\n        // Internal auth\r\n        flap.rely(address(vow));\r\n        flop.rely(address(vow));\r\n    }\r\n\r\n    function deployLiquidator() public auth {\r\n        require(address(vow) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy\r\n        cat = catFab.newCat(address(vat));\r\n\r\n        // Internal references set up\r\n        cat.file(\"vow\", address(vow));\r\n\r\n        // Internal auth\r\n        vat.rely(address(cat));\r\n        vow.rely(address(cat));\r\n    }\r\n\r\n    function deployShutdown(address gov, address pit, uint256 min) public auth {\r\n        require(address(cat) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy\r\n        end = endFab.newEnd();\r\n\r\n        // Internal references set up\r\n        end.file(\"vat\", address(vat));\r\n        end.file(\"cat\", address(cat));\r\n        end.file(\"vow\", address(vow));\r\n        end.file(\"pot\", address(pot));\r\n        end.file(\"spot\", address(spotter));\r\n\r\n        // Internal auth\r\n        vat.rely(address(end));\r\n        cat.rely(address(end));\r\n        vow.rely(address(end));\r\n        pot.rely(address(end));\r\n        spotter.rely(address(end));\r\n\r\n        // Deploy ESM\r\n        esm = esmFab.newESM(gov, address(end), address(pit), min);\r\n        end.rely(address(esm));\r\n    }\r\n\r\n    function deployPause(uint delay, DSAuthority authority) public auth {\r\n        require(address(dai) != address(0), \"Missing previous step\");\r\n        require(address(end) != address(0), \"Missing previous step\");\r\n\r\n        pause = pauseFab.newPause(delay, address(0), authority);\r\n\r\n        vat.rely(address(pause.proxy()));\r\n        cat.rely(address(pause.proxy()));\r\n        vow.rely(address(pause.proxy()));\r\n        jug.rely(address(pause.proxy()));\r\n        pot.rely(address(pause.proxy()));\r\n        spotter.rely(address(pause.proxy()));\r\n        flap.rely(address(pause.proxy()));\r\n        flop.rely(address(pause.proxy()));\r\n        end.rely(address(pause.proxy()));\r\n    }\r\n\r\n    function deployCollateral(bytes32 ilk, address join, address pip) public auth {\r\n        require(ilk != bytes32(\"\"), \"Missing ilk name\");\r\n        require(join != address(0), \"Missing join address\");\r\n        require(pip != address(0), \"Missing pip address\");\r\n        require(address(pause) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy\r\n        ilks[ilk].flip = flipFab.newFlip(address(vat), ilk);\r\n        ilks[ilk].join = join;\r\n        Spotter(spotter).file(ilk, \"pip\", address(pip)); // Set pip\r\n\r\n        // Internal references set up\r\n        cat.file(ilk, \"flip\", address(ilks[ilk].flip));\r\n        vat.init(ilk);\r\n        jug.init(ilk);\r\n\r\n        // Internal auth\r\n        vat.rely(join);\r\n        ilks[ilk].flip.rely(address(cat));\r\n        ilks[ilk].flip.rely(address(end));\r\n        ilks[ilk].flip.rely(address(pause.proxy()));\r\n    }\r\n\r\n    function releaseAuth() public auth {\r\n        vat.deny(address(this));\r\n        cat.deny(address(this));\r\n        vow.deny(address(this));\r\n        jug.deny(address(this));\r\n        pot.deny(address(this));\r\n        dai.deny(address(this));\r\n        spotter.deny(address(this));\r\n        flap.deny(address(this));\r\n        flop.deny(address(this));\r\n        end.deny(address(this));\r\n    }\r\n\r\n    function releaseAuthFlip(bytes32 ilk) public auth {\r\n        ilks[ilk].flip.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract Kicker {\r\n    function kick(address urn, address gal, uint tab, uint lot, uint bid)\r\n        public returns (uint);\r\n}\r\n\r\ncontract VatLikeCat {\r\n    function ilks(bytes32) external view returns (\r\n        uint256 Art,   // wad\r\n        uint256 rate,  // ray\r\n        uint256 spot   // ray\r\n    );\r\n    function urns(bytes32,address) external view returns (\r\n        uint256 ink,   // wad\r\n        uint256 art    // wad\r\n    );\r\n    function grab(bytes32,address,address,address,int,int) external;\r\n    function hope(address) external;\r\n    function nope(address) external;\r\n}\r\n\r\ncontract VowLike {\r\n    function fess(uint) external;\r\n}\r\n\r\ncontract VatLikeEnd {\r\n    function dai(address) external view returns (uint256);\r\n    function ilks(bytes32 ilk) external returns (\r\n        uint256 Art,\r\n        uint256 rate,\r\n        uint256 spot,\r\n        uint256 line,\r\n        uint256 dust\r\n    );\r\n    function urns(bytes32 ilk, address urn) external returns (\r\n        uint256 ink,\r\n        uint256 art\r\n    );\r\n    function debt() external returns (uint256);\r\n    function move(address src, address dst, uint256 rad) external;\r\n    function hope(address) external;\r\n    function flux(bytes32 ilk, address src, address dst, uint256 rad) external;\r\n    function grab(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external;\r\n    function suck(address u, address v, uint256 rad) external;\r\n    function cage() external;\r\n}\r\n\r\ncontract CatLike {\r\n    function ilks(bytes32) external returns (\r\n        address flip,  // Liquidator\r\n        uint256 chop,  // Liquidation Penalty   [ray]\r\n        uint256 lump   // Liquidation Quantity  [rad]\r\n    );\r\n    function cage() external;\r\n}\r\n\r\ncontract PotLike {\r\n    function cage() external;\r\n}\r\n\r\ncontract VowLikeEnd {\r\n    function cage() external;\r\n}\r\n\r\ncontract Flippy {\r\n    function bids(uint id) external view returns (\r\n        uint256 bid,\r\n        uint256 lot,\r\n        address guy,\r\n        uint48  tic,\r\n        uint48  end,\r\n        address usr,\r\n        address gal,\r\n        uint256 tab\r\n    );\r\n    function yank(uint id) external;\r\n}\r\n\r\ncontract PipLike {\r\n    function read() external view returns (bytes32);\r\n}\r\n\r\ncontract Spotty {\r\n    function par() external view returns (uint256);\r\n    function ilks(bytes32) external view returns (\r\n        PipLike pip,\r\n        uint256 mat\r\n    );\r\n    function cage() external;\r\n}\r\n\r\ncontract VatLikeFlap {\r\n    function move(address,address,uint) external;\r\n}\r\n\r\ncontract GemLikeFlap {\r\n    function move(address,address,uint) external;\r\n    function burn(address,uint) external;\r\n}\r\n\r\ncontract VatLikeFlip {\r\n    function move(address,address,uint) external;\r\n    function flux(bytes32,address,address,uint) external;\r\n}\r\n\r\ncontract VatLikeFlop {\r\n    function move(address,address,uint) external;\r\n}\r\n\r\ncontract GemLikeFlop {\r\n    function mint(address,uint) external;\r\n}\r\n\r\ncontract GemLike {\r\n    function decimals() public view returns (uint);\r\n    function transfer(address,uint) external returns (bool);\r\n    function transferFrom(address,address,uint) external returns (bool);\r\n}\r\n\r\ncontract DSTokenLike {\r\n    function mint(address,uint) external;\r\n    function burn(address,uint) external;\r\n}\r\n\r\ncontract VatLikeJoin {\r\n    function slip(bytes32,address,int) external;\r\n    function move(address,address,uint) external;\r\n}\r\n\r\ncontract VatLikeJug {\r\n    function ilks(bytes32) external returns (\r\n        uint256 Art,   // wad\r\n        uint256 rate   // ray\r\n    );\r\n    function fold(bytes32,address,int) external;\r\n}\r\n\r\ncontract LibNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  usr,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an 'anonymous' event with a constant 6 words of calldata\r\n            // and four indexed topics: selector, caller, arg1 and arg2\r\n            let mark := msize                         // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 caller,                              // msg.sender\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36)                     // arg2\r\n                )\r\n        }\r\n    }\r\n}\r\n\r\ncontract Cat is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Cat/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        address flip;  // Liquidator\r\n        uint256 chop;  // Liquidation Penalty   [ray]\r\n        uint256 lump;  // Liquidation Quantity  [wad]\r\n    }\r\n\r\n    mapping (bytes32 => Ilk) public ilks;\r\n\r\n    uint256 public live;\r\n    VatLikeCat public vat;\r\n    VowLike public vow;\r\n\r\n    // --- Events ---\r\n    event Bite(\r\n      bytes32 indexed ilk,\r\n      address indexed urn,\r\n      uint256 ink,\r\n      uint256 art,\r\n      uint256 tab,\r\n      address flip,\r\n      uint256 id\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = VatLikeCat(vat_);\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    uint constant ONE = 10 ** 27;\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, y) / ONE;\r\n    }\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        if (x > y) { z = y; } else { z = x; }\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, address data) external note auth {\r\n        if (what == \"vow\") vow = VowLike(data);\r\n        else revert(\"Cat/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\r\n        if (what == \"chop\") ilks[ilk].chop = data;\r\n        else if (what == \"lump\") ilks[ilk].lump = data;\r\n        else revert(\"Cat/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, address flip) external note auth {\r\n        if (what == \"flip\") {\r\n            vat.nope(ilks[ilk].flip);\r\n            ilks[ilk].flip = flip;\r\n            vat.hope(flip);\r\n        }\r\n        else revert(\"Cat/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- CDP Liquidation ---\r\n    function bite(bytes32 ilk, address urn) external returns (uint id) {\r\n        (, uint rate, uint spot) = vat.ilks(ilk);\r\n        (uint ink, uint art) = vat.urns(ilk, urn);\r\n\r\n        require(live == 1, \"Cat/not-live\");\r\n        require(spot > 0 && mul(ink, spot) < mul(art, rate), \"Cat/not-unsafe\");\r\n\r\n        uint lot = min(ink, ilks[ilk].lump);\r\n        art      = min(art, mul(lot, art) / ink);\r\n\r\n        require(lot <= 2**255 && art <= 2**255, \"Cat/overflow\");\r\n        vat.grab(ilk, urn, address(this), address(vow), -int(lot), -int(art));\r\n\r\n        vow.fess(mul(art, rate));\r\n        id = Kicker(ilks[ilk].flip).kick({ urn: urn\r\n                                         , gal: address(vow)\r\n                                         , tab: rmul(mul(art, rate), ilks[ilk].chop)\r\n                                         , lot: lot\r\n                                         , bid: 0\r\n                                         });\r\n\r\n        emit Bite(ilk, urn, lot, art, mul(art, rate), ilks[ilk].flip, id);\r\n    }\r\n\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n}\r\n\r\ncontract Dai is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1; }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Dai/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- ERC20 Data ---\r\n    string  public constant name     = \"Dai Stablecoin\";\r\n    string  public constant symbol   = \"DAI\";\r\n    string  public constant version  = \"1\";\r\n    uint8   public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => uint)                      public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n    mapping (address => uint)                      public nonces;\r\n\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n\r\n    // --- Math ---\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    // --- EIP712 niceties ---\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\r\n\r\n    constructor(uint256 chainId_) public {\r\n        wards[msg.sender] = 1;\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n            keccak256(bytes(name)),\r\n            keccak256(bytes(version)),\r\n            chainId_,\r\n            address(this)\r\n        ));\r\n    }\r\n\r\n    // --- Token ---\r\n    function transfer(address dst, uint wad) external returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad, \"Dai/insufficient-balance\");\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad, \"Dai/insufficient-allowance\");\r\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\r\n        }\r\n        balanceOf[src] = sub(balanceOf[src], wad);\r\n        balanceOf[dst] = add(balanceOf[dst], wad);\r\n        emit Transfer(src, dst, wad);\r\n        return true;\r\n    }\r\n    function mint(address usr, uint wad) external auth {\r\n        balanceOf[usr] = add(balanceOf[usr], wad);\r\n        totalSupply    = add(totalSupply, wad);\r\n        emit Transfer(address(0), usr, wad);\r\n    }\r\n    function burn(address usr, uint wad) external {\r\n        require(balanceOf[usr] >= wad, \"Dai/insufficient-balance\");\r\n        if (usr != msg.sender && allowance[usr][msg.sender] != uint(-1)) {\r\n            require(allowance[usr][msg.sender] >= wad, \"Dai/insufficient-allowance\");\r\n            allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\r\n        }\r\n        balanceOf[usr] = sub(balanceOf[usr], wad);\r\n        totalSupply    = sub(totalSupply, wad);\r\n        emit Transfer(usr, address(0), wad);\r\n    }\r\n    function approve(address usr, uint wad) external returns (bool) {\r\n        allowance[msg.sender][usr] = wad;\r\n        emit Approval(msg.sender, usr, wad);\r\n        return true;\r\n    }\r\n\r\n    // --- Alias ---\r\n    function push(address usr, uint wad) external {\r\n        transferFrom(msg.sender, usr, wad);\r\n    }\r\n    function pull(address usr, uint wad) external {\r\n        transferFrom(usr, msg.sender, wad);\r\n    }\r\n    function move(address src, address dst, uint wad) external {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n    // --- Approve by signature ---\r\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\r\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external\r\n    {\r\n        bytes32 digest =\r\n            keccak256(abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH,\r\n                                     holder,\r\n                                     spender,\r\n                                     nonce,\r\n                                     expiry,\r\n                                     allowed))\r\n        ));\r\n\r\n        require(holder != address(0), \"Dai/invalid-address-0\");\r\n        require(holder == ecrecover(digest, v, r, s), \"Dai/invalid-permit\");\r\n        require(expiry == 0 || now <= expiry, \"Dai/permit-expired\");\r\n        require(nonce == nonces[holder]++, \"Dai/invalid-nonce\");\r\n        uint wad = allowed ? uint(-1) : 0;\r\n        allowance[holder][spender] = wad;\r\n        emit Approval(holder, spender, wad);\r\n    }\r\n}\r\n\r\ncontract End is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1; }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"End/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    VatLikeEnd  public vat;\r\n    CatLike  public cat;\r\n    VowLikeEnd  public vow;\r\n    PotLike  public pot;\r\n    Spotty   public spot;\r\n\r\n    uint256  public live;  // cage flag\r\n    uint256  public when;  // time of cage\r\n    uint256  public wait;  // processing cooldown length\r\n    uint256  public debt;  // total outstanding dai following processing [rad]\r\n\r\n    mapping (bytes32 => uint256) public tag;  // cage price           [ray]\r\n    mapping (bytes32 => uint256) public gap;  // collateral shortfall [wad]\r\n    mapping (bytes32 => uint256) public Art;  // total debt per ilk   [wad]\r\n    mapping (bytes32 => uint256) public fix;  // final cash price     [ray]\r\n\r\n    mapping (address => uint256)                      public bag;  // [wad]\r\n    mapping (bytes32 => mapping (address => uint256)) public out;  // [wad]\r\n\r\n    // --- Init ---\r\n    constructor() public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        z = x + y;\r\n        require(z >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, y) / RAY;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, RAY) / y;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, WAD) / y;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, address data) external note auth {\r\n        require(live == 1, \"End/not-live\");\r\n        if (what == \"vat\")  vat = VatLikeEnd(data);\r\n        else if (what == \"cat\")  cat = CatLike(data);\r\n        else if (what == \"vow\")  vow = VowLikeEnd(data);\r\n        else if (what == \"pot\")  pot = PotLike(data);\r\n        else if (what == \"spot\") spot = Spotty(data);\r\n        else revert(\"End/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 what, uint256 data) external note auth {\r\n        require(live == 1, \"End/not-live\");\r\n        if (what == \"wait\") wait = data;\r\n        else revert(\"End/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- Settlement ---\r\n    function cage() external note auth {\r\n        require(live == 1, \"End/not-live\");\r\n        live = 0;\r\n        when = now;\r\n        vat.cage();\r\n        cat.cage();\r\n        vow.cage();\r\n        spot.cage();\r\n        pot.cage();\r\n    }\r\n\r\n    function cage(bytes32 ilk) external note {\r\n        require(live == 0, \"End/still-live\");\r\n        require(tag[ilk] == 0, \"End/tag-ilk-already-defined\");\r\n        (Art[ilk],,,,) = vat.ilks(ilk);\r\n        (PipLike pip,) = spot.ilks(ilk);\r\n        // par is a ray, pip returns a wad\r\n        tag[ilk] = wdiv(spot.par(), uint(pip.read()));\r\n    }\r\n\r\n    function skip(bytes32 ilk, uint256 id) external note {\r\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\r\n\r\n        (address flipV,,) = cat.ilks(ilk);\r\n        Flippy flip = Flippy(flipV);\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        (uint bid, uint lot,,,, address usr,, uint tab) = flip.bids(id);\r\n\r\n        vat.suck(address(vow), address(vow),  tab);\r\n        vat.suck(address(vow), address(this), bid);\r\n        vat.hope(address(flip));\r\n        flip.yank(id);\r\n\r\n        uint art = tab / rate;\r\n        Art[ilk] = add(Art[ilk], art);\r\n        require(int(lot) >= 0 && int(art) >= 0, \"End/overflow\");\r\n        vat.grab(ilk, usr, address(this), address(vow), int(lot), int(art));\r\n    }\r\n\r\n    function skim(bytes32 ilk, address urn) external note {\r\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        (uint ink, uint art) = vat.urns(ilk, urn);\r\n\r\n        uint owe = rmul(rmul(art, rate), tag[ilk]);\r\n        uint wad = min(ink, owe);\r\n        gap[ilk] = add(gap[ilk], sub(owe, wad));\r\n\r\n        require(wad <= 2**255 && art <= 2**255, \"End/overflow\");\r\n        vat.grab(ilk, urn, address(this), address(vow), -int(wad), -int(art));\r\n    }\r\n\r\n    function free(bytes32 ilk) external note {\r\n        require(live == 0, \"End/still-live\");\r\n        (uint ink, uint art) = vat.urns(ilk, msg.sender);\r\n        require(art == 0, \"End/art-not-zero\");\r\n        require(ink <= 2**255, \"End/overflow\");\r\n        vat.grab(ilk, msg.sender, msg.sender, address(vow), -int(ink), 0);\r\n    }\r\n\r\n    function thaw() external note {\r\n        require(live == 0, \"End/still-live\");\r\n        require(debt == 0, \"End/debt-not-zero\");\r\n        require(vat.dai(address(vow)) == 0, \"End/surplus-not-zero\");\r\n        require(now >= add(when, wait), \"End/wait-not-finished\");\r\n        debt = vat.debt();\r\n    }\r\n    function flow(bytes32 ilk) external note {\r\n        require(debt != 0, \"End/debt-zero\");\r\n        require(fix[ilk] == 0, \"End/fix-ilk-already-defined\");\r\n\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        uint256 wad = rmul(rmul(Art[ilk], rate), tag[ilk]);\r\n        fix[ilk] = rdiv(mul(sub(wad, gap[ilk]), RAY), debt);\r\n    }\r\n\r\n    function pack(uint256 wad) external note {\r\n        require(debt != 0, \"End/debt-zero\");\r\n        vat.move(msg.sender, address(vow), mul(wad, RAY));\r\n        bag[msg.sender] = add(bag[msg.sender], wad);\r\n    }\r\n    function cash(bytes32 ilk, uint wad) external note {\r\n        require(fix[ilk] != 0, \"End/fix-ilk-not-defined\");\r\n        vat.flux(ilk, address(this), msg.sender, rmul(wad, fix[ilk]));\r\n        out[ilk][msg.sender] = add(out[ilk][msg.sender], wad);\r\n        require(out[ilk][msg.sender] <= bag[msg.sender], \"End/insufficient-bag-balance\");\r\n    }\r\n}\r\n\r\ncontract Flapper is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Flapper/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Bid {\r\n        uint256 bid;\r\n        uint256 lot;\r\n        address guy;  // high bidder\r\n        uint48  tic;  // expiry time\r\n        uint48  end;\r\n    }\r\n\r\n    mapping (uint => Bid) public bids;\r\n\r\n    VatLikeFlap  public   vat;\r\n    GemLikeFlap  public   gem;\r\n\r\n    uint256  constant ONE = 1.00E18;\r\n    uint256  public   beg = 1.05E18;  // 5% minimum bid increase\r\n    uint48   public   ttl = 3 hours;  // 3 hours bid duration\r\n    uint48   public   tau = 2 days;   // 2 days total auction length\r\n    uint256  public kicks = 0;\r\n    uint256  public live;\r\n\r\n    // --- Events ---\r\n    event Kick(\r\n      uint256 id,\r\n      uint256 lot,\r\n      uint256 bid\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, address gem_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = VatLikeFlap(vat_);\r\n        gem = GemLikeFlap(gem_);\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Admin ---\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \"beg\") beg = data;\r\n        else if (what == \"ttl\") ttl = uint48(data);\r\n        else if (what == \"tau\") tau = uint48(data);\r\n        else revert(\"Flapper/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- Auction ---\r\n    function kick(uint lot, uint bid) external auth returns (uint id) {\r\n        require(live == 1, \"Flapper/not-live\");\r\n        require(kicks < uint(-1), \"Flapper/overflow\");\r\n        id = ++kicks;\r\n\r\n        bids[id].bid = bid;\r\n        bids[id].lot = lot;\r\n        bids[id].guy = msg.sender; // configurable??\r\n        bids[id].end = add(uint48(now), tau);\r\n\r\n        vat.move(msg.sender, address(this), lot);\r\n\r\n        emit Kick(id, lot, bid);\r\n    }\r\n    function tick(uint id) external note {\r\n        require(bids[id].end < now, \"Flapper/not-finished\");\r\n        require(bids[id].tic == 0, \"Flapper/bid-already-placed\");\r\n        bids[id].end = add(uint48(now), tau);\r\n    }\r\n    function tend(uint id, uint lot, uint bid) external note {\r\n        require(live == 1, \"Flapper/not-live\");\r\n        require(bids[id].guy != address(0), \"Flapper/guy-not-set\");\r\n        require(bids[id].tic > now || bids[id].tic == 0, \"Flapper/already-finished-tic\");\r\n        require(bids[id].end > now, \"Flapper/already-finished-end\");\r\n\r\n        require(lot == bids[id].lot, \"Flapper/lot-not-matching\");\r\n        require(bid >  bids[id].bid, \"Flapper/bid-not-higher\");\r\n        require(mul(bid, ONE) >= mul(beg, bids[id].bid), \"Flapper/insufficient-increase\");\r\n\r\n        gem.move(msg.sender, bids[id].guy, bids[id].bid);\r\n        gem.move(msg.sender, address(this), bid - bids[id].bid);\r\n\r\n        bids[id].guy = msg.sender;\r\n        bids[id].bid = bid;\r\n        bids[id].tic = add(uint48(now), ttl);\r\n    }\r\n    function deal(uint id) external note {\r\n        require(live == 1, \"Flapper/not-live\");\r\n        require(bids[id].tic != 0 && (bids[id].tic < now || bids[id].end < now), \"Flapper/not-finished\");\r\n        vat.move(address(this), bids[id].guy, bids[id].lot);\r\n        gem.burn(address(this), bids[id].bid);\r\n        delete bids[id];\r\n    }\r\n\r\n    function cage(uint rad) external note auth {\r\n       live = 0;\r\n       vat.move(address(this), msg.sender, rad);\r\n    }\r\n    function yank(uint id) external note {\r\n        require(live == 0, \"Flapper/still-live\");\r\n        require(bids[id].guy != address(0), \"Flapper/guy-not-set\");\r\n        gem.move(address(this), bids[id].guy, bids[id].bid);\r\n        delete bids[id];\r\n    }\r\n}\r\n\r\ncontract Flipper is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Flipper/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Bid {\r\n        uint256 bid;\r\n        uint256 lot;\r\n        address guy;  // high bidder\r\n        uint48  tic;  // expiry time\r\n        uint48  end;\r\n        address usr;\r\n        address gal;\r\n        uint256 tab;\r\n    }\r\n\r\n    mapping (uint => Bid) public bids;\r\n\r\n    VatLikeFlip public   vat;\r\n    bytes32 public   ilk;\r\n\r\n    uint256 constant ONE = 1.00E18;\r\n    uint256 public   beg = 1.05E18;  // 5% minimum bid increase\r\n    uint48  public   ttl = 3 hours;  // 3 hours bid duration\r\n    uint48  public   tau = 2 days;   // 2 days total auction length\r\n    uint256 public kicks = 0;\r\n\r\n    // --- Events ---\r\n    event Kick(\r\n      uint256 id,\r\n      uint256 lot,\r\n      uint256 bid,\r\n      uint256 tab,\r\n      address indexed usr,\r\n      address indexed gal\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, bytes32 ilk_) public {\r\n        vat = VatLikeFlip(vat_);\r\n        ilk = ilk_;\r\n        wards[msg.sender] = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Admin ---\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \"beg\") beg = data;\r\n        else if (what == \"ttl\") ttl = uint48(data);\r\n        else if (what == \"tau\") tau = uint48(data);\r\n        else revert(\"Flipper/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- Auction ---\r\n    function kick(address usr, address gal, uint tab, uint lot, uint bid)\r\n        public auth returns (uint id)\r\n    {\r\n        require(kicks < uint(-1), \"Flipper/overflow\");\r\n        id = ++kicks;\r\n\r\n        bids[id].bid = bid;\r\n        bids[id].lot = lot;\r\n        bids[id].guy = msg.sender; // configurable??\r\n        bids[id].end = add(uint48(now), tau);\r\n        bids[id].usr = usr;\r\n        bids[id].gal = gal;\r\n        bids[id].tab = tab;\r\n\r\n        vat.flux(ilk, msg.sender, address(this), lot);\r\n\r\n        emit Kick(id, lot, bid, tab, usr, gal);\r\n    }\r\n    function tick(uint id) external note {\r\n        require(bids[id].end < now, \"Flipper/not-finished\");\r\n        require(bids[id].tic == 0, \"Flipper/bid-already-placed\");\r\n        bids[id].end = add(uint48(now), tau);\r\n    }\r\n    function tend(uint id, uint lot, uint bid) external note {\r\n        require(bids[id].guy != address(0), \"Flipper/guy-not-set\");\r\n        require(bids[id].tic > now || bids[id].tic == 0, \"Flipper/already-finished-tic\");\r\n        require(bids[id].end > now, \"Flipper/already-finished-end\");\r\n\r\n        require(lot == bids[id].lot, \"Flipper/lot-not-matching\");\r\n        require(bid <= bids[id].tab, \"Flipper/higher-than-tab\");\r\n        require(bid >  bids[id].bid, \"Flipper/bid-not-higher\");\r\n        require(mul(bid, ONE) >= mul(beg, bids[id].bid) || bid == bids[id].tab, \"Flipper/insufficient-increase\");\r\n\r\n        vat.move(msg.sender, bids[id].guy, bids[id].bid);\r\n        vat.move(msg.sender, bids[id].gal, bid - bids[id].bid);\r\n\r\n        bids[id].guy = msg.sender;\r\n        bids[id].bid = bid;\r\n        bids[id].tic = add(uint48(now), ttl);\r\n    }\r\n    function dent(uint id, uint lot, uint bid) external note {\r\n        require(bids[id].guy != address(0), \"Flipper/guy-not-set\");\r\n        require(bids[id].tic > now || bids[id].tic == 0, \"Flipper/already-finished-tic\");\r\n        require(bids[id].end > now, \"Flipper/already-finished-end\");\r\n\r\n        require(bid == bids[id].bid, \"Flipper/not-matching-bid\");\r\n        require(bid == bids[id].tab, \"Flipper/tend-not-finished\");\r\n        require(lot < bids[id].lot, \"Flipper/lot-not-lower\");\r\n        require(mul(beg, lot) <= mul(bids[id].lot, ONE), \"Flipper/insufficient-decrease\");\r\n\r\n        vat.move(msg.sender, bids[id].guy, bid);\r\n        vat.flux(ilk, address(this), bids[id].usr, bids[id].lot - lot);\r\n\r\n        bids[id].guy = msg.sender;\r\n        bids[id].lot = lot;\r\n        bids[id].tic = add(uint48(now), ttl);\r\n    }\r\n    function deal(uint id) external note {\r\n        require(bids[id].tic != 0 && (bids[id].tic < now || bids[id].end < now), \"Flipper/not-finished\");\r\n        vat.flux(ilk, address(this), bids[id].guy, bids[id].lot);\r\n        delete bids[id];\r\n    }\r\n\r\n    function yank(uint id) external note auth {\r\n        require(bids[id].guy != address(0), \"Flipper/guy-not-set\");\r\n        require(bids[id].bid < bids[id].tab, \"Flipper/already-dent-phase\");\r\n        vat.flux(ilk, address(this), msg.sender, bids[id].lot);\r\n        vat.move(msg.sender, bids[id].guy, bids[id].bid);\r\n        delete bids[id];\r\n    }\r\n}\r\n\r\ncontract Flopper is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Flopper/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Bid {\r\n        uint256 bid;\r\n        uint256 lot;\r\n        address guy;  // high bidder\r\n        uint48  tic;  // expiry time\r\n        uint48  end;\r\n    }\r\n\r\n    mapping (uint => Bid) public bids;\r\n\r\n    VatLikeFlop  public   vat;\r\n    GemLikeFlop  public   gem;\r\n\r\n    uint256  constant ONE = 1.00E18;\r\n    uint256  public   beg = 1.05E18;  // 5% minimum bid increase\r\n    uint256  public   pad = 1.50E18;  // 50% lot increase for tick\r\n    uint48   public   ttl = 3 hours;  // 3 hours bid lifetime\r\n    uint48   public   tau = 2 days;   // 2 days total auction length\r\n    uint256  public kicks = 0;\r\n    uint256  public live;\r\n\r\n    // --- Events ---\r\n    event Kick(\r\n      uint256 id,\r\n      uint256 lot,\r\n      uint256 bid,\r\n      address indexed gal\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, address gem_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = VatLikeFlop(vat_);\r\n        gem = GemLikeFlop(gem_);\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Admin ---\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \"beg\") beg = data;\r\n        else if (what == \"pad\") pad = data;\r\n        else if (what == \"ttl\") ttl = uint48(data);\r\n        else if (what == \"tau\") tau = uint48(data);\r\n        else revert(\"Flopper/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- Auction ---\r\n    function kick(address gal, uint lot, uint bid) external auth returns (uint id) {\r\n        require(live == 1, \"Flopper/not-live\");\r\n        require(kicks < uint(-1), \"Flopper/overflow\");\r\n        id = ++kicks;\r\n\r\n        bids[id].bid = bid;\r\n        bids[id].lot = lot;\r\n        bids[id].guy = gal;\r\n        bids[id].end = add(uint48(now), tau);\r\n\r\n        emit Kick(id, lot, bid, gal);\r\n    }\r\n    function tick(uint id) external note {\r\n        require(bids[id].end < now, \"Flopper/not-finished\");\r\n        require(bids[id].tic == 0, \"Flopper/bid-already-placed\");\r\n        bids[id].lot = mul(pad, bids[id].lot) / ONE;\r\n        bids[id].end = add(uint48(now), tau);\r\n    }\r\n    function dent(uint id, uint lot, uint bid) external note {\r\n        require(live == 1, \"Flopper/not-live\");\r\n        require(bids[id].guy != address(0), \"Flopper/guy-not-set\");\r\n        require(bids[id].tic > now || bids[id].tic == 0, \"Flopper/already-finished-tic\");\r\n        require(bids[id].end > now, \"Flopper/already-finished-end\");\r\n\r\n        require(bid == bids[id].bid, \"Flopper/not-matching-bid\");\r\n        require(lot <  bids[id].lot, \"Flopper/lot-not-lower\");\r\n        require(mul(beg, lot) <= mul(bids[id].lot, ONE), \"Flopper/insufficient-decrease\");\r\n\r\n        vat.move(msg.sender, bids[id].guy, bid);\r\n\r\n        bids[id].guy = msg.sender;\r\n        bids[id].lot = lot;\r\n        bids[id].tic = add(uint48(now), ttl);\r\n    }\r\n    function deal(uint id) external note {\r\n        require(live == 1, \"Flopper/not-live\");\r\n        require(bids[id].tic != 0 && (bids[id].tic < now || bids[id].end < now), \"Flopper/not-finished\");\r\n        gem.mint(bids[id].guy, bids[id].lot);\r\n        delete bids[id];\r\n    }\r\n\r\n    function cage() external note auth {\r\n       live = 0;\r\n    }\r\n    function yank(uint id) external note {\r\n        require(live == 0, \"Flopper/still-live\");\r\n        require(bids[id].guy != address(0), \"Flopper/guy-not-set\");\r\n        vat.move(address(this), bids[id].guy, bids[id].bid);\r\n        delete bids[id];\r\n    }\r\n}\r\n\r\ncontract GemJoin is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"GemJoin/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    VatLikeJoin public vat;\r\n    bytes32 public ilk;\r\n    GemLike public gem;\r\n    uint    public dec;\r\n    uint    public live;  // Access Flag\r\n\r\n    constructor(address vat_, bytes32 ilk_, address gem_) public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n        vat = VatLikeJoin(vat_);\r\n        ilk = ilk_;\r\n        gem = GemLike(gem_);\r\n        dec = gem.decimals();\r\n    }\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n    function join(address usr, uint wad) external note {\r\n        require(live == 1, \"GemJoin/not-live\");\r\n        require(int(wad) >= 0, \"GemJoin/overflow\");\r\n        vat.slip(ilk, usr, int(wad));\r\n        require(gem.transferFrom(msg.sender, address(this), wad), \"GemJoin/failed-transfer\");\r\n    }\r\n    function exit(address usr, uint wad) external note {\r\n        require(wad <= 2 ** 255, \"GemJoin/overflow\");\r\n        vat.slip(ilk, msg.sender, -int(wad));\r\n        require(gem.transfer(usr, wad), \"GemJoin/failed-transfer\");\r\n    }\r\n}\r\n\r\ncontract ETHJoin is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"ETHJoin/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    VatLikeJoin public vat;\r\n    bytes32 public ilk;\r\n    uint    public live;  // Access Flag\r\n\r\n    constructor(address vat_, bytes32 ilk_) public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n        vat = VatLikeJoin(vat_);\r\n        ilk = ilk_;\r\n    }\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n    function join(address usr) external payable note {\r\n        require(live == 1, \"ETHJoin/not-live\");\r\n        require(int(msg.value) >= 0, \"ETHJoin/overflow\");\r\n        vat.slip(ilk, usr, int(msg.value));\r\n    }\r\n    function exit(address payable usr, uint wad) external note {\r\n        require(int(wad) >= 0, \"ETHJoin/overflow\");\r\n        vat.slip(ilk, msg.sender, -int(wad));\r\n        usr.transfer(wad);\r\n    }\r\n}\r\n\r\ncontract DaiJoin is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"DaiJoin/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    VatLikeJoin public vat;\r\n    DSTokenLike public dai;\r\n    uint    public live;  // Access Flag\r\n\r\n    constructor(address vat_, address dai_) public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n        vat = VatLikeJoin(vat_);\r\n        dai = DSTokenLike(dai_);\r\n    }\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n    uint constant ONE = 10 ** 27;\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function join(address usr, uint wad) external note {\r\n        vat.move(address(this), usr, mul(ONE, wad));\r\n        dai.burn(msg.sender, wad);\r\n    }\r\n    function exit(address usr, uint wad) external note {\r\n        require(live == 1, \"DaiJoin/not-live\");\r\n        vat.move(msg.sender, address(this), mul(ONE, wad));\r\n        dai.mint(usr, wad);\r\n    }\r\n}\r\n\r\ncontract Jug is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Jug/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        uint256 duty;\r\n        uint256  rho;\r\n    }\r\n\r\n    mapping (bytes32 => Ilk) public ilks;\r\n    VatLikeJug                  public vat;\r\n    address                  public vow;\r\n    uint256                  public base;\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = VatLikeJug(vat_);\r\n    }\r\n\r\n    // --- Math ---\r\n    function rpow(uint x, uint n, uint b) internal pure returns (uint z) {\r\n      assembly {\r\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\r\n        default {\r\n          switch mod(n, 2) case 0 { z := b } default { z := x }\r\n          let half := div(b, 2)  // for rounding.\r\n          for { n := div(n, 2) } n { n := div(n,2) } {\r\n            let xx := mul(x, x)\r\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n            let xxRound := add(xx, half)\r\n            if lt(xxRound, xx) { revert(0,0) }\r\n            x := div(xxRound, b)\r\n            if mod(n,2) {\r\n              let zx := mul(z, x)\r\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n              let zxRound := add(zx, half)\r\n              if lt(zxRound, zx) { revert(0,0) }\r\n              z := div(zxRound, b)\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    uint256 constant ONE = 10 ** 27;\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        z = x + y;\r\n        require(z >= x);\r\n    }\r\n    function diff(uint x, uint y) internal pure returns (int z) {\r\n        z = int(x) - int(y);\r\n        require(int(x) >= 0 && int(y) >= 0);\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = x * y;\r\n        require(y == 0 || z / y == x);\r\n        z = z / ONE;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function init(bytes32 ilk) external note auth {\r\n        Ilk storage i = ilks[ilk];\r\n        require(i.duty == 0, \"Jug/ilk-already-init\");\r\n        i.duty = ONE;\r\n        i.rho  = now;\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\r\n        require(now == ilks[ilk].rho, \"Jug/rho-not-updated\");\r\n        if (what == \"duty\") ilks[ilk].duty = data;\r\n        else revert(\"Jug/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \"base\") base = data;\r\n        else revert(\"Jug/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 what, address data) external note auth {\r\n        if (what == \"vow\") vow = data;\r\n        else revert(\"Jug/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- Stability Fee Collection ---\r\n    function drip(bytes32 ilk) external note returns (uint rate) {\r\n        require(now >= ilks[ilk].rho, \"Jug/invalid-now\");\r\n        (, uint prev) = vat.ilks(ilk);\r\n        rate = rmul(rpow(add(base, ilks[ilk].duty), now - ilks[ilk].rho, ONE), prev);\r\n        vat.fold(ilk, vow, diff(rate, prev));\r\n        ilks[ilk].rho = now;\r\n    }\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint256           wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        uint256 wad;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n            wad := callvalue\r\n        }\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\ncontract DSPause is DSAuth, DSNote {\r\n\r\n    // --- admin ---\r\n\r\n    modifier wait { require(msg.sender == address(proxy), \"ds-pause-undelayed-call\"); _; }\r\n\r\n    function setOwner(address owner_) public wait {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n    function setAuthority(DSAuthority authority_) public wait {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n    function setDelay(uint delay_) public note wait {\r\n        delay = delay_;\r\n    }\r\n\r\n    // --- math ---\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        z = x + y;\r\n        require(z >= x, \"ds-pause-addition-overflow\");\r\n    }\r\n\r\n    // --- data ---\r\n\r\n    mapping (bytes32 => bool) public plans;\r\n    DSPauseProxy public proxy;\r\n    uint         public delay;\r\n\r\n    // --- init ---\r\n\r\n    constructor(uint delay_, address owner_, DSAuthority authority_) public {\r\n        delay = delay_;\r\n        owner = owner_;\r\n        authority = authority_;\r\n        proxy = new DSPauseProxy();\r\n    }\r\n\r\n    // --- util ---\r\n\r\n    function hash(address usr, bytes32 tag, bytes memory fax, uint eta)\r\n        internal pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(usr, tag, fax, eta));\r\n    }\r\n\r\n    function soul(address usr)\r\n        internal view\r\n        returns (bytes32 tag)\r\n    {\r\n        assembly { tag := extcodehash(usr) }\r\n    }\r\n\r\n    // --- operations ---\r\n\r\n    function plot(address usr, bytes32 tag, bytes memory fax, uint eta)\r\n        public note auth\r\n    {\r\n        require(eta >= add(now, delay), \"ds-pause-delay-not-respected\");\r\n        plans[hash(usr, tag, fax, eta)] = true;\r\n    }\r\n\r\n    function drop(address usr, bytes32 tag, bytes memory fax, uint eta)\r\n        public note auth\r\n    {\r\n        plans[hash(usr, tag, fax, eta)] = false;\r\n    }\r\n\r\n    function exec(address usr, bytes32 tag, bytes memory fax, uint eta)\r\n        public note\r\n        returns (bytes memory out)\r\n    {\r\n        require(plans[hash(usr, tag, fax, eta)], \"ds-pause-unplotted-plan\");\r\n        require(soul(usr) == tag,                \"ds-pause-wrong-codehash\");\r\n        require(now >= eta,                      \"ds-pause-premature-exec\");\r\n\r\n        plans[hash(usr, tag, fax, eta)] = false;\r\n\r\n        out = proxy.exec(usr, fax);\r\n        require(proxy.owner() == address(this), \"ds-pause-illegal-storage-change\");\r\n    }\r\n}\r\n\r\ncontract DSPauseProxy {\r\n    address public owner;\r\n    modifier auth { require(msg.sender == owner, \"ds-pause-proxy-unauthorized\"); _; }\r\n    constructor() public { owner = msg.sender; }\r\n\r\n    function exec(address usr, bytes memory fax)\r\n        public auth\r\n        returns (bytes memory out)\r\n    {\r\n        bool ok;\r\n        (ok, out) = usr.delegatecall(fax);\r\n        require(ok, \"ds-pause-delegatecall-error\");\r\n    }\r\n}\r\n\r\ncontract VatLikePot {\r\n    function move(address,address,uint256) external;\r\n    function suck(address,address,uint256) external;\r\n}\r\n\r\ncontract Pot is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1; }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Pot/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    mapping (address => uint256) public pie;  // user Savings Dai\r\n\r\n    uint256 public Pie;  // total Savings Dai\r\n    uint256 public dsr;  // the Dai Savings Rate\r\n    uint256 public chi;  // the Rate Accumulator\r\n\r\n    VatLikePot public vat;  // CDP engine\r\n    address public vow;  // debt engine\r\n    uint256 public rho;  // time of last drip\r\n\r\n    uint256 public live;  // Access Flag\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = VatLikePot(vat_);\r\n        dsr = ONE;\r\n        chi = ONE;\r\n        rho = now;\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant ONE = 10 ** 27;\r\n    function rpow(uint x, uint n, uint base) internal pure returns (uint z) {\r\n        assembly {\r\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\r\n            default {\r\n                switch mod(n, 2) case 0 { z := base } default { z := x }\r\n                let half := div(base, 2)  // for rounding.\r\n                for { n := div(n, 2) } n { n := div(n,2) } {\r\n                    let xx := mul(x, x)\r\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n                    let xxRound := add(xx, half)\r\n                    if lt(xxRound, xx) { revert(0,0) }\r\n                    x := div(xxRound, base)\r\n                    if mod(n,2) {\r\n                        let zx := mul(z, x)\r\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n                        let zxRound := add(zx, half)\r\n                        if lt(zxRound, zx) { revert(0,0) }\r\n                        z := div(zxRound, base)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, y) / ONE;\r\n    }\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, uint256 data) external note auth {\r\n        require(live == 1, \"Pot/not-live\");\r\n        require(now == rho, \"Pot/rho-not-updated\");\r\n        if (what == \"dsr\") dsr = data;\r\n        else revert(\"Pot/file-unrecognized-param\");\r\n    }\r\n\r\n    function file(bytes32 what, address addr) external note auth {\r\n        if (what == \"vow\") vow = addr;\r\n        else revert(\"Pot/file-unrecognized-param\");\r\n    }\r\n\r\n    function cage() external note auth {\r\n        live = 0;\r\n        dsr = ONE;\r\n    }\r\n\r\n    // --- Savings Rate Accumulation ---\r\n    function drip() external note returns (uint tmp) {\r\n        require(now >= rho, \"Pot/invalid-now\");\r\n        tmp = rmul(rpow(dsr, now - rho, ONE), chi);\r\n        uint chi_ = sub(tmp, chi);\r\n        chi = tmp;\r\n        rho = now;\r\n        vat.suck(address(vow), address(this), mul(Pie, chi_));\r\n    }\r\n\r\n    // --- Savings Dai Management ---\r\n    function join(uint wad) external note {\r\n        require(now == rho, \"Pot/rho-not-updated\");\r\n        pie[msg.sender] = add(pie[msg.sender], wad);\r\n        Pie             = add(Pie,             wad);\r\n        vat.move(msg.sender, address(this), mul(chi, wad));\r\n    }\r\n\r\n    function exit(uint wad) external note {\r\n        pie[msg.sender] = sub(pie[msg.sender], wad);\r\n        Pie             = sub(Pie,             wad);\r\n        vat.move(address(this), msg.sender, mul(chi, wad));\r\n    }\r\n}\r\n\r\ncontract VatLikeSpot {\r\n    function file(bytes32, bytes32, uint) external;\r\n}\r\n\r\ncontract PipLikeSpot {\r\n    function peek() external returns (bytes32, bool);\r\n}\r\n\r\ncontract Spotter is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1;  }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Spotter/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        PipLikeSpot pip;\r\n        uint256 mat;\r\n    }\r\n\r\n    mapping (bytes32 => Ilk) public ilks;\r\n\r\n    VatLikeSpot public vat;\r\n    uint256 public par; // ref per dai\r\n\r\n    uint256 public live;\r\n\r\n    // --- Events ---\r\n    event Poke(\r\n      bytes32 ilk,\r\n      bytes32 val,\r\n      uint256 spot\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = VatLikeSpot(vat_);\r\n        par = ONE;\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    uint constant ONE = 10 ** 27;\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, ONE) / y;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 ilk, bytes32 what, address pip_) external note auth {\r\n        require(live == 1, \"Spotter/not-live\");\r\n        if (what == \"pip\") ilks[ilk].pip = PipLikeSpot(pip_);\r\n        else revert(\"Spotter/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 what, uint data) external note auth {\r\n        require(live == 1, \"Spotter/not-live\");\r\n        if (what == \"par\") par = data;\r\n        else revert(\"Spotter/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\r\n        require(live == 1, \"Spotter/not-live\");\r\n        if (what == \"mat\") ilks[ilk].mat = data;\r\n        else revert(\"Spotter/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- Update value ---\r\n    function poke(bytes32 ilk) external {\r\n        (bytes32 val, bool has) = ilks[ilk].pip.peek();\r\n        uint256 spot = has ? rdiv(rdiv(mul(uint(val), 10 ** 9), par), ilks[ilk].mat) : 0;\r\n        vat.file(ilk, \"spot\", spot);\r\n        emit Poke(ilk, val, spot);\r\n    }\r\n\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n}\r\n\r\ncontract Vat {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { require(live == 1, \"Vat/not-live\"); wards[usr] = 1; }\r\n    function deny(address usr) external note auth { require(live == 1, \"Vat/not-live\"); wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Vat/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    mapping(address => mapping (address => uint)) public can;\r\n    function hope(address usr) external note { can[msg.sender][usr] = 1; }\r\n    function nope(address usr) external note { can[msg.sender][usr] = 0; }\r\n    function wish(address bit, address usr) internal view returns (bool) {\r\n        return either(bit == usr, can[bit][usr] == 1);\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        uint256 Art;   // Total Normalised Debt     [wad]\r\n        uint256 rate;  // Accumulated Rates         [ray]\r\n        uint256 spot;  // Price with Safety Margin  [ray]\r\n        uint256 line;  // Debt Ceiling              [rad]\r\n        uint256 dust;  // Urn Debt Floor            [rad]\r\n    }\r\n    struct Urn {\r\n        uint256 ink;   // Locked Collateral  [wad]\r\n        uint256 art;   // Normalised Debt    [wad]\r\n    }\r\n\r\n    mapping (bytes32 => Ilk)                       public ilks;\r\n    mapping (bytes32 => mapping (address => Urn )) public urns;\r\n    mapping (bytes32 => mapping (address => uint)) public gem;  // [wad]\r\n    mapping (address => uint256)                   public dai;  // [rad]\r\n    mapping (address => uint256)                   public sin;  // [rad]\r\n\r\n    uint256 public debt;  // Total Dai Issued    [rad]\r\n    uint256 public vice;  // Total Unbacked Dai  [rad]\r\n    uint256 public Line;  // Total Debt Ceiling  [rad]\r\n    uint256 public live;  // Access Flag\r\n\r\n    // --- Logs ---\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes32  indexed  arg3,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an 'anonymous' event with a constant 6 words of calldata\r\n            // and four indexed topics: the selector and the first three args\r\n            let mark := msize                         // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36),                    // arg2\r\n                 calldataload(68)                     // arg3\r\n                )\r\n        }\r\n    }\r\n\r\n    // --- Init ---\r\n    constructor() public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint x, int y) internal pure returns (uint z) {\r\n        z = x + uint(y);\r\n        require(y >= 0 || z <= x);\r\n        require(y <= 0 || z >= x);\r\n    }\r\n    function sub(uint x, int y) internal pure returns (uint z) {\r\n        z = x - uint(y);\r\n        require(y <= 0 || z <= x);\r\n        require(y >= 0 || z >= x);\r\n    }\r\n    function mul(uint x, int y) internal pure returns (int z) {\r\n        z = int(x) * y;\r\n        require(int(x) >= 0);\r\n        require(y == 0 || z / y == int(x));\r\n    }\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Administration ---\r\n    function init(bytes32 ilk) external note auth {\r\n        require(ilks[ilk].rate == 0, \"Vat/ilk-already-init\");\r\n        ilks[ilk].rate = 10 ** 27;\r\n    }\r\n    function file(bytes32 what, uint data) external note auth {\r\n        require(live == 1, \"Vat/not-live\");\r\n        if (what == \"Line\") Line = data;\r\n        else revert(\"Vat/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\r\n        require(live == 1, \"Vat/not-live\");\r\n        if (what == \"spot\") ilks[ilk].spot = data;\r\n        else if (what == \"line\") ilks[ilk].line = data;\r\n        else if (what == \"dust\") ilks[ilk].dust = data;\r\n        else revert(\"Vat/file-unrecognized-param\");\r\n    }\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n\r\n    // --- Fungibility ---\r\n    function slip(bytes32 ilk, address usr, int256 wad) external note auth {\r\n        gem[ilk][usr] = add(gem[ilk][usr], wad);\r\n    }\r\n    function flux(bytes32 ilk, address src, address dst, uint256 wad) external note {\r\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\r\n        gem[ilk][src] = sub(gem[ilk][src], wad);\r\n        gem[ilk][dst] = add(gem[ilk][dst], wad);\r\n    }\r\n    function move(address src, address dst, uint256 rad) external note {\r\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\r\n        dai[src] = sub(dai[src], rad);\r\n        dai[dst] = add(dai[dst], rad);\r\n    }\r\n\r\n    function either(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := or(x, y)}\r\n    }\r\n    function both(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := and(x, y)}\r\n    }\r\n\r\n    // --- CDP Manipulation ---\r\n    function frob(bytes32 i, address u, address v, address w, int dink, int dart) external note {\r\n        // system is live\r\n        require(live == 1, \"Vat/not-live\");\r\n\r\n        Urn memory urn = urns[i][u];\r\n        Ilk memory ilk = ilks[i];\r\n        // ilk has been initialised\r\n        require(ilk.rate != 0, \"Vat/ilk-not-init\");\r\n\r\n        urn.ink = add(urn.ink, dink);\r\n        urn.art = add(urn.art, dart);\r\n        ilk.Art = add(ilk.Art, dart);\r\n\r\n        int dtab = mul(ilk.rate, dart);\r\n        uint tab = mul(ilk.rate, urn.art);\r\n        debt     = add(debt, dtab);\r\n\r\n        // either debt has decreased, or debt ceilings are not exceeded\r\n        require(either(dart <= 0, both(mul(ilk.Art, ilk.rate) <= ilk.line, debt <= Line)), \"Vat/ceiling-exceeded\");\r\n        // urn is either less risky than before, or it is safe\r\n        require(either(both(dart <= 0, dink >= 0), tab <= mul(urn.ink, ilk.spot)), \"Vat/not-safe\");\r\n\r\n        // urn is either more safe, or the owner consents\r\n        require(either(both(dart <= 0, dink >= 0), wish(u, msg.sender)), \"Vat/not-allowed-u\");\r\n        // collateral src consents\r\n        require(either(dink <= 0, wish(v, msg.sender)), \"Vat/not-allowed-v\");\r\n        // debt dst consents\r\n        require(either(dart >= 0, wish(w, msg.sender)), \"Vat/not-allowed-w\");\r\n\r\n        // urn has no debt, or a non-dusty amount\r\n        require(either(urn.art == 0, tab >= ilk.dust), \"Vat/dust\");\r\n\r\n        gem[i][v] = sub(gem[i][v], dink);\r\n        dai[w]    = add(dai[w],    dtab);\r\n\r\n        urns[i][u] = urn;\r\n        ilks[i]    = ilk;\r\n    }\r\n    // --- CDP Fungibility ---\r\n    function fork(bytes32 ilk, address src, address dst, int dink, int dart) external note {\r\n        Urn storage u = urns[ilk][src];\r\n        Urn storage v = urns[ilk][dst];\r\n        Ilk storage i = ilks[ilk];\r\n\r\n        u.ink = sub(u.ink, dink);\r\n        u.art = sub(u.art, dart);\r\n        v.ink = add(v.ink, dink);\r\n        v.art = add(v.art, dart);\r\n\r\n        uint utab = mul(u.art, i.rate);\r\n        uint vtab = mul(v.art, i.rate);\r\n\r\n        // both sides consent\r\n        require(both(wish(src, msg.sender), wish(dst, msg.sender)), \"Vat/not-allowed\");\r\n\r\n        // both sides safe\r\n        require(utab <= mul(u.ink, i.spot), \"Vat/not-safe-src\");\r\n        require(vtab <= mul(v.ink, i.spot), \"Vat/not-safe-dst\");\r\n\r\n        // both sides non-dusty\r\n        require(either(utab >= i.dust, u.art == 0), \"Vat/dust-src\");\r\n        require(either(vtab >= i.dust, v.art == 0), \"Vat/dust-dst\");\r\n    }\r\n    // --- CDP Confiscation ---\r\n    function grab(bytes32 i, address u, address v, address w, int dink, int dart) external note auth {\r\n        Urn storage urn = urns[i][u];\r\n        Ilk storage ilk = ilks[i];\r\n\r\n        urn.ink = add(urn.ink, dink);\r\n        urn.art = add(urn.art, dart);\r\n        ilk.Art = add(ilk.Art, dart);\r\n\r\n        int dtab = mul(ilk.rate, dart);\r\n\r\n        gem[i][v] = sub(gem[i][v], dink);\r\n        sin[w]    = sub(sin[w],    dtab);\r\n        vice      = sub(vice,      dtab);\r\n    }\r\n\r\n    // --- Settlement ---\r\n    function heal(uint rad) external note {\r\n        address u = msg.sender;\r\n        sin[u] = sub(sin[u], rad);\r\n        dai[u] = sub(dai[u], rad);\r\n        vice   = sub(vice,   rad);\r\n        debt   = sub(debt,   rad);\r\n    }\r\n    function suck(address u, address v, uint rad) external note auth {\r\n        sin[u] = add(sin[u], rad);\r\n        dai[v] = add(dai[v], rad);\r\n        vice   = add(vice,   rad);\r\n        debt   = add(debt,   rad);\r\n    }\r\n\r\n    // --- Rates ---\r\n    function fold(bytes32 i, address u, int rate) external note auth {\r\n        require(live == 1, \"Vat/not-live\");\r\n        Ilk storage ilk = ilks[i];\r\n        ilk.rate = add(ilk.rate, rate);\r\n        int rad  = mul(ilk.Art, rate);\r\n        dai[u]   = add(dai[u], rad);\r\n        debt     = add(debt,   rad);\r\n    }\r\n}\r\n\r\ncontract FlopLike {\r\n    function kick(address gal, uint lot, uint bid) external returns (uint);\r\n    function cage() external;\r\n    function live() external returns (uint);\r\n}\r\n\r\ncontract FlapLike {\r\n    function kick(uint lot, uint bid) external returns (uint);\r\n    function cage(uint) external;\r\n    function live() external returns (uint);\r\n}\r\n\r\ncontract VatLikeVow {\r\n    function dai (address) external view returns (uint);\r\n    function sin (address) external view returns (uint);\r\n    function heal(uint256) external;\r\n    function hope(address) external;\r\n    function nope(address) external;\r\n}\r\n\r\ncontract Vow is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { require(live == 1, \"Vow/not-live\"); wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Vow/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    VatLikeVow public vat;\r\n    FlapLike public flapper;\r\n    FlopLike public flopper;\r\n\r\n    mapping (uint256 => uint256) public sin; // debt queue\r\n    uint256 public Sin;   // queued debt          [rad]\r\n    uint256 public Ash;   // on-auction debt      [rad]\r\n\r\n    uint256 public wait;  // flop delay\r\n    uint256 public dump;  // flop initial lot size  [wad]\r\n    uint256 public sump;  // flop fixed bid size    [rad]\r\n\r\n    uint256 public bump;  // flap fixed lot size    [rad]\r\n    uint256 public hump;  // surplus buffer       [rad]\r\n\r\n    uint256 public live;\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, address flapper_, address flopper_) public {\r\n        wards[msg.sender] = 1;\r\n        vat     = VatLikeVow(vat_);\r\n        flapper = FlapLike(flapper_);\r\n        flopper = FlopLike(flopper_);\r\n        vat.hope(flapper_);\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \"wait\") wait = data;\r\n        else if (what == \"bump\") bump = data;\r\n        else if (what == \"sump\") sump = data;\r\n        else if (what == \"dump\") dump = data;\r\n        else if (what == \"hump\") hump = data;\r\n        else revert(\"Vow/file-unrecognized-param\");\r\n    }\r\n\r\n    function file(bytes32 what, address data) external note auth {\r\n        if (what == \"flapper\") {\r\n            vat.nope(address(flapper));\r\n            flapper = FlapLike(data);\r\n            vat.hope(data);\r\n        }\r\n        else if (what == \"flopper\") flopper = FlopLike(data);\r\n        else revert(\"Vow/file-unrecognized-param\");\r\n    }\r\n\r\n    // Push to debt-queue\r\n    function fess(uint tab) external note auth {\r\n        sin[now] = add(sin[now], tab);\r\n        Sin = add(Sin, tab);\r\n    }\r\n    // Pop from debt-queue\r\n    function flog(uint era) external note {\r\n        require(add(era, wait) <= now, \"Vow/wait-not-finished\");\r\n        Sin = sub(Sin, sin[era]);\r\n        sin[era] = 0;\r\n    }\r\n\r\n    // Debt settlement\r\n    function heal(uint rad) external note {\r\n        require(rad <= vat.dai(address(this)), \"Vow/insufficient-surplus\");\r\n        require(rad <= sub(sub(vat.sin(address(this)), Sin), Ash), \"Vow/insufficient-debt\");\r\n        vat.heal(rad);\r\n    }\r\n    function kiss(uint rad) external note {\r\n        require(rad <= Ash, \"Vow/not-enough-ash\");\r\n        require(rad <= vat.dai(address(this)), \"Vow/insufficient-surplus\");\r\n        Ash = sub(Ash, rad);\r\n        vat.heal(rad);\r\n    }\r\n\r\n    // Debt auction\r\n    function flop() external note returns (uint id) {\r\n        require(sump <= sub(sub(vat.sin(address(this)), Sin), Ash), \"Vow/insufficient-debt\");\r\n        require(vat.dai(address(this)) == 0, \"Vow/surplus-not-zero\");\r\n        Ash = add(Ash, sump);\r\n        id = flopper.kick(address(this), dump, sump);\r\n    }\r\n    // Surplus auction\r\n    function flap() external note returns (uint id) {\r\n        require(vat.dai(address(this)) >= add(add(vat.sin(address(this)), bump), hump), \"Vow/insufficient-surplus\");\r\n        require(sub(sub(vat.sin(address(this)), Sin), Ash) == 0, \"Vow/debt-not-zero\");\r\n        id = flapper.kick(bump, 0);\r\n    }\r\n\r\n    function cage() external note auth {\r\n        require(live == 1, \"Vow/not-live\");\r\n        live = 0;\r\n        Sin = 0;\r\n        Ash = 0;\r\n        flapper.cage(vat.dai(address(flapper)));\r\n        flopper.cage();\r\n        vat.heal(min(vat.dai(address(this)), vat.sin(address(this))));\r\n    }\r\n}"
    }
  }
}