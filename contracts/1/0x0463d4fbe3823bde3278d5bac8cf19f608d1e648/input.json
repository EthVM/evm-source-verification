{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Market.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\n pragma solidity = 0.7 .4;\r\n\r\n abstract contract Context {\r\n   function _msgSender() internal view virtual returns(address payable) {\r\n     return msg.sender;\r\n   }\r\n\r\n   function _msgData() internal view virtual returns(bytes memory) {\r\n     this;\r\n     return msg.data;\r\n   }\r\n }\r\n\r\n contract Ownable is Context {\r\n   address private _owner;\r\n\r\n   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n   constructor() {\r\n     address msgSender = _msgSender();\r\n     _owner = msgSender;\r\n     emit OwnershipTransferred(address(0), msgSender);\r\n   }\r\n\r\n   function owner() public view returns(address) {\r\n     return _owner;\r\n   }\r\n\r\n   modifier onlyOwner() {\r\n     require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n     _;\r\n   }\r\n\r\n   function renounceOwnership() public virtual onlyOwner {\r\n     emit OwnershipTransferred(_owner, address(0));\r\n     _owner = address(0);\r\n   }\r\n\r\n   function transferOwnership(address newOwner) public virtual onlyOwner {\r\n     require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n     emit OwnershipTransferred(_owner, newOwner);\r\n     _owner = newOwner;\r\n   }\r\n }\r\n\r\n library SafeMath {\r\n\r\n   function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n     uint256 c = a + b;\r\n     require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n     return c;\r\n   }\r\n\r\n   function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n     return sub(a, b, \"SafeMath: subtraction overflow\");\r\n   }\r\n\r\n   function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n     require(b <= a, errorMessage);\r\n     uint256 c = a - b;\r\n\r\n     return c;\r\n   }\r\n\r\n   function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n     if (a == 0) {\r\n       return 0;\r\n     }\r\n\r\n     uint256 c = a * b;\r\n     require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n     return c;\r\n   }\r\n\r\n   function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n     return div(a, b, \"SafeMath: division by zero\");\r\n   }\r\n\r\n   function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\r\n     require(b > 0, errorMessage);\r\n     uint256 c = a / b;\r\n     // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n     return c;\r\n   }\r\n\r\n }\r\n\r\n abstract contract Router {\r\n   function extrenalRouterCall(string memory route, address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\r\n }\r\n\r\n contract Market is Ownable {\r\n\r\n   using SafeMath\r\n   for uint;\r\n\r\n   uint private maxSell = 5000000000000000000000000;\r\n   uint private circulatingKrk = 0;\r\n   uint private circulatingEth = 0;\r\n   uint krakintTotalEthEarnings = 0;\r\n   uint investorsCirculatingEthEarnings = 0;\r\n   mapping(address => uint) private userEth;\r\n   mapping(address => uint) private circulatingUserKrk;\r\n   mapping(address => uint) private totalUserFees;\r\n   uint private totalBurnedKRK = 0;\r\n   uint private totalMintedKRK = 0;\r\n   uint private totalDepositedEth = 0;\r\n   uint private totalWithdrawnEth = 0;\r\n   uint private totalFeesPaid = 0;\r\n   uint private totalKrakintEarnings = 0;\r\n   uint private totalInvestorsEarnings = 0;\r\n   uint private totalDepositAfterFees = 0;\r\n\r\n   address private routerContract;\r\n   Router private router;\r\n   mapping(address => bool) private mutex;\r\n   mapping(address => uint) private mutexTimeout;\r\n\r\n   function purchaseTokens() external payable {\r\n     require(!mutex[msg.sender] || mutexTimeout[msg.sender] < block.number, \"Contract safety feature, please wait\");\r\n     mutex[msg.sender] = true;\r\n     mutexTimeout[msg.sender] = (block.number).add(1200); //approx. 20 min. assuming 12 seconds per block.\r\n\r\n     //get wei amount \r\n     if (msg.value <= 0) revertWithMutex(msg.sender);\r\n     uint weiAmount = msg.value;\r\n\r\n     //project KRK return\r\n     uint krks = getKrkReturn(weiAmount);\r\n     if (circulatingKrk.add(krks) > maxSell) revertWithMutex(msg.sender);\r\n\r\n     //calculate fees\r\n     uint fee = getFourPercent(weiAmount);\r\n     uint krakintFee = fee.div(2);\r\n     uint investorFee = fee.sub(krakintFee);\r\n     uint afterFees = weiAmount.sub(fee);\r\n\r\n     //update tables \r\n     circulatingKrk = circulatingKrk.add(krks);\r\n     circulatingEth = circulatingEth.add(weiAmount);\r\n     krakintTotalEthEarnings = krakintTotalEthEarnings.add(krakintFee);\r\n     investorsCirculatingEthEarnings = investorsCirculatingEthEarnings.add(investorFee);\r\n\r\n     userEth[msg.sender] = userEth[msg.sender].add(afterFees);\r\n     circulatingUserKrk[msg.sender] = circulatingUserKrk[msg.sender].add(krks);\r\n     totalUserFees[msg.sender] = totalUserFees[msg.sender].add(fee);\r\n\r\n     totalMintedKRK = totalMintedKRK.add(krks);\r\n     totalDepositedEth = totalDepositedEth.add(weiAmount);\r\n     totalFeesPaid = totalFeesPaid.add(fee);\r\n     totalKrakintEarnings = totalKrakintEarnings.add(krakintFee);\r\n     totalInvestorsEarnings = totalInvestorsEarnings.add(investorFee);\r\n     totalDepositAfterFees = totalDepositAfterFees.add(afterFees);\r\n\r\n     //mint tokens\r\n     mint(krks);\r\n     mutex[msg.sender] = false;\r\n\r\n   }\r\n\r\n   function purchaseEthereum(uint krkAmount) external returns(bool success) {\r\n     require(!mutex[msg.sender] || mutexTimeout[msg.sender] < block.number, \"Contract safety in place, please wait\");\r\n     mutex[msg.sender] = true;\r\n     mutexTimeout[msg.sender] = (block.number).add(100); //approx. 20 min.\r\n\r\n     if (circulatingKrk <= 0) revertWithMutex(msg.sender);\r\n     if (krkAmount <= 0) revertWithMutex(msg.sender);\r\n\r\n     uint ethAmount = getEthReturnNoBonus(krkAmount, msg.sender);\r\n\r\n     if (ethAmount <= 0) revertWithMutex(msg.sender);\r\n\r\n     uint bonusEth = getEthReturnBonus(krkAmount, msg.sender);\r\n     uint sendAmount = ethAmount.add(bonusEth);\r\n\r\n     if (sendAmount <= 0) revertWithMutex(msg.sender);\r\n\r\n     //update tables \r\n     circulatingKrk = circulatingKrk.sub(krkAmount);\r\n     investorsCirculatingEthEarnings = investorsCirculatingEthEarnings.sub(bonusEth);\r\n\r\n     userEth[msg.sender] = userEth[msg.sender].sub(ethAmount);\r\n     circulatingUserKrk[msg.sender] = circulatingUserKrk[msg.sender].sub(krkAmount);\r\n\r\n     totalBurnedKRK = totalBurnedKRK.add(krkAmount);\r\n\r\n     //burn krk\r\n     burn(krkAmount);\r\n\r\n     //send eth\r\n     address payable payableAddress = address(uint160(address(msg.sender)));\r\n     payableAddress.transfer(sendAmount);\r\n     totalWithdrawnEth = totalWithdrawnEth.add(sendAmount);\r\n     circulatingEth = circulatingEth.sub(sendAmount);\r\n\r\n     mutex[msg.sender] = false;\r\n     return true;\r\n   }\r\n\r\n   function mint(uint mintAmount) private returns(bool success) {\r\n     address fromAddress = address(0);\r\n     address[2] memory addresseArr = [fromAddress, msg.sender];\r\n     uint[2] memory uintArr = [mintAmount, 0];\r\n\r\n     router.extrenalRouterCall(\"mint_market\", addresseArr, uintArr);\r\n\r\n     return true;\r\n   }\r\n\r\n   function burn(uint burnAmount) private returns(bool success) {\r\n     address toAddress = address(0);\r\n     address[2] memory addresseArr = [msg.sender, toAddress];\r\n     uint[2] memory uintArr = [burnAmount, 0];\r\n\r\n     router.extrenalRouterCall(\"burn_market\", addresseArr, uintArr);\r\n\r\n     return true;\r\n   }\r\n\r\n   //----------VIEWS START---------------------\r\n   function getEthReturnNoBonus(uint krkAmount, address userAddress) public view virtual returns(uint ethAmount) {\r\n     if (circulatingKrk <= 0) return 0;\r\n     if (circulatingUserKrk[userAddress] <= 0) return 0;\r\n     if (krkAmount <= 0) return 0;\r\n     if (krkAmount > circulatingUserKrk[userAddress]) return 0; \r\n\r\n     uint returnEth = (userEth[userAddress].mul(krkAmount)).div(circulatingUserKrk[userAddress]);\r\n     return returnEth;\r\n   }\r\n\r\n   function getEthReturnBonus(uint krkAmount, address userAddress) public view virtual returns(uint bonusAmount) {\r\n     if (circulatingKrk <= 0) return 0;\r\n     if (krkAmount <= 0) return 0;\r\n     if (circulatingUserKrk[userAddress] < krkAmount) return 0;\r\n     \r\n     uint bonusEth = (circulatingUserKrk[userAddress].mul(circulatingUserKrk[userAddress])\r\n                    .mul(investorsCirculatingEthEarnings)).div(circulatingKrk.mul(circulatingKrk));\r\n     \r\n     return bonusEth;\r\n   }\r\n\r\n   function getKrkReturn(uint gweiAmount) public view virtual returns(uint krkAmount) {\r\n     uint fee_total = getFourPercent(gweiAmount);\r\n\r\n     uint afterFee = gweiAmount.sub(fee_total);\r\n     uint price = getPrice(circulatingKrk);\r\n     require(price > 0, \"at: market.sol | function: getKrkReturn | message: Division by zero, at getKrkReturn\");\r\n     uint krks = (afterFee.mul(1000000000000000000)).div(price);\r\n\r\n     uint stageNumber = getStageNumber(circulatingKrk);\r\n     uint multiplyBy = (uint(1000)).div(stageNumber);\r\n\r\n     krks = krks.mul(multiplyBy);\r\n\r\n     return krks;\r\n   }\r\n\r\n   function getCirculatingKrk() public view virtual returns(uint krkAmount) {\r\n     return circulatingKrk;\r\n   }\r\n   \r\n  function getCirculatingEth() public view virtual returns(uint krkAmount) {\r\n     return circulatingEth;\r\n   }\r\n\r\n   function getKrakintTotalEthEarnings() public view virtual returns(uint ethAmount) {\r\n     return krakintTotalEthEarnings;\r\n   }\r\n\r\n   function getInvestorsCirculatingEthEarnings() public view virtual returns(uint ethAmount) {\r\n     return investorsCirculatingEthEarnings;\r\n   }\r\n\r\n   function getUserEth(address userAddress) public view virtual returns(uint ethAmount) {\r\n     return userEth[userAddress];\r\n   }\r\n\r\n   function getCirculatingUserKrk(address userAddress) public view virtual returns(uint ethAmount) {\r\n     return circulatingUserKrk[userAddress];\r\n   }\r\n\r\n   function getTotalUserFees(address userAddress) public view virtual returns(uint ethAmount) {\r\n     return totalUserFees[userAddress];\r\n   }\r\n\r\n   function getTotalBurnedKRK() public view virtual returns(uint ethAmount) {\r\n     return totalBurnedKRK;\r\n   }\r\n\r\n   function getTotalMintedKRK() public view virtual returns(uint ethAmount) {\r\n     return totalMintedKRK;\r\n   }\r\n\r\n   function getTotalDepositedEth() public view virtual returns(uint ethAmount) {\r\n     return totalDepositedEth;\r\n   }\r\n   \r\n   function getTotalWithdrawnEth() public view virtual returns(uint ethAmount) {\r\n     return totalWithdrawnEth;\r\n   }\r\n\r\n   function getTotalFeesPaid() public view virtual returns(uint ethAmount) {\r\n     return totalFeesPaid;\r\n   }\r\n\r\n   function getTotalKrakintEarnings() public view virtual returns(uint ethAmount) {\r\n     return totalKrakintEarnings;\r\n   }\r\n\r\n   function getTotalInvestorsEarnings() public view virtual returns(uint ethAmount) {\r\n     return totalKrakintEarnings;\r\n   }\r\n\r\n   function getTotalDepositAfterFees() public view virtual returns(uint ethAmount) {\r\n     return totalKrakintEarnings;\r\n   }\r\n\r\n   //----------PRIVATE PURE START---------------------\r\n\r\n   function getStageNumber(uint x) private pure returns(uint stageNumber) {\r\n     uint ret = 1;\r\n     if (x >= 4500000000000000000000000) {\r\n       ret = 10;\r\n     } else if (x >= 4000000000000000000000000) {\r\n       ret = 9;\r\n     } else if (x >= 3500000000000000000000000) {\r\n       ret = 8;\r\n     } else if (x >= 3000000000000000000000000) {\r\n       ret = 7;\r\n     } else if (x >= 2500000000000000000000000) {\r\n       ret = 6;\r\n     } else if (x >= 2000000000000000000000000) {\r\n       ret = 5;\r\n     } else if (x >= 1500000000000000000000000) {\r\n       ret = 4;\r\n     } else if (x >= 1000000000000000000000000) {\r\n       ret = 3;\r\n     } else if (x >= 500000000000000000000000) {\r\n       ret = 2;\r\n     }\r\n     return ret;\r\n   }\r\n\r\n   //returns price per eth in gwei\r\n   function getPrice(uint x) private pure returns(uint retPrice) {\r\n\r\n     //uint x = circulatingKrk;\r\n\r\n     //stage 10\r\n     //linear equation: y = 5.8579×10^-6 x - 19.2895\r\n     //intercepts (4500000,7.07105) and (5000000,10)\r\n     if (x >= 4500000000000000000000000) {\r\n       return (((x).mul(58579)).div(10000000000)).sub(19289500000000000000);\r\n     }\r\n\r\n     //stage 9\r\n     //linear equation: y = 3.8579×10^-6 x - 10.2895\r\n     //intercepts (4000000,5.1421) and (5000000,9)\r\n     if (x >= 4000000000000000000000000) {\r\n       return (((x).mul(38579)).div(10000000000)).sub(10289500000000000000);\r\n     }\r\n\r\n     //stage 8\r\n     //linear equation: y = 2.85792×10^-6 x - 6.28958\r\n     //intercepts (3500000,3.713125) and (5000000,8)\r\n     if (x >= 3500000000000000000000000) {\r\n       return (((x).mul(6859)).div(2400000000)).sub(6289583333333333333);\r\n     }\r\n\r\n     //stage 7\r\n     //linear equation: y = 2.19125×10^-6 x - 3.95625\r\n     //intercepts (3000000,2.6175) and (5000000,7)\r\n     if (x >= 3000000000000000000000000) {\r\n       return (((x).mul(1753)).div(800000000)).sub(3956250000000000000);\r\n     }\r\n\r\n     //stage 6\r\n     //linear equation: y = 1.69125×10^-6 x - 2.45625\r\n     //intercepts (2500000,1.771875) and (5000000,6)\r\n     if (x >= 2500000000000000000000000) {\r\n       return (((x).mul(1353)).div(800000000)).sub(2456250000000000000);\r\n     }\r\n\r\n     //stage 5\r\n     //linear equation: y = 1.29125×10^-6 x - 1.45625\r\n     //intercepts (2000000,1.126251) and (5000000,5)\r\n     if (x >= 2000000000000000000000000) {\r\n       return (((x).mul(3873749)).div(3000000000000)).sub(1456248333333333333);\r\n     }\r\n\r\n     //stage 4\r\n     //linear equation: y = 9.57917×10^-7 x - 0.789583\r\n     //intercepts (1500000,0.647292) and (5000000,4)\r\n     if (x >= 1500000000000000000000000) {\r\n       return (((x).mul(838177)).div(875000000000)).sub(789582857142857142);\r\n     }\r\n\r\n     //stage 3\r\n     //linear equation: y = 6.72202×10^-7 x - 0.361011\r\n     //intercepts (1000000,0.311191) and (5000000,3)\r\n     if (x >= 1000000000000000000000000) {\r\n       return (((x).mul(2688809)).div(4000000000000)).sub(361011250000000000);\r\n     }\r\n\r\n     //stage 2\r\n     //linear equation: y = 4.22202×10^-7 x - 0.111011\r\n     //intercepts (500000,0.10009) and (5000000,2)\r\n     if (x >= 500000000000000000000000) {\r\n       return (((x).mul(189991)).div(450000000000)).sub(111011111111111111);\r\n     }\r\n\r\n     //stage 1\r\n     //linear equation: y = 1.9998×10^-7 x + 0.0001\r\n     //intercepts (0,0.0001) and (5000000,1)\r\n\r\n     return (((x).mul(9999)).div(50000000000)).add(100000000000000);\r\n   }\r\n\r\n   function getFourPercent(uint number) private pure returns(uint fivePercent) {\r\n     uint ret = number.div(25);\r\n     return ret;\r\n   }\r\n\r\n   function revertWithMutex(address userAddress) private {\r\n     mutex[userAddress] = false;\r\n     require(mutex[userAddress], \"at: market.sol | function: revertWithMutex | message: Prevented multiple calls with the mutex, your previous call must end or expire\");\r\n   }\r\n\r\n   //+++++++++++ONLY OWNER++++++++++++++++\r\n   //----------SETTERS--------------------\r\n   function setNewRouterContract(address newRouterAddress) onlyOwner public virtual returns(bool success) {\r\n     routerContract = newRouterAddress;\r\n     router = Router(newRouterAddress);\r\n     return true;\r\n   }\r\n\r\n   function withdrawEthereum() external onlyOwner returns(bool success) {\r\n     address payable payableAddress = address(uint160(address(msg.sender)));\r\n     payableAddress.transfer(krakintTotalEthEarnings);\r\n     krakintTotalEthEarnings = 0;\r\n     return true;\r\n   }\r\n\r\n }"}}}