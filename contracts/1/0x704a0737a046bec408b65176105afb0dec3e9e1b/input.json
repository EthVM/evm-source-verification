{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"SlowBurn.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n// SlowBurn contract\r\n//\r\n// Insert cool ASCII art here.\r\n//\r\npragma solidity ^0.7.5;\r\n\r\n// OpenZeppelin SafeMath.\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n  \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function sync() external;\r\n}\r\n\r\n// OpenZeppelin implementation of ERC20 plus some additional logic:\r\n// * During presale period, ether is collected in exchange for tokens.\r\n// * Once presale ends, the collected ether is used to supply liquidity to a uniswap pool\r\n//   with the initial token price set to the presale price.\r\n// * From this point on anyone can call maybeReprice() once per day to adjust uniswap's\r\n//   token balance so that the price is 20% higher than the previous day's.\r\n// * Note that while the price is guaranteed to rise day after day, at some point sellers will\r\n//   drain the pool of eth, making the high price meaningless since significant ether can no\r\n//   longer be extracted. Choose your exit wisely!\r\ncontract SlowBurn {\r\n    using SafeMath for uint256;\r\n    \r\n    address public developer;\r\n    uint32 public presaleStartTime;\r\n    uint32 public epoch;\r\n    uint32 public lastRepriceTime;\r\n    address public uniswapPair;\r\n    \r\n    // Presale period of 1 week.\r\n    uint32 constant private kPresalePeriod = 604800;\r\n    // Allow token reprices once per day.\r\n    uint32 constant private kRepriceInterval = 86400;\r\n    // Window during which maybeReprice can fail.\r\n    uint32 constant private kRepriceWindow = 3600;\r\n    // The token lister and successful maybeReprice callers will be rewarded with freshly minted tokens with\r\n    // value 0.1 eth to offset any gas costs incurred.\r\n    uint constant private kRewardWei = 10 ** 17;\r\n    // Upon listing, developer receives 5% of uniswap's initial token balance.  \r\n    uint constant private kDeveloperTokenCut = 5;\r\n    // Initial token price of ~ $0.01\r\n    uint constant private kPresaleTokensPerEth = 90000;\r\n    // Don't allow individual users to mint more than 1 eth's worth of tokens during presale.\r\n    uint constant private kMaxPresaleTokensPerAccount = kPresaleTokensPerEth * (10 ** 18);\r\n    // Don't allow presale to raise more than 200 Eth\r\n    uint constant private kPresaleHardCap = 200 * (10 ** 18);\r\n    // Token price increases by 20% each day.\r\n    uint constant private kTokenPriceBump = 20;\r\n\r\n    address constant private kWeth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    IUniswapV2Factory constant private kUniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n    IUniswapV2Router02 constant private kUniswapRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    \r\n    // ********* Start of boring old ERC20 stuff **********************\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    constructor () {\r\n        _name = \"SlowBurn\";\r\n        _symbol = \"SB\";\r\n        _decimals = 18;\r\n        developer = msg.sender;\r\n        presaleStartTime = uint32(block.timestamp);\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    \r\n    // ********* And now for the good stuff! **********************\r\n    \r\n    // Contract accepts ether during the presale period, minting the corresponding amount\r\n    // of tokens for the sender.\r\n    // The first caller after the presale period ends (or if the hard cap has been hit)\r\n    // will have their ether returned and will receive a small token reward in exchange\r\n    // for creating the uniswap pair for this token.\r\n    // Subsequent calls will fail.\r\n    receive() external payable {\r\n        if (msg.sender == address(kUniswapRouter)) {\r\n            // Failsafe. Just in case we screwed something up in listToken() and don't manage to\r\n            // supply our full balance, let the router return the excess funds (otherwise pool creation\r\n            // fails and we're all screwed!) Since any funds left in this contract will be unrecoverable,\r\n            // we send to the developer who will fix the mistake and deposit in the uniswap pool.\r\n            // Don't worry though, we didn't screw up the math!\r\n            payable(developer).transfer(msg.value);\r\n            return;\r\n        }\r\n        uint presaleEndTime = presaleStartTime + kPresalePeriod;\r\n        if (block.timestamp < presaleEndTime && address(this).balance - msg.value < kPresaleHardCap) {\r\n            uint tokens = msg.value.mul(kPresaleTokensPerEth);\r\n            require(_balances[msg.sender].add(tokens) <= kMaxPresaleTokensPerAccount, \"Exceeded the presale limit\");\r\n            _mint(msg.sender, tokens);\r\n            return;\r\n        }\r\n        require(uniswapPair == address(0), \"Presale has ended\");\r\n        msg.sender.transfer(msg.value);\r\n        listToken();\r\n        payReward();\r\n    }\r\n    \r\n    // To make everyone's lives just a little more interesting, reprices will be separated\r\n    // by roughly one day, but the exact timing is subject to the vicissitudes of fate.\r\n    // If the token has not yet been listed, or if the last reprice took place less than\r\n    // 23.5 hours ago, this function will fail.\r\n    // If the last reprice was between 23.5 and 24.5 hours ago, this function will succeed\r\n    // probabilistically, with the chance increasing from 0 to 1 linearly over the range.\r\n    // If the last reprice was more than 24.5 hours ago, this function will succeed.\r\n    // Upon success, the token is repriced and the caller is issued a small token reward.\r\n    function maybeReprice() public {\r\n        require(uniswapPair != address(0), \"Token hasn't been listed yet\");\r\n        require(block.timestamp >= lastRepriceTime + kRepriceInterval - kRepriceWindow / 2, \"Too soon since last reprice\");\r\n        if (block.timestamp < lastRepriceTime + kRepriceInterval + kRepriceWindow / 2) {\r\n            uint hash = uint(keccak256(abi.encodePacked(msg.sender, block.timestamp))).mod(kRepriceWindow);\r\n            uint mods = block.timestamp.sub(lastRepriceTime + kRepriceInterval - kRepriceWindow / 2);\r\n            require(hash < mods, \"The gods frown upon you\");\r\n        }\r\n        epoch++;\r\n        lastRepriceTime = uint32(block.timestamp);\r\n        adjustPrice();\r\n        payReward();\r\n    }\r\n    \r\n    // Create uniswap pair for this token, add liquidity, and mint the developer's token cut.\r\n    function listToken() internal {\r\n        require(uniswapPair == address(0), \"Token already listed.\");\r\n        _approve(address(this), address(kUniswapRouter), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        uint tokens = kPresaleTokensPerEth.mul(address(this).balance);\r\n        _mint(developer, tokens.mul(kDeveloperTokenCut).div(100));\r\n        uniswapPair = kUniswapFactory.getPair(address(this), kWeth);\r\n        if (uniswapPair == address(0)) {\r\n            _mint(address(this), tokens);\r\n            kUniswapRouter.addLiquidityETH{value:address(this).balance}(address(this), tokens, 0, 0, address(this), block.timestamp);\r\n            uniswapPair = kUniswapFactory.getPair(address(this), kWeth);\r\n        } else {\r\n            // Sigh, someone has already pointlessly created the pair. Now we have to do some math :(\r\n            (uint reserveA, uint reserveB,) = IUniswapV2Pair(uniswapPair).getReserves();\r\n            if (address(this) < kWeth) {\r\n                // Round up tokens to ensure that all of the eth will be taken by the router.\r\n                tokens = reserveA.mul(address(this).balance).add(reserveB).sub(1).div(reserveB);\r\n            } else {\r\n                // Round up tokens to ensure that all of the eth will be taken by the router.\r\n                tokens = reserveB.mul(address(this).balance).add(reserveA).sub(1).div(reserveA);\r\n            }\r\n            _mint(address(this), tokens);\r\n            kUniswapRouter.addLiquidityETH{value:address(this).balance}(address(this), tokens, 0, 0, address(this), block.timestamp);\r\n            // Adjust price to match presale.\r\n            adjustPrice();\r\n            // Might have a very small amount of tokens left in our contract. Tidy up.\r\n            uint leftoverTokens = balanceOf(address(this));\r\n            if (leftoverTokens > 0) {\r\n                _burn(address(this), leftoverTokens);\r\n            }\r\n        }\r\n        // Don't think these can fail, but just in case ...\r\n        require(uniswapPair != address(0));\r\n        // Set lastRepriceTime to nearest day since presaleStartTime to avoid reprices\r\n        // occurring at some horrible time in the middle of the night.\r\n        lastRepriceTime = presaleStartTime + ((uint32(block.timestamp) - presaleStartTime + 43200) / 86400) * 86400;\r\n    }\r\n    \r\n    // Adjust token balance of uniswapPair so that token price = 1.2^epoch * presale token price.\r\n    function adjustPrice() internal {\r\n        require(uniswapPair != address(0), \"Token hasn't been listed.\");\r\n        (uint reserveTokens, uint reserveEth,) = IUniswapV2Pair(uniswapPair).getReserves();\r\n        if (address(this) > kWeth) {\r\n            uint temp = reserveTokens;\r\n            reserveTokens = reserveEth;\r\n            reserveEth = temp;\r\n        }\r\n        uint tokens = reserveEth.mul(kPresaleTokensPerEth);\r\n        for (uint e = 0; e < epoch; e++) {\r\n            tokens = tokens.mul(100).div(100+kTokenPriceBump);\r\n        }\r\n        if (tokens > reserveTokens) {\r\n            _mint(uniswapPair, tokens.sub(reserveTokens));\r\n            IUniswapV2Pair(uniswapPair).sync();\r\n        } else if (tokens < reserveTokens) {\r\n            _burn(uniswapPair, reserveTokens.sub(tokens));\r\n            IUniswapV2Pair(uniswapPair).sync();\r\n        }\r\n    }\r\n    \r\n    // Mint tokens for msg.sender with value equal to kRewardWei.\r\n    function payReward() internal {\r\n    \tuint currentTokensPerEth = kPresaleTokensPerEth;\r\n    \tfor (uint e = 0; e < epoch; e++) {\r\n    \t    currentTokensPerEth = currentTokensPerEth.mul(100).div(100+kTokenPriceBump);\r\n    \t}\r\n    \t_mint(msg.sender, kRewardWei.mul(currentTokensPerEth));\r\n    }\r\n    \r\n    // Just in case people do something stupid like send WETH instead of ETH to presale,\r\n    // allow for recovery by devs.\r\n    function transferERC(address token, address recipient, uint amount) public {\r\n        require(msg.sender == developer, \"Nice try non-dev\");\r\n        require(token != uniswapPair && token != address(this), \"Nice try dev, no rug pulls allowed\");\r\n        IERC20(token).transfer(recipient, amount);\r\n    }\r\n}"}}}