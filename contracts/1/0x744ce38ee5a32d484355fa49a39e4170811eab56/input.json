{"language":"Solidity","settings":{"evmVersion":"london","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":999999},"remappings":[],"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}},"sources":{"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"},"contracts/Traits.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport 'hardhat-deploy/solc_0.8/proxy/Proxied.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol';\n\nimport './interfaces/ITraits.sol';\nimport './interfaces/IChickenNoodle.sol';\n\ncontract Traits is Proxied, ITraits {\n    using StringsUpgradeable for uint256;\n    using StringsUpgradeable for uint8;\n\n    // mapping from trait type (index) to its name\n    string[7] _traitTypes;\n\n    // storage for image baseURI\n    string public imageBaseURI;\n    // storage for metadata description\n    string public description;\n    // storage of each traits name\n    mapping(uint8 => mapping(uint8 => string)) public traitData;\n\n    IChickenNoodle public chickenNoodle;\n\n    // constructor(string memory _imageBaseURI) {\n    //     initialize(_imageBaseURI);\n    // }\n\n    function initialize(string memory _imageBaseURI) public proxied {\n        imageBaseURI = _imageBaseURI;\n\n        _traitTypes = [\n            'Backgrounds',\n            'Snake Bodies',\n            'Mouth Accessories',\n            'Pupils',\n            'Body Accessories',\n            'Hats',\n            'Tier'\n        ];\n    }\n\n    /** ADMIN */\n\n    function setChickenNoodle(address _chickenNoodle) external onlyProxyAdmin {\n        chickenNoodle = IChickenNoodle(_chickenNoodle);\n    }\n\n    /**\n     * administrative to set metadata description\n     * @param _imageBaseURI base URI for the image\n     */\n    function setImageBaseURI(string calldata _imageBaseURI)\n        external\n        onlyProxyAdmin\n    {\n        imageBaseURI = _imageBaseURI;\n    }\n\n    /**\n     * administrative to set metadata description\n     * @param _description the standard description for metadata\n     */\n    function setDescription(string calldata _description)\n        external\n        onlyProxyAdmin\n    {\n        description = _description;\n    }\n\n    /**\n     * administrative to upload the names and images associated with each trait\n     * @param traitType the trait type to upload the traits for (see traitTypes for a mapping)\n     * @param names the names for each trait\n     */\n    function uploadTraits(\n        uint8 traitType,\n        uint8[] calldata traitIds,\n        string[] calldata names\n    ) external onlyProxyAdmin {\n        require(traitIds.length == names.length, 'Mismatched inputs');\n        for (uint256 i = 0; i < names.length; i++) {\n            traitData[traitType][traitIds[i]] = names[i];\n        }\n    }\n\n    /** RENDER */\n\n    /**\n     * generates an attribute for the attributes array in the ERC721 metadata standard\n     * @param traitType the trait type to reference as the metadata key\n     * @param value the token's trait associated with the key\n     * @return a JSON dictionary for the single attribute\n     */\n    function attributeForTypeAndValue(\n        string memory traitType,\n        string memory value\n    ) internal pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    '{\"trait_type\":\"',\n                    traitType,\n                    '\",\"value\":\"',\n                    value,\n                    '\"}'\n                )\n            );\n    }\n\n    /**\n     * generates an array composed of all the individual traits and values\n     * @param tokenId the ID of the token to compose the metadata for\n     * @return a JSON array of all of the attributes for given token ID\n     */\n    function compileAttributes(uint256 tokenId)\n        public\n        view\n        returns (string memory)\n    {\n        IChickenNoodle.ChickenNoodleTraits memory s = chickenNoodle.tokenTraits(\n            tokenId\n        );\n        string memory traits;\n\n        if (!s.minted) {\n            return\n                string(\n                    abi.encodePacked(\n                        '[{\"trait_type\":\"Generation\",\"value\":',\n                        tokenId <= chickenNoodle.PAID_TOKENS()\n                            ? '\"Gen 0\"'\n                            : '\"Gen 1\"',\n                        '},{\"trait_type\":\"Status\",\"value\":\"Minting\"}]'\n                    )\n                );\n        }\n\n        if (s.isChicken) {\n            traits = string(\n                abi.encodePacked(\n                    attributeForTypeAndValue(\n                        _traitTypes[0],\n                        traitData[0][s.backgrounds]\n                    ),\n                    ',',\n                    attributeForTypeAndValue(\n                        _traitTypes[1],\n                        traitData[1][s.snakeBodies]\n                    ),\n                    ',',\n                    attributeForTypeAndValue(\n                        _traitTypes[2],\n                        traitData[2][s.mouthAccessories]\n                    ),\n                    ',',\n                    attributeForTypeAndValue(\n                        _traitTypes[3],\n                        traitData[3][s.pupils]\n                    ),\n                    ',',\n                    attributeForTypeAndValue(_traitTypes[4], 'Chicken Suit'),\n                    ',',\n                    attributeForTypeAndValue(\n                        _traitTypes[5],\n                        traitData[5][s.hats]\n                    )\n                )\n            );\n        } else {\n            traits = string(\n                abi.encodePacked(\n                    attributeForTypeAndValue(\n                        _traitTypes[0],\n                        traitData[0][s.backgrounds]\n                    ),\n                    ',',\n                    attributeForTypeAndValue(\n                        _traitTypes[1],\n                        traitData[1][s.snakeBodies]\n                    ),\n                    ',',\n                    attributeForTypeAndValue(\n                        _traitTypes[2],\n                        traitData[2][s.mouthAccessories]\n                    ),\n                    ',',\n                    attributeForTypeAndValue(\n                        _traitTypes[3],\n                        traitData[3][s.pupils]\n                    ),\n                    ',',\n                    attributeForTypeAndValue(\n                        _traitTypes[4],\n                        traitData[4][s.bodyAccessories]\n                    ),\n                    ',',\n                    attributeForTypeAndValue(\n                        _traitTypes[5],\n                        traitData[5][s.hats]\n                    ),\n                    ',',\n                    attributeForTypeAndValue('Tier', s.tier.toString())\n                )\n            );\n        }\n\n        return\n            string(\n                abi.encodePacked(\n                    '[',\n                    '{\"trait_type\":\"Generation\",\"value\":',\n                    tokenId <= chickenNoodle.PAID_TOKENS()\n                        ? '\"Gen 0\"'\n                        : '\"Gen 1\"',\n                    '},{\"trait_type\":\"Type\",\"value\":',\n                    s.isChicken ? '\"Chicken\"' : '\"Snake\"',\n                    '},',\n                    traits,\n                    ']'\n                )\n            );\n    }\n\n    /**\n     * generates a base64 encoded metadata response without referencing off-chain content\n     * @param tokenId the ID of the token to generate the metadata for\n     * @return a base64 encoded JSON dictionary of the token's metadata and SVG\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        IChickenNoodle.ChickenNoodleTraits memory s = chickenNoodle.tokenTraits(\n            tokenId\n        );\n\n        string memory metadata = string(\n            abi.encodePacked(\n                '{\"name\": \"',\n                s.isChicken ? 'Chicken #' : 'Noodle #',\n                tokenId.toString(),\n                '\", \"image\": \"',\n                imageBaseURI,\n                tokenId.toString(),\n                '.png\", \"description\": \"',\n                description,\n                '\", \"attributes\":',\n                compileAttributes(tokenId),\n                '}'\n            )\n        );\n\n        return\n            string(\n                abi.encodePacked(\n                    'data:application/json;base64,',\n                    base64(bytes(metadata))\n                )\n            );\n    }\n\n    /** BASE 64 - Written by Brech Devos */\n\n    string internal constant TABLE =\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    function base64(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n\n                // read 3 bytes\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(248, mload(add(tablePtr, and(input, 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n        }\n\n        return result;\n    }\n}\n"},"contracts/interfaces/IChickenNoodle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IChickenNoodle {\n    // struct to store each token's traits\n    struct ChickenNoodleTraits {\n        bool minted;\n        bool isChicken;\n        uint8 backgrounds;\n        uint8 snakeBodies;\n        uint8 mouthAccessories;\n        uint8 pupils;\n        uint8 bodyAccessories;\n        uint8 hats;\n        uint8 tier;\n    }\n\n    function MAX_TOKENS() external view returns (uint256);\n\n    function PAID_TOKENS() external view returns (uint256);\n\n    function tokenTraits(uint256 tokenId)\n        external\n        view\n        returns (ChickenNoodleTraits memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address tokenOwner) external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function mint(address to, uint16 tokenId) external;\n\n    function finalize(\n        uint16 tokenId,\n        ChickenNoodleTraits memory traits,\n        address thief\n    ) external;\n}\n"},"contracts/interfaces/ITraits.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITraits {\n  function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"},"hardhat-deploy/solc_0.8/proxy/Proxied.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Proxied {\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\n    /// It also allows these functions to be called inside a contructor\n    /// even if the contract is meant to be used without proxy\n    modifier proxied() {\n        address proxyAdminAddress = _proxyAdmin();\n        // With hardhat-deploy proxies\n        // the proxyAdminAddress is zero only for the implementation contract\n        // if the implementation contract want to be used as a standalone/immutable contract\n        // it simply has to execute the `proxied` function\n        // This ensure the proxyAdminAddress is never zero post deployment\n        // And allow you to keep the same code for both proxied contract and immutable contract\n        if (proxyAdminAddress == address(0)) {\n            // ensure can not be called twice when used outside of proxy : no admin\n            // solhint-disable-next-line security/no-inline-assembly\n            assembly {\n                sstore(\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n            }\n        } else {\n            require(msg.sender == proxyAdminAddress);\n        }\n        _;\n    }\n\n    modifier onlyProxyAdmin() {\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function _proxyAdmin() internal view returns (address ownerAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n}\n"}}}