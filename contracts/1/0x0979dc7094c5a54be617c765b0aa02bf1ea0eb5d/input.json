{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/ACOAssetHelper.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\nlibrary ACOAssetHelper {\r\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n     * @dev Internal function to get if the address is for Ethereum (0x0).\r\n     * @param _address Address to be checked.\r\n     * @return Whether the address is for Ethereum.\r\n     */ \r\n    function _isEther(address _address) internal pure returns(bool) {\r\n        return _address == address(0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to approve ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param spender Authorized address.\r\n     * @param amount Amount to authorize.\r\n     */\r\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, amount));\r\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOAssetHelper::_callApproveERC20\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to transfer ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param recipient Address of the transfer destination.\r\n     * @param amount Amount to transfer.\r\n     */\r\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount));\r\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOAssetHelper::_callTransferERC20\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to call transferFrom on ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param sender Address of the sender.\r\n     * @param recipient Address of the transfer destination.\r\n     * @param amount Amount to transfer.\r\n     */\r\n     function _callTransferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\r\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOAssetHelper::_callTransferFromERC20\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset symbol.\r\n     * @param asset Address of the asset.\r\n     * @return The asset symbol.\r\n     */\r\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\r\n        if (_isEther(asset)) {\r\n            return \"ETH\";\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\r\n            require(success, \"ACOAssetHelper::_getAssetSymbol\");\r\n            return abi.decode(returndata, (string));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset decimals.\r\n     * @param asset Address of the asset.\r\n     * @return The asset decimals.\r\n     */\r\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\r\n        if (_isEther(asset)) {\r\n            return uint8(18);\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\r\n            require(success, \"ACOAssetHelper::_getAssetDecimals\");\r\n            return abi.decode(returndata, (uint8));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to the asset name.\r\n     * @param asset Address of the asset.\r\n     * @return The asset name.\r\n     */\r\n    function _getAssetName(address asset) internal view returns(string memory) {\r\n        if (_isEther(asset)) {\r\n            return \"Ethereum\";\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x06fdde03));\r\n            require(success, \"ACOAssetHelper::_getAssetName\");\r\n            return abi.decode(returndata, (string));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset balance of an account.\r\n     * @param asset Address of the asset.\r\n     * @param account Address of the account.\r\n     * @return The account balance.\r\n     */\r\n    function _getAssetBalanceOf(address asset, address account) internal view returns(uint256) {\r\n        if (_isEther(asset)) {\r\n            return account.balance;\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, account));\r\n            require(success, \"ACOAssetHelper::_getAssetBalanceOf\");\r\n            return abi.decode(returndata, (uint256));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset allowance between two addresses.\r\n     * @param asset Address of the asset.\r\n     * @param owner Address of the owner of the tokens.\r\n     * @param spender Address of the spender authorized.\r\n     * @return The owner allowance for the spender.\r\n     */\r\n    function _getAssetAllowance(address asset, address owner, address spender) internal view returns(uint256) {\r\n        if (_isEther(asset)) {\r\n            return 0;\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0xdd62ed3e, owner, spender));\r\n            require(success, \"ACOAssetHelper::_getAssetAllowance\");\r\n            return abi.decode(returndata, (uint256));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer an asset. \r\n     * @param asset Address of the asset to be transferred.\r\n     * @param to Address of the destination.\r\n     * @param amount The amount to be transferred.\r\n     */\r\n    function _transferAsset(address asset, address to, uint256 amount) internal {\r\n        if (_isEther(asset)) {\r\n            (bool success,) = to.call{value:amount}(new bytes(0));\r\n            require(success, 'ACOAssetHelper::_transferAsset');\r\n        } else {\r\n            _callTransferERC20(asset, to, amount);\r\n        }\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to receive an asset. \r\n     * @param asset Address of the asset to be received.\r\n     * @param amount The amount to be received.\r\n     */\r\n    function _receiveAsset(address asset, uint256 amount) internal {\r\n        if (_isEther(asset)) {\r\n            require(msg.value == amount, \"ACOAssetHelper:: Invalid ETH amount\");\r\n        } else {\r\n            require(msg.value == 0, \"ACOAssetHelper:: Ether is not expected\");\r\n            _callTransferFromERC20(asset, msg.sender, address(this), amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to check asset allowance and set to Infinity if necessary.\r\n     * @param asset Address of the asset.\r\n     * @param owner Address of the owner of the tokens.\r\n     * @param spender Address of the spender authorized.\r\n     * @param amount Amount to check allowance.\r\n     */\r\n    function _setAssetInfinityApprove(address asset, address owner, address spender, uint256 amount) internal {\r\n        if (_getAssetAllowance(asset, owner, spender) < amount) {\r\n            _callApproveERC20(asset, spender, MAX_UINT);\r\n        }\r\n    }\r\n}"
    },
    "browser/ACONameFormatter.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\nimport './BokkyPooBahsDateTimeLibrary.sol';\r\nimport './Strings.sol';\r\n\r\nlibrary ACONameFormatter {\r\n    \r\n    /**\r\n     * @dev Function to get the `value` formatted.\r\n\t * The function returns a string for the `value` with a point (character '.') in the proper position considering the `decimals`.\r\n\t * Beyond that, the string returned presents only representative digits.\r\n\t * For example, a `value` with 18 decimals:\r\n\t *  - For 100000000000000000000 the return is \"100\"\r\n\t *  - For 100100000000000000000 the return is \"100.1\"\r\n\t *  - For 100000000000000000 the return is \"0.1\"\r\n\t *  - For 100000000000000 the return is \"0.0001\"\r\n\t *  - For 100000000000000000001 the return is \"100.000000000000000001\"\r\n\t * @param value The number to be formatted.\r\n\t * @param decimals The respective number decimals.\r\n     * @return The value formatted on a string.\r\n     */\r\n    function formatNumber(uint256 value, uint8 decimals) internal pure returns(string memory) {\r\n        uint256 digits;\r\n        uint256 count;\r\n        bool foundRepresentativeDigit = false;\r\n        uint256 addPointAt = 0;\r\n        uint256 temp = value;\r\n        uint256 number = value;\r\n        while (temp != 0) {\r\n            if (!foundRepresentativeDigit && (temp % 10 != 0 || count == uint256(decimals))) {\r\n                foundRepresentativeDigit = true;\r\n                number = temp;\r\n            }\r\n            if (foundRepresentativeDigit) {\r\n                if (count == uint256(decimals)) {\r\n                    addPointAt = digits;\r\n                }\r\n                digits++;\r\n            }\r\n            temp /= 10;\r\n            count++;\r\n        }\r\n        if (count <= uint256(decimals)) {\r\n            digits = digits + 2 + uint256(decimals) - count;\r\n            addPointAt = digits - 2;\r\n        } else if (addPointAt > 0) {\r\n            digits++;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = number;\r\n        for (uint256 i = 0; i < digits; ++i) {\r\n            if (i > 0 && i == addPointAt) {\r\n                buffer[index--] = byte(\".\");\r\n            } else if (number == 0) {\r\n                buffer[index--] = byte(\"0\");\r\n            } else {\r\n                buffer[index--] = byte(uint8(48 + number % 10));\r\n                number /= 10;\r\n            }\r\n        }\r\n        return string(buffer);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to get the `unixTime` formatted.\r\n     * @param unixTime The UNIX time to be formatted.\r\n     * @return The unix time formatted on a string.\r\n     */\r\n    function formatTime(uint256 unixTime) internal pure returns(string memory) {\r\n        (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute,) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(unixTime); \r\n        return string(abi.encodePacked(\r\n            _getDateNumberWithTwoCharacters(day),\r\n            _getMonthFormatted(month),\r\n            _getYearFormatted(year),\r\n            \"-\",\r\n            _getDateNumberWithTwoCharacters(hour),\r\n            _getDateNumberWithTwoCharacters(minute),\r\n            \"UTC\"\r\n            )); \r\n    }\r\n    \r\n    /**\r\n     * @dev Function to get the token type description.\r\n     * @return The token type description.\r\n     */\r\n    function formatType(bool isCall) internal pure returns(string memory) {\r\n        if (isCall) {\r\n            return \"C\";\r\n        } else {\r\n            return \"P\";\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to get the year formatted with 2 characters.\r\n     * @return The year formatted.\r\n     */\r\n    function _getYearFormatted(uint256 year) private pure returns(string memory) {\r\n        bytes memory yearBytes = bytes(Strings.toString(year));\r\n        bytes memory result = new bytes(2);\r\n        uint256 startIndex = yearBytes.length - 2;\r\n        for (uint256 i = startIndex; i < yearBytes.length; i++) {\r\n            result[i - startIndex] = yearBytes[i];\r\n        }\r\n        return string(result);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to get the month abbreviation.\r\n     * @return The month abbreviation.\r\n     */\r\n    function _getMonthFormatted(uint256 month) private pure returns(string memory) {\r\n        if (month == 1) {\r\n            return \"JAN\";\r\n        } else if (month == 2) {\r\n            return \"FEB\";\r\n        } else if (month == 3) {\r\n            return \"MAR\";\r\n        } else if (month == 4) {\r\n            return \"APR\";\r\n        } else if (month == 5) {\r\n            return \"MAY\";\r\n        } else if (month == 6) {\r\n            return \"JUN\";\r\n        } else if (month == 7) {\r\n            return \"JUL\";\r\n        } else if (month == 8) {\r\n            return \"AUG\";\r\n        } else if (month == 9) {\r\n            return \"SEP\";\r\n        } else if (month == 10) {\r\n            return \"OCT\";\r\n        } else if (month == 11) {\r\n            return \"NOV\";\r\n        } else if (month == 12) {\r\n            return \"DEC\";\r\n        } else {\r\n            return \"INVALID\";\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to get the date number with 2 characters.\r\n     * @return The 2 characters for the number.\r\n     */\r\n    function _getDateNumberWithTwoCharacters(uint256 number) private pure returns(string memory) {\r\n        string memory _string = Strings.toString(number);\r\n        if (number < 10) {\r\n            return string(abi.encodePacked(\"0\", _string));\r\n        } else {\r\n            return _string;\r\n        }\r\n    }\r\n}"
    },
    "browser/ACOPool.sol": {
      "content": "pragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './Ownable.sol';\r\nimport './SafeMath.sol';\r\nimport './Address.sol';\r\nimport './ACONameFormatter.sol';\r\nimport './ACOAssetHelper.sol';\r\nimport './ERC20.sol';\r\nimport './IACOPool.sol';\r\nimport './IACOFactory.sol';\r\nimport './IACOStrategy.sol';\r\nimport './IACOToken.sol';\r\nimport './IACOFlashExercise.sol';\r\nimport './IACOAssetConverterHelper.sol';\r\nimport './IChiToken.sol';\r\n\r\n/**\r\n * @title ACOPool\r\n * @dev A pool contract to trade ACO tokens.\r\n */\r\ncontract ACOPool is Ownable, ERC20, IACOPool {\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n    \r\n    uint256 internal constant POOL_PRECISION = 1000000000000000000; // 18 decimals\r\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    \r\n\t/**\r\n     * @dev Struct to store an ACO token trade data.\r\n     */\r\n    struct ACOTokenData {\r\n\t\t/**\r\n         * @dev Amount of tokens sold by the pool.\r\n         */\r\n        uint256 amountSold;\r\n\t\t\r\n\t\t/**\r\n         * @dev Amount of tokens purchased by the pool.\r\n         */\r\n        uint256 amountPurchased;\r\n\t\t\r\n\t\t/**\r\n         * @dev Index of the ACO token on the stored array.\r\n         */\r\n        uint256 index;\r\n    }\r\n    \r\n\t/**\r\n     * @dev Emitted when the strategy address has been changed.\r\n     * @param oldStrategy Address of the previous strategy.\r\n     * @param newStrategy Address of the new strategy.\r\n     */\r\n    event SetStrategy(address indexed oldStrategy, address indexed newStrategy);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the base volatility has been changed.\r\n     * @param oldBaseVolatility Value of the previous base volatility.\r\n     * @param newBaseVolatility Value of the new base volatility.\r\n     */\r\n    event SetBaseVolatility(uint256 indexed oldBaseVolatility, uint256 indexed newBaseVolatility);\r\n\t\r\n\t/**\r\n     * @dev Emitted when a collateral has been deposited on the pool.\r\n     * @param account Address of the account.\r\n     * @param amount Amount deposited.\r\n     */\r\n    event CollateralDeposited(address indexed account, uint256 amount);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the collateral and premium have been redeemed on the pool.\r\n     * @param account Address of the account.\r\n     * @param underlyingAmount Amount of underlying asset redeemed.\r\n     * @param strikeAssetAmount Amount of strike asset redeemed.\r\n     */\r\n    event Redeem(address indexed account, uint256 underlyingAmount, uint256 strikeAssetAmount);\r\n\t\r\n\t/**\r\n     * @dev Emitted when the collateral has been restored on the pool.\r\n     * @param amountOut Amount of the premium sold.\r\n     * @param collateralIn Amount of collateral restored.\r\n     */\r\n    event RestoreCollateral(uint256 amountOut, uint256 collateralIn);\r\n\t\r\n\t/**\r\n     * @dev Emitted when an ACO token has been redeemed.\r\n     * @param acoToken Address of the ACO token.\r\n     * @param collateralIn Amount of collateral redeemed.\r\n     * @param amountSold Total amount of ACO token sold by the pool.\r\n     * @param amountPurchased Total amount of ACO token purchased by the pool.\r\n     */\r\n    event ACORedeem(address indexed acoToken, uint256 collateralIn, uint256 amountSold, uint256 amountPurchased);\r\n\t\r\n\t/**\r\n     * @dev Emitted when an ACO token has been exercised.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens exercised.\r\n     * @param collateralIn Amount of collateral received.\r\n     */\r\n    event ACOExercise(address indexed acoToken, uint256 tokenAmount, uint256 collateralIn);\r\n\t\r\n\t/**\r\n     * @dev Emitted when an ACO token has been bought or sold by the pool.\r\n     * @param isPoolSelling True whether the pool is selling an ACO token, otherwise the pool is buying.\r\n     * @param account Address of the account that is doing the swap.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens swapped.\r\n     * @param price Value of the premium paid in strike asset.\r\n     * @param protocolFee Value of the protocol fee paid in strike asset.\r\n     * @param underlyingPrice The underlying price in strike asset.\r\n     */\r\n    event Swap(\r\n        bool indexed isPoolSelling, \r\n        address indexed account, \r\n        address indexed acoToken, \r\n        uint256 tokenAmount, \r\n        uint256 price, \r\n        uint256 protocolFee,\r\n        uint256 underlyingPrice\r\n    );\r\n    \r\n\t/**\r\n\t * @dev UNIX timestamp that the pool can start to trade ACO tokens.\r\n\t */\r\n    uint256 public poolStart;\r\n\t\r\n\t/**\r\n\t * @dev The protocol fee percentage. (100000 = 100%)\r\n\t */\r\n    uint256 public fee;\r\n\t\r\n\t/**\r\n\t * @dev Address of the ACO flash exercise contract.\r\n\t */\r\n    IACOFlashExercise public acoFlashExercise;\r\n\t\r\n\t/**\r\n\t * @dev Address of the ACO factory contract.\r\n\t */\r\n    IACOFactory public acoFactory;\r\n\t\r\n\t/**\r\n\t * @dev Address of the asset converter helper.\r\n\t */\r\n    IACOAssetConverterHelper public assetConverterHelper;\r\n\t\r\n\t/**\r\n\t * @dev Address of the Chi gas token.\r\n\t */\r\n    IChiToken public chiToken;\r\n\t\r\n\t/**\r\n\t * @dev Address of the protocol fee destination.\r\n\t */\r\n    address public feeDestination;\r\n    \r\n\t/**\r\n\t * @dev Address of the underlying asset accepts by the pool.\r\n\t */\r\n    address public underlying;\r\n\t\r\n\t/**\r\n\t * @dev Address of the strike asset accepts by the pool.\r\n\t */\r\n    address public strikeAsset;\r\n\t\r\n\t/**\r\n\t * @dev Value of the minimum strike price on ACO token that the pool accept to trade.\r\n\t */\r\n    uint256 public minStrikePrice;\r\n\t\r\n\t/**\r\n\t * @dev Value of the maximum strike price on ACO token that the pool accept to trade.\r\n\t */\r\n    uint256 public maxStrikePrice;\r\n\t\r\n\t/**\r\n\t * @dev Value of the minimum UNIX expiration on ACO token that the pool accept to trade.\r\n\t */\r\n    uint256 public minExpiration;\r\n\t\r\n\t/**\r\n\t * @dev Value of the maximum UNIX expiration on ACO token that the pool accept to trade.\r\n\t */\r\n    uint256 public maxExpiration;\r\n\t\r\n\t/**\r\n\t * @dev True whether the pool accepts CALL options, otherwise the pool accepts only PUT options. \r\n\t */\r\n    bool public isCall;\r\n\t\r\n\t/**\r\n\t * @dev True whether the pool can also buy ACO tokens, otherwise the pool only sells ACO tokens. \r\n\t */\r\n    bool public canBuy;\r\n    \r\n\t/**\r\n\t * @dev Address of the strategy. \r\n\t */\r\n    IACOStrategy public strategy;\r\n\t\r\n\t/**\r\n\t * @dev Percentage value for the base volatility. (100000 = 100%) \r\n\t */\r\n    uint256 public baseVolatility;\r\n    \r\n\t/**\r\n\t * @dev Total amount of collateral deposited.  \r\n\t */\r\n    uint256 public collateralDeposited;\r\n\t\r\n\t/**\r\n\t * @dev Total amount in strike asset spent buying ACO tokens.  \r\n\t */\r\n    uint256 public strikeAssetSpentBuying;\r\n\t\r\n\t/**\r\n\t * @dev Total amount in strike asset earned selling ACO tokens.  \r\n\t */\r\n    uint256 public strikeAssetEarnedSelling;\r\n    \r\n\t/**\r\n\t * @dev Array of ACO tokens currently negotiated.  \r\n\t */\r\n    address[] public acoTokens;\r\n\t\r\n\t/**\r\n\t * @dev Mapping for ACO tokens data currently negotiated.  \r\n\t */\r\n    mapping(address => ACOTokenData) public acoTokensData;\r\n    \r\n\t/**\r\n\t * @dev Underlying asset precision. (18 decimals = 1000000000000000000)\r\n\t */\r\n    uint256 internal underlyingPrecision;\r\n\t\r\n\t/**\r\n\t * @dev Strike asset precision. (6 decimals = 1000000)\r\n\t */\r\n    uint256 internal strikeAssetPrecision;\r\n    \r\n\t/**\r\n     * @dev Modifier to check if the pool is open to trade.\r\n     */\r\n    modifier open() {\r\n        require(isStarted() && notFinished(), \"ACOPool:: Pool is not open\");\r\n        _;\r\n    }\r\n    \r\n\t/**\r\n     * @dev Modifier to apply the Chi gas token and save gas.\r\n     */\r\n    modifier discountCHI {\r\n        uint256 gasStart = gasleft();\r\n        _;\r\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\r\n        chiToken.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\r\n    }\r\n\t\r\n    /**\r\n     * @dev Function to initialize the contract.\r\n     * It should be called by the ACO pool factory when creating the pool.\r\n     * It must be called only once. The first `require` is to guarantee that behavior.\r\n     * @param initData The initialize data.\r\n     */\r\n    function init(InitData calldata initData) external override {\r\n        require(underlying == address(0) && strikeAsset == address(0) && minExpiration == 0, \"ACOPool::init: Already initialized\");\r\n        \r\n        require(initData.acoFactory.isContract(), \"ACOPool:: Invalid ACO Factory\");\r\n        require(initData.acoFlashExercise.isContract(), \"ACOPool:: Invalid ACO flash exercise\");\r\n        require(initData.chiToken.isContract(), \"ACOPool:: Invalid Chi Token\");\r\n\t\trequire(initData.assetConverterHelper.isContract(), \"ACOPool:: Invalid asset converter helper\");\r\n        require(initData.fee <= 12500, \"ACOPool:: The maximum fee allowed is 12.5%\");\r\n        require(initData.poolStart > block.timestamp, \"ACOPool:: Invalid pool start\");\r\n        require(initData.minExpiration > block.timestamp, \"ACOPool:: Invalid expiration\");\r\n        require(initData.minStrikePrice <= initData.maxStrikePrice, \"ACOPool:: Invalid strike price range\");\r\n        require(initData.minStrikePrice > 0, \"ACOPool:: Invalid strike price\");\r\n        require(initData.minExpiration <= initData.maxExpiration, \"ACOPool:: Invalid expiration range\");\r\n        require(initData.underlying != initData.strikeAsset, \"ACOPool:: Same assets\");\r\n        require(ACOAssetHelper._isEther(initData.underlying) || initData.underlying.isContract(), \"ACOPool:: Invalid underlying\");\r\n        require(ACOAssetHelper._isEther(initData.strikeAsset) || initData.strikeAsset.isContract(), \"ACOPool:: Invalid strike asset\");\r\n        \r\n        super.init();\r\n        \r\n        poolStart = initData.poolStart;\r\n        acoFlashExercise = IACOFlashExercise(initData.acoFlashExercise);\r\n        acoFactory = IACOFactory(initData.acoFactory);\r\n        chiToken = IChiToken(initData.chiToken);\r\n\t\tassetConverterHelper = IACOAssetConverterHelper(initData.assetConverterHelper);\r\n\t\t\r\n        fee = initData.fee;\r\n        feeDestination = initData.feeDestination;\r\n        underlying = initData.underlying;\r\n        strikeAsset = initData.strikeAsset;\r\n        minStrikePrice = initData.minStrikePrice;\r\n        maxStrikePrice = initData.maxStrikePrice;\r\n        minExpiration = initData.minExpiration;\r\n        maxExpiration = initData.maxExpiration;\r\n        isCall = initData.isCall;\r\n        canBuy = initData.canBuy;\r\n\t\t\r\n        _setStrategy(initData.strategy);\r\n        _setBaseVolatility(initData.baseVolatility);\r\n        \r\n        _setAssetsPrecision(initData.underlying, initData.strikeAsset);\r\n        \r\n        _approveAssetsOnConverterHelper(initData.isCall, initData.canBuy, initData.assetConverterHelper, initData.underlying, initData.strikeAsset);\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to get the token name.\r\n     */\r\n    function name() public view override returns(string memory) {\r\n        return _name();\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to get the token symbol, that it is equal to the name.\r\n     */\r\n    function symbol() public view override returns(string memory) {\r\n        return _name();\r\n    }\r\n    \r\n\t/**\r\n     * @dev Function to get the token decimals.\r\n     */\r\n    function decimals() public view override returns(uint8) {\r\n        return 18;\r\n    }\r\n    \r\n\t/**\r\n     * @dev Function to get whether the pool already started trade ACO tokens.\r\n     */\r\n    function isStarted() public view returns(bool) {\r\n        return block.timestamp >= poolStart;\r\n    }\r\n    \r\n\t/**\r\n     * @dev Function to get whether the pool is not finished.\r\n     */\r\n    function notFinished() public view returns(bool) {\r\n        return block.timestamp < maxExpiration;\r\n    }\r\n    \r\n\t/**\r\n     * @dev Function to get the number of ACO tokens currently negotiated.\r\n     */\r\n    function numberOfACOTokensCurrentlyNegotiated() public override view returns(uint256) {\r\n        return acoTokens.length;\r\n    }\r\n    \r\n\t/**\r\n     * @dev Function to get the pool collateral asset.\r\n     */\r\n    function collateral() public override view returns(address) {\r\n        if (isCall) {\r\n            return underlying;\r\n        } else {\r\n            return strikeAsset;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to quote an ACO token swap.\r\n     * @param isBuying True whether it is quoting to buy an ACO token, otherwise it is quoting to sell an ACO token.\r\n     * @param acoToken Address of the ACO token.\r\n     * @param tokenAmount Amount of ACO tokens to swap.\r\n     * @return The swap price, the protocol fee charged on the swap, and the underlying price in strike asset.\r\n     */\r\n    function quote(bool isBuying, address acoToken, uint256 tokenAmount) open public override view returns(uint256, uint256, uint256) {\r\n        (uint256 swapPrice, uint256 protocolFee, uint256 underlyingPrice,) = _internalQuote(isBuying, acoToken, tokenAmount);\r\n        return (swapPrice, protocolFee, underlyingPrice);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the pool strategy address.\r\n     * Only can be called by the ACO pool factory contract.\r\n     * @param newStrategy Address of the new strategy.\r\n     */\r\n    function setStrategy(address newStrategy) onlyOwner external override {\r\n        _setStrategy(newStrategy);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the pool base volatility percentage. (100000 = 100%)\r\n     * Only can be called by the ACO pool factory contract.\r\n     * @param newBaseVolatility Value of the new base volatility.\r\n     */\r\n    function setBaseVolatility(uint256 newBaseVolatility) onlyOwner external override {\r\n        _setBaseVolatility(newBaseVolatility);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to deposit on the pool.\r\n     * Only can be called when the pool is not started.\r\n     * @param collateralAmount Amount of collateral to be deposited.\r\n     * @param to Address of the destination of the pool token.\r\n     * @return The amount of pool tokens minted.\r\n     */\r\n    function deposit(uint256 collateralAmount, address to) public override payable returns(uint256) {\r\n        require(!isStarted(), \"ACOPool:: Pool already started\");\r\n        require(collateralAmount > 0, \"ACOPool:: Invalid collateral amount\");\r\n        require(to != address(0) && to != address(this), \"ACOPool:: Invalid to\");\r\n        \r\n        (uint256 normalizedAmount, uint256 amount) = _getNormalizedDepositAmount(collateralAmount);\r\n        \r\n        ACOAssetHelper._receiveAsset(collateral(), amount);\r\n        \r\n        collateralDeposited = collateralDeposited.add(amount);\r\n        _mintAction(to, normalizedAmount);\r\n        \r\n        emit CollateralDeposited(msg.sender, amount);\r\n        \r\n        return normalizedAmount;\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to swap an ACO token with the pool.\r\n     * Only can be called when the pool is opened.\r\n     * @param isBuying True whether it is quoting to buy an ACO token, otherwise it is quoting to sell an ACO token.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens to swap.\r\n     * @param restriction Value of the swap restriction. The minimum premium to receive on a selling or the maximum value to pay on a purchase.\r\n     * @param to Address of the destination. ACO tokens when is buying or strike asset on a selling.\r\n     * @param deadline UNIX deadline for the swap to be executed.\r\n     * @return The amount ACO tokens received when is buying or the amount of strike asset received on a selling.\r\n     */\r\n    function swap(\r\n        bool isBuying, \r\n        address acoToken, \r\n        uint256 tokenAmount, \r\n        uint256 restriction, \r\n        address to, \r\n        uint256 deadline\r\n    ) open public override returns(uint256) {\r\n        return _swap(isBuying, acoToken, tokenAmount, restriction, to, deadline);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to swap an ACO token with the pool and use Chi token to save gas.\r\n     * Only can be called when the pool is opened.\r\n     * @param isBuying True whether it is quoting to buy an ACO token, otherwise it is quoting to sell an ACO token.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens to swap.\r\n     * @param restriction Value of the swap restriction. The minimum premium to receive on a selling or the maximum value to pay on a purchase.\r\n     * @param to Address of the destination. ACO tokens when is buying or strike asset on a selling.\r\n     * @param deadline UNIX deadline for the swap to be executed.\r\n     * @return The amount ACO tokens received when is buying or the amount of strike asset received on a selling.\r\n     */\r\n    function swapWithGasToken(\r\n        bool isBuying, \r\n        address acoToken, \r\n        uint256 tokenAmount, \r\n        uint256 restriction, \r\n        address to, \r\n        uint256 deadline\r\n    ) open discountCHI public override returns(uint256) {\r\n        return _swap(isBuying, acoToken, tokenAmount, restriction, to, deadline);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to redeem the collateral and the premium from the pool.\r\n     * Only can be called when the pool is finished.\r\n     * @return The amount of underlying asset received and the amount of strike asset received.\r\n     */\r\n    function redeem() public override returns(uint256, uint256) {\r\n        return _redeem(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to redeem the collateral and the premium from the pool from an account.\r\n     * Only can be called when the pool is finished.\r\n     * The allowance must be respected.\r\n     * The transaction sender will receive the redeemed assets.\r\n     * @param account Address of the account.\r\n     * @return The amount of underlying asset received and the amount of strike asset received.\r\n     */\r\n    function redeemFrom(address account) public override returns(uint256, uint256) {\r\n        return _redeem(account);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to redeem the collateral from the ACO tokens negotiated on the pool.\r\n     * It redeems the collateral only if the respective ACO token is expired.\r\n     */\r\n    function redeemACOTokens() public override {\r\n        for (uint256 i = acoTokens.length; i > 0; --i) {\r\n            address acoToken = acoTokens[i - 1];\r\n\t\t\tuint256 expiryTime = IACOToken(acoToken).expiryTime();\r\n            _redeemACOToken(acoToken, expiryTime);\r\n        }\r\n    }\r\n\t\r\n    /**\r\n     * @dev Function to redeem the collateral from an ACO token.\r\n     * It redeems the collateral only if the ACO token is expired.\r\n     * @param acoToken Address of the ACO token.\r\n     */\r\n\tfunction redeemACOToken(address acoToken) public override {\r\n        (,uint256 expiryTime) = _getValidACOTokenStrikePriceAndExpiration(acoToken);\r\n\t\t_redeemACOToken(acoToken, expiryTime);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to exercise an ACO token negotiated on the pool.\r\n     * Only ITM ACO tokens are exercisable.\r\n     * @param acoToken Address of the ACO token.\r\n     */\r\n    function exerciseACOToken(address acoToken) public override {\r\n        (uint256 strikePrice, uint256 expiryTime) = _getValidACOTokenStrikePriceAndExpiration(acoToken);\r\n        uint256 exercisableAmount = _getExercisableAmount(acoToken);\r\n        require(exercisableAmount > 0, \"ACOPool:: Exercise is not available\");\r\n        \r\n        address _strikeAsset = strikeAsset;\r\n        address _underlying = underlying;\r\n        bool _isCall = isCall;\r\n        \r\n        uint256 collateralAmount;\r\n        address _collateral;\r\n        if (_isCall) {\r\n            _collateral = _underlying;\r\n            collateralAmount = exercisableAmount;\r\n        } else {\r\n            _collateral = _strikeAsset;\r\n            collateralAmount = IACOToken(acoToken).getCollateralAmount(exercisableAmount);\r\n            \r\n        }\r\n        uint256 collateralAvailable = _getPoolBalanceOf(_collateral);\r\n        \r\n        ACOTokenData storage data = acoTokensData[acoToken];\r\n        (bool canExercise, uint256 minIntrinsicValue) = strategy.checkExercise(IACOStrategy.CheckExercise(\r\n            _underlying,\r\n            _strikeAsset,\r\n            _isCall,\r\n            strikePrice, \r\n            expiryTime,\r\n            collateralAmount,\r\n            collateralAvailable,\r\n            data.amountPurchased,\r\n            data.amountSold\r\n        ));\r\n        require(canExercise, \"ACOPool:: Exercise is not possible\");\r\n        \r\n        if (IACOToken(acoToken).allowance(address(this), address(acoFlashExercise)) < exercisableAmount) {\r\n            _setAuthorizedSpender(acoToken, address(acoFlashExercise));    \r\n        }\r\n        acoFlashExercise.flashExercise(acoToken, exercisableAmount, minIntrinsicValue, block.timestamp);\r\n        \r\n        uint256 collateralIn = _getPoolBalanceOf(_collateral).sub(collateralAvailable);\r\n        emit ACOExercise(acoToken, exercisableAmount, collateralIn);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to restore the collateral on the pool by selling the other asset balance.\r\n     */\r\n    function restoreCollateral() public override {\r\n        address _strikeAsset = strikeAsset;\r\n        address _underlying = underlying;\r\n        bool _isCall = isCall;\r\n        \r\n        uint256 balanceOut;\r\n        address assetIn;\r\n        address assetOut;\r\n        if (_isCall) {\r\n            balanceOut = _getPoolBalanceOf(_strikeAsset);\r\n            assetIn = _underlying;\r\n            assetOut = _strikeAsset;\r\n        } else {\r\n            balanceOut = _getPoolBalanceOf(_underlying);\r\n            assetIn = _strikeAsset;\r\n            assetOut = _underlying;\r\n        }\r\n        require(balanceOut > 0, \"ACOPool:: No balance\");\r\n        \r\n        uint256 acceptablePrice = strategy.getAcceptableUnderlyingPriceToSwapAssets(_underlying, _strikeAsset, false);\r\n        \r\n        uint256 minToReceive;\r\n        if (_isCall) {\r\n            minToReceive = balanceOut.mul(underlyingPrecision).div(acceptablePrice);\r\n        } else {\r\n            minToReceive = balanceOut.mul(acceptablePrice).div(underlyingPrecision);\r\n        }\r\n        uint256 collateralIn = _swapAssetsExactAmountOut(assetOut, assetIn, minToReceive, balanceOut);\r\n        \r\n        emit RestoreCollateral(balanceOut, collateralIn);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to swap an ACO token with the pool.\r\n     * @param isPoolSelling True whether the pool is selling an ACO token, otherwise the pool is buying.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens to swap.\r\n     * @param restriction Value of the swap restriction. The minimum premium to receive on a selling or the maximum value to pay on a purchase.\r\n     * @param to Address of the destination. ACO tokens when is buying or strike asset on a selling.\r\n     * @param deadline UNIX deadline for the swap to be executed.\r\n     * @return The amount ACO tokens received when is buying or the amount of strike asset received on a selling.\r\n     */\r\n    function _swap(\r\n        bool isPoolSelling, \r\n        address acoToken, \r\n        uint256 tokenAmount, \r\n        uint256 restriction, \r\n        address to, \r\n        uint256 deadline\r\n    ) internal returns(uint256) {\r\n        require(block.timestamp <= deadline, \"ACOPool:: Swap deadline\");\r\n        require(to != address(0) && to != acoToken && to != address(this), \"ACOPool:: Invalid destination\");\r\n        \r\n        (uint256 swapPrice, uint256 protocolFee, uint256 underlyingPrice, uint256 collateralAmount) = _internalQuote(isPoolSelling, acoToken, tokenAmount);\r\n        \r\n        uint256 amount;\r\n        if (isPoolSelling) {\r\n            amount = _internalSelling(to, acoToken, collateralAmount, tokenAmount, restriction, swapPrice, protocolFee);\r\n        } else {\r\n            amount = _internalBuying(to, acoToken, tokenAmount, restriction, swapPrice, protocolFee);\r\n        }\r\n        \r\n        if (protocolFee > 0) {\r\n            ACOAssetHelper._transferAsset(strikeAsset, feeDestination, protocolFee);\r\n        }\r\n        \r\n        emit Swap(isPoolSelling, msg.sender, acoToken, tokenAmount, swapPrice, protocolFee, underlyingPrice);\r\n        \r\n        return amount;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to quote an ACO token price.\r\n     * @param isPoolSelling True whether the pool is selling an ACO token, otherwise the pool is buying.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens to swap.\r\n     * @return The quote price, the protocol fee charged, the underlying price, and the collateral amount.\r\n     */\r\n    function _internalQuote(bool isPoolSelling, address acoToken, uint256 tokenAmount) internal view returns(uint256, uint256, uint256, uint256) {\r\n        require(isPoolSelling || canBuy, \"ACOPool:: The pool only sell\");\r\n        require(tokenAmount > 0, \"ACOPool:: Invalid token amount\");\r\n        (uint256 strikePrice, uint256 expiryTime) = _getValidACOTokenStrikePriceAndExpiration(acoToken);\r\n        require(expiryTime > block.timestamp, \"ACOPool:: ACO token expired\");\r\n        \r\n        (uint256 collateralAmount, uint256 collateralAvailable) = _getSizeData(isPoolSelling, acoToken, tokenAmount);\r\n        (uint256 price, uint256 underlyingPrice,) = _strategyQuote(acoToken, isPoolSelling, strikePrice, expiryTime, collateralAmount, collateralAvailable);\r\n        \r\n        price = price.mul(tokenAmount).div(underlyingPrecision);\r\n        \r\n        uint256 protocolFee = 0;\r\n        if (fee > 0) {\r\n            protocolFee = price.mul(fee).div(100000);\r\n            if (isPoolSelling) {\r\n                price = price.add(protocolFee);\r\n            } else {\r\n                price = price.sub(protocolFee);\r\n            }\r\n        }\r\n        require(price > 0, \"ACOPool:: Invalid quote\");\r\n        return (price, protocolFee, underlyingPrice, collateralAmount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the size data for a quote.\r\n     * @param isPoolSelling True whether the pool is selling an ACO token, otherwise the pool is buying.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param tokenAmount Amount of ACO tokens to swap.\r\n     * @return The collateral amount and the collateral available on the pool.\r\n     */\r\n    function _getSizeData(bool isPoolSelling, address acoToken, uint256 tokenAmount) internal view returns(uint256, uint256) {\r\n        uint256 collateralAmount;\r\n        uint256 collateralAvailable;\r\n        if (isCall) {\r\n            collateralAvailable = _getPoolBalanceOf(underlying);\r\n            collateralAmount = tokenAmount; \r\n        } else {\r\n            collateralAvailable = _getPoolBalanceOf(strikeAsset);\r\n            collateralAmount = IACOToken(acoToken).getCollateralAmount(tokenAmount);\r\n            require(collateralAmount > 0, \"ACOPool:: Token amount is too small\");\r\n        }\r\n        require(!isPoolSelling || collateralAmount <= collateralAvailable, \"ACOPool:: Insufficient liquidity\");\r\n        \r\n        return (collateralAmount, collateralAvailable);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to quote on the strategy contract.\r\n     * @param acoToken Address of the ACO token.\r\n     * @param isPoolSelling True whether the pool is selling an ACO token, otherwise the pool is buying.\r\n\t * @param strikePrice ACO token strike price.\r\n     * @param expiryTime ACO token expiry time on UNIX.\r\n     * @param collateralAmount Amount of collateral for the order size.\r\n     * @param collateralAvailable Amount of collateral available on the pool.\r\n     * @return The quote price, the underlying price and the volatility.\r\n     */\r\n    function _strategyQuote(\r\n        address acoToken,\r\n        bool isPoolSelling,\r\n        uint256 strikePrice,\r\n        uint256 expiryTime,\r\n        uint256 collateralAmount,\r\n        uint256 collateralAvailable\r\n    ) internal view returns(uint256, uint256, uint256) {\r\n        ACOTokenData storage data = acoTokensData[acoToken];\r\n        return strategy.quote(IACOStrategy.OptionQuote(\r\n            isPoolSelling, \r\n            underlying, \r\n            strikeAsset, \r\n            isCall, \r\n            strikePrice, \r\n            expiryTime, \r\n            baseVolatility, \r\n            collateralAmount, \r\n            collateralAvailable,\r\n            collateralDeposited,\r\n            strikeAssetEarnedSelling,\r\n            strikeAssetSpentBuying,\r\n            data.amountPurchased,\r\n            data.amountSold\r\n        ));\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to sell ACO tokens.\r\n     * @param to Address of the destination of the ACO tokens.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param collateralAmount Order collateral amount.\r\n     * @param tokenAmount Order token amount.\r\n     * @param maxPayment Maximum value to be paid for the ACO tokens.\r\n     * @param swapPrice The swap price quoted.\r\n     * @param protocolFee The protocol fee amount.\r\n     * @return The ACO token amount sold.\r\n     */\r\n    function _internalSelling(\r\n        address to,\r\n        address acoToken, \r\n        uint256 collateralAmount, \r\n        uint256 tokenAmount,\r\n        uint256 maxPayment,\r\n        uint256 swapPrice,\r\n        uint256 protocolFee\r\n    ) internal returns(uint256) {\r\n        require(swapPrice <= maxPayment, \"ACOPool:: Swap restriction\");\r\n        \r\n        ACOAssetHelper._callTransferFromERC20(strikeAsset, msg.sender, address(this), swapPrice);\r\n        \r\n        uint256 acoBalance = _getPoolBalanceOf(acoToken);\r\n\r\n        ACOTokenData storage acoTokenData = acoTokensData[acoToken];\r\n        uint256 _amountSold = acoTokenData.amountSold;\r\n        if (_amountSold == 0 && acoTokenData.amountPurchased == 0) {\r\n\t\t\tacoTokenData.index = acoTokens.length;\r\n            acoTokens.push(acoToken);    \r\n        }\r\n        if (tokenAmount > acoBalance) {\r\n            tokenAmount = acoBalance;\r\n            if (acoBalance > 0) {\r\n                collateralAmount = IACOToken(acoToken).getCollateralAmount(tokenAmount.sub(acoBalance));\r\n            }\r\n            if (collateralAmount > 0) {\r\n                address _collateral = collateral();\r\n                if (ACOAssetHelper._isEther(_collateral)) {\r\n                    tokenAmount = tokenAmount.add(IACOToken(acoToken).mintPayable{value: collateralAmount}());\r\n                } else {\r\n                    if (_amountSold == 0) {\r\n                        _setAuthorizedSpender(_collateral, acoToken);    \r\n                    }\r\n                    tokenAmount = tokenAmount.add(IACOToken(acoToken).mint(collateralAmount));\r\n                }\r\n            }\r\n        }\r\n        \r\n        acoTokenData.amountSold = tokenAmount.add(_amountSold);\r\n        strikeAssetEarnedSelling = swapPrice.sub(protocolFee).add(strikeAssetEarnedSelling); \r\n        \r\n        ACOAssetHelper._callTransferERC20(acoToken, to, tokenAmount);\r\n        \r\n        return tokenAmount;\r\n    }\r\n\t\r\n    /**\r\n     * @dev Internal function to buy ACO tokens.\r\n     * @param to Address of the destination of the premium.\r\n     * @param acoToken Address of the ACO token.\r\n     * @param tokenAmount Order token amount.\r\n     * @param minToReceive Minimum value to be received for the ACO tokens.\r\n     * @param swapPrice The swap price quoted.\r\n     * @param protocolFee The protocol fee amount.\r\n     * @return The premium amount transferred.\r\n     */\r\n    function _internalBuying(\r\n        address to,\r\n        address acoToken, \r\n        uint256 tokenAmount, \r\n        uint256 minToReceive,\r\n        uint256 swapPrice,\r\n        uint256 protocolFee\r\n    ) internal returns(uint256) {\r\n        require(swapPrice >= minToReceive, \"ACOPool:: Swap restriction\");\r\n        \r\n        uint256 requiredStrikeAsset = swapPrice.add(protocolFee);\r\n        if (isCall) {\r\n            _getStrikeAssetAmount(requiredStrikeAsset);\r\n        }\r\n        \r\n        ACOAssetHelper._callTransferFromERC20(acoToken, msg.sender, address(this), tokenAmount);\r\n        \r\n        ACOTokenData storage acoTokenData = acoTokensData[acoToken];\r\n        uint256 _amountPurchased = acoTokenData.amountPurchased;\r\n        if (_amountPurchased == 0 && acoTokenData.amountSold == 0) {\r\n\t\t\tacoTokenData.index = acoTokens.length;\r\n            acoTokens.push(acoToken);    \r\n        }\r\n        acoTokenData.amountPurchased = tokenAmount.add(_amountPurchased);\r\n        strikeAssetSpentBuying = requiredStrikeAsset.add(strikeAssetSpentBuying);\r\n        \r\n        ACOAssetHelper._transferAsset(strikeAsset, to, swapPrice);\r\n        \r\n        return swapPrice;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to get the normalized deposit amount.\r\n\t * The pool token has always with 18 decimals.\r\n     * @param collateralAmount Amount of collateral to be deposited.\r\n     * @return The normalized token amount and the collateral amount.\r\n     */\r\n    function _getNormalizedDepositAmount(uint256 collateralAmount) internal view returns(uint256, uint256) {\r\n        uint256 basePrecision = isCall ? underlyingPrecision : strikeAssetPrecision;\r\n        uint256 normalizedAmount;\r\n        if (basePrecision > POOL_PRECISION) {\r\n            uint256 adjust = basePrecision.div(POOL_PRECISION);\r\n            normalizedAmount = collateralAmount.div(adjust);\r\n            collateralAmount = normalizedAmount.mul(adjust);\r\n        } else if (basePrecision < POOL_PRECISION) {\r\n            normalizedAmount = collateralAmount.mul(POOL_PRECISION.div(basePrecision));\r\n        } else {\r\n            normalizedAmount = collateralAmount;\r\n        }\r\n        require(normalizedAmount > 0, \"ACOPool:: Invalid collateral amount\");\r\n        return (normalizedAmount, collateralAmount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to get an amount of strike asset for the pool.\r\n\t * The pool swaps the collateral for it if necessary.\r\n     * @param strikeAssetAmount Amount of strike asset required.\r\n     */\r\n    function _getStrikeAssetAmount(uint256 strikeAssetAmount) internal {\r\n        address _strikeAsset = strikeAsset;\r\n        uint256 balance = _getPoolBalanceOf(_strikeAsset);\r\n        if (balance < strikeAssetAmount) {\r\n            uint256 amountToPurchase = strikeAssetAmount.sub(balance);\r\n            address _underlying = underlying;\r\n            uint256 acceptablePrice = strategy.getAcceptableUnderlyingPriceToSwapAssets(_underlying, _strikeAsset, true);\r\n            uint256 maxPayment = amountToPurchase.mul(underlyingPrecision).div(acceptablePrice);\r\n            _swapAssetsExactAmountIn(_underlying, _strikeAsset, amountToPurchase, maxPayment);\r\n        }\r\n    }\r\n\t\r\n    /**\r\n     * @dev Internal function to redeem the collateral from an ACO token.\r\n     * It redeems the collateral only if the ACO token is expired.\r\n     * @param acoToken Address of the ACO token.\r\n\t * @param expiryTime ACO token expiry time in UNIX.\r\n     */\r\n\tfunction _redeemACOToken(address acoToken, uint256 expiryTime) internal {\r\n\t\tif (expiryTime <= block.timestamp) {\r\n\r\n            uint256 collateralIn = 0;\r\n            if (IACOToken(acoToken).currentCollateralizedTokens(address(this)) > 0) {\t\r\n\t\t\t    collateralIn = IACOToken(acoToken).redeem();\r\n            }\r\n\t\t\t\r\n\t\t\tACOTokenData storage data = acoTokensData[acoToken];\r\n\t\t\tuint256 lastIndex = acoTokens.length - 1;\r\n\t\t\tif (lastIndex != data.index) {\r\n\t\t\t\taddress last = acoTokens[lastIndex];\r\n\t\t\t\tacoTokensData[last].index = data.index;\r\n\t\t\t\tacoTokens[data.index] = last;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\temit ACORedeem(acoToken, collateralIn, data.amountSold, data.amountPurchased);\r\n\t\t\t\r\n\t\t\tacoTokens.pop();\r\n\t\t\tdelete acoTokensData[acoToken];\r\n\t\t}\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to redeem the collateral and the premium from the pool from an account.\r\n     * @param account Address of the account.\r\n     * @return The amount of underlying asset received and the amount of strike asset received.\r\n     */\r\n    function _redeem(address account) internal returns(uint256, uint256) {\r\n        uint256 share = balanceOf(account);\r\n        require(share > 0, \"ACOPool:: Account with no share\");\r\n        require(!notFinished(), \"ACOPool:: Pool is not finished\");\r\n        \r\n        redeemACOTokens();\r\n        \r\n        uint256 _totalSupply = totalSupply();\r\n        uint256 underlyingBalance = share.mul(_getPoolBalanceOf(underlying)).div(_totalSupply);\r\n        uint256 strikeAssetBalance = share.mul(_getPoolBalanceOf(strikeAsset)).div(_totalSupply);\r\n        \r\n        _callBurn(account, share);\r\n        \r\n        if (underlyingBalance > 0) {\r\n            ACOAssetHelper._transferAsset(underlying, msg.sender, underlyingBalance);\r\n        }\r\n        if (strikeAssetBalance > 0) {\r\n            ACOAssetHelper._transferAsset(strikeAsset, msg.sender, strikeAssetBalance);\r\n        }\r\n        \r\n        emit Redeem(msg.sender, underlyingBalance, strikeAssetBalance);\r\n        \r\n        return (underlyingBalance, strikeAssetBalance);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to burn pool tokens.\r\n     * @param account Address of the account.\r\n     * @param tokenAmount Amount of pool tokens to be burned.\r\n     */\r\n    function _callBurn(address account, uint256 tokenAmount) internal {\r\n        if (account == msg.sender) {\r\n            super._burnAction(account, tokenAmount);\r\n        } else {\r\n            super._burnFrom(account, tokenAmount);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to swap assets on the asset converter helper with an exact amount of an asset to be sold.\r\n     * @param assetOut Address of the asset to be sold.\r\n\t * @param assetIn Address of the asset to be purchased.\r\n     * @param minAmountIn Minimum amount to be received.\r\n     * @param amountOut The exact amount to be sold.\r\n\t * @return The amount of asset purchased.\r\n     */\r\n    function _swapAssetsExactAmountOut(address assetOut, address assetIn, uint256 minAmountIn, uint256 amountOut) internal returns(uint256) {\r\n\t\tuint256 etherAmount = 0;\r\n        if (ACOAssetHelper._isEther(assetOut)) {\r\n\t\t\tetherAmount = amountOut;\r\n        }\r\n        return assetConverterHelper.swapExactAmountOutWithMinAmountToReceive{value: etherAmount}(assetOut, assetIn, amountOut, minAmountIn);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to swap assets on the asset converter helper with an exact amount of an asset to be purchased.\r\n     * @param assetOut Address of the asset to be sold.\r\n\t * @param assetIn Address of the asset to be purchased.\r\n     * @param amountIn The exact amount to be purchased.\r\n     * @param maxAmountOut Maximum amount to be paid.\r\n\t * @return The amount of asset sold.\r\n     */\r\n    function _swapAssetsExactAmountIn(address assetOut, address assetIn, uint256 amountIn, uint256 maxAmountOut) internal returns(uint256) {\r\n\t\tuint256 etherAmount = 0;\r\n        if (ACOAssetHelper._isEther(assetOut)) {\r\n\t\t\tetherAmount = maxAmountOut;\r\n        }\r\n        return assetConverterHelper.swapExactAmountInWithMaxAmountToSold{value: etherAmount}(assetOut, assetIn, amountIn, maxAmountOut);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the strategy address.\r\n     * @param newStrategy Address of the new strategy.\r\n     */\r\n    function _setStrategy(address newStrategy) internal {\r\n        require(newStrategy.isContract(), \"ACOPool:: Invalid strategy\");\r\n        emit SetStrategy(address(strategy), newStrategy);\r\n        strategy = IACOStrategy(newStrategy);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the base volatility percentage. (100000 = 100%)\r\n     * @param newBaseVolatility Value of the new base volatility.\r\n     */\r\n    function _setBaseVolatility(uint256 newBaseVolatility) internal {\r\n        require(newBaseVolatility > 0, \"ACOPool:: Invalid base volatility\");\r\n        emit SetBaseVolatility(baseVolatility, newBaseVolatility);\r\n        baseVolatility = newBaseVolatility;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the pool assets precisions.\r\n     * @param _underlying Address of the underlying asset.\r\n     * @param _strikeAsset Address of the strike asset.\r\n     */\r\n    function _setAssetsPrecision(address _underlying, address _strikeAsset) internal {\r\n        underlyingPrecision = 10 ** uint256(ACOAssetHelper._getAssetDecimals(_underlying));\r\n        strikeAssetPrecision = 10 ** uint256(ACOAssetHelper._getAssetDecimals(_strikeAsset));\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to infinite authorize the pool assets on the asset converter helper.\r\n     * @param _isCall True whether it is a CALL option, otherwise it is PUT.\r\n     * @param _canBuy True whether the pool can also buy ACO tokens, otherwise it only sells.\r\n     * @param _assetConverterHelper Address of the asset converter helper.\r\n     * @param _underlying Address of the underlying asset.\r\n     * @param _strikeAsset Address of the strike asset.\r\n     */\r\n    function _approveAssetsOnConverterHelper(\r\n        bool _isCall, \r\n        bool _canBuy, \r\n        address _assetConverterHelper,\r\n        address _underlying,\r\n        address _strikeAsset\r\n    ) internal {\r\n        if (_isCall) {\r\n            if (!ACOAssetHelper._isEther(_strikeAsset)) {\r\n                _setAuthorizedSpender(_strikeAsset, _assetConverterHelper);\r\n            }\r\n            if (_canBuy && !ACOAssetHelper._isEther(_underlying)) {\r\n                _setAuthorizedSpender(_underlying, _assetConverterHelper);\r\n            }\r\n        } else if (!ACOAssetHelper._isEther(_underlying)) {\r\n            _setAuthorizedSpender(_underlying, _assetConverterHelper);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to infinite authorize a spender on an asset.\r\n     * @param asset Address of the asset.\r\n     * @param spender Address of the spender to be authorized.\r\n     */\r\n    function _setAuthorizedSpender(address asset, address spender) internal {\r\n        ACOAssetHelper._callApproveERC20(asset, spender, MAX_UINT);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to get the pool balance of an asset.\r\n     * @param asset Address of the asset.\r\n     * @return The pool balance.\r\n     */\r\n    function _getPoolBalanceOf(address asset) internal view returns(uint256) {\r\n        return ACOAssetHelper._getAssetBalanceOf(asset, address(this));\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to get the exercible amount of an ACO token.\r\n     * @param acoToken Address of the ACO token.\r\n     * @return The exercisable amount.\r\n     */\r\n    function _getExercisableAmount(address acoToken) internal view returns(uint256) {\r\n        uint256 balance = _getPoolBalanceOf(acoToken);\r\n        if (balance > 0) {\r\n            uint256 collaterized = IACOToken(acoToken).currentCollateralizedTokens(address(this));\r\n            if (balance > collaterized) {\r\n                return balance.sub(collaterized);\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to get an accepted ACO token by the pool.\r\n     * @param acoToken Address of the ACO token.\r\n     * @return The ACO token strike price, and the ACO token expiration.\r\n     */\r\n    function _getValidACOTokenStrikePriceAndExpiration(address acoToken) internal view returns(uint256, uint256) {\r\n        (address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime) = acoFactory.acoTokenData(acoToken);\r\n        require(\r\n            _underlying == underlying && \r\n            _strikeAsset == strikeAsset && \r\n            _isCall == isCall && \r\n            _strikePrice >= minStrikePrice &&\r\n            _strikePrice <= maxStrikePrice &&\r\n            _expiryTime >= minExpiration &&\r\n            _expiryTime <= maxExpiration,\r\n            \"ACOPool:: Invalid ACO Token\"\r\n        );\r\n        return (_strikePrice, _expiryTime);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to get the token name.\r\n     * The token name is assembled  with the token data:\r\n     * ACO POOL UNDERLYING_SYMBOL-STRIKE_ASSET_SYMBOL-TYPE-{ONLY_SELL}-MIN_STRIKE_PRICE-MAX_STRIKE_PRICE-MIN_EXPIRATION-MAX_EXPIRATION\r\n     * @return The token name.\r\n     */\r\n    function _name() internal view returns(string memory) {\r\n        uint8 strikeDecimals = ACOAssetHelper._getAssetDecimals(strikeAsset);\r\n        string memory strikePriceFormatted;\r\n        if (minStrikePrice != maxStrikePrice) {\r\n            strikePriceFormatted = string(abi.encodePacked(ACONameFormatter.formatNumber(minStrikePrice, strikeDecimals), \"-\", ACONameFormatter.formatNumber(maxStrikePrice, strikeDecimals)));\r\n        } else {\r\n            strikePriceFormatted = ACONameFormatter.formatNumber(minStrikePrice, strikeDecimals);\r\n        }\r\n        string memory dateFormatted;\r\n        if (minExpiration != maxExpiration) {\r\n            dateFormatted = string(abi.encodePacked(ACONameFormatter.formatTime(minExpiration), \"-\", ACONameFormatter.formatTime(maxExpiration)));\r\n        } else {\r\n            dateFormatted = ACONameFormatter.formatTime(minExpiration);\r\n        }\r\n        return string(abi.encodePacked(\r\n            \"ACO POOL \",\r\n            ACOAssetHelper._getAssetSymbol(underlying),\r\n            \"-\",\r\n            ACOAssetHelper._getAssetSymbol(strikeAsset),\r\n            \"-\",\r\n            ACONameFormatter.formatType(isCall),\r\n            (canBuy ? \"\" : \"-SELL\"),\r\n            \"-\",\r\n            strikePriceFormatted,\r\n            \"-\",\r\n            dateFormatted\r\n        ));\r\n    }\r\n}"
    },
    "browser/Address.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n"
    },
    "browser/BokkyPooBahsDateTimeLibrary.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\n// ----------------------------------------------------------------------------\r\n// BokkyPooBah's DateTime Library v1.01\r\n//\r\n// A gas-efficient Solidity date and time library\r\n//\r\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\r\n//\r\n// Tested date range 1970/01/01 to 2345/12/31\r\n//\r\n// Conventions:\r\n// Unit      | Range         | Notes\r\n// :-------- |:-------------:|:-----\r\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\r\n// year      | 1970 ... 2345 |\r\n// month     | 1 ... 12      |\r\n// day       | 1 ... 31      |\r\n// hour      | 0 ... 23      |\r\n// minute    | 0 ... 59      |\r\n// second    | 0 ... 59      |\r\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\r\n//\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary BokkyPooBahsDateTimeLibrary {\r\n\r\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint constant SECONDS_PER_MINUTE = 60;\r\n    int constant OFFSET19700101 = 2440588;\r\n\r\n    uint constant DOW_MON = 1;\r\n    uint constant DOW_TUE = 2;\r\n    uint constant DOW_WED = 3;\r\n    uint constant DOW_THU = 4;\r\n    uint constant DOW_FRI = 5;\r\n    uint constant DOW_SAT = 6;\r\n    uint constant DOW_SUN = 7;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate the number of days from 1970/01/01 to year/month/day using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // days = day\r\n    //      - 32075\r\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\r\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\r\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\r\n    //      - offset\r\n    // ------------------------------------------------------------------------\r\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\r\n        require(year >= 1970);\r\n        int _year = int(year);\r\n        int _month = int(month);\r\n        int _day = int(day);\r\n\r\n        int __days = _day\r\n          - 32075\r\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\r\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\r\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\r\n          - OFFSET19700101;\r\n\r\n        _days = uint(__days);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate year/month/day from the number of days since 1970/01/01 using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // int L = days + 68569 + offset\r\n    // int N = 4 * L / 146097\r\n    // L = L - (146097 * N + 3) / 4\r\n    // year = 4000 * (L + 1) / 1461001\r\n    // L = L - 1461 * year / 4 + 31\r\n    // month = 80 * L / 2447\r\n    // dd = L - 2447 * month / 80\r\n    // L = month / 11\r\n    // month = month + 2 - 12 * L\r\n    // year = 100 * (N - 49) + year + L\r\n    // ------------------------------------------------------------------------\r\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\r\n        int __days = int(_days);\r\n\r\n        int L = __days + 68569 + OFFSET19700101;\r\n        int N = 4 * L / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int _year = 4000 * (L + 1) / 1461001;\r\n        L = L - 1461 * _year / 4 + 31;\r\n        int _month = 80 * L / 2447;\r\n        int _day = L - 2447 * _month / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint(_year);\r\n        month = uint(_month);\r\n        day = uint(_day);\r\n    }\r\n\r\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\r\n    }\r\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\r\n    }\r\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n        secs = secs % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n        second = secs % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\r\n        if (year >= 1970 && month > 0 && month <= 12) {\r\n            uint daysInMonth = _getDaysInMonth(year, month);\r\n            if (day > 0 && day <= daysInMonth) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\r\n        if (isValidDate(year, month, day)) {\r\n            if (hour < 24 && minute < 60 && second < 60) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\r\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        leapYear = _isLeapYear(year);\r\n    }\r\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\r\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\r\n    }\r\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\r\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\r\n    }\r\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\r\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\r\n    }\r\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\r\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        daysInMonth = _getDaysInMonth(year, month);\r\n    }\r\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            daysInMonth = 31;\r\n        } else if (month != 2) {\r\n            daysInMonth = 30;\r\n        } else {\r\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\r\n        }\r\n    }\r\n    // 1 = Monday, 7 = Sunday\r\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\r\n        uint _days = timestamp / SECONDS_PER_DAY;\r\n        dayOfWeek = (_days + 3) % 7 + 1;\r\n    }\r\n\r\n    function getYear(uint timestamp) internal pure returns (uint year) {\r\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getMonth(uint timestamp) internal pure returns (uint month) {\r\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getDay(uint timestamp) internal pure returns (uint day) {\r\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getHour(uint timestamp) internal pure returns (uint hour) {\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n    }\r\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\r\n        uint secs = timestamp % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n    }\r\n    function getSecond(uint timestamp) internal pure returns (uint second) {\r\n        second = timestamp % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year += _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        month += _months;\r\n        year += (month - 1) / 12;\r\n        month = (month - 1) % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _seconds;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n\r\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year -= _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint yearMonth = year * 12 + (month - 1) - _months;\r\n        year = yearMonth / 12;\r\n        month = yearMonth % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _seconds;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n\r\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _years = toYear - fromYear;\r\n    }\r\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\r\n    }\r\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\r\n    }\r\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\r\n    }\r\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\r\n    }\r\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _seconds = toTimestamp - fromTimestamp;\r\n    }\r\n}\r\n"
    },
    "browser/ERC20.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./IERC20.sol\";\r\n\r\n/**\r\n * @title ERC20\r\n * @dev Base implementation of ERC20 token.\r\n */\r\nabstract contract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n    \r\n    uint256 private _totalSupply;\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    function name() public view virtual returns(string memory);\r\n    function symbol() public view virtual returns(string memory);\r\n    function decimals() public view virtual returns(uint8);\r\n\r\n    function totalSupply() public view override returns(uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns(uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns(uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns(bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns(bool) {\r\n        _approveAction(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        _transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns(bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 amount) public returns(bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(amount));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 amount) public returns(bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(amount));\r\n        return true;\r\n    }\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        _transferAction(sender, recipient, amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        _approveAction(owner, spender, amount);\r\n    }\r\n    \r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _approveAction(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n        _burnAction(account, amount);\r\n    }\r\n\r\n    function _transferAction(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20::_transferAction: Invalid sender\");\r\n        require(recipient != address(0), \"ERC20::_transferAction: Invalid recipient\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        \r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n    \r\n    function _approveAction(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20::_approveAction: Invalid owner\");\r\n        require(spender != address(0), \"ERC20::_approveAction: Invalid spender\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        \r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    \r\n    function _mintAction(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20::_mintAction: Invalid account\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        \r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burnAction(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20::_burnAction: Invalid account\");\r\n\r\n        _balances[account] = _balances[account].sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        \r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n}    \r\n"
    },
    "browser/IACOAssetConverterHelper.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\ninterface IACOAssetConverterHelper {\r\n    function setPairTolerancePercentage(address baseAsset, address quoteAsset, uint256 tolerancePercentage) external;\r\n    function setAggregator(address baseAsset, address quoteAsset, address aggregator) external;\r\n    function setUniswapMiddleRoute(address baseAsset, address quoteAsset, address[] calldata uniswapMiddleRoute) external;\r\n    function withdrawStuckAsset(address asset, address destination) external;\r\n    function hasAggregator(address baseAsset, address quoteAsset) external view returns(bool);\r\n    function getPairData(address baseAsset, address quoteAsset) external view returns(address, uint256, uint256, uint256);\r\n    function getUniswapMiddleRouteByIndex(address baseAsset, address quoteAsset, uint256 index) external view returns(address);\r\n    function getPrice(address baseAsset, address quoteAsset) external view returns(uint256);\r\n    function getPriceWithTolerance(address baseAsset, address quoteAsset, bool isMinimumPrice) external view returns(uint256);\r\n    function getExpectedAmountOutToSwapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external view returns(uint256);\r\n    function getExpectedAmountOutToSwapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external view returns(uint256);\r\n    function swapExactAmountOut(address assetToSold, address assetToBuy, uint256 amountToSold) external payable returns(uint256);\r\n    function swapExactAmountOutWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 tolerancePercentage) external payable returns(uint256);\r\n    function swapExactAmountOutWithMinAmountToReceive(address assetToSold, address assetToBuy, uint256 amountToSold, uint256 minAmountToReceive) external payable returns(uint256);\r\n    function swapExactAmountIn(address assetToSold, address assetToBuy, uint256 amountToBuy) external payable returns(uint256);\r\n    function swapExactAmountInWithSpecificTolerance(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 tolerancePercentage) external payable returns(uint256);\r\n    function swapExactAmountInWithMaxAmountToSold(address assetToSold, address assetToBuy, uint256 amountToBuy, uint256 maxAmountToSold) external payable returns(uint256);\r\n}"
    },
    "browser/IACOFactory.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\ninterface IACOFactory {\r\n\tfunction init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) external;\r\n    function acoFee() external view returns(uint256);\r\n    function factoryAdmin() external view returns(address);\r\n    function acoTokenImplementation() external view returns(address);\r\n    function acoFeeDestination() external view returns(address);\r\n    function acoTokenData(address acoToken) external view returns(address, address, bool, uint256, uint256);\r\n    function createAcoToken(address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime, uint256 maxExercisedAccounts) external returns(address);\r\n    function setFactoryAdmin(address newFactoryAdmin) external;\r\n    function setAcoTokenImplementation(address newAcoTokenImplementation) external;\r\n    function setAcoFee(uint256 newAcoFee) external;\r\n    function setAcoFeeDestination(address newAcoFeeDestination) external;\r\n}"
    },
    "browser/IACOFlashExercise.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\ninterface IACOFlashExercise {\r\n    function uniswapFactory() external view returns(address);\r\n    function uniswapRouter() external view returns(address);\r\n    function weth() external view returns(address);\r\n    function hasFlashExercise(address acoToken) external view returns(bool);\r\n    function getExerciseData(address acoToken, uint256 tokenAmount, address[] calldata accounts) external view returns(uint256, uint256);\r\n    function getEstimatedReturn(address acoToken, uint256 tokenAmount) external view returns(uint256);\r\n    function flashExercise(address acoToken, uint256 tokenAmount, uint256 minimumCollateral, uint256 salt) external;\r\n    function flashExerciseAccounts(address acoToken, uint256 tokenAmount, uint256 minimumCollateral, address[] calldata accounts) external;\r\n    function uniswapV2Call(address sender, uint256 amount0Out, uint256 amount1Out, bytes calldata data) external;\r\n}\r\n"
    },
    "browser/IACOPool.sol": {
      "content": "pragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './IERC20.sol';\r\n\r\ninterface IACOPool is IERC20 {\r\n    struct InitData {\r\n        uint256 poolStart;\r\n        address acoFlashExercise;\r\n        address acoFactory;\r\n        address chiToken;\r\n\t\taddress assetConverterHelper;\r\n        uint256 fee;\r\n        address feeDestination;\r\n        address underlying;\r\n        address strikeAsset;\r\n        uint256 minStrikePrice; \r\n        uint256 maxStrikePrice;\r\n        uint256 minExpiration;\r\n        uint256 maxExpiration;\r\n        bool isCall; \r\n        bool canBuy;\r\n        address strategy;\r\n        uint256 baseVolatility;    \r\n    }\r\n    \r\n\tfunction init(InitData calldata initData) external;\r\n    function numberOfACOTokensCurrentlyNegotiated() external view returns(uint256);\r\n    function collateral() external view returns(address);\r\n    function setStrategy(address strategy) external;\r\n    function setBaseVolatility(uint256 baseVolatility) external;\r\n    function quote(bool isBuying, address acoToken, uint256 tokenAmount) external view returns(uint256 swapPrice, uint256 fee, uint256 underlyingPrice);\r\n    function swap(bool isBuying, address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external returns(uint256);\r\n    function swapWithGasToken(bool isBuying, address acoToken, uint256 tokenAmount, uint256 restriction, address to, uint256 deadline) external returns(uint256);\r\n    function exerciseACOToken(address acoToken) external;\r\n    function redeemACOTokens() external;\r\n\tfunction redeemACOToken(address acoToken) external;\r\n    function deposit(uint256 collateralAmount, address to) external payable returns(uint256 acoPoolTokenAmount);\r\n    function redeem() external returns(uint256 underlyingReceived, uint256 strikeAssetReceived);\r\n    function redeemFrom(address account) external returns(uint256 underlyingReceived, uint256 strikeAssetReceived);\r\n    function restoreCollateral() external;\r\n}"
    },
    "browser/IACOStrategy.sol": {
      "content": "pragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IACOStrategy {\r\n    \r\n    struct OptionQuote {\r\n        bool isSellingQuote;\r\n        address underlying;\r\n        address strikeAsset;\r\n        bool isCallOption;\r\n        uint256 strikePrice; \r\n        uint256 expiryTime;\r\n        uint256 baseVolatility;\r\n        uint256 collateralOrderAmount;\r\n        uint256 collateralAvailable;\r\n        uint256 collateralTotalDeposited;\r\n        uint256 strikeAssetEarnedSelling;\r\n        uint256 strikeAssetSpentBuying;\r\n        uint256 amountPurchased;\r\n        uint256 amountSold;\r\n    }\r\n    \r\n    struct CheckExercise {\r\n        address underlying;\r\n        address strikeAsset;\r\n        bool isCallOption;\r\n        uint256 strikePrice; \r\n        uint256 expiryTime;\r\n        uint256 collateralAmount;\r\n        uint256 collateralAvailable;\r\n        uint256 amountPurchased;\r\n        uint256 amountSold;\r\n    }\r\n    \r\n    function quote(OptionQuote calldata quoteData) external view returns(uint256 optionPrice, uint256 underlyingPrice, uint256 volatility);\r\n    function getUnderlyingPrice(address underlying, address strikeAsset) external view returns(uint256 underlyingPrice);\r\n    function getAcceptableUnderlyingPriceToSwapAssets(address underlying, address strikeAsset, bool isBuying) external view returns(uint256 acceptablePrice);\r\n    function checkExercise(CheckExercise calldata exerciseData) external view returns(bool canExercise, uint256 minIntrinsicValue);\r\n}"
    },
    "browser/IACOToken.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface IACOToken is IERC20 {\r\n\tfunction init(address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime, uint256 _acoFee, address payable _feeDestination, uint256 _maxExercisedAccounts) external;\r\n    function name() external view returns(string memory);\r\n    function symbol() external view returns(string memory);\r\n    function decimals() external view returns(uint8);\r\n    function underlying() external view returns (address);\r\n    function strikeAsset() external view returns (address);\r\n    function feeDestination() external view returns (address);\r\n    function isCall() external view returns (bool);\r\n    function strikePrice() external view returns (uint256);\r\n    function expiryTime() external view returns (uint256);\r\n    function totalCollateral() external view returns (uint256);\r\n    function acoFee() external view returns (uint256);\r\n\tfunction maxExercisedAccounts() external view returns (uint256);\r\n    function underlyingSymbol() external view returns (string memory);\r\n    function strikeAssetSymbol() external view returns (string memory);\r\n    function underlyingDecimals() external view returns (uint8);\r\n    function strikeAssetDecimals() external view returns (uint8);\r\n    function currentCollateral(address account) external view returns(uint256);\r\n    function unassignableCollateral(address account) external view returns(uint256);\r\n    function assignableCollateral(address account) external view returns(uint256);\r\n    function currentCollateralizedTokens(address account) external view returns(uint256);\r\n    function unassignableTokens(address account) external view returns(uint256);\r\n    function assignableTokens(address account) external view returns(uint256);\r\n    function getCollateralAmount(uint256 tokenAmount) external view returns(uint256);\r\n    function getTokenAmount(uint256 collateralAmount) external view returns(uint256);\r\n    function getBaseExerciseData(uint256 tokenAmount) external view returns(address, uint256);\r\n    function numberOfAccountsWithCollateral() external view returns(uint256);\r\n    function getCollateralOnExercise(uint256 tokenAmount) external view returns(uint256, uint256);\r\n    function collateral() external view returns(address);\r\n    function mintPayable() external payable returns(uint256);\r\n    function mintToPayable(address account) external payable returns(uint256);\r\n    function mint(uint256 collateralAmount) external returns(uint256);\r\n    function mintTo(address account, uint256 collateralAmount) external returns(uint256);\r\n    function burn(uint256 tokenAmount) external returns(uint256);\r\n    function burnFrom(address account, uint256 tokenAmount) external returns(uint256);\r\n    function redeem() external returns(uint256);\r\n    function redeemFrom(address account) external returns(uint256);\r\n    function exercise(uint256 tokenAmount, uint256 salt) external payable returns(uint256);\r\n    function exerciseFrom(address account, uint256 tokenAmount, uint256 salt) external payable returns(uint256);\r\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\r\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\r\n}"
    },
    "browser/IChiToken.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\nimport './IERC20.sol';\r\n\r\ninterface IChiToken is IERC20 {\r\n    function mint(uint256 value) external;\r\n    function computeAddress2(uint256 salt) external view returns(address);\r\n    function free(uint256 value) external returns(uint256);\r\n    function freeUpTo(uint256 value) external returns(uint256);\r\n    function freeFrom(address from, uint256 value) external returns(uint256);\r\n    function freeFromUpTo(address from, uint256 value) external returns(uint256);\r\n}"
    },
    "browser/IERC20.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"
    },
    "browser/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Adapted from OpenZeppelin\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function init() internal {\r\n        require(_owner == address(0), \"Ownable: Contract initialized\");\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"
    },
    "browser/SafeMath.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"
    },
    "browser/Strings.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = byte(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n"
    }
  }
}