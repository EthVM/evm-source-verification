{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BridgeAdapter.sol":{"content":"// Sources flattened with hardhat v2.5.0 https://hardhat.org\n\n// File deps/@openzeppelin/contracts/token/ERC20/IERC20.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n// File deps/@openzeppelin/contracts/math/SafeMath.sol\n\n\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n// File deps/@openzeppelin/contracts/utils/Address.sol\n\n\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\n// File deps/@openzeppelin/contracts/token/ERC20/SafeERC20.sol\n\n\n\npragma solidity ^0.6.0;\n\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n\n// File deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\n\n\n\npragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { cs := extcodesize(self) }\n        return cs == 0;\n    }\n}\n\n\n// File deps/@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol\n\n\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File deps/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\n\n\n\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n\n\n// File deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\n\n\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n// File deps/@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\n\n\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n\n\n// File interfaces/badger/ISwapStrategyRouter.sol\n\npragma solidity >=0.6.0;\n\n// ISwapStrategyRouter performs optimal routing of swaps.\ninterface ISwapStrategyRouter {\n    // Return the optimal rate and the strategy ID.\n    function optimizeSwap(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (address strategy, uint256 amount);\n}\n\n// ISwapStrategy enforces a standard API for swaps.\ninterface ISwapStrategy {\n    function swapTokens(\n        address _from,\n        address _to,\n        uint256 _amount,\n        // Slippage is in bps.\n        uint256 _slippage\n    ) external returns (uint256 amount);\n\n    // Estimate swap amount returns the swap rate.\n    function estimateSwapAmount(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (uint256 amount);\n}\n\n\n// File interfaces/bridge/IGateway.sol\n\npragma solidity >=0.6.0;\n\ninterface IGateway {\n    function mint(\n        bytes32 _pHash,\n        uint256 _amount,\n        bytes32 _nHash,\n        bytes calldata _sig\n    ) external returns (uint256);\n\n    function burn(bytes calldata _to, uint256 _amount) external returns (uint256);\n}\n\ninterface IGatewayRegistry {\n    function getGatewayBySymbol(string calldata _tokenSymbol) external view returns (IGateway);\n\n    function getTokenBySymbol(string calldata _tokenSymbol) external view returns (IERC20);\n}\n\n\n// File interfaces/bridge/IBridgeVault.sol\n\n\n\npragma solidity ^0.6.8;\n\ninterface IBridgeVault is IERC20 {\n    function depositFor(address recipient, uint256 amount) external;\n\n    function withdraw(uint256 shares) external;\n\n    function token() external returns (IERC20);\n}\n\n\n// File interfaces/bridge/ICurveTokenWrapper.sol\n\n\n\npragma solidity ^0.6.8;\n\ninterface ICurveTokenWrapper {\n    function wrap(address vault) external returns (uint256);\n\n    function unwrap(address vault) external;\n}\n\n\n// File interfaces/curve/ICurveFi.sol\n\n\npragma solidity >=0.5.0 <0.8.0;\n\ninterface ICurveFi {\n    function get_virtual_price() external returns (uint256 out);\n\n    function add_liquidity(\n        // renbtc/tbtc pool\n        uint256[2] calldata amounts,\n        uint256 min_mint_amount\n    ) external;\n\n    function add_liquidity(\n        // sBTC pool\n        uint256[3] calldata amounts,\n        uint256 min_mint_amount\n    ) external;\n\n    function add_liquidity(\n        // bUSD pool\n        uint256[4] calldata amounts,\n        uint256 min_mint_amount\n    ) external;\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external returns (uint256 out);\n\n    function get_dy_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external returns (uint256 out);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        uint256 deadline\n    ) external;\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        uint256 deadline\n    ) external;\n\n    function remove_liquidity(\n        uint256 _amount,\n        uint256 deadline,\n        uint256[2] calldata min_amounts\n    ) external;\n\n    function remove_liquidity_imbalance(uint256[2] calldata amounts, uint256 deadline) external;\n\n    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount) external;\n\n    function remove_liquidity(uint256 _amount, uint256[3] calldata amounts) external;\n\n    function remove_liquidity_imbalance(uint256[4] calldata amounts, uint256 max_burn_amount) external;\n\n    function remove_liquidity(uint256 _amount, uint256[4] calldata amounts) external;\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 _min_amount\n    ) external;\n\n    function commit_new_parameters(\n        int128 amplification,\n        int128 new_fee,\n        int128 new_admin_fee\n    ) external;\n\n    function apply_new_parameters() external;\n\n    function revert_new_parameters() external;\n\n    function commit_transfer_ownership(address _owner) external;\n\n    function apply_transfer_ownership() external;\n\n    function revert_transfer_ownership() external;\n\n    function withdraw_admin_fees() external;\n\n    function coins(int128 arg0) external returns (address out);\n\n    function underlying_coins(int128 arg0) external returns (address out);\n\n    function balances(int128 arg0) external returns (uint256 out);\n\n    function A() external returns (int128 out);\n\n    function fee() external returns (int128 out);\n\n    function admin_fee() external returns (int128 out);\n\n    function owner() external returns (address out);\n\n    function admin_actions_deadline() external returns (uint256 out);\n\n    function transfer_ownership_deadline() external returns (uint256 out);\n\n    function future_A() external returns (int128 out);\n\n    function future_fee() external returns (int128 out);\n\n    function future_admin_fee() external returns (int128 out);\n\n    function future_owner() external returns (address out);\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 _i) external view returns (uint256 out);\n    \n    function calc_token_amount(uint[2] calldata amounts, bool isDeposit) external view returns(uint);\n    function calc_token_amount(uint[3] calldata amounts, bool isDeposit) external view returns(uint);\n    function calc_token_amount(uint[4] calldata amounts, bool isDeposit) external view returns(uint);\n}\n\n\n// File interfaces/defidollar/IBadgerSettPeak.sol\n\npragma solidity ^0.6.8;\n\ninterface IBadgerSettPeak {\n\n    function mint(uint poolId, uint inAmount, bytes32[] calldata merkleProof) external\n        returns(uint outAmount);\n    \n    function approveContractAccess(address account) external;\n\n    function owner() external view returns(address _owner);\n\n    function redeem(uint poolId, uint inAmount) external\n        returns (uint outAmount);\n\n    function calcMint(uint poolId, uint inAmount) external view returns(uint bBTC, uint fee);\n    function calcRedeem(uint poolId, uint bBtc) external view returns(uint sett, uint fee, uint max);\n\n}\n\n\n// File interfaces/defidollar/IBadgerYearnWbtcPeak.sol\n\npragma solidity ^0.6.8;\n\ninterface IBadgerYearnWbtcPeak {\n\n    function mint(uint inAmount, bytes32[] calldata merkleProof) external\n        returns(uint outAmount);\n    \n    function approveContractAccess(address account) external;\n\n    function owner() external view returns(address _owner);\n\n    function redeem(uint inAmount) external\n        returns (uint outAmount);\n\n    function calcMint(uint inAmount) external view returns(uint bBTC, uint fee);\n    function calcRedeem(uint bBtc) external view returns(uint sett, uint fee, uint max);\n}\n\n\n// File contracts/badger-bridge/BadgerBridgeAdapter.sol\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\n\n\n\n\n\n\n\n\n\ncontract BadgerBridgeAdapter is OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeMathUpgradeable for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public renBTC;\n    IERC20 public wBTC;\n\n    // RenVM gateway registry.\n    IGatewayRegistry public registry;\n    // Swap router that handles swap routing optimizations.\n    ISwapStrategyRouter public router;\n\n    event RecoverStuck(uint256 amount, uint256 fee);\n    event Mint(uint256 renbtc_minted, uint256 wbtc_swapped, uint256 fee);\n    event Burn(uint256 renbtc_burned, uint256 wbtc_transferred, uint256 fee);\n    event SwapError(bytes error);\n\n    address public rewards;\n    address public governance;\n\n    uint256 public mintFeeBps;\n    uint256 public burnFeeBps;\n    uint256 private percentageFeeRewardsBps;\n    uint256 private percentageFeeGovernanceBps;\n\n    uint256 public constant MAX_BPS = 10000;\n\n    mapping(address => bool) public approvedVaults;\n\n    // Configurable permissionless curve lp token wrapper.\n    address curveTokenWrapper;\n\n    // Make struct for mint args, otherwise too many local vars (stack too deep).\n    struct MintArguments {\n        uint256 _mintAmount;\n        uint256 _mintAmountMinusFee;\n        uint256 _fee;\n        uint256 _slippage;\n        address _vault;\n        address _user;\n        address _token;\n        bool _mintIbbtc;\n    }\n\n    IERC20 public ibBTC;\n    // Peak contract for minting ibbtc from renbtc, sbtc, tbtc.\n    IBadgerSettPeak public settPeak;\n    // Peak contract for minting ibbtc from wbtc.\n    IBadgerYearnWbtcPeak public yearnWbtcPeak;\n\n    mapping(address => uint256) public vaultToPoolId;\n\n    function initialize(\n        address _governance,\n        address _rewards,\n        address _registry,\n        address _router,\n        address _wbtc,\n        uint256[4] memory _feeConfig\n    ) public initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        require(_governance != address(0x0), \"must set governance address\");\n        require(_rewards != address(0x0), \"must set rewards address\");\n        require(_registry != address(0x0), \"must set registry address\");\n        require(_router != address(0x0), \"must set router address\");\n        require(_wbtc != address(0x0), \"must set wBTC address\");\n\n        governance = _governance;\n        rewards = _rewards;\n\n        registry = IGatewayRegistry(_registry);\n        router = ISwapStrategyRouter(_router);\n        renBTC = registry.getTokenBySymbol(\"BTC\");\n        wBTC = IERC20(_wbtc);\n\n        mintFeeBps = _feeConfig[0];\n        burnFeeBps = _feeConfig[1];\n        percentageFeeRewardsBps = _feeConfig[2];\n        percentageFeeGovernanceBps = _feeConfig[3];\n    }\n\n    function version() external pure returns (string memory) {\n        return \"1.1\";\n    }\n\n    // NB: This recovery fn only works for the BTC gateway (hardcoded and only one supported in this adapter).\n    function recoverStuck(\n        // encoded user args\n        bytes calldata encoded,\n        // darkdnode args\n        uint256 _amount,\n        bytes32 _nHash,\n        bytes calldata _sig\n    ) external nonReentrant {\n        // Ensure sender matches sender of original tx.\n        uint256 start = encoded.length - 32;\n        address sender = abi.decode(encoded[start:], (address));\n        require(sender == msg.sender);\n\n        bytes32 pHash = keccak256(encoded);\n        uint256 _mintAmount = registry.getGatewayBySymbol(\"BTC\").mint(pHash, _amount, _nHash, _sig);\n        uint256 _fee = _processFee(renBTC, _mintAmount, mintFeeBps);\n\n        emit RecoverStuck(_mintAmount, _fee);\n\n        renBTC.safeTransfer(msg.sender, _mintAmount.sub(_fee));\n    }\n\n    function mint(\n        // user args\n        address _token, // either renBTC or wBTC\n        uint256 _slippage,\n        address _user,\n        address _vault,\n        bool _mintIbbtc,\n        // darknode args\n        uint256 _amount,\n        bytes32 _nHash,\n        bytes calldata _sig\n    ) external nonReentrant {\n        require(_token == address(renBTC) || _token == address(wBTC), \"invalid token address\");\n\n        // Mint renBTC tokens\n        bytes32 pHash = keccak256(abi.encode(_token, _slippage, _user, _vault));\n        uint256 mintAmount = registry.getGatewayBySymbol(\"BTC\").mint(pHash, _amount, _nHash, _sig);\n\n        require(mintAmount > 0, \"zero mint amount\");\n\n        uint256 fee = _processFee(renBTC, mintAmount, mintFeeBps);\n        uint256 mintAmountMinusFee = mintAmount.sub(fee);\n\n        MintArguments memory args = MintArguments(mintAmount, mintAmountMinusFee, fee, _slippage, _vault, _user, _token, _mintIbbtc);\n        bool success = mintAdapter(args);\n\n        if (!success) {\n            renBTC.safeTransfer(_user, mintAmountMinusFee);\n        }\n    }\n\n    function burn(\n        // user args\n        address _token, // either renBTC or wBTC\n        address _vault,\n        uint256 _slippage,\n        bytes calldata _btcDestination,\n        uint256 _amount,\n        bool _burnIbbtc\n    ) external nonReentrant {\n        require(_token == address(renBTC) || _token == address(wBTC), \"invalid token address\");\n        require(!(_vault != address(0) && !approvedVaults[_vault]), \"Vault not approved\");\n\n        bool isVault = _vault != address(0);\n        bool isRenBTC = _token == address(renBTC);\n        IERC20 token = isRenBTC ? renBTC : wBTC;\n        uint256 startBalanceRenBTC = renBTC.balanceOf(address(this));\n        uint256 startBalanceWBTC = wBTC.balanceOf(address(this));\n\n        if (_burnIbbtc) {\n            //redeem ibbtc\n            ibBTC.safeTransferFrom(msg.sender, address(this), _amount);\n            uint256 poolId = vaultToPoolId[_vault];\n            uint256 redeemAmount = 0;\n            if (poolId == 3) {\n                redeemAmount = yearnWbtcPeak.redeem(_amount);\n            } else {\n                redeemAmount = settPeak.redeem(poolId, _amount);\n            }\n        }\n        \n        // Vaults can require up to two levels of unwrapping.\n        if (isVault) {\n            // First level of unwrapping for sett tokens.\n            if (!_burnIbbtc) {\n                IERC20(_vault).safeTransferFrom(msg.sender, address(this), _amount);\n            }\n            IERC20 vaultToken = IBridgeVault(_vault).token();\n\n            uint256 beforeBalance = vaultToken.balanceOf(address(this));\n            IBridgeVault(_vault).withdraw(IERC20(_vault).balanceOf(address(this)));\n            uint256 balance = vaultToken.balanceOf(address(this)).sub(beforeBalance);\n\n            // If the vault token does not match requested burn token, then we need to further unwrap\n            // vault token (e.g. withdrawing from crv sett gets us crv lp tokens which need to be unwrapped to renbtc).\n            if (address(vaultToken) != _token) {\n                vaultToken.safeTransfer(curveTokenWrapper, balance);\n                ICurveTokenWrapper(curveTokenWrapper).unwrap(_vault);\n            }\n        } else {\n            token.safeTransferFrom(msg.sender, address(this), _amount);\n        }\n\n        uint256 wbtcTransferred = wBTC.balanceOf(address(this)).sub(startBalanceWBTC);\n\n        if (!isRenBTC) {\n            _swapWBTCForRenBTC(wbtcTransferred, _slippage);\n        }\n\n        uint256 toBurnAmount = renBTC.balanceOf(address(this)).sub(startBalanceRenBTC);\n        uint256 fee = _processFee(renBTC, toBurnAmount, burnFeeBps);\n\n        uint256 burnAmount = registry.getGatewayBySymbol(\"BTC\").burn(_btcDestination, toBurnAmount.sub(fee));\n        \n        emit Burn(burnAmount, wbtcTransferred, fee);\n    }\n\n    function mintAdapter(MintArguments memory args) internal returns (bool) {\n        if (args._vault != address(0) && !approvedVaults[args._vault]) {\n            return false;\n        }\n\n        uint256 wbtcExchanged;\n        bool isVault = args._vault != address(0);\n        bool isRenBTC = args._token == address(renBTC);\n        IERC20 token = isRenBTC ? renBTC : wBTC;\n\n        if (!isRenBTC) {\n            // Try and swap and transfer wbtc if token wbtc specified.\n            uint256 startBalance = token.balanceOf(address(this));\n            if (!_swapRenBTCForWBTC(args._mintAmountMinusFee, args._slippage)) {\n                return false;\n            }\n            uint256 endBalance = token.balanceOf(address(this));\n            wbtcExchanged = endBalance.sub(startBalance);\n        }\n\n        emit Mint(args._mintAmount, wbtcExchanged, args._fee);\n\n        uint256 amount = isRenBTC ? args._mintAmountMinusFee : wbtcExchanged;\n\n        if (!isVault) {\n            token.safeTransfer(args._user, amount);\n            return true;\n        }\n\n        // If the token is wBTC then we just approve spend and deposit directly into the wbtc vault.\n        if (args._token == address(wBTC)) {\n            token.safeApprove(args._vault, token.balanceOf(address(this)));\n        } else {\n            // Otherwise, we need to wrap the token before depositing into vault.\n            // We currently only support wrapping renbtc into curve lp tokens.\n            // NB: The curve token wrapper contract is permissionless, we must transfer renbtc over\n            // and it will transfer back wrapped lp tokens.\n            token.safeTransfer(curveTokenWrapper, amount);\n            amount = ICurveTokenWrapper(curveTokenWrapper).wrap(args._vault);\n            IBridgeVault(args._vault).token().safeApprove(args._vault, amount);\n        }\n\n        if (args._mintIbbtc) {\n            IBridgeVault(args._vault).depositFor(address(this), amount);\n            uint256 balance = IERC20(args._vault).balanceOf(address(this));\n            \n            _mintIbbtc(args._vault, args._user, balance);\n        } else {    \n            IBridgeVault(args._vault).depositFor(args._user, amount);\n        }\n\n        return true;\n    }\n\n    function _mintIbbtc(address _vault, address _user, uint256 _amount) internal {\n        uint256 poolId = vaultToPoolId[_vault];\n        uint256 mintAmount = 0;\n        //passing in empty variable, no longer used in peak contract\n        bytes32[] memory unused;\n        if (poolId == 3) {\n            IERC20(_vault).approve(address(yearnWbtcPeak), _amount);\n            mintAmount = yearnWbtcPeak.mint(_amount, unused);\n        } else {\n            IERC20(_vault).approve(address(settPeak), _amount);\n            mintAmount = settPeak.mint(poolId, _amount, unused);\n        }\n        ibBTC.safeTransfer(_user, mintAmount);\n    }\n\n    function _swapWBTCForRenBTC(uint256 _amount, uint256 _slippage) internal {\n        (address strategy, uint256 estimatedAmount) = router.optimizeSwap(address(wBTC), address(renBTC), _amount);\n        uint256 minAmount = _minAmount(_slippage, _amount);\n        require(estimatedAmount > minAmount, \"slippage too high\");\n\n        // Approve strategy for spending of wbtc.\n        wBTC.safeApprove(strategy, _amount);\n        uint256 amount = ISwapStrategy(strategy).swapTokens(address(wBTC), address(renBTC), _amount, _slippage);\n        require(amount > minAmount, \"swapped amount less than min amount\");\n    }\n\n    // Avoid reverting on mint (renBTC -> wBTC swap) since we cannot roll back that transaction.:\n    function _swapRenBTCForWBTC(uint256 _amount, uint256 _slippage) internal returns (bool) {\n        (address strategy, uint256 estimatedAmount) = router.optimizeSwap(address(renBTC), address(wBTC), _amount);\n        uint256 minAmount = _minAmount(_slippage, _amount);\n        if (minAmount > estimatedAmount) {\n            // Do not swap if slippage is too high;\n            return false;\n        }\n\n        // Approve strategy for spending of renbtc.\n        renBTC.safeApprove(strategy, _amount);\n        try ISwapStrategy(strategy).swapTokens(address(renBTC), address(wBTC), _amount, _slippage)  {\n            return true;\n        } catch (bytes memory _error) {\n            emit SwapError(_error);\n            return false;\n        }\n    }\n\n    // Minimum amount w/ slippage applied.\n    function _minAmount(uint256 _slippage, uint256 _amount) internal pure returns (uint256) {\n        _slippage = uint256(1e4).sub(_slippage);\n        return _amount.mul(_slippage).div(1e4);\n    }\n\n    function _processFee(\n        IERC20 token,\n        uint256 amount,\n        uint256 feeBps\n    ) internal returns (uint256) {\n        if (feeBps == 0) {\n            return 0;\n        }\n        uint256 fee = amount.mul(feeBps).div(MAX_BPS);\n        uint256 governanceFee = fee.mul(percentageFeeGovernanceBps).div(MAX_BPS);\n        uint256 rewardsFee = fee.mul(percentageFeeRewardsBps).div(MAX_BPS);\n        IERC20(token).safeTransfer(governance, governanceFee);\n        IERC20(token).safeTransfer(rewards, rewardsFee);\n        return fee;\n    }\n\n    // Admin methods.\n    function setMintFeeBps(uint256 _mintFeeBps) external onlyOwner {\n        require(_mintFeeBps <= MAX_BPS, \"badger-bridge-adapter/excessive-mint-fee\");\n        mintFeeBps = _mintFeeBps;\n    }\n\n    function setBurnFeeBps(uint256 _burnFeeBps) external onlyOwner {\n        require(_burnFeeBps <= MAX_BPS, \"badger-bridge-adapter/excessive-burn-fee\");\n        burnFeeBps = _burnFeeBps;\n    }\n\n    function setPercentageFeeGovernanceBps(uint256 _percentageFeeGovernanceBps) external onlyOwner {\n        require(_percentageFeeGovernanceBps + percentageFeeRewardsBps <= MAX_BPS, \"badger-bridge-adapter/excessive-percentage-fee-governance\");\n        percentageFeeGovernanceBps = _percentageFeeGovernanceBps;\n    }\n\n    function setPercentageFeeRewardsBps(uint256 _percentageFeeRewardsBps) external onlyOwner {\n        require(_percentageFeeRewardsBps + percentageFeeGovernanceBps <= MAX_BPS, \"badger-bridge-adapter/excessive-percentage-fee-rewards\");\n        percentageFeeRewardsBps = _percentageFeeRewardsBps;\n    }\n\n    function setRewards(address _rewards) external onlyOwner {\n        rewards = _rewards;\n    }\n\n    function setRouter(address _router) external onlyOwner {\n        router = ISwapStrategyRouter(_router);\n    }\n\n    function setRegistry(address _registry) external onlyOwner {\n        registry = IGatewayRegistry(_registry);\n        renBTC = registry.getTokenBySymbol(\"BTC\");\n    }\n\n    function setVaultApproval(address _vault, bool _status) external onlyOwner {\n        approvedVaults[_vault] = _status;\n    }\n\n    function setVaultPoolId(address _vault, uint256 _poolId) external onlyOwner {\n        vaultToPoolId[_vault] = _poolId;\n    }\n\n    function setIbbtcContracts(address _ibbtc, address _settPeak, address _yearnWbtcPeak) external onlyOwner {\n        ibBTC = IERC20(_ibbtc);\n        settPeak = IBadgerSettPeak(_settPeak);\n        yearnWbtcPeak = IBadgerYearnWbtcPeak(_yearnWbtcPeak);\n    }\n\n    function setCurveTokenWrapper(address _wrapper) external onlyOwner {\n        curveTokenWrapper = _wrapper;\n    }\n\n    // Sweep all tokens and send to governance.\n    function sweep() external {\n        require(msg.sender == governance && msg.sender == tx.origin, \"caller must be governance\");\n        // NB: Sanity check but governance should have been set on init and cannot be modified.\n        require(governance != address(0x0), \"must set governance address\");\n        address[] memory sweepableTokens = new address[](2);\n        sweepableTokens[0] = address(renBTC);\n        sweepableTokens[1] = address(wBTC);\n\n        for (uint256 i = 0; i < 2; i++) {\n            IERC20 token = IERC20(sweepableTokens[i]);\n            uint256 balance = token.balanceOf(address(this));\n            if (balance > 0) {\n                token.safeTransfer(governance, balance);\n            }\n        }\n    }\n}\n"}}}