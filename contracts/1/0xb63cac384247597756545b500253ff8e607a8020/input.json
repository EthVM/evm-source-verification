{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "OlympusStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n// File: interfaces/IOlympusAuthority.sol\r\n\r\n\r\npragma solidity =0.7.5;\r\n\r\ninterface IOlympusAuthority {\r\n    /* ========== EVENTS ========== */\r\n    \r\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\r\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n\r\n    event GovernorPulled(address indexed from, address indexed to);\r\n    event GuardianPulled(address indexed from, address indexed to);\r\n    event PolicyPulled(address indexed from, address indexed to);\r\n    event VaultPulled(address indexed from, address indexed to);\r\n\r\n    /* ========== VIEW ========== */\r\n    \r\n    function governor() external view returns (address);\r\n    function guardian() external view returns (address);\r\n    function policy() external view returns (address);\r\n    function vault() external view returns (address);\r\n}\r\n// File: types/OlympusAccessControlled.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\nabstract contract OlympusAccessControlled {\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\r\n\r\n    string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    IOlympusAuthority public authority;\r\n\r\n\r\n    /* ========== Constructor ========== */\r\n\r\n    constructor(IOlympusAuthority _authority) {\r\n        authority = _authority;\r\n        emit AuthorityUpdated(_authority);\r\n    }\r\n    \r\n\r\n    /* ========== MODIFIERS ========== */\r\n    \r\n    modifier onlyGovernor() {\r\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyGuardian() {\r\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPolicy() {\r\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n\r\n    modifier onlyVault() {\r\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    /* ========== GOV ONLY ========== */\r\n    \r\n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\r\n        authority = _newAuthority;\r\n        emit AuthorityUpdated(_newAuthority);\r\n    }\r\n}\r\n\r\n// File: interfaces/IDistributor.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface IDistributor {\r\n    function distribute() external;\r\n\r\n    function bounty() external view returns (uint256);\r\n\r\n    function retrieveBounty() external returns (uint256);\r\n\r\n    function nextRewardAt(uint256 _rate) external view returns (uint256);\r\n\r\n    function nextRewardFor(address _recipient) external view returns (uint256);\r\n\r\n    function setBounty(uint256 _bounty) external;\r\n\r\n    function addRecipient(address _recipient, uint256 _rewardRate) external;\r\n\r\n    function removeRecipient(uint256 _index) external;\r\n\r\n    function setAdjustment(\r\n        uint256 _index,\r\n        bool _add,\r\n        uint256 _rate,\r\n        uint256 _target\r\n    ) external;\r\n}\r\n\r\n// File: interfaces/IERC20.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: interfaces/IgOHM.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\ninterface IgOHM is IERC20 {\r\n  function mint(address _to, uint256 _amount) external;\r\n\r\n  function burn(address _from, uint256 _amount) external;\r\n\r\n  function index() external view returns (uint256);\r\n\r\n  function balanceFrom(uint256 _amount) external view returns (uint256);\r\n\r\n  function balanceTo(uint256 _amount) external view returns (uint256);\r\n\r\n  function migrate( address _staking, address _sOHM ) external;\r\n}\r\n\r\n// File: interfaces/IsOHM.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\ninterface IsOHM is IERC20 {\r\n    function rebase( uint256 ohmProfit_, uint epoch_) external returns (uint256);\r\n\r\n    function circulatingSupply() external view returns (uint256);\r\n\r\n    function gonsForBalance( uint amount ) external view returns ( uint );\r\n\r\n    function balanceForGons( uint gons ) external view returns ( uint );\r\n\r\n    function index() external view returns ( uint );\r\n\r\n    function toG(uint amount) external view returns (uint);\r\n\r\n    function fromG(uint amount) external view returns (uint);\r\n\r\n     function changeDebt(\r\n        uint256 amount,\r\n        address debtor,\r\n        bool add\r\n    ) external;\r\n\r\n    function debtBalances(address _address) external view returns (uint256);\r\n\r\n}\r\n\r\n// File: libraries/SafeERC20.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\r\n/// Taken from Solmate\r\nlibrary SafeERC20 {\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\r\n        );\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\r\n        );\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\r\n        );\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        (bool success, ) = to.call{value: amount}(new bytes(0));\r\n\r\n        require(success, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n// File: libraries/SafeMath.sol\r\n\r\n\r\npragma solidity ^0.7.5;\r\n\r\n\r\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    // Only used in the  BondingCalculator.sol\r\n    function sqrrt(uint256 a) internal pure returns (uint c) {\r\n        if (a > 3) {\r\n            c = a;\r\n            uint b = add( div( a, 2), 1 );\r\n            while (b < c) {\r\n                c = b;\r\n                b = div( add( div( a, b ), b), 2 );\r\n            }\r\n        } else if (a != 0) {\r\n            c = 1;\r\n        }\r\n    }\r\n\r\n}\r\n// File: Staking.sol\r\n\r\n\r\npragma solidity ^0.7.5;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract OlympusStaking is OlympusAccessControlled {\r\n    /* ========== DEPENDENCIES ========== */\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using SafeERC20 for IsOHM;\r\n    using SafeERC20 for IgOHM;\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event DistributorSet(address distributor);\r\n    event WarmupSet(uint256 warmup);\r\n\r\n    /* ========== DATA STRUCTURES ========== */\r\n\r\n    struct Epoch {\r\n        uint256 length; // in seconds\r\n        uint256 number; // since inception\r\n        uint256 end; // timestamp\r\n        uint256 distribute; // amount\r\n    }\r\n\r\n    struct Claim {\r\n        uint256 deposit; // if forfeiting\r\n        uint256 gons; // staked balance\r\n        uint256 expiry; // end of warmup period\r\n        bool lock; // prevents malicious delays for claim\r\n    }\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    IERC20 public immutable OHM;\r\n    IsOHM public immutable sOHM;\r\n    IgOHM public immutable gOHM;\r\n\r\n    Epoch public epoch;\r\n\r\n    IDistributor public distributor;\r\n\r\n    mapping(address => Claim) public warmupInfo;\r\n    uint256 public warmupPeriod;\r\n    uint256 private gonsInWarmup;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(\r\n        address _ohm,\r\n        address _sOHM,\r\n        address _gOHM,\r\n        uint256 _epochLength,\r\n        uint256 _firstEpochNumber,\r\n        uint256 _firstEpochTime,\r\n        address _authority\r\n    ) OlympusAccessControlled(IOlympusAuthority(_authority)) {\r\n        require(_ohm != address(0), \"Zero address: OHM\");\r\n        OHM = IERC20(_ohm);\r\n        require(_sOHM != address(0), \"Zero address: sOHM\");\r\n        sOHM = IsOHM(_sOHM);\r\n        require(_gOHM != address(0), \"Zero address: gOHM\");\r\n        gOHM = IgOHM(_gOHM);\r\n\r\n        epoch = Epoch({length: _epochLength, number: _firstEpochNumber, end: _firstEpochTime, distribute: 0});\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice stake OHM to enter warmup\r\n     * @param _to address\r\n     * @param _amount uint\r\n     * @param _claim bool\r\n     * @param _rebasing bool\r\n     * @return uint\r\n     */\r\n    function stake(\r\n        address _to,\r\n        uint256 _amount,\r\n        bool _rebasing,\r\n        bool _claim\r\n    ) external returns (uint256) {\r\n        OHM.safeTransferFrom(msg.sender, address(this), _amount);\r\n        _amount = _amount.add(rebase()); // add bounty if rebase occurred\r\n        if (_claim && warmupPeriod == 0) {\r\n            return _send(_to, _amount, _rebasing);\r\n        } else {\r\n            Claim memory info = warmupInfo[_to];\r\n            if (!info.lock) {\r\n                require(_to == msg.sender, \"External deposits for account are locked\");\r\n            }\r\n\r\n            warmupInfo[_to] = Claim({\r\n                deposit: info.deposit.add(_amount),\r\n                gons: info.gons.add(sOHM.gonsForBalance(_amount)),\r\n                expiry: epoch.number.add(warmupPeriod),\r\n                lock: info.lock\r\n            });\r\n\r\n            gonsInWarmup = gonsInWarmup.add(sOHM.gonsForBalance(_amount));\r\n\r\n            return _amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice retrieve stake from warmup\r\n     * @param _to address\r\n     * @param _rebasing bool\r\n     * @return uint\r\n     */\r\n    function claim(address _to, bool _rebasing) public returns (uint256) {\r\n        Claim memory info = warmupInfo[_to];\r\n\r\n        if (!info.lock) {\r\n            require(_to == msg.sender, \"External claims for account are locked\");\r\n        }\r\n\r\n        if (epoch.number >= info.expiry && info.expiry != 0) {\r\n            delete warmupInfo[_to];\r\n\r\n            gonsInWarmup = gonsInWarmup.sub(info.gons);\r\n\r\n            return _send(_to, sOHM.balanceForGons(info.gons), _rebasing);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice forfeit stake and retrieve OHM\r\n     * @return uint\r\n     */\r\n    function forfeit() external returns (uint256) {\r\n        Claim memory info = warmupInfo[msg.sender];\r\n        delete warmupInfo[msg.sender];\r\n\r\n        gonsInWarmup = gonsInWarmup.sub(info.gons);\r\n\r\n        OHM.safeTransfer(msg.sender, info.deposit);\r\n\r\n        return info.deposit;\r\n    }\r\n\r\n    /**\r\n     * @notice prevent new deposits or claims from ext. address (protection from malicious activity)\r\n     */\r\n    function toggleLock() external {\r\n        warmupInfo[msg.sender].lock = !warmupInfo[msg.sender].lock;\r\n    }\r\n\r\n    /**\r\n     * @notice redeem sOHM for OHMs\r\n     * @param _to address\r\n     * @param _amount uint\r\n     * @param _trigger bool\r\n     * @param _rebasing bool\r\n     * @return amount_ uint\r\n     */\r\n    function unstake(\r\n        address _to,\r\n        uint256 _amount,\r\n        bool _trigger,\r\n        bool _rebasing\r\n    ) external returns (uint256 amount_) {\r\n        amount_ = _amount;\r\n        uint256 bounty;\r\n        if (_trigger) {\r\n            bounty = rebase();\r\n        }\r\n        if (_rebasing) {\r\n            sOHM.safeTransferFrom(msg.sender, address(this), _amount);\r\n            amount_ = amount_.add(bounty);\r\n        } else {\r\n            gOHM.burn(msg.sender, _amount); // amount was given in gOHM terms\r\n            amount_ = gOHM.balanceFrom(amount_).add(bounty); // convert amount to OHM terms & add bounty\r\n        }\r\n\r\n        require(amount_ <= OHM.balanceOf(address(this)), \"Insufficient OHM balance in contract\");\r\n        OHM.safeTransfer(_to, amount_);\r\n    }\r\n\r\n    /**\r\n     * @notice convert _amount sOHM into gBalance_ gOHM\r\n     * @param _to address\r\n     * @param _amount uint\r\n     * @return gBalance_ uint\r\n     */\r\n    function wrap(address _to, uint256 _amount) external returns (uint256 gBalance_) {\r\n        sOHM.safeTransferFrom(msg.sender, address(this), _amount);\r\n        gBalance_ = gOHM.balanceTo(_amount);\r\n        gOHM.mint(_to, gBalance_);\r\n    }\r\n\r\n    /**\r\n     * @notice convert _amount gOHM into sBalance_ sOHM\r\n     * @param _to address\r\n     * @param _amount uint\r\n     * @return sBalance_ uint\r\n     */\r\n    function unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_) {\r\n        gOHM.burn(msg.sender, _amount);\r\n        sBalance_ = gOHM.balanceFrom(_amount);\r\n        sOHM.safeTransfer(_to, sBalance_);\r\n    }\r\n\r\n    /**\r\n     * @notice trigger rebase if epoch over\r\n     * @return uint256\r\n     */\r\n    function rebase() public returns (uint256) {\r\n        uint256 bounty;\r\n        if (epoch.end <= block.timestamp) {\r\n            sOHM.rebase(epoch.distribute, epoch.number);\r\n\r\n            epoch.end = epoch.end.add(epoch.length);\r\n            epoch.number++;\r\n\r\n            if (address(distributor) != address(0)) {\r\n                distributor.distribute();\r\n                bounty = distributor.retrieveBounty(); // Will mint ohm for this contract if there exists a bounty\r\n            }\r\n            uint256 balance = OHM.balanceOf(address(this));\r\n            uint256 staked = sOHM.circulatingSupply();\r\n            if (balance <= staked.add(bounty)) {\r\n                epoch.distribute = 0;\r\n            } else {\r\n                epoch.distribute = balance.sub(staked).sub(bounty);\r\n            }\r\n        }\r\n        return bounty;\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice send staker their amount as sOHM or gOHM\r\n     * @param _to address\r\n     * @param _amount uint\r\n     * @param _rebasing bool\r\n     */\r\n    function _send(\r\n        address _to,\r\n        uint256 _amount,\r\n        bool _rebasing\r\n    ) internal returns (uint256) {\r\n        if (_rebasing) {\r\n            sOHM.safeTransfer(_to, _amount); // send as sOHM (equal unit as OHM)\r\n            return _amount;\r\n        } else {\r\n            gOHM.mint(_to, gOHM.balanceTo(_amount)); // send as gOHM (convert units from OHM)\r\n            return gOHM.balanceTo(_amount);\r\n        }\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice returns the sOHM index, which tracks rebase growth\r\n     * @return uint\r\n     */\r\n    function index() public view returns (uint256) {\r\n        return sOHM.index();\r\n    }\r\n\r\n    /**\r\n     * @notice total supply in warmup\r\n     */\r\n    function supplyInWarmup() public view returns (uint256) {\r\n        return sOHM.balanceForGons(gonsInWarmup);\r\n    }\r\n\r\n    /**\r\n     * @notice seconds until the next epoch begins\r\n     */\r\n    function secondsToNextEpoch() external view returns (uint256) {\r\n        return epoch.end.sub(block.timestamp);\r\n    }\r\n\r\n    /* ========== MANAGERIAL FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice sets the contract address for LP staking\r\n     * @param _distributor address\r\n     */\r\n    function setDistributor(address _distributor) external onlyGovernor {\r\n        distributor = IDistributor(_distributor);\r\n        emit DistributorSet(_distributor);\r\n    }\r\n\r\n    /**\r\n     * @notice set warmup period for new stakers\r\n     * @param _warmupPeriod uint\r\n     */\r\n    function setWarmupLength(uint256 _warmupPeriod) external onlyGovernor {\r\n        warmupPeriod = _warmupPeriod;\r\n        emit WarmupSet(_warmupPeriod);\r\n    }\r\n}"
    }
  }
}