{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Ownable.sol":{"content":"// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\n\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor(){\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n\n\n\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n"},"XIVDatabaseLib.sol":{"content":"// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\npragma abicoder v2;\n\nlibrary XIVDatabaseLib{\n    // deficoin struct for deficoinmappings..\n    struct DefiCoin{\n        uint16 oracleType;\n        string currencySymbol;\n        bool status;\n    }\n    struct TimePeriod{\n        uint256 _days;\n        bool status;\n    }\n     struct FlexibleInfo{\n        uint256 id;\n        uint16 upDownPercentage; //10**2\n        uint16 riskFactor;       //10**2\n        uint16 rewardFactor;     //10**2\n        bool status;\n    }\n    struct FixedInfo{\n        uint256 id;\n        uint256 daysCount;// integer value\n        uint16 upDownPercentage; //10**2\n        uint16 riskFactor;       //10**2\n        uint16 rewardFactor;     //10**2\n        bool status;\n    }\n    struct IndexCoin{\n        uint16 oracleType;\n        string currencySymbol;\n        address contractAddress;\n        bool status;\n        uint256 contributionPercentage; //10**2\n    }\n    struct BetPriceHistory{\n        uint256 baseIndexValue;\n        uint256 actualIndexValue;\n    }\n    struct LPLockedInfo{\n        uint256 lockedTimeStamp;\n        uint256 amountLocked;\n    }\n    struct StakingInfo{\n        uint256 investmentId;\n        uint256 stakeAmount;\n    }\n    struct IncentiveInfo{\n        uint256 tillInvestmentId;\n        uint256 incentiveAmount;\n        uint256 totalAmountStakedAtIncentiveTime;\n    }\n    struct BetInfo{\n        uint256 id;\n        uint256 principalAmount;\n        uint256 amount;\n        address userAddress;\n        address contractAddress;\n        uint256 betType; //\n        uint256 currentPrice;\n        uint256 timestamp;\n        uint256 betTimePeriod;\n        uint16 checkpointPercent;\n        uint16 rewardFactor;\n        uint16 riskFactor;\n        uint256 adminCommissionFee;\n        uint16 status; // 0->bet active, 1->bet won, 2->bet lost, 3-> withdraw before result\n    }\n}\n"},"XIVInterface.sol":{"content":"// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\npragma abicoder v2;\n\nimport \"./XIVDatabaseLib.sol\";\n\ninterface Token{\n    function decimals() external view returns(uint256);\n    function symbol() external view returns(string memory);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n}\n\n\ninterface OracleWrapper{\n    function getPrice(string calldata currencySymbol,uint256 oracleType) external view returns (uint256);\n}\ninterface DatabaseContract{\n    function transferTokens(address contractAddress,address userAddress,uint256 amount) external;\n    function transferFromTokens(address contractAddress,address fromAddress, address toAddress,uint256 amount) external;\n    function getTokensStaked(address userAddress) external view returns(uint256);\n    function updateTokensStaked(address userAddress, uint256 amount) external;\n    function getTokenStakedAmount() external view returns(uint256);\n    function updateTokenStakedAmount(uint256 _tokenStakedAmount) external;\n    function getBetId() external view returns(uint256);\n    function updateBetId(uint256 _userBetId) external;\n    function updateBetArray(XIVDatabaseLib.BetInfo memory bObject) external;\n    function getBetArray() external view returns(XIVDatabaseLib.BetInfo[] memory);\n    function getFindBetInArrayUsingBetIdMapping(uint256 _betid) external view returns(uint256);\n    function updateFindBetInArrayUsingBetIdMapping(uint256 _betid, uint256 value) external;\n    function updateUserStakedAddress(address _address) external;\n    function updateUserStakedAddress(address[] memory _userStakedAddress) external;\n    function getUserStakedAddress() external view returns(address[] memory);\n    function getDefiCoinsFixedMapping(address _betContractAddress,bool isFlashVault) external view returns(XIVDatabaseLib.DefiCoin memory);\n    function getDefiCoinsFlexibleMapping(address _betContractAddress) external view returns(XIVDatabaseLib.DefiCoin memory);\n    function getFlexibleDefiCoinArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\n    function getFlexibleIndexArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\n    function updateBetArrayIndex(XIVDatabaseLib.BetInfo memory bObject, uint256 index) external;\n    function updateBetIndexForFixedArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\n    function updateBetBaseIndexValue(uint256 _betBaseIndexValueFixed) external;\n    function getBetBaseIndexValue() external view returns(uint256);\n    function updateBetPriceHistoryFixedMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\n    function updateBetActualIndexValue(uint256 _betActualIndexValueFixed) external;\n    function getBetActualIndexValue() external view returns(uint256);\n    function getBetIndexForFixedArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\n    function getBetPriceHistoryFixedMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\n    function getXIVTokenContractAddress() external view returns(address);\n    function getAllIndexContractAddressArray() external view returns(address[] memory);\n    function getDefiCoinIndexMapping(address _ContractAddress) external view returns(XIVDatabaseLib.IndexCoin memory);\n    \n    function updateBetIndexForFlexibleArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\n    function getBetIndexForFlexibleArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\n    function updateBetPriceHistoryFlexibleMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\n    function getBetPriceHistoryFlexibleMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\n    \n    function getOracleWrapperContractAddress() external view returns(address);\n    function getPlentyOneDayPercentage() external view returns(uint256);\n    function getPlentyThreeDayPercentage(uint256 _days) external view returns(uint256);\n    function getPlentySevenDayPercentage(uint256 _days) external view returns(uint256);\n    function getBetsAccordingToUserAddress(address userAddress) external view returns(uint256[] memory);\n    function updateBetAddressesArray(address userAddress, uint256 _betId) external;\n    function getRewardGeneratedAmount() external view returns(uint256);\n    function updateRewardGeneratedAmount(uint256 _rewardGeneratedAmount) external;\n    function addUserAddressUsedForBetting(address userAddress) external;\n    function getUserAddressUsedForBetting() external view returns(address[] memory);\n    function getFixedDefiCoinArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\n    function getFixedDefiIndexArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\n    function getMaxStakeXIVAmount() external view returns(uint256);\n    function getMinStakeXIVAmount() external view returns(uint256);\n    function getBetFactorLP() external view returns(uint256);\n    function updateActualAmountStakedByUser(address userAddress, uint256 amount) external;\n    function getActualAmountStakedByUser(address userAddress) external view returns(uint256);\n    function isDaysAvailable(uint256 _days) external view returns(bool);\n    function updateExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress,bool status) external;\n    function getExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress) external view returns(bool);\n    function updateTotalTransactions(uint256 _totalTransactions) external;\n    function getTotalTransactions() external view returns(uint256);\n    function getFlexibleDefiCoinTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\n    function getFlexibleIndexTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\n    function getMinLPvalue() external view returns(uint256);\n    function getLockingPeriodForLPMapping(address userAddress) external view returns(XIVDatabaseLib.LPLockedInfo memory);\n    function updateLockingPeriodForLPMapping(address userAddress, uint256 _amountLocked, uint256 _lockedTimeStamp) external;\n    function getStakingInfoMapping(address userAddress) external view returns(XIVDatabaseLib.StakingInfo[] memory);\n    function updateStakingInfoMapping(address userAddress, XIVDatabaseLib.StakingInfo memory sInfo) external;\n    function getInvestmentId() external view returns(uint256);\n    function updateInvestmentId(uint256 _investmentId) external;\n    function getSlotExecutionId() external view returns(uint256);\n    function updateSlotExecutionId(uint256 _slotExecutionId) external;\n    function getSlotId() external view returns(uint256);\n    function updateSlotId(uint256 _slotId) external;\n    function updateIncentiveMapping(uint256 _slotId, XIVDatabaseLib.IncentiveInfo memory iInfo) external;\n    function getIncentiveMapping(uint256 _slotId) external view returns(XIVDatabaseLib.IncentiveInfo[] memory);\n    function emitBetDetails(uint256  betId, uint256  status, uint256  betEndTime) external;\n    function emitLPEvent(uint256 typeOfLP, address userAddress, uint256 amount, uint256 timestamp) external ;\n    function updateIsStakeMapping(address userAddress,bool isStake) external;\n    function getIsStakeMapping(address userAddress) external view returns(bool);\n    \n}\n"},"XIVMain.sol":{"content":"// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\npragma abicoder v2;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./XIVInterface.sol\";\n\n\ncontract XIVMain is Ownable{\n    \n    using SafeMath for uint256;\n    address[] tempArray;\n    \n    address public databaseContractAddress=0x18464e4584759A50CE9FC58eA5997F8B0D1EA1d8;\n    \n    XIVDatabaseLib.IndexCoin[] tempObjectArray;\n    \n    function stakeTokens(uint256 amount) external{\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        Token tokenObj = Token(dContract.getXIVTokenContractAddress());\n        require(amount>=dContract.getMinLPvalue(),\"Please enter more amount.\");\n        //check if user has balance\n        require(tokenObj.balanceOf(msg.sender) >= amount, \"You don't have enough XIV balance\");\n        //check if user has provided allowance\n        require(tokenObj.allowance(msg.sender,databaseContractAddress) >= amount, \n        \"Please allow smart contract to spend on your behalf\");\n        dContract.transferFromTokens(dContract.getXIVTokenContractAddress(),msg.sender,databaseContractAddress,amount);\n        \n        uint256 currentTimeStamp=block.timestamp;\n        XIVDatabaseLib.StakingInfo memory sInfo= XIVDatabaseLib.StakingInfo({\n            investmentId:dContract.getInvestmentId(),\n            stakeAmount:amount\n        });\n        dContract.updateStakingInfoMapping(msg.sender,sInfo);\n        dContract.updateInvestmentId(dContract.getInvestmentId().add(1));\n        if(!dContract.getIsStakeMapping(msg.sender)){\n            dContract.updateUserStakedAddress(msg.sender);\n            dContract.updateIsStakeMapping(msg.sender,true);\n        }\n        dContract.updateTokensStaked(msg.sender,dContract.getTokensStaked(msg.sender).add(amount));\n        dContract.updateActualAmountStakedByUser(msg.sender,dContract.getActualAmountStakedByUser(msg.sender).add(amount));\n        dContract.updateTokenStakedAmount(dContract.getTokenStakedAmount().add(amount));\n        dContract.updateTotalTransactions(dContract.getTotalTransactions().add(amount));\n        if(dContract.getLockingPeriodForLPMapping(msg.sender).lockedTimeStamp>currentTimeStamp){\n            dContract.updateLockingPeriodForLPMapping(msg.sender,(dContract.getLockingPeriodForLPMapping(msg.sender).amountLocked).add(amount),\n                                                        dContract.getLockingPeriodForLPMapping(msg.sender).lockedTimeStamp);\n        }else{\n            dContract.updateLockingPeriodForLPMapping(msg.sender,amount,currentTimeStamp.add(30 days));\n        }\n        dContract.emitLPEvent(0,msg.sender,amount,currentTimeStamp);\n    }\n     function unStakeTokens(uint256 amount) external{\n        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n        uint256 currentTimeStamp=block.timestamp;\n        if(dContract.getLockingPeriodForLPMapping(msg.sender).lockedTimeStamp>currentTimeStamp){\n            require(dContract.getTokensStaked(msg.sender).sub(dContract.getLockingPeriodForLPMapping(msg.sender).amountLocked) >= amount, \"You can not retrive LP token with this amount\");\n        }else{\n            require(dContract.getTokensStaked(msg.sender)>=amount, \"You can not retrive LP token with this amount\");\n        }\n        dContract.transferTokens(dContract.getXIVTokenContractAddress(),msg.sender,amount);\n        dContract.updateTokensStaked(msg.sender,dContract.getTokensStaked(msg.sender).sub(amount));\n        if(amount>dContract.getActualAmountStakedByUser(msg.sender)){\n            dContract.updateActualAmountStakedByUser(msg.sender,0);\n        }else{\n            dContract.updateActualAmountStakedByUser(msg.sender,dContract.getActualAmountStakedByUser(msg.sender).sub(amount));\n        }\n        dContract.updateTokenStakedAmount(dContract.getTokenStakedAmount().sub(amount));\n        dContract.emitLPEvent(1,msg.sender,amount,currentTimeStamp);\n    }\n    \n    function updateDatabaseAddress(address _databaseContractAddress) external onlyOwner{\n        databaseContractAddress=_databaseContractAddress;\n    }\n    \n}\n"}}}