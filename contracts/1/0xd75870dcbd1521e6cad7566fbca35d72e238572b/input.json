{"language":"Solidity","sources":{"contracts/modules/interest-rate-models/IRMClassMajor.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"../../BaseIRMLinearKink.sol\";\n\n\ncontract IRMClassMajor is BaseIRMLinearKink {\n    constructor(bytes32 moduleGitCommit_)\n        BaseIRMLinearKink(MODULEID__IRM_CLASS__MAJOR, moduleGitCommit_,\n            // Base=0% APY,  Kink(80%)=20% APY  Max=300% APY\n            0, 1681485479, 44415215206, 3435973836\n        ) {}\n}\n"},"contracts/BaseIRMLinearKink.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./BaseIRM.sol\";\n\n\ncontract BaseIRMLinearKink is BaseIRM {\n    uint public immutable baseRate;\n    uint public immutable slope1;\n    uint public immutable slope2;\n    uint public immutable kink;\n\n    constructor(uint moduleId_, bytes32 moduleGitCommit_, uint baseRate_, uint slope1_, uint slope2_, uint kink_) BaseIRM(moduleId_, moduleGitCommit_) {\n        baseRate = baseRate_;\n        slope1 = slope1_;\n        slope2 = slope2_;\n        kink = kink_;\n    }\n\n    function computeInterestRateImpl(address, uint32 utilisation) internal override view returns (int96) {\n        uint ir = baseRate;\n\n        if (utilisation <= kink) {\n            ir += utilisation * slope1;\n        } else {\n            ir += kink * slope1;\n            ir += slope2 * (utilisation - kink);\n        }\n\n        return int96(int(ir));\n    }\n}\n"},"contracts/BaseIRM.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./BaseModule.sol\";\n\nabstract contract BaseIRM is BaseModule {\n    constructor(uint moduleId_, bytes32 moduleGitCommit_) BaseModule(moduleId_, moduleGitCommit_) {}\n\n    int96 internal constant MAX_ALLOWED_INTEREST_RATE = int96(int(uint(5 * 1e27) / SECONDS_PER_YEAR)); // 500% APR\n    int96 internal constant MIN_ALLOWED_INTEREST_RATE = 0;\n\n    function computeInterestRateImpl(address, uint32) internal virtual returns (int96);\n\n    function computeInterestRate(address underlying, uint32 utilisation) external returns (int96) {\n        int96 rate = computeInterestRateImpl(underlying, utilisation);\n\n        if (rate > MAX_ALLOWED_INTEREST_RATE) rate = MAX_ALLOWED_INTEREST_RATE;\n        else if (rate < MIN_ALLOWED_INTEREST_RATE) rate = MIN_ALLOWED_INTEREST_RATE;\n\n        return rate;\n    }\n\n    function reset(address underlying, bytes calldata resetParams) external virtual {}\n}\n"},"contracts/BaseModule.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./Base.sol\";\n\n\nabstract contract BaseModule is Base {\n    // Construction\n\n    // public accessors common to all modules\n\n    uint immutable public moduleId;\n    bytes32 immutable public moduleGitCommit;\n\n    constructor(uint moduleId_, bytes32 moduleGitCommit_) {\n        moduleId = moduleId_;\n        moduleGitCommit = moduleGitCommit_;\n    }\n\n\n    // Accessing parameters\n\n    function unpackTrailingParamMsgSender() internal pure returns (address msgSender) {\n        assembly {\n            mstore(0, 0)\n\n            calldatacopy(12, sub(calldatasize(), 40), 20)\n            msgSender := mload(0)\n        }\n    }\n\n    function unpackTrailingParams() internal pure returns (address msgSender, address proxyAddr) {\n        assembly {\n            mstore(0, 0)\n\n            calldatacopy(12, sub(calldatasize(), 40), 20)\n            msgSender := mload(0)\n\n            calldatacopy(12, sub(calldatasize(), 20), 20)\n            proxyAddr := mload(0)\n        }\n    }\n\n\n    // Emit logs via proxies\n\n    function emitViaProxy_Transfer(address proxyAddr, address from, address to, uint value) internal FREEMEM {\n        (bool success,) = proxyAddr.call(abi.encodePacked(\n                               uint8(3),\n                               keccak256(bytes('Transfer(address,address,uint256)')),\n                               bytes32(uint(uint160(from))),\n                               bytes32(uint(uint160(to))),\n                               value\n                          ));\n        require(success, \"e/log-proxy-fail\");\n    }\n\n    function emitViaProxy_Approval(address proxyAddr, address owner, address spender, uint value) internal FREEMEM {\n        (bool success,) = proxyAddr.call(abi.encodePacked(\n                               uint8(3),\n                               keccak256(bytes('Approval(address,address,uint256)')),\n                               bytes32(uint(uint160(owner))),\n                               bytes32(uint(uint160(spender))),\n                               value\n                          ));\n        require(success, \"e/log-proxy-fail\");\n    }\n}\n"},"contracts/Base.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n//import \"hardhat/console.sol\"; // DEV_MODE\n\nimport \"./Storage.sol\";\nimport \"./Events.sol\";\nimport \"./Proxy.sol\";\n\nabstract contract Base is Storage, Events {\n    // Modules\n\n    function _createProxy(uint proxyModuleId) internal returns (address) {\n        require(proxyModuleId != 0, \"e/create-proxy/invalid-module\");\n        require(proxyModuleId <= MAX_EXTERNAL_MODULEID, \"e/create-proxy/internal-module\");\n\n        // If we've already created a proxy for a single-proxy module, just return it:\n\n        if (proxyLookup[proxyModuleId] != address(0)) return proxyLookup[proxyModuleId];\n\n        // Otherwise create a proxy:\n\n        address proxyAddr = address(new Proxy());\n\n        if (proxyModuleId <= MAX_EXTERNAL_SINGLE_PROXY_MODULEID) proxyLookup[proxyModuleId] = proxyAddr;\n\n        trustedSenders[proxyAddr] = TrustedSenderInfo({ moduleId: uint32(proxyModuleId), moduleImpl: address(0) });\n\n        emit ProxyCreated(proxyAddr, proxyModuleId);\n\n        return proxyAddr;\n    }\n\n    function callInternalModule(uint moduleId, bytes memory input) internal returns (bytes memory) {\n        (bool success, bytes memory result) = moduleLookup[moduleId].delegatecall(input);\n        if (!success) revertBytes(result);\n        return result;\n    }\n\n\n\n    // Modifiers\n\n    modifier nonReentrant() {\n        require(reentrancyLock == REENTRANCYLOCK__UNLOCKED, \"e/reentrancy\");\n\n        reentrancyLock = REENTRANCYLOCK__LOCKED;\n        _;\n        reentrancyLock = REENTRANCYLOCK__UNLOCKED;\n    }\n\n    modifier reentrantOK() { // documentation only\n        _;\n    }\n\n    // WARNING: Must be very careful with this modifier. It resets the free memory pointer\n    // to the value it was when the function started. This saves gas if more memory will\n    // be allocated in the future. However, if the memory will be later referenced\n    // (for example because the function has returned a pointer to it) then you cannot\n    // use this modifier.\n\n    modifier FREEMEM() {\n        uint origFreeMemPtr;\n\n        assembly {\n            origFreeMemPtr := mload(0x40)\n        }\n\n        _;\n\n        /*\n        assembly { // DEV_MODE: overwrite the freed memory with garbage to detect bugs\n            let garbage := 0xDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF\n            for { let i := origFreeMemPtr } lt(i, mload(0x40)) { i := add(i, 32) } { mstore(i, garbage) }\n        }\n        */\n\n        assembly {\n            mstore(0x40, origFreeMemPtr)\n        }\n    }\n\n\n\n    // Error handling\n\n    function revertBytes(bytes memory errMsg) internal pure {\n        if (errMsg.length > 0) {\n            assembly {\n                revert(add(32, errMsg), mload(errMsg))\n            }\n        }\n\n        revert(\"e/empty-error\");\n    }\n}\n"},"contracts/Storage.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./Constants.sol\";\n\nabstract contract Storage is Constants {\n    // Dispatcher and upgrades\n\n    uint reentrancyLock;\n\n    address upgradeAdmin;\n    address governorAdmin;\n\n    mapping(uint => address) moduleLookup; // moduleId => module implementation\n    mapping(uint => address) proxyLookup; // moduleId => proxy address (only for single-proxy modules)\n\n    struct TrustedSenderInfo {\n        uint32 moduleId; // 0 = un-trusted\n        address moduleImpl; // only non-zero for external single-proxy modules\n    }\n\n    mapping(address => TrustedSenderInfo) trustedSenders; // sender address => moduleId (0 = un-trusted)\n\n\n\n    // Account-level state\n    // Sub-accounts are considered distinct accounts\n\n    struct AccountStorage {\n        // Packed slot: 1 + 5 + 4 + 20 = 30\n        uint8 deferLiquidityStatus;\n        uint40 lastAverageLiquidityUpdate;\n        uint32 numMarketsEntered;\n        address firstMarketEntered;\n\n        uint averageLiquidity;\n        address averageLiquidityDelegate;\n    }\n\n    mapping(address => AccountStorage) accountLookup;\n    mapping(address => address[MAX_POSSIBLE_ENTERED_MARKETS]) marketsEntered;\n\n\n\n    // Markets and assets\n\n    struct AssetConfig {\n        // Packed slot: 20 + 1 + 4 + 4 + 3 = 32\n        address eTokenAddress;\n        bool borrowIsolated;\n        uint32 collateralFactor;\n        uint32 borrowFactor;\n        uint24 twapWindow;\n    }\n\n    struct UserAsset {\n        uint112 balance;\n        uint144 owed;\n\n        uint interestAccumulator;\n    }\n\n    struct AssetStorage {\n        // Packed slot: 5 + 1 + 4 + 12 + 4 + 2 + 4 = 32\n        uint40 lastInterestAccumulatorUpdate;\n        uint8 underlyingDecimals; // Not dynamic, but put here to live in same storage slot\n        uint32 interestRateModel;\n        int96 interestRate;\n        uint32 reserveFee;\n        uint16 pricingType;\n        uint32 pricingParameters;\n\n        address underlying;\n        uint96 reserveBalance;\n\n        address dTokenAddress;\n\n        uint112 totalBalances;\n        uint144 totalBorrows;\n\n        uint interestAccumulator;\n\n        mapping(address => UserAsset) users;\n\n        mapping(address => mapping(address => uint)) eTokenAllowance;\n        mapping(address => mapping(address => uint)) dTokenAllowance;\n    }\n\n    mapping(address => AssetConfig) internal underlyingLookup; // underlying => AssetConfig\n    mapping(address => AssetStorage) internal eTokenLookup; // EToken => AssetStorage\n    mapping(address => address) internal dTokenLookup; // DToken => EToken\n    mapping(address => address) internal pTokenLookup; // PToken => underlying\n    mapping(address => address) internal reversePTokenLookup; // underlying => PToken\n}\n"},"contracts/Events.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./Storage.sol\";\n\nabstract contract Events {\n    event Genesis();\n\n\n    event ProxyCreated(address indexed proxy, uint moduleId);\n    event MarketActivated(address indexed underlying, address indexed eToken, address indexed dToken);\n    event PTokenActivated(address indexed underlying, address indexed pToken);\n\n    event EnterMarket(address indexed underlying, address indexed account);\n    event ExitMarket(address indexed underlying, address indexed account);\n\n    event Deposit(address indexed underlying, address indexed account, uint amount);\n    event Withdraw(address indexed underlying, address indexed account, uint amount);\n    event Borrow(address indexed underlying, address indexed account, uint amount);\n    event Repay(address indexed underlying, address indexed account, uint amount);\n\n    event Liquidation(address indexed liquidator, address indexed violator, address indexed underlying, address collateral, uint repay, uint yield, uint healthScore, uint baseDiscount, uint discount);\n\n    event TrackAverageLiquidity(address indexed account);\n    event UnTrackAverageLiquidity(address indexed account);\n    event DelegateAverageLiquidity(address indexed account, address indexed delegate);\n\n    event PTokenWrap(address indexed underlying, address indexed account, uint amount);\n    event PTokenUnWrap(address indexed underlying, address indexed account, uint amount);\n\n    event AssetStatus(address indexed underlying, uint totalBalances, uint totalBorrows, uint96 reserveBalance, uint poolSize, uint interestAccumulator, int96 interestRate, uint timestamp);\n\n\n    event RequestDeposit(address indexed account, uint amount);\n    event RequestWithdraw(address indexed account, uint amount);\n    event RequestMint(address indexed account, uint amount);\n    event RequestBurn(address indexed account, uint amount);\n    event RequestTransferEToken(address indexed from, address indexed to, uint amount);\n\n    event RequestBorrow(address indexed account, uint amount);\n    event RequestRepay(address indexed account, uint amount);\n    event RequestTransferDToken(address indexed from, address indexed to, uint amount);\n\n    event RequestLiquidate(address indexed liquidator, address indexed violator, address indexed underlying, address collateral, uint repay, uint minYield);\n\n\n    event InstallerSetUpgradeAdmin(address indexed newUpgradeAdmin);\n    event InstallerSetGovernorAdmin(address indexed newGovernorAdmin);\n    event InstallerInstallModule(uint indexed moduleId, address indexed moduleImpl, bytes32 moduleGitCommit);\n\n\n    event GovSetAssetConfig(address indexed underlying, Storage.AssetConfig newConfig);\n    event GovSetIRM(address indexed underlying, uint interestRateModel, bytes resetParams);\n    event GovSetPricingConfig(address indexed underlying, uint16 newPricingType, uint32 newPricingParameter);\n    event GovSetReserveFee(address indexed underlying, uint32 newReserveFee);\n    event GovConvertReserves(address indexed underlying, address indexed recipient, uint amount);\n\n    event RequestSwap(address indexed accountIn, address indexed accountOut, address indexed underlyingIn, address underlyingOut, uint amount, uint swapType);\n}\n"},"contracts/Proxy.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\ncontract Proxy {\n    address immutable creator;\n\n    constructor() {\n        creator = msg.sender;\n    }\n\n    // External interface\n\n    fallback() external {\n        address creator_ = creator;\n\n        if (msg.sender == creator_) {\n            assembly {\n                mstore(0, 0)\n                calldatacopy(31, 0, calldatasize())\n\n                switch mload(0) // numTopics\n                    case 0 { log0(32,  sub(calldatasize(), 1)) }\n                    case 1 { log1(64,  sub(calldatasize(), 33),  mload(32)) }\n                    case 2 { log2(96,  sub(calldatasize(), 65),  mload(32), mload(64)) }\n                    case 3 { log3(128, sub(calldatasize(), 97),  mload(32), mload(64), mload(96)) }\n                    case 4 { log4(160, sub(calldatasize(), 129), mload(32), mload(64), mload(96), mload(128)) }\n                    default { revert(0, 0) }\n\n                return(0, 0)\n            }\n        } else {\n            assembly {\n                mstore(0, 0xe9c4a3ac00000000000000000000000000000000000000000000000000000000) // dispatch() selector\n                calldatacopy(4, 0, calldatasize())\n                mstore(add(4, calldatasize()), shl(96, caller()))\n\n                let result := call(gas(), creator_, 0, 0, add(24, calldatasize()), 0, 0)\n                returndatacopy(0, 0, returndatasize())\n\n                switch result\n                    case 0 { revert(0, returndatasize()) }\n                    default { return(0, returndatasize()) }\n            }\n        }\n    }\n}\n"},"contracts/Constants.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nabstract contract Constants {\n    // Universal\n\n    uint internal constant SECONDS_PER_YEAR = 365.2425 * 86400; // Gregorian calendar\n\n\n    // Protocol parameters\n\n    uint internal constant MAX_SANE_AMOUNT = type(uint112).max;\n    uint internal constant MAX_SANE_SMALL_AMOUNT = type(uint96).max;\n    uint internal constant MAX_SANE_DEBT_AMOUNT = type(uint144).max;\n    uint internal constant INTERNAL_DEBT_PRECISION = 1e9;\n    uint internal constant MAX_ENTERED_MARKETS = 10; // per sub-account\n    uint internal constant MAX_POSSIBLE_ENTERED_MARKETS = 2**32; // limited by size of AccountStorage.numMarketsEntered\n    uint internal constant CONFIG_FACTOR_SCALE = 4_000_000_000; // must fit into a uint32\n    uint internal constant RESERVE_FEE_SCALE = 4_000_000_000; // must fit into a uint32\n    uint32 internal constant DEFAULT_RESERVE_FEE = uint32(0.23 * 4_000_000_000);\n    uint internal constant INITIAL_INTEREST_ACCUMULATOR = 1e27;\n    uint internal constant AVERAGE_LIQUIDITY_PERIOD = 24 * 60 * 60;\n    uint16 internal constant MIN_UNISWAP3_OBSERVATION_CARDINALITY = 10;\n    uint24 internal constant DEFAULT_TWAP_WINDOW_SECONDS = 30 * 60;\n    uint32 internal constant DEFAULT_BORROW_FACTOR = uint32(0.28 * 4_000_000_000);\n\n\n    // Implementation internals\n\n    uint internal constant REENTRANCYLOCK__UNLOCKED = 1;\n    uint internal constant REENTRANCYLOCK__LOCKED = 2;\n\n    uint8 internal constant DEFERLIQUIDITY__NONE = 0;\n    uint8 internal constant DEFERLIQUIDITY__CLEAN = 1;\n    uint8 internal constant DEFERLIQUIDITY__DIRTY = 2;\n\n\n    // Pricing types\n\n    uint16 internal constant PRICINGTYPE__PEGGED = 1;\n    uint16 internal constant PRICINGTYPE__UNISWAP3_TWAP = 2;\n    uint16 internal constant PRICINGTYPE__FORWARDED = 3;\n\n\n    // Modules\n\n    // Public single-proxy modules\n    uint internal constant MODULEID__INSTALLER = 1;\n    uint internal constant MODULEID__MARKETS = 2;\n    uint internal constant MODULEID__LIQUIDATION = 3;\n    uint internal constant MODULEID__GOVERNANCE = 4;\n    uint internal constant MODULEID__EXEC = 5;\n    uint internal constant MODULEID__SWAP = 6;\n\n    uint internal constant MAX_EXTERNAL_SINGLE_PROXY_MODULEID = 499_999;\n\n    // Public multi-proxy modules\n    uint internal constant MODULEID__ETOKEN = 500_000;\n    uint internal constant MODULEID__DTOKEN = 500_001;\n\n    uint internal constant MAX_EXTERNAL_MODULEID = 999_999;\n\n    // Internal modules\n    uint internal constant MODULEID__RISK_MANAGER = 1_000_000;\n\n    // Interest rate models\n    //   Default for new markets\n    uint internal constant MODULEID__IRM_DEFAULT = 2_000_000;\n    //   Testing-only\n    uint internal constant MODULEID__IRM_ZERO = 2_000_001;\n    uint internal constant MODULEID__IRM_FIXED = 2_000_002;\n    uint internal constant MODULEID__IRM_LINEAR = 2_000_100;\n    //   Classes\n    uint internal constant MODULEID__IRM_CLASS__STABLE = 2_000_500;\n    uint internal constant MODULEID__IRM_CLASS__MAJOR = 2_000_501;\n    uint internal constant MODULEID__IRM_CLASS__MIDCAP = 2_000_502;\n\n    // Swap types\n    uint internal constant SWAP_TYPE__UNI_EXACT_INPUT_SINGLE = 1;\n    uint internal constant SWAP_TYPE__UNI_EXACT_INPUT = 2;\n    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT_SINGLE = 3;\n    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT = 4;\n    uint internal constant SWAP_TYPE__1INCH = 5;\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":1000000},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","abi"]}}}}